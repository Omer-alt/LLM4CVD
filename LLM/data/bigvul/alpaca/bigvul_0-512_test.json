[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tGetLengthMemory(const CSoundFile &sf)\n\t\t: sndFile(sf)\n\t\t, state(mpt::make_unique<CSoundFile::PlayState>(sf.m_PlayState))\n\t{\n\t\tReset();\n\t}\n",
        "output": "0",
        "index": 83306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::SetIsLoading(bool is_loading) {\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetWillSetIsLoading(is_loading);\n\n  is_loading_ = is_loading;\n  if (view_)\n    view_->SetIsLoading(is_loading);\n}\n",
        "output": "0",
        "index": 143710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int inflate()\n/* decompress an inflated entry */\n{\n  int e;                /* last block flag */\n  int r;                /* result code */\n  unsigned h;           /* maximum struct huft's malloc'ed */\n\n\n  /* initialize window, bit buffer */\n  wp = 0;\n  bk = 0;\n  bb = 0;\n\n\n  /* decompress until the last block */\n  h = 0;\n  do {\n    hufts = 0;\n    if ((r = inflate_block(&e)) != 0)\n      return r;\n    if (hufts > h)\n      h = hufts;\n  } while (!e);\n\n  /* Undo too much lookahead. The next read will be byte aligned so we\n   * can discard unused bits in the last meaningful byte.\n   */\n  while (bk >= 8) {\n    bk -= 8;\n    inptr--;\n  }\n\n  /* flush out slide */\n  flush_output(wp);\n\n\n  /* return success */\n  Trace ((stderr, \"<%u> \", h));\n  return 0;\n}\n",
        "output": "0",
        "index": 13507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ShareHandleToSelLdr(\n    base::ProcessHandle processh,\n    nacl::Handle sourceh,\n    bool close_source,\n    std::vector<nacl::FileDescriptor> *handles_for_sel_ldr) {\n#if defined(OS_WIN)\n  HANDLE channel;\n  int flags = DUPLICATE_SAME_ACCESS;\n  if (close_source)\n    flags |= DUPLICATE_CLOSE_SOURCE;\n  if (!DuplicateHandle(GetCurrentProcess(),\n                       reinterpret_cast<HANDLE>(sourceh),\n                       processh,\n                       &channel,\n                       0,  // Unused given DUPLICATE_SAME_ACCESS.\n                       FALSE,\n                       flags)) {\n    DLOG(ERROR) << \"DuplicateHandle() failed\";\n    return false;\n  }\n  handles_for_sel_ldr->push_back(\n      reinterpret_cast<nacl::FileDescriptor>(channel));\n#else\n  nacl::FileDescriptor channel;\n  channel.fd = sourceh;\n  channel.auto_close = close_source;\n  handles_for_sel_ldr->push_back(channel);\n#endif\n  return true;\n}\n",
        "output": "0",
        "index": 110227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_bufinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_bufinfo __user *arg, void *file)\n{\n\tstruct comedi_bufinfo bi;\n\tstruct comedi_subdevice *s;\n\tstruct comedi_async *async;\n\n\tif (copy_from_user(&bi, arg, sizeof(struct comedi_bufinfo)))\n\t\treturn -EFAULT;\n\n\tif (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)\n\t\treturn -EINVAL;\n\n\ts = dev->subdevices + bi.subdevice;\n\n\tif (s->lock && s->lock != file)\n\t\treturn -EACCES;\n\n\tasync = s->async;\n\n\tif (!async) {\n\t\tDPRINTK(\"subdevice does not have async capability\\n\");\n\t\tbi.buf_write_ptr = 0;\n\t\tbi.buf_read_ptr = 0;\n\t\tbi.buf_write_count = 0;\n\t\tbi.buf_read_count = 0;\n\t\tbi.bytes_read = 0;\n\t\tbi.bytes_written = 0;\n\t\tgoto copyback;\n\t}\n\tif (!s->busy) {\n\t\tbi.bytes_read = 0;\n\t\tbi.bytes_written = 0;\n\t\tgoto copyback_position;\n\t}\n\tif (s->busy != file)\n\t\treturn -EACCES;\n\n\tif (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {\n\t\tbi.bytes_read = comedi_buf_read_alloc(async, bi.bytes_read);\n\t\tcomedi_buf_read_free(async, bi.bytes_read);\n\n\t\tif (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR |\n\t\t\t\t\t\t\t  SRF_RUNNING))\n\t\t    && async->buf_write_count == async->buf_read_count) {\n\t\t\tdo_become_nonbusy(dev, s);\n\t\t}\n\t}\n\n\tif (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {\n\t\tbi.bytes_written =\n\t\t    comedi_buf_write_alloc(async, bi.bytes_written);\n\t\tcomedi_buf_write_free(async, bi.bytes_written);\n\t}\n\ncopyback_position:\n\tbi.buf_write_count = async->buf_write_count;\n\tbi.buf_write_ptr = async->buf_write_ptr;\n\tbi.buf_read_count = async->buf_read_count;\n\tbi.buf_read_ptr = async->buf_read_ptr;\n\ncopyback:\n\tif (copy_to_user(arg, &bi, sizeof(struct comedi_bufinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 41294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ahci_cond_start_engines(AHCIDevice *ad)\n{\n    AHCIPortRegs *pr = &ad->port_regs;\n    bool cmd_start = pr->cmd & PORT_CMD_START;\n    bool cmd_on    = pr->cmd & PORT_CMD_LIST_ON;\n    bool fis_start = pr->cmd & PORT_CMD_FIS_RX;\n    bool fis_on    = pr->cmd & PORT_CMD_FIS_ON;\n\n    if (cmd_start && !cmd_on) {\n        if (!ahci_map_clb_address(ad)) {\n            pr->cmd &= ~PORT_CMD_START;\n            error_report(\"AHCI: Failed to start DMA engine: \"\n                         \"bad command list buffer address\");\n            return -1;\n        }\n    } else if (!cmd_start && cmd_on) {\n        ahci_unmap_clb_address(ad);\n    }\n\n    if (fis_start && !fis_on) {\n        if (!ahci_map_fis_address(ad)) {\n            pr->cmd &= ~PORT_CMD_FIS_RX;\n            error_report(\"AHCI: Failed to start FIS receive engine: \"\n                         \"bad FIS receive buffer address\");\n            return -1;\n        }\n    } else if (!fis_start && fis_on) {\n        ahci_unmap_fis_address(ad);\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 5857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::PlatformFile PlatformFileFromPlatformHandleValue(uint64_t value) {\n#if defined(OS_WIN)\n  return reinterpret_cast<base::PlatformFile>(value);\n#else\n  return static_cast<base::PlatformFile>(value);\n#endif\n}\n",
        "output": "0",
        "index": 162435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ldb_dn *ldb_dn_new(TALLOC_CTX *mem_ctx,\n\t\t\t  struct ldb_context *ldb,\n\t\t\t  const char *strdn)\n{\n\tstruct ldb_val blob;\n\tblob.data = discard_const_p(uint8_t, strdn);\n\tblob.length = strdn ? strlen(strdn) : 0;\n\treturn ldb_dn_from_ldb_val(mem_ctx, ldb, &blob);\n}\n",
        "output": "0",
        "index": 2290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void Delete(base::ConditionVariable* instance) {\n    instance->~ConditionVariable();\n  }\n",
        "output": "0",
        "index": 129764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void WaitForFocus(bool target_state_is_focused) {\n    if (focused_ == target_state_is_focused)\n      return;\n    target_state_is_focused_ = target_state_is_focused;\n    run_loop_.Run();\n  }\n",
        "output": "0",
        "index": 150744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void UsbTransferFunction::OnCompleted(UsbTransferStatus status,\n                                      scoped_refptr<net::IOBuffer> data,\n                                      size_t length) {\n  scoped_ptr<base::DictionaryValue> transfer_info(new base::DictionaryValue());\n  transfer_info->SetInteger(kResultCodeKey, status);\n  transfer_info->Set(kDataKey, base::BinaryValue::CreateWithCopiedBuffer(\n                                   data->data(), length));\n\n  if (status == device::USB_TRANSFER_COMPLETED) {\n    Respond(OneArgument(transfer_info.release()));\n  } else {\n    scoped_ptr<base::ListValue> error_args(new base::ListValue());\n    error_args->Append(transfer_info.release());\n    Respond(ErrorWithArguments(error_args.Pass(),\n                               ConvertTransferStatusToApi(status)));\n  }\n}\n",
        "output": "0",
        "index": 132464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPage::setEnableLocalAccessToAllCookies(bool enabled)\n{\n    cookieManager().setCanLocalAccessAllCookies(enabled);\n}\n",
        "output": "0",
        "index": 111347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tswitch (cmd) {\n\tcase SIOCGSTAMP:\n\t\treturn sock_get_timestamp(sk, (struct timeval __user *)arg);\n\n\tcase SIOCGSTAMPNS:\n\t\treturn sock_get_timestampns(sk, (struct timespec __user *)arg);\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\n\t\treturn ipv6_route_ioctl(net, cmd, (void __user *)arg);\n\n\tcase SIOCSIFADDR:\n\t\treturn addrconf_add_ifaddr(net, (void __user *) arg);\n\tcase SIOCDIFADDR:\n\t\treturn addrconf_del_ifaddr(net, (void __user *) arg);\n\tcase SIOCSIFDSTADDR:\n\t\treturn addrconf_set_dstaddr(net, (void __user *) arg);\n\tdefault:\n\t\tif (!sk->sk_prot->ioctl)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn sk->sk_prot->ioctl(sk, cmd, arg);\n\t}\n\t/*NOTREACHED*/\n\treturn 0;\n}\n",
        "output": "0",
        "index": 41559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void insert_to_mm_slots_hash(struct mm_struct *mm,\n\t\t\t\t    struct mm_slot *mm_slot)\n{\n\tstruct hlist_head *bucket;\n\n\tbucket = &mm_slots_hash[((unsigned long)mm / sizeof(struct mm_struct))\n\t\t\t\t% MM_SLOTS_HASH_HEADS];\n\tmm_slot->mm = mm;\n\thlist_add_head(&mm_slot->hash, bucket);\n}\n",
        "output": "0",
        "index": 35103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}\n",
        "output": "0",
        "index": 90850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t/* Free the datagram. */\n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n",
        "output": "1",
        "index": 179660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ModuleExport size_t RegisterPDFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PDF\",\"AI\",\"Adobe Illustrator CS2\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"EPDF\",\n    \"Encapsulated Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDF\",\"Portable Document Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PDF\",\"PDFA\",\"Portable Document Archive Format\");\n  entry->decoder=(DecodeImageHandler *) ReadPDFImage;\n  entry->encoder=(EncodeImageHandler *) WritePDFImage;\n  entry->magick=(IsImageFormatHandler *) IsPDF;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/pdf\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "output": "0",
        "index": 91344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LocalFrameClientImpl::UpdateDocumentLoader(\n    DocumentLoader* document_loader,\n    std::unique_ptr<WebDocumentLoader::ExtraData> extra_data) {\n  static_cast<WebDocumentLoaderImpl*>(document_loader)\n      ->SetExtraData(std::move(extra_data));\n}\n",
        "output": "0",
        "index": 158132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rdp_init_data(int maxlen)\n{\n\tSTREAM s;\n\n\ts = sec_init(g_encryption ? SEC_ENCRYPT : 0, maxlen + 18);\n\ts_push_layer(s, rdp_hdr, 18);\n\n\treturn s;\n}\n",
        "output": "0",
        "index": 93003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cac_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_find_and_initialize(card, 1);\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_INVALID_CARD);\n\t}\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tcard->caps |= SC_CARD_CAP_RNG | SC_CARD_CAP_ISO7816_PIN_INFO;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n}\n",
        "output": "0",
        "index": 78240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_release(struct fuse* fuse, struct fuse_handler* handler,\n const struct fuse_in_header* hdr, const struct fuse_release_in* req)\n{\n struct handle *h = id_to_ptr(req->fh);\n\n    TRACE(\"[%d] RELEASE %p(%d)\\n\", handler->token, h, h->fd);\n    close(h->fd);\n    free(h);\n return 0;\n}\n",
        "output": "0",
        "index": 173749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u16 dev_cap_txqueue(struct net_device *dev, u16 queue_index)\n{\n\tif (unlikely(queue_index >= dev->real_num_tx_queues)) {\n\t\tif (net_ratelimit()) {\n\t\t\tpr_warning(\"%s selects TX queue %d, but \"\n\t\t\t\t\"real number of TX queues is %d\\n\",\n\t\t\t\tdev->name, queue_index, dev->real_num_tx_queues);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn queue_index;\n}\n",
        "output": "0",
        "index": 35240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2Implementation::GetIntegeri_vHelper(GLenum pname,\n                                              GLuint index,\n                                              GLint* data) {\n  return false;\n}\n",
        "output": "0",
        "index": 153691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline size_t write_octet_sequence(unsigned char *buf, enum entity_charset charset, unsigned code) {\n\t/* code is not necessarily a unicode code point */\n\tswitch (charset) {\n\tcase cs_utf_8:\n\t\treturn php_utf32_utf8(buf, code);\n\n\tcase cs_8859_1:\n\tcase cs_cp1252:\n\tcase cs_8859_15:\n\tcase cs_koi8r:\n\tcase cs_cp1251:\n\tcase cs_8859_5:\n\tcase cs_cp866:\n\tcase cs_macroman:\n\t\t/* single byte stuff */\n\t\t*buf = code;\n\t\treturn 1;\n\n\tcase cs_big5:\n\tcase cs_big5hkscs:\n\tcase cs_sjis:\n\tcase cs_gb2312:\n\t\t/* we don't have complete unicode mappings for these yet in entity_decode,\n\t\t * and we opt to pass through the octet sequences for these in htmlentities\n\t\t * instead of converting to an int and then converting back. */\n#if 0\n\t\treturn php_mb2_int_to_char(buf, code);\n#else\n#ifdef ZEND_DEBUG\n\t\tassert(code <= 0xFFU);\n#endif\n\t\t*buf = code;\n\t\treturn 1;\n#endif\n\n\tcase cs_eucjp:\n#if 0 /* idem */\n\t\treturn php_mb2_int_to_char(buf, code);\n#else\n#ifdef ZEND_DEBUG\n\t\tassert(code <= 0xFFU);\n#endif\n\t\t*buf = code;\n\t\treturn 1;\n#endif\n\n\tdefault:\n\t\tassert(0);\n\t\treturn 0;\n\t}\n}\n",
        "output": "0",
        "index": 52212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NavigationControllerImpl::SetPendingEntry(\n    std::unique_ptr<NavigationEntryImpl> entry) {\n  DiscardNonCommittedEntriesInternal();\n  pending_entry_ = entry.release();\n  DCHECK_EQ(-1, pending_entry_index_);\n  NotificationService::current()->Notify(\n      NOTIFICATION_NAV_ENTRY_PENDING,\n      Source<NavigationController>(this),\n      Details<NavigationEntry>(pending_entry_));\n}\n",
        "output": "0",
        "index": 163211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Shell::OnMaximizeModeEnded() {\n  FOR_EACH_OBSERVER(ShellObserver, observers_, OnMaximizeModeEnded());\n}\n",
        "output": "0",
        "index": 139840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int md_revalidate(struct gendisk *disk)\n{\n\tstruct mddev *mddev = disk->private_data;\n\n\tmddev->changed = 0;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 42459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutUnit PaintLayerScrollableArea::ScrollHeight() const {\n  return overflow_rect_.Height();\n}\n",
        "output": "0",
        "index": 141480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChildProcessSecurityPolicy::GrantRequestURL(\n    int renderer_id, const GURL& url) {\n\n  if (!url.is_valid())\n    return;  // Can't grant the capability to request invalid URLs.\n\n  if (IsWebSafeScheme(url.scheme()))\n    return;  // The scheme has already been white-listed for every renderer.\n\n  if (IsPseudoScheme(url.scheme())) {\n    if (url.SchemeIs(chrome::kViewSourceScheme) ||\n        url.SchemeIs(chrome::kPrintScheme)) {\n      GrantRequestURL(renderer_id, GURL(url.path()));\n    }\n\n    return;  // Can't grant the capability to request pseudo schemes.\n  }\n\n  {\n    AutoLock lock(lock_);\n    SecurityStateMap::iterator state = security_state_.find(renderer_id);\n    if (state == security_state_.end())\n      return;\n\n    state->second->GrantScheme(url.scheme());\n  }\n}\n",
        "output": "0",
        "index": 100531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static zend_always_inline int zend_mm_bitset_find_zero(zend_mm_bitset *bitset, int size)\n{\n\tint i = 0;\n\n\tdo {\n\t\tzend_mm_bitset tmp = bitset[i];\n\t\tif (tmp != (zend_mm_bitset)-1) {\n\t\t\treturn i * ZEND_MM_BITSET_LEN + zend_mm_bitset_nts(tmp);\n\t\t}\n\t\ti++;\n\t} while (i < size);\n\treturn -1;\n}\n",
        "output": "0",
        "index": 50184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}\n",
        "output": "0",
        "index": 94955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pmcraid_resume(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\tstruct Scsi_Host *host = pinstance->host;\n\tint rc;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\trc = pci_enable_device(pdev);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"resume: Enable device failed\\n\");\n\t\treturn rc;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif ((sizeof(dma_addr_t) == 4) ||\n\t     pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\n\t\trc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc == 0)\n\t\trc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\n\n\tif (rc != 0) {\n\t\tdev_err(&pdev->dev, \"resume: Failed to set PCI DMA mask\\n\");\n\t\tgoto disable_device;\n\t}\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tatomic_set(&pinstance->outstanding_cmds, 0);\n\trc = pmcraid_register_interrupt_handler(pinstance);\n\n\tif (rc) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"resume: couldn't register interrupt handlers\\n\");\n\t\trc = -ENODEV;\n\t\tgoto release_host;\n\t}\n\n\tpmcraid_init_tasklets(pinstance);\n\tpmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\n\n\t/* Start with hard reset sequence which brings up IOA to operational\n\t * state as well as completes the reset sequence.\n\t */\n\tpinstance->ioa_hard_reset = 1;\n\n\t/* Start IOA firmware initialization and bring card to Operational\n\t * state.\n\t */\n\tif (pmcraid_reset_bringup(pinstance)) {\n\t\tdev_err(&pdev->dev, \"couldn't initialize IOA\\n\");\n\t\trc = -ENODEV;\n\t\tgoto release_tasklets;\n\t}\n\n\treturn 0;\n\nrelease_tasklets:\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\nrelease_host:\n\tscsi_host_put(host);\n\ndisable_device:\n\tpci_disable_device(pdev);\n\n\treturn rc;\n}\n",
        "output": "0",
        "index": 26510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bio_map_kern_endio(struct bio *bio)\n{\n\tbio_put(bio);\n}\n",
        "output": "0",
        "index": 62836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct md_rdev *find_rdev(struct mddev *mddev, dev_t dev)\n{\n\tstruct md_rdev *rdev;\n\n\trdev_for_each(rdev, mddev)\n\t\tif (rdev->bdev->bd_dev == dev)\n\t\t\treturn rdev;\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 42390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mime_db_changed_callback (GObject           *ignore,\n                          NautilusDirectory *dir)\n{\n    NautilusFileAttributes attrs;\n\n    g_assert (dir != NULL);\n    g_assert (dir->details != NULL);\n\n    attrs = NAUTILUS_FILE_ATTRIBUTE_INFO |\n            NAUTILUS_FILE_ATTRIBUTE_LINK_INFO |\n            NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES;\n\n    nautilus_directory_force_reload_internal (dir, attrs);\n}\n",
        "output": "0",
        "index": 60941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_icctxt_output(jas_iccattrval_t *attrval, jas_stream_t *out)\n{\n\tjas_icctxt_t *txt = &attrval->data.txt;\n\tif (jas_stream_puts(out, txt->string) ||\n\t  jas_stream_putc(out, 0) == EOF)\n\t\treturn -1;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 72738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AirPDcapRecurseCleanSA(\n    PAIRPDCAP_SEC_ASSOCIATION sa)\n{\n    if (sa->next != NULL) {\n        AirPDcapRecurseCleanSA(sa->next);\n        g_free(sa->next);\n        sa->next = NULL;\n    }\n}\n",
        "output": "0",
        "index": 51906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PHP_MSHUTDOWN_FUNCTION(xmlwriter)\n{\n\treturn SUCCESS;\n}\n",
        "output": "0",
        "index": 15331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *xmlrpc_boolean(char *buf, int value)\n{\n\t*buf = '\\0';\n\tsnprintf(buf, XMLRPC_BUFSIZE, \"<boolean>%d</boolean>\", (value ? 1 : 0));\n\treturn buf;\n}\n",
        "output": "0",
        "index": 53272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayer::attachNewPlayer(const sp<IMediaPlayer>& player)\n{\n status_t err = UNKNOWN_ERROR;\n    sp<IMediaPlayer> p;\n { // scope for the lock\n Mutex::Autolock _l(mLock);\n\n if ( !( (mCurrentState & MEDIA_PLAYER_IDLE) ||\n (mCurrentState == MEDIA_PLAYER_STATE_ERROR ) ) ) {\n            ALOGE(\"attachNewPlayer called in state %d\", mCurrentState);\n return INVALID_OPERATION;\n }\n\n        clear_l();\n        p = mPlayer;\n        mPlayer = player;\n if (player != 0) {\n            mCurrentState = MEDIA_PLAYER_INITIALIZED;\n            err = NO_ERROR;\n } else {\n            ALOGE(\"Unable to create media player\");\n }\n }\n\n if (p != 0) {\n        p->disconnect();\n }\n\n return err;\n}\n",
        "output": "0",
        "index": 172650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcGetScreenSaver(ClientPtr client)\n{\n    xGetScreenSaverReply rep;\n    int rc, i;\n\n    REQUEST_SIZE_MATCH(xReq);\n\n    for (i = 0; i < screenInfo.numScreens; i++) {\n        rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],\n                      DixGetAttrAccess);\n        if (rc != Success)\n            return rc;\n    }\n\n    rep = (xGetScreenSaverReply) {\n        .type = X_Reply,\n        .sequenceNumber = client->sequence,\n        .length = 0,\n        .timeout = ScreenSaverTime / MILLI_PER_SECOND,\n        .interval = ScreenSaverInterval / MILLI_PER_SECOND,\n        .preferBlanking = ScreenSaverBlanking,\n        .allowExposures = ScreenSaverAllowExposures\n    };\n    WriteReplyToClient(client, sizeof(xGetScreenSaverReply), &rep);\n    return Success;\n}\n",
        "output": "0",
        "index": 14981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::ThreadedParsingEnabledForTesting() {\n  return g_threaded_parsing_enabled_for_testing;\n}\n",
        "output": "0",
        "index": 141266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DataReductionProxyConfig::FetchWarmupProbeURL() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  if (!enabled_by_user_) {\n    RecordWarmupURLFetchAttemptEvent(\n        WarmupURLFetchAttemptEvent::kProxyNotEnabledByUser);\n    return;\n  }\n\n  if (!params::FetchWarmupProbeURLEnabled()) {\n    RecordWarmupURLFetchAttemptEvent(\n        WarmupURLFetchAttemptEvent::kWarmupURLFetchingDisabled);\n    return;\n  }\n\n  if (connection_type_ == network::mojom::ConnectionType::CONNECTION_NONE) {\n    RecordWarmupURLFetchAttemptEvent(\n        WarmupURLFetchAttemptEvent::kConnectionTypeNone);\n    return;\n  }\n\n  base::Optional<DataReductionProxyServer> warmup_proxy =\n      GetProxyConnectionToProbe();\n\n  if (!warmup_proxy)\n    return;\n\n  warmup_url_fetch_in_flight_secure_proxy_ = warmup_proxy->IsSecureProxy();\n  warmup_url_fetch_in_flight_core_proxy_ = warmup_proxy->IsCoreProxy();\n\n  size_t previous_attempt_counts = GetWarmupURLFetchAttemptCounts();\n\n  network_properties_manager_->OnWarmupFetchInitiated(\n      warmup_url_fetch_in_flight_secure_proxy_,\n      warmup_url_fetch_in_flight_core_proxy_);\n\n  RecordWarmupURLFetchAttemptEvent(WarmupURLFetchAttemptEvent::kFetchInitiated);\n\n  warmup_url_fetcher_->FetchWarmupURL(previous_attempt_counts,\n                                      warmup_proxy.value());\n}\n",
        "output": "0",
        "index": 157518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WallpaperManager::UpdateWallpaper(bool clear_cache) {\n  if (last_selected_user_.empty())\n    SetDefaultWallpaperNow(user_manager::SignInAccountId());\n  WallpaperManagerBase::UpdateWallpaper(clear_cache);\n}\n",
        "output": "0",
        "index": 138924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SoftVorbis::onPortEnableCompleted(OMX_U32 portIndex, bool enabled) {\n if (portIndex != 1) {\n return;\n }\n\n switch (mOutputPortSettingsChange) {\n case NONE:\n break;\n\n case AWAITING_DISABLED:\n {\n            CHECK(!enabled);\n            mOutputPortSettingsChange = AWAITING_ENABLED;\n break;\n }\n\n default:\n {\n            CHECK_EQ((int)mOutputPortSettingsChange, (int)AWAITING_ENABLED);\n            CHECK(enabled);\n            mOutputPortSettingsChange = NONE;\n break;\n }\n }\n}\n",
        "output": "0",
        "index": 173798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGLRenderingContextBase::ExtensionTracker::MatchesNameWithPrefixes(\n    const String& name) const {\n  const char* const* prefix_set = Prefixes();\n  for (; *prefix_set; ++prefix_set) {\n    String prefixed_name = String(*prefix_set) + ExtensionName();\n    if (DeprecatedEqualIgnoringCase(prefixed_name, name)) {\n      return true;\n    }\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 146332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u8* h264bsdAllocateDpbImage(dpbStorage_t *dpb)\n{\n\n/* Variables */\n\n/* Code */\n\n    ASSERT( !dpb->buffer[dpb->dpbSize].toBeDisplayed &&\n !IS_REFERENCE(dpb->buffer[dpb->dpbSize]) );\n    ASSERT(dpb->fullness <=  dpb->dpbSize);\n\n    dpb->currentOut = dpb->buffer + dpb->dpbSize;\n\n return(dpb->currentOut->data);\n\n}\n",
        "output": "0",
        "index": 172753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reclaim_consumed_buffers(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (!port->portdev) {\n\t\t/* Device has been unplugged.  vqs are already gone. */\n\t\treturn;\n\t}\n\twhile ((buf = virtqueue_get_buf(port->out_vq, &len))) {\n\t\tfree_buf(buf, false);\n\t\tport->outvq_full = false;\n\t}\n}\n",
        "output": "0",
        "index": 66611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBox::paintBoxDecorations(PaintInfo& paintInfo, const LayoutPoint& paintOffset)\n{\n    if (!paintInfo.shouldPaintWithinRoot(this))\n        return;\n\n    LayoutRect paintRect = borderBoxRect();\n    paintRect.moveBy(paintOffset);\n    paintBoxDecorationsWithRect(paintInfo, paintOffset, paintRect);\n}\n",
        "output": "0",
        "index": 124915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderBlock::checkPaginationAndFloatsAtEndLine(LineLayoutState& layoutState)\n{\n    LayoutUnit lineDelta = logicalHeight() - layoutState.endLineLogicalTop();\n\n    bool paginated = view()->layoutState() && view()->layoutState()->isPaginated();\n    if (paginated && layoutState.flowThread()) {\n        for (RootInlineBox* lineBox = layoutState.endLine(); lineBox; lineBox = lineBox->nextRootBox()) {\n            if (paginated) {\n                LayoutUnit oldPaginationStrut = lineBox->paginationStrut();\n                lineDelta -= oldPaginationStrut;\n                adjustLinePositionForPagination(lineBox, lineDelta, layoutState.flowThread());\n                lineBox->setPaginationStrut(oldPaginationStrut);\n            }\n            if (lineWidthForPaginatedLineChanged(lineBox, lineDelta, layoutState.flowThread()))\n                return false;\n        }\n    }\n\n    if (!lineDelta || !m_floatingObjects)\n        return true;\n\n    LayoutUnit logicalTop = min(logicalHeight(), layoutState.endLineLogicalTop());\n\n    RootInlineBox* lastLine = layoutState.endLine();\n    while (RootInlineBox* nextLine = lastLine->nextRootBox())\n        lastLine = nextLine;\n\n    LayoutUnit logicalBottom = lastLine->lineBottomWithLeading() + absoluteValue(lineDelta);\n\n    const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n    FloatingObjectSetIterator end = floatingObjectSet.end();\n    for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {\n        FloatingObject* f = *it;\n        if (f->logicalBottom(isHorizontalWritingMode()) >= logicalTop && f->logicalBottom(isHorizontalWritingMode()) < logicalBottom)\n            return false;\n    }\n\n    return true;\n}\n",
        "output": "0",
        "index": 119576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  FlakyRegressionTestData(const char* filename)\n      : filename(filename) {\n  }\n",
        "output": "0",
        "index": 114783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *Type_Signature_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsSignature* SigPtr = (cmsSignature*) _cmsMalloc(self ->ContextID, sizeof(cmsSignature));\n    if (SigPtr == NULL) return NULL;\n\n     if (!_cmsReadUInt32Number(io, SigPtr)) return NULL;\n     *nItems = 1;\n\n     return SigPtr;\n\n     cmsUNUSED_PARAMETER(SizeOfTag);\n}\n",
        "output": "0",
        "index": 71054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "process_config_files(const char *host_arg, struct passwd *pw, int post_canon)\n{\n\tchar buf[PATH_MAX];\n\tint r;\n\n\tif (config != NULL) {\n\t\tif (strcasecmp(config, \"none\") != 0 &&\n\t\t    !read_config_file(config, pw, host, host_arg, &options,\n\t\t    SSHCONF_USERCONF | (post_canon ? SSHCONF_POSTCANON : 0)))\n\t\t\tfatal(\"Can't open user config file %.100s: \"\n\t\t\t    \"%.100s\", config, strerror(errno));\n\t} else {\n\t\tr = snprintf(buf, sizeof buf, \"%s/%s\", pw->pw_dir,\n\t\t    _PATH_SSH_USER_CONFFILE);\n\t\tif (r > 0 && (size_t)r < sizeof(buf))\n\t\t\t(void)read_config_file(buf, pw, host, host_arg,\n\t\t\t    &options, SSHCONF_CHECKPERM | SSHCONF_USERCONF |\n\t\t\t    (post_canon ? SSHCONF_POSTCANON : 0));\n\n\t\t/* Read systemwide configuration file after user config. */\n\t\t(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,\n\t\t    host, host_arg, &options,\n\t\t    post_canon ? SSHCONF_POSTCANON : 0);\n\t}\n}\n",
        "output": "0",
        "index": 15565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_archive_filter_code(struct archive *_a, int n)\n{\n\tstruct archive_read_filter *f = get_filter(_a, n);\n\treturn f == NULL ? -1 : f->code;\n}\n",
        "output": "0",
        "index": 50003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ghash_setkey(struct crypto_shash *tfm,\n\t\t\tconst u8 *key, unsigned int keylen)\n{\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(tfm);\n\n\tif (keylen != GHASH_BLOCK_SIZE) {\n\t\tcrypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ctx->key, key, GHASH_BLOCK_SIZE);\n\tmemset(ctx->icv, 0, GHASH_BLOCK_SIZE);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 46709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PrintingContext::Result PrintingContext::ParseDialogResult(\n    const PRINTDLG& dialog_options) {\n  ResetSettings();\n\n  DEVMODE* dev_mode = NULL;\n  if (dialog_options.hDevMode) {\n    dev_mode =\n        reinterpret_cast<DEVMODE*>(GlobalLock(dialog_options.hDevMode));\n    DCHECK(dev_mode);\n  }\n\n  std::wstring device_name;\n  if (dialog_options.hDevNames) {\n    DEVNAMES* dev_names =\n        reinterpret_cast<DEVNAMES*>(GlobalLock(dialog_options.hDevNames));\n    DCHECK(dev_names);\n    if (dev_names) {\n      device_name =\n          reinterpret_cast<const wchar_t*>(\n              reinterpret_cast<const wchar_t*>(dev_names) +\n                  dev_names->wDeviceOffset);\n      GlobalUnlock(dialog_options.hDevNames);\n    }\n  }\n\n  bool success = false;\n  if (dev_mode && !device_name.empty()) {\n    context_ = dialog_options.hDC;\n    success = InitializeSettings(*dev_mode, device_name, NULL, 0, false);\n  }\n\n  if (!success && dialog_options.hDC) {\n    DeleteDC(dialog_options.hDC);\n    context_ = NULL;\n  }\n\n  if (dev_mode) {\n    GlobalUnlock(dialog_options.hDevMode);\n  }\n\n  if (dialog_options.hDevMode != NULL)\n    GlobalFree(dialog_options.hDevMode);\n  if (dialog_options.hDevNames != NULL)\n    GlobalFree(dialog_options.hDevNames);\n\n  return context_ ? OK : FAILED;\n}\n",
        "output": "0",
        "index": 99383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,\n        OMX_IN OMX_BUFFERHEADERTYPE* buffer)\n{\n    OMX_ERRORTYPE ret1 = OMX_ErrorNone;\n\n     unsigned int nBufferIndex ;\n \n     DEBUG_PRINT_LOW(\"ETB: buffer = %p, buffer->pBuffer[%p]\", buffer, buffer->pBuffer);\n    if (m_state == OMX_StateInvalid) {\n         DEBUG_PRINT_ERROR(\"ERROR: Empty this buffer in Invalid State\");\n         return OMX_ErrorInvalidState;\n     }\n\n if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_video::etb--> buffer is null or buffer size is invalid\");\n return OMX_ErrorBadParameter;\n }\n\n if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_video::etb--> OMX Version Invalid\");\n return OMX_ErrorVersionMismatch;\n }\n\n if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {\n        DEBUG_PRINT_ERROR(\"ERROR: Bad port index to call empty_this_buffer\");\n return OMX_ErrorBadPortIndex;\n }\n if (!m_sInPortDef.bEnabled) {\n        DEBUG_PRINT_ERROR(\"ERROR: Cannot call empty_this_buffer while I/P port is disabled\");\n return OMX_ErrorIncorrectStateOperation;\n }\n\n    nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);\n\n if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {\n        DEBUG_PRINT_ERROR(\"ERROR: ETB: Invalid buffer index[%d]\", nBufferIndex);\n return OMX_ErrorBadParameter;\n }\n\n    m_etb_count++;\n    DEBUG_PRINT_LOW(\"DBG: i/p nTimestamp = %u\", (unsigned)buffer->nTimeStamp);\n    post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);\n return OMX_ErrorNone;\n}\n",
        "output": "1",
        "index": 187767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WindowTreeHostManager::~WindowTreeHostManager() {}\n",
        "output": "0",
        "index": 133382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct inode *__udf_iget(struct super_block *sb, struct kernel_lb_addr *ino,\n\t\t\t bool hidden_inode)\n{\n\tunsigned long block = udf_get_lb_pblock(sb, ino, 0);\n\tstruct inode *inode = iget_locked(sb, block);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tmemcpy(&UDF_I(inode)->i_location, ino, sizeof(struct kernel_lb_addr));\n\terr = udf_read_inode(inode, hidden_inode);\n\tif (err < 0) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tunlock_new_inode(inode);\n\n\treturn inode;\n}\n",
        "output": "0",
        "index": 43061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::HandleKeyboardEvent(const NativeWebKeyboardEvent& event) {\n  if (browser_plugin_embedder_ &&\n      browser_plugin_embedder_->HandleKeyboardEvent(event)) {\n    return;\n  }\n\n  if (delegate_)\n    delegate_->HandleKeyboardEvent(this, event);\n}\n",
        "output": "0",
        "index": 118939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::ScheduleTextTrackResourceLoad() {\n  BLINK_MEDIA_LOG << \"scheduleTextTrackResourceLoad(\" << (void*)this << \")\";\n\n  pending_action_flags_ |= kLoadTextTrackResource;\n\n  if (!load_timer_.IsActive())\n    load_timer_.StartOneShot(TimeDelta(), FROM_HERE);\n}\n",
        "output": "0",
        "index": 142889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ClearDisplayPropertiesOnHost(AshWindowTreeHost* ash_host) {\n#if defined(OS_CHROMEOS) && defined(USE_OZONE)\n  aura::WindowTreeHost* host = ash_host->AsWindowTreeHost();\n  ui::CursorController::GetInstance()->ClearCursorConfigForWindow(\n      host->GetAcceleratedWidget());\n#endif\n}\n",
        "output": "0",
        "index": 133348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rtadv_process_packet (u_char *buf, unsigned int len, ifindex_t ifindex,\n    int hoplimit, vrf_id_t vrf_id)\n{\n  struct icmp6_hdr *icmph;\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  /* Interface search. */\n  ifp = if_lookup_by_index_vrf (ifindex, vrf_id);\n  if (ifp == NULL)\n    {\n      zlog_warn (\"Unknown interface index: %d, vrf %u\", ifindex, vrf_id);\n      return;\n    }\n\n  if (if_is_loopback (ifp))\n    return;\n\n  /* Check interface configuration. */\n  zif = ifp->info;\n  if (! zif->rtadv.AdvSendAdvertisements)\n    return;\n\n  /* ICMP message length check. */\n  if (len < sizeof (struct icmp6_hdr))\n    {\n      zlog_warn (\"Invalid ICMPV6 packet length: %d\", len);\n      return;\n    }\n\n  icmph = (struct icmp6_hdr *) buf;\n\n  /* ICMP message type check. */\n  if (icmph->icmp6_type != ND_ROUTER_SOLICIT &&\n      icmph->icmp6_type != ND_ROUTER_ADVERT)\n    {\n      zlog_warn (\"Unwanted ICMPV6 message type: %d\", icmph->icmp6_type);\n      return;\n    }\n\n  /* Hoplimit check. */\n  if (hoplimit >= 0 && hoplimit != 255)\n    {\n      zlog_warn (\"Invalid hoplimit %d for router advertisement ICMP packet\",\n\t\t hoplimit);\n      return;\n    }\n\n  /* Check ICMP message type. */\n  if (icmph->icmp6_type == ND_ROUTER_SOLICIT)\n    rtadv_process_solicit (ifp);\n  else if (icmph->icmp6_type == ND_ROUTER_ADVERT)\n    rtadv_process_advert ();\n\n  return;\n}\n",
        "output": "0",
        "index": 73957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LocalWindowProxy* LocalFrame::WindowProxy(DOMWrapperWorld& world) {\n  return ToLocalWindowProxy(Frame::GetWindowProxy(world));\n}\n",
        "output": "0",
        "index": 167992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  std::unique_ptr<content::URLLoaderInterceptor> SetupRequestFailForURL(\n      const GURL& url) {\n    return std::make_unique<content::URLLoaderInterceptor>(base::BindRepeating(\n        [](const GURL& url,\n           content::URLLoaderInterceptor::RequestParams* params) {\n          if (params->url_request.url != url)\n            return false;\n          network::URLLoaderCompletionStatus status;\n          status.error_code = net::ERR_DNS_TIMED_OUT;\n          params->client->OnComplete(status);\n          return true;\n        },\n        url));\n  }\n",
        "output": "0",
        "index": 167032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ACodec::ExecutingToIdleState::onMessageReceived(const sp<AMessage> &msg) {\n bool handled = false;\n\n switch (msg->what()) {\n case kWhatFlush:\n {\n            ALOGW(\"Ignoring flush request in ExecutingToIdleState\");\n break;\n }\n\n case kWhatShutdown:\n {\n\n            handled = true;\n break;\n }\n\n default:\n            handled = BaseState::onMessageReceived(msg);\n break;\n }\n\n return handled;\n}\n",
        "output": "0",
        "index": 177263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n}\n",
        "output": "0",
        "index": 21805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::DetachFromInputMethod() {\n  ui::InputMethod* input_method = GetInputMethod();\n  if (input_method && input_method->GetTextInputClient() == this)\n    input_method->SetFocusedTextInputClient(NULL);\n}\n",
        "output": "0",
        "index": 123160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int in_set_format(struct audio_stream *stream, audio_format_t format)\n{\n    UNUSED(stream);\n    UNUSED(format);\n\n    FNLOG();\n if (format == AUDIO_FORMAT_PCM_16_BIT)\n return 0;\n else\n return -1;\n}\n",
        "output": "0",
        "index": 171652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserView::EnterFullscreen(const GURL& url,\n                                  ExclusiveAccessBubbleType bubble_type) {\n  if (IsFullscreen())\n    return;  // Nothing to do.\n\n  ProcessFullscreen(true, url, bubble_type);\n}\n",
        "output": "0",
        "index": 168245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pgp_get_info_by_tag(sc_card_t *card, unsigned int tag)\n{\n\tstruct pgp_priv_data *priv = DRVDATA(card);\n\tstruct do_info *info;\n\n\tfor (info = priv->pgp_objects; (info != NULL) && (info->id > 0); info++)\n\t\tif (tag == info->id)\n\t\t\treturn info;\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 78591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fm10k_init_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tint err;\n\n\t/* Number of supported queues */\n\tfm10k_set_num_queues(interface);\n\n\t/* Configure MSI-X capability */\n\terr = fm10k_init_msix_capability(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to initialize MSI-X capability\\n\");\n\t\tgoto err_init_msix;\n\t}\n\n\t/* Allocate memory for queues */\n\terr = fm10k_alloc_q_vectors(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to allocate queue vectors\\n\");\n\t\tgoto err_alloc_q_vectors;\n\t}\n\n\t/* Map rings to devices, and map devices to physical queues */\n\tfm10k_assign_rings(interface);\n\n\t/* Initialize RSS redirection table */\n\tfm10k_init_reta(interface);\n\n\treturn 0;\n\nerr_alloc_q_vectors:\n\tfm10k_reset_msix_capability(interface);\nerr_init_msix:\n\tfm10k_reset_num_queues(interface);\n\treturn err;\n}\n",
        "output": "0",
        "index": 87931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void streamDecodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    memcpy(e,buf,sizeof(e));\n    id->ms = ntohu64(e[0]);\n    id->seq = ntohu64(e[1]);\n}\n",
        "output": "0",
        "index": 81788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vfp_set(struct task_struct *target,\n\t\t\t  const struct user_regset *regset,\n\t\t\t  unsigned int pos, unsigned int count,\n\t\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\tstruct thread_info *thread = task_thread_info(target);\n\tstruct vfp_hard_struct new_vfp = thread->vfpstate.hard;\n\tconst size_t user_fpregs_offset = offsetof(struct user_vfp, fpregs);\n\tconst size_t user_fpscr_offset = offsetof(struct user_vfp, fpscr);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &new_vfp.fpregs,\n\t\t\t\t  user_fpregs_offset,\n\t\t\t\t  user_fpregs_offset + sizeof(new_vfp.fpregs));\n\tif (ret)\n\t\treturn ret;\n\n\tret = user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\tuser_fpregs_offset + sizeof(new_vfp.fpregs),\n\t\t\t\tuser_fpscr_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &new_vfp.fpscr,\n\t\t\t\t user_fpscr_offset,\n\t\t\t\t user_fpscr_offset + sizeof(new_vfp.fpscr));\n\tif (ret)\n\t\treturn ret;\n\n\tvfp_sync_hwstate(thread);\n\tthread->vfpstate.hard = new_vfp;\n\tvfp_flush_hwstate(thread);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 25341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::invalidateAccessKeyMap()\n{\n    m_accessKeyMapValid = false;\n    m_elementsByAccessKey.clear();\n}\n",
        "output": "0",
        "index": 112488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataFileSystem::StartFileUploadOnUIThreadAfterGetEntryInfo(\n    const StartFileUploadParams& params,\n    int64 file_size,\n    std::string content_type,\n    GDataFileError error,\n    scoped_ptr<GDataEntryProto> entry_proto) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  if (entry_proto.get() && !entry_proto->file_info().is_directory())\n    error = GDATA_FILE_ERROR_NOT_A_DIRECTORY;\n\n  if (error != GDATA_FILE_OK) {\n    if (!params.callback.is_null())\n      params.callback.Run(error);\n    return;\n  }\n  DCHECK(entry_proto.get());\n\n  scoped_ptr<UploadFileInfo> upload_file_info(new UploadFileInfo);\n  upload_file_info->file_path = params.local_file_path;\n  upload_file_info->file_size = file_size;\n  upload_file_info->gdata_path = params.remote_file_path;\n  upload_file_info->title = params.remote_file_path.BaseName().value();\n  upload_file_info->content_length = file_size;\n  upload_file_info->all_bytes_present = true;\n  upload_file_info->content_type = content_type;\n  upload_file_info->initial_upload_location = GURL(entry_proto->upload_url());\n\n  upload_file_info->completion_callback =\n      base::Bind(&GDataFileSystem::OnTransferCompleted,\n                 ui_weak_ptr_,\n                 params.callback);\n\n  uploader_->UploadNewFile(upload_file_info.Pass());\n}\n",
        "output": "0",
        "index": 125467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::CanExecuteScripts(ReasonForCallingCanExecuteScripts reason) {\n  DCHECK(GetFrame())\n      << \"you are querying canExecuteScripts on a non contextDocument.\";\n\n  if (IsSandboxed(kSandboxScripts) &&\n      !GetFrame()->GetScriptController().ShouldBypassMainWorldCSP()) {\n    if (reason == kAboutToExecuteScript) {\n      AddConsoleMessage(ConsoleMessage::Create(\n          kSecurityMessageSource, kErrorMessageLevel,\n          \"Blocked script execution in '\" + Url().ElidedString() +\n              \"' because the document's frame is sandboxed and the \"\n              \"'allow-scripts' permission is not set.\"));\n    }\n    return false;\n  }\n\n  if (!GetFrame()->Client())\n    return false;\n\n  WebContentSettingsClient* settings_client =\n      GetFrame()->GetContentSettingsClient();\n\n  Settings* settings = GetFrame()->GetSettings();\n  bool script_enabled = settings && settings->GetScriptEnabled();\n  if (settings_client)\n    script_enabled = settings_client->AllowScript(script_enabled);\n  if (!script_enabled && reason == kAboutToExecuteScript && settings_client)\n    settings_client->DidNotAllowScript();\n  return script_enabled;\n}\n",
        "output": "0",
        "index": 165445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string16 DevToolsConfirmInfoBarDelegate::GetButtonLabel(\n    InfoBarButton button) const {\n  return l10n_util::GetStringUTF16((button == BUTTON_OK) ?\n      IDS_DEV_TOOLS_CONFIRM_ALLOW_BUTTON : IDS_DEV_TOOLS_CONFIRM_DENY_BUTTON);\n}\n",
        "output": "0",
        "index": 121409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int em_in(struct x86_emulate_ctxt *ctxt)\n{\n\tif (!pio_in_emulated(ctxt, ctxt->dst.bytes, ctxt->src.val,\n\t\t\t     &ctxt->dst.val))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n",
        "output": "0",
        "index": 21753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dev_queue_xmit_nit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct packet_type *ptype;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct packet_type *pt_prev = NULL;\n\tstruct list_head *ptype_list = &ptype_all;\n\n\trcu_read_lock();\nagain:\n\tlist_for_each_entry_rcu(ptype, ptype_list, list) {\n\t\t/* Never send packets back to the socket\n\t\t * they originated from - MvS (miquels@drinkel.ow.org)\n\t\t */\n\t\tif (skb_loop_sk(ptype, skb))\n\t\t\tcontinue;\n\n\t\tif (pt_prev) {\n\t\t\tdeliver_skb(skb2, pt_prev, skb->dev);\n\t\t\tpt_prev = ptype;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* need to clone skb, done only once */\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!skb2)\n\t\t\tgoto out_unlock;\n\n\t\tnet_timestamp_set(skb2);\n\n\t\t/* skb->nh should be correctly\n\t\t * set by sender, so that the second statement is\n\t\t * just protection against buggy protocols.\n\t\t */\n\t\tskb_reset_mac_header(skb2);\n\n\t\tif (skb_network_header(skb2) < skb2->data ||\n\t\t    skb_network_header(skb2) > skb_tail_pointer(skb2)) {\n\t\t\tnet_crit_ratelimited(\"protocol %04x is buggy, dev %s\\n\",\n\t\t\t\t\t     ntohs(skb2->protocol),\n\t\t\t\t\t     dev->name);\n\t\t\tskb_reset_network_header(skb2);\n\t\t}\n\n\t\tskb2->transport_header = skb2->network_header;\n\t\tskb2->pkt_type = PACKET_OUTGOING;\n\t\tpt_prev = ptype;\n\t}\n\n\tif (ptype_list == &ptype_all) {\n\t\tptype_list = &dev->ptype_all;\n\t\tgoto again;\n\t}\nout_unlock:\n\tif (pt_prev) {\n\t\tif (!skb_orphan_frags_rx(skb2, GFP_ATOMIC))\n\t\t\tpt_prev->func(skb2, skb->dev, pt_prev, skb->dev);\n\t\telse\n\t\t\tkfree_skb(skb2);\n\t}\n\trcu_read_unlock();\n}\n",
        "output": "0",
        "index": 93379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ParamTraits<IPC::ChannelHandle>::Log(const param_type& p,\n                                          std::string* l) {\n  l->append(StringPrintf(\"ChannelHandle(%s\", p.name.c_str()));\n#if defined(OS_POSIX)\n  l->append(\", \");\n  ParamTraits<base::FileDescriptor>::Log(p.socket, l);\n#endif\n  l->append(\")\");\n}\n",
        "output": "0",
        "index": 125794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AudioNode::AudioNode(BaseAudioContext& context)\n    : context_(context), handler_(nullptr) {}\n",
        "output": "0",
        "index": 161602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CursorFreeHideCount(void *data, XID id)\n{\n    CursorHideCountPtr pChc = (CursorHideCountPtr) data;\n    ScreenPtr pScreen = pChc->pScreen;\n    DeviceIntPtr dev;\n\n    deleteCursorHideCount(pChc, pChc->pScreen);\n    for (dev = inputInfo.devices; dev; dev = dev->next) {\n        if (IsMaster(dev) && IsPointerDevice(dev))\n            CursorDisplayCursor(dev, pScreen, CursorCurrent[dev->id]);\n    }\n\n    return 1;\n}\n",
        "output": "0",
        "index": 17645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SiteInstanceImpl::IsRelatedSiteInstance(const SiteInstance* instance) {\n  return browsing_instance_.get() == static_cast<const SiteInstanceImpl*>(\n                                         instance)->browsing_instance_.get();\n}\n",
        "output": "0",
        "index": 167606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lua_translate_name_harness_last(request_rec *r)\n{\n    return lua_request_rec_hook_harness(r, \"translate_name\", AP_LUA_HOOK_LAST);\n}\n",
        "output": "0",
        "index": 35712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}\n",
        "output": "0",
        "index": 26226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PerformanceEntryVector Performance::getEntriesByName(const String& name,\n                                                     const String& entry_type) {\n  PerformanceEntryVector entries;\n  PerformanceEntry::EntryType type =\n      PerformanceEntry::ToEntryTypeEnum(entry_type);\n\n  if (!entry_type.IsNull() && type == PerformanceEntry::kInvalid)\n    return entries;\n\n  if (entry_type.IsNull() || type == PerformanceEntry::kResource) {\n    for (const auto& resource : resource_timing_buffer_) {\n      if (resource->name() == name)\n        entries.push_back(resource);\n    }\n  }\n\n  if (entry_type.IsNull() || type == PerformanceEntry::kNavigation) {\n    if (!navigation_timing_)\n      navigation_timing_ = CreateNavigationTimingInstance();\n    if (navigation_timing_ && navigation_timing_->name() == name)\n      entries.push_back(navigation_timing_);\n  }\n\n  if (entry_type.IsNull() || type == PerformanceEntry::kComposite ||\n      type == PerformanceEntry::kRender) {\n    for (const auto& frame : frame_timing_buffer_) {\n      if (frame->name() == name &&\n          (entry_type.IsNull() || entry_type == frame->entryType()))\n        entries.push_back(frame);\n    }\n  }\n\n  if (user_timing_) {\n    if (entry_type.IsNull() || type == PerformanceEntry::kMark)\n      entries.AppendVector(user_timing_->GetMarks(name));\n    if (entry_type.IsNull() || type == PerformanceEntry::kMeasure)\n      entries.AppendVector(user_timing_->GetMeasures(name));\n  }\n\n  if (entry_type.IsNull() || type == PerformanceEntry::kPaint) {\n    if (first_paint_timing_ && first_paint_timing_->name() == name)\n      entries.push_back(first_paint_timing_);\n    if (first_contentful_paint_timing_ &&\n        first_contentful_paint_timing_->name() == name)\n      entries.push_back(first_contentful_paint_timing_);\n  }\n\n  std::sort(entries.begin(), entries.end(),\n            PerformanceEntry::StartTimeCompareLessThan);\n  return entries;\n}\n",
        "output": "0",
        "index": 166909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderObject* Element::pseudoElementRenderer(PseudoId pseudoId) const\n{\n    if (PseudoElement* element = pseudoElement(pseudoId))\n        return element->renderer();\n    return 0;\n}\n",
        "output": "0",
        "index": 120585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ui::ModalType ExternalProtocolDialog::GetModalType() const {\n  return ui::MODAL_TYPE_CHILD;\n}\n",
        "output": "0",
        "index": 168459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_orig_addr(struct msghdr *m, struct tipc_msg *msg)\n{\n\tstruct sockaddr_tipc *addr = (struct sockaddr_tipc *)m->msg_name;\n\n\tif (addr) {\n\t\taddr->family = AF_TIPC;\n\t\taddr->addrtype = TIPC_ADDR_ID;\n\t\tmemset(&addr->addr, 0, sizeof(addr->addr));\n\t\taddr->addr.id.ref = msg_origport(msg);\n\t\taddr->addr.id.node = msg_orignode(msg);\n\t\taddr->addr.name.domain = 0;\t/* could leave uninitialized */\n\t\taddr->scope = 0;\t\t/* could leave uninitialized */\n\t\tm->msg_namelen = sizeof(struct sockaddr_tipc);\n\t}\n}\n",
        "output": "0",
        "index": 40721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 65444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\t/*\n\t * no branch sampling for software events\n\t */\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 50523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool NPJSObject::NP_Invoke(NPObject* npObject, NPIdentifier methodName, const NPVariant* arguments, uint32_t argumentCount, NPVariant* result)\n{\n    return toNPJSObject(npObject)->invoke(methodName, arguments, argumentCount, result);\n}\n",
        "output": "0",
        "index": 99458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofproto_set_netflow(struct ofproto *ofproto,\n                    const struct netflow_options *nf_options)\n{\n    if (nf_options && sset_is_empty(&nf_options->collectors)) {\n        nf_options = NULL;\n    }\n\n    if (ofproto->ofproto_class->set_netflow) {\n        return ofproto->ofproto_class->set_netflow(ofproto, nf_options);\n    } else {\n        return nf_options ? EOPNOTSUPP : 0;\n    }\n}\n",
        "output": "0",
        "index": 77391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tsize_t n;\n\tint result;\n\tJAS_DBGLOG(100, (\"sfile_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tfp = JAS_CAST(FILE *, obj);\n\tn = fread(buf, 1, cnt, fp);\n\tif (n != cnt) {\n\t\tresult = (!ferror(fp) && feof(fp)) ? 0 : -1;\n\t}\n\tresult = JAS_CAST(int, n);\n\treturn result;\n}\n",
        "output": "0",
        "index": 72807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ctts_del(GF_Box *s)\n{\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);\n}\n",
        "output": "0",
        "index": 80034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_array_it_get_current_key(zend_object_iterator *iter, char **str_key, uint *str_key_len, ulong *int_key TSRMLS_DC) /* {{{ */\n{\n\tspl_array_it       *iterator = (spl_array_it *)iter;\n\tspl_array_object   *object   = iterator->object;\n\tHashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);\n\n\tif (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {\n\t\treturn zend_user_it_get_current_key(iter, str_key, str_key_len, int_key TSRMLS_CC);\n\t} else {\n\t\tif (spl_array_object_verify_pos_ex(object, aht, \"ArrayIterator::current(): \" TSRMLS_CC) == FAILURE) {\n\t\t\treturn HASH_KEY_NON_EXISTANT;\n\t\t}\n\t\n\t\treturn zend_hash_get_current_key_ex(aht, str_key, str_key_len, int_key, 1, &object->pos);\n\t}\n}\n/* }}} */\n",
        "output": "0",
        "index": 12364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const QList<Smb4KWorkgroup *> &Smb4KGlobal::workgroupsList()\n{\n  return p->workgroupsList;\n}\n",
        "output": "0",
        "index": 6584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void UpdateCheckCallback(AutomationJSONReply* reply,\n                         UpdateEngineClient::UpdateCheckResult result) {\n  if (result == UpdateEngineClient::UPDATE_RESULT_SUCCESS)\n    reply->SendSuccess(NULL);\n  else\n    reply->SendError(\"update check failed\");\n  delete reply;\n}\n",
        "output": "0",
        "index": 117496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sanitize_rfc5988(char *str, size_t len, zval *zv TSRMLS_DC)\n{\n\tzval_dtor(zv);\n\tphp_trim(str, len, \" ><\", 3, zv, 3 TSRMLS_CC);\n}\n",
        "output": "0",
        "index": 94005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebContentsImpl::IsCrashed() const {\n  return (crashed_status_ == base::TERMINATION_STATUS_PROCESS_CRASHED ||\n          crashed_status_ == base::TERMINATION_STATUS_ABNORMAL_TERMINATION ||\n          crashed_status_ == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);\n}\n",
        "output": "0",
        "index": 118948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_dor(int fdc, char mask, char data)\n{\n\tunsigned char unit;\n\tunsigned char drive;\n\tunsigned char newdor;\n\tunsigned char olddor;\n\n\tif (FDCS->address == -1)\n\t\treturn -1;\n\n\tolddor = FDCS->dor;\n\tnewdor = (olddor & mask) | data;\n\tif (newdor != olddor) {\n\t\tunit = olddor & 0x3;\n\t\tif (is_selected(olddor, unit) && !is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tdebug_dcl(UDP->flags,\n\t\t\t\t  \"calling disk change from set_dor\\n\");\n\t\t\tdisk_change(drive);\n\t\t}\n\t\tFDCS->dor = newdor;\n\t\tfd_outb(newdor, FD_DOR);\n\n\t\tunit = newdor & 0x3;\n\t\tif (!is_selected(olddor, unit) && is_selected(newdor, unit)) {\n\t\t\tdrive = REVDRIVE(fdc, unit);\n\t\t\tUDRS->select_date = jiffies;\n\t\t}\n\t}\n\treturn olddor;\n}\n",
        "output": "0",
        "index": 39432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_deassign_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)\n{\n\tenum kvm_bus bus_idx = ioeventfd_bus_from_flags(args->flags);\n\tint ret = kvm_deassign_ioeventfd_idx(kvm, bus_idx, args);\n\n\tif (!args->len && bus_idx == KVM_MMIO_BUS)\n\t\tkvm_deassign_ioeventfd_idx(kvm, KVM_FAST_MMIO_BUS, args);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 58892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct posix_acl *get_cached_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *acl;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tacl = rcu_dereference(*p);\n\t\tif (!acl || is_uncached_acl(acl) ||\n\t\t    atomic_inc_not_zero(&acl->a_refcount))\n\t\t\tbreak;\n\t\trcu_read_unlock();\n\t\tcpu_relax();\n\t}\n\trcu_read_unlock();\n\treturn acl;\n}\n",
        "output": "0",
        "index": 50374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep,\n\t\t\t\t      uint8_t *buffer, int buffer_length)\n{\n\tint i;\n\n\tfor (i = 0; i + 3 < buffer_length; i += 4)\n\t\tif (buffer[i + 3] != 0) {\n\t\t\tint port = buffer[i + 3] >> 4;\n\t\t\tint length = buffer[i + 3] & 3;\n\t\t\tsnd_usbmidi_input_data(ep, port, &buffer[i], length);\n\t\t}\n}\n",
        "output": "0",
        "index": 54788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "job_free (Job *job)\n{\n  if (job->user_data_destroy_func != NULL)\n    job->user_data_destroy_func (job->user_data);\n  if (job->device != NULL)\n    g_object_unref (job->device);\n  if (job->stderr_fd >= 0)\n    close (job->stderr_fd);\n  if (job->stdout_fd >= 0)\n    close (job->stdout_fd);\n  if (job->stdin_fd >= 0)\n    {\n      close (job->stdin_fd);\n      g_source_remove (job->in_channel_source_id);\n      g_io_channel_unref (job->in_channel);\n    }\n  g_source_remove (job->error_channel_source_id);\n  g_source_remove (job->out_channel_source_id);\n  g_io_channel_unref (job->error_channel);\n  g_io_channel_unref (job->out_channel);\n  g_string_free (job->error_string, TRUE);\n  /* scrub stdin (may contain secrets) */\n  if (job->stdin_str != NULL)\n    {\n      memset (job->stdin_str, '\\0', strlen (job->stdin_str));\n    }\n  g_string_free (job->stdout_string, TRUE);\n  g_free (job->stdin_str);\n  g_free (job->job_id);\n  g_free (job);\n}\n",
        "output": "0",
        "index": 11726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int32_t WebPage::finishComposition()\n{\n    return d->m_inputHandler->finishComposition();\n}\n",
        "output": "0",
        "index": 111156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AP_DECLARE(const char *) ap_auth_name(request_rec *r)\n{\n    if (authn_ap_auth_name) {\n        return authn_ap_auth_name(r);\n    }\n    return NULL;\n}\n",
        "output": "0",
        "index": 64182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_read_format_rar_options(struct archive_read *a,\n    const char *key, const char *val)\n{\n  struct rar *rar;\n  int ret = ARCHIVE_FAILED;\n\n  rar = (struct rar *)(a->format->data);\n  if (strcmp(key, \"hdrcharset\")  == 0) {\n    if (val == NULL || val[0] == 0)\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n          \"rar: hdrcharset option needs a character-set name\");\n    else {\n      rar->opt_sconv =\n          archive_string_conversion_from_charset(\n              &a->archive, val, 0);\n      if (rar->opt_sconv != NULL)\n        ret = ARCHIVE_OK;\n      else\n        ret = ARCHIVE_FATAL;\n    }\n    return (ret);\n  }\n\n  /* Note: The \"warn\" return is just to inform the options\n   * supervisor that we didn't handle it.  It will generate\n   * a suitable error if no one used this option. */\n  return (ARCHIVE_WARN);\n}\n",
        "output": "0",
        "index": 53462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderWidgetHostViewAura::GetCompositionTextRange(\n    gfx::Range* range) const {\n  NOTIMPLEMENTED();\n  return false;\n}\n",
        "output": "0",
        "index": 132948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_itoa(int proto)\n{\n\tconst char * protocol;\n\tswitch(proto) {\n\tcase IPPROTO_UDP:\n\t\tprotocol = \"UDP\";\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tprotocol = \"TCP\";\n\t\tbreak;\n#ifdef IPPROTO_UDPLITE\n\tcase IPPROTO_UDPLITE:\n\t\tprotocol = \"UDPLITE\";\n\t\tbreak;\n#endif /* IPPROTO_UDPLITE */\n\tdefault:\n\t\tprotocol = \"*UNKNOWN*\";\n\t}\n\treturn protocol;\n}\n",
        "output": "0",
        "index": 89835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ldb_dn_is_null(struct ldb_dn *dn)\n{\n\tif ( ! dn || dn->invalid) return false;\n\tif (ldb_dn_has_extended(dn)) return false;\n\tif (dn->linearized && (dn->linearized[0] == '\\0')) return true;\n\treturn false;\n}\n",
        "output": "0",
        "index": 2354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void VaapiWrapper::VADisplayState::SetDrmFd(base::PlatformFile fd) {\n  drm_fd_.reset(HANDLE_EINTR(dup(fd)));\n}\n",
        "output": "0",
        "index": 99715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HWND RenderWidgetHostViewAura::GetHostWindowHWND() const {\n  aura::WindowTreeHost* host = window_->GetHost();\n  return host ? host->GetAcceleratedWidget() : nullptr;\n}\n",
        "output": "0",
        "index": 144910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cifs_prune_tlinks(struct work_struct *work)\n{\n\tstruct cifs_sb_info *cifs_sb = container_of(work, struct cifs_sb_info,\n\t\t\t\t\t\t    prune_tlinks.work);\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node = rb_first(root);\n\tstruct rb_node *tmp;\n\tstruct tcon_link *tlink;\n\n\t/*\n\t * Because we drop the spinlock in the loop in order to put the tlink\n\t * it's not guarded against removal of links from the tree. The only\n\t * places that remove entries from the tree are this function and\n\t * umounts. Because this function is non-reentrant and is canceled\n\t * before umount can proceed, this is safe.\n\t */\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\tnode = rb_first(root);\n\twhile (node != NULL) {\n\t\ttmp = node;\n\t\tnode = rb_next(tmp);\n\t\ttlink = rb_entry(tmp, struct tcon_link, tl_rbnode);\n\n\t\tif (test_bit(TCON_LINK_MASTER, &tlink->tl_flags) ||\n\t\t    atomic_read(&tlink->tl_count) != 0 ||\n\t\t    time_after(tlink->tl_time + TLINK_IDLE_EXPIRE, jiffies))\n\t\t\tcontinue;\n\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(tmp, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tqueue_delayed_work(system_nrt_wq, &cifs_sb->prune_tlinks,\n\t\t\t\tTLINK_IDLE_EXPIRE);\n}\n",
        "output": "0",
        "index": 24489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext_analyzer_insn_hook(struct bpf_verifier_env *env,\n\t\t\t\t  int insn_idx, int prev_insn_idx)\n{\n\tif (!env->analyzer_ops || !env->analyzer_ops->insn_hook)\n\t\treturn 0;\n\n\treturn env->analyzer_ops->insn_hook(env, insn_idx, prev_insn_idx);\n}\n",
        "output": "0",
        "index": 65058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_EMC(fz_context *ctx, pdf_processor *proc)\n{\n}\n",
        "output": "0",
        "index": 479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport void AttachBlob(BlobInfo *blob_info,const void *blob,\n  const size_t length)\n{\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  blob_info->length=length;\n  blob_info->extent=length;\n  blob_info->quantum=(size_t) MagickMaxBlobExtent;\n  blob_info->offset=0;\n  blob_info->type=BlobStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  blob_info->data=(unsigned char *) blob;\n  blob_info->mapped=MagickFalse;\n}\n",
        "output": "0",
        "index": 88504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TranslateInfoBarDelegate::MessageInfoBarButtonPressed() {\n  DCHECK_EQ(translate::TRANSLATE_STEP_TRANSLATE_ERROR, step_);\n  if (error_type_ == TranslateErrors::UNSUPPORTED_LANGUAGE) {\n    RevertTranslation();\n    return;\n  }\n  TranslateManager* manager =\n      TranslateTabHelper::GetManagerFromWebContents(GetWebContents());\n  DCHECK(manager);\n  manager->TranslatePage(\n      original_language_code(), target_language_code(), false);\n}\n",
        "output": "0",
        "index": 119300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_proc_sequence(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_task *task;\n\tint ret;\n\n\ttask = _nfs41_proc_sequence(clp, cred);\n\tif (IS_ERR(task)) {\n\t\tret = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\tret = rpc_wait_for_completion_task(task);\n\tif (!ret) {\n\t\tstruct nfs4_sequence_res *res = task->tk_msg.rpc_resp;\n\n\t\tif (task->tk_status == 0)\n\t\t\tnfs41_handle_sequence_flag_errors(clp, res->sr_status_flags);\n\t\tret = task->tk_status;\n\t}\n\trpc_put_task(task);\nout:\n\tdprintk(\"<-- %s status=%d\\n\", __func__, ret);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 19993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean toshiba_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[TOSHIBA_LINE_LENGTH];\n\tguint\ti, reclen, level, line;\n\tchar\tbyte;\n\n\tbuf[TOSHIBA_LINE_LENGTH-1] = 0;\n\n\tfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = (guint) strlen(buf);\n\t\tif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlevel = 0;\n\t\tfor (i = 0; i < reclen; i++) {\n\t\t\tbyte = buf[i];\n\t\t\tif (byte == toshiba_hdr_magic[level]) {\n\t\t\t\tlevel++;\n\t\t\t\tif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlevel = 0;\n\t\t\t}\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n",
        "output": "0",
        "index": 51778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2DecoderImpl::IsDrawValid(GLuint max_vertex_accessed) {\n  if (!current_program_) {\n    return false;\n  }\n  const VertexAttribManager::VertexAttribInfoList& infos =\n      vertex_attrib_manager_.GetEnabledVertexAttribInfos();\n  for (VertexAttribManager::VertexAttribInfoList::const_iterator it =\n       infos.begin(); it != infos.end(); ++it) {\n    const VertexAttribManager::VertexAttribInfo* info = *it;\n    const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n        current_program_->GetAttribInfoByLocation(info->index());\n    if (attrib_info) {\n      if (!info->CanAccess(max_vertex_accessed)) {\n        SetGLError(GL_INVALID_OPERATION,\n                   \"glDrawXXX: attempt to access out of range vertices\");\n        return false;\n      }\n    } else {\n      if (!info->buffer() || info->buffer()->IsDeleted()) {\n        SetGLError(\n            GL_INVALID_OPERATION,\n            \"glDrawXXX: attempt to render with no buffer attached to enabled \"\n            \"attrib\");\n        return false;\n      }\n    }\n  }\n   return true;\n }\n",
        "output": "0",
        "index": 104166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncManager::SyncInternal::UpdateCryptographerAndNigori(\n    const base::Callback<void(bool)>& done_callback) {\n  DCHECK(initialized_);\n  scoped_refptr<browser_sync::GetSessionNameTask> task =\n      new browser_sync::GetSessionNameTask(base::Bind(\n          &SyncManager::SyncInternal::UpdateCryptographerAndNigoriCallback,\n          weak_ptr_factory_.GetWeakPtr(),\n          done_callback));\n  content::BrowserThread::PostTask(\n      content::BrowserThread::FILE,\n      FROM_HERE,\n      base::Bind(&browser_sync::GetSessionNameTask::GetSessionNameAsync,\n                 task.get()));\n}\n",
        "output": "0",
        "index": 116111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool got_dom() const {\n    return got_dom_;\n  }\n",
        "output": "0",
        "index": 115810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionWithScriptStateVoidException(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    ExceptionCode ec = 0;\n    impl->withScriptStateVoidException(exec, ec);\n    setDOMException(exec, ec);\n    return JSValue::encode(jsUndefined());\n}\n",
        "output": "0",
        "index": 106155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoVertexAttrib1fv(GLuint index, const GLfloat* v) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_.GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttrib1fv: index out of range\");\n    return;\n  }\n  VertexAttribManager::VertexAttribInfo::Vec4 value;\n  value.v[0] = v[0];\n  value.v[1] = 0.0f;\n  value.v[2] = 0.0f;\n  value.v[3] = 1.0f;\n  info->set_value(value);\n  glVertexAttrib1fv(index, v);\n}\n",
        "output": "0",
        "index": 104066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int GetMimeTypeMatch(const std::string& mime_type_string,\n                     std::map<std::string, int> mime_type_map) {\n  for (const auto& entry : mime_type_map) {\n    if (entry.first == mime_type_string) {\n      return entry.second;\n    }\n  }\n  return 0;\n}\n",
        "output": "0",
        "index": 166420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  LoadWatcher(ScriptContext* context,\n              content::RenderFrame* frame,\n              v8::Local<v8::Function> cb)\n      : content::RenderFrameObserver(frame),\n        context_(context),\n        callback_(context->isolate(), cb) {\n    if (ExtensionFrameHelper::Get(frame)->\n            did_create_current_document_element()) {\n      base::MessageLoop::current()->PostTask(\n          FROM_HERE,\n          base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this),\n                     true));\n    }\n   }\n",
        "output": "1",
        "index": 186113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " ProcXSendExtensionEvent(ClientPtr client)\n {\n    int ret;\n     DeviceIntPtr dev;\n     xEvent *first;\n     XEventClass *list;\n    struct tmask tmp[EMASKSIZE];\n\n    REQUEST(xSendExtensionEventReq);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        (stuff->num_events * bytes_to_int32(sizeof(xEvent))))\n        return BadLength;\n\n    ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess);\n    if (ret != Success)\n        return ret;\n\n    if (stuff->num_events == 0)\n        return ret;\n\n     /* The client's event type must be one defined by an extension. */\n \n     first = ((xEvent *) &stuff[1]);\n    if (!((EXTENSION_EVENT_BASE <= first->u.u.type) &&\n          (first->u.u.type < lastEvent))) {\n        client->errorValue = first->u.u.type;\n        return BadValue;\n     }\n \n     list = (XEventClass *) (first + stuff->num_events);\n        return ret;\n\n    ret = (SendEvent(client, dev, stuff->destination,\n                     stuff->propagate, (xEvent *) &stuff[1],\n                     tmp[stuff->deviceid].mask, stuff->num_events));\n\n    return ret;\n}\n",
        "output": "1",
        "index": 177937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypt_extent(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct page *dst_page,\n\t\t\tstruct page *src_page,\n\t\t\tunsigned long extent_offset, int op)\n{\n\tpgoff_t page_index = op == ENCRYPT ? src_page->index : dst_page->index;\n\tloff_t extent_base;\n\tchar extent_iv[ECRYPTFS_MAX_IV_BYTES];\n\tstruct scatterlist src_sg, dst_sg;\n\tsize_t extent_size = crypt_stat->extent_size;\n\tint rc;\n\n\textent_base = (((loff_t)page_index) * (PAGE_CACHE_SIZE / extent_size));\n\trc = ecryptfs_derive_iv(extent_iv, crypt_stat,\n\t\t\t\t(extent_base + extent_offset));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error attempting to derive IV for \"\n\t\t\t\"extent [0x%.16llx]; rc = [%d]\\n\",\n\t\t\t(unsigned long long)(extent_base + extent_offset), rc);\n\t\tgoto out;\n\t}\n\n\tsg_init_table(&src_sg, 1);\n\tsg_init_table(&dst_sg, 1);\n\n\tsg_set_page(&src_sg, src_page, extent_size,\n\t\t    extent_offset * extent_size);\n\tsg_set_page(&dst_sg, dst_page, extent_size,\n\t\t    extent_offset * extent_size);\n\n\trc = crypt_scatterlist(crypt_stat, &dst_sg, &src_sg, extent_size,\n\t\t\t       extent_iv, op);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to crypt page with \"\n\t\t       \"page_index = [%ld], extent_offset = [%ld]; \"\n\t\t       \"rc = [%d]\\n\", __func__, page_index, extent_offset, rc);\n\t\tgoto out;\n\t}\n\trc = 0;\nout:\n\treturn rc;\n}\n",
        "output": "0",
        "index": 45399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AudioOutputDevice::OnIPCClosed() {\n  ipc_ = NULL;\n}\n",
        "output": "0",
        "index": 109965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tracing_alloc_snapshot(void)\n{\n\tWARN_ONCE(1, \"Snapshot feature not enabled, but snapshot allocation used\");\n\treturn -ENODEV;\n}\n",
        "output": "0",
        "index": 81452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ServiceWorkerContextCore::AddProviderHost(\n    std::unique_ptr<ServiceWorkerProviderHost> host) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  int provider_id = host->provider_id();\n  providers_->emplace(provider_id, std::move(host));\n}\n",
        "output": "0",
        "index": 152119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_scsi_flush(struct vhost_scsi *vs)\n{\n\tstruct vhost_scsi_inflight *old_inflight[VHOST_SCSI_MAX_VQ];\n\tint i;\n\n\t/* Init new inflight and remember the old inflight */\n\tvhost_scsi_init_inflight(vs, old_inflight);\n\n\t/*\n\t * The inflight->kref was initialized to 1. We decrement it here to\n\t * indicate the start of the flush operation so that it will reach 0\n\t * when all the reqs are finished.\n\t */\n\tfor (i = 0; i < VHOST_SCSI_MAX_VQ; i++)\n\t\tkref_put(&old_inflight[i]->kref, vhost_scsi_done_inflight);\n\n\t/* Flush both the vhost poll and vhost work */\n\tfor (i = 0; i < VHOST_SCSI_MAX_VQ; i++)\n\t\tvhost_scsi_flush_vq(vs, i);\n\tvhost_work_flush(&vs->dev, &vs->vs_completion_work);\n\tvhost_work_flush(&vs->dev, &vs->vs_event_work);\n\n\t/* Wait for all reqs issued before the flush to be finished */\n\tfor (i = 0; i < VHOST_SCSI_MAX_VQ; i++)\n\t\twait_for_completion(&old_inflight[i]->comp);\n}\n",
        "output": "0",
        "index": 43089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GBool DCTStream::readAdobeMarker() {\n  int length, i;\n  char buf[12];\n  int c;\n\n  length = read16();\n  if (length < 14) {\n    goto err;\n  }\n  for (i = 0; i < 12; ++i) {\n    if ((c = str->getChar()) == EOF) {\n      goto err;\n    }\n    buf[i] = c;\n  }\n  if (strncmp(buf, \"Adobe\", 5)) {\n    goto err;\n  }\n  colorXform = buf[11];\n  gotAdobeMarker = gTrue;\n  for (i = 14; i < length; ++i) {\n    if (str->getChar() == EOF) {\n      goto err;\n    }\n  }\n  return gTrue;\n\n err:\n  error(errSyntaxError, getPos(), \"Bad DCT Adobe APP14 marker\");\n  return gFalse;\n}\n",
        "output": "0",
        "index": 4010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t/*\n\t\t * Ensure the list deletion is visible before we clear\n\t\t * the owner, closes a race against perf_release() where\n\t\t * we need to serialize on the owner->perf_event_mutex.\n\t\t */\n\t\tsmp_wmb();\n\t\tevent->owner = NULL;\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n}\n",
        "output": "0",
        "index": 26076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool fd_in_set(int fd, const int fdset[], unsigned n_fdset) {\n        unsigned i;\n\n        assert(n_fdset == 0 || fdset);\n\n        for (i = 0; i < n_fdset; i++)\n                if (fdset[i] == fd)\n                        return true;\n\n        return false;\n}\n",
        "output": "0",
        "index": 11522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::DidHandleKeyEvent() {\n  edit_commands_.clear();\n}\n",
        "output": "0",
        "index": 97891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned int muldiv32(unsigned int a, unsigned int b,\n\t\t\t\t    unsigned int c, unsigned int *r)\n{\n\tu_int64_t n = (u_int64_t) a * b;\n\tif (c == 0) {\n\t\tsnd_BUG_ON(!n);\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\tn = div_u64_rem(n, c, r);\n\tif (n >= UINT_MAX) {\n\t\t*r = 0;\n\t\treturn UINT_MAX;\n\t}\n\treturn n;\n}\n",
        "output": "0",
        "index": 47786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::ForciblyLoseOldestContext(\n    const String& reason) {\n  WebGLRenderingContextBase* candidate = OldestContext();\n  if (!candidate)\n    return;\n\n  candidate->PrintWarningToConsole(reason);\n  probe::didFireWebGLWarning(candidate->canvas());\n\n  candidate->ForceLostContext(WebGLRenderingContextBase::kSyntheticLostContext,\n                              WebGLRenderingContextBase::kWhenAvailable);\n}\n",
        "output": "0",
        "index": 146299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CreateFrameResourceCoordinator(\n    RenderFrameHostImpl* render_frame_host,\n    resource_coordinator::mojom::FrameCoordinationUnitRequest request) {\n  render_frame_host->GetFrameResourceCoordinator()->AddBinding(\n      std::move(request));\n}\n",
        "output": "0",
        "index": 160426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Cluster::GetEntryCount() const\n{\n    return m_entries_count;\n}\n",
        "output": "1",
        "index": 188340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int qeth_mtu_is_valid(struct qeth_card *card, int mtu)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_OSD:\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn ((mtu >= 576) &&\n\t\t\t(mtu <= card->info.max_mtu));\n\tcase QETH_CARD_TYPE_OSN:\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
        "output": "0",
        "index": 28595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void StorageHandler::GetUsageAndQuota(\n     const String& origin,\n     std::unique_ptr<GetUsageAndQuotaCallback> callback) {\n  if (!process_)\n     return callback->sendFailure(Response::InternalError());\n \n   GURL origin_url(origin);\n  if (!origin_url.is_valid()) {\n    return callback->sendFailure(\n         Response::Error(origin + \" is not a valid URL\"));\n   }\n \n  storage::QuotaManager* manager =\n      process_->GetStoragePartition()->GetQuotaManager();\n   BrowserThread::PostTask(\n       BrowserThread::IO, FROM_HERE,\n       base::BindOnce(&GetUsageAndQuotaOnIOThread, base::RetainedRef(manager),\n                      origin_url, base::Passed(std::move(callback))));\n }\n",
        "output": "1",
        "index": 186750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_dpb(AVCodecContext *avctx)\n{\n    H264Context *h = avctx->priv_data;\n    int i;\n\n    for (i = 0; i <= MAX_DELAYED_PIC_COUNT; i++) {\n        if (h->delayed_pic[i])\n            h->delayed_pic[i]->reference = 0;\n        h->delayed_pic[i] = NULL;\n    }\n\n    flush_change(h);\n\n    if (h->DPB)\n        for (i = 0; i < MAX_PICTURE_COUNT; i++)\n            unref_picture(h, &h->DPB[i]);\n    h->cur_pic_ptr = NULL;\n    unref_picture(h, &h->cur_pic);\n\n    h->mb_x = h->mb_y = 0;\n\n    h->parse_context.state             = -1;\n    h->parse_context.frame_start_found = 0;\n    h->parse_context.overread          = 0;\n    h->parse_context.overread_index    = 0;\n    h->parse_context.index             = 0;\n    h->parse_context.last_index        = 0;\n}\n",
        "output": "0",
        "index": 28239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProfileSyncComponentsFactoryImpl::~ProfileSyncComponentsFactoryImpl() {\n}\n",
        "output": "0",
        "index": 97540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebLocalFrame* WebLocalFrame::CreateMainFrame(\n    WebView* web_view,\n    WebFrameClient* client,\n    InterfaceRegistry* interface_registry,\n    WebFrame* opener,\n    const WebString& name,\n    WebSandboxFlags sandbox_flags) {\n  return WebLocalFrameImpl::CreateMainFrame(\n      web_view, client, interface_registry, opener, name, sandbox_flags);\n}\n",
        "output": "0",
        "index": 146943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PermissionsData::CheckAPIPermissionWithParam(\n    APIPermission::ID permission,\n    const APIPermission::CheckParam* param) const {\n  return active_permissions()->CheckAPIPermissionWithParam(permission, param);\n}\n",
        "output": "0",
        "index": 129108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    virtual ~StubbornSpellCheckClient() { }\n",
        "output": "0",
        "index": 119553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BookmarkManagerView::PaintBackground(gfx::Canvas* canvas) {\n  canvas->drawColor(kBackgroundColorBottom, SkPorterDuff::kSrc_Mode);\n\n  SkPaint paint;\n  paint.setShader(skia::CreateGradientShader(0, kBackgroundGradientHeight,\n      kBackgroundColorTop,\n      kBackgroundColorBottom))->safeUnref();\n  canvas->FillRectInt(0, 0, width(), kBackgroundGradientHeight, paint);\n}\n",
        "output": "0",
        "index": 117371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ModuleExport size_t RegisterMVGImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"MVG\");\n  entry->decoder=(DecodeImageHandler *) ReadMVGImage;\n  entry->encoder=(EncodeImageHandler *) WriteMVGImage;\n  entry->magick=(IsImageFormatHandler *) IsMVG;\n  entry->adjoin=MagickFalse;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Magick Vector Graphics\");\n  entry->module=ConstantString(\"MVG\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "output": "0",
        "index": 71613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> unsignedLongLongSequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.unsignedLongLongSequenceAttr._get\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    return v8Array(imp->unsignedLongLongSequenceAttr(), info.GetIsolate());\n}\n",
        "output": "0",
        "index": 117885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::HandleBindAttribLocationBucket(\n    uint32 immediate_data_size, const gles2::BindAttribLocationBucket& c) {\n  GLuint program = static_cast<GLuint>(c.program);\n  GLuint index = static_cast<GLuint>(c.index);\n  Bucket* bucket = GetBucket(c.name_bucket_id);\n  if (!bucket || bucket->size() == 0) {\n    return error::kInvalidArguments;\n  }\n  std::string name_str;\n  if (!bucket->GetAsString(&name_str)) {\n    return error::kInvalidArguments;\n  }\n  DoBindAttribLocation(program, index, name_str.c_str());\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 110567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CrostiniUpgrader::Cancel() {\n  CrostiniManager::GetForProfile(profile_)->CancelUpgradeContainer(\n      container_id_, base::BindOnce(&CrostiniUpgrader::OnCancel,\n                                    weak_ptr_factory_.GetWeakPtr()));\n}\n",
        "output": "0",
        "index": 149266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPB_Flash_MessageLoop_Impl::RunFromHostProxy(\n    const RunFromHostProxyCallback& callback) {\n  InternalRun(callback);\n}\n",
        "output": "0",
        "index": 143759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ContentSecurityPolicy::HasPolicyFromSource(\n    ContentSecurityPolicyHeaderSource source) const {\n  for (const auto& policy : policies_) {\n    if (policy->HeaderSource() == source)\n      return true;\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 165523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BrandcodeConfigFetcher::BrandcodeConfigFetcher(\n    network::mojom::URLLoaderFactory* url_loader_factory,\n    const FetchCallback& callback,\n    const GURL& url,\n    const std::string& brandcode)\n    : fetch_callback_(callback) {\n  DCHECK(!brandcode.empty());\n  net::NetworkTrafficAnnotationTag traffic_annotation =\n      net::DefineNetworkTrafficAnnotation(\"brandcode_config\", R\"(\n        semantics {\n          sender: \"Brandcode Configuration Fetcher\"\n          description:\n            \"Chrome installation can be non-organic. That means that Chrome \"\n            \"is distributed by partners and it has a brand code associated \"\n            \"with that partner. For the settings reset operation, Chrome needs \"\n            \"to know the default settings which are partner specific.\"\n          trigger: \"'Reset Settings' invocation from Chrome settings.\"\n          data: \"Brandcode.\"\n          destination: GOOGLE_OWNED_SERVICE\n        }\n        policy {\n          cookies_allowed: NO\n          setting:\n            \"This feature cannot be disabled and is only invoked by user \"\n            \"request.\"\n          policy_exception_justification:\n            \"Not implemented, considered not useful as enterprises don't need \"\n            \"to install Chrome in a non-organic fashion.\"\n        })\");\n  auto resource_request = std::make_unique<network::ResourceRequest>();\n  resource_request->url = url;\n  resource_request->load_flags = net::LOAD_DO_NOT_SEND_COOKIES |\n                                 net::LOAD_DO_NOT_SAVE_COOKIES |\n                                 net::LOAD_DISABLE_CACHE;\n  resource_request->method = \"POST\";\n  resource_request->headers.SetHeader(\"Accept\", \"text/xml\");\n  simple_url_loader_ = network::SimpleURLLoader::Create(\n      std::move(resource_request), traffic_annotation);\n  simple_url_loader_->AttachStringForUpload(GetUploadData(brandcode),\n                                            \"text/xml\");\n  simple_url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(\n      url_loader_factory,\n      base::BindOnce(&BrandcodeConfigFetcher::OnSimpleLoaderComplete,\n                     base::Unretained(this)));\n  download_timer_.Start(FROM_HERE,\n                        base::TimeDelta::FromSeconds(kDownloadTimeoutSec),\n                        this,\n                        &BrandcodeConfigFetcher::OnDownloadTimeout);\n}\n",
        "output": "0",
        "index": 145600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_write(struct xdr_stream *xdr, const struct nfs_writeargs *args)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4);\n\tWRITE32(OP_WRITE);\n\n\tencode_stateid(xdr, args->context);\n\n\tRESERVE_SPACE(16);\n\tWRITE64(args->offset);\n\tWRITE32(args->stable);\n\tWRITE32(args->count);\n\n\txdr_write_pages(xdr, args->pages, args->pgbase, args->count);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 23093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_pts(int pts)\n{\n\tchar target[PATH_MAX];\n\n\tif (!pts)\n\t\treturn 0;\n\n\tif (!access(\"/dev/pts/ptmx\", F_OK) && umount(\"/dev/pts\")) {\n\t\tSYSERROR(\"failed to umount 'dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (mkdir(\"/dev/pts\", 0755)) {\n\t\tif ( errno != EEXIST ) {\n\t\t    SYSERROR(\"failed to create '/dev/pts'\");\n\t\t    return -1;\n\t\t}\n\t}\n\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,\n\t\t  \"newinstance,ptmxmode=0666,mode=0620,gid=5\")) {\n\t\tSYSERROR(\"failed to mount a new instance of '/dev/pts'\");\n\t\treturn -1;\n\t}\n\n\tif (access(\"/dev/ptmx\", F_OK)) {\n\t\tif (!symlink(\"/dev/pts/ptmx\", \"/dev/ptmx\"))\n\t\t\tgoto out;\n\t\tSYSERROR(\"failed to symlink '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tif (realpath(\"/dev/ptmx\", target) && !strcmp(target, \"/dev/pts/ptmx\"))\n\t\tgoto out;\n\n\t/* fallback here, /dev/pts/ptmx exists just mount bind */\n\tif (mount(\"/dev/pts/ptmx\", \"/dev/ptmx\", \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"mount failed '/dev/pts/ptmx'->'/dev/ptmx'\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"created new pts instance\");\n\nout:\n\treturn 0;\n}\n",
        "output": "0",
        "index": 44645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void t1_puts(PDF pdf, const char *s)\n{\n    if (s != t1_line_array)\n        strcpy(t1_line_array, s);\n    t1_line_ptr = strend(t1_line_array);\n    t1_putline(pdf);\n}\n",
        "output": "0",
        "index": 76702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_pe32_bytes(const ut8 *buf, ut64 length) {\n\tunsigned int idx;\n\tif (!buf || length <= 0x3d) {\n\t\treturn false;\n\t}\n\tidx = (buf[0x3c] | (buf[0x3d]<<8));\n\tif (length > idx + 0x18 + 2) {\n\t\tif (!memcmp (buf, \"MZ\", 2) && !memcmp (buf+idx, \"PE\", 2) && !memcmp (buf+idx+0x18, \"\\x0b\\x01\", 2)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n",
        "output": "0",
        "index": 79700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParseName(xmlParserCtxtPtr ctxt) {\n const xmlChar *in;\n const xmlChar *ret;\n int count = 0;\n\n    GROW;\n\n#ifdef DEBUG\n    nbParseName++;\n#endif\n\n /*\n     * Accelerator for simple ASCII names\n     */\n    in = ctxt->input->cur;\n if (((*in >= 0x61) && (*in <= 0x7A)) ||\n ((*in >= 0x41) && (*in <= 0x5A)) ||\n (*in == '_') || (*in == ':')) {\n\tin++;\n while (((*in >= 0x61) && (*in <= 0x7A)) ||\n ((*in >= 0x41) && (*in <= 0x5A)) ||\n ((*in >= 0x30) && (*in <= 0x39)) ||\n (*in == '_') || (*in == '-') ||\n (*in == ':') || (*in == '.'))\n\t    in++;\n if ((*in > 0) && (*in < 0x80)) {\n\t    count = in - ctxt->input->cur;\n if ((count > XML_MAX_NAME_LENGTH) &&\n ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"Name\");\n return(NULL);\n }\n\t    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n\t    ctxt->input->cur = in;\n\t    ctxt->nbChars += count;\n\t    ctxt->input->col += count;\n if (ret == NULL)\n\t        xmlErrMemory(ctxt, NULL);\n return(ret);\n }\n }\n /* accelerator for special cases */\n return(xmlParseNameComplex(ctxt));\n}\n",
        "output": "0",
        "index": 176656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ~SecurityState() {\n    storage::IsolatedContext* isolated_context =\n        storage::IsolatedContext::GetInstance();\n    for (FileSystemMap::iterator iter = filesystem_permissions_.begin();\n         iter != filesystem_permissions_.end();\n         ++iter) {\n      isolated_context->RemoveReference(iter->first);\n    }\n    UMA_HISTOGRAM_COUNTS_1M(\n        \"ChildProcessSecurityPolicy.PerChildFilePermissions\",\n        file_permissions_.size());\n  }\n",
        "output": "0",
        "index": 156563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPage::notificationClicked(const BlackBerry::Platform::String& notificationId)\n{\n#if ENABLE(NOTIFICATIONS) || ENABLE(LEGACY_NOTIFICATIONS)\n    d->notificationManager().notificationClicked(notificationId);\n#else\n    UNUSED_PARAM(notificationId);\n#endif\n}\n",
        "output": "0",
        "index": 111236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_unseal (minor_status,\n            context_handle,\n            input_message_buffer,\n            output_message_buffer,\n            conf_state,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\toutput_message_buffer;\nint *\t\t\tconf_state;\nint *\t\t\tqop_state;\n\n{\n    return (gss_unwrap(minor_status, context_handle,\n\t\t       input_message_buffer,\n\t\t       output_message_buffer, conf_state, (gss_qop_t *) qop_state));\n}\n",
        "output": "0",
        "index": 63346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *ping_v4_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn ping_seq_start(seq, pos, AF_INET);\n}\n",
        "output": "0",
        "index": 28393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long read_pmc(int idx)\n{\n\tunsigned long val;\n\n\tswitch (idx) {\n\tcase 1:\n\t\tval = mfspr(SPRN_PMC1);\n\t\tbreak;\n\tcase 2:\n\t\tval = mfspr(SPRN_PMC2);\n\t\tbreak;\n\tcase 3:\n\t\tval = mfspr(SPRN_PMC3);\n\t\tbreak;\n\tcase 4:\n\t\tval = mfspr(SPRN_PMC4);\n\t\tbreak;\n\tcase 5:\n\t\tval = mfspr(SPRN_PMC5);\n\t\tbreak;\n\tcase 6:\n\t\tval = mfspr(SPRN_PMC6);\n\t\tbreak;\n#ifdef CONFIG_PPC64\n\tcase 7:\n\t\tval = mfspr(SPRN_PMC7);\n\t\tbreak;\n\tcase 8:\n\t\tval = mfspr(SPRN_PMC8);\n\t\tbreak;\n#endif /* CONFIG_PPC64 */\n\tdefault:\n\t\tprintk(KERN_ERR \"oops trying to read PMC%d\\n\", idx);\n\t\tval = 0;\n\t}\n\treturn val;\n}\n",
        "output": "0",
        "index": 22705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lua_ivm_get(lua_State *L) \n{\n    const char *key, *raw_key;\n    apr_pool_t *pool;\n    lua_ivm_object *object = NULL;\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    key = luaL_checkstring(L, 2);\n    raw_key = apr_pstrcat(r->pool, \"lua_ivm_\", key, NULL);\n    apr_global_mutex_lock(lua_ivm_mutex);\n    pool = *((apr_pool_t**) apr_shm_baseaddr_get(lua_ivm_shm));\n    apr_pool_userdata_get((void **)&object, raw_key, pool);\n    if (object) {\n        if (object->type == LUA_TBOOLEAN) lua_pushboolean(L, (int) object->number);\n        else if (object->type == LUA_TNUMBER) lua_pushnumber(L, object->number);\n        else if (object->type == LUA_TSTRING) lua_pushlstring(L, object->vb.buf, object->size);\n        apr_global_mutex_unlock(lua_ivm_mutex);\n        return 1;\n    }\n    else {\n        apr_global_mutex_unlock(lua_ivm_mutex);\n        return 0;\n    }\n}\n",
        "output": "0",
        "index": 45101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JSValue jsTestObjShortSequenceAttr(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = jsArray(exec, castedThis->globalObject(), impl->shortSequenceAttr());\n    return result;\n}\n",
        "output": "0",
        "index": 106169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LocalDOMWindow* Document::defaultView() const {\n  return frame_ ? dom_window_ : nullptr;\n}\n",
        "output": "0",
        "index": 141324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void remove_from_net_schedule_list(struct xenvif *vif)\n{\n\tif (likely(__on_net_schedule_list(vif))) {\n\t\tlist_del_init(&vif->schedule_list);\n\t\txenvif_put(vif);\n\t}\n}\n",
        "output": "0",
        "index": 33994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NaClSubprocess* Plugin::LoadHelperNaClModule(nacl::DescWrapper* wrapper,\n                                             const Manifest* manifest,\n                                             ErrorInfo* error_info) {\n  nacl::scoped_ptr<NaClSubprocess> nacl_subprocess(\n      new NaClSubprocess(\"helper module\", NULL, NULL));\n  if (NULL == nacl_subprocess.get()) {\n    error_info->SetReport(ERROR_SEL_LDR_INIT,\n                          \"unable to allocate helper subprocess.\");\n    return NULL;\n  }\n\n  if (!LoadNaClModuleCommon(wrapper, nacl_subprocess.get(), manifest,\n                            false, error_info,\n                            pp::BlockUntilComplete(),\n                            pp::BlockUntilComplete())) {\n    return NULL;\n  }\n  if (!nacl_subprocess->StartSrpcServices()) {\n    error_info->SetReport(ERROR_SRPC_CONNECTION_FAIL,\n                          \"SRPC connection failure for \" +\n                          nacl_subprocess->description());\n    return NULL;\n  }\n\n  PLUGIN_PRINTF((\"Plugin::LoadHelperNaClModule (%s)\\n\",\n                 nacl_subprocess.get()->detailed_description().c_str()));\n\n  return nacl_subprocess.release();\n}\n",
        "output": "0",
        "index": 110316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OmniboxViewWin::OnPaint(HDC bogus_hdc) {\n\n  CRect paint_clip_rect;\n  if (!GetUpdateRect(&paint_clip_rect, true))\n    return;\n\n  CPaintDC paint_dc(m_hWnd);\n  CDC memory_dc(CreateCompatibleDC(paint_dc));\n  CRect rect;\n  GetClientRect(&rect);\n  CBitmap memory_bitmap(CreateCompatibleBitmap(paint_dc, rect.Width(),\n                                               rect.Height()));\n  HBITMAP old_bitmap = memory_dc.SelectBitmap(memory_bitmap);\n\n  HWND old_edit_hwnd = edit_hwnd;\n  edit_hwnd = m_hWnd;\n  paint_struct = paint_dc.m_ps;\n  paint_struct.hdc = memory_dc;\n  DefWindowProc(WM_PAINT, reinterpret_cast<WPARAM>(bogus_hdc), 0);\n\n  EraseTopOfSelection(&memory_dc, rect, paint_clip_rect);\n\n  if (insecure_scheme_component_.is_nonempty())\n    DrawSlashForInsecureScheme(memory_dc, rect, paint_clip_rect);\n\n  if (drop_highlight_position_ != -1)\n    DrawDropHighlight(memory_dc, rect, paint_clip_rect);\n\n  BitBlt(paint_dc, rect.left, rect.top, rect.Width(), rect.Height(), memory_dc,\n         rect.left, rect.top, SRCCOPY);\n  memory_dc.SelectBitmap(old_bitmap);\n  edit_hwnd = old_edit_hwnd;\n}\n",
        "output": "0",
        "index": 115257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PPB_URLLoader_API* PPB_URLLoader_Impl::AsPPB_URLLoader_API() {\n   return this;\n }\n",
        "output": "0",
        "index": 104880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MockContentSettingsClient::MockContentSettingsClient(\n    LayoutTestRuntimeFlags* layout_test_runtime_flags)\n    : delegate_(nullptr), flags_(layout_test_runtime_flags) {}\n",
        "output": "0",
        "index": 139906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int if6_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &if6_seq_ops,\n\t\t\t    sizeof(struct if6_iter_state));\n}\n",
        "output": "0",
        "index": 41819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ft_smooth_render_lcd( FT_Renderer       render,\n                        FT_GlyphSlot      slot,\n                        FT_Render_Mode    mode,\n                        const FT_Vector*  origin )\n  {\n    FT_Error  error;\n\n    error = ft_smooth_render_generic( render, slot, mode, origin,\n                                      FT_RENDER_MODE_LCD );\n    if ( !error )\n      slot->bitmap.pixel_mode = FT_PIXEL_MODE_LCD;\n\n    return error;\n  }\n",
        "output": "0",
        "index": 4203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int x86_pmu_commit_txn(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint assign[X86_PMC_IDX_MAX];\n\tint n, ret;\n\n\tn = cpuc->n_events;\n\n\tif (!x86_pmu_initialized())\n\t\treturn -EAGAIN;\n\n\tret = x86_pmu.schedule_events(cpuc, n, assign);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * copy new assignment, now we know it is possible\n\t * will be used by hw_perf_enable()\n\t */\n\tmemcpy(cpuc->assign, assign, n*sizeof(int));\n\n\tcpuc->group_flag &= ~PERF_EVENT_TXN;\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 25781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ColorChooser(content::ColorChooser* chooser,\n               blink::mojom::ColorChooserRequest request,\n               blink::mojom::ColorChooserClientPtr client)\n      : chooser_(chooser),\n        binding_(this, std::move(request)),\n        client_(std::move(client)) {\n    binding_.set_connection_error_handler(\n        base::BindOnce([](content::ColorChooser* chooser) { chooser->End(); },\n                       base::Unretained(chooser)));\n  }\n",
        "output": "0",
        "index": 157729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayerService::AudioOutput::start()\n{\n    ALOGV(\"start\");\n Mutex::Autolock lock(mLock);\n if (mCallbackData != NULL) {\n        mCallbackData->endTrackSwitch();\n }\n if (mTrack != 0) {\n        mTrack->setVolume(mLeftVolume, mRightVolume);\n        mTrack->setAuxEffectSendLevel(mSendLevel);\n return mTrack->start();\n }\n return NO_INIT;\n}\n",
        "output": "0",
        "index": 171220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::ImeCommitText(\n    const base::string16& text,\n    const std::vector<ui::ImeTextSpan>& ime_text_spans,\n    const gfx::Range& replacement_range,\n    int relative_cursor_pos) {\n  GetWidgetInputHandler()->ImeCommitText(\n      text, ime_text_spans, replacement_range, relative_cursor_pos);\n}\n",
        "output": "0",
        "index": 168752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool hal_open() {\n  LOG_INFO(\"%s\", __func__);\n\n int fd_array[CH_MAX];\n int number_of_ports = vendor->send_command(VENDOR_OPEN_USERIAL, &fd_array);\n\n if (number_of_ports != 1) {\n    LOG_ERROR(\"%s opened the wrong number of ports: got %d, expected 1.\", __func__, number_of_ports);\n goto error;\n }\n\n  uart_fd = fd_array[0];\n if (uart_fd == INVALID_FD) {\n    LOG_ERROR(\"%s unable to open the uart serial port.\", __func__);\n goto error;\n }\n\n  uart_stream = eager_reader_new(uart_fd, &allocator_malloc, HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX, \"hci_single_channel\");\n if (!uart_stream) {\n    LOG_ERROR(\"%s unable to create eager reader for the uart serial port.\", __func__);\n goto error;\n }\n\n  stream_has_interpretation = false;\n  stream_corruption_detected = false;\n  stream_corruption_bytes_to_ignore = 0;\n  eager_reader_register(uart_stream, thread_get_reactor(thread), event_uart_has_bytes, NULL);\n\n  thread_set_priority(thread, HCI_THREAD_PRIORITY);\n  thread_set_priority(eager_reader_get_read_thread(uart_stream), HCI_THREAD_PRIORITY);\n\n return true;\n\nerror:\n  interface.close();\n return false;\n}\n",
        "output": "0",
        "index": 172108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_ERR(TAG,  \"sending %\"PRIu16\" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s,\n\t\t                         FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n",
        "output": "0",
        "index": 83552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static inline void SetImpl(FixedArrayBase* backing_store, uint32_t entry,\n Object* value) {\n FixedArray::cast(backing_store)->set(entry, value);\n }\n",
        "output": "0",
        "index": 176346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int build_report(struct sk_buff *skb, u8 proto,\n\t\t\tstruct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct xfrm_user_report *ur;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_REPORT, sizeof(*ur), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tur = nlmsg_data(nlh);\n\tur->proto = proto;\n\tmemcpy(&ur->sel, sel, sizeof(ur->sel));\n\n\tif (addr) {\n\t\tint err = nla_put(skb, XFRMA_COADDR, sizeof(*addr), addr);\n\t\tif (err) {\n\t\t\tnlmsg_cancel(skb, nlh);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn nlmsg_end(skb, nlh);\n}\n",
        "output": "0",
        "index": 33093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_current_time(struct timeval *t)\n{\n#if defined(_WIN32)\n    SYSTEMTIME st;\n    union {\n        unsigned __int64 ul;\n        FILETIME ft;\n    } now;\n\n    GetSystemTime(&st);\n    SystemTimeToFileTime(&st, &now.ft);\n# ifdef  __MINGW32__\n    now.ul -= 116444736000000000ULL;\n# else\n    now.ul -= 116444736000000000UI64; /* re-bias to 1/1/1970 */\n# endif\n    t->tv_sec = (long)(now.ul / 10000000);\n    t->tv_usec = ((int)(now.ul % 10000000)) / 10;\n#elif defined(OPENSSL_SYS_VMS)\n    struct timeb tb;\n    ftime(&tb);\n    t->tv_sec = (long)tb.time;\n    t->tv_usec = (long)tb.millitm * 1000;\n#else\n    gettimeofday(t, NULL);\n#endif\n}\n",
        "output": "0",
        "index": 6501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ServiceWorkerProviderHost* ServiceWorkerContextCore::GetProviderHost(\n    int provider_id) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  auto found = providers_->find(provider_id);\n  if (found == providers_->end())\n    return nullptr;\n  return found->second.get();\n}\n",
        "output": "0",
        "index": 152139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nl_msg_dump(struct nl_msg *msg, FILE *ofd)\n{\n\tstruct nlmsghdr *hdr = nlmsg_hdr(msg);\n\t\n\tfprintf(ofd, \n\t\"--------------------------   BEGIN NETLINK MESSAGE ---------------------------\\n\");\n\n\tfprintf(ofd, \"  [NETLINK HEADER] %zu octets\\n\", sizeof(struct nlmsghdr));\n\tprint_hdr(ofd, msg);\n\n\tif (hdr->nlmsg_type == NLMSG_ERROR)\n\t\tdump_error_msg(msg, ofd);\n\telse if (nlmsg_len(hdr) > 0)\n\t\tprint_msg(msg, ofd, hdr);\n\n\tfprintf(ofd, \n\t\"---------------------------  END NETLINK MESSAGE   ---------------------------\\n\");\n}\n",
        "output": "0",
        "index": 12898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "float AXNodeObject::minValueForRange() const {\n  if (hasAttribute(aria_valueminAttr))\n    return getAttribute(aria_valueminAttr).toFloat();\n\n  if (isNativeSlider())\n    return toHTMLInputElement(*getNode()).minimum();\n\n  if (isHTMLMeterElement(getNode()))\n    return toHTMLMeterElement(*getNode()).min();\n\n  return 0.0;\n}\n",
        "output": "0",
        "index": 138094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(openssl_random_pseudo_bytes)\n{\n        long buffer_length;\n        unsigned char *buffer = NULL;\n        zval *zstrong_result_returned = NULL;\n       int strong_result = 0;\n \n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &buffer_length, &zstrong_result_returned) == FAILURE) {\n                return;\n\t\treturn;\n\t}\n\n\tif (buffer_length <= 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zstrong_result_returned) {\n\t\tzval_dtor(zstrong_result_returned);\n\t\tZVAL_BOOL(zstrong_result_returned, 0);\n\t}\n        buffer = emalloc(buffer_length + 1);\n \n #ifdef PHP_WIN32\n       strong_result = 1;\n        /* random/urandom equivalent on Windows */\n        if (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {\n                efree(buffer);\n\tif (php_win32_get_random_bytes(buffer, (size_t) buffer_length) == FAILURE) {\n\t\tefree(buffer);\n\t\tif (zstrong_result_returned) {\n                RETURN_FALSE;\n        }\n #else\n       if ((strong_result = RAND_pseudo_bytes(buffer, buffer_length)) < 0) {\n                efree(buffer);\n                if (zstrong_result_returned) {\n                        ZVAL_BOOL(zstrong_result_returned, 0);\n\t\tif (zstrong_result_returned) {\n\t\t\tZVAL_BOOL(zstrong_result_returned, 0);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n#endif\n        RETVAL_STRINGL((char *)buffer, buffer_length, 0);\n \n        if (zstrong_result_returned) {\n               ZVAL_BOOL(zstrong_result_returned, strong_result);\n        }\n }\n /* }}} */\n",
        "output": "1",
        "index": 178444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EXPORTED int mboxlist_unsetquota(const char *root)\n{\n    struct quota q;\n    int r=0;\n\n    if (!root[0] || root[0] == '.' || strchr(root, '/')\n        || strchr(root, '*') || strchr(root, '%') || strchr(root, '?')) {\n        return IMAP_MAILBOX_BADNAME;\n    }\n\n    quota_init(&q, root);\n    r = quota_read(&q, NULL, 0);\n    /* already unset */\n    if (r == IMAP_QUOTAROOT_NONEXISTENT) {\n        r = 0;\n        goto done;\n    }\n    if (r) goto done;\n\n    r = quota_changelock();\n\n    /*\n     * Have to remove it from all affected mailboxes\n     */\n    mboxlist_mboxtree(root, mboxlist_rmquota, (void *)root, /*flags*/0);\n\n    r = quota_deleteroot(root);\n    quota_changelockrelease();\n\n    if (!r) sync_log_quota(root);\n\n done:\n    quota_free(&q);\n    return r;\n}\n",
        "output": "0",
        "index": 61300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint n = 0;\n\tstruct genl_family *rt;\n\tstruct net *net = sock_net(skb->sk);\n\tint fams_to_skip = cb->args[0];\n\tunsigned int id;\n\n\tidr_for_each_entry(&genl_fam_idr, rt, id) {\n\t\tif (!rt->netnsok && !net_eq(net, &init_net))\n\t\t\tcontinue;\n\n\t\tif (n++ < fams_to_skip)\n\t\t\tcontinue;\n\n\t\tif (ctrl_fill_info(rt, NETLINK_CB(cb->skb).portid,\n\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t   skb, CTRL_CMD_NEWFAMILY) < 0) {\n\t\t\tn--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[0] = n;\n\treturn skb->len;\n}\n",
        "output": "0",
        "index": 88031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_arg_pair_ok(const struct bpf_func_proto *fn)\n{\n\t/* bpf_xxx(..., buf, len) call will access 'len'\n\t * bytes from memory 'buf'. Both arg types need\n\t * to be paired, so make sure there's no buggy\n\t * helper function specification.\n\t */\n\tif (arg_type_is_mem_size(fn->arg1_type) ||\n\t    arg_type_is_mem_ptr(fn->arg5_type)  ||\n\t    check_args_pair_invalid(fn->arg1_type, fn->arg2_type) ||\n\t    check_args_pair_invalid(fn->arg2_type, fn->arg3_type) ||\n\t    check_args_pair_invalid(fn->arg3_type, fn->arg4_type) ||\n\t    check_args_pair_invalid(fn->arg4_type, fn->arg5_type))\n\t\treturn false;\n\n\treturn true;\n}\n",
        "output": "0",
        "index": 76364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reinit_sched_domains(void)\n{\n\tget_online_cpus();\n\n\t/* Destroy domains first to force the rebuild */\n\tpartition_sched_domains(0, NULL, NULL);\n\n\trebuild_sched_domains();\n\tput_online_cpus();\n}\n",
        "output": "0",
        "index": 26319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_to_header_rcpt_addrs(smtp_t *smtp)\n{\n\tchar *fetched_email;\n\tchar *email_to_addrs;\n\tsize_t bytes_available = SMTP_BUFFER_MAX - 1;\n\tsize_t bytes_to_write;\n\n\tif (smtp == NULL)\n\t\treturn;\n\n\temail_to_addrs = smtp->email_to;\n\tsmtp->email_it = 0;\n\n\twhile (1) {\n\t\tfetched_email = fetch_next_email(smtp);\n\t\tif (fetched_email == NULL)\n\t\t\tbreak;\n\n\t\tbytes_to_write = strlen(fetched_email);\n\t\tif (!smtp->email_it) {\n\t\t\tif (bytes_available < bytes_to_write)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (bytes_available < 2 + bytes_to_write)\n\t\t\t\tbreak;\n\n\t\t\t/* Prepend with a comma and space to all non-first email addresses */\n\t\t\t*email_to_addrs++ = ',';\n\t\t\t*email_to_addrs++ = ' ';\n\t\t\tbytes_available -= 2;\n\t\t}\n\n\t\tif (snprintf(email_to_addrs, bytes_to_write + 1, \"%s\", fetched_email) != (int)bytes_to_write) {\n\t\t\t/* Inconsistent state, no choice but to break here and do nothing */\n\t\t\tbreak;\n\t\t}\n\n\t\temail_to_addrs += bytes_to_write;\n\t\tbytes_available -= bytes_to_write;\n\t\tsmtp->email_it++;\n\t}\n\n\tsmtp->email_it = 0;\n}\n",
        "output": "0",
        "index": 75923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void voidMethodStringArgVariadicStringArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"voidMethodStringArgVariadicStringArg\", \"TestObjectPython\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, stringArg, info[0]);\n    V8TRYCATCH_VOID(Vector<String>, variadicStringArgs, toNativeArguments<String>(info, 1));\n    imp->voidMethodStringArgVariadicStringArg(stringArg, variadicStringArgs);\n}\n",
        "output": "0",
        "index": 131967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::ResolveScheduledPlayPromises() {\n  for (auto& resolver : play_promise_resolve_list_)\n    resolver->Resolve();\n\n  play_promise_resolve_list_.clear();\n}\n",
        "output": "0",
        "index": 142882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebDevToolsAgentImpl::didCreateScriptContext(WebLocalFrameImpl* webframe, int worldId)\n{\n    if (worldId)\n        return;\n    if (WebCore::LocalFrame* frame = webframe->frame())\n        frame->script().setContextDebugId(m_hostId);\n}\n",
        "output": "0",
        "index": 122548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)\n{\n\tu_char buf[4096];\n\tint r, status;\n\n\tif (ssh->state->compression_out_started != 1)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\n\t/* This case is not handled below. */\n\tif (sshbuf_len(in) == 0)\n\t\treturn 0;\n\n\t/* Input is the contents of the input buffer. */\n\tif ((ssh->state->compression_out_stream.next_in =\n\t    sshbuf_mutable_ptr(in)) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tssh->state->compression_out_stream.avail_in = sshbuf_len(in);\n\n\t/* Loop compressing until deflate() returns with avail_out != 0. */\n\tdo {\n\t\t/* Set up fixed-size output buffer. */\n\t\tssh->state->compression_out_stream.next_out = buf;\n\t\tssh->state->compression_out_stream.avail_out = sizeof(buf);\n\n\t\t/* Compress as much data into the buffer as possible. */\n\t\tstatus = deflate(&ssh->state->compression_out_stream,\n\t\t    Z_PARTIAL_FLUSH);\n\t\tswitch (status) {\n\t\tcase Z_MEM_ERROR:\n\t\t\treturn SSH_ERR_ALLOC_FAIL;\n\t\tcase Z_OK:\n\t\t\t/* Append compressed data to output_buffer. */\n\t\t\tif ((r = sshbuf_put(out, buf, sizeof(buf) -\n\t\t\t    ssh->state->compression_out_stream.avail_out)) != 0)\n\t\t\t\treturn r;\n\t\t\tbreak;\n\t\tcase Z_STREAM_ERROR:\n\t\tdefault:\n\t\t\tssh->state->compression_out_failures++;\n\t\t\treturn SSH_ERR_INVALID_FORMAT;\n\t\t}\n\t} while (ssh->state->compression_out_stream.avail_out == 0);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 12943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HostCache::RecordErase(EraseReason reason,\n                            base::TimeTicks now,\n                            const Entry& entry) {\n  HostCache::EntryStaleness stale;\n  entry.GetStaleness(now, network_changes_, &stale);\n  CACHE_HISTOGRAM_ENUM(\"Erase\", reason, MAX_ERASE_REASON);\n  if (stale.is_stale()) {\n    CACHE_HISTOGRAM_TIME(\"EraseStale.ExpiredBy\", stale.expired_by);\n    CACHE_HISTOGRAM_COUNT(\"EraseStale.NetworkChanges\", stale.network_changes);\n    CACHE_HISTOGRAM_COUNT(\"EraseStale.StaleHits\", entry.stale_hits());\n  } else {\n    CACHE_HISTOGRAM_TIME(\"EraseValid.ValidFor\", -stale.expired_by);\n  }\n}\n",
        "output": "0",
        "index": 139354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_machine_state()\n{\n\tchar* state_str = NULL;\n\tState s;\n\n\tReliSock* sock;\n\tDaemon my_startd( DT_STARTD );\n\tif( ! my_startd.locate() ) {\n\t\tdprintf( D_ALWAYS, \"Can't find local startd address.\\n\" );\n\t\treturn _error_state_;\n\t}\n   \n\tif( !(sock = (ReliSock*)\n\t\t  my_startd.startCommand(GIVE_STATE, Stream::reli_sock, 0)) ) {\n\t\tdprintf( D_ALWAYS, \"Can't connect to startd at %s\\n\", \n\t\t\t\t my_startd.addr() );\n\t\treturn _error_state_;\n\t}\n\n\tsock->end_of_message();\n\tsock->decode();\n\tif( !sock->code( state_str ) || !sock->end_of_message() ) {\n\t\tdprintf( D_ALWAYS, \"Can't read state/eom from startd.\\n\" );\n\t\tfree(state_str);\n\t\treturn _error_state_;\n\t}\n\n\tsock->close();\n\tdelete sock;\n\n\ts = string_to_state( state_str );\n\tfree(state_str);\n\treturn s;\n}\n",
        "output": "0",
        "index": 16467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TransportDIB::Map() {\n  if (!is_valid_id(key_))\n    return false;\n  if (address_ != kInvalidAddress)\n    return true;\n\n  struct shmid_ds shmst;\n  if (shmctl(key_.shmkey, IPC_STAT, &shmst) == -1)\n    return false;\n\n  void* address = shmat(key_.shmkey, NULL /* desired address */, 0 /* flags */);\n  if (address == kInvalidAddress)\n    return false;\n\n  address_ = address;\n  size_ = shmst.shm_segsz;\n  return true;\n}\n",
        "output": "0",
        "index": 127659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct pdf_object *pdf_find_last_object(struct pdf_doc *pdf,\n        int type)\n{\n    return pdf->last_objects[type];\n}\n",
        "output": "0",
        "index": 83009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Image CreateImage(SkColor color) {\n  SkBitmap bitmap;\n  bitmap.allocN32Pixels(1, 1);\n  bitmap.eraseColor(color);\n  return gfx::Image::CreateFrom1xBitmap(bitmap);\n}\n",
        "output": "0",
        "index": 157684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Node* RenderBlock::nodeForHitTest() const\n{\n    return isAnonymousBlockContinuation() ? continuation()->node() : node();\n}\n",
        "output": "0",
        "index": 124598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ChromotingInstance::OnConnectionState(\n     protocol::ConnectionToHost::State state,\n     protocol::ErrorCode error) {\n  scoped_ptr<base::DictionaryValue> data(new base::DictionaryValue());\n  data->SetString(\"state\", ConnectionStateToString(state));\n  data->SetString(\"error\", ConnectionErrorToString(error));\n  PostLegacyJsonMessage(\"onConnectionStatus\", data.Pass());\n}\n",
        "output": "0",
        "index": 132741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t\t/* if copy is defined the driver will be required to copy\n\t\t * the data from core\n\t\t */\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int airo_get_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tstrncpy(extra, local->config.nodeName, 16);\n\textra[16] = '\\0';\n\tdwrq->length = strlen(extra);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 23956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t ProCamera2Client::submitRequest(camera_metadata_t* request,\n bool streaming) {\n    ATRACE_CALL();\n    ALOGV(\"%s\", __FUNCTION__);\n\n Mutex::Autolock icl(mBinderSerializationLock);\n\n if (!mDevice.get()) return DEAD_OBJECT;\n\n if (!mExclusiveLock) {\n return PERMISSION_DENIED;\n }\n\n CameraMetadata metadata(request);\n\n if (!enforceRequestPermissions(metadata)) {\n return PERMISSION_DENIED;\n }\n\n if (streaming) {\n return mDevice->setStreamingRequest(metadata);\n } else {\n return mDevice->capture(metadata);\n }\n\n return OK;\n}\n",
        "output": "0",
        "index": 175012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unblock_all_signals(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&current->sighand->siglock, flags);\n\tcurrent->notifier = NULL;\n\tcurrent->notifier_data = NULL;\n\trecalc_sigpending();\n\tspin_unlock_irqrestore(&current->sighand->siglock, flags);\n}\n",
        "output": "0",
        "index": 31815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AfterTranslateInfoBar::ButtonPressed(views::Button* sender,\n                                          const views::Event& event) {\n  if (sender == revert_button_) {\n    GetDelegate()->RevertTranslation();\n    return;\n  }\n  TranslateInfoBarBase::ButtonPressed(sender, event);\n}\n",
        "output": "0",
        "index": 107896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rds_ib_nodev_connect(void)\n{\n\tstruct rds_ib_connection *ic;\n\n\tspin_lock(&ib_nodev_conns_lock);\n\tlist_for_each_entry(ic, &ib_nodev_conns, ib_node)\n\t\trds_conn_connect_if_down(ic->conn);\n\tspin_unlock(&ib_nodev_conns_lock);\n}\n",
        "output": "0",
        "index": 40111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_dev(struct mapped_device *md)\n{\n\tint minor = MINOR(disk_devt(md->disk));\n\n\tunlock_fs(md);\n\n\tcleanup_mapped_device(md);\n\n\tfree_table_devices(&md->table_devices);\n\tdm_stats_cleanup(&md->stats);\n\tfree_minor(minor);\n\n\tmodule_put(THIS_MODULE);\n\tkvfree(md);\n}\n",
        "output": "0",
        "index": 85951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_get_ilocked(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_da_args\t*args)\n{\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\n\tif (!xfs_inode_hasattr(ip))\n\t\treturn -ENOATTR;\n\telse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\n\t\treturn xfs_attr_shortform_getvalue(args);\n\telse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\n\t\treturn xfs_attr_leaf_get(args);\n\telse\n\t\treturn xfs_attr_node_get(args);\n}\n",
        "output": "0",
        "index": 76317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::dispatchIntent(\n    WebFrame* frame, const WebIntentRequest& intentRequest) {\n  webkit_glue::WebIntentData intent_data(intentRequest.intent());\n  int id = intents_host_->RegisterWebIntent(intentRequest);\n  Send(new IntentsHostMsg_WebIntentDispatch(\n      routing_id_, intent_data, id));\n}\n",
        "output": "0",
        "index": 116687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " Encoder* ChromotingHost::CreateEncoder(const protocol::SessionConfig& config) {\n   const protocol::ChannelConfig& video_config = config.video_config();\n\n  if (video_config.codec == protocol::ChannelConfig::CODEC_VERBATIM) {\n    return EncoderRowBased::CreateVerbatimEncoder();\n  } else if (video_config.codec == protocol::ChannelConfig::CODEC_ZIP) {\n    return EncoderRowBased::CreateZlibEncoder();\n  } else if (video_config.codec == protocol::ChannelConfig::CODEC_VP8) {\n    return new remoting::EncoderVp8();\n  }\n\n  return NULL;\n}\n",
        "output": "0",
        "index": 115646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    ~UserCloudPolicyManagerFactoryChromeOS() {}\n",
        "output": "0",
        "index": 118669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrLocationSetMerge(xmlLocationSetPtr val1, xmlLocationSetPtr val2) {\n    int i;\n\n    if (val1 == NULL) return(NULL);\n    if (val2 == NULL) return(val1);\n\n    /*\n     * !!!!! this can be optimized a lot, knowing that both\n     *       val1 and val2 already have unicity of their values.\n     */\n\n    for (i = 0;i < val2->locNr;i++)\n        xmlXPtrLocationSetAdd(val1, val2->locTab[i]);\n\n    return(val1);\n}\n",
        "output": "0",
        "index": 117320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static freelist_idx_t next_random_slot(union freelist_init_state *state)\n {\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n }\n",
        "output": "1",
        "index": 181569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CameraClient::handleGenericData(int32_t msgType,\n const sp<IMemory>& dataPtr, camera_frame_metadata_t *metadata) {\n    sp<ICameraClient> c = mRemoteCallback;\n    mLock.unlock();\n if (c != 0) {\n        c->dataCallback(msgType, dataPtr, metadata);\n }\n}\n",
        "output": "0",
        "index": 174950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::HandleGetUniformIndices(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  if (!feature_info_->IsWebGL2OrES3Context())\n    return error::kUnknownCommand;\n  const volatile gles2::cmds::GetUniformIndices& c =\n      *static_cast<const volatile gles2::cmds::GetUniformIndices*>(cmd_data);\n  Bucket* bucket = GetBucket(c.names_bucket_id);\n  if (!bucket) {\n    return error::kInvalidArguments;\n  }\n  GLsizei count = 0;\n  std::vector<char*> names;\n  std::vector<GLint> len;\n  if (!bucket->GetAsStrings(&count, &names, &len) || count <= 0) {\n    return error::kInvalidArguments;\n  }\n  typedef cmds::GetUniformIndices::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.indices_shm_id, c.indices_shm_offset,\n      Result::ComputeSize(static_cast<size_t>(count)));\n  GLuint* indices = result ? result->GetData() : nullptr;\n  if (indices == nullptr) {\n    return error::kOutOfBounds;\n  }\n  if (result->size != 0) {\n    return error::kInvalidArguments;\n  }\n  Program* program = GetProgramInfoNotShader(c.program, \"glGetUniformIndices\");\n  if (!program) {\n    return error::kNoError;\n  }\n  GLuint service_id = program->service_id();\n  GLint link_status = GL_FALSE;\n  api()->glGetProgramivFn(service_id, GL_LINK_STATUS, &link_status);\n  if (link_status != GL_TRUE) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n        \"glGetUniformIndices\", \"program not linked\");\n    return error::kNoError;\n  }\n  LOCAL_COPY_REAL_GL_ERRORS_TO_WRAPPER(\"GetUniformIndices\");\n  api()->glGetUniformIndicesFn(service_id, count, &names[0], indices);\n  GLenum error = api()->glGetErrorFn();\n  if (error == GL_NO_ERROR) {\n    result->SetNumResults(count);\n  } else {\n    LOCAL_SET_GL_ERROR(error, \"GetUniformIndices\", \"\");\n  }\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 158719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ShelfWidget* GetShelfWidget() {\n  return AshTestBase::GetPrimaryShelf()->shelf_widget();\n}\n",
        "output": "0",
        "index": 142508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLInputElement::SetSuggestedValue(const String& value) {\n  if (!input_type_->CanSetSuggestedValue())\n    return;\n  needs_to_update_view_value_ = true;\n  TextControlElement::SetSuggestedValue(SanitizeValue(value));\n  SetNeedsStyleRecalc(\n      kSubtreeStyleChange,\n      StyleChangeReasonForTracing::Create(StyleChangeReason::kControlValue));\n  input_type_view_->UpdateView();\n}\n",
        "output": "0",
        "index": 136969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n{\n    ssize_t ret;\n    guint watch;\n    assert(qemu_in_coroutine());\n    /* Negotiation are always in main loop. */\n    watch = qio_channel_add_watch(ioc,\n                                  G_IO_IN,\n                                  nbd_negotiate_continue,\n                                  qemu_coroutine_self(),\n                                  NULL);\n    ret = nbd_read(ioc, buffer, size, NULL);\n    g_source_remove(watch);\n    return ret;\n}\n",
        "output": "1",
        "index": 178626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DocumentModuleScriptFetcher::Fetch(FetchParameters& fetch_params,\n                                        ModuleScriptFetcher::Client* client) {\n  SetClient(client);\n  ScriptResource::Fetch(fetch_params, fetcher_, this);\n}\n",
        "output": "0",
        "index": 162448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cdrom_update_settings(void)\n{\n\tstruct cdrom_device_info *cdi;\n\n\tmutex_lock(&cdrom_mutex);\n\tlist_for_each_entry(cdi, &cdrom_list, list) {\n\t\tif (autoclose && CDROM_CAN(CDC_CLOSE_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_CLOSE;\n\t\telse if (!autoclose)\n\t\t\tcdi->options &= ~CDO_AUTO_CLOSE;\n\t\tif (autoeject && CDROM_CAN(CDC_OPEN_TRAY))\n\t\t\tcdi->options |= CDO_AUTO_EJECT;\n\t\telse if (!autoeject)\n\t\t\tcdi->options &= ~CDO_AUTO_EJECT;\n\t\tif (lockdoor && CDROM_CAN(CDC_LOCK))\n\t\t\tcdi->options |= CDO_LOCK;\n\t\telse if (!lockdoor)\n\t\t\tcdi->options &= ~CDO_LOCK;\n\t\tif (check_media_type)\n\t\t\tcdi->options |= CDO_CHECK_TYPE;\n\t\telse\n\t\t\tcdi->options &= ~CDO_CHECK_TYPE;\n\t}\n\tmutex_unlock(&cdrom_mutex);\n}\n",
        "output": "0",
        "index": 76283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GfxImageColorMap::getCMYK(Guchar *x, GfxCMYK *cmyk) {\n  GfxColor color;\n  int i;\n\n  if (colorSpace2) {\n    for (i = 0; i < nComps2; ++i) {\n      color.c[i] = lookup[i][x[0]];\n    }\n    colorSpace2->getCMYK(&color, cmyk);\n  } else {\n    for (i = 0; i < nComps; ++i) {\n      color.c[i] = lookup[i][x[i]];\n    }\n    colorSpace->getCMYK(&color, cmyk);\n  }\n}\n",
        "output": "0",
        "index": 1022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TEE_Result op_attr_bignum_from_obj(void *attr, void *src_attr)\n{\n\tstruct bignum **bn = attr;\n\tstruct bignum **src_bn = src_attr;\n\n\tcrypto_bignum_copy(*bn, *src_bn);\n\treturn TEE_SUCCESS;\n}\n",
        "output": "0",
        "index": 86840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoaderClient::didChangeTitle(WebCore::DocumentLoader *l)\n{\n    setTitle(l->title(), l->url());\n}\n",
        "output": "0",
        "index": 98288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_cmd_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}\n",
        "output": "0",
        "index": 85377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_mp_unreach_parse (struct bgp_attr_parser_args *args,\n\t\t      struct bgp_nlri *mp_withdraw)\n{\n  struct stream *s;\n  afi_t afi;\n  safi_t safi;\n  u_int16_t withdraw_len;\n  int ret;\n  struct peer *const peer = args->peer;  \n  const bgp_size_t length = args->length;\n\n  s = peer->ibuf;\n  \n#define BGP_MP_UNREACH_MIN_SIZE 3\n  if ((length > STREAM_READABLE(s)) || (length <  BGP_MP_UNREACH_MIN_SIZE))\n    return BGP_ATTR_PARSE_ERROR;\n  \n  afi = stream_getw (s);\n  safi = stream_getc (s);\n  \n  withdraw_len = length - BGP_MP_UNREACH_MIN_SIZE;\n\n  if (safi != SAFI_MPLS_LABELED_VPN)\n    {\n      ret = bgp_nlri_sanity_check (peer, afi, stream_pnt (s), withdraw_len);\n      if (ret < 0)\n\treturn BGP_ATTR_PARSE_ERROR;\n    }\n\n  mp_withdraw->afi = afi;\n  mp_withdraw->safi = safi;\n  mp_withdraw->nlri = stream_pnt (s);\n  mp_withdraw->length = withdraw_len;\n\n  stream_forward_getp (s, withdraw_len);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}\n",
        "output": "0",
        "index": 270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_policy_nodemask(struct mempolicy *p, nodemask_t *nodes)\n{\n\tnodes_clear(*nodes);\n\tif (p == &default_policy)\n\t\treturn;\n\n\tswitch (p->mode) {\n\tcase MPOL_BIND:\n\t\t/* Fall through */\n\tcase MPOL_INTERLEAVE:\n\t\t*nodes = p->v.nodes;\n\t\tbreak;\n\tcase MPOL_PREFERRED:\n\t\tif (!(p->flags & MPOL_F_LOCAL))\n\t\t\tnode_set(p->v.preferred_node, *nodes);\n\t\t/* else return empty node mask for local allocation */\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n",
        "output": "0",
        "index": 21309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ShadowRoot::~ShadowRoot()\n{\n    ASSERT(!m_prev);\n    ASSERT(!m_next);\n\n    if (hasRareData())\n        clearRareData();\n}\n",
        "output": "0",
        "index": 105179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fz_set_icc_bgr(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_iccprofile *profile;\n\n\tif (cs == NULL || !fz_colorspace_is_icc(ctx, cs))\n\t\treturn;\n\n\tprofile = cs->data;\n\tprofile->bgr = 1;\n\treturn;\n}\n",
        "output": "0",
        "index": 407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PaintLayerScrollableArea::ShouldSuspendScrollAnimations() const {\n  if (HasBeenDisposed())\n    return true;\n  LayoutView* view = GetLayoutBox()->View();\n  if (!view)\n    return true;\n  return !GetLayoutBox()->GetDocument().LoadEventFinished();\n}\n",
        "output": "0",
        "index": 141504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrEndPointFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlXPathObjectPtr tmp, obj, point;\n    xmlLocationSetPtr newset = NULL;\n    xmlLocationSetPtr oldset = NULL;\n\n    CHECK_ARITY(1);\n    if ((ctxt->value == NULL) ||\n\t((ctxt->value->type != XPATH_LOCATIONSET) &&\n\t (ctxt->value->type != XPATH_NODESET)))\n        XP_ERROR(XPATH_INVALID_TYPE)\n\n    obj = valuePop(ctxt);\n    if (obj->type == XPATH_NODESET) {\n\t/*\n\t * First convert to a location set\n\t */\n\ttmp = xmlXPtrNewLocationSetNodeSet(obj->nodesetval);\n\txmlXPathFreeObject(obj);\n\tobj = tmp;\n    }\n\n    newset = xmlXPtrLocationSetCreate(NULL);\n    oldset = (xmlLocationSetPtr) obj->user;\n    if (oldset != NULL) {\n\tint i;\n\n\tfor (i = 0; i < oldset->locNr; i++) {\n\t    tmp = oldset->locTab[i];\n\t    if (tmp == NULL)\n\t\tcontinue;\n\t    point = NULL;\n\t    switch (tmp->type) {\n\t\tcase XPATH_POINT:\n\t\t    point = xmlXPtrNewPoint(tmp->user, tmp->index);\n\t\t    break;\n\t\tcase XPATH_RANGE: {\n\t\t    xmlNodePtr node = tmp->user2;\n\t\t    if (node != NULL) {\n\t\t\tif (node->type == XML_ATTRIBUTE_NODE) {\n\t\t\t    /* TODO: Namespace Nodes ??? */\n\t\t\t    xmlXPathFreeObject(obj);\n\t\t\t    xmlXPtrFreeLocationSet(newset);\n\t\t\t    XP_ERROR(XPTR_SYNTAX_ERROR);\n\t\t\t}\n\t\t\tpoint = xmlXPtrNewPoint(node, tmp->index2);\n\t\t    } else if (tmp->user == NULL) {\n\t\t\tpoint = xmlXPtrNewPoint(node,\n\t\t\t\t       xmlXPtrNbLocChildren(node));\n\t\t    }\n\t\t    break;\n\t        }\n\t\tdefault:\n\t\t    /*** Should we raise an error ?\n\t\t    xmlXPathFreeObject(obj);\n\t\t    xmlXPathFreeObject(newset);\n\t\t    XP_ERROR(XPATH_INVALID_TYPE)\n\t\t    ***/\n\t\t    break;\n\t    }\n            if (point != NULL)\n\t\txmlXPtrLocationSetAdd(newset, point);\n\t}\n    }\n    xmlXPathFreeObject(obj);\n    valuePush(ctxt, xmlXPtrWrapLocationSet(newset));\n}\n",
        "output": "0",
        "index": 117299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::Close(RenderViewHost* rvh) {\n#if defined(OS_MACOSX)\n  if (view_->IsEventTracking()) {\n    view_->CloseTabAfterEventTracking();\n    return;\n  }\n#endif\n\n  if (delegate_ && rvh == GetRenderViewHost())\n    delegate_->CloseContents(this);\n}\n",
        "output": "0",
        "index": 118823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual bool GetCellColors(int model_row,\n                             int column,\n                             ItemColor* foreground,\n                             ItemColor* background,\n                             LOGFONT* logfont) {\n    if (!model_->IsBackgroundResource(model_row))\n      return false;\n\n    background->color_is_set = true;\n    background->color = kBackgroundResourceHighlight;\n    foreground->color_is_set = false;\n    return true;\n  }\n",
        "output": "0",
        "index": 114042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fz_rendering_intent_name(int ri)\n{\n\tif (ri >= 0 && ri < nelem(fz_intent_names))\n\t\treturn (char*)fz_intent_names[ri];\n\treturn \"RelativeColorimetric\";\n}\n",
        "output": "0",
        "index": 402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool isValidNameStart(UChar32 c)\n{\n    if ((c >= 0x02BB && c <= 0x02C1) || c == 0x559 || c == 0x6E5 || c == 0x6E6)\n        return true;\n\n    if (c == ':' || c == '_')\n        return true;\n\n    const uint32_t nameStartMask = Letter_Lowercase | Letter_Uppercase | Letter_Other | Letter_Titlecase | Number_Letter;\n    if (!(Unicode::category(c) & nameStartMask))\n        return false;\n\n    if (c >= 0xF900 && c < 0xFFFE)\n        return false;\n\n    CharDecompositionType decompType = decompositionType(c);\n    if (decompType == DecompositionFont || decompType == DecompositionCompat)\n        return false;\n\n    return true;\n}\n",
        "output": "0",
        "index": 135291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "efx_ethtool_get_rxnfc(struct net_device *net_dev,\n\t\t      struct ethtool_rxnfc *info, u32 *rules __always_unused)\n{\n\tstruct efx_nic *efx = netdev_priv(net_dev);\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tinfo->data = efx->n_rx_channels;\n\t\treturn 0;\n\n\tcase ETHTOOL_GRXFH: {\n\t\tunsigned min_revision = 0;\n\n\t\tinfo->data = 0;\n\t\tswitch (info->flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\t/* fall through */\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase IPV4_FLOW:\n\t\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\t\tmin_revision = EFX_REV_FALCON_B0;\n\t\t\tbreak;\n\t\tcase TCP_V6_FLOW:\n\t\t\tinfo->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\t\t/* fall through */\n\t\tcase UDP_V6_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\tcase AH_ESP_V6_FLOW:\n\t\tcase IPV6_FLOW:\n\t\t\tinfo->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\t\tmin_revision = EFX_REV_SIENA_A0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (efx_nic_rev(efx) < min_revision)\n\t\t\tinfo->data = 0;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
        "output": "0",
        "index": 19454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pcm_chmap_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 0;\n\tuinfo->count = info->max_channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = SNDRV_CHMAP_LAST;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 47788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "server_away_free_messages (server *serv)\n{\n\tGSList *list, *next;\n\tstruct away_msg *away;\n\n\tlist = away_list;\n\twhile (list)\n\t{\n\t\taway = list->data;\n\t\tnext = list->next;\n\t\tif (away->server == serv)\n\t\t{\n\t\t\taway_list = g_slist_remove (away_list, away);\n\t\t\tif (away->message)\n\t\t\t\tfree (away->message);\n\t\t\tfree (away);\n\t\t\tnext = away_list;\n\t\t}\n\t\tlist = next;\n\t}\n}\n",
        "output": "0",
        "index": 58441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_tr_index(void *data, struct trace_array **ptr,\n\t\t\t unsigned int *pindex)\n{\n\t*pindex = *(unsigned char *)data;\n\n\t*ptr = container_of(data - *pindex, struct trace_array,\n\t\t\t    trace_flags_index);\n}\n",
        "output": "0",
        "index": 81293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\n\t\t/* Never want to jump backwards in a file. */\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n \n \t\t/* Calculate new file offset and position ourselves there. */\n \t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n \n\t\treturn 1 ;\n \t\t} ;\n \n \treturn 0 ;\n} /* id3_skip */\n",
        "output": "1",
        "index": 181431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ewk_view_toolbars_visible_set(Evas_Object* ewkView, bool visible)\n{\n    DBG(\"ewkView=%p (visible=%d)\", ewkView, !!visible);\n    evas_object_smart_callback_call(ewkView, \"toolbars,visible,set\", &visible);\n}\n",
        "output": "0",
        "index": 107675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n  scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n  if (IsAttached())\n    RevokePolicy();\n  ForceDetachAllSessions();\n  frame_host_ = nullptr;\n  agent_ptr_.reset();\n  SetFrameTreeNode(nullptr);\n  Release();\n}\n",
        "output": "0",
        "index": 168872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ExprCreateInteger(int ival)\n{\n    EXPR_CREATE(ExprInteger, expr, EXPR_VALUE, EXPR_TYPE_INT);\n    expr->integer.ival = ival;\n     return expr;\n }\n",
        "output": "0",
        "index": 79029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_zip_has_property(zval *object, zval *member, int type, void **cache_slot) /* {{{ */\n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzip_prop_handler *hnd = NULL;\n\tzend_object_handlers *std_hnd;\n\tint retval = 0;\n\n\tif (Z_TYPE_P(member) != IS_STRING) {\n\t\tZVAL_COPY(&tmp_member, member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tcache_slot = NULL;\n\t}\n\n\tobj = Z_ZIP_P(object);\n\n\tif (obj->prop_handler != NULL) {\n\t\thnd = zend_hash_find_ptr(obj->prop_handler, Z_STR_P(member));\n\t}\n\n\tif (hnd != NULL) {\n\t\tzval tmp, *prop;\n\n\t\tif (type == 2) {\n\t\t\tretval = 1;\n\t\t} else if ((prop = php_zip_property_reader(obj, hnd, &tmp)) != NULL) {\n\t\t\tif (type == 1) {\n\t\t\t\tretval = zend_is_true(&tmp);\n\t\t\t} else if (type == 0) {\n\t\t\t\tretval = (Z_TYPE(tmp) != IS_NULL);\n\t\t\t}\n\t\t}\n\n\t\tzval_ptr_dtor(&tmp);\n\t} else {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->has_property(object, member, type, cache_slot);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\n\treturn retval;\n}\n/* }}} */\n",
        "output": "0",
        "index": 54429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(readlink)\n{\n\tchar *link;\n\tsize_t link_len;\n\tchar target[MAXPATHLEN];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (OPENBASEDIR_CHECKPATH(link)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_sys_readlink(link, target, MAXPATHLEN) == -1) {\n\t\tphp_error_docref(NULL, E_WARNING, \"readlink failed to read the symbolic link (%s), error %d)\", link, GetLastError());\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRING(target);\n}\n",
        "output": "0",
        "index": 79114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_new_values(int disc_state, double offset, double recv_time)\n{\n\t/* Enter new state and set state variables. Note we use the time\n\t * of the last clock filter sample, which must be earlier than\n\t * the current time.\n\t */\n\tVERB4 bb_error_msg(\"disc_state=%d last update offset=%f recv_time=%f\",\n\t\t\tdisc_state, offset, recv_time);\n\tG.discipline_state = disc_state;\n\tG.last_update_offset = offset;\n\tG.last_update_recv_time = recv_time;\n}\n",
        "output": "0",
        "index": 9505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long hung_up_tty_ioctl(struct file *file, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\treturn cmd == TIOCSPGRP ? -ENOTTY : -EIO;\n}\n",
        "output": "0",
        "index": 55870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}\n",
        "output": "0",
        "index": 37869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int alluser_cb(const mbentry_t *mbentry, void *rock)\n{\n    struct alluser_rock *urock = (struct alluser_rock *)rock;\n    char *userid = mboxname_to_userid(mbentry->name);\n    int r = 0;\n\n    if (userid) {\n        if (strcmpsafe(urock->prev, userid)) {\n            r = urock->proc(userid, urock->rock);\n            free(urock->prev);\n            urock->prev = xstrdup(userid);\n        }\n        free(userid);\n    }\n\n    return r;\n}\n",
        "output": "0",
        "index": 61239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_fsuid(void)\n{\n    return get_proc_fs_id(/*UID*/'U');\n}\n",
        "output": "0",
        "index": 96394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int debugMutexEnd(void){ return SQLITE_OK; }\n",
        "output": "0",
        "index": 149145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ClassicPendingScript::IsCurrentlyStreaming() const {\n  return is_currently_streaming_;\n}\n",
        "output": "0",
        "index": 162506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestRenderFrame::SwapOut(\n    int proxy_routing_id,\n    bool is_loading,\n    const FrameReplicationState& replicated_frame_state) {\n  OnSwapOut(proxy_routing_id, is_loading, replicated_frame_state);\n}\n",
        "output": "0",
        "index": 152612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void make_flow_keys_digest(struct flow_keys_digest *digest,\n\t\t\t   const struct flow_keys *flow)\n{\n\tstruct _flow_keys_digest_data *data =\n\t    (struct _flow_keys_digest_data *)digest;\n\n\tBUILD_BUG_ON(sizeof(*data) > sizeof(*digest));\n\n\tmemset(digest, 0, sizeof(*digest));\n\n\tdata->n_proto = flow->basic.n_proto;\n\tdata->ip_proto = flow->basic.ip_proto;\n\tdata->ports = flow->ports.ports;\n\tdata->src = flow->addrs.v4addrs.src;\n\tdata->dst = flow->addrs.v4addrs.dst;\n}\n",
        "output": "0",
        "index": 61963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CommandLatencyQuery::Destroy(bool /* have_context */) {\n  if (!IsDeleted()) {\n    MarkAsDeleted();\n  }\n}\n",
        "output": "0",
        "index": 130484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tg3_link_report(struct tg3 *tp)\n{\n\tif (!netif_carrier_ok(tp->dev)) {\n\t\tnetif_info(tp, link, tp->dev, \"Link is down\\n\");\n\t\ttg3_ump_link_report(tp);\n\t} else if (netif_msg_link(tp)) {\n\t\tnetdev_info(tp->dev, \"Link is up at %d Mbps, %s duplex\\n\",\n\t\t\t    (tp->link_config.active_speed == SPEED_1000 ?\n\t\t\t     1000 :\n\t\t\t     (tp->link_config.active_speed == SPEED_100 ?\n\t\t\t      100 : 10)),\n\t\t\t    (tp->link_config.active_duplex == DUPLEX_FULL ?\n\t\t\t     \"full\" : \"half\"));\n\n\t\tnetdev_info(tp->dev, \"Flow control is %s for TX and %s for RX\\n\",\n\t\t\t    (tp->link_config.active_flowctrl & FLOW_CTRL_TX) ?\n\t\t\t    \"on\" : \"off\",\n\t\t\t    (tp->link_config.active_flowctrl & FLOW_CTRL_RX) ?\n\t\t\t    \"on\" : \"off\");\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_EEE_CAP)\n\t\t\tnetdev_info(tp->dev, \"EEE is %s\\n\",\n\t\t\t\t    tp->setlpicnt ? \"enabled\" : \"disabled\");\n\n\t\ttg3_ump_link_report(tp);\n\t}\n\n\ttp->link_up = netif_carrier_ok(tp->dev);\n}\n",
        "output": "0",
        "index": 32606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JSArray::getOwnPropertySlot(ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    if (propertyName == exec->propertyNames().length) {\n        slot.setValue(jsNumber(length()));\n        return true;\n    }\n\n    bool isArrayIndex;\n    unsigned i = propertyName.toArrayIndex(isArrayIndex);\n    if (isArrayIndex)\n        return JSArray::getOwnPropertySlot(exec, i, slot);\n\n    return JSObject::getOwnPropertySlot(exec, propertyName, slot);\n}\n",
        "output": "0",
        "index": 107431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pp::Buffer_Dev PDFiumEngine::PrintPagesAsPDF(\n    const PP_PrintPageNumberRange_Dev* page_ranges, uint32_t page_range_count,\n    const PP_PrintSettings_Dev& print_settings) {\n  if (!page_range_count)\n    return pp::Buffer_Dev();\n\n  DCHECK(doc_);\n  FPDF_DOCUMENT output_doc = FPDF_CreateNewDocument();\n  if (!output_doc)\n    return pp::Buffer_Dev();\n\n  SaveSelectedFormForPrint();\n\n  std::string page_number_str;\n  for (uint32_t index = 0; index < page_range_count; ++index) {\n    if (!page_number_str.empty())\n      page_number_str.append(\",\");\n    page_number_str.append(\n        base::UintToString(page_ranges[index].first_page_number + 1));\n    if (page_ranges[index].first_page_number !=\n            page_ranges[index].last_page_number) {\n      page_number_str.append(\"-\");\n      page_number_str.append(\n          base::UintToString(page_ranges[index].last_page_number + 1));\n    }\n  }\n\n  std::vector<uint32_t> page_numbers =\n      GetPageNumbersFromPrintPageNumberRange(page_ranges, page_range_count);\n  for (uint32_t page_number : page_numbers) {\n    pages_[page_number]->GetPage();\n    if (!IsPageVisible(page_number))\n      pages_[page_number]->Unload();\n  }\n\n  FPDF_CopyViewerPreferences(output_doc, doc_);\n  if (!FPDF_ImportPages(output_doc, doc_, page_number_str.c_str(), 0)) {\n    FPDF_CloseDocument(output_doc);\n    return pp::Buffer_Dev();\n  }\n\n  FitContentsToPrintableAreaIfRequired(output_doc, print_settings);\n\n  pp::Buffer_Dev buffer = GetFlattenedPrintData(output_doc);\n  FPDF_CloseDocument(output_doc);\n  return buffer;\n}\n",
        "output": "0",
        "index": 153095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,\n                             LodePNGColorType colortype, unsigned bitdepth)\n{\n  unsigned char* buffer = NULL;\n  size_t buffersize = 0;\n  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);\n  if(!error) error = lodepng_save_file(buffer, buffersize, filename);\n  free(buffer);\n  return error;\n}\n",
        "output": "0",
        "index": 87543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void ndp_msg_addrto_adjust_all_nodes(struct in6_addr *addr)\n{\n\tstruct in6_addr any = IN6ADDR_ANY_INIT;\n\n\tif (memcmp(addr, &any, sizeof(any)))\n\t\treturn;\n\taddr->s6_addr32[0] = htonl(0xFF020000);\n\taddr->s6_addr32[1] = 0;\n\taddr->s6_addr32[2] = 0;\n\taddr->s6_addr32[3] = htonl(0x1);\n}\n",
        "output": "0",
        "index": 94931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageChar (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy;\n\tint px, py;\n\tint fline;\n\tcx = 0;\n\tcy = 0;\n#ifdef CHARSET_EBCDIC\n\tc = ASC (c);\n#endif /*CHARSET_EBCDIC */\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py < (y + f->h)); py++) {\n\t\tfor (px = x; (px < (x + f->w)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel (im, px, py, color);\n\t\t\t}\n\t\t\tcx++;\n\t\t}\n\t\tcx = 0;\n\t\tcy++;\n\t}\n}\n",
        "output": "0",
        "index": 73037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kernel_shutdown_prepare(enum system_states state)\n{\n\tblocking_notifier_call_chain(&reboot_notifier_list,\n (state == SYSTEM_HALT)?SYS_HALT:SYS_POWER_OFF, NULL);\n\tsystem_state = state;\n\tusermodehelper_disable();\n\tdevice_shutdown();\n}\n",
        "output": "0",
        "index": 175226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ResetObserver() {\n    suppressed_ = false;\n    notified_ = false;\n  }\n",
        "output": "0",
        "index": 132378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ManifestUmaUtil::FetchSucceeded() {\n  UMA_HISTOGRAM_ENUMERATION(kUMANameFetchResult,\n                            MANIFEST_FETCH_SUCCESS,\n                            MANIFEST_FETCH_RESULT_TYPE_COUNT);\n}\n",
        "output": "0",
        "index": 162974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int phar_dir_close(php_stream *stream, int close_handle TSRMLS_DC)  /* {{{ */\n{\n\tHashTable *data = (HashTable *)stream->abstract;\n\n\tif (data && data->arBuckets) {\n\t\tzend_hash_destroy(data);\n\t\tdata->arBuckets = 0;\n\t\tFREE_HASHTABLE(data);\n\t\tstream->abstract = NULL;\n\t}\n\n\treturn 0;\n}\n/* }}} */\n",
        "output": "0",
        "index": 176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_create_session(struct xdr_stream *xdr,\n\t\t\t\t struct nfs41_create_session_res *res)\n{\n\t__be32 *p;\n\tint status;\n\tstruct nfs_client *clp = res->client;\n\tstruct nfs4_session *session = clp->cl_session;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE_SESSION);\n\tif (!status)\n\t\tstatus = decode_sessionid(xdr, &session->sess_id);\n\tif (unlikely(status))\n\t\treturn status;\n\n\t/* seqid, flags */\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tclp->cl_seqid = be32_to_cpup(p++);\n\tsession->flags = be32_to_cpup(p);\n\n\t/* Channel attributes */\n\tstatus = decode_chan_attrs(xdr, &session->fc_attrs);\n\tif (!status)\n\t\tstatus = decode_chan_attrs(xdr, &session->bc_attrs);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n",
        "output": "0",
        "index": 23296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool QQuickWebView::canGoForward() const\n{\n    Q_D(const QQuickWebView);\n    return d->webPageProxy->canGoForward();\n}\n",
        "output": "0",
        "index": 106966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}\n",
        "output": "0",
        "index": 48018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hugetlb_fix_reserve_counts(struct inode *inode)\n{\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tlong rsv_adjust;\n\n\trsv_adjust = hugepage_subpool_get_pages(spool, 1);\n\tif (rsv_adjust) {\n\t\tstruct hstate *h = hstate_inode(inode);\n\n\t\thugetlb_acct_memory(h, 1);\n\t}\n}\n",
        "output": "0",
        "index": 86376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __sched notrace preempt_schedule_common(void)\n{\n\tdo {\n\t\t/*\n\t\t * Because the function tracer can trace preempt_count_sub()\n\t\t * and it also uses preempt_enable/disable_notrace(), if\n\t\t * NEED_RESCHED is set, the preempt_enable_notrace() called\n\t\t * by the function tracer will call this function again and\n\t\t * cause infinite recursion.\n\t\t *\n\t\t * Preemption must be disabled here before the function\n\t\t * tracer can trace. Break up preempt_disable() into two\n\t\t * calls. One to disable preemption without fear of being\n\t\t * traced. The other to still record the preemption latency,\n\t\t * which can also be traced by the function tracer.\n\t\t */\n\t\tpreempt_disable_notrace();\n\t\tpreempt_latency_start(1);\n\t\t__schedule(true);\n\t\tpreempt_latency_stop(1);\n\t\tpreempt_enable_no_resched_notrace();\n\n\t\t/*\n\t\t * Check again in case we missed a preemption opportunity\n\t\t * between schedule and now.\n\t\t */\n\t} while (need_resched());\n}\n",
        "output": "0",
        "index": 55578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc)\n{\n  GNode *child;\n  guint8 *buffer;\n  guint32 child_fourcc;\n\n  for (child = g_node_next_sibling (node); child;\n      child = g_node_next_sibling (child)) {\n    buffer = (guint8 *) child->data;\n\n    child_fourcc = QT_FOURCC (buffer + 4);\n\n    if (child_fourcc == fourcc) {\n      return child;\n    }\n  }\n  return NULL;\n}\n",
        "output": "0",
        "index": 4982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void immutablePointAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.immutablePoint._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    RefPtr<SVGPropertyTearOff<FloatPoint> > v = V8SVGPoint::HasInstance(value) ? V8SVGPoint::toNative(v8::Handle<v8::Object>::Cast(value)) : 0;\n    imp->setImmutablePoint(WTF::getPtr(v));\n    return;\n}\n",
        "output": "0",
        "index": 117818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)\n#else\nstatic void\nyydestruct (yymsg, yytype, yyvaluep)\n    const char *yymsg;\n    int yytype;\n    YYSTYPE *yyvaluep;\n#endif\n{\n  YYUSE (yyvaluep);\n\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  switch (yytype)\n    {\n\n      default:\n\tbreak;\n    }\n}\n",
        "output": "0",
        "index": 74239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsAgentHostImpl::DispatchProtocolMessage(\n    DevToolsSession* session,\n    const std::string& message) {}\n",
        "output": "0",
        "index": 168914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_buf_read_compressed(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n\n    if (!s->inflate_buffer) {\n        s->inflate_buffer = av_malloc(DECOMPRESS_BUF_SIZE);\n        if (!s->inflate_buffer)\n            return AVERROR(ENOMEM);\n    }\n\n    if (s->inflate_stream.avail_in == 0) {\n        int read = http_buf_read(h, s->inflate_buffer, DECOMPRESS_BUF_SIZE);\n        if (read <= 0)\n            return read;\n        s->inflate_stream.next_in  = s->inflate_buffer;\n        s->inflate_stream.avail_in = read;\n    }\n\n    s->inflate_stream.avail_out = size;\n    s->inflate_stream.next_out  = buf;\n\n    ret = inflate(&s->inflate_stream, Z_SYNC_FLUSH);\n    if (ret != Z_OK && ret != Z_STREAM_END)\n        av_log(h, AV_LOG_WARNING, \"inflate return value: %d, %s\\n\",\n               ret, s->inflate_stream.msg);\n\n    return size - s->inflate_stream.avail_out;\n}\n",
        "output": "0",
        "index": 70853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZSTD_encodeSequences_default(\n            void* dst, size_t dstCapacity,\n            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\n            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\n            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n            seqDef const* sequences, size_t nbSeq, int longOffsets)\n{\n    return ZSTD_encodeSequences_body(dst, dstCapacity,\n                                    CTable_MatchLength, mlCodeTable,\n                                    CTable_OffsetBits, ofCodeTable,\n                                    CTable_LitLength, llCodeTable,\n                                    sequences, nbSeq, longOffsets);\n}\n",
        "output": "0",
        "index": 90051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CrosMock::InitMockNetworkLibrary() {\n  InitMockLibraryLoader();\n  if (mock_network_library_)\n    return;\n  mock_network_library_ = new StrictMock<MockNetworkLibrary>();\n  test_api()->SetNetworkLibrary(mock_network_library_, true);\n}\n",
        "output": "0",
        "index": 104501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PopupType AutofillManager::GetPopupType(const FormData& form,\n                                        const FormFieldData& field) {\n  const AutofillField* autofill_field = GetAutofillField(form, field);\n  if (!autofill_field)\n    return PopupType::kUnspecified;\n\n  switch (autofill_field->Type().group()) {\n    case NO_GROUP:\n    case PASSWORD_FIELD:\n    case TRANSACTION:\n    case USERNAME_FIELD:\n    case UNFILLABLE:\n      return PopupType::kUnspecified;\n\n    case CREDIT_CARD:\n      return PopupType::kCreditCards;\n\n    case ADDRESS_HOME:\n    case ADDRESS_BILLING:\n      return PopupType::kAddresses;\n\n    case NAME:\n    case NAME_BILLING:\n    case EMAIL:\n    case COMPANY:\n    case PHONE_HOME:\n    case PHONE_BILLING:\n      return FormHasAddressField(form) ? PopupType::kAddresses\n                                       : PopupType::kPersonalInformation;\n\n    default:\n      NOTREACHED();\n  }\n}\n",
        "output": "0",
        "index": 168049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __fanout_link(struct sock *sk, struct packet_sock *po)\n{\n\tstruct packet_fanout *f = po->fanout;\n\n\tspin_lock(&f->lock);\n\tf->arr[f->num_members] = sk;\n\tsmp_wmb();\n\tf->num_members++;\n\tspin_unlock(&f->lock);\n}\n",
        "output": "0",
        "index": 40599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn,\n\t\t\t\t\t      struct mm_struct *mm,\n\t\t\t\t\t      unsigned long address)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint young, idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\tyoung = kvm_age_hva(kvm, address);\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\tif (young)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\treturn young;\n}\n",
        "output": "0",
        "index": 20369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int LocalReaderProxy::Read(net::IOBuffer* buffer, int buffer_length,\n                           const net::CompletionCallback& callback) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  DCHECK(file_stream_);\n  return file_stream_->Read(buffer, buffer_length, callback);\n}\n",
        "output": "0",
        "index": 121546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int clientsCronResizeQueryBuffer(client *c) {\n    size_t querybuf_size = sdsAllocSize(c->querybuf);\n    time_t idletime = server.unixtime - c->lastinteraction;\n\n    /* There are two conditions to resize the query buffer:\n     * 1) Query buffer is > BIG_ARG and too big for latest peak.\n     * 2) Client is inactive and the buffer is bigger than 1k. */\n    if (((querybuf_size > PROTO_MBULK_BIG_ARG) &&\n         (querybuf_size/(c->querybuf_peak+1)) > 2) ||\n         (querybuf_size > 1024 && idletime > 2))\n    {\n        /* Only resize the query buffer if it is actually wasting space. */\n        if (sdsavail(c->querybuf) > 1024) {\n            c->querybuf = sdsRemoveFreeSpace(c->querybuf);\n        }\n    }\n    /* Reset the peak again to capture the peak memory usage in the next\n     * cycle. */\n    c->querybuf_peak = 0;\n    return 0;\n}\n",
        "output": "0",
        "index": 70005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hfsplus_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(dir->i_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\n\tmutex_lock(&sbi->vh_mutex);\n\tres = hfsplus_delete_cat(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfsplus_delete_inode(inode);\n\tmark_inode_dirty(inode);\nout:\n\tmutex_unlock(&sbi->vh_mutex);\n\treturn res;\n}\n",
        "output": "0",
        "index": 20069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ShadowRoot::ShadowRoot(Document* document)\n    : DocumentFragment(document, CreateShadowRoot)\n    , TreeScope(this)\n    , m_prev(0)\n    , m_next(0)\n    , m_applyAuthorStyles(false)\n    , m_insertionPointAssignedTo(0)\n{\n    ASSERT(document);\n    \n    setParentTreeScope(document);\n    ensureRareData()->setTreeScope(this);\n}\n",
        "output": "0",
        "index": 105167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SafeSock::~SafeSock()\n{\n\t_condorInMsg *tempMsg, *delMsg;\n\n\tfor(int i=0; i<SAFE_SOCK_HASH_BUCKET_SIZE; i++) {\n\t\ttempMsg = _inMsgs[i];\n\t\twhile(tempMsg) {\n\t\t\tdelMsg = tempMsg;\n\t\t\ttempMsg = tempMsg->nextMsg;\n\t\t\tdelete delMsg;\n\t\t}\n\t\t_inMsgs[i] = NULL;\n\t}\n\tclose();\n\n    delete mdChecker_;\n}\n",
        "output": "0",
        "index": 16298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flac_byterate (SF_PRIVATE *psf)\n{\n\tif (psf->file.mode == SFM_READ)\n\t\treturn (psf->datalength * psf->sf.samplerate) / psf->sf.frames ;\n\n\treturn -1 ;\n} /* flac_byterate */\n",
        "output": "0",
        "index": 67106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_port_stats_to_ofp10(const struct ofputil_port_stats *ops,\n                            struct ofp10_port_stats *ps10)\n{\n    ps10->port_no = htons(ofp_to_u16(ops->port_no));\n    memset(ps10->pad, 0, sizeof ps10->pad);\n    put_32aligned_be64(&ps10->rx_packets, htonll(ops->stats.rx_packets));\n    put_32aligned_be64(&ps10->tx_packets, htonll(ops->stats.tx_packets));\n    put_32aligned_be64(&ps10->rx_bytes, htonll(ops->stats.rx_bytes));\n    put_32aligned_be64(&ps10->tx_bytes, htonll(ops->stats.tx_bytes));\n    put_32aligned_be64(&ps10->rx_dropped, htonll(ops->stats.rx_dropped));\n    put_32aligned_be64(&ps10->tx_dropped, htonll(ops->stats.tx_dropped));\n    put_32aligned_be64(&ps10->rx_errors, htonll(ops->stats.rx_errors));\n    put_32aligned_be64(&ps10->tx_errors, htonll(ops->stats.tx_errors));\n    put_32aligned_be64(&ps10->rx_frame_err, htonll(ops->stats.rx_frame_errors));\n    put_32aligned_be64(&ps10->rx_over_err, htonll(ops->stats.rx_over_errors));\n    put_32aligned_be64(&ps10->rx_crc_err, htonll(ops->stats.rx_crc_errors));\n    put_32aligned_be64(&ps10->collisions, htonll(ops->stats.collisions));\n}\n",
        "output": "0",
        "index": 77653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpdyWriteQueue::PendingWrite::PendingWrite(\n    SpdyFrameType frame_type,\n    SpdyBufferProducer* frame_producer,\n    const base::WeakPtr<SpdyStream>& stream)\n    : frame_type(frame_type),\n      frame_producer(frame_producer),\n      stream(stream),\n      has_stream(stream.get() != NULL) {}\n",
        "output": "0",
        "index": 129791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n}\n",
        "output": "0",
        "index": 20749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoBindAttribLocation(\n    GLuint program,\n    GLuint index,\n    const char* name) {\n  api()->glBindAttribLocationFn(GetProgramServiceID(program, resources_), index,\n                                name);\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 154558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QQuickWebViewPrivate::setIcon(const QUrl& iconURL)\n{\n    Q_Q(QQuickWebView);\n    if (m_iconURL == iconURL)\n        return;\n\n    String oldPageURL = QUrl::fromPercentEncoding(m_iconURL.encodedFragment());\n    String newPageURL = webPageProxy->mainFrame()->url();\n\n    if (oldPageURL != newPageURL) {\n        QtWebIconDatabaseClient* iconDatabase = context->iconDatabase();\n        if (!oldPageURL.isEmpty())\n            iconDatabase->releaseIconForPageURL(oldPageURL);\n\n        if (!newPageURL.isEmpty())\n            iconDatabase->retainIconForPageURL(newPageURL);\n    }\n\n    m_iconURL = iconURL;\n    emit q->iconChanged();\n}\n",
        "output": "0",
        "index": 107068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void EditorClientBlackBerry::respondToChangedSelection(Frame* frame)\n{\n    if (m_waitingForCursorFocus)\n        m_waitingForCursorFocus = false;\n    else\n        m_webPagePrivate->selectionChanged(frame);\n\n    if (m_webPagePrivate->m_dumpRenderTree)\n        m_webPagePrivate->m_dumpRenderTree->didChangeSelection();\n}\n",
        "output": "0",
        "index": 111709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::ReleaseIOSurfaceForTexture(GLuint texture_id) {\n  TextureToIOSurfaceMap::iterator it = texture_to_io_surface_map_.find(\n      texture_id);\n  if (it != texture_to_io_surface_map_.end()) {\n    IOSurfaceRef surface = it->second;\n    CFRelease(surface);\n    texture_to_io_surface_map_.erase(it);\n  }\n}\n",
        "output": "0",
        "index": 129474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " MdSettingsUI::MdSettingsUI(content::WebUI* web_ui)\n     : content::WebUIController(web_ui) {\n   AddSettingsPageUIHandler(new AppearanceHandler(web_ui));\n   AddSettingsPageUIHandler(new DownloadsHandler());\n   AddSettingsPageUIHandler(new StartupPagesHandler(web_ui));\n \n  content::WebUIDataSource* html_source =\n      content::WebUIDataSource::Create(chrome::kChromeUIMdSettingsHost);\n\n  for (size_t i = 0; i < kSettingsResourcesSize; ++i) {\n    html_source->AddResourcePath(kSettingsResources[i].name,\n                                 kSettingsResources[i].value);\n  }\n\n  AddLocalizedStrings(html_source);\n  html_source->SetDefaultResource(IDR_SETTINGS_SETTINGS_HTML);\n\n  content::WebUIDataSource::Add(web_ui->GetWebContents()->GetBrowserContext(),\n                                html_source);\n}\n",
        "output": "1",
        "index": 185427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tipc_sk_finish_conn(struct tipc_sock *tsk, u32 peer_port,\n\t\t\t\tu32 peer_node)\n{\n\tstruct sock *sk = &tsk->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct tipc_msg *msg = &tsk->phdr;\n\n\tmsg_set_destnode(msg, peer_node);\n\tmsg_set_destport(msg, peer_port);\n\tmsg_set_type(msg, TIPC_CONN_MSG);\n\tmsg_set_lookup_scope(msg, 0);\n\tmsg_set_hdr_sz(msg, SHORT_H_SIZE);\n\n\ttsk->probing_intv = CONN_PROBING_INTERVAL;\n\ttsk->probing_state = TIPC_CONN_OK;\n\ttsk->connected = 1;\n\tsk_reset_timer(sk, &sk->sk_timer, jiffies + tsk->probing_intv);\n\ttipc_node_add_conn(net, peer_node, tsk->portid, peer_port);\n\ttsk->max_pkt = tipc_node_get_mtu(net, peer_node, tsk->portid);\n\ttsk->peer_caps = tipc_node_get_capabilities(net, peer_node);\n\tif (tsk->peer_caps & TIPC_BLOCK_FLOWCTL)\n\t\treturn;\n\n\t/* Fall back to message based flow control */\n\ttsk->rcv_win = FLOWCTL_MSG_WIN;\n\ttsk->snd_win = FLOWCTL_MSG_WIN;\n}\n",
        "output": "0",
        "index": 52499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n",
        "output": "0",
        "index": 35794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_put_ofp11_match(struct ofpbuf *b, const struct match *match,\n                        enum ofputil_protocol protocol)\n{\n    switch (protocol) {\n    case OFPUTIL_P_OF10_STD:\n    case OFPUTIL_P_OF10_STD_TID:\n    case OFPUTIL_P_OF10_NXM:\n    case OFPUTIL_P_OF10_NXM_TID:\n        OVS_NOT_REACHED();\n\n    case OFPUTIL_P_OF11_STD: {\n        struct ofp11_match *om;\n\n        /* Make sure that no padding is needed. */\n        BUILD_ASSERT_DECL(sizeof *om % 8 == 0);\n\n        om = ofpbuf_put_uninit(b, sizeof *om);\n        ofputil_match_to_ofp11_match(match, om);\n        return sizeof *om;\n    }\n\n    case OFPUTIL_P_OF12_OXM:\n    case OFPUTIL_P_OF13_OXM:\n    case OFPUTIL_P_OF14_OXM:\n    case OFPUTIL_P_OF15_OXM:\n    case OFPUTIL_P_OF16_OXM:\n        return oxm_put_match(b, match,\n                             ofputil_protocol_to_ofp_version(protocol));\n    }\n\n    OVS_NOT_REACHED();\n}\n",
        "output": "0",
        "index": 77689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataCache::GetResourceIdsOfBacklogOnUIThread(\n    const GetResourceIdsOfBacklogCallback& callback) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  std::vector<std::string>* to_fetch = new std::vector<std::string>;\n  std::vector<std::string>* to_upload = new std::vector<std::string>;\n  pool_->GetSequencedTaskRunner(sequence_token_)->PostTaskAndReply(\n      FROM_HERE,\n      base::Bind(&GDataCache::GetResourceIdsOfBacklog,\n                 base::Unretained(this),\n                 to_fetch,\n                 to_upload),\n      base::Bind(&RunGetResourceIdsOfBacklogCallback,\n                 callback,\n                 base::Owned(to_fetch),\n                 base::Owned(to_upload)));\n}\n",
        "output": "0",
        "index": 112882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_map_prog_compatibility(struct bpf_verifier_env *env,\n\t\t\t\t\tstruct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog *prog)\n\n{\n\t/* Make sure that BPF_PROG_TYPE_PERF_EVENT programs only use\n\t * preallocated hash maps, since doing memory allocation\n\t * in overflow_handler can crash depending on where nmi got\n\t * triggered.\n\t */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT) {\n\t\tif (!check_map_prealloc(map)) {\n\t\t\tverbose(env, \"perf_event programs can only use preallocated hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (map->inner_map_meta &&\n\t\t    !check_map_prealloc(map->inner_map_meta)) {\n\t\t\tverbose(env, \"perf_event programs can only use preallocated inner hash map\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 59118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void SVGProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",target,data);\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n",
        "output": "0",
        "index": 71735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TEE_Result check_ta_store(void)\n{\n\tconst struct user_ta_store_ops *op = NULL;\n\n\tSCATTERED_ARRAY_FOREACH(op, ta_stores, struct user_ta_store_ops)\n\t\tDMSG(\"TA store: \\\"%s\\\"\", op->description);\n\n\treturn TEE_SUCCESS;\n}\n",
        "output": "0",
        "index": 86929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CameraClient::copyFrameAndPostCopiedFrame(\n int32_t msgType, const sp<ICameraClient>& client,\n const sp<IMemoryHeap>& heap, size_t offset, size_t size,\n camera_frame_metadata_t *metadata) {\n    LOG2(\"copyFrameAndPostCopiedFrame\");\n    sp<MemoryHeapBase> previewBuffer;\n\n if (mPreviewBuffer == 0) {\n        mPreviewBuffer = new MemoryHeapBase(size, 0, NULL);\n } else if (size > mPreviewBuffer->virtualSize()) {\n        mPreviewBuffer.clear();\n        mPreviewBuffer = new MemoryHeapBase(size, 0, NULL);\n }\n if (mPreviewBuffer == 0) {\n        ALOGE(\"failed to allocate space for preview buffer\");\n        mLock.unlock();\n return;\n }\n    previewBuffer = mPreviewBuffer;\n\n    memcpy(previewBuffer->base(), (uint8_t *)heap->base() + offset, size);\n\n    sp<MemoryBase> frame = new MemoryBase(previewBuffer, 0, size);\n if (frame == 0) {\n        ALOGE(\"failed to allocate space for frame callback\");\n        mLock.unlock();\n return;\n }\n\n    mLock.unlock();\n    client->dataCallback(msgType, frame, metadata);\n}\n",
        "output": "0",
        "index": 174940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FLTDoAxisSwappingIfNecessary(FilterEncodingNode *psFilterNode,\n                                  int bDefaultSRSNeedsAxisSwapping)\n{\n    if( psFilterNode == NULL )\n        return;\n\n    if( psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n        psFilterNode->psRightNode->eType == FILTER_NODE_TYPE_BBOX )\n    {\n        rectObj* rect = (rectObj *)psFilterNode->psRightNode->pOther;\n        const char* pszSRS = psFilterNode->pszSRS;\n        if( (pszSRS != NULL && FLTNeedSRSSwapping(pszSRS)) ||\n            (pszSRS == NULL && bDefaultSRSNeedsAxisSwapping) )\n        {\n            double tmp;\n\n            tmp = rect->minx;\n            rect->minx = rect->miny;\n            rect->miny = tmp;\n\n            tmp = rect->maxx;\n            rect->maxx = rect->maxy;\n            rect->maxy = tmp;\n        }\n    }\n    else if( psFilterNode->eType == FILTER_NODE_TYPE_SPATIAL &&\n             FLTIsGeometryFilterNodeType(psFilterNode->psRightNode->eType) )\n    {\n        shapeObj* shape = (shapeObj *)(psFilterNode->psRightNode->pOther);\n        const char* pszSRS = psFilterNode->pszSRS;\n        if( (pszSRS != NULL && FLTNeedSRSSwapping(pszSRS)) ||\n            (pszSRS == NULL && bDefaultSRSNeedsAxisSwapping) )\n        {\n            msAxisSwapShape(shape);\n        }\n    }\n    else\n    {\n        FLTDoAxisSwappingIfNecessary(psFilterNode->psLeftNode, bDefaultSRSNeedsAxisSwapping);\n        FLTDoAxisSwappingIfNecessary(psFilterNode->psRightNode, bDefaultSRSNeedsAxisSwapping);\n    }\n}\n",
        "output": "0",
        "index": 68970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeContentBrowserClient::InitWebContextInterfaces() {\n  frame_interfaces_ = std::make_unique<service_manager::BinderRegistry>();\n  frame_interfaces_parameterized_ = std::make_unique<\n      service_manager::BinderRegistryWithArgs<content::RenderFrameHost*>>();\n  worker_interfaces_parameterized_ =\n      std::make_unique<service_manager::BinderRegistryWithArgs<\n          content::RenderProcessHost*, const url::Origin&>>();\n\n  frame_interfaces_parameterized_->AddInterface(base::BindRepeating(\n      &ChromeLanguageDetectionTabHelper::BindContentTranslateDriver));\n\n  frame_interfaces_parameterized_->AddInterface(\n      base::BindRepeating(&ChromePasswordManagerClient::BindCredentialManager));\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&InsecureSensitiveInputDriverFactory::BindDriver));\n\n#if defined(OS_ANDROID)\n  frame_interfaces_parameterized_->AddInterface(base::Bind(\n      &ForwardToJavaFrameRegistry<blink::mojom::InstalledAppProvider>));\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&ForwardToJavaFrameRegistry<payments::mojom::PaymentRequest>));\n  frame_interfaces_parameterized_->AddInterface(\n      base::Bind(&ForwardToJavaFrameRegistry<blink::mojom::Authenticator>));\n#else\n  if (base::FeatureList::IsEnabled(features::kWebPayments)) {\n    frame_interfaces_parameterized_->AddInterface(\n        base::Bind(&payments::CreatePaymentRequest));\n  }\n#endif\n\n#if defined(OS_ANDROID)\n  frame_interfaces_parameterized_->AddInterface(base::Bind(\n      &ForwardToJavaWebContentsRegistry<blink::mojom::ShareService>));\n#elif defined(OS_LINUX) || defined(OS_WIN)\n  frame_interfaces_->AddInterface(base::Bind(&ShareServiceImpl::Create));\n#endif\n\n#if defined(OS_CHROMEOS)\n  frame_interfaces_->AddInterface(\n      base::BindRepeating(&BadgeServiceImpl::Create));\n#endif\n\n  frame_interfaces_parameterized_->AddInterface(\n      base::BindRepeating(&NavigationPredictor::Create));\n\n#if defined(OS_ANDROID)\n  frame_interfaces_parameterized_->AddInterface(\n      base::BindRepeating(&offline_pages::OfflinePageAutoFetcher::Create),\n      base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::UI}));\n#endif\n}\n",
        "output": "0",
        "index": 166510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RendererSchedulerImpl::ResumeTimersForAndroidWebView() {\n  main_thread_only().pause_timers_for_webview = false;\n  UpdatePolicy();\n}\n",
        "output": "0",
        "index": 156256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::OverloadedMethodNMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_overloadedMethodN\");\n\n  test_object_v8_internal::OverloadedMethodNMethod(info);\n}\n",
        "output": "0",
        "index": 147661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fbFetchPixel_a8b8g8r8 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = READ((CARD32 *)bits + offset);\n\n    return ((pixel & 0xff000000) |\n\t    ((pixel >> 16) & 0xff) |\n\t    (pixel & 0x0000ff00) |\n\t    ((pixel & 0xff) << 16));\n}\n",
        "output": "0",
        "index": 11414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tvoid testNormalizeSyntaxMaskRequired() {\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/\", URI_NORMALIZED));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"httP://localhost/\", URI_NORMALIZE_SCHEME));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://%0d@localhost/\", URI_NORMALIZE_USER_INFO));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhosT/\", URI_NORMALIZE_HOST));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/./abc\", URI_NORMALIZE_PATH));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/?AB%43\", URI_NORMALIZE_QUERY));\n\t\tTEST_ASSERT(testNormalizeMaskHelper(L\"http://localhost/#AB%43\", URI_NORMALIZE_FRAGMENT));\n\t}\n",
        "output": "0",
        "index": 75746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(char*) iw_get_copyright_string(struct iw_context *ctx, char *dst, int dstlen)\n{\n\tiw_translatef(ctx,0,dst,dstlen,\"Copyright \\xc2\\xa9 %s %s\",IW_COPYRIGHT_YEAR,\"Jason Summers\");\n\treturn dst;\n}\n",
        "output": "0",
        "index": 64961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "camera_metadata_t *place_camera_metadata(void *dst,\n size_t dst_size,\n size_t entry_capacity,\n size_t data_capacity) {\n if (dst == NULL) return NULL;\n\n size_t memory_needed = calculate_camera_metadata_size(entry_capacity,\n                                                          data_capacity);\n if (memory_needed > dst_size) return NULL;\n\n camera_metadata_t *metadata = (camera_metadata_t*)dst;\n    metadata->version = CURRENT_METADATA_VERSION;\n    metadata->flags = 0;\n    metadata->entry_count = 0;\n    metadata->entry_capacity = entry_capacity;\n    metadata->entries_start =\n            ALIGN_TO(sizeof(camera_metadata_t), ENTRY_ALIGNMENT);\n    metadata->data_count = 0;\n    metadata->data_capacity = data_capacity;\n    metadata->size = memory_needed;\n size_t data_unaligned = (uint8_t*)(get_entries(metadata) +\n            metadata->entry_capacity) - (uint8_t*)metadata;\n    metadata->data_start = ALIGN_TO(data_unaligned, DATA_ALIGNMENT);\n\n    assert(validate_camera_metadata_structure(metadata, NULL) == OK);\n return metadata;\n}\n",
        "output": "0",
        "index": 171115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::SynthesizeGLError(\n    GLenum error,\n    const char* function_name,\n    const char* description,\n    ConsoleDisplayPreference display) {\n  String error_type = GetErrorString(error);\n  if (synthesized_errors_to_console_ && display == kDisplayInConsole) {\n    String message = String(\"WebGL: \") + error_type + \": \" +\n                     String(function_name) + \": \" + String(description);\n    PrintGLErrorToConsole(message);\n  }\n  if (!isContextLost()) {\n    if (!synthetic_errors_.Contains(error))\n      synthetic_errors_.push_back(error);\n  } else {\n    if (!lost_context_errors_.Contains(error))\n      lost_context_errors_.push_back(error);\n  }\n  probe::DidFireWebGLError(canvas(), error_type);\n}\n",
        "output": "0",
        "index": 154980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_good_protocol(const char *protocol_list, const char *protocol)\n{\n    char *tmp = strdup(protocol_list);\n    char *pch = strtok(tmp, \", \");\n    while (pch != NULL) {\n        if (strcmp(pch, protocol) == 0) {\n            free(tmp);\n            return true;\n        }\n        pch = strtok(NULL, \", \");\n    }\n    free(tmp);\n    return false;\n}\n",
        "output": "0",
        "index": 76573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AppLaunchObserver::AppLaunchObserver(\n    NavigationController* controller,\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    extension_misc::LaunchContainer launch_container)\n    : controller_(controller),\n      automation_(automation->AsWeakPtr()),\n      reply_message_(reply_message),\n      launch_container_(launch_container),\n      new_window_id_(extension_misc::kUnknownWindowId) {\n  if (launch_container_ == extension_misc::LAUNCH_TAB) {\n    content::Source<NavigationController> source(controller_);\n    registrar_.Add(this, content::NOTIFICATION_LOAD_STOP, source);\n  } else {\n    registrar_.Add(this, content::NOTIFICATION_LOAD_STOP,\n                   content::NotificationService::AllSources());\n    registrar_.Add(this, chrome::NOTIFICATION_BROWSER_WINDOW_READY,\n                   content::NotificationService::AllSources());\n  }\n}\n",
        "output": "0",
        "index": 125910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SVGDocumentExtensions::startPan(const FloatPoint& start)\n{\n    if (SVGSVGElement* svg = rootElement(*m_document))\n        m_translate = FloatPoint(start.x() - svg->currentTranslate().x(), start.y() - svg->currentTranslate().y());\n}\n",
        "output": "0",
        "index": 128874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InputMethodLinuxX11::OnPreeditChanged(\n    const CompositionText& composition_text) {\n  TextInputClient* text_input_client = GetTextInputClient();\n  if (text_input_client)\n    text_input_client->SetCompositionText(composition_text);\n}\n",
        "output": "0",
        "index": 134151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wiki_show_changes_page(HttpResponse *res)\n{\n  WikiPageList **pages = NULL;\n  int            n_pages, i;\n\n  wiki_show_header(res, \"Changes\", FALSE);\n\n  pages = wiki_get_pages(&n_pages, NULL);\n\n  for (i=0; i<n_pages; i++)\n    {\n      struct tm   *pTm;\n      char   datebuf[64];\n\n      pTm = localtime(&pages[i]->mtime);\n      strftime(datebuf, sizeof(datebuf), \"%Y-%m-%d %H:%M\", pTm);\n      http_response_printf(res, \"<a href='%s'>%s</a> %s<br />\\n\", \n\t\t\t   pages[i]->name, \n\t\t\t   pages[i]->name, \n\t\t\t   datebuf);\n    }\n\n  wiki_show_footer(res);\n  http_response_send(res);\n  exit(0);\n}\n",
        "output": "0",
        "index": 58496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void CheckDefaultDatatypesInMapExcept(\n      DataTypeController::StateMap* map,\n      syncer::ModelType exception_type) {\n    std::vector<syncer::ModelType> defaults = DefaultDatatypes();\n    std::vector<syncer::ModelType>::iterator iter;\n    for (iter = defaults.begin(); iter != defaults.end(); ++iter) {\n      if (exception_type != syncer::UNSPECIFIED && exception_type == *iter)\n        EXPECT_EQ(0U, map->count(*iter))\n            << *iter << \" found in dataypes map, shouldn't be there.\";\n      else\n        EXPECT_EQ(1U, map->count(*iter))\n            << *iter << \" not found in datatypes map\";\n    }\n  }\n",
        "output": "0",
        "index": 97541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Extension::Type Extension::GetType() const {\n  if (is_theme())\n    return TYPE_THEME;\n  if (converted_from_user_script())\n    return TYPE_USER_SCRIPT;\n  if (is_hosted_app())\n    return TYPE_HOSTED_APP;\n  if (is_packaged_app())\n    return TYPE_PACKAGED_APP;\n  return TYPE_EXTENSION;\n}\n",
        "output": "0",
        "index": 104619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void blitter_set_rectangle(struct vrend_blitter_ctx *blit_ctx,\n                                  int x1, int y1, int x2, int y2,\n                                  float depth)\n{\n   int i;\n\n   /* set vertex positions */\n   blit_ctx->vertices[0][0][0] = (float)x1 / blit_ctx->dst_width * 2.0f - 1.0f; /*v0.x*/\n   blit_ctx->vertices[0][0][1] = (float)y1 / blit_ctx->dst_height * 2.0f - 1.0f; /*v0.y*/\n\n   blit_ctx->vertices[1][0][0] = (float)x2 / blit_ctx->dst_width * 2.0f - 1.0f; /*v1.x*/\n   blit_ctx->vertices[1][0][1] = (float)y1 / blit_ctx->dst_height * 2.0f - 1.0f; /*v1.y*/\n\n   blit_ctx->vertices[2][0][0] = (float)x2 / blit_ctx->dst_width * 2.0f - 1.0f; /*v2.x*/\n   blit_ctx->vertices[2][0][1] = (float)y2 / blit_ctx->dst_height * 2.0f - 1.0f; /*v2.y*/\n\n   blit_ctx->vertices[3][0][0] = (float)x1 / blit_ctx->dst_width * 2.0f - 1.0f; /*v3.x*/\n   blit_ctx->vertices[3][0][1] = (float)y2 / blit_ctx->dst_height * 2.0f - 1.0f; /*v3.y*/\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][2] = depth; /*z*/\n\n   glViewport(0, 0, blit_ctx->dst_width, blit_ctx->dst_height);\n}\n",
        "output": "0",
        "index": 9165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gnra_Size(GF_Box *s)\n{\n\tGF_GenericAudioSampleEntryBox *ptr = (GF_GenericAudioSampleEntryBox *)s;\n\ts->type = GF_ISOM_BOX_TYPE_GNRA;\n\tgf_isom_audio_sample_entry_size((GF_AudioSampleEntryBox *)s);\n\tptr->size += ptr->data_size;\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_uc_to_curlcode(CURLUcode uc)\n{\n  switch(uc) {\n  default:\n    return CURLE_URL_MALFORMAT;\n  case CURLUE_UNSUPPORTED_SCHEME:\n    return CURLE_UNSUPPORTED_PROTOCOL;\n  case CURLUE_OUT_OF_MEMORY:\n    return CURLE_OUT_OF_MEMORY;\n  case CURLUE_USER_NOT_ALLOWED:\n    return CURLE_LOGIN_DENIED;\n  }\n}\n",
        "output": "0",
        "index": 77777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool decode(ArgumentDecoder* decoder, RetainPtr<SecKeychainItemRef>& result)\n{\n    RetainPtr<CFDataRef> data;\n    if (!CoreIPC::decode(decoder, data))\n        return false;\n\n    SecKeychainItemRef item;\n    if (SecKeychainItemCopyFromPersistentReference(data.get(), &item) != errSecSuccess || !item)\n        return false;\n    \n    result.adoptCF(item);\n    return true;\n}\n",
        "output": "0",
        "index": 107984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *enl_send_and_wait(char *msg)\n{\n\tchar *reply = IPC_TIMEOUT;\n\tsighandler_t old_alrm;\n\n\t/*\n\t * Shortcut this func and return IPC_FAKE\n\t * If the IPC Window is the E17 fake\n\t */\n\tif (e17_fake_ipc)\n\t\treturn IPC_FAKE;\n\n\tif (ipc_win == None) {\n\t\t/* The IPC window is missing.  Wait for it to return or feh to be killed. */\n\t\t/* Only called once in the E17 case */\n\t\tfor (; enl_ipc_get_win() == None;) {\n\t\t\tif (e17_fake_ipc)\n\t\t\t\treturn IPC_FAKE;\n\t\t\telse\n\t\t\t\tsleep(1);\n\t\t}\n\t}\n\told_alrm = (sighandler_t) signal(SIGALRM, (sighandler_t) enl_ipc_timeout);\n\tfor (; reply == IPC_TIMEOUT;) {\n\t\ttimeout = 0;\n\t\tenl_ipc_send(msg);\n\t\tfor (; !(reply = enl_ipc_get(enl_wait_for_reply())););\n\t\tif (reply == IPC_TIMEOUT) {\n\t\t\t/* We timed out.  The IPC window must be AWOL.  Reset and resend message. */\n\t\t\tD((\"IPC timed out.  IPC window has gone. Clearing ipc_win.\\n\"));\n\t\t\tXSelectInput(disp, ipc_win, None);\n\t\t\tipc_win = None;\n\t\t}\n\t}\n\tsignal(SIGALRM, old_alrm);\n\treturn(reply);\n}\n",
        "output": "0",
        "index": 66911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_remove(FsContext *ctx, const char *path)\n{\n    errno = EOPNOTSUPP;\n    return -1;\n}\n",
        "output": "0",
        "index": 7689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Cluster::Cluster(\n    Segment* pSegment,\n    long idx,\n    long long element_start\n    /* long long element_size */ ) :\n    m_pSegment(pSegment),\n    m_element_start(element_start),\n    m_index(idx),\n    m_pos(element_start),\n    m_element_size(-1 /* element_size */ ),\n    m_timecode(-1),\n    m_entries(NULL),\n    m_entries_size(0),\n    m_entries_count(-1)  //means \"has not been parsed yet\"\n{\n}\n",
        "output": "1",
        "index": 188271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PermissionPromptImpl::Show() {\n  DCHECK(browser_);\n  DCHECK(browser_->window());\n\n  bubble_delegate_ =\n      new PermissionsBubbleDialogDelegateView(this, delegate_->Requests());\n\n  bubble_delegate_->set_parent_window(\n      platform_util::GetViewForWindow(browser_->window()->GetNativeWindow()));\n\n  bubble_delegate_->set_anchor_view_insets(gfx::Insets(\n      GetLayoutConstant(LOCATION_BAR_BUBBLE_ANCHOR_VERTICAL_INSET), 0));\n\n  views::Widget* widget =\n      views::BubbleDialogDelegateView::CreateBubble(bubble_delegate_);\n  if (browser_->window()->IsActive())\n    widget->Show();\n  else\n    widget->ShowInactive();\n\n  bubble_delegate_->SizeToContents();\n\n  bubble_delegate_->UpdateAnchor();\n}\n",
        "output": "0",
        "index": 159781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_snmp_has_property(zval *object, zval *member, int has_set_exists, const zend_literal *key TSRMLS_DC)\n{\n\tphp_snmp_prop_handler *hnd;\n\tint ret = 0;\n\n\tif (zend_hash_find(&php_snmp_properties, Z_STRVAL_P(member), Z_STRLEN_P(member) + 1, (void **)&hnd) == SUCCESS) {\n\t\tswitch (has_set_exists) {\n\t\t\tcase 2:\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0: {\n\t\t\t\tzval *value = php_snmp_read_property(object, member, BP_VAR_IS, key TSRMLS_CC);\n\t\t\t\tif (value != EG(uninitialized_zval_ptr)) {\n\t\t\t\t\tret = Z_TYPE_P(value) != IS_NULL? 1:0;\n\t\t\t\t\t/* refcount is 0 */\n\t\t\t\t\tZ_ADDREF_P(value);\n\t\t\t\t\tzval_ptr_dtor(&value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tzval *value = php_snmp_read_property(object, member, BP_VAR_IS, key TSRMLS_CC);\n\t\t\t\tif (value != EG(uninitialized_zval_ptr)) {\n\t\t\t\t\tconvert_to_boolean(value);\n\t\t\t\t\tret = Z_BVAL_P(value)? 1:0;\n\t\t\t\t\t/* refcount is 0 */\n\t\t\t\t\tZ_ADDREF_P(value);\n\t\t\t\t\tzval_ptr_dtor(&value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tzend_object_handlers * std_hnd = zend_get_std_object_handlers();\n\t\tret = std_hnd->has_property(object, member, has_set_exists, key TSRMLS_CC);\n\t}\n\treturn ret;\n }\n",
        "output": "0",
        "index": 9553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long sys_oabi_lstat64(const char __user * filename,\n\t\t\t\t struct oldabi_stat64 __user * statbuf)\n{\n\tstruct kstat stat;\n\tint error = vfs_lstat(filename, &stat);\n\tif (!error)\n\t\terror = cp_oldabi_stat64(&stat, statbuf);\n\treturn error;\n}\n",
        "output": "0",
        "index": 27520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImageTransportFactory* ImageTransportFactory::GetInstance() {\n  return g_factory;\n}\n",
        "output": "0",
        "index": 122828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "buf_find_pos_of_char(char ch, buf_pos_t *out)\n{\n  const chunk_t *chunk;\n  int pos;\n  tor_assert(out);\n  if (out->chunk) {\n    if (out->chunk->datalen) {\n      tor_assert(out->pos < (off_t)out->chunk->datalen);\n    } else {\n      tor_assert(out->pos == 0);\n    }\n  }\n  pos = out->pos;\n  for (chunk = out->chunk; chunk; chunk = chunk->next) {\n    char *cp = memchr(chunk->data+pos, ch, chunk->datalen - pos);\n    if (cp) {\n      out->chunk = chunk;\n      tor_assert(cp - chunk->data < INT_MAX);\n      out->pos = (int)(cp - chunk->data);\n      return out->chunk_pos + out->pos;\n    } else {\n      out->chunk_pos += chunk->datalen;\n      pos = 0;\n    }\n  }\n  return -1;\n}\n",
        "output": "0",
        "index": 73145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}\n",
        "output": "0",
        "index": 34816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jbig2_huffman_skip(Jbig2HuffmanState *hs)\n{\n    int bits = hs->offset_bits & 7;\n\n    if (bits) {\n        bits = 8 - bits;\n        hs->offset_bits += bits;\n        hs->this_word = (hs->this_word << bits) | (hs->next_word >> (32 - hs->offset_bits));\n    }\n\n    if (hs->offset_bits >= 32) {\n        hs->this_word = hs->next_word;\n        hs->offset += 4;\n        hs->next_word = huff_get_next_word(hs, hs->offset + 4);\n        hs->offset_bits -= 32;\n        if (hs->offset_bits) {\n            hs->this_word = (hs->this_word << hs->offset_bits) | (hs->next_word >> (32 - hs->offset_bits));\n        }\n    }\n}\n",
        "output": "0",
        "index": 18047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n \tcase ACL_TYPE_ACCESS:\n \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n \t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n \t\t\t\treturn error;\n \t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n \t\t}\n \t\tbreak;\n \n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}\n",
        "output": "1",
        "index": 180143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void MSLProcessingInstructions(void *context,const xmlChar *target,\n  const xmlChar *data)\n{\n  MSLInfo\n    *msl_info;\n\n  /*\n    A processing instruction has been parsed.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.processingInstruction(%s, %s)\",\n    target,data);\n  msl_info=(MSLInfo *) context;\n  (void) msl_info;\n}\n",
        "output": "0",
        "index": 62787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool dev_type_flutter(enum sas_device_type new, enum sas_device_type old)\n{\n\tif (old == new)\n\t\treturn true;\n\n\t/* treat device directed resets as flutter, if we went\n\t * SAS_END_DEVICE to SAS_SATA_PENDING the link needs recovery\n\t */\n\tif ((old == SAS_SATA_PENDING && new == SAS_END_DEVICE) ||\n\t    (old == SAS_END_DEVICE && new == SAS_SATA_PENDING))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "output": "0",
        "index": 83923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_TJ(fz_context *ctx, pdf_processor *proc, pdf_obj *obj)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_show_text(ctx, pr, obj);\n}\n",
        "output": "0",
        "index": 496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rend_service_allow_non_anonymous_connection(const or_options_t *options)\n{\n  tor_assert(rend_service_non_anonymous_mode_consistent(options));\n  return options->HiddenServiceSingleHopMode ? 1 : 0;\n}\n",
        "output": "0",
        "index": 69603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sysbus_ahci_realize(DeviceState *dev, Error **errp)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n    SysbusAHCIState *s = SYSBUS_AHCI(dev);\n\n    ahci_init(&s->ahci, dev, &address_space_memory, s->num_ports);\n\n    sysbus_init_mmio(sbd, &s->ahci.mem);\n    sysbus_init_irq(sbd, &s->ahci.irq);\n}\n",
        "output": "0",
        "index": 15787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::RestoreClearState() {\n  framebuffer_state_.clear_state_dirty = true;\n  api()->glClearColorFn(state_.color_clear_red, state_.color_clear_green,\n                        state_.color_clear_blue, state_.color_clear_alpha);\n  api()->glClearStencilFn(state_.stencil_clear);\n  api()->glClearDepthFn(state_.depth_clear);\n  state_.SetDeviceCapabilityState(GL_SCISSOR_TEST,\n                                  state_.enable_flags.scissor_test);\n  RestoreDeviceWindowRectangles();\n  gfx::Vector2d scissor_offset = GetBoundFramebufferDrawOffset();\n  api()->glScissorFn(state_.scissor_x + scissor_offset.x(),\n                     state_.scissor_y + scissor_offset.y(),\n                     state_.scissor_width, state_.scissor_height);\n}\n",
        "output": "0",
        "index": 154343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::ShowCreatedWindow(int route_id,\n                                        WindowOpenDisposition disposition,\n                                        const gfx::Rect& initial_rect,\n                                        bool user_gesture) {\n  WebContentsImpl* contents = GetCreatedWindow(route_id);\n  if (contents) {\n    WebContentsDelegate* delegate = GetDelegate();\n    contents->is_resume_pending_ = true;\n    if (!delegate || delegate->ShouldResumeRequestsForCreatedWindow())\n      contents->ResumeLoadingCreatedWebContents();\n\n    if (delegate) {\n      delegate->AddNewContents(\n          this, contents, disposition, initial_rect, user_gesture, NULL);\n    }\n  }\n}\n",
        "output": "0",
        "index": 144686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_ecn_rcv_syn(struct tcp_sock *tp, const struct tcphdr *th)\n{\n\tif ((tp->ecn_flags & TCP_ECN_OK) && (!th->ece || !th->cwr))\n\t\ttp->ecn_flags &= ~TCP_ECN_OK;\n}\n",
        "output": "0",
        "index": 51543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int build_acquire(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t struct xfrm_tmpl *xt, struct xfrm_policy *xp,\n\t\t\t int dir)\n{\n\t__u32 seq = xfrm_get_acqseq();\n\tstruct xfrm_user_acquire *ua;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_ACQUIRE, sizeof(*ua), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tua = nlmsg_data(nlh);\n\tmemcpy(&ua->id, &x->id, sizeof(ua->id));\n\tmemcpy(&ua->saddr, &x->props.saddr, sizeof(ua->saddr));\n\tmemcpy(&ua->sel, &x->sel, sizeof(ua->sel));\n\tcopy_to_user_policy(xp, &ua->policy, dir);\n\tua->aalgos = xt->aalgos;\n\tua->ealgos = xt->ealgos;\n\tua->calgos = xt->calgos;\n\tua->seq = x->km.seq = seq;\n\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_state_sec_ctx(x, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_end(skb, nlh);\n}\n",
        "output": "0",
        "index": 33087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void report_error(struct translate_ctx *ctx, const char *format, ...)\n{\n   va_list args;\n   int line = 1;\n   int column = 1;\n   const char *itr = ctx->text;\n\n   debug_printf(\"\\nTGSI asm error: \");\n\n   va_start(args, format);\n   _debug_vprintf(format, args);\n   va_end(args);\n\n   while (itr != ctx->cur) {\n      if (*itr == '\\n') {\n         column = 1;\n         ++line;\n      }\n      ++column;\n      ++itr;\n   }\n\n   debug_printf(\" [%d : %d] \\n\", line, column);\n}\n",
        "output": "0",
        "index": 9746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MediaStreamManager::InitializeMaybeAsync(\n    std::unique_ptr<VideoCaptureProvider> video_capture_provider) {\n  if (!BrowserThread::CurrentlyOn(BrowserThread::IO)) {\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::BindOnce(&MediaStreamManager::InitializeMaybeAsync,\n                       base::Unretained(this),\n                       std::move(video_capture_provider)));\n    return;\n  }\n\n  g_media_stream_manager_tls_ptr.Pointer()->Set(this);\n\n  audio_input_device_manager_ = new AudioInputDeviceManager(audio_system_);\n  audio_input_device_manager_->RegisterListener(this);\n\n  base::MessageLoop::current()->AddDestructionObserver(this);\n\n  video_capture_manager_ =\n      new VideoCaptureManager(std::move(video_capture_provider),\n                              base::BindRepeating(&SendVideoCaptureLogMessage));\n  video_capture_manager_->RegisterListener(this);\n\n  media_devices_manager_.reset(\n      new MediaDevicesManager(audio_system_, video_capture_manager_, this));\n}\n",
        "output": "0",
        "index": 161136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ui_write(struct file *filp, const char __user *buf,\n\t\t\tsize_t count, loff_t *f_pos)\n{\n\tstruct hfi1_devdata *dd = filp->private_data;\n\tvoid __iomem *base;\n\tunsigned long total, data, csr_off;\n\tint in_lcb;\n\n\t/* only write 8 byte quantities */\n\tif ((count % 8) != 0)\n\t\treturn -EINVAL;\n\t/* offset must be 8-byte aligned */\n\tif ((*f_pos % 8) != 0)\n\t\treturn -EINVAL;\n\t/* source buffer must be 8-byte aligned */\n\tif ((unsigned long)buf % 8 != 0)\n\t\treturn -EINVAL;\n\t/* must be in range */\n\tif (*f_pos + count > dd->kregend - dd->kregbase)\n\t\treturn -EINVAL;\n\n\tbase = (void __iomem *)dd->kregbase + *f_pos;\n\tcsr_off = *f_pos;\n\tin_lcb = 0;\n\tfor (total = 0; total < count; total += 8, csr_off += 8) {\n\t\tif (get_user(data, (unsigned long __user *)(buf + total)))\n\t\t\tbreak;\n\t\t/* accessing LCB CSRs requires a special procedure */\n\t\tif (is_lcb_offset(csr_off)) {\n\t\t\tif (!in_lcb) {\n\t\t\t\tint ret = acquire_lcb_access(dd, 1);\n\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\t\t\t\tin_lcb = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (in_lcb) {\n\t\t\t\trelease_lcb_access(dd, 1);\n\t\t\t\tin_lcb = 0;\n\t\t\t}\n\t\t}\n\t\twriteq(data, base + total);\n\t}\n\tif (in_lcb)\n\t\trelease_lcb_access(dd, 1);\n\t*f_pos += total;\n\treturn total;\n}\n",
        "output": "0",
        "index": 52984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  JBIG2HuffmanTable *getHuffTable() { return table; }\n",
        "output": "0",
        "index": 1181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_inode_free(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(!xfs_isiflocked(ip));\n\n\t/*\n\t * Because we use RCU freeing we need to ensure the inode always\n\t * appears to be reclaimed with an invalid inode number when in the\n\t * free state. The ip->i_flags_lock provides the barrier against lookup\n\t * races.\n\t */\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags = XFS_IRECLAIM;\n\tip->i_ino = 0;\n\tspin_unlock(&ip->i_flags_lock);\n\n\t__xfs_inode_free(ip);\n}\n",
        "output": "0",
        "index": 79963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void free_camera_metadata(camera_metadata_t *metadata) {\n    free(metadata);\n}\n",
        "output": "0",
        "index": 171100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PassRefPtr<CSSPrimitiveValue> lineHeightFromStyle(RenderStyle* style, RenderView* renderView)\n{\n    Length length = style->lineHeight();\n    if (length.isNegative())\n        return cssValuePool().createIdentifierValue(CSSValueNormal);\n    if (length.isPercent())\n        return zoomAdjustedPixelValue(static_cast<int>(length.percent() * style->fontDescription().specifiedSize()) / 100, style);\n    return zoomAdjustedPixelValue(valueForLength(length, 0, renderView), style);\n}\n",
        "output": "0",
        "index": 104368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AutofillPopupItemView::OnMouseReleased(const ui::MouseEvent& event) {\n  AutofillPopupController* controller = popup_view_->controller();\n  if (controller && event.IsOnlyLeftMouseButton() &&\n      HitTestPoint(event.location())) {\n    controller->AcceptSuggestion(line_number_);\n  }\n}\n",
        "output": "0",
        "index": 141936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TestTransactionConsumer::TestTransactionConsumer(\n    RequestPriority priority,\n    HttpTransactionFactory* factory)\n    : state_(IDLE), error_(OK) {\n  factory->CreateTransaction(priority, &trans_);\n  ++quit_counter_;\n}\n",
        "output": "0",
        "index": 127770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::SaveImageAt(int x, int y) {\n  Send(new FrameMsg_SaveImageAt(routing_id_, x, y));\n}\n",
        "output": "0",
        "index": 138793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sig_server_setup_read(IRC_SERVER_SETUP_REC *rec, CONFIG_NODE *node)\n{\n\tg_return_if_fail(rec != NULL);\n\tg_return_if_fail(node != NULL);\n\n\tif (!IS_IRC_SERVER_SETUP(rec))\n\t\treturn;\n\n\trec->max_cmds_at_once = config_node_get_int(node, \"cmds_max_at_once\", 0);\n\trec->cmd_queue_speed = config_node_get_int(node, \"cmd_queue_speed\", 0);\n\trec->max_query_chans = config_node_get_int(node, \"max_query_chans\", 0);\n}\n",
        "output": "0",
        "index": 89423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void flush_nat_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct nat_entry_set *setvec[SETVEC_SIZE];\n\tstruct nat_entry_set *set, *tmp;\n\tunsigned int found;\n\tnid_t set_idx = 0;\n\tLIST_HEAD(sets);\n\n\tif (!nm_i->dirty_nat_cnt)\n\t\treturn;\n\n\tdown_write(&nm_i->nat_tree_lock);\n\n\t/*\n\t * if there are no enough space in journal to store dirty nat\n\t * entries, remove all entries from journal and merge them\n\t * into nat entry set.\n\t */\n\tif (enabled_nat_bits(sbi, cpc) ||\n\t\t!__has_cursum_space(journal, nm_i->dirty_nat_cnt, NAT_JOURNAL))\n\t\tremove_nats_in_journal(sbi);\n\n\twhile ((found = __gang_lookup_nat_set(nm_i,\n\t\t\t\t\tset_idx, SETVEC_SIZE, setvec))) {\n\t\tunsigned idx;\n\t\tset_idx = setvec[found - 1]->set + 1;\n\t\tfor (idx = 0; idx < found; idx++)\n\t\t\t__adjust_nat_entry_set(setvec[idx], &sets,\n\t\t\t\t\t\tMAX_NAT_JENTRIES(journal));\n\t}\n\n\t/* flush dirty nats in nat entry set */\n\tlist_for_each_entry_safe(set, tmp, &sets, set_list)\n\t\t__flush_nat_entry_set(sbi, set, cpc);\n\n\tup_write(&nm_i->nat_tree_lock);\n\n\tf2fs_bug_on(sbi, nm_i->dirty_nat_cnt);\n}\n",
        "output": "0",
        "index": 85264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::NativeView OmniboxViewWin::GetNativeView() const {\n  return m_hWnd;\n}\n",
        "output": "0",
        "index": 115204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ShouldTreatNavigationAsReload(const NavigationEntry* entry) {\n  if (!entry)\n    return false;\n\n  if ((ui::PageTransitionCoreTypeIs(entry->GetTransitionType(),\n                                    ui::PAGE_TRANSITION_RELOAD) &&\n       (entry->GetTransitionType() & ui::PAGE_TRANSITION_FROM_ADDRESS_BAR))) {\n    return true;\n  }\n\n  if (ui::PageTransitionCoreTypeIs(entry->GetTransitionType(),\n                                   ui::PAGE_TRANSITION_TYPED)) {\n    return true;\n  }\n\n  if (ui::PageTransitionCoreTypeIs(entry->GetTransitionType(),\n                                   ui::PAGE_TRANSITION_LINK)) {\n    return true;\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 169418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aesni_cbc_hmac_sha256_init_key(EVP_CIPHER_CTX *ctx,\n                                          const unsigned char *inkey,\n                                          const unsigned char *iv, int enc)\n{\n    EVP_AES_HMAC_SHA256 *key = data(ctx);\n    int ret;\n\n    if (enc)\n        memset(&key->ks, 0, sizeof(key->ks.rd_key)),\n            ret = aesni_set_encrypt_key(inkey, ctx->key_len * 8, &key->ks);\n    else\n        ret = aesni_set_decrypt_key(inkey, ctx->key_len * 8, &key->ks);\n\n    SHA256_Init(&key->head);    /* handy when benchmarking */\n    key->tail = key->head;\n    key->md = key->head;\n\n    key->payload_length = NO_PAYLOAD_LENGTH;\n\n    return ret < 0 ? 0 : 1;\n}\n",
        "output": "0",
        "index": 12859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_inobp_check(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\txfs_dinode_t\t*dip;\n\n\tj = mp->m_inode_cluster_size >> mp->m_sb.sb_inodelog;\n\n\tfor (i = 0; i < j; i++) {\n\t\tdip = xfs_buf_offset(bp, i * mp->m_sb.sb_inodesize);\n\t\tif (!dip->di_next_unlinked)  {\n\t\t\txfs_alert(mp,\n\t\"Detected bogus zero next_unlinked field in inode %d buffer 0x%llx.\",\n\t\t\t\ti, (long long)bp->b_bn);\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 79896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string GetManagedLoginScreenLocale() {\n  chromeos::CrosSettings* cros_settings = chromeos::CrosSettings::Get();\n  const base::ListValue* login_screen_locales = nullptr;\n  if (!cros_settings->GetList(chromeos::kDeviceLoginScreenLocales,\n                              &login_screen_locales))\n    return std::string();\n\n  std::string login_screen_locale;\n  if (login_screen_locales->empty() ||\n      !login_screen_locales->GetString(0, &login_screen_locale))\n    return std::string();\n\n  return login_screen_locale;\n}\n",
        "output": "0",
        "index": 144295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}\n",
        "output": "0",
        "index": 67373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebThemeEngine* LayoutTestContentRendererClient::OverrideThemeEngine() {\n  return LayoutTestRenderProcessObserver::GetInstance()\n      ->test_interfaces()\n      ->ThemeEngine();\n}\n",
        "output": "0",
        "index": 132698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void megasas_frame_set_cmd_status(MegasasState *s,\n                                         unsigned long frame, uint8_t v)\n{\n    PCIDevice *pci = &s->parent_obj;\n    stb_pci_dma(pci, frame + offsetof(struct mfi_frame_header, cmd_status), v);\n}\n",
        "output": "0",
        "index": 10446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebKitTestController::ResetAfterLayoutTest() {\n  DCHECK(CalledOnValidThread());\n  printer_->PrintTextFooter();\n  printer_->PrintImageFooter();\n  printer_->CloseStderr();\n  send_configuration_to_next_host_ = false;\n  test_phase_ = BETWEEN_TESTS;\n  is_compositing_test_ = false;\n  enable_pixel_dumping_ = false;\n  expected_pixel_hash_.clear();\n  test_url_ = GURL();\n  prefs_ = WebPreferences();\n  should_override_prefs_ = false;\n\n#if defined(OS_ANDROID)\n  DiscardMainWindow();\n#endif\n  return true;\n}\n",
        "output": "0",
        "index": 132606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebContentsImpl::~WebContentsImpl() {\n  is_being_destroyed_ = true;\n\n  ClearAllPowerSaveBlockers();\n\n  for (std::set<RenderWidgetHostImpl*>::iterator iter =\n           created_widgets_.begin(); iter != created_widgets_.end(); ++iter) {\n    (*iter)->DetachDelegate();\n  }\n  created_widgets_.clear();\n\n  if (dialog_manager_)\n    dialog_manager_->WebContentsDestroyed(this);\n\n  if (color_chooser_)\n    color_chooser_->End();\n\n  NotifyDisconnected();\n\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_DESTROYED,\n      Source<WebContents>(this),\n      NotificationService::NoDetails());\n\n#if defined(OS_WIN) && !defined(USE_AURA)\n  if (view_->GetNativeView()) {\n    RenderViewHost* host = GetRenderViewHost();\n    if (host && host->GetView())\n      RenderWidgetHostViewPort::FromRWHV(host->GetView())->WillWmDestroy();\n  }\n#endif\n\n  RenderViewHost* pending_rvh = GetRenderManager()->pending_render_view_host();\n  if (pending_rvh) {\n    FOR_EACH_OBSERVER(WebContentsObserver,\n                      observers_,\n                      RenderViewDeleted(pending_rvh));\n  }\n\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    RenderViewDeleted(GetRenderManager()->current_host()));\n\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    WebContentsImplDestroyed());\n\n  SetDelegate(NULL);\n\n  STLDeleteContainerPairSecondPointers(destruction_observers_.begin(),\n                                       destruction_observers_.end());\n}\n",
        "output": "0",
        "index": 133644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int user_page_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\n\t\treturn 1;\n\n\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\treturn generic_pipe_buf_steal(pipe, buf);\n}\n",
        "output": "0",
        "index": 46397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImportSingleTIFF_Long ( const TIFF_Manager::TagInfo & tagInfo, const bool nativeEndian,\n\t\t\t\t\t\tSXMPMeta * xmp, const char * xmpNS, const char * xmpProp )\n{\n\ttry {\t// Don't let errors with one stop the others.\n\n\t\tXMP_Uns32 binValue = GetUns32AsIs ( tagInfo.dataPtr );\n\t\tif ( ! nativeEndian ) binValue = Flip4 ( binValue );\n\n\t\tchar strValue[20];\n\t\tsnprintf ( strValue, sizeof(strValue), \"%lu\", (unsigned long)binValue );\t// AUDIT: Using sizeof(strValue) is safe.\n\n\t\txmp->SetProperty ( xmpNS, xmpProp, strValue );\n\n\t} catch ( ... ) {\n\t}\n\n}\t// ImportSingleTIFF_Long\n",
        "output": "0",
        "index": 15974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void S_AL_Gain(ALuint source, float gainval)\n{\n\tif(s_muted->integer)\n\t\tqalSourcef(source, AL_GAIN, 0.0f);\n\telse\n\t\tqalSourcef(source, AL_GAIN, gainval);\n}\n",
        "output": "0",
        "index": 95528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setJSTestObjDoubleSequenceAttr(ExecState* exec, JSObject* thisObject, JSValue value)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(thisObject);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    impl->setDoubleSequenceAttr(toNativeArray<double>(exec, value));\n}\n",
        "output": "0",
        "index": 106206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AttestationPermissionRequestSheetModel::OnAccept() {\n  dialog_model()->OnAttestationPermissionResponse(true);\n}\n",
        "output": "0",
        "index": 155678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Platform::IntSize WebPagePrivate::recomputeVirtualViewportFromViewportArguments()\n{\n    static const ViewportArguments defaultViewportArguments;\n    if (m_viewportArguments == defaultViewportArguments)\n        return IntSize();\n\n    int desktopWidth = DEFAULT_MAX_LAYOUT_WIDTH;\n    int deviceWidth = Platform::Graphics::Screen::primaryScreen()->width();\n    int deviceHeight = Platform::Graphics::Screen::primaryScreen()->height();\n    float devicePixelRatio = m_webSettings->devicePixelRatio();\n    ViewportAttributes result = computeViewportAttributes(m_viewportArguments, desktopWidth, deviceWidth, deviceHeight, devicePixelRatio, m_defaultLayoutSize);\n    m_page->setDeviceScaleFactor(devicePixelRatio);\n\n    setUserScalable(m_webSettings->isUserScalable() && result.userScalable);\n    if (result.initialScale > 0)\n        setInitialScale(result.initialScale * devicePixelRatio);\n    if (result.minimumScale > 0)\n        setMinimumScale(result.minimumScale * devicePixelRatio);\n    if (result.maximumScale > 0)\n        setMaximumScale(result.maximumScale * devicePixelRatio);\n\n    return Platform::IntSize(result.layoutSize.width(), result.layoutSize.height());\n}\n",
        "output": "0",
        "index": 111291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_uiserver_decrypt (void *engine, int verify,\n\t\t   gpgme_data_t ciph, gpgme_data_t plain)\n{\n  engine_uiserver_t uiserver = engine;\n  gpgme_error_t err;\n  const char *protocol;\n  char *cmd;\n\n  if (!uiserver)\n    return gpg_error (GPG_ERR_INV_VALUE);\n  if (uiserver->protocol == GPGME_PROTOCOL_DEFAULT)\n    protocol = \"\";\n  else if (uiserver->protocol == GPGME_PROTOCOL_OpenPGP)\n    protocol = \" --protocol=OpenPGP\";\n  else if (uiserver->protocol == GPGME_PROTOCOL_CMS)\n    protocol = \" --protocol=CMS\";\n  else\n    return gpgme_error (GPG_ERR_UNSUPPORTED_PROTOCOL);\n\n  if (asprintf (&cmd, \"DECRYPT%s%s\", protocol,\n\t\tverify ? \"\" : \" --no-verify\") < 0)\n    return gpg_error_from_syserror ();\n\n  uiserver->input_cb.data = ciph;\n  err = uiserver_set_fd (uiserver, INPUT_FD,\n\t\t\t map_data_enc (uiserver->input_cb.data));\n  if (err)\n    {\n      free (cmd);\n      return gpg_error (GPG_ERR_GENERAL);\t/* FIXME */\n    }\n  uiserver->output_cb.data = plain;\n  err = uiserver_set_fd (uiserver, OUTPUT_FD, 0);\n  if (err)\n    {\n      free (cmd);\n      return gpg_error (GPG_ERR_GENERAL);\t/* FIXME */\n    }\n  uiserver->inline_data = NULL;\n\n  err = start (engine, cmd);\n  free (cmd);\n  return err;\n}\n",
        "output": "0",
        "index": 12290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)\n{\n\tint yy_is_jam;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */\n\tchar *yy_cp = yyg->yy_c_buf_p;\n\n\tYY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 45 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 44);\n\n\t(void)yyg;\n\treturn yy_is_jam ? 0 : yy_current_state;\n}\n",
        "output": "0",
        "index": 70513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const base::FilePath& test_file() const { return test_file_; }\n",
        "output": "0",
        "index": 166471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ib_uverbs_init_event_queue(struct ib_uverbs_event_queue *ev_queue)\n{\n\tspin_lock_init(&ev_queue->lock);\n\tINIT_LIST_HEAD(&ev_queue->event_list);\n\tinit_waitqueue_head(&ev_queue->poll_wait);\n\tev_queue->is_closed   = 0;\n\tev_queue->async_queue = NULL;\n}\n",
        "output": "0",
        "index": 90460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TabStripGtk::GetMiniTabCount() const {\n  int mini_count = 0;\n  for (size_t i = 0; i < tab_data_.size(); ++i) {\n    if (tab_data_[i].tab->mini())\n      mini_count++;\n    else\n      return mini_count;\n  }\n  return mini_count;\n}\n",
        "output": "0",
        "index": 126514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t GLES2Implementation::ShareGroupTracingGUID() const {\n  return share_group_->TracingGUID();\n}\n",
        "output": "0",
        "index": 153816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Handle<v8::Value> V8WebGLRenderingContext::getExtensionCallback(const v8::Arguments& args)\n{\n     INC_STATS(\"DOM.WebGLRenderingContext.getExtensionCallback()\");\n     WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, args[0]);\n     WebGLExtension* extension = imp->getExtension(name);\n     return toV8Object(extension, args.Holder(), args.GetIsolate());\n}\n",
        "output": "1",
        "index": 184813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl = NULL;\n\tstruct xfs_acl *xfs_acl;\n\tunsigned char *ea_name;\n\tint error;\n\tint len;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\tlen = XFS_ACL_MAX_SIZE(ip->i_mount);\n\txfs_acl = kmem_zalloc_large(len, KM_SLEEP);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient.\n\t\t */\n\t\tif (error != -ENOATTR)\n\t\t\tacl = ERR_PTR(error);\n\t} else  {\n\t\tacl = xfs_acl_from_disk(xfs_acl, len,\n\t\t\t\t\tXFS_ACL_MAX_ENTRIES(ip->i_mount));\n\t}\n\tkmem_free(xfs_acl);\n\treturn acl;\n}\n",
        "output": "0",
        "index": 50406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\t/* Cache the lock if possible... */\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, 1);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "output": "0",
        "index": 22877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int airspy_g_frequency(struct file *file, void *priv,\n\t\tstruct v4l2_frequency *f)\n{\n\tstruct airspy *s = video_drvdata(file);\n\tint ret;\n\n\tif (f->tuner == 0) {\n\t\tf->type = V4L2_TUNER_ADC;\n\t\tf->frequency = s->f_adc;\n\t\tdev_dbg(s->dev, \"ADC frequency=%u Hz\\n\", s->f_adc);\n\t\tret = 0;\n\t} else if (f->tuner == 1) {\n\t\tf->type = V4L2_TUNER_RF;\n\t\tf->frequency = s->f_rf;\n\t\tdev_dbg(s->dev, \"RF frequency=%u Hz\\n\", s->f_rf);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 51662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool PluginInstance::ConvertPoint(double source_x, double source_y,\n                                  NPCoordinateSpace source_space,\n                                  double* dest_x, double* dest_y,\n                                  NPCoordinateSpace dest_space) {\n#if defined(OS_MACOSX)\n  CGRect main_display_bounds = CGDisplayBounds(CGMainDisplayID());\n\n  double flipped_screen_x = source_x;\n  double flipped_screen_y = source_y;\n  switch(source_space) {\n    case NPCoordinateSpacePlugin:\n      flipped_screen_x += plugin_origin_.x();\n      flipped_screen_y += plugin_origin_.y();\n      break;\n    case NPCoordinateSpaceScreen:\n      flipped_screen_y = main_display_bounds.size.height - flipped_screen_y;\n    case NPCoordinateSpaceFlippedScreen:\n      break;\n    case NPCoordinateSpaceWindow:\n    case NPCoordinateSpaceFlippedWindow:\n      NOTIMPLEMENTED();\n      return false;\n    default:\n      NOTREACHED();\n      return false;\n  }\n\n  double target_x = flipped_screen_x;\n  double target_y = flipped_screen_y;\n  switch(dest_space) {\n    case NPCoordinateSpacePlugin:\n      target_x -= plugin_origin_.x();\n      target_y -= plugin_origin_.y();\n      break;\n    case NPCoordinateSpaceScreen:\n      target_y = main_display_bounds.size.height - flipped_screen_y;\n    case NPCoordinateSpaceFlippedScreen:\n      break;\n    case NPCoordinateSpaceWindow:\n    case NPCoordinateSpaceFlippedWindow:\n      NOTIMPLEMENTED();\n      return false;\n    default:\n      NOTREACHED();\n      return false;\n  }\n\n  if (dest_x)\n    *dest_x = target_x;\n  if (dest_y)\n    *dest_y = target_y;\n  return true;\n#else\n  NOTIMPLEMENTED();\n  return false;\n #endif\n }\n",
        "output": "0",
        "index": 99939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ~CancelThenRestartTestJob() {}\n",
        "output": "0",
        "index": 108665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit sclp_ctl_exit(void)\n{\n\tmisc_deregister(&sclp_ctl_device);\n}\n",
        "output": "0",
        "index": 51180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *dec3_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\ttmp->cfg.is_ec3 = 1;\n\treturn (GF_Box *)tmp;\n}\n",
        "output": "0",
        "index": 80039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CSSStyleDeclaration* Document::getOverrideStyle(Element*, const String&)\n{\n    return 0;\n}\n",
        "output": "0",
        "index": 109687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_task(struct task_struct *task,\n\t\t\t      struct perf_event_context *task_ctx,\n\t\t\t      int new)\n{\n\tstruct perf_task_event task_event;\n\n\tif (!atomic_read(&nr_comm_events) &&\n\t    !atomic_read(&nr_mmap_events) &&\n\t    !atomic_read(&nr_task_events))\n\t\treturn;\n\n\ttask_event = (struct perf_task_event){\n\t\t.task\t  = task,\n\t\t.task_ctx = task_ctx,\n\t\t.event_id    = {\n\t\t\t.header = {\n\t\t\t\t.type = new ? PERF_RECORD_FORK : PERF_RECORD_EXIT,\n\t\t\t\t.misc = 0,\n\t\t\t\t.size = sizeof(task_event.event_id),\n\t\t\t},\n\t\t\t/* .pid  */\n\t\t\t/* .ppid */\n\t\t\t/* .tid  */\n\t\t\t/* .ptid */\n\t\t\t.time = perf_clock(),\n\t\t},\n\t};\n\n\tperf_event_aux(perf_event_task_output,\n\t\t       &task_event,\n\t\t       task_ctx);\n}\n",
        "output": "0",
        "index": 50494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "getbits (long data, unsigned char *dst)\n{\n    dst[0] = (data      ) & 0xff;\n    dst[1] = (data >>  8) & 0xff;\n    dst[2] = (data >> 16) & 0xff;\n    dst[3] = (data >> 24) & 0xff;\n}\n",
        "output": "0",
        "index": 17928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dtls1_hm_fragment_new(unsigned long frag_len, int reassembly)\n\t{\n\thm_fragment *frag = NULL;\n\tunsigned char *buf = NULL;\n\tunsigned char *bitmask = NULL;\n\n\tfrag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));\n\tif ( frag == NULL)\n\t\treturn NULL;\n\n\tif (frag_len)\n\t\t{\n\t\tbuf = (unsigned char *)OPENSSL_malloc(frag_len);\n\t\tif ( buf == NULL)\n\t\t\t{\n\t\t\tOPENSSL_free(frag);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t/* zero length fragment gets zero frag->fragment */\n\tfrag->fragment = buf;\n\n\t/* Initialize reassembly bitmask if necessary */\n\tif (reassembly)\n\t\t{\n\t\tbitmask = (unsigned char *)OPENSSL_malloc(RSMBLY_BITMASK_SIZE(frag_len));\n\t\tif (bitmask == NULL)\n\t\t\t{\n\t\t\tif (buf != NULL) OPENSSL_free(buf);\n\t\t\tOPENSSL_free(frag);\n\t\t\treturn NULL;\n\t\t\t}\n\t\tmemset(bitmask, 0, RSMBLY_BITMASK_SIZE(frag_len));\n\t\t}\n\n\tfrag->reassembly = bitmask;\n\n\treturn frag;\n\t}\n",
        "output": "0",
        "index": 12490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " addrs_in_same_network_family(const tor_addr_t *a1,\n                              const tor_addr_t *a2)\n {\n  return 0 == tor_addr_compare_masked(a1, a2, 16, CMP_SEMANTIC);\n}\n",
        "output": "0",
        "index": 69762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PrintMsg_Print_Params::~PrintMsg_Print_Params() {}\n",
        "output": "0",
        "index": 112808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int drm_mode_addfb(struct drm_device *dev,\n\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_mode_fb_cmd *r = data;\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_framebuffer *fb;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\n\tif ((config->min_width > r->width) || (r->width > config->max_width)) {\n\t\tDRM_ERROR(\"mode new framebuffer width not within limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((config->min_height > r->height) || (r->height > config->max_height)) {\n\t\tDRM_ERROR(\"mode new framebuffer height not within limits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dev->mode_config.mutex);\n\n\t/* TODO check buffer is sufficiently large */\n\t/* TODO setup destructor callback */\n\n\tfb = dev->mode_config.funcs->fb_create(dev, file_priv, r);\n\tif (IS_ERR(fb)) {\n\t\tDRM_ERROR(\"could not create framebuffer\\n\");\n\t\tret = PTR_ERR(fb);\n\t\tgoto out;\n\t}\n\n\tr->fb_id = fb->base.id;\n\tlist_add(&fb->filp_head, &file_priv->fbs);\n\tDRM_DEBUG_KMS(\"[FB:%d]\\n\", fb->base.id);\n\nout:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 21876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " unsigned getMaxBlockSize() const {\n return mStreamInfo.max_blocksize;\n }\n",
        "output": "0",
        "index": 175682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CompositorElementId GetMaskEffectId() const { return mask_effect_id_; }\n",
        "output": "0",
        "index": 136389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PDFiumEngine::SetInFormTextArea(bool in_form_text_area) {\n  if (in_form_text_area_)\n    pp::PDF::SetSelectedText(GetPluginInstance(), \"\");\n\n  client_->FormTextFieldFocusChange(in_form_text_area);\n  in_form_text_area_ = in_form_text_area;\n\n  if (!in_form_text_area_)\n    editable_form_text_area_ = false;\n}\n",
        "output": "0",
        "index": 159024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_zip_get_num_files(struct zip *za TSRMLS_DC) /* {{{ */\n{\n\treturn zip_get_num_files(za);\n}\n/* }}} */\n",
        "output": "0",
        "index": 51294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RendererSchedulerImpl::DecrementVirtualTimePauseCount() {\n  main_thread_only().virtual_time_pause_count--;\n  DCHECK_GE(main_thread_only().virtual_time_pause_count, 0);\n  ApplyVirtualTimePolicy();\n}\n",
        "output": "0",
        "index": 156182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void eventHandlerAttrAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectV8Internal::eventHandlerAttrAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 130782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_ssi_exec(struct mg_connection *conn, char *tag)\n{\n\tchar cmd[1024] = \"\";\n\tstruct mg_file file = STRUCT_FILE_INITIALIZER;\n\n\tif (sscanf(tag, \" \\\"%1023[^\\\"]\\\"\", cmd) != 1) {\n\t\tmg_cry_internal(conn, \"Bad SSI #exec: [%s]\", tag);\n\t} else {\n\t\tcmd[1023] = 0;\n\t\tif ((file.access.fp = popen(cmd, \"r\")) == NULL) {\n\t\t\tmg_cry_internal(conn,\n\t\t\t                \"Cannot SSI #exec: [%s]: %s\",\n\t\t\t                cmd,\n\t\t\t                strerror(ERRNO));\n\t\t} else {\n\t\t\tsend_file_data(conn, &file, 0, INT64_MAX);\n\t\t\tpclose(file.access.fp);\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 81652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int try_get_ioctx(struct kioctx *kioctx)\n{\n\treturn atomic_inc_not_zero(&kioctx->users);\n}\n",
        "output": "0",
        "index": 21700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLCanvasElement::setHeight(unsigned value,\n                                  ExceptionState& exception_state) {\n  if (IsPlaceholderRegistered()) {\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kInvalidStateError,\n        \"Cannot resize canvas after call to transferControlToOffscreen().\");\n    return;\n  }\n  SetUnsignedIntegralAttribute(kHeightAttr, value, kDefaultCanvasHeight);\n}\n",
        "output": "0",
        "index": 165049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tty_flush_works(struct tty_struct *tty)\n{\n\tflush_work(&tty->SAK_work);\n\tflush_work(&tty->hangup_work);\n\tif (tty->link) {\n\t\tflush_work(&tty->link->SAK_work);\n\t\tflush_work(&tty->link->hangup_work);\n\t}\n}\n",
        "output": "0",
        "index": 55916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserView::Show() {\n  if (frame_->IsVisible()) {\n    frame_->Activate();\n    return;\n  }\n\n  CreateLauncherIcon();\n\n  force_location_bar_focus_ = true;\n\n  RestoreFocus();\n\n  frame_->Show();\n\n  force_location_bar_focus_ = false;\n\n  browser()->OnWindowDidShow();\n\n  chrome::MaybeShowInvertBubbleView(browser_.get(), contents_);\n}\n",
        "output": "0",
        "index": 126856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp)\n{\n\treturn _xdr_kadm5_policy_ent_rec(xdrs, objp, KADM5_API_VERSION_4);\n}\n",
        "output": "0",
        "index": 46063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)\n{\n\tvoid *target;\n\tvoid *padding;\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tint padlen = WORD_ROUND(chunklen) - chunklen;\n\n\tpadding = skb_put(chunk->skb, padlen);\n\ttarget = skb_put(chunk->skb, len);\n\n\tmemset(padding, 0, padlen);\n\tmemcpy(target, data, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + padlen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n",
        "output": "0",
        "index": 35831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int blkcipher_walk_virt_block(struct blkcipher_desc *desc,\n\t\t\t      struct blkcipher_walk *walk,\n\t\t\t      unsigned int blocksize)\n{\n\twalk->flags &= ~BLKCIPHER_WALK_PHYS;\n\twalk->blocksize = blocksize;\n\treturn blkcipher_walk_first(desc, walk);\n}\n",
        "output": "0",
        "index": 31285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool pmd_trans_migrating(pmd_t pmd)\n{\n\tstruct page *page = pmd_page(pmd);\n\treturn PageLocked(page);\n}\n",
        "output": "0",
        "index": 54489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aiff_get_chunk_size (SF_PRIVATE *psf, const SF_CHUNK_ITERATOR * iterator, SF_CHUNK_INFO * chunk_info)\n{\tint indx ;\n\n\tif ((indx = psf_find_read_chunk_iterator (&psf->rchunks, iterator)) < 0)\n\t\treturn SFE_UNKNOWN_CHUNK ;\n\n\tchunk_info->datalen = psf->rchunks.chunks [indx].len ;\n\n\treturn SFE_NO_ERROR ;\n} /* aiff_get_chunk_size */\n",
        "output": "0",
        "index": 67867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ash::SessionStateDelegate* ShellDelegateImpl::CreateSessionStateDelegate() {\n  return new SessionStateDelegateImpl;\n}\n",
        "output": "0",
        "index": 133392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __account_system_time(struct task_struct *p, cputime_t cputime,\n\t\t\tcputime_t cputime_scaled, cputime64_t *target_cputime64)\n{\n\tcputime64_t tmp = cputime_to_cputime64(cputime);\n\n\t/* Add system time to process. */\n\tp->stime = cputime_add(p->stime, cputime);\n\tp->stimescaled = cputime_add(p->stimescaled, cputime_scaled);\n\taccount_group_system_time(p, cputime);\n\n\t/* Add system time to cpustat. */\n\t*target_cputime64 = cputime64_add(*target_cputime64, tmp);\n\tcpuacct_update_stats(p, CPUACCT_STAT_SYSTEM, cputime);\n\n\t/* Account for system time used */\n\tacct_update_integrals(p);\n}\n",
        "output": "0",
        "index": 26243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int SocketStream::Delegate::OnStartOpenConnection(\n    SocketStream* socket, const CompletionCallback& callback) {\n  return OK;\n}\n",
        "output": "0",
        "index": 120964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t\tvoid CWebServer::SetWebRoot(const std::string &webRoot)\n\t\t{\n\t\t\tif (m_pWebEm == NULL)\n\t\t\t\treturn;\n\t\t\tm_pWebEm->SetWebRoot(webRoot);\n\t\t}\n",
        "output": "0",
        "index": 91076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int X509_STORE_CTX_get_ex_new_index(long argl, void *argp,\n                                    CRYPTO_EX_new *new_func,\n                                    CRYPTO_EX_dup *dup_func,\n                                    CRYPTO_EX_free *free_func)\n{\n    /*\n     * This function is (usually) called only once, by\n     * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c).\n     */\n    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,\n                                   new_func, dup_func, free_func);\n}\n",
        "output": "0",
        "index": 5000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TranslateManager::RevertTranslation(TabContents* tab_contents) {\n  NavigationEntry* entry = tab_contents->controller().GetActiveEntry();\n  if (!entry) {\n    NOTREACHED();\n    return;\n  }\n  tab_contents->render_view_host()->RevertTranslation(entry->page_id());\n  tab_contents->language_state().set_current_language(\n      tab_contents->language_state().original_language());\n}\n",
        "output": "0",
        "index": 98193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "checkBackBuffer(Buffer *buf)\n{\n    Buffer *fbuf = buf->linkBuffer[LB_N_FRAME];\n\n    if (fbuf) {\n\tif (fbuf->frameQ)\n\t    return TRUE;\t/* Currentbuf has stacked frames */\n\t/* when no frames stacked and next is frame source, try next's\n\t * nextBuffer */\n\tif (RenderFrame && fbuf == buf->nextBuffer) {\n\t    if (fbuf->nextBuffer != NULL)\n\t\treturn TRUE;\n\t    else\n\t\treturn FALSE;\n\t}\n    }\n\n    if (buf->nextBuffer)\n\treturn TRUE;\n\n    return FALSE;\n}\n",
        "output": "0",
        "index": 84468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "correct_table_matrix2(struct table *t, int col, int cspan, double s, double b)\n{\n    int i, j;\n    int ecol = col + cspan;\n    int size = t->maxcol + 1;\n    double w = 1. / (b * b);\n    double ss;\n\n    for (i = 0; i < size; i++) {\n\tfor (j = i; j < size; j++) {\n\t    if (i >= col && i < ecol && j >= col && j < ecol)\n\t\tss = (1. - s) * (1. - s);\n\t    else if ((i >= col && i < ecol) || (j >= col && j < ecol))\n\t\tss = -(1. - s) * s;\n\t    else\n\t\tss = s * s;\n\t    m_add_val(t->matrix, i, j, w * ss);\n\t}\n    }\n}\n",
        "output": "0",
        "index": 84616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebKitTestController::DiscardMainWindow() {\n  WebContentsObserver::Observe(NULL);\n  if (test_phase_ != BETWEEN_TESTS) {\n    Shell::CloseAllWindows();\n    base::MessageLoop::current()->PostTask(FROM_HERE,\n                                           base::MessageLoop::QuitClosure());\n    test_phase_ = CLEAN_UP;\n  } else if (main_window_) {\n    main_window_->Close();\n  }\n  main_window_ = NULL;\n  current_pid_ = base::kNullProcessId;\n}\n",
        "output": "0",
        "index": 132569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GetWord(Buffer *buf)\n{\n    int b, e;\n    char *p;\n\n    if ((p = getCurWord(buf, &b, &e)) != NULL) {\n\treturn Strnew_charp_n(p, e - b)->ptr;\n    }\n    return NULL;\n}\n",
        "output": "0",
        "index": 84449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JsVar *jsvNewArrayBufferWithData(JsVarInt length, unsigned char *data) {\n  assert(data);\n  JsVar *dst = 0;\n  JsVar *arr = jsvNewArrayBufferWithPtr((unsigned int)length, (char**)&dst);\n  if (!dst) {\n    jsvUnLock(arr);\n    return 0;\n  }\n  memcpy(dst, data, (size_t)length);\n  return arr;\n}\n",
        "output": "0",
        "index": 82513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceMessageFilter::OnPreCacheFont(LOGFONT font) {\n\n  static const int kFontCacheSize = 32;\n  static HFONT fonts[kFontCacheSize] = {0};\n  static HDC hdcs[kFontCacheSize] = {0};\n  static size_t font_index = 0;\n\n  UMA_HISTOGRAM_COUNTS_100(\"Memory.CachedFontAndDC\",\n      fonts[kFontCacheSize-1] ? kFontCacheSize : static_cast<int>(font_index));\n\n  HDC hdc = GetDC(NULL);\n  HFONT font_handle = CreateFontIndirect(&font);\n  DCHECK(NULL != font_handle);\n\n  HGDIOBJ old_font = SelectObject(hdc, font_handle);\n  DCHECK(NULL != old_font);\n\n  TEXTMETRIC tm;\n  BOOL ret = GetTextMetrics(hdc, &tm);\n  DCHECK(ret);\n\n  if (fonts[font_index] || hdcs[font_index]) {\n    DeleteObject(fonts[font_index]);\n    ReleaseDC(NULL, hdcs[font_index]);\n  }\n\n  fonts[font_index] = font_handle;\n  hdcs[font_index] = hdc;\n  font_index = (font_index + 1) % kFontCacheSize;\n}\n",
        "output": "0",
        "index": 99326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sas_ata_strategy_handler(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\tASYNC_DOMAIN_EXCLUSIVE(async);\n\tint i;\n\n\t/* it's ok to defer revalidation events during ata eh, these\n\t * disks are in one of three states:\n\t * 1/ present for initial domain discovery, and these\n\t *    resets will cause bcn flutters\n\t * 2/ hot removed, we'll discover that after eh fails\n\t * 3/ hot added after initial discovery, lost the race, and need\n\t *    to catch the next train.\n\t */\n\tsas_disable_revalidation(sas_ha);\n\n\tspin_lock_irq(&sas_ha->phy_port_lock);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\t\tstruct domain_device *dev;\n\n\t\tspin_lock(&port->dev_list_lock);\n\t\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\t\tif (!dev_is_sata(dev))\n\t\t\t\tcontinue;\n\n\t\t\t/* hold a reference over eh since we may be\n\t\t\t * racing with final remove once all commands\n\t\t\t * are completed\n\t\t\t */\n\t\t\tkref_get(&dev->kref);\n\n\t\t\tasync_schedule_domain(async_sas_ata_eh, dev, &async);\n\t\t}\n\t\tspin_unlock(&port->dev_list_lock);\n\t}\n\tspin_unlock_irq(&sas_ha->phy_port_lock);\n\n\tasync_synchronize_full_domain(&async);\n\n\tsas_enable_revalidation(sas_ha);\n}\n",
        "output": "0",
        "index": 85454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void crypto_cts_free(struct crypto_instance *inst)\n{\n\tcrypto_drop_spawn(crypto_instance_ctx(inst));\n\tkfree(inst);\n}\n",
        "output": "0",
        "index": 45700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bin_mach0_versioninfo(RCore *r) {\n\t/* TODO */\n}\n",
        "output": "0",
        "index": 82959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)\n{\n\tint ret, i;\n\tstruct dvb_usb_device *d = adap_to_d(adap);\n\n\tdev_dbg(&d->udev->dev, \"%s: adap=%d\\n\", __func__, adap->id);\n\n\tfor (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {\n\t\tif (adap->fe[i]) {\n\t\t\tdvb_unregister_frontend(adap->fe[i]);\n\t\t\tdvb_frontend_detach(adap->fe[i]);\n\t\t}\n\t}\n\n\tif (d->props->tuner_detach) {\n\t\tret = d->props->tuner_detach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev, \"%s: tuner_detach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\n\tif (d->props->frontend_detach) {\n\t\tret = d->props->frontend_detach(adap);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&d->udev->dev,\n\t\t\t\t\t\"%s: frontend_detach() failed=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 66683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tswitch (ctxt->modrm_reg) {\n \tcase 2: /* call near abs */ {\n \t\tlong int old_eip;\n \t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n \t\tctxt->src.val = old_eip;\n \t\trc = em_push(ctxt);\n \t\tbreak;\n \t}\n \tcase 4: /* jmp abs */\n\t\tctxt->_eip = ctxt->src.val;\n \t\tbreak;\n \tcase 5: /* jmp far */\n \t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t/* push */\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}\n",
        "output": "1",
        "index": 183082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __put_anon_vma(struct anon_vma *anon_vma)\n{\n\tstruct anon_vma *root = anon_vma->root;\n\n\tif (root != anon_vma && atomic_dec_and_test(&root->refcount))\n\t\tanon_vma_free(root);\n\n\tanon_vma_free(anon_vma);\n}\n",
        "output": "0",
        "index": 38283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TopSitesImpl::RegisterPrefs(PrefRegistrySimple* registry) {\n  registry->RegisterDictionaryPref(kMostVisitedURLsBlacklist);\n}\n",
        "output": "0",
        "index": 159894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fep_client_get_poll_fd (FepClient *client)\n{\n  return client->control;\n}\n",
        "output": "0",
        "index": 36963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "String BaseRenderingContext2D::textAlign() const {\n  return TextAlignName(GetState().GetTextAlign());\n}\n",
        "output": "0",
        "index": 162783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ToCastCodecSpecificParams(const CodecSpecificParams& ext_params,\n                               CastCodecSpecificParams* cast_params) {\n  cast_params->key = ext_params.key;\n  cast_params->value = ext_params.value;\n}\n",
        "output": "0",
        "index": 169593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebMediaPlayerImpl::SetPipelineStatisticsForTest(\n    const PipelineStatistics& stats) {\n  pipeline_statistics_for_test_ = base::make_optional(stats);\n}\n",
        "output": "0",
        "index": 157323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::string16 GenerateKeywordFromNavigationEntry(\n    const NavigationEntry* entry,\n    const std::string& accept_languages) {\n  if (IsFormSubmit(entry))\n    return base::string16();\n\n  GURL url = entry->GetUserTypedURL();\n  if (!url.is_valid()) {\n    url = entry->GetURL();\n    if (!url.is_valid())\n       return base::string16();\n   }\n \n  if (!url.SchemeIs(url::kHttpScheme) || (url.path().length() > 1))\n     return base::string16();\n \n   return TemplateURL::GenerateKeyword(url, accept_languages);\n }\n",
        "output": "1",
        "index": 185451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VisibleSelection correctedVisibleSelection(\n    const VisibleSelection& passedSelection) {\n  if (!passedSelection.base().isConnected() ||\n      !passedSelection.extent().isConnected())\n    return VisibleSelection();\n  DCHECK(!passedSelection.base().document()->needsLayoutTreeUpdate());\n  return createVisibleSelection(passedSelection.asSelection());\n}\n",
        "output": "0",
        "index": 140314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SelectionEditor::UpdateCachedVisibleSelectionIfNeeded() const {\n  DCHECK_GE(GetDocument().Lifecycle().GetState(),\n            DocumentLifecycle::kAfterPerformLayout);\n  AssertSelectionValid();\n  if (!NeedsUpdateVisibleSelection())\n    return;\n  style_version_for_dom_tree_ = GetDocument().StyleVersion();\n  cached_visible_selection_in_dom_tree_is_dirty_ = false;\n  cached_visible_selection_in_dom_tree_ = CreateVisibleSelection(selection_);\n  if (!cached_visible_selection_in_dom_tree_.IsNone())\n    return;\n  style_version_for_flat_tree_ = GetDocument().StyleVersion();\n  cached_visible_selection_in_flat_tree_is_dirty_ = false;\n  cached_visible_selection_in_flat_tree_ = VisibleSelectionInFlatTree();\n}\n",
        "output": "0",
        "index": 135838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void Splash::drawSpan(SplashPipe *pipe, int x0, int x1, int y,\n\t\t\t     GBool noClip) {\n  int x;\n\n  pipeSetXY(pipe, x0, y);\n  if (noClip) {\n    for (x = x0; x <= x1; ++x) {\n      pipeRun(pipe);\n    }\n    updateModX(x0);\n    updateModX(x1);\n    updateModY(y);\n  } else {\n    for (x = x0; x <= x1; ++x) {\n      if (state->clip->test(x, y)) {\n\tpipeRun(pipe);\n\tupdateModX(x);\n\tupdateModY(y);\n      } else {\n\tpipeIncX(pipe);\n      }\n    }\n  }\n}\n",
        "output": "0",
        "index": 1241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MockDaemonProcess::SendToNetwork(IPC::Message* message) {\n  Sent(*message);\n  delete message;\n}\n",
        "output": "0",
        "index": 127195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fdctrl_handle_relative_seek_in(FDCtrl *fdctrl, int direction)\n{\n    FDrive *cur_drv;\n\n    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);\n    cur_drv = get_cur_drv(fdctrl);\n    if (fdctrl->fifo[2] + cur_drv->track >= cur_drv->max_track) {\n        fd_seek(cur_drv, cur_drv->head, cur_drv->max_track - 1,\n                cur_drv->sect, 1);\n    } else {\n        fd_seek(cur_drv, cur_drv->head,\n                cur_drv->track + fdctrl->fifo[2], cur_drv->sect, 1);\n    }\n    fdctrl_reset_fifo(fdctrl);\n    /* Raise Interrupt */\n    fdctrl->status0 |= FD_SR0_SEEK;\n    fdctrl_raise_irq(fdctrl);\n}\n",
        "output": "0",
        "index": 3317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock->sk, *other;\n\tunsigned int mask, writable;\n\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\n\t/* exceptional events? */\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR;\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\n\t/* readable? */\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\t/* Connection-based need to check for termination and startup */\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (sk->sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\t/* connection hasn't started yet? */\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\n\t/* No write status requested, avoid expensive OUT tests. */\n\tif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\n\twritable = unix_writable(sk);\n\tother = unix_peer_get(sk);\n\tif (other) {\n\t\tif (unix_peer(other) != sk) {\n\t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\n\t\t\tif (unix_recvq_full(other))\n\t\t\t\twritable = 0;\n\t\t}\n\t\tsock_put(other);\n\t}\n\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\n\treturn mask;\n}\n",
        "output": "0",
        "index": 19293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~VP9WorkerThreadTest() {}\n",
        "output": "0",
        "index": 177706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TreeView::Expand(TreeModelNode* node) {\n  DCHECK(model_ && node);\n  if (!root_shown_ && model_->GetRoot() == node) {\n    return;\n  }\n  TreeModelNode* parent = model_->GetParent(node);\n  if (parent) {\n    Expand(parent);\n  }\n  TreeView_Expand(tree_view_, GetNodeDetails(node)->tree_item, TVE_EXPAND);\n}\n",
        "output": "0",
        "index": 105646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void raw_unhash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\n\twrite_lock_bh(&h->lock);\n\tif (sk_del_node_init(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\twrite_unlock_bh(&h->lock);\n}\n",
        "output": "0",
        "index": 18976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "open_patch_file (char const *filename)\n{\n    file_offset file_pos = 0;\n    file_offset pos;\n    struct stat st;\n\n    if (!filename || !*filename || strEQ (filename, \"-\"))\n      pfp = stdin;\n    else\n      {\n\tpfp = fopen (filename, binary_transput ? \"rb\" : \"r\");\n\tif (!pfp)\n\t  pfatal (\"Can't open patch file %s\", quotearg (filename));\n      }\n#if HAVE_SETMODE_DOS\n    if (binary_transput)\n      {\n\tif (isatty (fileno (pfp)))\n\t  fatal (\"cannot read binary data from tty on this platform\");\n\tsetmode (fileno (pfp), O_BINARY);\n      }\n#endif\n    if (fstat (fileno (pfp), &st) != 0)\n      pfatal (\"fstat\");\n    if (S_ISREG (st.st_mode) && (pos = file_tell (pfp)) != -1)\n      file_pos = pos;\n    else\n      {\n\tsize_t charsread;\n\tint fd = make_tempfile (&TMPPATNAME, 'p', NULL, O_RDWR | O_BINARY, 0);\n\tFILE *read_pfp = pfp;\n\tTMPPATNAME_needs_removal = true;\n\tpfp = fdopen (fd, \"w+b\");\n\tif (! pfp)\n\t  pfatal (\"Can't open stream for file %s\", quotearg (TMPPATNAME));\n\tfor (st.st_size = 0;\n\t     (charsread = fread (buf, 1, bufsize, read_pfp)) != 0;\n\t     st.st_size += charsread)\n\t  if (fwrite (buf, 1, charsread, pfp) != charsread)\n\t    write_fatal ();\n\tif (ferror (read_pfp) || fclose (read_pfp) != 0)\n\t  read_fatal ();\n\tif (fflush (pfp) != 0\n\t    || file_seek (pfp, (file_offset) 0, SEEK_SET) != 0)\n\t  write_fatal ();\n      }\n    p_filesize = st.st_size;\n    if (p_filesize != (file_offset) p_filesize)\n      fatal (\"patch file is too long\");\n    next_intuit_at (file_pos, 1);\n}\n",
        "output": "0",
        "index": 16741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pick_next_task(struct rq *rq)\n{\n\tconst struct sched_class *class;\n\tstruct task_struct *p;\n\n\t/*\n\t * Optimization: we know that if all tasks are in\n\t * the fair class we can call that function directly:\n\t */\n\tif (likely(rq->nr_running == rq->cfs.nr_running)) {\n\t\tp = fair_sched_class.pick_next_task(rq);\n\t\tif (likely(p))\n\t\t\treturn p;\n\t}\n\n\tfor_each_class(class) {\n\t\tp = class->pick_next_task(rq);\n\t\tif (p)\n\t\t\treturn p;\n\t}\n\n\tBUG(); /* the idle class will always have a runnable task */\n}\n",
        "output": "0",
        "index": 22499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebKit::WebUserMediaClient* RenderViewImpl::userMediaClient() {\n  EnsureMediaStreamImpl();\n  return media_stream_impl_;\n}\n",
        "output": "0",
        "index": 109170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Vertical_Sweep_Step( RAS_ARG )\n  {\n    ras.traceOfs += ras.traceIncr;\n  }\n",
        "output": "0",
        "index": 7048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "store_storenew(png_store *ps)\n{\n   png_store_buffer *pb;\n\n if (ps->writepos != STORE_BUFFER_SIZE)\n      png_error(ps->pwrite, \"invalid store call\");\n\n   pb = voidcast(png_store_buffer*, malloc(sizeof *pb));\n\n if (pb == NULL)\n      png_error(ps->pwrite, \"store new: OOM\");\n\n *pb = ps->new;\n   ps->new.prev = pb;\n   ps->writepos = 0;\n}\n",
        "output": "0",
        "index": 173246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\n \tcase PT_ID:\n \t\tif (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_RREQ:\n \t\tif (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_RREP:\n \t\tif (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_DRAWOP:\n \t\tif (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_PREQ:\n \t\tif (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tcase PT_PREP:\n \t\tif (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)\n \t\t\treturn;\n \t\tbreak;\n \n \tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}\n",
        "output": "1",
        "index": 181051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const IndexPacket *GetVirtualIndexesFromCache(const Image *image)\n{\n  CacheInfo\n    *restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]));\n}\n",
        "output": "0",
        "index": 73634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_usage(int argc, char *argv[])\n{\n    char *name = NULL;\n    name = strrchr(argv[0], '/');\n    printf(\"Usage: %s -i|--infile FILE [-o|--outfile FILE] [-d|--debug]\\n\", (name ? name + 1: argv[0]));\n    printf(\"Convert a plist FILE from binary to XML format or vice-versa.\\n\\n\");\n    printf(\"  -i, --infile FILE\\tThe FILE to convert from\\n\");\n    printf(\"  -o, --outfile FILE\\tOptional FILE to convert to or stdout if not used\\n\");\n    printf(\"  -d, --debug\\t\\tEnable extended debug output\\n\");\n    printf(\"\\n\");\n}\n",
        "output": "0",
        "index": 68961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (!net->sctp.auth_enable)\n\t\treturn -EACCES;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, sizeof(struct sctp_authkeyid)))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tval.scact_keynumber = asoc->active_key_id;\n\telse\n\t\tval.scact_keynumber = sctp_sk(sk)->ep->active_key_id;\n\n\tlen = sizeof(struct sctp_authkeyid);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 32988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dissect_usb_vid_control_value(proto_tree *tree, tvbuff_t *tvb, int offset, guint8 request)\n{\n    gint        value_size;\n    const char *fallback_name;\n    int         hf;\n\n    switch (request)\n    {\n        case USB_SETUP_GET_DEF:\n            hf = hf_usb_vid_control_default;\n            fallback_name = \"Default Value\";\n            break;\n\n        case USB_SETUP_GET_MIN:\n        case CONTROL_CHANGE_MIN:\n            hf = hf_usb_vid_control_min;\n            fallback_name = \"Min Value\";\n            break;\n\n        case USB_SETUP_GET_MAX:\n        case CONTROL_CHANGE_MAX:\n            hf = hf_usb_vid_control_max;\n            fallback_name = \"Max Value\";\n            break;\n\n        case USB_SETUP_GET_RES:\n            hf = hf_usb_vid_control_res;\n            fallback_name = \"Resolution\";\n            break;\n\n        case USB_SETUP_GET_CUR:\n        case USB_SETUP_SET_CUR:\n        case CONTROL_CHANGE_VALUE:\n            hf = hf_usb_vid_control_cur;\n            fallback_name = \"Current Value\";\n            break;\n\n        /* @todo UVC 1.5 USB_SETUP_x_ALL?\n         *       They are poorly specified.\n         */\n\n        default:\n            hf = -1;\n            fallback_name = \"Value\";\n            break;\n    }\n\n    value_size = tvb_reported_length_remaining(tvb, offset);\n\n    if (hf != -1)\n    {\n        header_field_info *hfinfo;\n        hfinfo = proto_registrar_get_nth(hf);\n        DISSECTOR_ASSERT(IS_FT_INT(hfinfo->type) || IS_FT_UINT(hfinfo->type));\n    }\n\n    if ((hf != -1) && (value_size <= 4))\n    {\n        proto_tree_add_item(tree, hf, tvb, offset, value_size, ENC_LITTLE_ENDIAN);\n    }\n    else\n    {\n        /* @todo Display as FT_BYTES with a big-endian disclaimer?\n         * See https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=7933\n         */\n        proto_tree_add_bytes_format(tree, hf_usb_vid_control_value, tvb, offset, value_size, NULL, \"%s\", fallback_name);\n    }\n}\n",
        "output": "0",
        "index": 51822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  NodeIDWrapper(AutomationInternalCustomBindings* automation_bindings,\n                NodeIDFunction function)\n      : automation_bindings_(automation_bindings), function_(function) {}\n",
        "output": "0",
        "index": 169530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IOHandler::SetRenderer(RenderProcessHost* process_host,\n                             RenderFrameHostImpl* frame_host) {\n  process_host_ = process_host;\n }\n",
        "output": "1",
        "index": 186728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cred_init(FsCred *credp)\n{\n    credp->fc_uid = -1;\n    credp->fc_gid = -1;\n    credp->fc_mode = -1;\n    credp->fc_rdev = -1;\n}\n",
        "output": "0",
        "index": 1455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);\n\n\tif (dirty_bytes > PAGE_SIZE)\n\t\tmemslot->dirty_bitmap = vzalloc(dirty_bytes);\n\telse\n\t\tmemslot->dirty_bitmap = kzalloc(dirty_bytes, GFP_KERNEL);\n\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\n\tmemslot->dirty_bitmap_head = memslot->dirty_bitmap;\n\tmemslot->nr_dirty_pages = 0;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 20334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MPEG4Extractor::parseQTMetaVal(\n int32_t keyId, off64_t offset, size_t size) {\n ssize_t index = mMetaKeyMap.indexOfKey(keyId);\n if (index < 0) {\n return ERROR_MALFORMED;\n }\n\n if (size <= 16) {\n return ERROR_MALFORMED;\n }\n uint32_t dataSize;\n if (!mDataSource->getUInt32(offset, &dataSize)\n || dataSize > size || dataSize <= 16) {\n return ERROR_MALFORMED;\n }\n uint32_t atomFourCC;\n if (!mDataSource->getUInt32(offset + 4, &atomFourCC)\n || atomFourCC != FOURCC('d', 'a', 't', 'a')) {\n return ERROR_MALFORMED;\n }\n uint32_t dataType;\n if (!mDataSource->getUInt32(offset + 8, &dataType)\n || ((dataType & 0xff000000) != 0)) {\n return ERROR_MALFORMED;\n }\n\n    dataSize -= 16;\n    offset += 16;\n\n if (dataType == 23 && dataSize >= 4) {\n uint32_t val;\n if (!mDataSource->getUInt32(offset, &val)) {\n return ERROR_MALFORMED;\n }\n if (!strcasecmp(mMetaKeyMap[index].c_str(), \"com.android.capture.fps\")) {\n            mFileMetaData->setFloat(kKeyCaptureFramerate, *(float *)&val);\n }\n } else if (dataType == 67 && dataSize >= 4) {\n uint32_t val;\n if (!mDataSource->getUInt32(offset, &val)) {\n return ERROR_MALFORMED;\n }\n if (!strcasecmp(mMetaKeyMap[index].c_str(), \"com.android.video.temporal_layers_count\")) {\n            mFileMetaData->setInt32(kKeyTemporalLayerCount, val);\n }\n } else {\n        ALOGV(\"ignoring key: type %d, size %d\", dataType, dataSize);\n }\n\n return OK;\n}\n",
        "output": "0",
        "index": 175327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdt_init(void)\n{\n    bdt_log(\"INIT BT \");\n    status = sBtInterface->init(&bt_callbacks);\n\n if (status == BT_STATUS_SUCCESS) {\n        status = sBtInterface->set_os_callouts(&callouts);\n }\n\n    check_return_status(status);\n}\n",
        "output": "0",
        "index": 172884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnUnregisterProtocolHandler(RenderFrameHostImpl* source,\n                                                  const std::string& protocol,\n                                                  const GURL& url,\n                                                  bool user_gesture) {\n  if (!delegate_)\n    return;\n\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n  if (policy->IsPseudoScheme(protocol))\n    return;\n\n  delegate_->UnregisterProtocolHandler(this, protocol, url, user_gesture);\n}\n",
        "output": "0",
        "index": 148508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TabStrip::TabStrip(std::unique_ptr<TabStripController> controller)\n    : controller_(std::move(controller)),\n      layout_helper_(std::make_unique<TabStripLayoutHelper>()),\n      drag_context_(std::make_unique<TabDragContextImpl>(this)) {\n  Init();\n  SetEventTargeter(std::make_unique<views::ViewTargeter>(this));\n  md_observer_.Add(MD::GetInstance());\n}\n",
        "output": "0",
        "index": 153490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool BackendImpl::CreateBackingStore(disk_cache::File* file) {\n  AdjustMaxCacheSize(0);\n\n  IndexHeader header;\n  header.table_len = DesiredIndexTableLen(max_size_);\n\n  if (new_eviction_)\n    header.version = 0x20001;\n\n  header.create_time = Time::Now().ToInternalValue();\n\n  if (!file->Write(&header, sizeof(header), 0))\n    return false;\n\n  return file->SetLength(GetIndexSize(header.table_len));\n}\n",
        "output": "0",
        "index": 160012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EAS_I32 WT_UpdateGain (S_SYNTH_VOICE *pVoice, S_WT_VOICE *pWTVoice, const S_ARTICULATION *pArt, S_SYNTH_CHANNEL *pChannel, EAS_I32 gain)\n{\n    EAS_I32 lfoGain;\n    EAS_I32 temp;\n\n /*\n    If this voice was stolen, then the velocity is actually\n    for the new note, not the note that we are currently ramping down.\n    So we really shouldn't use this velocity. However, that would require\n    more memory to store the velocity value, and the improvement may\n    not be sufficient to warrant the added memory.\n    */\n /* velocity is fixed at note start for a given voice and must be squared */\n    temp = (pVoice->velocity) << (NUM_EG1_FRAC_BITS - 7);\n    temp = MULT_EG1_EG1(temp, temp);\n\n /* region gain is fixed as part of the articulation */\n    temp = MULT_EG1_EG1(temp, gain);\n\n /* include the channel gain */\n    temp = MULT_EG1_EG1(temp, pChannel->staticGain);\n\n /* calculate LFO gain using an approximation for 10^x */\n    lfoGain = MULT_EG1_EG1(pWTVoice->modLFO.lfoValue, pArt->lfoToGain);\n    lfoGain = MULT_EG1_EG1(lfoGain, LFO_GAIN_TO_CENTS);\n\n /* convert from a dB-like value to linear gain */\n    lfoGain = EAS_Calculate2toX(lfoGain);\n    temp = MULT_EG1_EG1(temp, lfoGain);\n\n /* calculate the voice's gain */\n    temp = (EAS_I16)MULT_EG1_EG1(temp, pWTVoice->eg1Value);\n\n return temp;\n}\n",
        "output": "0",
        "index": 174750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_log_lost_samples(struct perf_event *event, u64 lost)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\tlost;\n\t} lost_samples_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_LOST_SAMPLES,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(lost_samples_event),\n\t\t},\n\t\t.lost\t\t= lost,\n\t};\n\n\tperf_event_header__init_id(&lost_samples_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tlost_samples_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, lost_samples_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n",
        "output": "0",
        "index": 56116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GpuDataManager::UpdateGpuBlacklist(\n    GpuBlacklist* gpu_blacklist, bool preliminary) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(gpu_blacklist);\n\n  scoped_ptr<GpuBlacklist> updated_list(gpu_blacklist);\n\n  uint16 updated_version_major, updated_version_minor;\n  if (!updated_list->GetVersion(\n          &updated_version_major, &updated_version_minor))\n    return;\n\n  uint16 current_version_major, current_version_minor;\n  bool succeed = gpu_blacklist_->GetVersion(\n      &current_version_major, &current_version_minor);\n  DCHECK(succeed);\n  if (updated_version_major < current_version_major ||\n      (updated_version_major == current_version_major &&\n       updated_version_minor <= current_version_minor))\n    return;\n\n  gpu_blacklist_.reset(updated_list.release());\n  UpdateGpuFeatureFlags();\n  if (preliminary)\n    preliminary_gpu_feature_flags_ = gpu_feature_flags_;\n  VLOG(1) << \"Using software rendering list version \"\n          << updated_version_major << \".\" << updated_version_minor;\n}\n",
        "output": "0",
        "index": 103315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "force_luks_teardown_cleartext_done (Device *device,\n                                    gboolean success,\n                                    gpointer user_data)\n{\n  int n;\n  char *argv[16];\n  ForceLuksTeardownData *data = user_data;\n\n  if (!success)\n    {\n      if (data->fr_callback != NULL)\n        data->fr_callback (data->device, FALSE, data->fr_user_data);\n\n      force_luks_teardown_data_unref (data);\n      goto out;\n    }\n\n  /* ok, clear text device is out of the way; now tear it down */\n\n  n = 0;\n  argv[n++] = \"cryptsetup\";\n  argv[n++] = \"luksClose\";\n  argv[n++] = data->dm_name;\n  argv[n++] = NULL;\n\n\n  if (!job_new (NULL,\n                \"ForceLuksTeardown\",\n                FALSE,\n                data->device,\n                argv,\n                NULL,\n                force_luks_teardown_completed_cb,\n                FALSE,\n                data,\n                (GDestroyNotify) force_luks_teardown_data_unref))\n    {\n\n      g_warning (\"Couldn't spawn cryptsetup for force teardown for device %s\", data->dm_name);\n      if (data->fr_callback != NULL)\n        data->fr_callback (data->device, FALSE, data->fr_user_data);\n\n      force_luks_teardown_data_unref (data);\n    }\n out:\n  ;\n}\n",
        "output": "0",
        "index": 11709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n \trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n \tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n \tnl_table[NETLINK_USERSOCK].registered = 1;\n \n \tnetlink_table_ungrab();\n }\n",
        "output": "1",
        "index": 180786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtr<TouchList> Document::createTouchList(Vector<RefPtr<Touch> >& touches) const\n{\n    return TouchList::create(touches);\n}\n",
        "output": "0",
        "index": 109621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vrrp_track_srcip_handler(__attribute__((unused)) vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tvrrp->track_saddr = true;\n}\n",
        "output": "0",
        "index": 76046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 64857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::AddConsoleMessage(ConsoleMessage* console_message) {\n  if (!IsContextThread()) {\n    PostCrossThreadTask(\n        *GetTaskRunner(TaskType::kInternalInspector), FROM_HERE,\n        CrossThreadBind(&RunAddConsoleMessageTask, console_message->Source(),\n                        console_message->Level(), console_message->Message(),\n                        WrapCrossThreadPersistent(this)));\n    return;\n  }\n\n  if (!frame_)\n    return;\n\n  if (console_message->Location()->IsUnknown()) {\n    unsigned line_number = 0;\n    if (!IsInDocumentWrite() && GetScriptableDocumentParser()) {\n      ScriptableDocumentParser* parser = GetScriptableDocumentParser();\n      if (parser->IsParsingAtLineNumber())\n        line_number = parser->LineNumber().OneBasedInt();\n    }\n    Vector<DOMNodeId> nodes(console_message->Nodes());\n    console_message = ConsoleMessage::Create(\n        console_message->Source(), console_message->Level(),\n        console_message->Message(),\n        SourceLocation::Create(Url().GetString(), line_number, 0, nullptr));\n    console_message->SetNodes(frame_, std::move(nodes));\n  }\n\n  frame_->Console().AddMessage(console_message);\n}\n",
        "output": "0",
        "index": 156781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\n\tfor_each_set_bit(bit, (const unsigned long *) &mask,\n\t\t\t sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}\n",
        "output": "0",
        "index": 31968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n",
        "output": "1",
        "index": 179639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "got_filesystem_info (FilesystemInfoState *state,\n                     GFileInfo           *info)\n{\n    NautilusDirectory *directory;\n    NautilusFile *file;\n    const char *filesystem_type;\n\n    /* careful here, info may be NULL */\n\n    directory = nautilus_directory_ref (state->directory);\n\n    state->directory->details->filesystem_info_state = NULL;\n    async_job_end (state->directory, \"filesystem info\");\n\n    file = nautilus_file_ref (state->file);\n\n    file->details->filesystem_info_is_up_to_date = TRUE;\n    if (info != NULL)\n    {\n        file->details->filesystem_use_preview =\n            g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW);\n        file->details->filesystem_readonly =\n            g_file_info_get_attribute_boolean (info, G_FILE_ATTRIBUTE_FILESYSTEM_READONLY);\n        filesystem_type = g_file_info_get_attribute_string (info, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE);\n        if (g_strcmp0 (eel_ref_str_peek (file->details->filesystem_type), filesystem_type) != 0)\n        {\n            eel_ref_str_unref (file->details->filesystem_type);\n            file->details->filesystem_type = eel_ref_str_get_unique (filesystem_type);\n        }\n    }\n\n    nautilus_directory_async_state_changed (directory);\n    nautilus_file_changed (file);\n\n    nautilus_file_unref (file);\n\n    nautilus_directory_unref (directory);\n\n    filesystem_info_state_free (state);\n}\n",
        "output": "0",
        "index": 60910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int add_parents_only(struct rev_info *revs, const char *arg_, int flags)\n{\n\tunsigned char sha1[20];\n\tstruct object *it;\n\tstruct commit *commit;\n\tstruct commit_list *parents;\n\tconst char *arg = arg_;\n\n\tif (*arg == '^') {\n\t\tflags ^= UNINTERESTING | BOTTOM;\n\t\targ++;\n\t}\n\tif (get_sha1_committish(arg, sha1))\n\t\treturn 0;\n\twhile (1) {\n\t\tit = get_reference(revs, arg, sha1, 0);\n\t\tif (!it && revs->ignore_missing)\n\t\t\treturn 0;\n\t\tif (it->type != OBJ_TAG)\n\t\t\tbreak;\n\t\tif (!((struct tag*)it)->tagged)\n\t\t\treturn 0;\n\t\thashcpy(sha1, ((struct tag*)it)->tagged->sha1);\n\t}\n\tif (it->type != OBJ_COMMIT)\n\t\treturn 0;\n\tcommit = (struct commit *)it;\n\tfor (parents = commit->parents; parents; parents = parents->next) {\n\t\tit = &parents->item->object;\n\t\tit->flags |= flags;\n\t\tadd_rev_cmdline(revs, it, arg_, REV_CMD_PARENTS_ONLY, flags);\n\t\tadd_pending_object(revs, it, arg);\n\t}\n\treturn 1;\n}\n",
        "output": "0",
        "index": 55156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jpc_ppm_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tif (ppm->data) {\n\t\tjas_free(ppm->data);\n\t}\n}\n",
        "output": "0",
        "index": 72863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err trun_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_TrunEntry *ent;\n\tGF_TrackFragmentRunBox *p;\n\n\tp = (GF_TrackFragmentRunBox *)a;\n\tgf_isom_box_dump_start(a, \"TrackRunBox\", trace);\n\tfprintf(trace, \"SampleCount=\\\"%d\\\"\", p->sample_count);\n\n\tif (p->flags & GF_ISOM_TRUN_DATA_OFFSET)\n\t\tfprintf(trace, \" DataOffset=\\\"%d\\\"\", p->data_offset);\n\tfprintf(trace, \">\\n\");\n\n\tif (p->flags & GF_ISOM_TRUN_FIRST_FLAG) {\n\t\tsample_flags_dump(\"FirstSampleFlags\", p->first_sample_flags, trace);\n\t}\n\n\tif (p->flags & (GF_ISOM_TRUN_DURATION|GF_ISOM_TRUN_SIZE|GF_ISOM_TRUN_CTS_OFFSET|GF_ISOM_TRUN_FLAGS)) {\n\t\ti=0;\n\t\twhile ((ent = (GF_TrunEntry *)gf_list_enum(p->entries, &i))) {\n\n\t\t\tfprintf(trace, \"<TrackRunEntry\");\n\n\t\t\tif (p->flags & GF_ISOM_TRUN_DURATION)\n\t\t\t\tfprintf(trace, \" Duration=\\\"%u\\\"\", ent->Duration);\n\t\t\tif (p->flags & GF_ISOM_TRUN_SIZE)\n\t\t\t\tfprintf(trace, \" Size=\\\"%u\\\"\", ent->size);\n\t\t\tif (p->flags & GF_ISOM_TRUN_CTS_OFFSET)\n\t\t\t{\n\t\t\t\tif (p->version == 0)\n\t\t\t\t\tfprintf(trace, \" CTSOffset=\\\"%u\\\"\", (u32) ent->CTS_Offset);\n\t\t\t\telse\n\t\t\t\t\tfprintf(trace, \" CTSOffset=\\\"%d\\\"\", ent->CTS_Offset);\n\t\t\t}\n\n\t\t\tif (p->flags & GF_ISOM_TRUN_FLAGS) {\n\t\t\t\tfrag_dump_sample_flags(trace, ent->flags);\n\t\t\t}\n\t\t\tfprintf(trace, \"/>\\n\");\n\t\t}\n\t} else if (p->size) {\n\t\tfprintf(trace, \"<!-- all default values used -->\\n\");\n\t} else {\n\t\tfprintf(trace, \"<TrackRunEntry Duration=\\\"\\\" Size=\\\"\\\" CTSOffset=\\\"\\\"\");\n\t\tfrag_dump_sample_flags(trace, 0);\n\t\tfprintf(trace, \"/>\\n\");\n\t}\n\n\tgf_isom_box_dump_done(\"TrackRunBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sock *vsock_find_connected_socket(struct sockaddr_vm *src,\n\t\t\t\t\t struct sockaddr_vm *dst)\n{\n\tstruct sock *sk;\n\n\tspin_lock_bh(&vsock_table_lock);\n\tsk = __vsock_find_connected_socket(src, dst);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\tspin_unlock_bh(&vsock_table_lock);\n\n\treturn sk;\n}\n",
        "output": "0",
        "index": 30340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void DidFinish(File::Error error) {\n    error_ = error;\n    MessageLoop::current()->QuitWhenIdle();\n  }\n",
        "output": "0",
        "index": 119110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AfterTranslateInfoBar::Layout() {\n   TranslateInfoBarBase::Layout();\n \n  int available_width = InfoBar::GetAvailableWidth();\n   gfx::Size pref_size = options_menu_button_->GetPreferredSize();\n   options_menu_button_->SetBounds(available_width - pref_size.width(),\n       OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n\n  views::MenuButton* left_button = swapped_language_buttons_ ?\n      target_language_menu_button_ : original_language_menu_button_;\n  views::MenuButton* right_button = swapped_language_buttons_ ?\n       original_language_menu_button_ : target_language_menu_button_;\n \n   pref_size = label_1_->GetPreferredSize();\n  label_1_->SetBounds(icon_->bounds().right() + InfoBar::kIconLabelSpacing,\n      InfoBar::OffsetY(this, pref_size), pref_size.width(), pref_size.height());\n \n   pref_size = left_button->GetPreferredSize();\n   left_button->SetBounds(label_1_->bounds().right() +\n      InfoBar::kButtonInLabelSpacing, OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n \n   pref_size = label_2_->GetPreferredSize();\n   label_2_->SetBounds(left_button->bounds().right() +\n      InfoBar::kButtonInLabelSpacing, InfoBar::OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n \n   pref_size = right_button->GetPreferredSize();\n   right_button->SetBounds(label_2_->bounds().right() +\n      InfoBar::kButtonInLabelSpacing, OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n \n   pref_size = label_3_->GetPreferredSize();\n   label_3_->SetBounds(right_button->bounds().right() +\n      InfoBar::kButtonInLabelSpacing, InfoBar::OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n \n   pref_size = revert_button_->GetPreferredSize();\n   revert_button_->SetBounds(label_3_->bounds().right() +\n      InfoBar::kButtonInLabelSpacing, InfoBar::OffsetY(this, pref_size),\n       pref_size.width(), pref_size.height());\n }\n",
        "output": "1",
        "index": 184189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evdns_shutdown(int fail_requests)\n{\n\tif (current_base) {\n\t\tstruct evdns_base *b = current_base;\n\t\tcurrent_base = NULL;\n\t\tevdns_base_free(b, fail_requests);\n\t}\n\tevdns_log_fn = NULL;\n}\n",
        "output": "0",
        "index": 70655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmci_transport_release_pending(struct sock *pending)\n{\n\tsock_put(pending);\n}\n",
        "output": "0",
        "index": 30413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::cancelDeferredLoad() {\n  m_deferredLoadTimer.stop();\n  m_deferredLoadState = NotDeferred;\n}\n",
        "output": "0",
        "index": 139941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\n\t/* Turn off cputimer->running. This is done without locking. */\n\tWRITE_ONCE(cputimer->running, false);\n\ttick_dep_clear_signal(sig, TICK_DEP_BIT_POSIX_TIMER);\n}\n",
        "output": "0",
        "index": 81128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rt_cache_flush(struct net *net)\n{\n\trt_genid_bump_ipv4(net);\n}\n",
        "output": "0",
        "index": 44356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int packet_poll(struct file *file, struct socket *sock,\n\t\t\t\tpoll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tunsigned int mask = datagram_poll(file, sock, wait);\n\n\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\tif (po->rx_ring.pg_vec) {\n\t\tif (!packet_previous_frame(po, &po->rx_ring, TP_STATUS_KERNEL))\n\t\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\tspin_lock_bh(&sk->sk_write_queue.lock);\n\tif (po->tx_ring.pg_vec) {\n\t\tif (packet_current_frame(po, &po->tx_ring, TP_STATUS_AVAILABLE))\n\t\t\tmask |= POLLOUT | POLLWRNORM;\n\t}\n\tspin_unlock_bh(&sk->sk_write_queue.lock);\n\treturn mask;\n}\n",
        "output": "0",
        "index": 26564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  SiteInstance* parent_site_instance() const {\n    return parent_site_instance_.get();\n  }\n",
        "output": "1",
        "index": 187030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cdelete(JF, js_Ast *exp)\n{\n\tjs_Ast *arg = exp->a;\n\tswitch (arg->type) {\n\tcase EXP_IDENTIFIER:\n\t\tif (F->strict)\n\t\t\tjsC_error(J, exp, \"delete on an unqualified name is not allowed in strict mode\");\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_DELLOCAL, OP_DELVAR, arg);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, arg->a);\n\t\tcexp(J, F, arg->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DELPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, arg->a);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_DELPROP_S, arg->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, exp, \"invalid l-value in delete expression\");\n\t}\n}\n",
        "output": "0",
        "index": 90712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs41_proc_secinfo_no_name(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t   struct nfs_fsinfo *info, struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs41_proc_secinfo_no_name(server, fhandle, info, flavors);\n\t\tswitch (err) {\n\t\tcase 0:\n\t\tcase -NFS4ERR_WRONGSEC:\n\t\tcase -NFS4ERR_NOTSUPP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = nfs4_handle_exception(server, err, &exception);\n\t\t}\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "output": "0",
        "index": 19859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "clean_up(void) {\n    send_event(INSTANCE_EXIT, uzbl.info.pid_str, NULL);\n    g_free(uzbl.info.pid_str);\n\n    g_free(uzbl.state.executable_path);\n    g_hash_table_destroy(uzbl.behave.commands);\n\n    if(uzbl.state.event_buffer)\n        g_ptr_array_free(uzbl.state.event_buffer, TRUE);\n\n    if (uzbl.behave.fifo_dir)\n        unlink (uzbl.comm.fifo_path);\n    if (uzbl.behave.socket_dir)\n        unlink (uzbl.comm.socket_path);\n}\n",
        "output": "0",
        "index": 18328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::NavigateBackForwardSoon(int offset) {\n  history_navigation_virtual_time_pauser_ =\n      RenderThreadImpl::current()\n          ->GetRendererScheduler()\n          ->CreateWebScopedVirtualTimePauser();\n  history_navigation_virtual_time_pauser_.PauseVirtualTime(true);\n  Send(new ViewHostMsg_GoToEntryAtOffset(GetRoutingID(), offset));\n}\n",
        "output": "0",
        "index": 160795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "user_get_password_expiration_policy_authorized_cb (Daemon                *daemon,\n                                                   User                  *user,\n                                                   GDBusMethodInvocation *context,\n                                                   gpointer               data)\n\n{\n        if (!user->account_expiration_policy_known) {\n                throw_error (context, ERROR_NOT_SUPPORTED, \"account expiration policy unknown to accounts service\");\n                return;\n        }\n\n        accounts_user_complete_get_password_expiration_policy (ACCOUNTS_USER (user),\n                                                               context,\n                                                               user->expiration_time,\n                                                               user->last_change_time,\n                                                               user->min_days_between_changes,\n                                                               user->max_days_between_changes,\n                                                               user->days_to_warn,\n                                                               user->days_after_expiration_until_lock);\n}\n",
        "output": "0",
        "index": 4737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "format_SET_MPLS_TTL(const struct ofpact_mpls_ttl *a, struct ds *s)\n{\n    ds_put_format(s, \"%sset_mpls_ttl(%s%\"PRIu8\"%s)%s\",\n                  colors.paren, colors.end, a->ttl,\n                  colors.paren, colors.end);\n}\n",
        "output": "0",
        "index": 76955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~PowerPopupView() {\n  }\n",
        "output": "0",
        "index": 114097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct sock *get_cookie_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t   struct request_sock *req,\n\t\t\t\t\t   struct dst_entry *dst)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct sock *child;\n\n\tchild = icsk->icsk_af_ops->syn_recv_sock(sk, skb, req, dst);\n\tif (child)\n\t\tinet_csk_reqsk_queue_add(sk, req, child);\n\telse\n\t\treqsk_free(req);\n\n\treturn child;\n}\n",
        "output": "0",
        "index": 18985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ux500_hash_resume(struct device *dev)\n{\n\tint ret = 0;\n\tstruct hash_device_data *device_data;\n\tstruct hash_ctx *temp_ctx = NULL;\n\n\tdevice_data = dev_get_drvdata(dev);\n\tif (!device_data) {\n\t\tdev_err(dev, \"%s: platform_get_drvdata() failed!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&device_data->ctx_lock);\n\tif (device_data->current_ctx == ++temp_ctx)\n\t\tdevice_data->current_ctx = NULL;\n\tspin_unlock(&device_data->ctx_lock);\n\n\tif (!device_data->current_ctx)\n\t\tup(&driver_data.device_allocation);\n\telse\n\t\tret = hash_enable_power(device_data, true);\n\n\tif (ret)\n\t\tdev_err(dev, \"%s: hash_enable_power() failed!\\n\", __func__);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 47564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_MINIT_FUNCTION(spl_observer)\n{\n\tREGISTER_SPL_INTERFACE(SplObserver);\n\tREGISTER_SPL_INTERFACE(SplSubject);\n\n\tREGISTER_SPL_STD_CLASS_EX(SplObjectStorage, spl_SplObjectStorage_new, spl_funcs_SplObjectStorage);\n\tmemcpy(&spl_handler_SplObjectStorage, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_SplObjectStorage.get_debug_info  = spl_object_storage_debug_info;\n\tspl_handler_SplObjectStorage.compare_objects = spl_object_storage_compare_objects;\n\tspl_handler_SplObjectStorage.clone_obj       = spl_object_storage_clone;\n\tspl_handler_SplObjectStorage.get_gc          = spl_object_storage_get_gc;\n\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Countable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(SplObjectStorage, ArrayAccess);\n\n\tREGISTER_SPL_STD_CLASS_EX(MultipleIterator, spl_SplObjectStorage_new, spl_funcs_MultipleIterator);\n\tREGISTER_SPL_ITERATOR(MultipleIterator);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ANY\",     MIT_NEED_ANY);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_NEED_ALL\",     MIT_NEED_ALL);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_NUMERIC\", MIT_KEYS_NUMERIC);\n\tREGISTER_SPL_CLASS_CONST_LONG(MultipleIterator, \"MIT_KEYS_ASSOC\",   MIT_KEYS_ASSOC);\n\n\treturn SUCCESS;\n}\n",
        "output": "0",
        "index": 12397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LIBOPENMPT_MODPLUG_API void ModPlug_InitMixerCallback(ModPlugFile* file,ModPlugMixerProc proc)\n{\n\tif(!file) return;\n\tif(!file->mixerbuf){\n\t\tfile->mixerbuf = malloc(BUFFER_COUNT*sizeof(signed int)*4);\n\t}\n\tfile->mixerproc = proc;\n}\n",
        "output": "0",
        "index": 87640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderViewTest::ExecuteJavaScriptAndReturnIntValue(\n    const base::string16& script,\n    int* int_result) {\n  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());\n  v8::Local<v8::Value> result =\n      GetMainFrame()->executeScriptAndReturnValue(WebScriptSource(script));\n  if (result.IsEmpty() || !result->IsInt32())\n    return false;\n\n  if (int_result)\n    *int_result = result->Int32Value();\n\n  return true;\n}\n",
        "output": "0",
        "index": 132143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dwarf_elf_object_access_get_pointer_size(void* obj_in)\n{\n    dwarf_elf_object_access_internals_t*obj =\n        (dwarf_elf_object_access_internals_t*)obj_in;\n    return obj->pointer_size;\n}\n",
        "output": "0",
        "index": 74058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ContentSecurityPolicy::ReportInvalidPathCharacter(\n    const String& directive_name,\n    const String& value,\n    const char invalid_char) {\n  DCHECK(invalid_char == '#' || invalid_char == '?');\n\n  String ignoring =\n      \"The fragment identifier, including the '#', will be ignored.\";\n  if (invalid_char == '?')\n    ignoring = \"The query component, including the '?', will be ignored.\";\n  String message = \"The source list for Content Security Policy directive '\" +\n                   directive_name +\n                   \"' contains a source with an invalid path: '\" + value +\n                   \"'. \" + ignoring;\n  LogToConsole(message);\n}\n",
        "output": "0",
        "index": 165541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QQuickWebViewFlickablePrivate::didChangeContentsSize(const QSize& newSize)\n{\n    Q_Q(QQuickWebView);\n\n    pageView->setContentsSize(newSize); // emits contentsSizeChanged()\n    m_viewportHandler->pageContentsSizeChanged(newSize, q->boundingRect().size().toSize());\n}\n",
        "output": "0",
        "index": 116241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_attribute(struct tee_obj *o,\n\t\t\t  const struct tee_cryp_obj_type_props *props,\n\t\t\t  uint32_t attr)\n{\n\tint idx = tee_svc_cryp_obj_find_type_attr_idx(attr, props);\n\n\tif (idx < 0)\n\t\treturn;\n\to->have_attrs |= BIT(idx);\n}\n",
        "output": "0",
        "index": 86858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    FromMojom(media::mojom::ResolutionChangePolicy input,\n              media::ResolutionChangePolicy* output) {\n  switch (input) {\n    case media::mojom::ResolutionChangePolicy::FIXED_RESOLUTION:\n      *output = media::ResolutionChangePolicy::FIXED_RESOLUTION;\n      return true;\n    case media::mojom::ResolutionChangePolicy::FIXED_ASPECT_RATIO:\n      *output = media::ResolutionChangePolicy::FIXED_ASPECT_RATIO;\n      return true;\n    case media::mojom::ResolutionChangePolicy::ANY_WITHIN_LIMIT:\n      *output = media::ResolutionChangePolicy::ANY_WITHIN_LIMIT;\n      return true;\n  }\n  NOTREACHED();\n  return false;\n}\n",
        "output": "0",
        "index": 152928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GraphicsLayer* RenderLayerScrollableArea::layerForScrollCorner() const\n{\n    DisableCompositingQueryAsserts disabler;\n\n    return layer()->hasCompositedLayerMapping() ? layer()->compositedLayerMapping()->layerForScrollCorner() : 0;\n}\n",
        "output": "0",
        "index": 128414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HeadlessDevToolsManagerDelegate::HandleCommand(\n    content::DevToolsAgentHost* agent_host,\n    int session_id,\n    base::DictionaryValue* command) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (!browser_)\n    return false;\n\n  const base::Value* id_value = command->FindKey(\"id\");\n  const base::Value* method_value = command->FindKey(\"method\");\n  if (!id_value || !method_value)\n    return false;\n\n  const base::DictionaryValue* params = nullptr;\n  command->GetDictionary(\"params\", &params);\n\n  const std::string& method = method_value->GetString();\n  auto find_it = command_map_.find(method);\n  if (find_it == command_map_.end()) {\n    find_it = unhandled_command_map_.find(method);\n    if (find_it != unhandled_command_map_.end())\n      find_it->second.Run(agent_host, session_id, id_value->GetInt(), params);\n    return false;\n  }\n\n  if (method.find(\"Browser.\") == 0 &&\n      agent_host->GetType() != content::DevToolsAgentHost::kTypeBrowser)\n    return false;\n\n  auto cmd_result =\n      find_it->second.Run(agent_host, session_id, id_value->GetInt(), params);\n  if (!cmd_result)\n    return false;\n  agent_host->SendProtocolMessageToClient(session_id,\n                                          ToString(std::move(cmd_result)));\n  return true;\n}\n",
        "output": "0",
        "index": 162631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rds_send_reset(struct rds_connection *conn)\n{\n\tstruct rds_message *rm, *tmp;\n\tunsigned long flags;\n\n\tif (conn->c_xmit_rm) {\n\t\trm = conn->c_xmit_rm;\n\t\tconn->c_xmit_rm = NULL;\n\t\t/* Tell the user the RDMA op is no longer mapped by the\n\t\t * transport. This isn't entirely true (it's flushed out\n\t\t * independently) but as the connection is down, there's\n\t\t * no ongoing RDMA to/from that memory */\n\t\trds_message_unmapped(rm);\n\t\trds_message_put(rm);\n\t}\n\n\tconn->c_xmit_sg = 0;\n\tconn->c_xmit_hdr_off = 0;\n\tconn->c_xmit_data_off = 0;\n\tconn->c_xmit_atomic_sent = 0;\n\tconn->c_xmit_rdma_sent = 0;\n\tconn->c_xmit_data_sent = 0;\n\n\tconn->c_map_queued = 0;\n\n\tconn->c_unacked_packets = rds_sysctl_max_unacked_packets;\n\tconn->c_unacked_bytes = rds_sysctl_max_unacked_bytes;\n\n\t/* Mark messages as retransmissions, and move them to the send q */\n\tspin_lock_irqsave(&conn->c_lock, flags);\n\tlist_for_each_entry_safe(rm, tmp, &conn->c_retrans, m_conn_item) {\n\t\tset_bit(RDS_MSG_ACK_REQUIRED, &rm->m_flags);\n\t\tset_bit(RDS_MSG_RETRANSMITTED, &rm->m_flags);\n\t}\n\tlist_splice_init(&conn->c_retrans, &conn->c_send_queue);\n\tspin_unlock_irqrestore(&conn->c_lock, flags);\n}\n",
        "output": "0",
        "index": 41956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void AddSubPST(SplineChar *sc,struct lookup_subtable *sub,char *variant) {\n    PST *pst;\n\n    pst = chunkalloc(sizeof(PST));\n    pst->type = pst_substitution;\n    pst->subtable = sub;\n    pst->u.alt.components = copy(variant);\n    pst->next = sc->possub;\n    sc->possub = pst;\n}\n",
        "output": "0",
        "index": 88317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PassRefPtr<JSONObject> buildObjectForPoint(const FloatPoint& point)\n{\n    RefPtr<JSONObject> object = JSONObject::create();\n    object->setNumber(\"x\", point.x());\n    object->setNumber(\"y\", point.y());\n    return object.release();\n}\n",
        "output": "0",
        "index": 109221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dct264_sad8x8_c(/*MpegEncContext*/ void *c, uint8_t *src1, uint8_t *src2, int stride, int h){\n    MpegEncContext * const s= (MpegEncContext *)c;\n    int16_t dct[8][8];\n    int i;\n    int sum=0;\n\n    s->dsp.diff_pixels(dct[0], src1, src2, stride);\n\n#define SRC(x) dct[i][x]\n#define DST(x,v) dct[i][x]= v\n    for( i = 0; i < 8; i++ )\n        DCT8_1D\n#undef SRC\n#undef DST\n\n#define SRC(x) dct[x][i]\n#define DST(x,v) sum += FFABS(v)\n    for( i = 0; i < 8; i++ )\n        DCT8_1D\n#undef SRC\n#undef DST\n    return sum;\n}\n",
        "output": "0",
        "index": 28111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoUniformMatrix3fv(\n  GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {\n  GLenum type = 0;\n  if (!PrepForSetUniformByLocation(\n      location, \"glUniformMatrix3fv\", &type, &count)) {\n    return;\n  }\n  glUniformMatrix3fv (location, count, transpose, value);\n}\n",
        "output": "0",
        "index": 104061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hub_irq(struct urb *urb)\n{\n\tstruct usb_hub *hub = urb->context;\n\tint status = urb->status;\n\tunsigned i;\n\tunsigned long bits;\n\n\tswitch (status) {\n\tcase -ENOENT:\t\t/* synchronous unlink */\n\tcase -ECONNRESET:\t/* async unlink */\n\tcase -ESHUTDOWN:\t/* hardware going away */\n\t\treturn;\n\n\tdefault:\t\t/* presumably an error */\n\t\t/* Cause a hub reset after 10 consecutive errors */\n\t\tdev_dbg(hub->intfdev, \"transfer --> %d\\n\", status);\n\t\tif ((++hub->nerrors < 10) || hub->error)\n\t\t\tgoto resubmit;\n\t\thub->error = status;\n\t\t/* FALL THROUGH */\n\n\t/* let hub_wq handle things */\n\tcase 0:\t\t\t/* we got data:  port status changed */\n\t\tbits = 0;\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tbits |= ((unsigned long) ((*hub->buffer)[i]))\n\t\t\t\t\t<< (i*8);\n\t\thub->event_bits[0] = bits;\n\t\tbreak;\n\t}\n\n\thub->nerrors = 0;\n\n\t/* Something happened, let hub_wq figure it out */\n\tkick_hub_wq(hub);\n\nresubmit:\n\tif (hub->quiescing)\n\t\treturn;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_ATOMIC);\n\tif (status != 0 && status != -ENODEV && status != -EPERM)\n\t\tdev_err(hub->intfdev, \"resubmit --> %d\\n\", status);\n}\n",
        "output": "0",
        "index": 56751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsTestingID(const std::string& id) {\n  return id.size() < 16;\n}\n",
        "output": "0",
        "index": 141820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gsicc_get_default_type(cmm_profile_t *profile_data)\n{\n    switch (profile_data->default_match) {\n        case DEFAULT_GRAY:\n            return gs_color_space_index_DeviceGray;\n        case DEFAULT_RGB:\n            return gs_color_space_index_DeviceRGB;\n        case DEFAULT_CMYK:\n            return gs_color_space_index_DeviceCMYK;\n        case CIE_A:\n            return gs_color_space_index_CIEA;\n        case CIE_ABC:\n            return gs_color_space_index_CIEABC;\n        case CIE_DEF:\n            return gs_color_space_index_CIEDEF;\n        case CIE_DEFG:\n            return gs_color_space_index_CIEDEFG;\n        default:\n            return gs_color_space_index_ICC;\n    }\n}\n",
        "output": "0",
        "index": 13958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LocalFrame::DidChangeVisibilityState() {\n  if (GetDocument())\n    GetDocument()->DidChangeVisibilityState();\n\n  Frame::DidChangeVisibilityState();\n}\n",
        "output": "0",
        "index": 167918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AXARIAGridCell::AXARIAGridCell(LayoutObject* layoutObject,\n                               AXObjectCacheImpl& axObjectCache)\n    : AXTableCell(layoutObject, axObjectCache) {}\n",
        "output": "0",
        "index": 137896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int req_warn(lua_State *L)\n{\n    return req_log_at(L, APLOG_WARNING);\n}\n",
        "output": "0",
        "index": 45161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoLineWidth(GLfloat width) {\n  api()->glLineWidthFn(\n      std::min(std::max(width, line_width_range_[0]), line_width_range_[1]));\n}\n",
        "output": "0",
        "index": 154036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SiteInstanceImpl::IncrementActiveFrameCount() {\n  active_frame_count_++;\n}\n",
        "output": "0",
        "index": 167602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsTagTypeHandler* _cmsGetTagTypeHandler(cmsContext ContextID, cmsTagTypeSignature sig)\n{\n    _cmsTagTypePluginChunkType* ctx = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(ContextID, TagTypePlugin);\n\n    return GetHandler(sig, ctx->TagTypes, SupportedTagTypes);\n}\n",
        "output": "0",
        "index": 71101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sk_buff *validate_xmit_vlan(struct sk_buff *skb,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tif (skb_vlan_tag_present(skb) &&\n\t    !vlan_hw_offload_capable(features, skb->vlan_proto))\n\t\tskb = __vlan_hwaccel_push_inside(skb);\n\treturn skb;\n}\n",
        "output": "0",
        "index": 48958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ContentSecurityPolicy::shouldSendViolationReport(\n    const String& report) const {\n  return !m_violationReportsSent.contains(report.impl()->hash());\n}\n",
        "output": "0",
        "index": 149485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::WasShown() {\n  controller_.SetActive(true);\n  RenderWidgetHostViewPort* rwhv =\n      RenderWidgetHostViewPort::FromRWHV(GetRenderWidgetHostView());\n  if (rwhv) {\n    rwhv->WasShown();\n#if defined(OS_MACOSX)\n    rwhv->SetActive(true);\n#endif\n  }\n\n  last_selected_time_ = base::TimeTicks::Now();\n\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_, WasShown());\n\n  RenderViewHostImpl* rvh =\n      static_cast<RenderViewHostImpl*>(GetRenderViewHost());\n  if (rvh) {\n    rvh->ResizeRectChanged(GetRootWindowResizerRect());\n  }\n\n  should_normally_be_visible_ = true;\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_VISIBILITY_CHANGED,\n      Source<WebContents>(this),\n      Details<const bool>(&should_normally_be_visible_));\n}\n",
        "output": "0",
        "index": 119069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int f2fs_submit_page_mbio(struct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io;\n\tbool is_read = is_read_io(fio->op);\n\tstruct page *bio_page;\n\tint err = 0;\n\n\tio = is_read ? &sbi->read_io : &sbi->write_io[btype];\n\n\tif (fio->old_blkaddr != NEW_ADDR)\n\t\tverify_block_addr(sbi, fio->old_blkaddr);\n\tverify_block_addr(sbi, fio->new_blkaddr);\n\n\tbio_page = fio->encrypted_page ? fio->encrypted_page : fio->page;\n\n\tif (!is_read)\n\t\tinc_page_count(sbi, WB_DATA_TYPE(bio_page));\n\n\tdown_write(&io->io_rwsem);\n\n\tif (io->bio && (io->last_block_in_bio != fio->new_blkaddr - 1 ||\n\t    (io->fio.op != fio->op || io->fio.op_flags != fio->op_flags) ||\n\t\t\t!__same_bdev(sbi, fio->new_blkaddr, io->bio)))\n\t\t__submit_merged_bio(io);\nalloc_new:\n\tif (io->bio == NULL) {\n\t\tif ((fio->type == DATA || fio->type == NODE) &&\n\t\t\t\tfio->new_blkaddr & F2FS_IO_SIZE_MASK(sbi)) {\n\t\t\terr = -EAGAIN;\n\t\t\tdec_page_count(sbi, WB_DATA_TYPE(bio_page));\n\t\t\tgoto out_fail;\n\t\t}\n\t\tio->bio = __bio_alloc(sbi, fio->new_blkaddr,\n\t\t\t\t\t\tBIO_MAX_PAGES, is_read);\n\t\tio->fio = *fio;\n\t}\n\n\tif (bio_add_page(io->bio, bio_page, PAGE_SIZE, 0) <\n\t\t\t\t\t\t\tPAGE_SIZE) {\n\t\t__submit_merged_bio(io);\n\t\tgoto alloc_new;\n\t}\n\n\tio->last_block_in_bio = fio->new_blkaddr;\n\tf2fs_trace_ios(fio, 0);\nout_fail:\n\tup_write(&io->io_rwsem);\n\ttrace_f2fs_submit_page_mbio(fio->page, fio);\n\treturn err;\n}\n",
        "output": "0",
        "index": 85181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  int number_of_callbacks() const { return number_of_callbacks_; }\n",
        "output": "0",
        "index": 159946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void overloadedMethodG2Method(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"overloadedMethodG\", \"TestObjectPython\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, strictTypeCheckingStringArg, info[0]);\n    imp->overloadedMethodG(strictTypeCheckingStringArg);\n}\n",
        "output": "0",
        "index": 131548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlCtxtReadMemory(xmlParserCtxtPtr ctxt, const char *buffer, int size,\n const char *URL, const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n\n if (ctxt == NULL)\n return (NULL);\n if (buffer == NULL)\n return (NULL);\n    xmlInitParser();\n\n    xmlCtxtReset(ctxt);\n\n    input = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);\n if (input == NULL) {\n return(NULL);\n }\n\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n if (stream == NULL) {\n\txmlFreeParserInputBuffer(input);\n return(NULL);\n }\n\n    inputPush(ctxt, stream);\n return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}\n",
        "output": "0",
        "index": 176574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned CSSComputedStyleDeclaration::length() const\n{\n    Node* node = m_node.get();\n    if (!node)\n        return 0;\n\n    RenderStyle* style = node->computedStyle(m_pseudoElementSpecifier);\n    if (!style)\n        return 0;\n\n    return numComputedProperties;\n}\n",
        "output": "0",
        "index": 104367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_req *req;\n\tsize_t num_read;\n\tloff_t pos = page_offset(page);\n\tsize_t count = PAGE_CACHE_SIZE;\n\tu64 attr_ver;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\t/*\n\t * Page writeback can extend beyond the liftime of the\n\t * page-cache page, so make sure we read a properly synced\n\t * page.\n\t */\n\tfuse_wait_on_page_writeback(inode, page->index);\n\n\treq = fuse_get_req(fc);\n\terr = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tattr_ver = fuse_get_attr_version(fc);\n\n\treq->out.page_zeroing = 1;\n\treq->out.argpages = 1;\n\treq->num_pages = 1;\n\treq->pages[0] = page;\n\tnum_read = fuse_send_read(req, file, pos, count, NULL);\n\terr = req->out.h.error;\n\tfuse_put_request(fc, req);\n\n\tif (!err) {\n\t\t/*\n\t\t * Short read means EOF.  If file size is larger, truncate it\n\t\t */\n\t\tif (num_read < count)\n\t\t\tfuse_read_update_size(inode, pos + num_read, attr_ver);\n\n\t\tSetPageUptodate(page);\n\t}\n\n\tfuse_invalidate_attr(inode); /* atime changed */\n out:\n\tunlock_page(page);\n\treturn err;\n}\n",
        "output": "0",
        "index": 27891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void JingleSessionManager::Close() {\n   DCHECK(CalledOnValidThread());\n \n  DCHECK(sessions_.empty());\n   if (!closed_) {\n     cricket_session_manager_->RemoveClient(kChromotingXmlNamespace);\n     jingle_signaling_connector_.reset();\n    cricket_session_manager_.reset();\n     closed_ = true;\n   }\n }\n",
        "output": "1",
        "index": 184656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  int64_t buffer_size() {\n    return loader()->current_buffer_size_ * 32768 /* block size */;\n  }\n",
        "output": "0",
        "index": 157087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t NuPlayer::GenericSource::setDataSource(\n const sp<IMediaHTTPService> &httpService,\n const char *url,\n const KeyedVector<String8, String8> *headers) {\n    resetDataSource();\n\n    mHTTPService = httpService;\n    mUri = url;\n\n if (headers) {\n        mUriHeaders = *headers;\n }\n\n return OK;\n}\n",
        "output": "0",
        "index": 173610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NetworkChangeNotifier::NotifyObserversOfDNSChange() {\n  if (g_network_change_notifier) {\n    g_network_change_notifier->resolver_state_observer_list_->Notify(\n        &DNSObserver::OnDNSChanged);\n  }\n}\n",
        "output": "0",
        "index": 115559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MediaControlsProgressView::SetDuration(const base::string16& duration) {\n   duration_->SetText(duration);\n }\n",
        "output": "0",
        "index": 149211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sort_dir_list(struct fixup_entry *p)\n{\n\tstruct fixup_entry *a, *b, *t;\n\n\tif (p == NULL)\n\t\treturn (NULL);\n\t/* A one-item list is already sorted. */\n\tif (p->next == NULL)\n\t\treturn (p);\n\n\t/* Step 1: split the list. */\n\tt = p;\n\ta = p->next->next;\n\twhile (a != NULL) {\n\t\t/* Step a twice, t once. */\n\t\ta = a->next;\n\t\tif (a != NULL)\n\t\t\ta = a->next;\n\t\tt = t->next;\n\t}\n\t/* Now, t is at the mid-point, so break the list here. */\n\tb = t->next;\n\tt->next = NULL;\n\ta = p;\n\n\t/* Step 2: Recursively sort the two sub-lists. */\n\ta = sort_dir_list(a);\n\tb = sort_dir_list(b);\n\n\t/* Step 3: Merge the returned lists. */\n\t/* Pick the first element for the merged list. */\n\tif (strcmp(a->name, b->name) > 0) {\n\t\tt = p = a;\n\t\ta = a->next;\n\t} else {\n\t\tt = p = b;\n\t\tb = b->next;\n\t}\n\n\t/* Always put the later element on the list first. */\n\twhile (a != NULL && b != NULL) {\n\t\tif (strcmp(a->name, b->name) > 0) {\n\t\t\tt->next = a;\n\t\t\ta = a->next;\n\t\t} else {\n\t\t\tt->next = b;\n\t\t\tb = b->next;\n\t\t}\n\t\tt = t->next;\n\t}\n\n\t/* Only one list is non-empty, so just splice it on. */\n\tif (a != NULL)\n\t\tt->next = a;\n\tif (b != NULL)\n\t\tt->next = b;\n\n\treturn (p);\n}\n",
        "output": "0",
        "index": 43942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *get_template_name(mychan_t *mc, unsigned int level)\n{\n\tmetadata_t *md;\n\tconst char *p, *q, *r;\n\tchar *s;\n\tchar ss[40];\n\tstatic char flagname[400];\n\ttemplate_iter_t iter;\n\n\tmd = metadata_find(mc, \"private:templates\");\n\tif (md != NULL)\n\t{\n\t\tp = md->value;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;\n\t\t\tq = strchr(p, '=');\n\t\t\tif (q == NULL)\n\t\t\t\tbreak;\n\t\t\tr = strchr(q, ' ');\n\t\t\tif (r != NULL && r < q)\n\t\t\t\tbreak;\n\t\t\tmowgli_strlcpy(ss, q, sizeof ss);\n\t\t\tif (r != NULL && r - q < (int)(sizeof ss - 1))\n\t\t\t{\n\t\t\t\tss[r - q] = '\\0';\n\t\t\t}\n\t\t\tif (level == flags_to_bitmask(ss, 0))\n\t\t\t{\n\t\t\t\tmowgli_strlcpy(flagname, p, sizeof flagname);\n\t\t\t\ts = strchr(flagname, '=');\n\t\t\t\tif (s != NULL)\n\t\t\t\t\t*s = '\\0';\n\t\t\t\treturn flagname;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\n\titer.res = NULL;\n\titer.level = level;\n\tmowgli_patricia_foreach(global_template_dict, global_template_search, &iter);\n\n\treturn iter.res;\n}\n",
        "output": "0",
        "index": 58399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit SelectionAdapter(Plugin* plugin)\n    : pp::Selection_Dev(plugin),\n      plugin_(plugin) {\n    BrowserPpp* proxy = plugin_->ppapi_proxy();\n    CHECK(proxy != NULL);\n    ppp_selection_ = static_cast<const PPP_Selection_Dev*>(\n        proxy->GetPluginInterface(PPP_SELECTION_DEV_INTERFACE));\n  }\n",
        "output": "0",
        "index": 110343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void writeDate(double numberValue)\n    {\n        append(DateTag);\n        doWriteNumber(numberValue);\n    }\n",
        "output": "0",
        "index": 129019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enqueue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_rq_clock(rq);\n\tsched_info_queued(p);\n\tp->sched_class->enqueue_task(rq, p, flags);\n}\n",
        "output": "0",
        "index": 26280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_attach_cgroups_work(struct vhost_work *work)\n{\n\tstruct vhost_attach_cgroups_struct *s;\n\n\ts = container_of(work, struct vhost_attach_cgroups_struct, work);\n\ts->ret = cgroup_attach_task_all(s->owner, current);\n}\n",
        "output": "0",
        "index": 33779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::MaybeRestoreContext(TimerBase*) {\n  DCHECK(isContextLost());\n\n  if (!restore_allowed_)\n    return;\n\n  if (canvas()) {\n    LocalFrame* frame = canvas()->GetDocument().GetFrame();\n    if (!frame)\n      return;\n\n    Settings* settings = frame->GetSettings();\n\n    if (!frame->Client()->AllowWebGL(settings && settings->GetWebGLEnabled()))\n      return;\n  }\n\n  if (GetDrawingBuffer()) {\n    drawing_buffer_->BeginDestruction();\n    drawing_buffer_.Clear();\n  }\n\n  auto execution_context = host()->GetTopExecutionContext();\n  Platform::ContextAttributes attributes = ToPlatformContextAttributes(\n      CreationAttributes(), Version(),\n      SupportOwnOffscreenSurface(execution_context));\n  Platform::GraphicsInfo gl_info;\n  std::unique_ptr<WebGraphicsContext3DProvider> context_provider;\n  const auto& url = host()->GetExecutionContextUrl();\n\n  if (IsMainThread()) {\n    context_provider =\n        Platform::Current()->CreateOffscreenGraphicsContext3DProvider(\n            attributes, url, 0, &gl_info);\n  } else {\n    context_provider =\n        CreateContextProviderOnWorkerThread(attributes, &gl_info, url);\n  }\n  RefPtr<DrawingBuffer> buffer;\n  if (context_provider && context_provider->BindToCurrentThread()) {\n    buffer = CreateDrawingBuffer(std::move(context_provider));\n  }\n  if (!buffer) {\n    if (context_lost_mode_ == kRealLostContext) {\n      restore_timer_.StartOneShot(kSecondsBetweenRestoreAttempts,\n                                  BLINK_FROM_HERE);\n    } else {\n      SynthesizeGLError(GL_INVALID_OPERATION, \"\", \"error restoring context\");\n    }\n    return;\n  }\n\n  drawing_buffer_ = std::move(buffer);\n  GetDrawingBuffer()->Bind(GL_FRAMEBUFFER);\n  lost_context_errors_.clear();\n  context_lost_mode_ = kNotLostContext;\n  auto_recovery_method_ = kManual;\n  restore_allowed_ = false;\n  RemoveFromEvictedList(this);\n\n  SetupFlags();\n  InitializeNewContext();\n  MarkContextChanged(kCanvasContextChanged);\n  WebGLContextEvent* event = WebGLContextEvent::Create(\n      EventTypeNames::webglcontextrestored, false, true, \"\");\n  host()->HostDispatchEvent(event);\n}\n",
        "output": "0",
        "index": 146335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ARIAWidgetSet* createARIARoleWidgetSet() {\n  ARIAWidgetSet* widgetSet = new HashSet<String, CaseFoldingHash>();\n  for (size_t i = 0; i < WTF_ARRAY_LENGTH(ariaWidgets); ++i)\n    widgetSet->insert(String(ariaWidgets[i]));\n  return widgetSet;\n}\n",
        "output": "0",
        "index": 138145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *stbl_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleTableBox, GF_ISOM_BOX_TYPE_STBL);\n\ttmp->MaxSamplePerChunk = 10;\n\ttmp->groupID = 1;\n\treturn (GF_Box *)tmp;\n}\n",
        "output": "0",
        "index": 80435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)\n {\n     if (origin && BlobURL::getOrigin(url) == \"null\")\n         originMap()->add(url.string(), origin);\n \n    if (isMainThread())\n        blobRegistry().registerBlobURL(url, srcURL);\n    else {\n         OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));\n         callOnMainThread(&registerBlobURLFromTask, context.leakPtr());\n     }\n}\n",
        "output": "1",
        "index": 184259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long php_curl_ssl_id(void)\n{\n\treturn (unsigned long) tsrm_thread_id();\n}\n",
        "output": "0",
        "index": 5109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xc2028_get_frequency(struct dvb_frontend *fe, u32 *frequency)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\n\ttuner_dbg(\"%s called\\n\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t*frequency = priv->frequency;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 49550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t ZSTD_crossEntropyCost(short const* norm, unsigned accuracyLog,\n                                    unsigned const* count, unsigned const max)\n{\n    unsigned const shift = 8 - accuracyLog;\n    size_t cost = 0;\n    unsigned s;\n    assert(accuracyLog <= 8);\n    for (s = 0; s <= max; ++s) {\n        unsigned const normAcc = norm[s] != -1 ? norm[s] : 1;\n        unsigned const norm256 = normAcc << shift;\n        assert(norm256 > 0);\n        assert(norm256 < 256);\n        cost += count[s] * kInverseProbabiltyLog256[norm256];\n    }\n    return cost >> 8;\n}\n",
        "output": "0",
        "index": 90048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bond_setup_by_slave(struct net_device *bond_dev,\n\t\t\t\tstruct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tbond_dev->header_ops\t    = slave_dev->header_ops;\n\n\tbond_dev->type\t\t    = slave_dev->type;\n\tbond_dev->hard_header_len   = slave_dev->hard_header_len;\n\tbond_dev->addr_len\t    = slave_dev->addr_len;\n\n\tmemcpy(bond_dev->broadcast, slave_dev->broadcast,\n\t\tslave_dev->addr_len);\n\tbond->setup_by_slave = 1;\n}\n",
        "output": "0",
        "index": 23756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "connection_ap_process_transparent(entry_connection_t *conn)\n{\n  socks_request_t *socks;\n\n  tor_assert(conn);\n  tor_assert(conn->socks_request);\n  socks = conn->socks_request;\n\n  /* pretend that a socks handshake completed so we don't try to\n   * send a socks reply down a transparent conn */\n  socks->command = SOCKS_COMMAND_CONNECT;\n  socks->has_finished = 1;\n\n  log_debug(LD_APP,\"entered.\");\n\n  if (connection_ap_get_original_destination(conn, socks) < 0) {\n    log_warn(LD_APP,\"Fetching original destination failed. Closing.\");\n    connection_mark_unattached_ap(conn,\n                               END_STREAM_REASON_CANT_FETCH_ORIG_DEST);\n    return -1;\n  }\n  /* we have the original destination */\n\n  control_event_stream_status(conn, STREAM_EVENT_NEW, 0);\n\n  return connection_ap_rewrite_and_attach_if_allowed(conn, NULL, NULL);\n}\n",
        "output": "0",
        "index": 69903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dns_packet_set_flags(DnsPacket *p, bool dnssec_checking_disabled, bool truncated) {\n\n        DnsPacketHeader *h;\n\n        assert(p);\n\n        h = DNS_PACKET_HEADER(p);\n\n        switch(p->protocol) {\n        case DNS_PROTOCOL_LLMNR:\n                assert(!truncated);\n\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0 /* qr */,\n                                                         0 /* opcode */,\n                                                         0 /* c */,\n                                                         0 /* tc */,\n                                                         0 /* t */,\n                                                         0 /* ra */,\n                                                         0 /* ad */,\n                                                         0 /* cd */,\n                                                         0 /* rcode */));\n                break;\n\n        case DNS_PROTOCOL_MDNS:\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0         /* qr */,\n                                                         0         /* opcode */,\n                                                         0         /* aa */,\n                                                         truncated /* tc */,\n                                                         0         /* rd (ask for recursion) */,\n                                                         0         /* ra */,\n                                                         0         /* ad */,\n                                                         0         /* cd */,\n                                                         0         /* rcode */));\n                break;\n\n        default:\n                assert(!truncated);\n\n                h->flags = htobe16(DNS_PACKET_MAKE_FLAGS(0 /* qr */,\n                                                         0 /* opcode */,\n                                                         0 /* aa */,\n                                                         0 /* tc */,\n                                                         1 /* rd (ask for recursion) */,\n                                                         0 /* ra */,\n                                                         0 /* ad */,\n                                                         dnssec_checking_disabled /* cd */,\n                                                         0 /* rcode */));\n        }\n}\n",
        "output": "0",
        "index": 64757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  AnimationForTesting() {\n    compositor_animation_ = CompositorAnimation::Create();\n  }\n",
        "output": "0",
        "index": 136483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebMediaPlayerImpl::SetDeviceScaleFactor(float scale_factor) {\n  cast_impl_.SetDeviceScaleFactor(scale_factor);\n}\n",
        "output": "0",
        "index": 157316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AccessibilityUIElement::showMenu()\n{\n}\n",
        "output": "0",
        "index": 113627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int apply_policy_zone(struct mempolicy *policy, enum zone_type zone)\n{\n\tenum zone_type dynamic_policy_zone = policy_zone;\n\n\tBUG_ON(dynamic_policy_zone == ZONE_MOVABLE);\n\n\t/*\n\t * if policy->v.nodes has movable memory only,\n\t * we apply policy when gfp_zone(gfp) = ZONE_MOVABLE only.\n\t *\n\t * policy->v.nodes is intersect with node_states[N_MEMORY].\n\t * so if the following test faile, it implies\n\t * policy->v.nodes has movable memory only.\n\t */\n\tif (!nodes_intersects(policy->v.nodes, node_states[N_HIGH_MEMORY]))\n\t\tdynamic_policy_zone = ZONE_MOVABLE;\n\n\treturn zone >= dynamic_policy_zone;\n}\n",
        "output": "0",
        "index": 67162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool CheckSrt(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 20);\n\n  int offset = StartsWith(buffer, buffer_size, UTF8_BYTE_ORDER_MARK) ? 3 : 0;\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '\\n', '\\r'));\n\n  while (VerifyCharacters(buffer, buffer_size, &offset, '\\n', '\\r')) {}\n  --offset;  // Since VerifyCharacters() gobbled up the next non-CR/LF.\n\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ',', '.'));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 3));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ' ', 0));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '-', 0));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '-', 0));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, '>', 0));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ' ', 0));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 100));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ':', 0));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 2));\n  RCHECK(VerifyCharacters(buffer, buffer_size, &offset, ',', '.'));\n  RCHECK(VerifyNumber(buffer, buffer_size, &offset, 3));\n  return true;\n}\n",
        "output": "0",
        "index": 127869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kwsfree (kwset_t kwset)\n{\n  obstack_free (&kwset->obstack, NULL);\n  free (kwset);\n}\n",
        "output": "0",
        "index": 5272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void deprecatedLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    UseCounter::countDeprecation(callingExecutionContext(info.GetIsolate()), UseCounter::LongAttribute);\n    TestObjectPythonV8Internal::deprecatedLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 131340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::HandleNigoriConfigurationCompletedOnFrontendLoop(\n    const WeakHandle<JsBackend>& js_backend,\n    const syncable::ModelTypeSet failed_configuration_types) {\n  HandleInitializationCompletedOnFrontendLoop(\n      js_backend, failed_configuration_types.Empty());\n}\n",
        "output": "0",
        "index": 111803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void unix_set_secdata(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tscm->secid = UNIXCB(skb).secid;\n}\n",
        "output": "0",
        "index": 46542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JSTestObjPrototype::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    JSTestObjPrototype* thisObject = jsCast<JSTestObjPrototype*>(cell);\n    return getStaticPropertySlot<JSTestObjPrototype, JSObject>(exec, &JSTestObjPrototypeTable, thisObject, propertyName, slot);\n}\n",
        "output": "0",
        "index": 106082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainListGetStats(virDomainPtr *doms,\n                      unsigned int stats,\n                      virDomainStatsRecordPtr **retStats,\n                      unsigned int flags)\n{\n    virConnectPtr conn = NULL;\n    virDomainPtr *nextdom = doms;\n    unsigned int ndoms = 0;\n    int ret = -1;\n\n    VIR_DEBUG(\"doms=%p, stats=0x%x, retStats=%p, flags=0x%x\",\n              doms, stats, retStats, flags);\n\n    virResetLastError();\n\n    virCheckNonNullArgGoto(doms, cleanup);\n    virCheckNonNullArgGoto(retStats, cleanup);\n\n    if (!*doms) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"doms array in %s must contain at least one domain\"),\n                       __FUNCTION__);\n        goto cleanup;\n    }\n\n    conn = doms[0]->conn;\n    virCheckConnectReturn(conn, -1);\n\n    if (!conn->driver->connectGetAllDomainStats) {\n        virReportUnsupportedError();\n        goto cleanup;\n    }\n\n    while (*nextdom) {\n        virDomainPtr dom = *nextdom;\n\n        virCheckDomainGoto(dom, cleanup);\n\n        if (dom->conn != conn) {\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                           _(\"domains in 'doms' array must belong to a \"\n                             \"single connection\"));\n            goto cleanup;\n        }\n\n        ndoms++;\n        nextdom++;\n    }\n\n    ret = conn->driver->connectGetAllDomainStats(conn, doms, ndoms,\n                                                 stats, retStats, flags);\n\n cleanup:\n    if (ret < 0)\n        virDispatchError(conn);\n    return ret;\n}\n",
        "output": "0",
        "index": 93839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BasePage::BasePage(PageMemory* storage, BaseArena* arena)\n    : magic_(GetMagic()),\n      storage_(storage),\n      arena_(arena),\n      next_(nullptr),\n      swept_(true) {\n#if DCHECK_IS_ON()\n  DCHECK(IsPageHeaderAddress(reinterpret_cast<Address>(this)));\n#endif\n}\n",
        "output": "0",
        "index": 166724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoaderClient::setCopiesOnScroll()\n{\n    notImplemented();\n}\n",
        "output": "0",
        "index": 98356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_update_iter_read_stamp(struct ring_buffer_iter *iter,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tu64 delta;\n\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\treturn;\n\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\tdelta = event->array[0];\n\t\tdelta <<= TS_SHIFT;\n\t\tdelta += event->time_delta;\n\t\titer->read_stamp += delta;\n\t\treturn;\n\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\t/* FIXME: not implemented */\n\t\treturn;\n\n\tcase RINGBUF_TYPE_DATA:\n\t\titer->read_stamp += event->time_delta;\n\t\treturn;\n\n\tdefault:\n\t\tBUG();\n\t}\n\treturn;\n}\n",
        "output": "0",
        "index": 72583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WT_ProcessVoice (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n\n /* use noise generator */\n if (pWTVoice->loopStart == WT_NOISE_GENERATOR)\n        WT_NoiseGenerator(pWTVoice, pWTIntFrame);\n\n /* generate interpolated samples for looped waves */\n else if (pWTVoice->loopStart != pWTVoice->loopEnd)\n        WT_Interpolate(pWTVoice, pWTIntFrame);\n\n /* generate interpolated samples for unlooped waves */\n else\n {\n        WT_InterpolateNoLoop(pWTVoice, pWTIntFrame);\n }\n\n#ifdef _FILTER_ENABLED\n if (pWTIntFrame->frame.k != 0)\n        WT_VoiceFilter(&pWTVoice->filter, pWTIntFrame);\n#endif\n\n#ifdef UNIFIED_MIXER\n {\n        EAS_I32 gainLeft, gainIncLeft;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n        EAS_I32 gainRight, gainIncRight;\n#endif\n\n        gainLeft = (pWTIntFrame->prevGain * pWTVoice->gainLeft) << 1;\n        gainIncLeft = (((pWTIntFrame->frame.gainTarget * pWTVoice->gainLeft) << 1) - gainLeft) >> SYNTH_UPDATE_PERIOD_IN_BITS;\n\n#if (NUM_OUTPUT_CHANNELS == 2)\n        gainRight = (pWTIntFrame->prevGain * pWTVoice->gainRight) << 1;\n        gainIncRight = (((pWTIntFrame->frame.gainTarget * pWTVoice->gainRight) << 1) - gainRight) >> SYNTH_UPDATE_PERIOD_IN_BITS;\n        EAS_MixStream(\n            pWTIntFrame->pAudioBuffer,\n            pWTIntFrame->pMixBuffer,\n            pWTIntFrame->numSamples,\n            gainLeft,\n            gainRight,\n            gainIncLeft,\n            gainIncRight,\n            MIX_FLAGS_STEREO_OUTPUT);\n\n#else\n        EAS_MixStream(\n            pWTIntFrame->pAudioBuffer,\n            pWTIntFrame->pMixBuffer,\n            pWTIntFrame->numSamples,\n            gainLeft,\n 0,\n            gainIncLeft,\n 0,\n 0);\n#endif\n }\n\n#else\n /* apply gain, and left and right gain */\n    WT_VoiceGain(pWTVoice, pWTIntFrame);\n#endif\n}\n",
        "output": "0",
        "index": 174738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int major_to_index(unsigned major)\n{\n\treturn major % BLKDEV_MAJOR_HASH_SIZE;\n}\n",
        "output": "0",
        "index": 49709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IOThread::Globals::~Globals() {}\n",
        "output": "0",
        "index": 121880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "views::NativeWidget* BrowserFrameGtk::AsNativeWidget() {\n  return this;\n}\n",
        "output": "0",
        "index": 103364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TabStripGtk::GetAvailableWidthForTabs(TabGtk* last_tab) const {\n  if (!base::i18n::IsRTL())\n    return last_tab->x() - bounds_.x() + last_tab->width();\n  else\n    return bounds_.width() - last_tab->x();\n}\n",
        "output": "0",
        "index": 126499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DomDistillerViewerSource::RequestViewerHandle::DidFinishLoad(\n    content::RenderFrameHost* render_frame_host,\n    const GURL& validated_url) {\n  if (render_frame_host->GetParent()) {\n    return;\n  }\n\n  waiting_for_page_ready_ = false;\n  if (!buffer_.empty()) {\n    RunIsolatedJavaScript(web_contents()->GetMainFrame(), buffer_);\n    buffer_.clear();\n  }\n}\n",
        "output": "0",
        "index": 129913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool DesktopWindowTreeHostX11::ShouldWindowContentsBeTransparent() const {\n  return use_argb_visual_;\n}\n",
        "output": "0",
        "index": 153297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_bin_object_delete(RBin *bin, ut32 binfile_id, ut32 binobj_id) {\n\tRBinFile *binfile = NULL; //, *cbinfile = r_bin_cur (bin);\n\tRBinObject *obj = NULL;\n\tint res = false;\n\n#if 0\n\tif (binfile_id == UT32_MAX && binobj_id == UT32_MAX) {\n\t\treturn false;\n\t}\n#endif\n\tif (binfile_id == -1) {\n\t\tbinfile = r_bin_file_find_by_object_id (bin, binobj_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t} else if (binobj_id == -1) {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? binfile->o: NULL;\n\t} else {\n\t\tbinfile = r_bin_file_find_by_id (bin, binfile_id);\n\t\tobj = binfile? r_bin_file_object_find_by_id (binfile, binobj_id): NULL;\n\t}\n\n\tif (binfile && (r_list_length (binfile->objs) > 1)) {\n\t\tbinfile->o = NULL;\n\t\tr_list_delete_data (binfile->objs, obj);\n\t\tobj = (RBinObject *)r_list_get_n (binfile->objs, 0);\n\t\tres = obj && binfile &&\n\t\t      r_bin_file_set_cur_binfile_obj (bin, binfile, obj);\n\t}\n\treturn res;\n}\n",
        "output": "0",
        "index": 60188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<service_manager::Service> CreateMediaService() {\n   return std::unique_ptr<service_manager::Service>(\n       new ::media::MediaService(base::MakeUnique<CdmMojoMediaClient>()));\n }\n",
        "output": "1",
        "index": 185819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeExtensionWebContentsObserver::InitializeRenderFrame(\n    content::RenderFrameHost* render_frame_host) {\n  ExtensionWebContentsObserver::InitializeRenderFrame(render_frame_host);\n  WindowController* controller = dispatcher()->GetExtensionWindowController();\n  if (controller) {\n    render_frame_host->Send(new ExtensionMsg_UpdateBrowserWindowId(\n        render_frame_host->GetRoutingID(), controller->GetWindowId()));\n  }\n}\n",
        "output": "0",
        "index": 135979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool NavigationControllerImpl::IsRedirect(\n  const ViewHostMsg_FrameNavigate_Params& params) {\n  if (PageTransitionIsMainFrame(params.transition)) {\n    return PageTransitionIsRedirect(params.transition);\n  }\n  return params.redirects.size() > 1;\n}\n",
        "output": "0",
        "index": 119791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::AttachInterstitialPage(\n    InterstitialPageImpl* interstitial_page) {\n  DCHECK(interstitial_page);\n  GetRenderManager()->set_interstitial_page(interstitial_page);\n\n  CancelActiveAndPendingDialogs();\n\n  for (auto& observer : observers_)\n    observer.DidAttachInterstitialPage();\n\n  if (frame_tree_.IsLoading())\n    LoadingStateChanged(true, true, nullptr);\n\n  if (node_.OuterContentsFrameTreeNode()) {\n    if (GetRenderManager()->GetProxyToOuterDelegate()) {\n      DCHECK(\n          static_cast<RenderWidgetHostViewBase*>(interstitial_page->GetView())\n              ->IsRenderWidgetHostViewChildFrame());\n      RenderWidgetHostViewChildFrame* view =\n          static_cast<RenderWidgetHostViewChildFrame*>(\n              interstitial_page->GetView());\n      GetRenderManager()->SetRWHViewForInnerContents(view);\n    }\n  }\n}\n",
        "output": "0",
        "index": 148311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Parcel::readBool() const\n{\n return readInt32() != 0;\n}\n",
        "output": "0",
        "index": 176732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_ABS( INS_ARG )\n  {\n    DO_ABS\n  }\n",
        "output": "0",
        "index": 10083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RecordAppContainerStatus(int error_code, bool crashed_before) {\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n  if (!crashed_before &&\n      service_manager::SandboxWin::IsAppContainerEnabledForSandbox(\n          *command_line, service_manager::SANDBOX_TYPE_GPU)) {\n    base::UmaHistogramSparse(\"GPU.AppContainer.Status\", error_code);\n  }\n}\n",
        "output": "0",
        "index": 145176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _hid_get_device_descriptor(struct hid_device_priv* dev, void *data, size_t *size)\n{\n\tstruct libusb_device_descriptor d;\n\td.bLength = LIBUSB_DT_DEVICE_SIZE;\n\td.bDescriptorType = LIBUSB_DT_DEVICE;\n\td.bcdUSB = 0x0200; /* 2.00 */\n\td.bDeviceClass = 0;\n\td.bDeviceSubClass = 0;\n\td.bDeviceProtocol = 0;\n\td.bMaxPacketSize0 = 64; /* fix this! */\n\td.idVendor = (uint16_t)dev->vid;\n\td.idProduct = (uint16_t)dev->pid;\n\td.bcdDevice = 0x0100;\n\td.iManufacturer = dev->string_index[0];\n\td.iProduct = dev->string_index[1];\n\td.iSerialNumber = dev->string_index[2];\n\td.bNumConfigurations = 1;\n\tif (*size > LIBUSB_DT_DEVICE_SIZE)\n\t\t*size = LIBUSB_DT_DEVICE_SIZE;\n\tmemcpy(data, &d, *size);\n\treturn LIBUSB_COMPLETED;\n}\n",
        "output": "1",
        "index": 187213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::OnDidStopLoading() {\n  TRACE_EVENT1(\"navigation\", \"RenderFrameHostImpl::OnDidStopLoading\",\n               \"frame_tree_node\", frame_tree_node_->frame_tree_node_id());\n\n  if (!is_loading_)\n    return;\n\n  was_discarded_ = false;\n  is_loading_ = false;\n  navigation_request_.reset();\n\n  if (is_active())\n    frame_tree_node_->DidStopLoading();\n}\n",
        "output": "0",
        "index": 169160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Splash::vertFlipImage(SplashBitmap *img, int width, int height,\n\t\t\t   int nComps) {\n  Guchar *lineBuf;\n  Guchar *p0, *p1;\n  int w;\n\n  w = width * nComps;\n   Guchar *lineBuf;\n   Guchar *p0, *p1;\n   int w;\n \n   w = width * nComps;\n   lineBuf = (Guchar *)gmalloc(w);\n\t p0 += width, p1 -= width) {\n      memcpy(lineBuf, p0, width);\n      memcpy(p0, p1, width);\n      memcpy(p1, lineBuf, width);\n    }\n  }\n",
        "output": "1",
        "index": 177908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "htmlAttrAllowed(const htmlElemDesc* elt, const xmlChar* attr, int legacy) {\n  const char** p ;\n\n  if ( !elt || ! attr )\n\treturn HTML_INVALID ;\n\n  if ( elt->attrs_req )\n    for ( p = elt->attrs_req; *p; ++p)\n      if ( !xmlStrcmp((const xmlChar*)*p, attr) )\n        return HTML_REQUIRED ;\n\n  if ( elt->attrs_opt )\n    for ( p = elt->attrs_opt; *p; ++p)\n      if ( !xmlStrcmp((const xmlChar*)*p, attr) )\n        return HTML_VALID ;\n\n  if ( legacy && elt->attrs_depr )\n    for ( p = elt->attrs_depr; *p; ++p)\n      if ( !xmlStrcmp((const xmlChar*)*p, attr) )\n        return HTML_DEPRECATED ;\n\n  return HTML_INVALID ;\n}\n",
        "output": "0",
        "index": 163568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ConvertRequestLEScanOptions(\n    const BluetoothLEScanOptions* options,\n    mojom::blink::WebBluetoothRequestLEScanOptionsPtr& result,\n    ExceptionState& exception_state) {\n  if (!(options->hasFilters() ^ options->acceptAllAdvertisements())) {\n    exception_state.ThrowTypeError(\n        \"Either 'filters' should be present or 'acceptAllAdvertisements' \"\n        \"should be true, but not both.\");\n    return;\n  }\n\n  result->accept_all_advertisements = options->acceptAllAdvertisements();\n  result->keep_repeated_devices = options->keepRepeatedDevices();\n\n  if (options->hasFilters()) {\n    if (options->filters().IsEmpty()) {\n      exception_state.ThrowTypeError(\n          \"'filters' member must be non-empty to find any devices.\");\n      return;\n    }\n\n    result->filters.emplace();\n\n    for (const BluetoothLEScanFilterInit* filter : options->filters()) {\n      auto canonicalized_filter = mojom::blink::WebBluetoothLeScanFilter::New();\n\n      CanonicalizeFilter(filter, canonicalized_filter, exception_state);\n\n      if (exception_state.HadException())\n        return;\n\n      result->filters->push_back(std::move(canonicalized_filter));\n    }\n  }\n}\n",
        "output": "0",
        "index": 150941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int may_umount_tree(struct vfsmount *m)\n{\n\tstruct mount *mnt = real_mount(m);\n\tint actual_refs = 0;\n\tint minimum_refs = 0;\n\tstruct mount *p;\n\tBUG_ON(!m);\n\n\t/* write lock needed for mnt_get_count */\n\tbr_write_lock(&vfsmount_lock);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tactual_refs += mnt_get_count(p);\n\t\tminimum_refs += 2;\n\t}\n\tbr_write_unlock(&vfsmount_lock);\n\n\tif (actual_refs > minimum_refs)\n\t\treturn 0;\n\n\treturn 1;\n}\n",
        "output": "0",
        "index": 32376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_timeout_skbs(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb;\n\n\tif (!tcp_is_fack(tp) || !tcp_head_timedout(sk))\n\t\treturn;\n\n\tskb = tp->scoreboard_skb_hint;\n\tif (tp->scoreboard_skb_hint == NULL)\n\t\tskb = tcp_write_queue_head(sk);\n\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\tif (!tcp_skb_timedout(sk, skb))\n\t\t\tbreak;\n\n\t\ttcp_skb_mark_lost(tp, skb);\n\t}\n\n\ttp->scoreboard_skb_hint = skb;\n\n\ttcp_verify_left_out(tp);\n}\n",
        "output": "0",
        "index": 41219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnDidLoadResourceFromMemoryCache(\n    const GURL& url,\n    const std::string& security_info,\n    const std::string& http_method,\n    const std::string& mime_type,\n    ResourceType resource_type) {\n  SSLStatus status;\n  if (!DeserializeSecurityInfo(security_info, &status)) {\n    bad_message::ReceivedBadMessage(\n        GetRenderProcessHost(),\n        bad_message::WC_MEMORY_CACHE_RESOURCE_BAD_SECURITY_INFO);\n    return;\n  }\n\n  LoadFromMemoryCacheDetails details(\n      url, status.cert_id, status.cert_status, http_method, mime_type,\n      resource_type);\n\n  controller_.ssl_manager()->DidLoadFromMemoryCache(details);\n\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidLoadResourceFromMemoryCache(details));\n\n  if (url.is_valid() && url.SchemeIsHTTPOrHTTPS()) {\n    scoped_refptr<net::URLRequestContextGetter> request_context(\n        resource_type == RESOURCE_TYPE_MEDIA ?\n            GetBrowserContext()->GetMediaRequestContextForRenderProcess(\n                GetRenderProcessHost()->GetID()) :\n            GetBrowserContext()->GetRequestContextForRenderProcess(\n                GetRenderProcessHost()->GetID()));\n    BrowserThread::PostTask(\n        BrowserThread::IO,\n        FROM_HERE,\n        base::Bind(&NotifyCacheOnIO, request_context, url, http_method));\n  }\n}\n",
        "output": "0",
        "index": 144597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "raptor_libxml_update_document_locator(raptor_sax2* sax2,\n                                      raptor_locator* locator)\n{\n  /* for storing error info */\n  xmlSAXLocatorPtr loc = sax2 ? sax2->loc : NULL;\n  xmlParserCtxtPtr xc= sax2 ? sax2->xc : NULL;\n\n  if(xc && xc->inSubset)\n    return;\n\n  if(!locator) \n    return;\n  \n  locator->line= -1;\n  locator->column= -1;\n\n  if(!xc)\n    return;\n\n  if(loc) {\n    locator->line = loc->getLineNumber(xc);\n    /* Seems to be broken */\n    /* locator->column = loc->getColumnNumber(xc); */\n  }\n\n}\n",
        "output": "0",
        "index": 21978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int peer_recv_tpkt_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags;\n\n\trdp = client->context->rdp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tfprintf(stderr, \"Incorrect RDP header.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rdp->settings->DisableEncryption)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length - 4, securityFlags))\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"rdp_decrypt failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tif(!freerdp_channel_peer_process(client, s, channelId))\n\t\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\treturn -1;\n\n\t\tclient->settings->PduSource = pduSource;\n\n\t\tswitch (pduType)\n\t\t{\n\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\tif (!peer_recv_data_pdu(client, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Client sent pduType %d\\n\", pduType);\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::clearStencil(GLint s) {\n  if (isContextLost())\n    return;\n  clear_stencil_ = s;\n  ContextGL()->ClearStencil(s);\n}\n",
        "output": "0",
        "index": 146461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void addReplyBulk(client *c, robj *obj) {\n    addReplyBulkLen(c,obj);\n    addReply(c,obj);\n    addReply(c,shared.crlf);\n}\n",
        "output": "0",
        "index": 69931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,\n                                     long long size) {\n  assert(pReader);\n  assert(pos >= 0);\n  if ((size <= 0) || (size > 8))\n     return E_FILE_FORMAT_INVALID;\n \n   long long result = 0;\n\n for (long long i = 0; i < size; ++i) {\n unsigned char b;\n\n const long status = pReader->Read(pos, 1, &b);\n\n if (status < 0)\n return status;\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n",
        "output": "1",
        "index": 187890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InterstitialPageImpl::Hide() {\n  if (!render_view_host_)\n    return;\n\n  Disable();\n\n  RenderWidgetHostView* old_view =\n      controller_->delegate()->GetRenderViewHost()->GetWidget()->GetView();\n  if (controller_->delegate()->GetInterstitialPage() == this &&\n      old_view &&\n      !old_view->IsShowing() &&\n      !controller_->delegate()->IsHidden()) {\n    old_view->Show();\n  }\n\n  if (render_view_host_->GetWidget()->GetView() &&\n      render_view_host_->GetWidget()->GetView()->HasFocus() &&\n      controller_->delegate()->GetRenderViewHost()->GetWidget()->GetView()) {\n    controller_->delegate()\n        ->GetRenderViewHost()\n        ->GetWidget()\n        ->GetView()\n        ->Focus();\n  }\n\n  base::ThreadTaskRunnerHandle::Get()->PostNonNestableTask(\n      FROM_HERE, base::Bind(&InterstitialPageImpl::Shutdown,\n                            weak_ptr_factory_.GetWeakPtr()));\n  render_view_host_ = NULL;\n  frame_tree_->root()->ResetForNewProcess();\n  controller_->delegate()->DetachInterstitialPage();\n  NavigationEntry* entry = controller_->GetVisibleEntry();\n  if (entry && !new_navigation_ && should_revert_web_contents_title_)\n    web_contents_->UpdateTitleForEntry(entry, original_web_contents_title_);\n\n  static_cast<WebContentsImpl*>(web_contents_)->DidChangeVisibleSecurityState();\n\n  InterstitialPageMap::iterator iter =\n      g_web_contents_to_interstitial_page->find(web_contents_);\n  DCHECK(iter != g_web_contents_to_interstitial_page->end());\n  if (iter != g_web_contents_to_interstitial_page->end())\n    g_web_contents_to_interstitial_page->erase(iter);\n\n  web_contents_ = NULL;\n}\n",
        "output": "0",
        "index": 148788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   MockProcessLauncherDelegate() {}\n",
        "output": "0",
        "index": 127238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ShelfLayoutManager::OnWallpaperBlurChanged() {\n  MaybeUpdateShelfBackground(AnimationChangeType::ANIMATE);\n}\n",
        "output": "0",
        "index": 142472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *parse_value(void)\n{\n\tstatic char value[1024];\n\tint quote = 0, comment = 0, space = 0;\n\tsize_t len = 0;\n\n\tfor (;;) {\n\t\tint c = get_next_char();\n\n\t\tif (len >= sizeof(value) - 1)\n\t\t\treturn NULL;\n\t\tif (c == '\\n') {\n\t\t\tif (quote)\n\t\t\t\treturn NULL;\n\t\t\tvalue[len] = 0;\n\t\t\treturn value;\n\t\t}\n\t\tif (comment)\n\t\t\tcontinue;\n\t\tif (isspace(c) && !quote) {\n\t\t\tspace = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!quote) {\n\t\t\tif (c == ';' || c == '#') {\n\t\t\t\tcomment = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (space) {\n\t\t\tif (len)\n\t\t\t\tvalue[len++] = ' ';\n\t\t\tspace = 0;\n\t\t}\n\t\tif (c == '\\\\') {\n\t\t\tc = get_next_char();\n\t\t\tswitch (c) {\n\t\t\tcase '\\n':\n\t\t\t\tcontinue;\n\t\t\tcase 't':\n\t\t\t\tc = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tc = '\\b';\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tc = '\\n';\n\t\t\t\tbreak;\n\t\t\t/* Some characters escape as themselves */\n\t\t\tcase '\\\\': case '\"':\n\t\t\t\tbreak;\n\t\t\t/* Reject unknown escape sequences */\n\t\t\tdefault:\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tvalue[len++] = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c == '\"') {\n\t\t\tquote = 1-quote;\n\t\t\tcontinue;\n\t\t}\n\t\tvalue[len++] = c;\n\t}\n}\n",
        "output": "0",
        "index": 34834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebElement RenderFrameImpl::GetFocusedElement() {\n  WebDocument doc = frame_->document();\n  if (!doc.isNull())\n    return doc.focusedElement();\n\n  return WebElement();\n}\n",
        "output": "0",
        "index": 118410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_shortform_lookup(xfs_da_args_t *args)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i;\n\txfs_ifork_t *ifp;\n\n\ttrace_xfs_attr_sf_lookup(args);\n\n\tifp = args->dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count;\n\t\t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\treturn(XFS_ERROR(EEXIST));\n\t}\n\treturn(XFS_ERROR(ENOATTR));\n}\n",
        "output": "0",
        "index": 44956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static handle_t *ocfs2_zero_start_ordered_transaction(struct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *di_bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\n\tif (!ocfs2_should_order_data(inode))\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_jbd2_file_inode(handle, inode);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\nout:\n\tif (ret) {\n\t\tif (!IS_ERR(handle))\n\t\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = ERR_PTR(ret);\n\t}\n\treturn handle;\n}\n",
        "output": "0",
        "index": 85829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __iommu_free_buffer(struct device *dev, struct page **pages,\n\t\t\t       size_t size, struct dma_attrs *attrs)\n{\n\tint count = size >> PAGE_SHIFT;\n\tint array_size = count * sizeof(struct page *);\n\tint i;\n\n\tif (dma_get_attr(DMA_ATTR_FORCE_CONTIGUOUS, attrs)) {\n\t\tdma_release_from_contiguous(dev, pages[0], count);\n\t} else {\n\t\tfor (i = 0; i < count; i++)\n\t\t\tif (pages[i])\n\t\t\t\t__free_pages(pages[i], 0);\n\t}\n\n\tif (array_size <= PAGE_SIZE)\n\t\tkfree(pages);\n\telse\n\t\tvfree(pages);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct net_device *dev_get_by_name_rcu(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\tstruct hlist_head *head = dev_name_hash(net, name);\n\n\thlist_for_each_entry_rcu(dev, head, name_hlist)\n\t\tif (!strncmp(dev->name, name, IFNAMSIZ))\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 48789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ClearFileReferenceOnIOThread(\n    scoped_refptr<storage::ShareableFileReference>) {}\n",
        "output": "0",
        "index": 164291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vmxnet3_io_bar0_read(void *opaque, hwaddr addr, unsigned size)\n{\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        g_assert_not_reached();\n    }\n\n    VMW_CBPRN(\"BAR0 unknown read [%\" PRIx64 \"], size %d\", addr, size);\n    return 0;\n}\n",
        "output": "0",
        "index": 15590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void timer_free_values(Timer *t) {\n        TimerValue *v;\n\n        assert(t);\n\n        while ((v = t->values)) {\n                LIST_REMOVE(value, t->values, v);\n                calendar_spec_free(v->calendar_spec);\n                free(v);\n        }\n}\n",
        "output": "0",
        "index": 96127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoGetFramebufferAttachmentParameteriv(\n    GLenum target,\n    GLenum attachment,\n    GLenum pname,\n    GLsizei bufsize,\n    GLsizei* length,\n    GLint* params) {\n  GLenum updated_attachment = attachment;\n  if (IsEmulatedFramebufferBound(target)) {\n    if (!ModifyAttachmentForEmulatedFramebuffer(&updated_attachment)) {\n      InsertError(GL_INVALID_OPERATION, \"Invalid attachment.\");\n      *length = 0;\n      return error::kNoError;\n    }\n\n    switch (pname) {\n      case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:\n      case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:\n      case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:\n      case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:\n        InsertError(GL_INVALID_ENUM, \"Invalid parameter name.\");\n        *length = 0;\n        return error::kNoError;\n    }\n  }\n\n  CheckErrorCallbackState();\n\n  GLint* scratch_params = GetTypedScratchMemory<GLint>(bufsize);\n  api()->glGetFramebufferAttachmentParameterivRobustANGLEFn(\n      target, updated_attachment, pname, bufsize, length, scratch_params);\n\n  if (CheckErrorCallbackState()) {\n    DCHECK(*length == 0);\n    return error::kNoError;\n  }\n\n  error::Error error = PatchGetFramebufferAttachmentParameter(\n      target, updated_attachment, pname, *length, scratch_params);\n  if (error != error::kNoError) {\n    *length = 0;\n    return error;\n  }\n\n  DCHECK(*length < bufsize);\n  std::copy(scratch_params, scratch_params + *length, params);\n\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 154686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rad_put_vendor_attr(struct rad_handle *h, int vendor, int type,\n    const void *value, size_t len)\n{\n\tstruct vendor_attribute *attr;\n\tint res;\n    \n    if (!h->request_created) {\n        generr(h, \"Please call rad_create_request()\");\n        return -1;\n    }    \n\n\tif ((attr = malloc(len + 6)) == NULL) {\n\t\tgenerr(h, \"malloc failure (%d bytes)\", len + 6);\n\t\treturn -1;\n\t}\n\n\tattr->vendor_value = htonl(vendor);\n\tattr->attrib_type = type;\n\tattr->attrib_len = len + 2;\n\tmemcpy(attr->attrib_data, value, len);\n\n\tres = put_raw_attr(h, RAD_VENDOR_SPECIFIC, attr, len + 6);\n\tfree(attr);\n\tif (res == 0 && vendor == RAD_VENDOR_MICROSOFT\n\t    && (type == RAD_MICROSOFT_MS_CHAP_RESPONSE\n\t    || type == RAD_MICROSOFT_MS_CHAP2_RESPONSE)) {\n\t\th->chap_pass = 1;\n\t}\n\treturn (res);\n}\n",
        "output": "0",
        "index": 31546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool FakeCentral::IsPresent() const {\n  switch (state_) {\n    case mojom::CentralState::ABSENT:\n      return false;\n    case mojom::CentralState::POWERED_OFF:\n    case mojom::CentralState::POWERED_ON:\n      return true;\n  }\n  NOTREACHED();\n  return false;\n}\n",
        "output": "0",
        "index": 150910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AccessibilityUIElement::lineForIndex(int index)\n{\n    return 0;\n}\n",
        "output": "0",
        "index": 113601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool TryAddNextUnusedAxesButton() {\n     for (const auto& axes_data_pair : axes_data_) {\n       vr::EVRButtonId button_id = axes_data_pair.first;\n       if (IsUsed(button_id))\n         continue;\n \n      if (TryAddAxesButton(button_id, AxesRequirement::kRequired))\n         return true;\n     }\n \n    return false;\n  }\n",
        "output": "1",
        "index": 186536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  NewlibPackagedAppTest() : PackagedAppTest(\"newlib\") { }\n",
        "output": "0",
        "index": 143750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qeth_cm_enable(struct qeth_card *card)\n{\n\tint rc;\n\tstruct qeth_cmd_buffer *iob;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"cmenable\");\n\n\tiob = qeth_wait_for_buffer(&card->write);\n\tmemcpy(iob->data, CM_ENABLE, CM_ENABLE_SIZE);\n\tmemcpy(QETH_CM_ENABLE_ISSUER_RM_TOKEN(iob->data),\n\t       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);\n\tmemcpy(QETH_CM_ENABLE_FILTER_TOKEN(iob->data),\n\t       &card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);\n\n\trc = qeth_send_control_data(card, CM_ENABLE_SIZE, iob,\n\t\t\t\t    qeth_cm_enable_cb, NULL);\n\treturn rc;\n}\n",
        "output": "0",
        "index": 28503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebUIBidiCheckerBrowserTestLTR::RunBidiCheckerOnPage(\n    const std::string& page_url) {\n  WebUIBidiCheckerBrowserTest::RunBidiCheckerOnPage(page_url, false);\n}\n",
        "output": "0",
        "index": 110163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "user_unregister (User *user)\n{\n        g_signal_handlers_disconnect_by_func (G_OBJECT (user), G_CALLBACK (on_user_property_notify), NULL);\n\n        g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (user));\n\n        if (user->extension_ids) {\n                guint i;\n\n                for (i = 0; i < user->n_extension_ids; i++) {\n                        /* In theory, if an error happened during registration, we could have 0 here. */\n                        if (user->extension_ids[i] == 0)\n                                continue;\n\n                        g_dbus_connection_unregister_object (user->system_bus_connection, user->extension_ids[i]);\n                }\n\n                g_clear_pointer (&user->extension_ids, g_free);\n                user->n_extension_ids = 0;\n        }\n}\n",
        "output": "0",
        "index": 4757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int enter_vmx_non_root_mode(struct kvm_vcpu *vcpu, bool from_vmentry)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct loaded_vmcs *vmcs02;\n\tu32 msr_entry_idx;\n\tu32 exit_qual;\n\n\tvmcs02 = nested_get_current_vmcs02(vmx);\n\tif (!vmcs02)\n\t\treturn -ENOMEM;\n\n\tenter_guest_mode(vcpu);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\n\tvmx_switch_vmcs(vcpu, vmcs02);\n\tvmx_segment_cache_clear(vmx);\n\n\tif (prepare_vmcs02(vcpu, vmcs12, from_vmentry, &exit_qual)) {\n\t\tleave_guest_mode(vcpu);\n\t\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\t\t EXIT_REASON_INVALID_STATE, exit_qual);\n\t\treturn 1;\n\t}\n\n\tnested_get_vmcs12_pages(vcpu, vmcs12);\n\n\tmsr_entry_idx = nested_vmx_load_msr(vcpu,\n\t\t\t\t\t    vmcs12->vm_entry_msr_load_addr,\n\t\t\t\t\t    vmcs12->vm_entry_msr_load_count);\n\tif (msr_entry_idx) {\n\t\tleave_guest_mode(vcpu);\n\t\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\t\tnested_vmx_entry_failure(vcpu, vmcs12,\n\t\t\t\tEXIT_REASON_MSR_LOAD_FAIL, msr_entry_idx);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn 0;\n}\n",
        "output": "0",
        "index": 62953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = sk_filter(sk, skb);\n\tif (err)\n\t\treturn err;\n\n\treturn __sock_queue_rcv_skb(sk, skb);\n}\n",
        "output": "0",
        "index": 47909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t      gpa_t gpa)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint offset = offset_in_page(gpa);\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\n\tghc->gpa = gpa;\n\tghc->generation = slots->generation;\n\tghc->memslot = __gfn_to_memslot(slots, gfn);\n\tghc->hva = gfn_to_hva_many(ghc->memslot, gfn, NULL);\n\tif (!kvm_is_error_hva(ghc->hva))\n\t\tghc->hva += offset;\n\telse\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 20350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)\n{\n\tif (dev->addr_len != ETH_ALEN)\n\t\treturn -1;\n\tmemcpy(eui, dev->dev_addr, 3);\n\tmemcpy(eui + 5, dev->dev_addr + 3, 3);\n\n\t/*\n\t * The zSeries OSA network cards can be shared among various\n\t * OS instances, but the OSA cards have only one MAC address.\n\t * This leads to duplicate address conflicts in conjunction\n\t * with IPv6 if more than one instance uses the same card.\n\t *\n\t * The driver for these cards can deliver a unique 16-bit\n\t * identifier for each instance sharing the same card.  It is\n\t * placed instead of 0xFFFE in the interface identifier.  The\n\t * \"u\" bit of the interface identifier is not inverted in this\n\t * case.  Hence the resulting interface identifier has local\n\t * scope according to RFC2373.\n\t */\n\tif (dev->dev_id) {\n\t\teui[3] = (dev->dev_id >> 8) & 0xFF;\n\t\teui[4] = dev->dev_id & 0xFF;\n\t} else {\n\t\teui[3] = 0xFF;\n\t\teui[4] = 0xFE;\n\t\teui[0] ^= 2;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 41774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u8 llc_ui_header_len(struct sock *sk, struct sockaddr_llc *addr)\n{\n\tu8 rc = LLC_PDU_LEN_U;\n\n\tif (addr->sllc_test || addr->sllc_xid)\n\t\trc = LLC_PDU_LEN_U;\n\telse if (sk->sk_type == SOCK_STREAM)\n\t\trc = LLC_PDU_LEN_I;\n\treturn rc;\n}\n",
        "output": "0",
        "index": 30543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sctp_setsockopt_add_streams(struct sock *sk,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_add_streams params;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(params))\n\t\tgoto out;\n\n\tif (copy_from_user(&params, optval, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, params.sas_assoc_id);\n\tif (!asoc)\n\t\tgoto out;\n\n\tretval = sctp_send_add_streams(asoc, &params);\n\nout:\n\treturn retval;\n}\n",
        "output": "0",
        "index": 60691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nvmet_fc_free_ls_iodlist(struct nvmet_fc_tgtport *tgtport)\n{\n\tstruct nvmet_fc_ls_iod *iod = tgtport->iod;\n\tint i;\n\n\tfor (i = 0; i < NVMET_LS_CTX_COUNT; iod++, i++) {\n\t\tfc_dma_unmap_single(tgtport->dev,\n\t\t\t\tiod->rspdma, NVME_FC_MAX_LS_BUFFER_SIZE,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tkfree(iod->rqstbuf);\n\t\tlist_del(&iod->ls_list);\n\t}\n\tkfree(tgtport->iod);\n}\n",
        "output": "0",
        "index": 93610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsUInt32Number CMSEXPORT cmsNamedColorCount(const cmsNAMEDCOLORLIST* NamedColorList)\n{\n     if (NamedColorList == NULL) return 0;\n     return NamedColorList ->nColors;\n}\n",
        "output": "0",
        "index": 41003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dict_param_list_write(dict_param_list *plist, ref *pdict, const ref *pwanted,\n                      gs_ref_memory_t *imem)\n{\n    check_dict_write(*pdict);\n    plist->u.w.write = dict_param_write;\n    plist->enumerate = dict_param_enumerate;\n    ref_param_write_init((iparam_list *) plist, pwanted, imem);\n    plist->dict = *pdict;\n    return 0;\n}\n",
        "output": "0",
        "index": 3257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InlineFlowBox::removeChild(InlineBox* child)\n{\n    checkConsistency();\n\n    if (!m_dirty)\n        dirtyLineBoxes();\n\n    root()->childRemoved(child);\n\n    if (child == m_firstChild)\n        m_firstChild = child->nextOnLine();\n    if (child == m_lastChild)\n        m_lastChild = child->prevOnLine();\n    if (child->nextOnLine())\n        child->nextOnLine()->setPrevOnLine(child->prevOnLine());\n    if (child->prevOnLine())\n        child->prevOnLine()->setNextOnLine(child->nextOnLine());\n    \n    child->setParent(0);\n\n    checkConsistency();\n}\n",
        "output": "0",
        "index": 99162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fib6_walk(struct fib6_walker_t *w)\n{\n\tint res;\n\n\tw->state = FWS_INIT;\n\tw->node = w->root;\n\n\tfib6_walker_link(w);\n\tres = fib6_walk_continue(w);\n\tif (res <= 0)\n\t\tfib6_walker_unlink(w);\n\treturn res;\n}\n",
        "output": "0",
        "index": 28431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mpol_fix_fork_child_flag(struct task_struct *p)\n{\n\tif (p->mempolicy)\n\t\tp->flags |= PF_MEMPOLICY;\n\telse\n\t\tp->flags &= ~PF_MEMPOLICY;\n}\n",
        "output": "0",
        "index": 21321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebKit::WebFrame* RenderViewImpl::GetFrameByMappedID(int frame_id) {\n  std::map<int, int>::iterator it = active_frame_id_map_.find(frame_id);\n  if (it == active_frame_id_map_.end())\n    return NULL;\n  return FindFrameByID(webview()->mainFrame(), it->second);\n }\n",
        "output": "1",
        "index": 184225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sctp_v6_protosw_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&sctpv6_prot, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t/* Add SCTPv6(UDP and TCP style) to inetsw6 linked list. */\n\tinet6_register_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_register_protosw(&sctpv6_stream_protosw);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 29650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtnet_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct virtnet_info *vi = netdev_priv(dev);\n\tstruct virtio_device *vdev = vi->vdev;\n\tint ret;\n\tstruct sockaddr *addr = p;\n\tstruct scatterlist sg;\n\n\tret = eth_prepare_mac_addr_change(dev, p);\n\tif (ret)\n\t\treturn ret;\n\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_MAC_ADDR)) {\n\t\tsg_init_one(&sg, addr->sa_data, dev->addr_len);\n\t\tif (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,\n\t\t\t\t\t  VIRTIO_NET_CTRL_MAC_ADDR_SET, &sg)) {\n\t\t\tdev_warn(&vdev->dev,\n\t\t\t\t \"Failed to set mac address by vq command.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (virtio_has_feature(vdev, VIRTIO_NET_F_MAC) &&\n\t\t   !virtio_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\t\tunsigned int i;\n\n\t\t/* Naturally, this has an atomicity problem. */\n\t\tfor (i = 0; i < dev->addr_len; i++)\n\t\t\tvirtio_cwrite8(vdev,\n\t\t\t\t       offsetof(struct virtio_net_config, mac) +\n\t\t\t\t       i, addr->sa_data[i]);\n\t}\n\n\teth_commit_mac_addr_change(dev, p);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 43012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> optionsObjectCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.optionsObject\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(Dictionary, oo, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));\n     if (args.Length() > 0 && !oo.isUndefinedOrNull() && !oo.isObject()) {\n        return V8Proxy::throwTypeError(\"Not an object.\");\n    }\n    if (args.Length() <= 1) {\n        imp->optionsObject(oo);\n        return v8::Handle<v8::Value>();\n    }\n    EXCEPTION_BLOCK(Dictionary, ooo, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));\n    if (args.Length() > 1 && !ooo.isUndefinedOrNull() && !ooo.isObject()) {\n        return V8Proxy::throwTypeError(\"Not an object.\");\n    }\n    imp->optionsObject(oo, ooo);\n    return v8::Handle<v8::Value>();\n}\n",
        "output": "1",
        "index": 184786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n    ResourceLoader* loader,\n    net::AuthChallengeInfo* auth_info) {\n  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))\n    return false;\n\n  if (!auth_info->is_proxy) {\n    HttpAuthResourceType resource_type =\n        HttpAuthResourceTypeOf(loader->request());\n    UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\",\n                              resource_type,\n                              HTTP_AUTH_RESOURCE_LAST);\n\n    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n      return false;\n  }\n\n  return true;\n}\n",
        "output": "0",
        "index": 112307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int trace_vbprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct trace_event_call *call = &event_bprint;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct trace_array *tr = &global_trace;\n\tstruct bprint_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\tint len = 0, size, pc;\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\t/* Don't pollute graph traces with trace_vprintk internals */\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out_nobuffer;\n\t}\n\n\tlen = vbin_printf((u32 *)tbuffer, TRACE_BUF_SIZE/sizeof(int), fmt, args);\n\n\tif (len > TRACE_BUF_SIZE/sizeof(int) || len < 0)\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + sizeof(u32) * len;\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = __trace_buffer_lock_reserve(buffer, TRACE_BPRINT, size,\n\t\t\t\t\t    flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->fmt\t\t\t= fmt;\n\n\tmemcpy(entry->buf, tbuffer, sizeof(u32) * len);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(tr, buffer, flags, 6, pc, NULL);\n\t}\n\nout:\n\tput_trace_buf();\n\nout_nobuffer:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\n",
        "output": "0",
        "index": 81442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LoginDisplayHostWebUI::OnDisplayAdded(\n    const display::Display& new_display) {\n  if (GetOobeUI())\n    GetOobeUI()->OnDisplayConfigurationChanged();\n}\n",
        "output": "0",
        "index": 144314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xt_table_unlock(struct xt_table *table)\n{\n\tmutex_unlock(&xt[table->af].mutex);\n}\n",
        "output": "0",
        "index": 52443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int piv_logout(sc_card_t *card)\n{\n\tint r = SC_ERROR_NOT_SUPPORTED; /* TODO Some PIV cards may support a logout */\n\t/* piv_private_data_t * priv = PIV_DATA(card); */\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* TODO 800-73-3 does not define a logout, 800-73-4 does */\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n",
        "output": "0",
        "index": 78644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(int) gdImageSetInterpolationMethod(gdImagePtr im, gdInterpolationMethod id)\n{\n\tif (im == NULL || id < 0 || id > GD_METHOD_COUNT) {\n\t\treturn 0;\n\t}\n\n\tswitch (id) {\n\t\tcase GD_DEFAULT:\n\t\t\tim->interpolation_id = GD_BILINEAR_FIXED;\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* Optimized versions */\n\t\tcase GD_BILINEAR_FIXED:\n\t\tcase GD_BICUBIC_FIXED:\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\tcase GD_WEIGHTED4:\n\t\t\tim->interpolation = NULL;\n\t\t\tbreak;\n\n\t\t/* generic versions*/\n\t\tcase GD_BELL:\n\t\t\tim->interpolation = filter_bell;\n\t\t\tbreak;\n\t\tcase GD_BESSEL:\n\t\t\tim->interpolation = filter_bessel;\n\t\t\tbreak;\n\t\tcase GD_BICUBIC:\n\t\t\tim->interpolation = filter_bicubic;\n\t\t\tbreak;\n\t\tcase GD_BLACKMAN:\n\t\t\tim->interpolation = filter_blackman;\n\t\t\tbreak;\n\t\tcase GD_BOX:\n\t\t\tim->interpolation = filter_box;\n\t\t\tbreak;\n\t\tcase GD_BSPLINE:\n\t\t\tim->interpolation = filter_bspline;\n\t\t\tbreak;\n\t\tcase GD_CATMULLROM:\n\t\t\tim->interpolation = filter_catmullrom;\n\t\t\tbreak;\n\t\tcase GD_GAUSSIAN:\n\t\t\tim->interpolation = filter_gaussian;\n\t\t\tbreak;\n\t\tcase GD_GENERALIZED_CUBIC:\n\t\t\tim->interpolation = filter_generalized_cubic;\n\t\t\tbreak;\n\t\tcase GD_HERMITE:\n\t\t\tim->interpolation = filter_hermite;\n\t\t\tbreak;\n\t\tcase GD_HAMMING:\n\t\t\tim->interpolation = filter_hamming;\n\t\t\tbreak;\n\t\tcase GD_HANNING:\n\t\t\tim->interpolation = filter_hanning;\n\t\t\tbreak;\n\t\tcase GD_MITCHELL:\n\t\t\tim->interpolation = filter_mitchell;\n\t\t\tbreak;\n\t\tcase GD_POWER:\n\t\t\tim->interpolation = filter_power;\n\t\t\tbreak;\n\t\tcase GD_QUADRATIC:\n\t\t\tim->interpolation = filter_quadratic;\n\t\t\tbreak;\n\t\tcase GD_SINC:\n\t\t\tim->interpolation = filter_sinc;\n\t\t\tbreak;\n\t\tcase GD_TRIANGLE:\n\t\t\tim->interpolation = filter_triangle;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t}\n\tim->interpolation_id = id;\n\treturn 1;\n}\n",
        "output": "0",
        "index": 58416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::HandleDrawElements(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::DrawElements& c =\n      *static_cast<const volatile gles2::cmds::DrawElements*>(cmd_data);\n  return DoDrawElements(\"glDrawElements\", false, static_cast<GLenum>(c.mode),\n                        static_cast<GLsizei>(c.count),\n                        static_cast<GLenum>(c.type),\n                        static_cast<int32_t>(c.index_offset), 1);\n}\n",
        "output": "0",
        "index": 158712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs_write_rpcsetup(struct nfs_write_data *data,\n\t\tunsigned int count, unsigned int offset,\n\t\tint how, struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *req = data->header->req;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tdata->args.fh     = NFS_FH(data->header->inode);\n\tdata->args.offset = req_offset(req) + offset;\n\t/* pnfs_set_layoutcommit needs this */\n\tdata->mds_offset = data->args.offset;\n\tdata->args.pgbase = req->wb_pgbase + offset;\n\tdata->args.pages  = data->pages.pagevec;\n\tdata->args.count  = count;\n\tdata->args.context = get_nfs_open_context(req->wb_context);\n\tdata->args.lock_context = req->wb_lock_context;\n\tdata->args.stable  = NFS_UNSTABLE;\n\tswitch (how & (FLUSH_STABLE | FLUSH_COND_STABLE)) {\n\tcase 0:\n\t\tbreak;\n\tcase FLUSH_COND_STABLE:\n\t\tif (nfs_reqs_to_commit(cinfo))\n\t\t\tbreak;\n\tdefault:\n\t\tdata->args.stable = NFS_FILE_SYNC;\n\t}\n\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.count   = count;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}\n",
        "output": "0",
        "index": 39208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExpectChildFrameCollapsed(Shell* shell,\n                               const std::string& frame_id,\n                               bool expect_collapsed) {\n  ExpectChildFrameSetAsCollapsedInFTN(shell, expect_collapsed);\n  ExpectChildFrameCollapsedInLayout(shell, frame_id, expect_collapsed);\n}\n",
        "output": "0",
        "index": 163225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool xfrm_is_alive(const struct km_event *c)\n{\n\treturn (bool)xfrm_acquire_is_on(c->net);\n}\n",
        "output": "0",
        "index": 59370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OfflinePageModelImpl::OnStoreInitialized(const base::TimeTicks& start_time,\n                                              int init_attempts_spent,\n                                              bool success) {\n  init_attempts_spent++;\n\n  if (success) {\n    DCHECK_EQ(store_->state(), StoreState::LOADED);\n    ReportInitializationAttemptsSpent(init_attempts_spent);\n    store_->GetOfflinePages(\n        base::Bind(&OfflinePageModelImpl::OnInitialGetOfflinePagesDone,\n                   weak_ptr_factory_.GetWeakPtr(), start_time));\n    return;\n  }\n\n  DCHECK_EQ(store_->state(), StoreState::FAILED_LOADING);\n  if (init_attempts_spent >= kInitializeAttemptsMax) {\n    FinalizeModelLoad();\n    return;\n  }\n\n  const base::TimeDelta delay = base::TimeDelta::FromMilliseconds(100);\n  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&OfflinePageModelImpl::RetryDbInitialization,\n                 weak_ptr_factory_.GetWeakPtr(), start_time,\n                 init_attempts_spent),\n      delay);\n}\n",
        "output": "0",
        "index": 169087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool OxideQQuickWebViewPrivate::CanCreateWindows() const {\n  Q_Q(const OxideQQuickWebView);\n\n  return q->receivers(SIGNAL(newViewRequested(OxideQNewViewRequest*))) > 0;\n}\n",
        "output": "0",
        "index": 17024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::Delete() {\n  RenderFrameHost* focused_frame = GetFocusedFrame();\n  if (!focused_frame)\n    return;\n\n  focused_frame->Send(new InputMsg_Delete(focused_frame->GetRoutingID()));\n  RecordAction(base::UserMetricsAction(\"DeleteSelection\"));\n}\n",
        "output": "0",
        "index": 144467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static iw_tmpsample get_raw_sample(struct iw_context *ctx,\n\t   int x, int y, int channel)\n{\n\tunsigned int v;\n\n\tif(channel>=ctx->img1_numchannels_physical) {\n\t\treturn 1.0;\n\t}\n\n\tif(ctx->img1.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) {\n\t\tint rx, ry;\n\t\ttranslate_coords(ctx,x,y,&rx,&ry);\n\t\tif(ctx->img1.bit_depth!=32) return 0.0;\n\t\treturn get_raw_sample_flt32(ctx,rx,ry,channel);\n\t}\n\n\tv = get_raw_sample_int(ctx,x,y,channel);\n\treturn ((double)v) / ctx->img1_ci[channel].maxcolorcode_dbl;\n}\n",
        "output": "0",
        "index": 64906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned, flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);\n\n\tif (!sock)\n\t\tgoto out;\n\n\terr = __sys_sendmsg(sock, msg, &msg_sys, flags, NULL);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n",
        "output": "0",
        "index": 22716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int composite_abort_transfers(int sub_api, struct usbi_transfer *itransfer)\n{\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_transfer_priv *transfer_priv = usbi_transfer_get_os_priv(itransfer);\n\tstruct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);\n\n\treturn priv->usb_interface[transfer_priv->interface_number].apib->\n\t\tabort_transfers(priv->usb_interface[transfer_priv->interface_number].sub_api, itransfer);}\n",
        "output": "0",
        "index": 168524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PermissionsData::HasEffectiveAccessToAllHosts() const {\n  base::AutoLock auto_lock(runtime_lock_);\n  return active_permissions_unsafe_->HasEffectiveAccessToAllHosts();\n}\n",
        "output": "0",
        "index": 164416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::VoidMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethod\");\n\n  test_object_v8_internal::VoidMethodMethod(info);\n}\n",
        "output": "0",
        "index": 148120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DownloadManagerImpl::BeginDownloadInternal(\n    std::unique_ptr<content::DownloadUrlParameters> params,\n    uint32_t id) {\n  download::InProgressCache* in_progress_cache =\n      GetBrowserContext()->GetDownloadManagerDelegate()->GetInProgressCache();\n  if (in_progress_cache) {\n    in_progress_cache->AddOrReplaceEntry(\n        download::DownloadEntry(params->guid(), params->request_origin(),\n                                ToDownloadSource(params->download_source())));\n  }\n\n  if (base::FeatureList::IsEnabled(features::kNetworkService)) {\n    std::unique_ptr<ResourceRequest> request = CreateResourceRequest(\n        params.get());\n    StoragePartitionImpl* storage_partition =\n        GetStoragePartition(browser_context_, params->render_process_host_id(),\n                            params->render_frame_host_routing_id());\n    BrowserThread::PostTaskAndReplyWithResult(\n        BrowserThread::IO, FROM_HERE,\n        base::BindOnce(\n            &BeginResourceDownload, std::move(params), std::move(request),\n            storage_partition->url_loader_factory_getter(),\n             base::WrapRefCounted(storage_partition->GetFileSystemContext()),\n             id, weak_factory_.GetWeakPtr()),\n        base::BindOnce(&DownloadManagerImpl::AddUrlDownloadHandler,\n                       weak_factory_.GetWeakPtr()));\n  } else {\n    BrowserThread::PostTaskAndReplyWithResult(\n        BrowserThread::IO, FROM_HERE,\n        base::BindOnce(&BeginDownload, std::move(params),\n                       browser_context_->GetResourceContext(), id,\n                       weak_factory_.GetWeakPtr()),\n         base::BindOnce(&DownloadManagerImpl::AddUrlDownloadHandler,\n                        weak_factory_.GetWeakPtr()));\n   }\n}\n",
        "output": "0",
        "index": 159227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Block::IsInvisible() const\n{\n    return bool(int(m_flags & 0x08) != 0);\n }\n",
        "output": "1",
        "index": 188413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_open_recover(struct nfs4_opendata *opendata, struct nfs4_state *state)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\t/* memory barrier prior to reading state->n_* */\n\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\tsmp_rmb();\n\tif (state->n_rdwr != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ|FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_wronly != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_WRITE, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\tif (state->n_rdonly != 0) {\n\t\tret = nfs4_open_recover_helper(opendata, FMODE_READ, &newstate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tif (newstate != state)\n\t\t\treturn -ESTALE;\n\t}\n\t/*\n\t * We may have performed cached opens for all three recoveries.\n\t * Check if we need to update the current stateid.\n\t */\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0 &&\n\t    memcmp(state->stateid.data, state->open_stateid.data, sizeof(state->stateid.data)) != 0) {\n\t\twrite_seqlock(&state->seqlock);\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\t\tmemcpy(state->stateid.data, state->open_stateid.data, sizeof(state->stateid.data));\n\t\twrite_sequnlock(&state->seqlock);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 22886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsWindow::HandleKeyboardEvent(\n    WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (event.windows_key_code == 0x08) {\n    return;\n  }\n  BrowserWindow* inspected_window = GetInspectedBrowserWindow();\n  if (inspected_window)\n    inspected_window->HandleKeyboardEvent(event);\n}\n",
        "output": "0",
        "index": 163873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GDataFile* GDataFile::AsGDataFile() {\n  return this;\n}\n",
        "output": "0",
        "index": 111625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void btif_config_write(void) {\n  assert(config != NULL);\n  assert(alarm_timer != NULL);\n\n  pthread_mutex_lock(&lock);\n config_t *config_paired = config_new_clone(config);\n  btif_config_remove_unpaired(config_paired);\n  config_save(config_paired, CONFIG_FILE_PATH);\n  config_free(config_paired);\n  pthread_mutex_unlock(&lock);\n}\n",
        "output": "0",
        "index": 172843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::OnNavigate(\n    const CommonNavigationParams& common_params,\n    const StartNavigationParams& start_params,\n    const RequestNavigationParams& request_params) {\n  DCHECK(!base::CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableBrowserSideNavigation));\n  TRACE_EVENT2(\"navigation\", \"RenderFrameImpl::OnNavigate\", \"id\", routing_id_,\n               \"url\", common_params.url.possibly_invalid_spec());\n  NavigateInternal(common_params, start_params, request_params,\n                   scoped_ptr<StreamOverrideParameters>());\n}\n",
        "output": "0",
        "index": 132246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_param_count(int nparams, int expect)\n{\n if (nparams != expect)\n {\n      fprintf(stderr, \"bad parameter count (internal error)\\n\");\n      exit(1);\n }\n}\n",
        "output": "0",
        "index": 172992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_rndis(USBNetState *s)\n{\n    return s->dev.config ?\n            s->dev.config->bConfigurationValue == DEV_RNDIS_CONFIG_VALUE : 0;\n}\n",
        "output": "0",
        "index": 12590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WasAutoOpened(DownloadItem* item) {\n  return item->GetAutoOpened();\n}\n",
        "output": "0",
        "index": 164873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool DefaultTabHandler::RunUnloadListenerBeforeClosing(\n    TabContentsWrapper* contents) {\n   return delegate_->AsBrowser()->RunUnloadListenerBeforeClosing(contents);\n }\n",
        "output": "0",
        "index": 102929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MaybeReportDownloadDeepScanningVerdict(\n    Profile* profile,\n    const GURL& url,\n    const std::string& file_name,\n     const std::string& download_digest_sha256,\n     BinaryUploadService::Result result,\n     DeepScanningClientResponse response) {\n   if (response.malware_scan_verdict().verdict() ==\n           MalwareDeepScanningVerdict::UWS ||\n       response.malware_scan_verdict().verdict() ==\n           MalwareDeepScanningVerdict::MALWARE) {\n     extensions::SafeBrowsingPrivateEventRouterFactory::GetForProfile(profile)\n         ->OnDangerousDeepScanningResult(url, file_name, download_digest_sha256);\n   }\n }\n",
        "output": "1",
        "index": 186381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::ActivityLoggingForAllWorldsPerWorldBindingsVoidMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_activityLoggingForAllWorldsPerWorldBindingsVoidMethod\");\n\n  ScriptState* script_state = ScriptState::ForRelevantRealm(info);\n  V8PerContextData* context_data = script_state->PerContextData();\n  if (context_data && context_data->ActivityLogger()) {\n    context_data->ActivityLogger()->LogMethod(\"TestObject.activityLoggingForAllWorldsPerWorldBindingsVoidMethod\", info);\n  }\n  test_object_v8_internal::ActivityLoggingForAllWorldsPerWorldBindingsVoidMethodMethod(info);\n}\n",
        "output": "0",
        "index": 147165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GBool FlateStream::isBinary(GBool last) {\n  return str->isBinary(gTrue);\n}\n",
        "output": "0",
        "index": 3983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NetworkChangeNotifierMac::~NetworkChangeNotifierMac() {\n  config_watcher_.reset();\n\n  if (reachability_.get() && run_loop_.get()) {\n    SCNetworkReachabilityUnscheduleFromRunLoop(reachability_.get(),\n                                               run_loop_.get(),\n                                               kCFRunLoopCommonModes);\n  }\n}\n",
        "output": "0",
        "index": 169469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pop_check_mailbox(struct Context *ctx, int *index_hint)\n{\n  int ret;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n\n  if ((pop_data->check_time + PopCheckinterval) > time(NULL))\n    return 0;\n\n  pop_logout(ctx);\n\n  mutt_socket_close(pop_data->conn);\n\n  if (pop_open_connection(pop_data) < 0)\n    return -1;\n\n  ctx->size = pop_data->size;\n\n  mutt_message(_(\"Checking for new messages...\"));\n\n  ret = pop_fetch_headers(ctx);\n  pop_clear_cache(pop_data);\n\n  if (ret < 0)\n    return -1;\n\n  if (ret > 0)\n    return MUTT_NEW_MAIL;\n\n  return 0;\n}\n",
        "output": "0",
        "index": 79479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int getSocketType(char* name) {\n    int type = -1;\n    uint i;\n    for(i=0; i<sizeof(types)/sizeof(struct socket_type); ++i) {\n        if( !strcmp(types[i].name, name) ) {\n            type = types[i].type;\n            break;\n        }\n    }\n    return type;\n}\n",
        "output": "0",
        "index": 62763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AppCacheDatabase::ReadGroupRecord(\n    const sql::Statement& statement, GroupRecord* record) {\n  record->group_id = statement.ColumnInt64(0);\n  record->origin = url::Origin::Create(GURL(statement.ColumnString(1)));\n  record->manifest_url = GURL(statement.ColumnString(2));\n  record->creation_time =\n      base::Time::FromInternalValue(statement.ColumnInt64(3));\n\n  const auto found = lazy_last_access_times_.find(record->group_id);\n  if (found != lazy_last_access_times_.end()) {\n    record->last_access_time = found->second;\n  } else {\n    record->last_access_time =\n        base::Time::FromInternalValue(statement.ColumnInt64(4));\n  }\n\n  record->last_full_update_check_time =\n      base::Time::FromInternalValue(statement.ColumnInt64(5));\n  record->first_evictable_error_time =\n      base::Time::FromInternalValue(statement.ColumnInt64(6));\n}\n",
        "output": "0",
        "index": 164126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParse3986DecOctet(const char **str) {\n const char *cur = *str;\n\n if (!(ISA_DIGIT(cur)))\n return(1);\n if (!ISA_DIGIT(cur+1))\n\tcur++;\n else if ((*cur != '0') && (ISA_DIGIT(cur + 1)) && (!ISA_DIGIT(cur+2)))\n\tcur += 2;\n else if ((*cur == '1') && (ISA_DIGIT(cur + 1)) && (ISA_DIGIT(cur + 2)))\n\tcur += 3;\n else if ((*cur == '2') && (*(cur + 1) >= '0') &&\n (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))\n\tcur += 3;\n else if ((*cur == '2') && (*(cur + 1) == '5') &&\n (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))\n\tcur += 3;\n else\n return(1);\n *str = cur;\n return(0);\n}\n",
        "output": "0",
        "index": 176516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebView::setFindIndicatorCallback(WKViewFindIndicatorCallback callback, void* context)\n{\n    m_findIndicatorCallback = callback;\n    m_findIndicatorCallbackContext = context;\n}\n",
        "output": "0",
        "index": 106758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEdgeDetectQuick(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n",
        "output": "0",
        "index": 15198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OfflineAudioDestinationHandler::Create(AudioNode& node,\n                                       unsigned number_of_channels,\n                                       uint32_t frames_to_process,\n                                       float sample_rate) {\n  return base::AdoptRef(new OfflineAudioDestinationHandler(\n      node, number_of_channels, frames_to_process, sample_rate));\n}\n",
        "output": "0",
        "index": 143080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void VoidMethodNodeArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"voidMethodNodeArg\", \"TestObject\", ExceptionMessages::NotEnoughArguments(1, info.Length())));\n    return;\n  }\n\n  Node* node_arg;\n  node_arg = V8Node::ToImplWithTypeCheck(info.GetIsolate(), info[0]);\n  if (!node_arg) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"voidMethodNodeArg\", \"TestObject\", ExceptionMessages::ArgumentNotOfType(0, \"Node\")));\n    return;\n  }\n\n  impl->voidMethodNodeArg(node_arg);\n}\n",
        "output": "0",
        "index": 148121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionService::TrackTerminatedExtension(const Extension* extension) {\n  if (terminated_extension_ids_.insert(extension->id()).second)\n    terminated_extensions_.push_back(make_scoped_refptr(extension));\n\n  UnloadExtension(extension->id(), extension_misc::UNLOAD_REASON_DISABLE);\n}\n",
        "output": "0",
        "index": 103528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "enqueue_job(job j, usec delay, char update_store)\n{\n    int r;\n\n    j->reserver = NULL;\n    if (delay) {\n        j->deadline_at = now_usec() + delay;\n        r = pq_give(&j->tube->delay, j);\n        if (!r) return 0;\n        j->state = JOB_STATE_DELAYED;\n        set_main_delay_timeout();\n    } else {\n        r = pq_give(&j->tube->ready, j);\n        if (!r) return 0;\n        j->state = JOB_STATE_READY;\n        ready_ct++;\n        if (j->pri < URGENT_THRESHOLD) {\n            global_stat.urgent_ct++;\n            j->tube->stat.urgent_ct++;\n        }\n    }\n\n    if (update_store) {\n        r = binlog_write_job(j);\n        if (!r) return -1;\n    }\n\n    process_queue();\n    return 1;\n}\n",
        "output": "0",
        "index": 18134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  lookup_lwfn_by_fond( const UInt8*      path_fond,\n                       ConstStr255Param  base_lwfn,\n                       UInt8*            path_lwfn,\n                       size_t            path_size )\n  {\n    FSRef   ref, par_ref;\n    size_t  dirname_len;\n\n\n    /* Pathname for FSRef can be in various formats: HFS, HFS+, and POSIX. */\n    /* We should not extract parent directory by string manipulation.      */\n\n    if ( noErr != FSPathMakeRef( path_fond, &ref, FALSE ) )\n      return FT_THROW( Invalid_Argument );\n\n    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoNone,\n                                    NULL, NULL, NULL, &par_ref ) )\n      return FT_THROW( Invalid_Argument );\n\n    if ( noErr != FSRefMakePath( &par_ref, path_lwfn, path_size ) )\n      return FT_THROW( Invalid_Argument );\n\n    if ( ft_strlen( (char *)path_lwfn ) + 1 + base_lwfn[0] > path_size )\n      return FT_THROW( Invalid_Argument );\n\n    /* now we have absolute dirname in path_lwfn */\n    ft_strcat( (char *)path_lwfn, \"/\" );\n    dirname_len = ft_strlen( (char *)path_lwfn );\n    ft_strcat( (char *)path_lwfn, (char *)base_lwfn + 1 );\n    path_lwfn[dirname_len + base_lwfn[0]] = '\\0';\n\n    if ( noErr != FSPathMakeRef( path_lwfn, &ref, FALSE ) )\n      return FT_THROW( Cannot_Open_Resource );\n\n    if ( noErr != FSGetCatalogInfo( &ref, kFSCatInfoNone,\n                                    NULL, NULL, NULL, NULL ) )\n      return FT_THROW( Cannot_Open_Resource );\n\n    return FT_Err_Ok;\n  }\n",
        "output": "0",
        "index": 6958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "removedirs (char const *name)\n{\n  char *filename = xstrdup (name);\n  size_t i;\n\n  for (i = strlen (filename);  i != 0;  i--)\n    if (ISSLASH (filename[i])\n\t&& ! (ISSLASH (filename[i - 1])\n\t      || (filename[i - 1] == '.'\n\t\t  && (i == 1\n\t\t      || ISSLASH (filename[i - 2])\n\t\t      || (filename[i - 2] == '.'\n\t\t\t  && (i == 2\n\t\t\t      || ISSLASH (filename[i - 3])))))))\n      {\n\tfilename[i] = '\\0';\n\tif (rmdir (filename) == 0 && verbosity == VERBOSE)\n\t  say (\"Removed empty directory %s\\n\", quotearg (filename));\n\tfilename[i] = '/';\n      }\n  free (filename);\n}\n",
        "output": "0",
        "index": 5661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool tcp_need_reset(int state)\n{\n\treturn (1 << state) &\n\t       (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_FIN_WAIT1 |\n\t\tTCPF_FIN_WAIT2 | TCPF_SYN_RECV);\n}\n",
        "output": "0",
        "index": 61751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FrameLoader::InsecureNavigationsToUpgrade() const {\n  DCHECK(frame_);\n  Frame* parent_frame = frame_->Tree().Parent();\n  if (!parent_frame)\n    return nullptr;\n\n  return parent_frame->GetSecurityContext()->InsecureNavigationsToUpgrade();\n}\n",
        "output": "0",
        "index": 136662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  media::VideoCapture::EventHandler* capture_client() {\n    return static_cast<media::VideoCapture::EventHandler*>(decoder_);\n   }\n",
        "output": "0",
        "index": 113327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __cast6_decrypt(struct cast6_ctx *c, u8 *outbuf, const u8 *inbuf)\n{\n\tconst __be32 *src = (const __be32 *)inbuf;\n\t__be32 *dst = (__be32 *)outbuf;\n\tu32 block[4];\n\tu32 *Km;\n\tu8 *Kr;\n\n\tblock[0] = be32_to_cpu(src[0]);\n\tblock[1] = be32_to_cpu(src[1]);\n\tblock[2] = be32_to_cpu(src[2]);\n\tblock[3] = be32_to_cpu(src[3]);\n\n\tKm = c->Km[11]; Kr = c->Kr[11]; Q(block, Kr, Km);\n\tKm = c->Km[10]; Kr = c->Kr[10]; Q(block, Kr, Km);\n\tKm = c->Km[9]; Kr = c->Kr[9]; Q(block, Kr, Km);\n\tKm = c->Km[8]; Kr = c->Kr[8]; Q(block, Kr, Km);\n\tKm = c->Km[7]; Kr = c->Kr[7]; Q(block, Kr, Km);\n\tKm = c->Km[6]; Kr = c->Kr[6]; Q(block, Kr, Km);\n\tKm = c->Km[5]; Kr = c->Kr[5]; QBAR(block, Kr, Km);\n\tKm = c->Km[4]; Kr = c->Kr[4]; QBAR(block, Kr, Km);\n\tKm = c->Km[3]; Kr = c->Kr[3]; QBAR(block, Kr, Km);\n\tKm = c->Km[2]; Kr = c->Kr[2]; QBAR(block, Kr, Km);\n\tKm = c->Km[1]; Kr = c->Kr[1]; QBAR(block, Kr, Km);\n\tKm = c->Km[0]; Kr = c->Kr[0]; QBAR(block, Kr, Km);\n\n\tdst[0] = cpu_to_be32(block[0]);\n\tdst[1] = cpu_to_be32(block[1]);\n\tdst[2] = cpu_to_be32(block[2]);\n\tdst[3] = cpu_to_be32(block[3]);\n}\n",
        "output": "0",
        "index": 47179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "coolkey_find_object_by_template(sc_card_t *card, sc_cardctl_coolkey_attribute_t *template, int count)\n{\n\tlist_t *list;\n\tsc_cardctl_coolkey_object_t *current, *rv = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint i, r;\n\tunsigned int tmp_pos = (unsigned int) -1;\n\n\tlist = &priv->objects_list;\n\tif (list->iter_active) {\n\t\t/* workaround missing functionality of second iterator */\n\t\ttmp_pos = list->iter_pos;\n\t\tlist_iterator_stop(list);\n\t}\n\n\tlist_iterator_start(list);\n\twhile (list_iterator_hasnext(list)) {\n\t\tsc_cardctl_coolkey_attribute_t attribute;\n\t\tcurrent = list_iterator_next(list);\n\t\tattribute.object = current;\n\n\t\tfor (i=0; i < count; i++) {\n\t\t\tattribute.attribute_type = template[i].attribute_type;\n\t\t\tr = coolkey_find_attribute(card, &attribute);\n\t\t\tif (r < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (template[i].attribute_data_type != attribute.attribute_data_type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (template[i].attribute_length != attribute.attribute_length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (memcmp(attribute.attribute_value, template[i].attribute_value,\n\t\t\t\t\t\t\tattribute.attribute_length) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* just return the first one */\n\t\tif (i == count) {\n\t\t\trv = current;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_iterator_stop(list);\n\tif (tmp_pos != (unsigned int)-1) {\n\t\t/* workaround missing functionality of second iterator */\n\t\tlist_iterator_start(list);\n\t\twhile (list_iterator_hasnext(list) && list->iter_pos < tmp_pos)\n\t\t\t(void) list_iterator_next(list);\n\t}\n\treturn rv;\n}\n",
        "output": "0",
        "index": 78286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string TestURLLoader::TestUntrustedCorbEligibleRequest() {\n  std::string cross_origin_url =\n      GetReachableCrossOriginURL(\"corb_eligible_resource.json\");\n\n  pp::URLRequestInfo request(instance_);\n  request.SetURL(cross_origin_url);\n  request.SetAllowCrossOriginRequests(true);\n\n  std::string response_body;\n  int32_t rv = OpenUntrusted(request, &response_body);\n\n  if (rv != PP_ERROR_NOACCESS) {\n    return ReportError(\"Untrusted Javascript URL request restriction failed\",\n                       rv);\n  }\n  ASSERT_EQ(\"\", response_body);\n  PASS();\n}\n",
        "output": "0",
        "index": 169638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::SetSubframeUnloadTimeoutForTesting(\n    const base::TimeDelta& timeout) {\n  subframe_unload_timeout_ = timeout;\n}\n",
        "output": "0",
        "index": 152093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::registerProtocolHandler(const WebString& scheme,\n                                         const WebString& base_url,\n                                         const WebString& url,\n                                         const WebString& title) {\n  GURL base(base_url);\n  GURL absolute_url = base.Resolve(UTF16ToUTF8(url));\n  if (base.GetOrigin() != absolute_url.GetOrigin()) {\n    return;\n  }\n  RenderThread::current()->Send(\n      new ViewHostMsg_RegisterProtocolHandler(routing_id_,\n                                              UTF16ToUTF8(scheme),\n                                              absolute_url,\n                                              title));\n}\n",
        "output": "0",
        "index": 103912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virConnectGetDomainCapabilities(virConnectPtr conn,\n                                const char *emulatorbin,\n                                const char *arch,\n                                const char *machine,\n                                const char *virttype,\n                                unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, emulatorbin=%s, arch=%s, \"\n              \"machine=%s, virttype=%s, flags=%x\",\n              conn, NULLSTR(emulatorbin), NULLSTR(arch),\n              NULLSTR(machine), NULLSTR(virttype), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    if (conn->driver->connectGetDomainCapabilities) {\n        char *ret;\n        ret = conn->driver->connectGetDomainCapabilities(conn, emulatorbin,\n                                                         arch, machine,\n                                                         virttype, flags);\n        if (!ret)\n            goto error;\n        VIR_DEBUG(\"conn=%p, ret=%s\", conn, ret);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}\n",
        "output": "0",
        "index": 93753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VOID ProcessSGListHandler(\n    IN PDEVICE_OBJECT  pDO,\n    IN PVOID  Reserved,\n    IN PSCATTER_GATHER_LIST  pSGL,\n    IN PVOID  Context\n    )\n{\n    UNREFERENCED_PARAMETER(Reserved);\n    UNREFERENCED_PARAMETER(pDO);\n\n    auto NBHolder = static_cast<CNB*>(Context);\n    NBHolder->MappingDone(pSGL);\n}\n",
        "output": "0",
        "index": 96377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static QJSValue buildQJSValue(QJSEngine* engine, JSGlobalContextRef context, JSValueRef value, int depth)\n{\n    QJSValue var;\n    JSValueRef exception = 0;\n\n    if (depth > 10)\n        return var;\n\n    switch (JSValueGetType(context, value)) {\n    case kJSTypeBoolean:\n        var = QJSValue(JSValueToBoolean(context, value));\n        break;\n    case kJSTypeNumber:\n        {\n            double number = JSValueToNumber(context, value, &exception);\n            if (!exception)\n                var = QJSValue(number);\n        }\n        break;\n    case kJSTypeString:\n        {\n            JSRetainPtr<JSStringRef> string = JSValueToStringCopy(context, value, &exception);\n            if (!exception)\n                var = toQJSValue(string.get());\n        }\n        break;\n    case kJSTypeObject:\n        {\n            JSObjectRef obj = JSValueToObject(context, value, &exception);\n\n            JSPropertyNameArrayRef names = JSObjectCopyPropertyNames(context, obj);\n            size_t length = JSPropertyNameArrayGetCount(names);\n\n            var = engine->newObject();\n\n            for (size_t i = 0; i < length; ++i) {\n                JSRetainPtr<JSStringRef> name = JSPropertyNameArrayGetNameAtIndex(names, i);\n                JSValueRef property = JSObjectGetProperty(context, obj, name.get(), &exception);\n\n                if (!exception) {\n                    QJSValue value = buildQJSValue(engine, context, property, depth + 1);\n                    var.setProperty(toQString(name.get()), value);\n                }\n            }\n        }\n        break;\n    }\n    return var;\n}\n",
        "output": "0",
        "index": 116228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 62020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u32 nfsd4_getfh_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + NFS4_FHSIZE;\n}\n",
        "output": "0",
        "index": 65334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void PruneToCubeDepth(CubeInfo *cube_info,const NodeInfo *node_info)\n{\n  register ssize_t\n    i;\n\n  size_t\n    number_children;\n\n  /*\n    Traverse any children.\n  */\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      PruneToCubeDepth(cube_info,node_info->child[i]);\n  if (node_info->level > cube_info->depth)\n    PruneChild(cube_info,node_info);\n}\n",
        "output": "0",
        "index": 62720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t    union sctp_params param)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (net->sctp.prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\t    asoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\t/* if the peer reports AUTH, assume that he\n\t\t\t * supports AUTH.\n\t\t\t */\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 35885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChildProcessSecurityPolicyImpl::AddWorker(int child_id,\n                                               int main_render_process_id) {\n  base::AutoLock lock(lock_);\n  AddChild(child_id);\n  worker_map_[child_id] = main_render_process_id;\n}\n",
        "output": "0",
        "index": 108768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::setVisuallyOrdered()\n{\n    m_visuallyOrdered = true;\n    if (renderer())\n        renderer()->style()->setRTLOrdering(VisualOrder);\n    setNeedsStyleRecalc();\n}\n",
        "output": "0",
        "index": 109830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FoFiType1 *FoFiType1::load(char *fileName) {\n  char *fileA;\n  int lenA;\n\n  if (!(fileA = FoFiBase::readFile(fileName, &lenA))) {\n    return NULL;\n  }\n  return new FoFiType1(fileA, lenA, gTrue);\n}\n",
        "output": "0",
        "index": 8062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int bond_slave_override(struct bonding *bond,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint i, res = 1;\n\tstruct slave *slave = NULL;\n\tstruct slave *check_slave;\n\n\tif (!skb->queue_mapping)\n\t\treturn 1;\n\n\t/* Find out if any slaves have the same mapping as this skb. */\n\tbond_for_each_slave(bond, check_slave, i) {\n\t\tif (check_slave->queue_id == skb->queue_mapping) {\n\t\t\tslave = check_slave;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If the slave isn't UP, use default transmit policy. */\n\tif (slave && slave->queue_id && IS_UP(slave->dev) &&\n\t    (slave->link == BOND_LINK_UP)) {\n\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t}\n\n\treturn res;\n}\n",
        "output": "0",
        "index": 23762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtr<XPathNSResolver> Document::createNSResolver(Node* nodeResolver)\n{\n    if (!m_xpathEvaluator)\n        m_xpathEvaluator = XPathEvaluator::create();\n    return m_xpathEvaluator->createNSResolver(nodeResolver);\n}\n",
        "output": "0",
        "index": 112422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void le_test_mode_recv_callback (bt_status_t status, uint16_t packet_count) {\n\n    ALOGV(\"%s: status:%d packet_count:%d \", __FUNCTION__, status, packet_count);\n}\n",
        "output": "0",
        "index": 176864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n {\n\tif(!src.HasSampleData()) return;\n \n \tdest.FreeSample();\n \tdest = src;\n \tdest.nLength = len;\n \tdest.pSample = nullptr;\n\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}\n",
        "output": "1",
        "index": 182510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API void r_bin_java_bootstrap_methods_attr_free(void /*RBinJavaAttrInfo*/ *a) {\n\tRBinJavaAttrInfo *attr = a;\n\tif (attr && attr->type == R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR) {\n\t\tfree (attr->name);\n\t\tfree (attr->metas);\n\t\tr_list_free (attr->info.bootstrap_methods_attr.bootstrap_methods);\n\t\tfree (attr);\n\t}\n}\n",
        "output": "0",
        "index": 79686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BaseShadow::retryJobCleanupHandler( void )\n{\n\tm_cleanup_retry_tid = -1;\n\tdprintf(D_ALWAYS, \"Retrying job cleanup, calling terminateJob()\\n\");\n\tterminateJob();\n\treturn TRUE;\n}\n",
        "output": "0",
        "index": 16349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int send_udp(struct mt_packet *packet, int retransmit) {\n\tint sent_bytes;\n\n\t/* Clear keepalive counter */\n\tkeepalive_counter = 0;\n\n\tif (!use_raw_socket) {\n\t\t/* Init SendTo struct */\n\t\tstruct sockaddr_in socket_address;\n\t\tsocket_address.sin_family = AF_INET;\n\t\tsocket_address.sin_port = htons(MT_MACTELNET_PORT);\n\t\tsocket_address.sin_addr.s_addr = htonl(INADDR_BROADCAST);\n\n\t\tsent_bytes = sendto(send_socket, packet->data, packet->size, 0, (struct sockaddr*)&socket_address, sizeof(socket_address));\n\t} else {\n\t\tsent_bytes = net_send_udp(sockfd, active_interface, srcmac, dstmac, &sourceip,  sourceport, &destip, MT_MACTELNET_PORT, packet->data, packet->size);\n\t}\n\n\t/* \n\t * Retransmit packet if no data is received within\n\t * retransmit_intervals milliseconds.\n\t */\n\tif (retransmit) {\n\t\tint i;\n\n\t\tfor (i = 0; i < MAX_RETRANSMIT_INTERVALS; ++i) {\n\t\t\tfd_set read_fds;\n\t\t\tint reads;\n\t\t\tstruct timeval timeout;\n\t\t\tint interval = retransmit_intervals[i] * 1000;\n\n\t\t\t/* Init select */\n\t\t\tFD_ZERO(&read_fds);\n\t\t\tFD_SET(insockfd, &read_fds);\n\t\t\ttimeout.tv_sec = 0;\n\t\t\ttimeout.tv_usec = interval;\n\n\t\t\t/* Wait for data or timeout */\n\t\t\treads = select(insockfd + 1, &read_fds, NULL, NULL, &timeout);\n\t\t\tif (reads && FD_ISSET(insockfd, &read_fds)) {\n\t\t\t\tunsigned char buff[MT_PACKET_LEN];\n\t\t\t\tint result;\n\n\t\t\t\tbzero(buff, sizeof(buff));\n\t\t\t\tresult = recvfrom(insockfd, buff, sizeof(buff), 0, 0, 0);\n\n\t\t\t\t/* Handle incoming packets, waiting for an ack */\n\t\t\t\tif (result > 0 && handle_packet(buff, result) == MT_PTYPE_ACK) {\n\t\t\t\t\treturn sent_bytes;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Retransmit */\n\t\t\tsend_udp(packet, 0);\n\t\t}\n\n\t\tif (is_a_tty && terminal_mode) {\n\t\t\treset_term();\n\t\t}\n\n\t\tfprintf(stderr, _(\"\\nConnection timed out\\n\"));\n\t\texit(1);\n\t}\n\treturn sent_bytes;\n}\n",
        "output": "0",
        "index": 50287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mark_page_dirty_in_slot(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\t     gfn_t gfn)\n{\n\tif (memslot && memslot->dirty_bitmap) {\n\t\tunsigned long rel_gfn = gfn - memslot->base_gfn;\n\n\t\tif (!test_and_set_bit_le(rel_gfn, memslot->dirty_bitmap))\n\t\t\tmemslot->nr_dirty_pages++;\n\t}\n}\n",
        "output": "0",
        "index": 20415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebMediaPlayerImpl::RegisterContentsLayer(cc::Layer* layer) {\n  DCHECK(bridge_);\n  bridge_->SetContentsOpaque(opaque_);\n  client_->SetCcLayer(layer);\n}\n",
        "output": "0",
        "index": 157299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}\n",
        "output": "0",
        "index": 84808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BaseNode::~BaseNode() {}\n",
        "output": "0",
        "index": 101391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtr<Document> HTMLDocument::cloneDocumentWithoutChildren()\n{\n    return create(DocumentInit(url()).withRegistrationContext(registrationContext()));\n}\n",
        "output": "0",
        "index": 118727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sock_def_write_space(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\n\t/* Do not wake up a writer until he can make \"significant\"\n\t * progress.  --DaveM\n\t */\n\tif ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf) {\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq_has_sleeper(wq))\n\t\t\twake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n\t\t\t\t\t\tPOLLWRNORM | POLLWRBAND);\n\n\t\t/* Should agree with poll, otherwise some programs break */\n\t\tif (sock_writeable(sk))\n\t\t\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\t}\n\n\trcu_read_unlock();\n}\n",
        "output": "0",
        "index": 20163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "scoped_ptr<ViewMsg_Resize_Params> RenderViewTest::InitialSizeParams() {\n  return make_scoped_ptr(new ViewMsg_Resize_Params());\n}\n",
        "output": "0",
        "index": 132155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ecryptfs_filldir(struct dir_context *ctx, const char *lower_name,\n\t\t int lower_namelen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct ecryptfs_getdents_callback *buf =\n\t\tcontainer_of(ctx, struct ecryptfs_getdents_callback, ctx);\n\tsize_t name_size;\n\tchar *name;\n\tint rc;\n\n\tbuf->filldir_called++;\n\trc = ecryptfs_decode_and_decrypt_filename(&name, &name_size,\n\t\t\t\t\t\t  buf->sb, lower_name,\n\t\t\t\t\t\t  lower_namelen);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decode and decrypt \"\n\t\t       \"filename [%s]; rc = [%d]\\n\", __func__, lower_name,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tbuf->caller->pos = buf->ctx.pos;\n\trc = !dir_emit(buf->caller, name, name_size, ino, d_type);\n\tkfree(name);\n\tif (!rc)\n\t\tbuf->entries_written++;\nout:\n\treturn rc;\n}\n",
        "output": "0",
        "index": 94940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2Implementation::GetUniformiv(GLuint program,\n                                       GLint location,\n                                       GLint* params) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glGetUniformiv(\" << program << \", \"\n                     << location << \", \" << static_cast<const void*>(params)\n                     << \")\");\n  TRACE_EVENT0(\"gpu\", \"GLES2::GetUniformiv\");\n  typedef cmds::GetUniformiv::Result Result;\n  auto result = GetResultAs<Result>();\n  if (!result) {\n    return;\n  }\n  result->SetNumResults(0);\n  helper_->GetUniformiv(program, location, GetResultShmId(), result.offset());\n  WaitForCmd();\n  result->CopyResult(params);\n  GPU_CLIENT_LOG_CODE_BLOCK({\n    for (int32_t i = 0; i < result->GetNumResults(); ++i) {\n      GPU_CLIENT_LOG(\"  \" << i << \": \" << result->GetData()[i]);\n    }\n  });\n  CheckGLError();\n}\n",
        "output": "0",
        "index": 153738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_delayed_job_ct()\n{\n    tube t;\n    size_t i;\n    unsigned int count = 0;\n\n    for (i = 0; i < tubes.used; i++) {\n        t = tubes.items[i];\n        count += t->delay.used;\n    }\n    return count;\n}\n",
        "output": "0",
        "index": 18143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntPoint RenderBox::flipForWritingMode(const IntPoint& position) const\n{\n    if (!style()->isFlippedBlocksWritingMode())\n        return position;\n    return isHorizontalWritingMode() ? IntPoint(position.x(), height() - position.y()) : IntPoint(width() - position.x(), position.y());\n}\n",
        "output": "0",
        "index": 106871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InterstitialPageImpl::SetSize(const gfx::Size& size) {\n  if (!enabled())\n    return;\n#if !defined(OS_MACOSX)\n  if (render_view_host_->GetWidget()->GetView())\n    render_view_host_->GetWidget()->GetView()->SetSize(size);\n#else\n  NOTIMPLEMENTED();\n#endif\n}\n",
        "output": "0",
        "index": 148809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGL2RenderingContextBase::framebufferTextureLayer(GLenum target,\n                                                         GLenum attachment,\n                                                         WebGLTexture* texture,\n                                                         GLint level,\n                                                         GLint layer) {\n  if (isContextLost() || !ValidateFramebufferFuncParameters(\n                             \"framebufferTextureLayer\", target, attachment))\n    return;\n  if (texture && !texture->Validate(ContextGroup(), this)) {\n    SynthesizeGLError(GL_INVALID_VALUE, \"framebufferTextureLayer\",\n                      \"no texture or texture not from this context\");\n    return;\n  }\n  GLenum textarget = texture ? texture->GetTarget() : 0;\n  if (texture) {\n    if (textarget != GL_TEXTURE_3D && textarget != GL_TEXTURE_2D_ARRAY) {\n      SynthesizeGLError(GL_INVALID_OPERATION, \"framebufferTextureLayer\",\n                        \"invalid texture type\");\n      return;\n    }\n    if (!ValidateTexFuncLayer(\"framebufferTextureLayer\", textarget, layer))\n      return;\n    if (!ValidateTexFuncLevel(\"framebufferTextureLayer\", textarget, level))\n      return;\n  }\n\n  WebGLFramebuffer* framebuffer_binding = GetFramebufferBinding(target);\n  if (!framebuffer_binding || !framebuffer_binding->Object()) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"framebufferTextureLayer\",\n                      \"no framebuffer bound\");\n    return;\n  }\n  framebuffer_binding->SetAttachmentForBoundFramebuffer(\n      target, attachment, textarget, texture, level, layer);\n  ApplyStencilTest();\n}\n",
        "output": "0",
        "index": 146094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}\n",
        "output": "0",
        "index": 55582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rawv6_mh_filter_unregister(mh_filter_t filter)\n{\n\tRCU_INIT_POINTER(mh_filter, NULL);\n\tsynchronize_rcu();\n\treturn 0;\n}\n",
        "output": "0",
        "index": 40204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mark_page_dirty(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot;\n\n\tmemslot = gfn_to_memslot(kvm, gfn);\n\tmark_page_dirty_in_slot(kvm, memslot, gfn);\n}\n",
        "output": "0",
        "index": 20414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CreateContextMenuDownload(int render_process_id,\n                               int render_view_id,\n                               const content::ContextMenuParams& params,\n                               bool is_link,\n                               const std::string& extra_headers,\n                               bool granted) {\n  if (!granted)\n    return;\n\n  content::WebContents* web_contents =\n      GetWebContents(render_process_id, render_view_id);\n  if (!web_contents)\n    return;\n\n  const GURL& url = is_link ? params.link_url : params.src_url;\n  const GURL& referring_url =\n      params.frame_url.is_empty() ? params.page_url : params.frame_url;\n  content::DownloadManager* dlm =\n      content::BrowserContext::GetDownloadManager(\n          web_contents->GetBrowserContext());\n  std::unique_ptr<content::DownloadUrlParameters> dl_params(\n      content::DownloadUrlParameters::CreateForWebContentsMainFrame(\n          web_contents, url));\n  content::Referrer referrer = content::Referrer::SanitizeForRequest(\n      url,\n      content::Referrer(referring_url.GetAsReferrer(), params.referrer_policy));\n  dl_params->set_referrer(referrer);\n  if (is_link)\n    dl_params->set_referrer_encoding(params.frame_charset);\n  net::HttpRequestHeaders headers;\n  headers.AddHeadersFromString(extra_headers);\n  for (net::HttpRequestHeaders::Iterator it(headers); it.GetNext();)\n    dl_params->add_request_header(it.name(), it.value());\n  if (!is_link && extra_headers.empty())\n    dl_params->set_prefer_cache(true);\n  dl_params->set_prompt(false);\n  dlm->DownloadUrl(std::move(dl_params));\n}\n",
        "output": "0",
        "index": 137609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t mptsas_diag_read(void *opaque, hwaddr addr,\n                                   unsigned size)\n{\n    MPTSASState *s = opaque;\n    trace_mptsas_diag_read(s, addr, 0);\n    return 0;\n}\n",
        "output": "0",
        "index": 8355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayer::setPlaybackSettings(const AudioPlaybackRate& rate)\n{\n    ALOGV(\"setPlaybackSettings: %f %f %d %d\",\n            rate.mSpeed, rate.mPitch, rate.mFallbackMode, rate.mStretchMode);\n if (rate.mSpeed < 0.f || rate.mPitch < 0.f) {\n return BAD_VALUE;\n }\n Mutex::Autolock _l(mLock);\n if (mPlayer == 0) return INVALID_OPERATION;\n status_t err = mPlayer->setPlaybackSettings(rate);\n if (err == OK) {\n if (rate.mSpeed == 0.f && mCurrentState == MEDIA_PLAYER_STARTED) {\n            mCurrentState = MEDIA_PLAYER_PAUSED;\n } else if (rate.mSpeed != 0.f && mCurrentState == MEDIA_PLAYER_PAUSED) {\n            mCurrentState = MEDIA_PLAYER_STARTED;\n }\n }\n return err;\n}\n",
        "output": "0",
        "index": 172687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " views::MenuButton* TranslateInfoBarBase::CreateMenuButton(\n    const string16& text,\n    bool normal_has_border,\n    views::ViewMenuDelegate* menu_delegate) {\n  views::MenuButton* menu_button =\n      new views::MenuButton(NULL, std::wstring(), menu_delegate, true);\n  menu_button->set_border(new InfoBarButtonBorder);\n  menu_button->set_menu_marker(ResourceBundle::GetSharedInstance().\n      GetBitmapNamed(IDR_INFOBARBUTTON_MENU_DROPARROW));\n  if (normal_has_border) {\n    menu_button->SetNormalHasBorder(true);  // Normal button state has border.\n    menu_button->SetAnimationDuration(0);\n  }\n  menu_button->SetEnabledColor(SK_ColorBLACK);\n  menu_button->SetHighlightColor(SK_ColorBLACK);\n  menu_button->SetHoverColor(SK_ColorBLACK);\n\n  menu_button->SetFont(ResourceBundle::GetSharedInstance().GetFont(\n      ResourceBundle::MediumFont));\n  menu_button->SetText(UTF16ToWideHack(text));\n  menu_button->ClearMaxTextSize();\n  menu_button->SizeToPreferredSize();\n  return menu_button;\n}\n",
        "output": "0",
        "index": 107967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Handle<v8::Context> V8DOMWrapper::getWrapperContext(Frame* frame)\n{\n    v8::Handle<v8::Context> context = V8Proxy::context(frame);\n    if (context.IsEmpty())\n        return v8::Handle<v8::Context>();\n\n    if (V8IsolatedWorld* world = V8IsolatedWorld::getEntered()) {\n       context = world->context();\n       if (frame != V8Proxy::retrieveFrame(context))\n          return v8::Handle<v8::Context>();\n    }\n\n    return context;\n}\n",
        "output": "0",
        "index": 99192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnFocusedElementChangedInFrame(\n    RenderFrameHostImpl* frame,\n    const gfx::Rect& bounds_in_root_view) {\n  RenderWidgetHostViewBase* root_view =\n      static_cast<RenderWidgetHostViewBase*>(GetRenderWidgetHostView());\n  if (!root_view || !frame->GetView())\n    return;\n\n  gfx::Point origin = bounds_in_root_view.origin();\n  origin += root_view->GetViewBounds().OffsetFromOrigin();\n  gfx::Rect bounds_in_screen(origin, bounds_in_root_view.size());\n\n  root_view->FocusedNodeChanged(frame->has_focused_editable_element(),\n                                bounds_in_screen);\n\n  FocusedNodeDetails details = {frame->has_focused_editable_element(),\n                                bounds_in_screen};\n\n  NotificationService::current()->Notify(\n      NOTIFICATION_FOCUS_CHANGED_IN_PAGE,\n      Source<RenderViewHost>(GetRenderViewHost()),\n      Details<FocusedNodeDetails>(&details));\n}\n",
        "output": "0",
        "index": 148481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static zend_object_value spl_object_storage_clone(zval *zobject TSRMLS_DC)\n{\n\tzend_object_value new_obj_val;\n\tzend_object *old_object;\n\tzend_object *new_object;\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tspl_SplObjectStorage *intern;\n\n\told_object = zend_objects_get_address(zobject TSRMLS_CC);\n\tnew_obj_val = spl_object_storage_new_ex(old_object->ce, &intern, zobject TSRMLS_CC);\n\tnew_object = &intern->std;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\treturn new_obj_val;\n}\n",
        "output": "0",
        "index": 12428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    ~InstallPromptPermissions() {\n}\n",
        "output": "0",
        "index": 144400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rdpsnd_init_packet(uint8 type, uint16 size)\n{\n\tSTREAM s;\n\n\ts = channel_init(rdpsnd_channel, size + 4);\n\tout_uint8(s, type);\n\tout_uint8(s, 0);\t/* protocol-mandated padding */\n\tout_uint16_le(s, size);\n\treturn s;\n}\n",
        "output": "0",
        "index": 93062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct station_info sinfo;\n\tint err = 0;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t/* check if STA exists already */\n\tif (sta_info_get_bss(sdata, sta->sta.addr)) {\n\t\terr = -EEXIST;\n\t\tgoto out_err;\n\t}\n\n\t/* notify driver */\n\terr = sta_info_insert_drv_state(local, sdata, sta);\n\tif (err)\n\t\tgoto out_err;\n\n\tlocal->num_sta++;\n\tlocal->sta_generation++;\n\tsmp_mb();\n\n\t/* make the station visible */\n\tsta_info_hash_add(local, sta);\n\n\tlist_add_rcu(&sta->list, &local->sta_list);\n\n\tset_sta_flag(sta, WLAN_STA_INSERTED);\n\n\tieee80211_recalc_min_chandef(sdata);\n\tieee80211_sta_debugfs_add(sta);\n\trate_control_add_sta_debugfs(sta);\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tsinfo.filled = 0;\n\tsinfo.generation = local->sta_generation;\n\tcfg80211_new_sta(sdata->dev, sta->sta.addr, &sinfo, GFP_KERNEL);\n\n\tsta_dbg(sdata, \"Inserted STA %pM\\n\", sta->sta.addr);\n\n\t/* move reference to rcu-protected */\n\trcu_read_lock();\n\tmutex_unlock(&local->sta_mtx);\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_accept_plinks_update(sdata);\n\n\treturn 0;\n out_err:\n\tmutex_unlock(&local->sta_mtx);\n\trcu_read_lock();\n\treturn err;\n}\n",
        "output": "0",
        "index": 38563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InProcessBrowserTest::TearDown() {\n  DCHECK(!g_browser_process);\n#if defined(OS_WIN)\n  com_initializer_.reset();\n#endif\n  BrowserTestBase::TearDown();\n}\n",
        "output": "0",
        "index": 118682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cipso_v4_doi_free(struct cipso_v4_doi *doi_def)\n{\n\tif (doi_def == NULL)\n\t\treturn;\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tkfree(doi_def->map.std->lvl.cipso);\n\t\tkfree(doi_def->map.std->lvl.local);\n\t\tkfree(doi_def->map.std->cat.cipso);\n\t\tkfree(doi_def->map.std->cat.local);\n\t\tbreak;\n\t}\n\tkfree(doi_def);\n}\n",
        "output": "0",
        "index": 18815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string ProfileDependencyManager::DumpGraphvizDependency() {\n  std::string result(\"digraph {\\n\");\n\n  std::deque<ProfileKeyedBaseFactory*> components;\n  std::copy(all_components_.begin(),\n            all_components_.end(),\n            std::back_inserter(components));\n\n  std::deque<ProfileKeyedBaseFactory*>::iterator components_end =\n      components.end();\n  result.append(\"  /* Dependencies */\\n\");\n  for (EdgeMap::const_iterator it = edges_.begin(); it != edges_.end(); ++it) {\n    result.append(\"  \");\n    result.append(it->second->name());\n    result.append(\" -> \");\n    result.append(it->first->name());\n    result.append(\";\\n\");\n\n    components_end = std::remove(components.begin(), components_end,\n                                 it->second);\n  }\n  components.erase(components_end, components.end());\n\n  result.append(\"\\n  /* Toplevel attachments */\\n\");\n  for (std::deque<ProfileKeyedBaseFactory*>::const_iterator it =\n           components.begin(); it != components.end(); ++it) {\n    result.append(\"  \");\n    result.append((*it)->name());\n    result.append(\" -> Profile;\\n\");\n  }\n\n  result.append(\"\\n  /* Toplevel profile */\\n\");\n  result.append(\"  Profile [shape=box];\\n\");\n\n  result.append(\"}\\n\");\n  return result;\n}\n",
        "output": "0",
        "index": 122070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PrintPreviewDialogController::ForEachPreviewDialog(\n    base::Callback<void(content::WebContents*)> callback) {\n  for (PrintPreviewDialogMap::const_iterator it = preview_dialog_map_.begin();\n       it != preview_dialog_map_.end();\n       ++it) {\n    callback.Run(it->first);\n  }\n}\n",
        "output": "0",
        "index": 137661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int bat_socket_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\n\tpoll_wait(file, &socket_client->queue_wait, wait);\n\n\tif (socket_client->queue_len > 0)\n\t\treturn POLLIN | POLLRDNORM;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 34604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IndexedDBDatabase::SendObservations(\n    std::map<int32_t, blink::mojom::IDBObserverChangesPtr> changes_map) {\n  for (auto* conn : connections_) {\n    auto it = changes_map.find(conn->id());\n    if (it != changes_map.end())\n      conn->callbacks()->OnDatabaseChange(std::move(it->second));\n  }\n}\n",
        "output": "0",
        "index": 164658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OfflinePageModelImpl::DoDeletePagesByOfflineId(\n    const std::vector<int64_t>& offline_ids,\n    const DeletePageCallback& callback) {\n  DCHECK(is_loaded_);\n\n  std::vector<base::FilePath> paths_to_delete;\n  for (const auto& offline_id : offline_ids) {\n    auto iter = offline_pages_.find(offline_id);\n    if (iter != offline_pages_.end()) {\n      paths_to_delete.push_back(iter->second.file_path);\n    }\n  }\n\n  if (paths_to_delete.empty()) {\n    InformDeletePageDone(callback, DeletePageResult::SUCCESS);\n    return;\n  }\n\n  archive_manager_->DeleteMultipleArchives(\n      paths_to_delete,\n      base::Bind(&OfflinePageModelImpl::OnDeleteArchiveFilesDone,\n                 weak_ptr_factory_.GetWeakPtr(), offline_ids, callback));\n}\n",
        "output": "0",
        "index": 169047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderThreadImpl::RegisterPendingRenderFrameConnect(\n    int routing_id,\n    mojo::ScopedMessagePipeHandle handle) {\n  std::pair<std::map<int, mojo::MessagePipeHandle>::iterator, bool> result =\n      pending_render_frame_connects_.insert(\n          std::make_pair(routing_id, handle.release()));\n  CHECK(result.second) << \"Inserting a duplicate item.\";\n}\n",
        "output": "0",
        "index": 119423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserTitlebar::ExecuteCommand(int command_id) {\n  if (command_id == kShowWindowDecorationsCommand) {\n    PrefService* prefs = browser_window_->browser()->profile()->GetPrefs();\n    prefs->SetBoolean(prefs::kUseCustomChromeFrame,\n                  !prefs->GetBoolean(prefs::kUseCustomChromeFrame));\n    return;\n  }\n\n  browser_window_->browser()->ExecuteCommand(command_id);\n}\n",
        "output": "0",
        "index": 100554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BackendImpl::RunTaskForTest(const base::Closure& task,\n                                const CompletionCallback& callback) {\n  background_queue_.RunTask(task, callback);\n  return net::ERR_IO_PENDING;\n}\n",
        "output": "0",
        "index": 160085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AudioNode::disconnect(unsigned output_index,\n                           ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  BaseAudioContext::GraphAutoLocker locker(context());\n\n  if (output_index >= numberOfOutputs()) {\n    exception_state.ThrowDOMException(\n        kIndexSizeError,\n        ExceptionMessages::IndexOutsideRange(\n            \"output index\", output_index, 0u,\n            ExceptionMessages::kInclusiveBound, numberOfOutputs() - 1,\n            ExceptionMessages::kInclusiveBound));\n    return;\n  }\n  DisconnectAllFromOutput(output_index);\n}\n",
        "output": "0",
        "index": 161655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipx_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc;\n\n\tlock_sock(sk);\n\trc = __ipx_bind(sock, uaddr, addr_len);\n\trelease_sock(sk);\n\n\treturn rc;\n}\n",
        "output": "0",
        "index": 40418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfs4_open_delegation_recall(struct nfs_open_context *ctx, struct nfs4_state *state, const nfs4_stateid *stateid)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tint err;\n\tdo {\n\t\terr = _nfs4_open_delegation_recall(ctx, state, stateid);\n\t\tswitch (err) {\n\t\t\tcase 0:\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\t/* Don't recall a delegation if it was lost */\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\t\t/*\n\t\t\t\t * The show must go on: exit, but mark the\n\t\t\t\t * stateid as needing recovery.\n\t\t\t\t */\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\t\tnfs_inode_find_state_and_recover(state->inode,\n\t\t\t\t\t\tstateid);\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\t/*\n\t\t\t\t * User RPCSEC_GSS context has expired.\n\t\t\t\t * We cannot recover this stateid now, so\n\t\t\t\t * skip it and allow recovery thread to\n\t\t\t\t * proceed.\n\t\t\t\t */\n\t\t\tcase -ENOMEM:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}\n",
        "output": "0",
        "index": 19944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool MaybeRunCallback() {\n    if (wait_for_copy_result || !display_did_finish_frame)\n      return false;\n    callback.Run(has_damage, main_frame_content_updated, std::move(bitmap));\n    return true;\n  }\n",
        "output": "0",
        "index": 137761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get8_packet_raw(vorb *f)\n{\n   if (!f->bytes_in_seg) {  // CLANG!\n      if (f->last_seg) return EOP;\n      else if (!next_segment(f)) return EOP;\n   }\n   assert(f->bytes_in_seg > 0);\n   --f->bytes_in_seg;\n   ++f->packet_bytes;\n   return get8(f);\n}\n",
        "output": "0",
        "index": 75263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LayerTreeHost::ApplyScrollAndScale(const ScrollAndScaleSet& info) {\n  if (!root_layer_.get())\n    return;\n\n  gfx::Vector2d inner_viewport_scroll_delta;\n  gfx::Vector2d outer_viewport_scroll_delta;\n\n  for (size_t i = 0; i < info.scrolls.size(); ++i) {\n    Layer* layer =\n        LayerTreeHostCommon::FindLayerInSubtree(root_layer_.get(),\n                                                info.scrolls[i].layer_id);\n    if (!layer)\n      continue;\n    if (layer == outer_viewport_scroll_layer_.get()) {\n      outer_viewport_scroll_delta += info.scrolls[i].scroll_delta;\n    } else if (layer == inner_viewport_scroll_layer_.get()) {\n      inner_viewport_scroll_delta += info.scrolls[i].scroll_delta;\n    } else {\n      layer->SetScrollOffsetFromImplSide(layer->scroll_offset() +\n                                         info.scrolls[i].scroll_delta);\n    }\n  }\n\n  if (!inner_viewport_scroll_delta.IsZero() ||\n      !outer_viewport_scroll_delta.IsZero() || info.page_scale_delta != 1.f) {\n\n    DCHECK(inner_viewport_scroll_layer_);  // We should always have this.\n\n    inner_viewport_scroll_layer_->SetScrollOffsetFromImplSide(\n        inner_viewport_scroll_layer_->scroll_offset() +\n        inner_viewport_scroll_delta);\n    if (outer_viewport_scroll_layer_) {\n      outer_viewport_scroll_layer_->SetScrollOffsetFromImplSide(\n          outer_viewport_scroll_layer_->scroll_offset() +\n          outer_viewport_scroll_delta);\n    }\n    ApplyPageScaleDeltaFromImplSide(info.page_scale_delta);\n\n    client_->ApplyScrollAndScale(\n        inner_viewport_scroll_delta + outer_viewport_scroll_delta,\n        info.page_scale_delta);\n   }\n }\n",
        "output": "0",
        "index": 120203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void OverloadedPerWorldBindingsMethod2MethodForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"overloadedPerWorldBindingsMethod\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  int32_t long_arg;\n  long_arg = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->overloadedPerWorldBindingsMethod(long_arg);\n}\n",
        "output": "0",
        "index": 147665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOLEAN btif_hl_create_socket(UINT8 app_idx, UINT8 mcl_idx, UINT8 mdl_idx){\n btif_hl_mcl_cb_t *p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);\n btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);\n btif_hl_soc_cb_t *p_scb = NULL;\n    BOOLEAN               status = FALSE;\n\n    BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);\n\n if (p_dcb && ((p_scb = (btif_hl_soc_cb_t *)GKI_getbuf((UINT16)sizeof(btif_hl_soc_cb_t)))!=NULL))\n {\n if (socketpair(AF_UNIX, SOCK_STREAM, 0, p_scb->socket_id) >= 0)\n {\n            BTIF_TRACE_DEBUG(\"socket id[0]=%d id[1]=%d\",p_scb->socket_id[0], p_scb->socket_id[1] );\n            p_dcb->p_scb = p_scb;\n            p_scb->app_idx = app_idx;\n            p_scb->mcl_idx = mcl_idx;\n            p_scb->mdl_idx = mdl_idx;\n            p_scb->channel_id = p_dcb->channel_id;\n            p_scb->mdep_cfg_idx = p_dcb->local_mdep_cfg_idx;\n            memcpy(p_scb->bd_addr, p_mcb->bd_addr,sizeof(BD_ADDR));\n            btif_hl_set_socket_state(p_scb,  BTIF_HL_SOC_STATE_W4_ADD);\n            p_scb->max_s = p_scb->socket_id[1];\n            list_append(soc_queue, (void *)p_scb);\n            btif_hl_select_wakeup();\n            status = TRUE;\n }\n else\n {\n\n            btif_hl_free_buf((void **)&p_scb);\n }\n }\n\n    BTIF_TRACE_DEBUG(\"%s status=%d\", __FUNCTION__, status);\n return status;\n}\n",
        "output": "0",
        "index": 171842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_vm_readpage(\n\tstruct file\t\t*unused,\n\tstruct page\t\t*page)\n{\n\ttrace_xfs_vm_readpage(page->mapping->host, 1);\n\treturn mpage_readpage(page, xfs_get_blocks);\n}\n",
        "output": "0",
        "index": 93971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lockd_inetaddr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct sockaddr_in sin;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nlmsvc_rqst) {\n\t\tdprintk(\"lockd_inetaddr_event: removed %pI4\\n\",\n\t\t\t&ifa->ifa_local);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = ifa->ifa_local;\n\t\tsvc_age_temp_xprts_now(nlmsvc_rqst->rq_server,\n\t\t\t(struct sockaddr *)&sin);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n",
        "output": "0",
        "index": 65202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    bool lastChildIsSelfCollapsingBlockWithClearance() const { return m_lastChildIsSelfCollapsingBlockWithClearance; }\n",
        "output": "0",
        "index": 132079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntRect RenderBox::reflectedRect(const IntRect& r) const\n{\n    if (!style()->boxReflect())\n        return IntRect();\n\n    IntRect box = borderBoxRect();\n    IntRect result = r;\n    switch (style()->boxReflect()->direction()) {\n        case ReflectionBelow:\n            result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));\n            break;\n        case ReflectionAbove:\n            result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));\n            break;\n        case ReflectionLeft:\n            result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));\n            break;\n        case ReflectionRight:\n            result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));\n            break;\n    }\n    return result;\n}\n",
        "output": "0",
        "index": 106918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ignoreSectionProcessor(XML_Parser parser,\n                       const char *start,\n                       const char *end,\n                       const char **endPtr)\n{\n  enum XML_Error result = doIgnoreSection(parser, parser->m_encoding, &start, end,\n                                          endPtr, (XML_Bool)!parser->m_parsingStatus.finalBuffer);\n  if (result != XML_ERROR_NONE)\n    return result;\n  if (start) {\n    parser->m_processor = prologProcessor;\n    return prologProcessor(parser, start, end, endPtr);\n  }\n  return result;\n}\n",
        "output": "0",
        "index": 92340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::didEndDocument()\n{\n    m_isLoadingMainResource = false;\n}\n",
        "output": "0",
        "index": 108245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static GURL ToAndFromOriginIdentifier(const GURL origin_url) {\n  string16 id = DatabaseUtil::GetOriginIdentifier(origin_url);\n   return DatabaseUtil::GetOriginFromIdentifier(id);\n }\n",
        "output": "0",
        "index": 125265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtnet_busy_poll(struct napi_struct *napi)\n{\n\tstruct receive_queue *rq =\n\t\tcontainer_of(napi, struct receive_queue, napi);\n\tstruct virtnet_info *vi = rq->vq->vdev->priv;\n\tint r, received = 0, budget = 4;\n\n\tif (!(vi->status & VIRTIO_NET_S_LINK_UP))\n\t\treturn LL_FLUSH_FAILED;\n\n\tif (!napi_schedule_prep(napi))\n\t\treturn LL_FLUSH_BUSY;\n\n\tvirtqueue_disable_cb(rq->vq);\n\nagain:\n\treceived += virtnet_receive(rq, budget);\n\n\tr = virtqueue_enable_cb_prepare(rq->vq);\n\tclear_bit(NAPI_STATE_SCHED, &napi->state);\n\tif (unlikely(virtqueue_poll(rq->vq, r)) &&\n\t    napi_schedule_prep(napi)) {\n\t\tvirtqueue_disable_cb(rq->vq);\n\t\tif (received < budget) {\n\t\t\tbudget -= received;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t__napi_schedule(napi);\n\t\t}\n\t}\n\n\treturn received;\n}\n",
        "output": "0",
        "index": 42988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::didChangeLoadProgress(double load_progress) {\n  render_view_->FrameDidChangeLoadProgress(frame_, load_progress);\n}\n",
        "output": "0",
        "index": 118491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n",
        "output": "0",
        "index": 39835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const AtomicString& DOMWindow::InterfaceName() const {\n  return EventTargetNames::DOMWindow;\n}\n",
        "output": "0",
        "index": 160906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ldb_dn_replace_components(struct ldb_dn *dn, struct ldb_dn *new_dn)\n{\n\tint i;\n\n\tif ( ! ldb_dn_validate(dn) || ! ldb_dn_validate(new_dn)) {\n\t\treturn false;\n\t}\n\n\t/* free components */\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tLDB_FREE(dn->components[i].name);\n\t\tLDB_FREE(dn->components[i].value.data);\n\t\tLDB_FREE(dn->components[i].cf_name);\n\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t}\n\n\tdn->components = talloc_realloc(dn,\n\t\t\t\t\tdn->components,\n\t\t\t\t\tstruct ldb_dn_component,\n\t\t\t\t\tnew_dn->comp_num);\n\tif (dn->components == NULL) {\n\t\tldb_dn_mark_invalid(dn);\n\t\treturn false;\n\t}\n\n\tdn->comp_num = new_dn->comp_num;\n\tdn->valid_case = new_dn->valid_case;\n\n\tfor (i = 0; i < dn->comp_num; i++) {\n\t\tdn->components[i] = ldb_dn_copy_component(dn->components, &new_dn->components[i]);\n\t\tif (dn->components[i].name == NULL) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (new_dn->linearized == NULL) {\n\t\tdn->linearized = NULL;\n\t} else {\n\t\tdn->linearized = talloc_strdup(dn, new_dn->linearized);\n\t\tif (dn->linearized == NULL) {\n\t\t\tldb_dn_mark_invalid(dn);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n",
        "output": "0",
        "index": 2360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_stream_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t size, int flags)\n{\n\tstruct unix_stream_read_state state = {\n\t\t.recv_actor = unix_stream_read_actor,\n\t\t.socket = sock,\n\t\t.msg = msg,\n\t\t.size = size,\n\t\t.flags = flags\n\t};\n\n\treturn unix_stream_read_generic(&state);\n}\n",
        "output": "0",
        "index": 46548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  IsMacResource( FT_Library  library,\n                 FT_Stream   stream,\n                 FT_Long     resource_offset,\n                 FT_Long     face_index,\n                 FT_Face    *aface )\n  {\n    FT_Memory  memory = library->memory;\n    FT_Error   error;\n    FT_Long    map_offset, rdara_pos;\n    FT_Long    *data_offsets;\n    FT_Long    count;\n\n\n    error = FT_Raccess_Get_HeaderInfo( library, stream, resource_offset,\n                                       &map_offset, &rdara_pos );\n    if ( error )\n      return error;\n\n    error = FT_Raccess_Get_DataOffsets( library, stream,\n                                        map_offset, rdara_pos,\n                                        TTAG_POST,\n                                        &data_offsets, &count );\n    if ( !error )\n    {\n      error = Mac_Read_POST_Resource( library, stream, data_offsets, count,\n                                      face_index, aface );\n      FT_FREE( data_offsets );\n      /* POST exists in an LWFN providing a single face */\n      if ( !error )\n        (*aface)->num_faces = 1;\n      return error;\n    }\n\n    error = FT_Raccess_Get_DataOffsets( library, stream,\n                                        map_offset, rdara_pos,\n                                        TTAG_sfnt,\n                                        &data_offsets, &count );\n    if ( !error )\n    {\n      FT_Long  face_index_internal = face_index % count;\n\n\n      error = Mac_Read_sfnt_Resource( library, stream, data_offsets, count,\n                                      face_index_internal, aface );\n      FT_FREE( data_offsets );\n      if ( !error )\n        (*aface)->num_faces = count;\n    }\n\n    return error;\n  }\n",
        "output": "0",
        "index": 10274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pci_ers_result_t tg3_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct tg3 *tp = netdev_priv(netdev);\n\tpci_ers_result_t rc = PCI_ERS_RESULT_DISCONNECT;\n\tint err;\n\n\trtnl_lock();\n\n\tif (pci_enable_device(pdev)) {\n\t\tnetdev_err(netdev, \"Cannot re-enable PCI device after reset.\\n\");\n\t\tgoto done;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tif (!netif_running(netdev)) {\n\t\trc = PCI_ERS_RESULT_RECOVERED;\n\t\tgoto done;\n\t}\n\n\terr = tg3_power_up(tp);\n\tif (err)\n\t\tgoto done;\n\n\trc = PCI_ERS_RESULT_RECOVERED;\n\ndone:\n\trtnl_unlock();\n\n\treturn rc;\n}\n",
        "output": "0",
        "index": 32600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(strcoll)\n{\n\tzend_string *s1, *s2;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"SS\", &s1, &s2) == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(strcoll((const char *) ZSTR_VAL(s1),\n\t                    (const char *) ZSTR_VAL(s2)));\n}\n",
        "output": "0",
        "index": 14606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcUnmapSubwindows(ClientPtr client)\n{\n    WindowPtr pWin;\n\n    REQUEST(xResourceReq);\n    int rc;\n\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);\n    if (rc != Success)\n        return rc;\n    UnmapSubwindows(pWin);\n    return Success;\n}\n",
        "output": "0",
        "index": 15022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ClearLoader() {\n    loader_ = nullptr;\n    script_state_ = nullptr;\n  }\n",
        "output": "0",
        "index": 160289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sco_sock_close(struct sock *sk)\n{\n\tsco_sock_clear_timer(sk);\n\tlock_sock(sk);\n\t__sco_sock_close(sk);\n\trelease_sock(sk);\n\tsco_sock_kill(sk);\n}\n",
        "output": "0",
        "index": 27745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebContentsImpl::IsFullscreenForCurrentTab() const {\n  return delegate_ ? delegate_->IsFullscreenForTabOrPending(this) : false;\n}\n",
        "output": "0",
        "index": 118949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void handleMetaReferrer(const String& attributeValue, CachedDocumentParameters* documentParameters, CSSPreloadScanner* cssScanner)\n {\n    if (attributeValue.isEmpty() || attributeValue.isNull() || !SecurityPolicy::referrerPolicyFromString(attributeValue, &documentParameters->referrerPolicy)) {\n        documentParameters->referrerPolicy = ReferrerPolicyDefault;\n     }\n     cssScanner->setReferrerPolicy(documentParameters->referrerPolicy);\n }\n",
        "output": "1",
        "index": 186070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool mount_too_revealing(struct vfsmount *mnt, int *new_mnt_flags)\n{\n\tconst unsigned long required_iflags = SB_I_NOEXEC | SB_I_NODEV;\n\tstruct mnt_namespace *ns = current->nsproxy->mnt_ns;\n\tunsigned long s_iflags;\n\n\tif (ns->user_ns == &init_user_ns)\n\t\treturn false;\n\n\t/* Can this filesystem be too revealing? */\n\ts_iflags = mnt->mnt_sb->s_iflags;\n\tif (!(s_iflags & SB_I_USERNS_VISIBLE))\n\t\treturn false;\n\n\tif ((s_iflags & required_iflags) != required_iflags) {\n\t\tWARN_ONCE(1, \"Expected s_iflags to contain 0x%lx\\n\",\n\t\t\t  required_iflags);\n\t\treturn true;\n\t}\n\n\treturn !mnt_already_visible(ns, mnt, new_mnt_flags);\n}\n",
        "output": "0",
        "index": 50968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadUserLogFileState::convertState(\n\tconst ReadUserLog::FileState\t\t\t\t&state,\n\tconst ReadUserLogFileState::FileStatePub\t*&pub )\n{\n\tpub = (const ReadUserLogFileState::FileStatePub *) state.buf;\n\treturn true;\n}\n",
        "output": "0",
        "index": 16650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   FakePluginServiceFilter() {}\n",
        "output": "0",
        "index": 125105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "raptor_turtle_writer_get_option_string(raptor_turtle_writer *turtle_writer, \n                                        raptor_option option)\n{\n  return NULL;\n}\n",
        "output": "0",
        "index": 22062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MngInfo *MngInfoFreeStruct(MngInfo *mng_info)\n{\n  register ssize_t\n    i;\n\n  if (mng_info == (MngInfo *) NULL)\n    return((MngInfo *) NULL);\n\n  for (i=1; i < MNG_MAX_OBJECTS; i++)\n    MngInfoDiscardObject(mng_info,i);\n\n  mng_info->global_plte=(png_colorp)\n    RelinquishMagickMemory(mng_info->global_plte);\n\n  return((MngInfo *) RelinquishMagickMemory(mng_info));\n}\n",
        "output": "0",
        "index": 77941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~ScopedExtensionPrefUpdate() {\n    prefs_->ScheduleSavePersistentPrefs();\n  }\n",
        "output": "0",
        "index": 102345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(pg_escape_bytea)\n{\n\tchar *from = NULL, *to = NULL;\n\tsize_t to_len;\n\tint from_len, id = -1;\n#ifdef HAVE_PQESCAPE_BYTEA_CONN\n\tPGconn *pgsql;\n#endif\n\tzval *pgsql_link;\n\n\tswitch (ZEND_NUM_ARGS()) {\n\t\tcase 1:\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &from, &from_len) == FAILURE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpgsql_link = NULL;\n\t\t\tid = PGG(default_link);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &pgsql_link, &from, &from_len) == FAILURE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n#ifdef HAVE_PQESCAPE_BYTEA_CONN\n\tif (pgsql_link != NULL || id != -1) {\n\t\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\t\tto = (char *)PQescapeByteaConn(pgsql, (unsigned char *)from, (size_t)from_len, &to_len);\n\t} else\n#endif\n\t\tto = (char *)PQescapeBytea((unsigned char*)from, from_len, &to_len);\n\n\tRETVAL_STRINGL(to, to_len-1, 1); /* to_len includes addtional '\\0' */\n\tPQfreemem(to);\n}\n",
        "output": "0",
        "index": 14751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gcm_hash_len(struct aead_request *req,\n\t\t\tstruct crypto_gcm_req_priv_ctx *pctx)\n{\n\tstruct ahash_request *ahreq = &pctx->u.ahreq;\n\tstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\n\tu128 lengths;\n\n\tlengths.a = cpu_to_be64(req->assoclen * 8);\n\tlengths.b = cpu_to_be64(gctx->cryptlen * 8);\n\tmemcpy(pctx->iauth_tag, &lengths, 16);\n\tsg_init_one(pctx->src, pctx->iauth_tag, 16);\n\tahash_request_set_callback(ahreq, aead_request_flags(req),\n\t\t\t\t   gcm_hash_len_done, req);\n\tahash_request_set_crypt(ahreq, pctx->src,\n\t\t\t\tNULL, sizeof(lengths));\n\n\treturn crypto_ahash_update(ahreq);\n}\n",
        "output": "0",
        "index": 45780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_message_send_receipt(const char *const fulljid, const char *const message_id)\n{\n    xmpp_ctx_t * const ctx = connection_get_ctx();\n\n    char *id = create_unique_id(\"receipt\");\n    xmpp_stanza_t *message = xmpp_message_new(ctx, NULL, fulljid, id);\n    free(id);\n\n    xmpp_stanza_t *receipt = xmpp_stanza_new(ctx);\n    xmpp_stanza_set_name(receipt, \"received\");\n    xmpp_stanza_set_ns(receipt, STANZA_NS_RECEIPTS);\n    xmpp_stanza_set_id(receipt, message_id);\n\n    xmpp_stanza_add_child(message, receipt);\n    xmpp_stanza_release(receipt);\n\n    _send_message_stanza(message);\n    xmpp_stanza_release(message);\n}\n",
        "output": "0",
        "index": 68662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ void isdn_net_device_stop_queue(isdn_net_local *lp)\n{\n\tif (lp->master)\n\t\tnetif_stop_queue(lp->master);\n\telse\n\t\tnetif_stop_queue(lp->netdev->dev);\n}\n",
        "output": "0",
        "index": 23635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int test_rshift1(BIO *bp)\n{\n    BIGNUM *a, *b, *c;\n    int i;\n\n    a = BN_new();\n    b = BN_new();\n    c = BN_new();\n\n    BN_bntest_rand(a, 200, 0, 0);\n    a->neg = rand_neg();\n    for (i = 0; i < num0; i++) {\n        BN_rshift1(b, a);\n        if (bp != NULL) {\n            if (!results) {\n                BN_print(bp, a);\n                BIO_puts(bp, \" / 2\");\n                BIO_puts(bp, \" - \");\n            }\n            BN_print(bp, b);\n            BIO_puts(bp, \"\\n\");\n        }\n        BN_sub(c, a, b);\n        BN_sub(c, c, b);\n        if (!BN_is_zero(c) && !BN_abs_is_word(c, 1)) {\n            fprintf(stderr, \"Right shift one test failed!\\n\");\n            return 0;\n        }\n        BN_copy(a, b);\n    }\n    BN_free(a);\n    BN_free(b);\n    BN_free(c);\n    return (1);\n}\n",
        "output": "0",
        "index": 3668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void callbackFunctionAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectV8Internal::callbackFunctionAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 130666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}\n",
        "output": "1",
        "index": 180905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vblur(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize,\n                  int w, int h, int radius, int power, uint8_t *temp[2])\n{\n    int x;\n\n    if (radius == 0 && dst == src)\n        return;\n\n    for (x = 0; x < w; x++)\n        blur_power(dst + x, dst_linesize, src + x, src_linesize,\n                   h, radius, power, temp);\n}\n",
        "output": "0",
        "index": 29723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CL_Disconnect_f( void ) {\n\tSCR_StopCinematic();\n\tCvar_Set(\"ui_singlePlayerActive\", \"0\");\n\tif ( clc.state != CA_DISCONNECTED && clc.state != CA_CINEMATIC ) {\n\t\tCom_Error (ERR_DISCONNECT, \"Disconnected from server\");\n\t}\n}\n",
        "output": "0",
        "index": 95957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HRESULT CGaiaCredentialBase::Initialize(IGaiaCredentialProvider* provider) {\n  LOGFN(INFO);\n  DCHECK(provider);\n\n  provider_ = provider;\n  return S_OK;\n}\n",
        "output": "0",
        "index": 142070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    AVIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    avio_read(pb, cmov_data, cmov_len);\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n        goto free_and_return;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n",
        "output": "0",
        "index": 54512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool GesturePoint::IsOverMinFlickSpeed() {\n  return velocity_calculator_.VelocitySquared() > kMinFlickSpeedSquared;\n }\n",
        "output": "1",
        "index": 184737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 37250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vrrp_vip_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_vip, vector_slot(strvec, 0));\n}\n",
        "output": "0",
        "index": 76050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DiskCacheBackendTest::BackendCalculateSizeOfAllEntries() {\n  InitCache();\n\n  EXPECT_EQ(0, CalculateSizeOfAllEntries());\n\n  std::set<std::string> key_pool;\n  CreateSetOfRandomEntries(&key_pool);\n\n  int count = 0;\n  int total_size = 0;\n  for (std::string key : key_pool) {\n    std::string data(count, ' ');\n    scoped_refptr<net::StringIOBuffer> buffer = new net::StringIOBuffer(data);\n\n    disk_cache::Entry* entry;\n    ASSERT_THAT(OpenEntry(key, &entry), IsOk());\n    ASSERT_EQ(count, WriteData(entry, count % 2, 0, buffer.get(), count, true));\n    entry->Close();\n\n    total_size += GetRoundedSize(count + GetEntryMetadataSize(key));\n    ++count;\n  }\n\n  int result = CalculateSizeOfAllEntries();\n  EXPECT_EQ(total_size, result);\n\n  {\n    const int last_entry_size = 47;\n    std::string data(last_entry_size, ' ');\n    scoped_refptr<net::StringIOBuffer> buffer = new net::StringIOBuffer(data);\n\n    disk_cache::Entry* entry;\n    std::string key = GenerateKey(true);\n    ASSERT_THAT(CreateEntry(key, &entry), IsOk());\n    ASSERT_EQ(last_entry_size,\n              WriteData(entry, 0, 0, buffer.get(), last_entry_size, true));\n    entry->Close();\n\n    int new_result = CalculateSizeOfAllEntries();\n    EXPECT_EQ(\n        result + GetRoundedSize(last_entry_size + GetEntryMetadataSize(key)),\n        new_result);\n\n    DoomEntry(key);\n    new_result = CalculateSizeOfAllEntries();\n    EXPECT_EQ(result, new_result);\n  }\n\n  ASSERT_THAT(DoomAllEntries(), IsOk());\n  EXPECT_EQ(0, CalculateSizeOfAllEntries());\n}\n",
        "output": "0",
        "index": 159954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::UnlockMouse() {\n  event_handler_->UnlockMouse();\n}\n",
        "output": "0",
        "index": 144992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XFixesDestroyRegion (Display *dpy, XserverRegion region)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesDestroyRegionReq\t*req;\n\n    XFixesSimpleCheckExtension (dpy, info);\n    LockDisplay (dpy);\n    GetReq (XFixesDestroyRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesDestroyRegion;\n    req->region = region;\n    UnlockDisplay (dpy);\n    SyncHandle();\n}\n",
        "output": "0",
        "index": 8307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n    if (pages_[page_index]->GetPage() == page)\n      return page_index;\n  }\n  return -1;\n}\n",
        "output": "0",
        "index": 153049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SchedulerObject::remove(std::string key, std::string &reason, std::string &text)\n {\n        PROC_ID id = getProcByString(key.c_str());\n       if (id.cluster < 0 || id.proc < 0) {\n                dprintf(D_FULLDEBUG, \"Remove: Failed to parse id: %s\\n\", key.c_str());\n                text = \"Invalid Id\";\n                return false;\n\t}\n\n\tif (!abortJob(id.cluster,\n\t\t\t\t  id.proc,\n\t\t\t\t  reason.c_str(),\n\t\t\t\t  true // Always perform within a transaction\n\t\t\t\t  )) {\n\t\ttext = \"Failed to remove job\";\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "output": "1",
        "index": 178006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Plugin::LoadNaClModule(nacl::DescWrapper* wrapper,\n                            ErrorInfo* error_info,\n                            pp::CompletionCallback init_done_cb,\n                            pp::CompletionCallback crash_cb) {\n  ShutDownSubprocesses();\n  if (!LoadNaClModuleCommon(wrapper, &main_subprocess_, manifest_.get(),\n                            true, error_info, init_done_cb, crash_cb)) {\n    return false;\n  }\n  PLUGIN_PRINTF((\"Plugin::LoadNaClModule (%s)\\n\",\n                 main_subprocess_.detailed_description().c_str()));\n  return true;\n }\n",
        "output": "0",
        "index": 110317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)\n{\n\tstruct kmem_cache_node *n;\n\n\t/*\n\t * Set up the kmem_cache_node for cpu before we can\n\t * begin anything. Make sure some other cpu on this\n\t * node has not already allocated this\n\t */\n\tn = get_node(cachep, node);\n\tif (n) {\n\t\tspin_lock_irq(&n->list_lock);\n\t\tn->free_limit = (1 + nr_cpus_node(node)) * cachep->batchcount +\n\t\t\t\tcachep->num;\n\t\tspin_unlock_irq(&n->list_lock);\n\n\t\treturn 0;\n\t}\n\n\tn = kmalloc_node(sizeof(struct kmem_cache_node), gfp, node);\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\tkmem_cache_node_init(n);\n\tn->next_reap = jiffies + REAPTIMEOUT_NODE +\n\t\t    ((unsigned long)cachep) % REAPTIMEOUT_NODE;\n\n\tn->free_limit =\n\t\t(1 + nr_cpus_node(node)) * cachep->batchcount + cachep->num;\n\n\t/*\n\t * The kmem_cache_nodes don't come and go as CPUs\n\t * come and go.  slab_mutex is sufficient\n\t * protection here.\n\t */\n\tcachep->node[node] = n;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 68890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ft_smooth_render( FT_Renderer       render,\n                    FT_GlyphSlot      slot,\n                    FT_Render_Mode    mode,\n                    const FT_Vector*  origin )\n  {\n    if ( mode == FT_RENDER_MODE_LIGHT )\n      mode = FT_RENDER_MODE_NORMAL;\n\n    return ft_smooth_render_generic( render, slot, mode, origin,\n                                     FT_RENDER_MODE_NORMAL );\n  }\n",
        "output": "0",
        "index": 4202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPagePrivate::setTextReflowAnchorPoint(const Platform::IntPoint& documentFocalPoint)\n{\n    ASSERT(m_webPage->settings()->textReflowMode() == WebSettings::TextReflowEnabled);\n\n    m_currentPinchZoomNode = bestNodeForZoomUnderPoint(documentFocalPoint);\n    if (!m_currentPinchZoomNode)\n        return;\n\n    IntRect nodeRect = rectForNode(m_currentPinchZoomNode.get());\n    m_anchorInNodeRectRatio.set(\n        static_cast<float>(documentFocalPoint.x() - nodeRect.x()) / nodeRect.width(),\n        static_cast<float>(documentFocalPoint.y() - nodeRect.y()) / nodeRect.height());\n}\n",
        "output": "0",
        "index": 111370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool DataReductionProxyConfigServiceClient::RemoteConfigApplied() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return remote_config_applied_;\n}\n",
        "output": "0",
        "index": 150584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   virtual bool SetImeConfig(const std::string& section,\n                             const std::string& config_name,\n                            const ImeConfigValue& value) {\n     return false;\n   }\n",
        "output": "1",
        "index": 183963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int afiucv_netdev_event(struct notifier_block *this,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *event_dev = netdev_notifier_info_to_dev(ptr);\n\tstruct sock *sk;\n\tstruct iucv_sock *iucv;\n\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\tcase NETDEV_GOING_DOWN:\n\t\tsk_for_each(sk, &iucv_sk_list.head) {\n\t\t\tiucv = iucv_sk(sk);\n\t\t\tif ((iucv->hs_dev == event_dev) &&\n\t\t\t    (sk->sk_state == IUCV_CONNECTED)) {\n\t\t\t\tif (event == NETDEV_GOING_DOWN)\n\t\t\t\t\tiucv_send_ctrl(sk, AF_IUCV_FLAG_FIN);\n\t\t\t\tsk->sk_state = IUCV_DISCONN;\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\tcase NETDEV_UNREGISTER:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n",
        "output": "0",
        "index": 40471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebMediaPlayerImpl::DidPassCORSAccessCheck() const {\n  if (data_source_)\n    return data_source_->DidPassCORSAccessCheck();\n  return false;\n }\n",
        "output": "1",
        "index": 186608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    virtual ~CookieRetriever() {}\n",
        "output": "0",
        "index": 161365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BubbleManager::BubbleManager() : manager_state_(SHOW_BUBBLES) {}\n",
        "output": "0",
        "index": 168188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestNavigationManager::OnNavigationStateChanged() {\n  if (current_state_ >= desired_state_) {\n    if (loop_runner_)\n      loop_runner_->Quit();\n    return;\n  }\n\n  if (navigation_paused_)\n    handle_->CallResumeForTesting();\n}\n",
        "output": "0",
        "index": 169284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionSettingsHandler::MaybeRegisterForNotifications() {\n  if (registered_for_notifications_)\n    return;\n\n  registered_for_notifications_  = true;\n  Profile* profile = Profile::FromWebUI(web_ui());\n\n  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_LOADED,\n                 content::Source<Profile>(profile));\n  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UNLOADED,\n                 content::Source<Profile>(profile));\n  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_UPDATE_DISABLED,\n                 content::Source<Profile>(profile));\n  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_WARNING_CHANGED,\n                 content::Source<Profile>(profile));\n  registrar_.Add(this, chrome::NOTIFICATION_EXTENSION_HOST_CREATED,\n                 content::NotificationService::AllBrowserContextsAndSources());\n  registrar_.Add(this,\n                 content::NOTIFICATION_RENDER_VIEW_HOST_CREATED,\n                 content::NotificationService::AllBrowserContextsAndSources());\n  registrar_.Add(this,\n                 content::NOTIFICATION_RENDER_VIEW_HOST_DELETED,\n                 content::NotificationService::AllBrowserContextsAndSources());\n  registrar_.Add(this,\n                 chrome::NOTIFICATION_BACKGROUND_CONTENTS_NAVIGATED,\n                 content::NotificationService::AllBrowserContextsAndSources());\n  registrar_.Add(this,\n                 chrome::NOTIFICATION_BACKGROUND_CONTENTS_DELETED,\n                 content::NotificationService::AllBrowserContextsAndSources());\n  registrar_.Add(\n      this,\n      chrome::NOTIFICATION_EXTENSION_BROWSER_ACTION_VISIBILITY_CHANGED,\n      content::Source<ExtensionPrefs>(profile->GetExtensionService()->\n                             extension_prefs()));\n}\n",
        "output": "0",
        "index": 116074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control |= CPU_BASED_MOV_DR_EXITING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n}\n",
        "output": "0",
        "index": 37312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Match(IMkvReader* pReader, long long& pos, unsigned long expected_id,\n unsigned char*& buf, size_t& buflen) {\n if (!pReader || pos < 0)\n return false;\n\n long long total = 0;\n long long available = 0;\n\n long status = pReader->Length(&total, &available);\n if (status < 0 || (total >= 0 && available > total))\n return false;\n\n long len = 0;\n const long long id = ReadID(pReader, pos, len);\n if (id < 0 || (available - pos) > len)\n return false;\n\n if (static_cast<unsigned long>(id) != expected_id)\n return false;\n\n  pos += len; // consume id\n\n const long long size = ReadUInt(pReader, pos, len);\n if (size < 0 || len <= 0 || len > 8 || (available - pos) > len)\n return false;\n\n unsigned long long rollover_check =\n static_cast<unsigned long long>(pos) + len;\n if (rollover_check > LONG_LONG_MAX)\n return false;\n\n  pos += len; // consume length of size of payload\n\n  rollover_check = static_cast<unsigned long long>(pos) + size;\n if (rollover_check > LONG_LONG_MAX)\n return false;\n\n if ((pos + size) > available)\n return false;\n\n if (size >= LONG_MAX)\n return false;\n\n const long buflen_ = static_cast<long>(size);\n\n  buf = SafeArrayAlloc<unsigned char>(1, buflen_);\n if (!buf)\n return false;\n\n  status = pReader->Read(pos, buflen_, buf);\n if (status != 0)\n return false;\n\n  buflen = buflen_;\n\n  pos += size; // consume size of payload\n return true;\n}\n",
        "output": "0",
        "index": 177437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sp<MetaData> AudioSource::getFormat() {\n Mutex::Autolock autoLock(mLock);\n if (mInitCheck != OK) {\n return 0;\n }\n\n    sp<MetaData> meta = new MetaData;\n    meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);\n    meta->setInt32(kKeySampleRate, mSampleRate);\n    meta->setInt32(kKeyChannelCount, mRecord->channelCount());\n    meta->setInt32(kKeyMaxInputSize, kMaxBufferSize);\n\n return meta;\n}\n",
        "output": "0",
        "index": 173698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wc_ecc_sign_hash_hw(const byte* in, word32 inlen,\n    mp_int* r, mp_int* s, byte* out, word32 *outlen, WC_RNG* rng,\n    ecc_key* key)\n{\n    int err;\n\n#ifdef PLUTON_CRYPTO_ECC\n    if (key->devId != INVALID_DEVID) /* use hardware */\n#endif\n    {\n        int keysize = key->dp->size;\n\n        /* Check args */\n        if (keysize > ECC_MAX_CRYPTO_HW_SIZE || inlen != keysize ||\n                                                *outlen < keysize*2) {\n            return ECC_BAD_ARG_E;\n        }\n\n    #if defined(WOLFSSL_ATECC508A)\n        /* Sign: Result is 32-bytes of R then 32-bytes of S */\n        err = atcatls_sign(key->slot, in, out);\n        if (err != ATCA_SUCCESS) {\n           return BAD_COND_E;\n        }\n    #elif defined(PLUTON_CRYPTO_ECC)\n        {\n            /* perform ECC sign */\n            word32 raw_sig_size = *outlen;\n            err = Crypto_EccSign(in, inlen, out, &raw_sig_size);\n            if (err != CRYPTO_RES_SUCCESS || raw_sig_size != keysize*2){\n               return BAD_COND_E;\n            }\n        }\n    #endif\n\n        /* Load R and S */\n        err = mp_read_unsigned_bin(r, &out[0], keysize);\n        if (err != MP_OKAY) {\n            return err;\n        }\n        err = mp_read_unsigned_bin(s, &out[keysize], keysize);\n        if (err != MP_OKAY) {\n            return err;\n        }\n\n        /* Check for zeros */\n        if (mp_iszero(r) || mp_iszero(s)) {\n            return MP_ZERO_E;\n        }\n    }\n#ifdef PLUTON_CRYPTO_ECC\n    else {\n        err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);\n    }\n#endif\n\n    return err;\n}\n",
        "output": "0",
        "index": 81929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Splash::vertFlipImage(SplashBitmap *img, int width, int height,\n\t\t\t   int nComps) {\n  Guchar *lineBuf;\n  Guchar *p0, *p1;\n  int w;\n  \n  if (unlikely(img->data == NULL)) {\n    error(errInternal, -1, \"img->data is NULL in Splash::vertFlipImage\");\n    return;\n  }\n\n  w = width * nComps;\n  lineBuf = (Guchar *)gmalloc(w);\n  for (p0 = img->data, p1 = img->data + (height - 1) * w;\n       p0 < p1;\n       p0 += w, p1 -= w) {\n    memcpy(lineBuf, p0, w);\n    memcpy(p0, p1, w);\n    memcpy(p1, lineBuf, w);\n  }\n  if (img->alpha) {\n    for (p0 = img->alpha, p1 = img->alpha + (height - 1) * width;\n\t p0 < p1;\n\t p0 += width, p1 -= width) {\n      memcpy(lineBuf, p0, width);\n      memcpy(p0, p1, width);\n      memcpy(p1, lineBuf, width);\n    }\n  }\n  gfree(lineBuf);\n}\n",
        "output": "0",
        "index": 4168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "entry_guards_free_all(void)\n{\n  /* Null out the default */\n  curr_guard_context = NULL;\n  /* Free all the guard contexts */\n  if (guard_contexts != NULL) {\n    SMARTLIST_FOREACH_BEGIN(guard_contexts, guard_selection_t *, gs) {\n      guard_selection_free(gs);\n    } SMARTLIST_FOREACH_END(gs);\n    smartlist_free(guard_contexts);\n    guard_contexts = NULL;\n  }\n  circuit_build_times_free_timeouts(get_circuit_build_times_mutable());\n}\n",
        "output": "0",
        "index": 69689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int snd_seq_client_notify_subscription(int client, int port,\n\t\t\t\t       struct snd_seq_port_subscribe *info,\n\t\t\t\t       int evtype)\n{\n\tstruct snd_seq_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.type = evtype;\n\tevent.data.connect.dest = info->dest;\n\tevent.data.connect.sender = info->sender;\n\n\treturn snd_seq_system_notify(client, port, &event);  /* non-atomic */\n}\n",
        "output": "0",
        "index": 54683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TabContentsWrapper* TabStripModel::DetachTabContentsAt(int index) {\n  if (contents_data_.empty())\n    return NULL;\n\n  DCHECK(ContainsIndex(index));\n\n  TabContentsWrapper* removed_contents = GetContentsAt(index);\n  int next_selected_index = order_controller_->DetermineNewSelectedIndex(index);\n  delete contents_data_.at(index);\n  contents_data_.erase(contents_data_.begin() + index);\n  ForgetOpenersAndGroupsReferencing(&(removed_contents->controller()));\n  if (empty())\n    closing_all_ = true;\n  FOR_EACH_OBSERVER(TabStripModelObserver, observers_,\n      TabDetachedAt(removed_contents, index));\n  if (empty()) {\n    FOR_EACH_OBSERVER(TabStripModelObserver, observers_, TabStripEmpty());\n  } else {\n    int old_active = active_index();\n    selection_model_.DecrementFrom(index);\n    if (index == old_active) {\n      if (!selection_model_.empty()) {\n        selection_model_.set_active(selection_model_.selected_indices()[0]);\n        selection_model_.set_anchor(selection_model_.active());\n        NotifyTabSelectedIfChanged(removed_contents, active_index(), false);\n      } else {\n        selection_model_.SetSelectedIndex(next_selected_index);\n        NotifyTabSelectedIfChanged(removed_contents, next_selected_index,\n                                   false);\n      }\n    }\n  }\n  return removed_contents;\n}\n",
        "output": "0",
        "index": 102954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,\n\t\t\t       struct drm_display_mode *in)\n{\n\tout->clock = in->clock;\n\tout->hdisplay = in->hdisplay;\n\tout->hsync_start = in->hsync_start;\n\tout->hsync_end = in->hsync_end;\n\tout->htotal = in->htotal;\n\tout->hskew = in->hskew;\n\tout->vdisplay = in->vdisplay;\n\tout->vsync_start = in->vsync_start;\n\tout->vsync_end = in->vsync_end;\n\tout->vtotal = in->vtotal;\n\tout->vscan = in->vscan;\n\tout->vrefresh = in->vrefresh;\n\tout->flags = in->flags;\n\tout->type = in->type;\n\tstrncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);\n\tout->name[DRM_DISPLAY_MODE_LEN-1] = 0;\n}\n",
        "output": "0",
        "index": 21865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int bitmap_position_extended(const unsigned char *sha1)\n{\n\tkhash_sha1_pos *positions = bitmap_git.ext_index.positions;\n\tkhiter_t pos = kh_get_sha1_pos(positions, sha1);\n\n\tif (pos < kh_end(positions)) {\n\t\tint bitmap_pos = kh_value(positions, pos);\n\t\treturn bitmap_pos + bitmap_git.pack->num_objects;\n\t}\n\n\treturn -1;\n}\n",
        "output": "0",
        "index": 54923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool nfs4_roc(struct inode *inode)\n{\n\tif (!nfs_have_layout(inode))\n\t\treturn false;\n\treturn pnfs_roc(inode);\n}\n",
        "output": "0",
        "index": 57235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::didFocus() {\n  if (webview() && webview()->mainFrame() &&\n      webview()->mainFrame()->isProcessingUserGesture()) {\n    Send(new ViewHostMsg_Focus(routing_id_));\n  }\n}\n",
        "output": "0",
        "index": 103890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int br_ip4_multicast_igmp3_report(struct net_bridge *br,\n\t\t\t\t\t struct net_bridge_port *port,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct igmpv3_report *ih;\n\tstruct igmpv3_grec *grec;\n\tint i;\n\tint len;\n\tint num;\n\tint type;\n\tint err = 0;\n\t__be32 group;\n\tu16 vid = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(*ih)))\n\t\treturn -EINVAL;\n\n\tbr_vlan_get_tag(skb, &vid);\n\tih = igmpv3_report_hdr(skb);\n\tnum = ntohs(ih->ngrec);\n\tlen = sizeof(*ih);\n\n\tfor (i = 0; i < num; i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tgroup = grec->grec_mca;\n\t\ttype = grec->grec_type;\n\n\t\tlen += ntohs(grec->grec_nsrcs) * 4;\n\t\tif (!pskb_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\n\t\t/* We treat this as an IGMPv2 report for now. */\n\t\tswitch (type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = br_ip4_multicast_add_group(br, port, group, vid);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 29991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void JSArray::copyToRegisters(ExecState* exec, Register* buffer, uint32_t maxSize)\n{\n    ASSERT(m_storage->m_length >= maxSize);\n    UNUSED_PARAM(maxSize);\n    WriteBarrier<Unknown>* vector = m_storage->m_vector;\n    unsigned vectorEnd = min(maxSize, m_vectorLength);\n    unsigned i = 0;\n    for (; i < vectorEnd; ++i) {\n        WriteBarrier<Unknown>& v = vector[i];\n        if (!v)\n            break;\n        buffer[i] = v.get();\n    }\n\n    for (; i < maxSize; ++i)\n        buffer[i] = get(exec, i);\n}\n",
        "output": "0",
        "index": 107423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLenum GLES2DecoderImpl::GetBoundDrawFrameBufferInternalFormat() {\n  FramebufferManager::FramebufferInfo* framebuffer =\n      GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER_EXT);\n  if (framebuffer != NULL) {\n    return framebuffer->GetColorAttachmentFormat();\n  } else if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_target_color_format_;\n  } else {\n    return back_buffer_color_format_;\n  }\n}\n",
        "output": "0",
        "index": 110541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CSSStyleSheet* CSSStyleSheet::CreateInline(Node& owner_node,\n                                           const KURL& base_url,\n                                           const TextPosition& start_position,\n                                            const WTF::TextEncoding& encoding) {\n   CSSParserContext* parser_context = CSSParserContext::Create(\n       owner_node.GetDocument(), owner_node.GetDocument().BaseURL(),\n       owner_node.GetDocument().GetReferrerPolicy(), encoding);\n   StyleSheetContents* sheet =\n       StyleSheetContents::Create(base_url.GetString(), parser_context);\n  return new CSSStyleSheet(sheet, owner_node, true, start_position);\n}\n",
        "output": "1",
        "index": 187138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "newSWFInput_input(SWFInput in, unsigned int length)\n{\n\tSWFInput input;\n\tstruct SWFInputPtr *data;\n\n\tif (in == NULL)\n\t\treturn NULL;\n\n\tinput = (SWFInput)malloc(sizeof(struct SWFInput_s));\n\n\t/* If malloc failed, return NULL to signify this */\n\tif (NULL == input)\n\t\treturn NULL;\n\n\tinput->getChar = SWFInput_input_getChar;\n\tinput->destroy = SWFInput_input_dtor;\n\tinput->eof = SWFInput_input_eof;\n\tinput->read = SWFInput_input_read;\n\tinput->seek = SWFInput_input_seek;\n\n\tdata = (struct SWFInputPtr *)malloc(sizeof(struct SWFInputPtr));\n\n\t/* If malloc failed, free memory allocated for input and return NULL to signify the failure */\n\tif (NULL == data)\n\t{\n\t\tfree(input);\n\t\treturn NULL;\n\t}\n\n\tdata->offset = SWFInput_tell(in);\n\tdata->input = in;\n\n\tinput->offset = 0;\n\tinput->length = length;\n\n\tinput->data = (void *)data;\n\tinput->buffer = 0;\n\tinput->bufbits = 0;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\n\treturn input;\n}\n",
        "output": "0",
        "index": 89581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "filesystem_mount_data_free (MountData *data)\n{\n  g_free (data->mount_point);\n  g_free (data);\n}\n",
        "output": "0",
        "index": 11700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\treturn ret;\n}\n",
        "output": "0",
        "index": 57376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ptrace_peek_siginfo(struct task_struct *child,\n\t\t\t\tunsigned long addr,\n\t\t\t\tunsigned long data)\n{\n\tstruct ptrace_peeksiginfo_args arg;\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint ret, i;\n\n\tret = copy_from_user(&arg, (void __user *) addr,\n\t\t\t\tsizeof(struct ptrace_peeksiginfo_args));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (arg.flags & ~PTRACE_PEEKSIGINFO_SHARED)\n\t\treturn -EINVAL; /* unknown flags */\n\n\tif (arg.nr < 0)\n\t\treturn -EINVAL;\n\n\t/* Ensure arg.off fits in an unsigned long */\n\tif (arg.off > ULONG_MAX)\n\t\treturn 0;\n\n\tif (arg.flags & PTRACE_PEEKSIGINFO_SHARED)\n\t\tpending = &child->signal->shared_pending;\n\telse\n\t\tpending = &child->pending;\n\n\tfor (i = 0; i < arg.nr; ) {\n\t\tkernel_siginfo_t info;\n\t\tunsigned long off = arg.off + i;\n\t\tbool found = false;\n\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tlist_for_each_entry(q, &pending->list, list) {\n\t\t\tif (!off--) {\n\t\t\t\tfound = true;\n\t\t\t\tcopy_siginfo(&info, &q->info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\n\t\tif (!found) /* beyond the end of the list */\n\t\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\t\tif (unlikely(in_compat_syscall())) {\n\t\t\tcompat_siginfo_t __user *uinfo = compat_ptr(data);\n\n\t\t\tif (copy_siginfo_to_user32(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else\n#endif\n\t\t{\n\t\t\tsiginfo_t __user *uinfo = (siginfo_t __user *) data;\n\n\t\t\tif (copy_siginfo_to_user(uinfo, &info)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(siginfo_t);\n\t\ti++;\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (i > 0)\n\t\treturn i;\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 89070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_port_status(struct usb_device *hdev, int port1,\n\t\tstruct usb_port_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port1,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n",
        "output": "0",
        "index": 56739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ut8 getsib(const ut8 sib) {\n\tif (!sib) {\n\t\treturn 0;\n\t}\n\treturn (sib & 0x8) ? 3 : getsib ((sib << 1) | 1) - 1;\n}\n",
        "output": "0",
        "index": 75372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t\tvoid CWebServer::RestoreDatabase(WebEmSession & session, const request& req, std::string & redirect_uri)\n\t\t{\n\t\t\tredirect_uri = \"/index.html\";\n\t\t\tif (session.rights != 2)\n\t\t\t{\n\t\t\t\tsession.reply_status = reply::forbidden;\n\t\t\t\treturn; //Only admin user allowed\n\t\t\t}\n\n\t\t\tstd::string dbasefile = request::findValue(&req, \"dbasefile\");\n\t\t\tif (dbasefile.empty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tm_mainworker.StopDomoticzHardware();\n\n\t\t\tm_sql.RestoreDatabase(dbasefile);\n\t\t\tm_mainworker.AddAllDomoticzHardware();\n\t\t}\n",
        "output": "0",
        "index": 91073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_msnd_initialize(struct snd_card *card)\n{\n\tstruct snd_msnd *chip = card->private_data;\n\tint err, timeout;\n\n#ifdef MSND_CLASSIC\n\toutb(HPWAITSTATE_0, chip->io + HP_WAIT);\n\toutb(HPBITMODE_16, chip->io + HP_BITM);\n\n\treset_proteus(chip);\n#endif\n\terr = snd_msnd_init_sma(chip);\n\tif (err < 0) {\n\t\tprintk(KERN_WARNING LOGNAME \": Cannot initialize SMA\\n\");\n\t\treturn err;\n\t}\n\n\terr = snd_msnd_reset_dsp(chip->io, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = upload_dsp_code(card);\n\tif (err < 0) {\n\t\tprintk(KERN_WARNING LOGNAME \": Cannot upload DSP code\\n\");\n\t\treturn err;\n\t}\n\n\ttimeout = 200;\n\n\twhile (readw(chip->mappedbase)) {\n\t\tmsleep(1);\n\t\tif (!timeout--) {\n\t\t\tsnd_printd(KERN_ERR LOGNAME \": DSP reset timeout\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tsnd_msndmix_setup(chip);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 64117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "db_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n",
        "output": "0",
        "index": 33592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_global_data(data_t * data)\n{\n\tif (!data)\n\t\treturn;\n\n\tfree_list(&data->email);\n#if HAVE_DECL_CLONE_NEWNET\n\tFREE_PTR(data->network_namespace);\n#endif\n\tFREE_PTR(data->instance_name);\n\tFREE_PTR(data->router_id);\n\tFREE_PTR(data->email_from);\n\tFREE_PTR(data->smtp_helo_name);\n\tFREE_PTR(data->local_name);\n#ifdef _WITH_SNMP_\n\tFREE_PTR(data->snmp_socket);\n#endif\n#if defined _WITH_LVS_ && defined _WITH_VRRP_\n\tFREE_PTR(data->lvs_syncd.ifname);\n\tFREE_PTR(data->lvs_syncd.vrrp_name);\n#endif\n\tFREE_PTR(data->notify_fifo.name);\n\tfree_notify_script(&data->notify_fifo.script);\n#ifdef _WITH_VRRP_\n\tFREE_PTR(data->default_ifname);\n\tFREE_PTR(data->vrrp_notify_fifo.name);\n\tfree_notify_script(&data->vrrp_notify_fifo.script);\n#endif\n#ifdef _WITH_LVS_\n\tFREE_PTR(data->lvs_notify_fifo.name);\n\tfree_notify_script(&data->lvs_notify_fifo.script);\n#endif\n\tFREE(data);\n}\n",
        "output": "0",
        "index": 75799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int netlink_unicast(struct sock *ssk, struct sk_buff *skb,\n\t\t    u32 pid, int nonblock)\n{\n\tstruct sock *sk;\n\tint err;\n\tlong timeo;\n\n\tskb = netlink_trim(skb, gfp_any());\n\n\ttimeo = sock_sndtimeo(ssk, nonblock);\nretry:\n\tsk = netlink_getsockbypid(ssk, pid);\n\tif (IS_ERR(sk)) {\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(sk);\n\t}\n\tif (netlink_is_kernel(sk))\n\t\treturn netlink_unicast_kernel(sk, skb);\n\n\tif (sk_filter(sk, skb)) {\n\t\terr = skb->len;\n\t\tkfree_skb(skb);\n\t\tsock_put(sk);\n\t\treturn err;\n\t}\n\n\terr = netlink_attachskb(sk, skb, &timeo, ssk);\n\tif (err == 1)\n\t\tgoto retry;\n\tif (err)\n\t\treturn err;\n\n\treturn netlink_sendskb(sk, skb);\n}\n",
        "output": "0",
        "index": 19261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QuotaManager::GetCachedOrigins(\n    StorageType type, std::set<GURL>* origins) {\n  DCHECK(origins);\n  LazyInitialize();\n  switch (type) {\n    case kStorageTypeTemporary:\n      DCHECK(temporary_usage_tracker_.get());\n      temporary_usage_tracker_->GetCachedOrigins(origins);\n      return;\n    case kStorageTypePersistent:\n      DCHECK(persistent_usage_tracker_.get());\n      persistent_usage_tracker_->GetCachedOrigins(origins);\n      return;\n    default:\n      NOTREACHED();\n  }\n}\n",
        "output": "0",
        "index": 101017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewHostImpl::SynchronousFind(int request_id,\n                                         const string16& search_text,\n                                         const WebKit::WebFindOptions& options,\n                                         int* match_count,\n                                         int* active_ordinal) {\n  if (!CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableWebViewSynchronousAPIs)) {\n    return;\n  }\n\n  Send(new ViewMsg_SynchronousFind(GetRoutingID(), request_id, search_text,\n                                   options, match_count, active_ordinal));\n}\n",
        "output": "0",
        "index": 125720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err flxs_dump(GF_Box *a, FILE * trace)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox *)a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"AdobeFlashAccessParamsBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tif (ptr->metadata)\n\t\tfprintf(trace, \"<FmrmsV2Metadata=\\\"%s\\\"/>\\n\", ptr->metadata);\n\tgf_isom_box_dump_done(\"AdobeFlashAccessParamsBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPageProxy::backForwardGoToItem(uint64_t itemID)\n{\n    m_backForwardList->goToItem(process()->webBackForwardItem(itemID));\n}\n",
        "output": "0",
        "index": 106436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  DisconnectWindowLinux() {}\n",
        "output": "0",
        "index": 105694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cmp_subprogs(const void *a, const void *b)\n{\n\treturn ((struct bpf_subprog_info *)a)->start -\n\t       ((struct bpf_subprog_info *)b)->start;\n}\n",
        "output": "0",
        "index": 76391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_ttymodes(Ssh ssh,\n                           void (*do_mode)(void *data,\n                                           const struct ssh_ttymode *mode,\n                                           char *val),\n\t\t\t   void *data)\n{\n    int i;\n    const struct ssh_ttymode *mode;\n    char *val;\n    char default_val[2];\n\n    strcpy(default_val, \"A\");\n\n    for (i = 0; i < lenof(ssh_ttymodes); i++) {\n        mode = ssh_ttymodes + i;\n        val = conf_get_str_str_opt(ssh->conf, CONF_ttymodes, mode->mode);\n        if (!val)\n            val = default_val;\n\n\t/*\n\t * val[0] is either 'V', indicating that an explicit value\n\t * follows it, or 'A' indicating that we should pass the\n\t * value through from the local environment via get_ttymode.\n\t */\n\tif (val[0] == 'A') {\n\t    val = get_ttymode(ssh->frontend, mode->mode);\n\t    if (val) {\n\t\tdo_mode(data, mode, val);\n\t\tsfree(val);\n\t    }\n\t} else\n            do_mode(data, mode, val + 1);              /* skip the 'V' */\n    }\n}\n",
        "output": "0",
        "index": 8521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "run_test (const char *test, const char *expected_result, enum url_scheme scheme,\n          bool expected_change)\n{\n  char *test_copy = xstrdup (test);\n  bool modified = path_simplify (scheme, test_copy);\n\n  if (0 != strcmp (test_copy, expected_result))\n    {\n      printf (\"Failed path_simplify(\\\"%s\\\"): expected \\\"%s\\\", got \\\"%s\\\".\\n\",\n              test, expected_result, test_copy);\n      mu_assert (\"\", 0);\n    }\n  if (modified != expected_change)\n    {\n      if (expected_change)\n        printf (\"Expected modification with path_simplify(\\\"%s\\\").\\n\",\n                test);\n      else\n        printf (\"Expected no modification with path_simplify(\\\"%s\\\").\\n\",\n                test);\n    }\n  xfree (test_copy);\n  mu_assert (\"\", modified == expected_change);\n  return NULL;\n}\n",
        "output": "0",
        "index": 8693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fbStore_a1r1g1b1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  pixel;\n        Splita(READ(values + i));\n        pixel = (((a >> 4) & 0x8) |\n                 ((r >> 5) & 0x4) |\n                 ((g >> 6) & 0x2) |\n                 ((b >> 7)      ));\n        Store4(bits, i + x, pixel);\n    }\n}\n",
        "output": "0",
        "index": 11470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayerTreeHostImpl::FrameData::~FrameData() {}\n",
        "output": "0",
        "index": 150081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool venc_dev::venc_get_performance_level(OMX_U32 *perflevel)\n{\n if (!perflevel) {\n        DEBUG_PRINT_ERROR(\"Null pointer error\");\n return false;\n } else {\n *perflevel = performance_level.perflevel;\n return true;\n }\n}\n",
        "output": "0",
        "index": 172437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip_mc_del1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\tint rv = 0;\n\n\tpsf_prev = NULL;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf || psf->sf_count[sfmode] == 0) {\n\t\t/* source filter not found, or count wrong =>  bug */\n\t\treturn -ESRCH;\n\t}\n\tpsf->sf_count[sfmode]--;\n\tif (psf->sf_count[sfmode] == 0) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\tif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct in_device *in_dev = pmc->interface;\n#endif\n\n\t\t/* no more filters for this source */\n\t\tif (psf_prev)\n\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\telse\n\t\t\tpmc->sources = psf->sf_next;\n#ifdef CONFIG_IP_MULTICAST\n\t\tif (psf->sf_oldin &&\n\t\t    !IGMP_V1_SEEN(in_dev) && !IGMP_V2_SEEN(in_dev)) {\n\t\t\tpsf->sf_crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\t\tIGMP_Unsolicited_Report_Count;\n\t\t\tpsf->sf_next = pmc->tomb;\n\t\t\tpmc->tomb = psf;\n\t\t\trv = 1;\n\t\t} else\n#endif\n\t\t\tkfree(psf);\n\t}\n\treturn rv;\n}\n",
        "output": "0",
        "index": 21630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::RenderProcessGone(base::TerminationStatus status,\n                                                 int error_code) {\n  UpdateCursorIfOverSelf();\n  Destroy();\n}\n",
        "output": "0",
        "index": 133010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CreatePrintSettingsDictionary(DictionaryValue* dict) {\n  dict->SetBoolean(printing::kSettingLandscape, false);\n  dict->SetBoolean(printing::kSettingCollate, false);\n  dict->SetInteger(printing::kSettingColor, printing::GRAY);\n  dict->SetBoolean(printing::kSettingPrintToPDF, true);\n  dict->SetInteger(printing::kSettingDuplexMode, printing::SIMPLEX);\n  dict->SetInteger(printing::kSettingCopies, 1);\n  dict->SetString(printing::kSettingDeviceName, \"dummy\");\n  dict->SetString(printing::kPreviewUIAddr, \"0xb33fbeef\");\n  dict->SetInteger(printing::kPreviewRequestID, 12345);\n  dict->SetBoolean(printing::kIsFirstRequest, true);\n  dict->SetBoolean(printing::kSettingDefaultMarginsSelected, true);\n  dict->SetBoolean(printing::kSettingHeaderFooterEnabled, false);\n  dict->SetBoolean(printing::kSettingGenerateDraftData, true);\n}\n",
        "output": "0",
        "index": 101984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *__dentry_path(struct dentry *d, char *buf, int buflen)\n{\n\tstruct dentry *dentry;\n\tchar *end, *retval;\n\tint len, seq = 0;\n\tint error = 0;\n\n\tif (buflen < 2)\n\t\tgoto Elong;\n\n\trcu_read_lock();\nrestart:\n\tdentry = d;\n\tend = buf + buflen;\n\tlen = buflen;\n\tprepend(&end, &len, \"\\0\", 1);\n\t/* Get '/' right */\n\tretval = end-1;\n\t*retval = '/';\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (!IS_ROOT(dentry)) {\n\t\tstruct dentry *parent = dentry->d_parent;\n\n\t\tprefetch(parent);\n\t\terror = prepend_name(&end, &len, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tretval = end;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (error)\n\t\tgoto Elong;\n\treturn retval;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}\n",
        "output": "0",
        "index": 67281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::AcceleratedWidget DesktopWindowTreeHostX11::GetAcceleratedWidget() {\n  return xwindow_;\n}\n",
        "output": "0",
        "index": 153221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BaseArena::sweepUnsweptPage() {\n  BasePage* page = m_firstUnsweptPage;\n  if (page->isEmpty()) {\n    page->unlink(&m_firstUnsweptPage);\n    page->removeFromHeap();\n  } else {\n    page->sweep();\n    page->unlink(&m_firstUnsweptPage);\n    page->link(&m_firstPage);\n    page->markAsSwept();\n  }\n}\n",
        "output": "0",
        "index": 160402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TestWebKitPlatformSupport::sharedWorkerRepository() {\n  return NULL;\n}\n",
        "output": "0",
        "index": 116901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  int last_packet_num() { return last_packet_num_; }\n",
        "output": "0",
        "index": 145439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evdns_base_search_add(struct evdns_base *base, const char *domain) {\n\tEVDNS_LOCK(base);\n\tsearch_postfix_add(base, domain);\n\tEVDNS_UNLOCK(base);\n}\n",
        "output": "0",
        "index": 70594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsWindow::CloseContents(content::WebContents* source) {\n  CHECK(IsDocked());\n  BrowserWindow* inspected_window = GetInspectedBrowserWindow();\n  if (inspected_window)\n    inspected_window->UpdateDevTools();\n  delete web_contents_;\n}\n",
        "output": "0",
        "index": 121390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swap_node(Node* a, Node* b)\n{\n  Node c;\n\n  c = *a; *a = *b; *b = c;\n\n  if (NODE_TYPE(a) == NODE_STRING) {\n    StrNode* sn = STR_(a);\n    if (sn->capacity == 0) {\n      int len = (int )(sn->end - sn->s);\n      sn->s   = sn->buf;\n      sn->end = sn->s + len;\n    }\n  }\n\n  if (NODE_TYPE(b) == NODE_STRING) {\n    StrNode* sn = STR_(b);\n    if (sn->capacity == 0) {\n      int len = (int )(sn->end - sn->s);\n      sn->s   = sn->buf;\n      sn->end = sn->s + len;\n    }\n  }\n}\n",
        "output": "0",
        "index": 89239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ShelfWidget::WillDeleteShelfLayoutManager() {\n  shelf_layout_manager_->RemoveObserver(this);\n  shelf_layout_manager_ = nullptr;\n}\n",
        "output": "0",
        "index": 142576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void packet_finished(UNUSED_ATTR serial_data_type_t type) {\n}\n",
        "output": "0",
        "index": 172120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ServiceManagerConnectionImpl::AddEmbeddedService(\n    const std::string& name,\n    const service_manager::EmbeddedServiceInfo& info) {\n  context_->AddEmbeddedService(name, info);\n}\n",
        "output": "0",
        "index": 138361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RunTaskOnUIThread(const base::Closure& task) {\n  RunTaskOnThread(\n      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::UI), task);\n}\n",
        "output": "0",
        "index": 125461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::DoCommands(unsigned int num_commands,\n                                          const volatile void* buffer,\n                                          int num_entries,\n                                          int* entries_processed) {\n  if (gpu_debug_commands_) {\n    return DoCommandsImpl<true>(\n        num_commands, buffer, num_entries, entries_processed);\n  } else {\n    return DoCommandsImpl<false>(\n        num_commands, buffer, num_entries, entries_processed);\n  }\n}\n",
        "output": "0",
        "index": 153971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Ref(::Cursor cursor) {\n    cache_[cursor]->Ref();\n  }\n",
        "output": "0",
        "index": 127619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n        return xdr_ressize_check(rqstp, p);\n}\n",
        "output": "0",
        "index": 65727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tcpmss_tg6_check(const struct xt_tgchk_param *par)\n{\n\tconst struct xt_tcpmss_info *info = par->targinfo;\n\tconst struct ip6t_entry *e = par->entryinfo;\n\tconst struct xt_entry_match *ematch;\n\n\tif (info->mss == XT_TCPMSS_CLAMP_PMTU &&\n\t    (par->hook_mask & ~((1 << NF_INET_FORWARD) |\n\t\t\t   (1 << NF_INET_LOCAL_OUT) |\n\t\t\t   (1 << NF_INET_POST_ROUTING))) != 0) {\n\t\tpr_info(\"path-MTU clamping only supported in \"\n\t\t\t\"FORWARD, OUTPUT and POSTROUTING hooks\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (par->nft_compat)\n\t\treturn 0;\n\n\txt_ematch_foreach(ematch, e)\n\t\tif (find_syn_match(ematch))\n\t\t\treturn 0;\n\tpr_info(\"Only works on TCP SYN packets\\n\");\n\treturn -EINVAL;\n}\n",
        "output": "0",
        "index": 86260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tnfs4_setup_sequence(NFS_SERVER(data->inode),\n\t\t\t&data->args.seq_args,\n\t\t\t&data->res.seq_res,\n\t\t\ttask);\n}\n",
        "output": "0",
        "index": 57182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\t*err = -EBADF;\n\tfile = fget_light(fd, fput_needed);\n\tif (file) {\n\t\tsock = sock_from_file(file, err);\n\t\tif (sock)\n\t\t\treturn sock;\n\t\tfput_light(file, *fput_needed);\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 18708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL update_send_refresh_rect(rdpContext* context, BYTE count,\n                                     const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n",
        "output": "0",
        "index": 83605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __init shmem_init(void)\n{\n\tBUG_ON(register_filesystem(&shmem_fs_type) != 0);\n\n\tshm_mnt = kern_mount(&shmem_fs_type);\n\tBUG_ON(IS_ERR(shm_mnt));\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 33516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,\n PixelFormat format, uint32_t usage) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());\n        data.writeInt32(static_cast<int32_t>(async));\n        data.writeUint32(width);\n        data.writeUint32(height);\n        data.writeInt32(static_cast<int32_t>(format));\n        data.writeUint32(usage);\n status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);\n if (result != NO_ERROR) {\n            ALOGE(\"allocateBuffers failed to transact: %d\", result);\n }\n }\n",
        "output": "0",
        "index": 174094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __hw_addr_flush(struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha, *tmp;\n\n\tlist_for_each_entry_safe(ha, tmp, &list->list, list) {\n\t\tlist_del_rcu(&ha->list);\n\t\tcall_rcu(&ha->rcu_head, ha_rcu_free);\n\t}\n\tlist->count = 0;\n}\n",
        "output": "0",
        "index": 32072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CameraSource::signalBufferReturned(MediaBuffer *buffer) {\n    ALOGV(\"signalBufferReturned: %p\", buffer->data());\n Mutex::Autolock autoLock(mLock);\n\n     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();\n          it != mFramesBeingEncoded.end(); ++it) {\n         if ((*it)->pointer() ==  buffer->data()) {\n             releaseOneRecordingFrame((*it));\n             mFramesBeingEncoded.erase(it);\n             ++mNumFramesEncoded;\n            buffer->setObserver(0);\n            buffer->release();\n            mFrameCompleteCondition.signal();\n return;\n }\n }\n    CHECK(!\"signalBufferReturned: bogus buffer\");\n}\n",
        "output": "1",
        "index": 187532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChildThread::OnShutdown() {\n  base::MessageLoop::current()->Quit();\n}\n",
        "output": "0",
        "index": 129778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void powermate_pulse_led(struct powermate_device *pm, int static_brightness, int pulse_speed,\n\t\t\t\tint pulse_table, int pulse_asleep, int pulse_awake)\n{\n\tunsigned long flags;\n\n\tif (pulse_speed < 0)\n\t\tpulse_speed = 0;\n\tif (pulse_table < 0)\n\t\tpulse_table = 0;\n\tif (pulse_speed > 510)\n\t\tpulse_speed = 510;\n\tif (pulse_table > 2)\n\t\tpulse_table = 2;\n\n\tpulse_asleep = !!pulse_asleep;\n\tpulse_awake = !!pulse_awake;\n\n\n\tspin_lock_irqsave(&pm->lock, flags);\n\n\t/* mark state updates which are required */\n\tif (static_brightness != pm->static_brightness) {\n\t\tpm->static_brightness = static_brightness;\n\t\tpm->requires_update |= UPDATE_STATIC_BRIGHTNESS;\n\t}\n\tif (pulse_asleep != pm->pulse_asleep) {\n\t\tpm->pulse_asleep = pulse_asleep;\n\t\tpm->requires_update |= (UPDATE_PULSE_ASLEEP | UPDATE_STATIC_BRIGHTNESS);\n\t}\n\tif (pulse_awake != pm->pulse_awake) {\n\t\tpm->pulse_awake = pulse_awake;\n\t\tpm->requires_update |= (UPDATE_PULSE_AWAKE | UPDATE_STATIC_BRIGHTNESS);\n\t}\n\tif (pulse_speed != pm->pulse_speed || pulse_table != pm->pulse_table) {\n\t\tpm->pulse_speed = pulse_speed;\n\t\tpm->pulse_table = pulse_table;\n\t\tpm->requires_update |= UPDATE_PULSE_MODE;\n\t}\n\n\tpowermate_sync_state(pm);\n\n\tspin_unlock_irqrestore(&pm->lock, flags);\n}\n",
        "output": "0",
        "index": 55205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = (char *)wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->int32_sent_bits = *byteptr++;\n    wps->int32_zeros = *byteptr++;\n    wps->int32_ones = *byteptr++;\n    wps->int32_dups = *byteptr;\n\n    return TRUE;\n}\n",
        "output": "0",
        "index": 75630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ReplaceableReadonlyLongAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueInt(info, impl->replaceableReadonlyLongAttribute());\n}\n",
        "output": "0",
        "index": 147791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PageHandler::RenderWidgetHostDestroyed(RenderWidgetHost* widget_host) {\n  observer_.Remove(widget_host);\n}\n",
        "output": "0",
        "index": 156412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ldb_dn_is_special(struct ldb_dn *dn)\n{\n\tif ( ! dn || dn->invalid) return false;\n\treturn dn->special;\n}\n",
        "output": "0",
        "index": 2355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void feh_wm_set_bg_filled(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint img_w, img_h, cut_x;\n\tint render_w, render_h, render_x, render_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\timg_w = gib_imlib_image_get_width(im);\n\timg_h = gib_imlib_image_get_height(im);\n\n\tcut_x = (((img_w * h) > (img_h * w)) ? 1 : 0);\n\n\trender_w = (  cut_x ? ((img_h * w) / h) : img_w);\n\trender_h = ( !cut_x ? ((img_w * h) / w) : img_h);\n\n\trender_x = (  cut_x ? ((img_w - render_w) >> 1) : 0);\n\trender_y = ( !cut_x ? ((img_h - render_h) >> 1) : 0);\n\n\tgib_imlib_render_image_part_on_drawable_at_size(pmap, im,\n\t\trender_x, render_y,\n\t\trender_w, render_h,\n\t\tx, y, w, h,\n\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n",
        "output": "0",
        "index": 66918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool UpdateAccessTimeOnDBThread(const GURL& origin,\n                                StorageType type,\n                                base::Time accessed_time,\n                                QuotaDatabase* database) {\n  DCHECK(database);\n  return database->SetOriginLastAccessTime(origin, type, accessed_time);\n}\n",
        "output": "0",
        "index": 108543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fb_append_extra_logo(const struct linux_logo *logo, unsigned int n)\n{\n\tif (!n || fb_logo_ex_num == FB_LOGO_EX_NUM_MAX)\n\t\treturn;\n\n\tfb_logo_ex[fb_logo_ex_num].logo = logo;\n\tfb_logo_ex[fb_logo_ex_num].n = n;\n\tfb_logo_ex_num++;\n}\n",
        "output": "0",
        "index": 31125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::NotifyScreenInfoChanged() {\n  WebKit::WebScreenInfo screen_info;\n  GetWebScreenInfo(&screen_info);\n  Send(new ViewMsg_ScreenInfoChanged(GetRoutingID(), screen_info));\n}\n",
        "output": "0",
        "index": 122995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n     __asm {\n        rdtsc\n        ret       ; return value at EDX:EAX\n     }\n  }\n",
        "output": "0",
        "index": 148949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void force_user_fault(unsigned long address, int write)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tint code;\n\n\tcode = SEGV_MAPERR;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_vma(mm, address);\n\tif(!vma)\n\t\tgoto bad_area;\n\tif(vma->vm_start <= address)\n\t\tgoto good_area;\n\tif(!(vma->vm_flags & VM_GROWSDOWN))\n\t\tgoto bad_area;\n\tif(expand_stack(vma, address))\n\t\tgoto bad_area;\ngood_area:\n\tcode = SEGV_ACCERR;\n\tif(write) {\n\t\tif(!(vma->vm_flags & VM_WRITE))\n\t\t\tgoto bad_area;\n\t} else {\n\t\tif(!(vma->vm_flags & (VM_READ | VM_EXEC)))\n\t\t\tgoto bad_area;\n\t}\n\tswitch (handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0)) {\n\tcase VM_FAULT_SIGBUS:\n\tcase VM_FAULT_OOM:\n\t\tgoto do_sigbus;\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn;\nbad_area:\n\tup_read(&mm->mmap_sem);\n\t__do_fault_siginfo(code, SIGSEGV, tsk->thread.kregs, address);\n\treturn;\n\ndo_sigbus:\n\tup_read(&mm->mmap_sem);\n\t__do_fault_siginfo(BUS_ADRERR, SIGBUS, tsk->thread.kregs, address);\n}\n",
        "output": "0",
        "index": 25730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "poolCopyString(STRING_POOL *pool, const XML_Char *s) {\n  do {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  } while (*s++);\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}\n",
        "output": "0",
        "index": 88295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PixelBufferRasterWorkerPool::CheckForCompletedRasterTasks() {\n  TRACE_EVENT0(\n      \"cc\", \"PixelBufferRasterWorkerPool::CheckForCompletedRasterTasks\");\n\n  DCHECK(should_notify_client_if_no_tasks_are_pending_);\n\n  check_for_completed_raster_tasks_callback_.Cancel();\n  check_for_completed_raster_tasks_pending_ = false;\n\n  CheckForCompletedWorkerTasks();\n  CheckForCompletedUploads();\n  FlushUploads();\n\n   bool will_notify_client_that_no_tasks_required_for_activation_are_pending =\n       (should_notify_client_if_no_tasks_required_for_activation_are_pending_ &&\n        !HasPendingTasksRequiredForActivation());\n   bool will_notify_client_that_no_tasks_are_pending =\n       (should_notify_client_if_no_tasks_are_pending_ &&\n        !HasPendingTasks());\n \n  should_notify_client_if_no_tasks_required_for_activation_are_pending_ &=\n      !will_notify_client_that_no_tasks_required_for_activation_are_pending;\n  should_notify_client_if_no_tasks_are_pending_ &=\n      !will_notify_client_that_no_tasks_are_pending;\n\n  scheduled_raster_task_count_ = 0;\n  if (PendingRasterTaskCount())\n    ScheduleMoreTasks();\n\n  TRACE_EVENT_ASYNC_STEP_INTO1(\n      \"cc\", \"ScheduledTasks\", this, StateName(),\n      \"state\", TracedValue::FromValue(StateAsValue().release()));\n\n  if (HasPendingTasks())\n    ScheduleCheckForCompletedRasterTasks();\n\n  if (will_notify_client_that_no_tasks_required_for_activation_are_pending) {\n    DCHECK(std::find_if(raster_tasks_required_for_activation().begin(),\n                        raster_tasks_required_for_activation().end(),\n                        WasCanceled) ==\n          raster_tasks_required_for_activation().end());\n    client()->DidFinishRunningTasksRequiredForActivation();\n  }\n  if (will_notify_client_that_no_tasks_are_pending) {\n    TRACE_EVENT_ASYNC_END0(\"cc\", \"ScheduledTasks\", this);\n    DCHECK(!HasPendingTasksRequiredForActivation());\n    client()->DidFinishRunningTasks();\n  }\n}\n",
        "output": "1",
        "index": 184951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ChromeClientImpl* ChromeClientImpl::Create(WebViewImpl* web_view) {\n  return new ChromeClientImpl(web_view);\n}\n",
        "output": "0",
        "index": 160943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tun_set_headroom(struct net_device *dev, int new_hr)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tif (new_hr < NET_SKB_PAD)\n\t\tnew_hr = NET_SKB_PAD;\n\n\ttun->align = new_hr;\n}\n",
        "output": "0",
        "index": 93325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::WasHidden() {\n  if (!host_ || host_->is_hidden())\n    return;\n  host_->WasHidden();\n  software_frame_manager_->SetVisibility(false);\n  delegated_frame_evictor_->SetVisible(false);\n  released_front_lock_ = NULL;\n\n#if defined(OS_WIN)\n  constrained_rects_.clear();\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (dispatcher) {\n    HWND parent = dispatcher->host()->GetAcceleratedWidget();\n    LPARAM lparam = reinterpret_cast<LPARAM>(this);\n\n    EnumChildWindows(parent, HideWindowsCallback, lparam);\n  }\n  if (::IsWindow(plugin_parent_window_))\n    ::SetWindowPos(plugin_parent_window_, NULL, 0, 0, 0, 0, 0);\n#endif\n}\n",
        "output": "0",
        "index": 133055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ap_control_domain_mask_show(struct bus_type *bus, char *buf)\n{\n\tif (ap_configuration != NULL) { /* QCI not supported */\n\t\tif (test_facility(76)) { /* format 1 - 256 bit domain field */\n\t\t\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\t\"0x%08x%08x%08x%08x%08x%08x%08x%08x\\n\",\n\t\t\tap_configuration->adm[0], ap_configuration->adm[1],\n\t\t\tap_configuration->adm[2], ap_configuration->adm[3],\n\t\t\tap_configuration->adm[4], ap_configuration->adm[5],\n\t\t\tap_configuration->adm[6], ap_configuration->adm[7]);\n\t\t} else { /* format 0 - 16 bit domain field */\n\t\t\treturn snprintf(buf, PAGE_SIZE, \"%08x%08x\\n\",\n\t\t\tap_configuration->adm[0], ap_configuration->adm[1]);\n\t\t  }\n\t} else {\n\t\treturn snprintf(buf, PAGE_SIZE, \"not supported\\n\");\n\t  }\n}\n",
        "output": "0",
        "index": 47585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n",
        "output": "0",
        "index": 57422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "megasas_setup_irqs_ioapic(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\tinstance->irq_context[0].instance = instance;\n\tinstance->irq_context[0].MSIxIndex = 0;\n\tif (request_irq(pci_irq_vector(pdev, 0),\n\t\t\tinstance->instancet->service_isr, IRQF_SHARED,\n\t\t\t\"megasas\", &instance->irq_context[0])) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 90412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::didHandleOnloadEvents(blink::WebLocalFrame* frame) {\n  DCHECK(!frame_ || frame_ == frame);\n  if (!frame->parent())\n    Send(new FrameHostMsg_DocumentOnLoadCompleted(routing_id_));\n}\n",
        "output": "0",
        "index": 118508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeBrowserMainPartsChromeos::PreMainMessageLoopStart() {\n  if (!parameters().ui_task) {\n    bool use_stub = parameters().command_line.HasSwitch(switches::kStubCros);\n    chromeos::CrosLibrary::Initialize(use_stub);\n  }\n  net::NetworkChangeNotifier::SetFactory(\n      new chromeos::CrosNetworkChangeNotifierFactory());\n\n  ChromeBrowserMainPartsLinux::PreMainMessageLoopStart();\n}\n",
        "output": "0",
        "index": 117542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::SetSelectionControllerClientForTest(\n    std::unique_ptr<TouchSelectionControllerClientAura> client) {\n  selection_controller_client_.swap(client);\n  CreateSelectionController();\n}\n",
        "output": "0",
        "index": 144980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool DOMWindow::closed() const {\n  return window_is_closing_ || !GetFrame() || !GetFrame()->GetPage();\n}\n",
        "output": "0",
        "index": 160914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_SSL_socket (SSL_CTX *ctx, int sd)\n{\n\tSSL *ssl;\n\n\n\tif (!(ssl = SSL_new (ctx)))\n\t\t/* FATAL */\n\t\t__SSL_critical_error (\"SSL_new\");\n\n\tSSL_set_fd (ssl, sd);\n\tif (ctx->method == SSLv23_client_method())\n\t\tSSL_set_connect_state (ssl);\n\telse\n\t        SSL_set_accept_state(ssl);\n\n\treturn (ssl);\n}\n",
        "output": "0",
        "index": 58482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "netdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb,\n\t\t\t\t  struct fm10k_ring *tx_ring)\n{\n\tu16 count = TXD_USE_COUNT(skb_headlen(skb));\n\tstruct fm10k_tx_buffer *first;\n\tunsigned short f;\n\tu32 tx_flags = 0;\n\tint tso;\n\n\t/* need: 1 descriptor per page * PAGE_SIZE/FM10K_MAX_DATA_PER_TXD,\n\t *       + 1 desc for skb_headlen/FM10K_MAX_DATA_PER_TXD,\n\t *       + 2 desc gap to keep tail from touching head\n\t * otherwise try next time\n\t */\n\tfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++)\n\t\tcount += TXD_USE_COUNT(skb_shinfo(skb)->frags[f].size);\n\n\tif (fm10k_maybe_stop_tx(tx_ring, count + 3)) {\n\t\ttx_ring->tx_stats.tx_busy++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t/* record the location of the first descriptor for this packet */\n\tfirst = &tx_ring->tx_buffer[tx_ring->next_to_use];\n\tfirst->skb = skb;\n\tfirst->bytecount = max_t(unsigned int, skb->len, ETH_ZLEN);\n\tfirst->gso_segs = 1;\n\n\t/* record initial flags and protocol */\n\tfirst->tx_flags = tx_flags;\n\n\ttso = fm10k_tso(tx_ring, first);\n\tif (tso < 0)\n\t\tgoto out_drop;\n\telse if (!tso)\n\t\tfm10k_tx_csum(tx_ring, first);\n\n\tfm10k_tx_map(tx_ring, first);\n\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\tdev_kfree_skb_any(first->skb);\n\tfirst->skb = NULL;\n\n\treturn NETDEV_TX_OK;\n}\n",
        "output": "0",
        "index": 87957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double InputType::Minimum() const {\n  return CreateStepRange(kRejectAny).Minimum().ToDouble();\n}\n",
        "output": "0",
        "index": 137084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string16 PluginServiceImpl::GetPluginDisplayNameByPath(const FilePath& path) {\n  string16 plugin_name = path.LossyDisplayName();\n  webkit::WebPluginInfo info;\n  if (PluginService::GetInstance()->GetPluginInfoByPath(path, &info) &&\n      !info.name.empty()) {\n    plugin_name = info.name;\n#if defined(OS_MACOSX)\n    const std::string kPluginExtension = \".plugin\";\n    if (EndsWith(plugin_name, ASCIIToUTF16(kPluginExtension), true))\n      plugin_name.erase(plugin_name.length() - kPluginExtension.length());\n#endif  // OS_MACOSX\n  }\n  return plugin_name;\n}\n",
        "output": "0",
        "index": 125127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tint i;\n\tstruct thread_struct *t = &tsk->thread;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; i++) {\n\t\tif (t->debug.hbp[i]) {\n\t\t\tunregister_hw_breakpoint(t->debug.hbp[i]);\n\t\t\tt->debug.hbp[i] = NULL;\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 25312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n {\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \"X\" */\n\tchar *endptr;\n \n \tif (hexadecimal && (**buf != '\\0'))\n \t\t(*buf)++;\n \t/* strtol allows whitespace and other stuff in the beginning\n \t\t* we're not interested */\n \tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}\n",
        "output": "1",
        "index": 180349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pkinit_server_plugin_fini_realm(krb5_context context, pkinit_kdc_context plgctx)\n{\n    if (plgctx == NULL)\n        return;\n\n    pkinit_fini_kdc_profile(context, plgctx);\n    pkinit_fini_identity_opts(plgctx->idopts);\n    pkinit_fini_identity_crypto(plgctx->idctx);\n    pkinit_fini_plg_crypto(plgctx->cryptoctx);\n    pkinit_fini_plg_opts(plgctx->opts);\n    free(plgctx->realmname);\n    free(plgctx);\n}\n",
        "output": "0",
        "index": 34594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LockContentsView::UpdateAuthForPublicAccount(\n    LoginPublicAccountUserView* opt_to_update,\n    LoginPublicAccountUserView* opt_to_hide,\n    bool animate) {\n  if (opt_to_update)\n    opt_to_update->SetAuthEnabled(true /*enabled*/, animate);\n  if (opt_to_hide)\n    opt_to_hide->SetAuthEnabled(false /*enabled*/, animate);\n}\n",
        "output": "0",
        "index": 144227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "remove_opt_anc_info(OptAnc* to, int anc)\n{\n  if (is_left(anc))\n    to->left &= ~anc;\n  else\n    to->right &= ~anc;\n}\n",
        "output": "0",
        "index": 89215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBox::panScroll(const IntPoint& sourcePoint)\n{\n    LocalFrame* frame = this->frame();\n    if (!frame)\n        return;\n\n    IntPoint lastKnownMousePosition = frame->eventHandler().lastKnownMousePosition();\n\n    static IntPoint previousMousePosition;\n    if (lastKnownMousePosition.x() < 0 || lastKnownMousePosition.y() < 0)\n        lastKnownMousePosition = previousMousePosition;\n    else\n        previousMousePosition = lastKnownMousePosition;\n\n    IntSize delta = lastKnownMousePosition - sourcePoint;\n\n    if (abs(delta.width()) <= ScrollView::noPanScrollRadius) // at the center we let the space for the icon\n        delta.setWidth(0);\n    if (abs(delta.height()) <= ScrollView::noPanScrollRadius)\n        delta.setHeight(0);\n\n    scrollByRecursively(adjustedScrollDelta(delta), ScrollOffsetClamped);\n}\n",
        "output": "0",
        "index": 124923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_SROUND( TT_ExecContext  exc,\n              FT_Long*        args )\n  {\n    SetSuperRound( exc, 0x4000, args[0] );\n\n    exc->GS.round_state = TT_Round_Super;\n    exc->func_round     = (TT_Round_Func)Round_Super;\n  }\n",
        "output": "0",
        "index": 10676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ffs_release_dev(struct ffs_data *ffs_data)\n{\n\tstruct ffs_dev *ffs_dev;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_dev = ffs_data->private_data;\n\tif (ffs_dev) {\n\t\tffs_dev->mounted = false;\n\n\t\tif (ffs_dev->ffs_release_dev_callback)\n\t\t\tffs_dev->ffs_release_dev_callback(ffs_dev);\n\t}\n\n\tffs_dev_unlock();\n}\n",
        "output": "0",
        "index": 49632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LockContentsView::OnPublicSessionDisplayNameChanged(\n    const AccountId& account_id,\n    const std::string& display_name) {\n  LoginUserView* user_view = TryToFindUserView(account_id);\n  if (!user_view || !IsPublicAccountUser(user_view->current_user()))\n    return;\n\n  mojom::LoginUserInfoPtr user_info = user_view->current_user()->Clone();\n  user_info->basic_user_info->display_name = display_name;\n  user_view->UpdateForUser(user_info, false /*animate*/);\n}\n",
        "output": "0",
        "index": 144207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)\n{\n    if (number >= INT_MAX)\n    {\n        object->valueint = INT_MAX;\n    }\n    else if (number <= (double)INT_MIN)\n    {\n        object->valueint = INT_MIN;\n    }\n    else\n    {\n        object->valueint = (int)number;\n    }\n\n    return object->valuedouble = number;\n}\n",
        "output": "0",
        "index": 87143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tls1_check_sig_alg(CERT *c, X509 *x, int default_nid)\n{\n    int sig_nid;\n    size_t i;\n    if (default_nid == -1)\n        return 1;\n    sig_nid = X509_get_signature_nid(x);\n    if (default_nid)\n        return sig_nid == default_nid ? 1 : 0;\n    for (i = 0; i < c->shared_sigalgslen; i++)\n        if (sig_nid == c->shared_sigalgs[i].signandhash_nid)\n            return 1;\n    return 0;\n}\n",
        "output": "0",
        "index": 6164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void impeg2d_dec_seq_disp_ext(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n\n /*\n    sequence_display_extension()\n    {\n        extension_start_code_identifier 4\n        video_format                    3\n        colour_description              1\n        if (colour_description)\n        {\n            colour_primaries            8\n            transfer_characteristics    8\n            matrix_coefficients         8\n        }\n        display_horizontal_size         14\n        marker_bit                      1\n        display_vertical_size           14\n        next_start_code()\n    }\n    */\n\n    impeg2d_bit_stream_get(ps_stream, 4);\n    ps_dec->u1_video_format = impeg2d_bit_stream_get(ps_stream, 3);\n    ps_dec->u1_colour_description = impeg2d_bit_stream_get(ps_stream, 1);\n    ps_dec->u1_colour_primaries = 2;\n    ps_dec->u1_transfer_characteristics = 2;\n    ps_dec->u1_matrix_coefficients = 2;\n if(ps_dec->u1_colour_description)\n {\n        ps_dec->u1_colour_primaries = impeg2d_bit_stream_get(ps_stream, 8);\n        ps_dec->u1_transfer_characteristics = impeg2d_bit_stream_get(ps_stream, 8);\n        ps_dec->u1_matrix_coefficients = impeg2d_bit_stream_get(ps_stream, 8);\n }\n\n /* display_horizontal_size and display_vertical_size */\n    ps_dec->u2_display_horizontal_size = impeg2d_bit_stream_get(ps_stream,14);;\n    GET_MARKER_BIT(ps_dec,ps_stream);\n    ps_dec->u2_display_vertical_size   = impeg2d_bit_stream_get(ps_stream,14);\n\n    ps_dec->u1_seq_disp_extn_present = 1;\n    impeg2d_next_start_code(ps_dec);\n}\n",
        "output": "0",
        "index": 175774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\tsynchronize_sched();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_sched().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 81555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "assegment_data_free (as_t *asdata)\n{\n  XFREE (MTYPE_AS_SEG_DATA, asdata);\n}\n",
        "output": "0",
        "index": 1612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostManager::InitializeRenderFrameIfNecessary(\n    RenderFrameHostImpl* render_frame_host) {\n  if (render_frame_host->IsRenderFrameLive())\n    return;\n\n  if (!ReinitializeRenderFrame(render_frame_host))\n    return;\n\n  if (render_frame_host != render_frame_host_.get())\n    return;\n\n  EnsureRenderFrameHostVisibilityConsistent();\n\n\n  delegate_->NotifyMainFrameSwappedFromRenderManager(\n      nullptr, render_frame_host_->render_view_host());\n}\n",
        "output": "0",
        "index": 159646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FILE\t*FS_FileForHandle( fileHandle_t f ) {\n\tif ( f < 1 || f >= MAX_FILE_HANDLES ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: out of range\" );\n\t}\n\tif (fsh[f].zipFile == qtrue) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: can't get FILE on zip file\" );\n\t}\n\tif ( ! fsh[f].handleFiles.file.o ) {\n\t\tCom_Error( ERR_DROP, \"FS_FileForHandle: NULL\" );\n\t}\n\t\n\treturn fsh[f].handleFiles.file.o;\n}\n",
        "output": "0",
        "index": 96022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void calc_load_account_idle(struct rq *this_rq)\n{\n}\n",
        "output": "0",
        "index": 22354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    QWindow* get(Display* dpy)\n    {\n        if (!window) {\n            window = new QWindow;\n            window->setGeometry(QRect(-1, -1, 1, 1));\n            window->create();\n            XSetWindowAttributes attributes;\n            attributes.override_redirect = true;\n            XChangeWindowAttributes(dpy, window->handle()->winId(), X11OverrideRedirect, &attributes);\n            window->show();\n        }\n        return window;\n    }\n",
        "output": "1",
        "index": 183711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t ne2000_ioport_read(void *opaque, uint32_t addr)\n{\n    NE2000State *s = opaque;\n    int offset, page, ret;\n\n    addr &= 0xf;\n    if (addr == E8390_CMD) {\n        ret = s->cmd;\n    } else {\n        page = s->cmd >> 6;\n        offset = addr | (page << 4);\n        switch(offset) {\n        case EN0_TSR:\n            ret = s->tsr;\n            break;\n        case EN0_BOUNDARY:\n            ret = s->boundary;\n            break;\n        case EN0_ISR:\n            ret = s->isr;\n            break;\n\tcase EN0_RSARLO:\n\t    ret = s->rsar & 0x00ff;\n\t    break;\n\tcase EN0_RSARHI:\n\t    ret = s->rsar >> 8;\n\t    break;\n        case EN1_PHYS ... EN1_PHYS + 5:\n            ret = s->phys[offset - EN1_PHYS];\n            break;\n        case EN1_CURPAG:\n            ret = s->curpag;\n            break;\n        case EN1_MULT ... EN1_MULT + 7:\n            ret = s->mult[offset - EN1_MULT];\n            break;\n        case EN0_RSR:\n            ret = s->rsr;\n            break;\n        case EN2_STARTPG:\n            ret = s->start >> 8;\n            break;\n        case EN2_STOPPG:\n            ret = s->stop >> 8;\n            break;\n\tcase EN0_RTL8029ID0:\n\t    ret = 0x50;\n\t    break;\n\tcase EN0_RTL8029ID1:\n\t    ret = 0x43;\n\t    break;\n\tcase EN3_CONFIG0:\n\t    ret = 0;\t\t/* 10baseT media */\n\t    break;\n\tcase EN3_CONFIG2:\n\t    ret = 0x40;\t\t/* 10baseT active */\n\t    break;\n\tcase EN3_CONFIG3:\n\t    ret = 0x40;\t\t/* Full duplex */\n\t    break;\n        default:\n            ret = 0x00;\n            break;\n        }\n    }\n#ifdef DEBUG_NE2000\n    printf(\"NE2000: read addr=0x%x val=%02x\\n\", addr, ret);\n#endif\n    return ret;\n}\n",
        "output": "0",
        "index": 12571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool current_in_userns(const struct user_namespace *target_ns)\n{\n\treturn in_userns(target_ns, current_user_ns());\n}\n",
        "output": "0",
        "index": 76177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType SetImageStorageClass(Image *image,\n  const ClassType storage_class)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  image->storage_class=storage_class;\n  return(SyncImagePixelCache(image,&image->exception));\n}\n",
        "output": "0",
        "index": 64537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ikev1_ship_chain(chunk_t *chain, int n, pb_stream *outs,\n\t\t\t\t\t     u_int8_t type,\n\t\t\t\t\t     u_int8_t setnp)\n{\n\tint i;\n\tu_int8_t np;\n\n\tfor (i = 0; i < n; i++) {\n\t\t/* set np for last cert, or another */\n\t\tnp = i == n - 1 ? setnp : ISAKMP_NEXT_CERT;\n\n\t\tif (!ikev1_ship_CERT(type, chain[i], outs, np))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n",
        "output": "0",
        "index": 51685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static String imeRequestName(WPARAM wparam)\n{\n    switch (wparam) {\n    case IMR_CANDIDATEWINDOW:\n        return \"IMR_CANDIDATEWINDOW\";\n    case IMR_COMPOSITIONFONT:\n        return \"IMR_COMPOSITIONFONT\";\n    case IMR_COMPOSITIONWINDOW:\n        return \"IMR_COMPOSITIONWINDOW\";\n    case IMR_CONFIRMRECONVERTSTRING:\n        return \"IMR_CONFIRMRECONVERTSTRING\";\n    case IMR_DOCUMENTFEED:\n        return \"IMR_DOCUMENTFEED\";\n    case IMR_QUERYCHARPOSITION:\n        return \"IMR_QUERYCHARPOSITION\";\n    case IMR_RECONVERTSTRING:\n        return \"IMR_RECONVERTSTRING\";\n    default:\n        return \"Unknown (\" + String::number(wparam) + \")\";\n    }\n}\n",
        "output": "0",
        "index": 106714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int smaps_open(struct inode *inode, struct file *file)\n{\n\treturn do_maps_open(inode, file, &proc_pid_smaps_op);\n}\n",
        "output": "0",
        "index": 20997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool HasReachedMaxRecursionDepth() {\n    return max_recursion_depth_ < 0;\n  }\n",
        "output": "0",
        "index": 169690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void setConsumerName(const String8& name) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());\n        data.writeString8(name);\n        remote()->transact(SET_CONSUMER_NAME, data, &reply);\n }\n",
        "output": "0",
        "index": 174083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "KURL Document::CompleteURLWithOverride(const String& url,\n                                       const KURL& base_url_override) const {\n  DCHECK(base_url_override.IsEmpty() || base_url_override.IsValid());\n\n  if (url.IsNull())\n    return KURL();\n  if (!Encoding().IsValid())\n    return KURL(base_url_override, url);\n  return KURL(base_url_override, url, Encoding());\n}\n",
        "output": "0",
        "index": 140991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vrend_destroy_surface_object(void *obj_ptr)\n{\n   struct vrend_surface *surface = obj_ptr;\n\n   vrend_surface_reference(&surface, NULL);\n}\n",
        "output": "0",
        "index": 8852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_HB_GPOS_Free_SubTable( HB_GPOS_SubTable* st,\n\t\t\tHB_UShort         lookup_type )\n{\n  switch ( lookup_type ) {\n    case HB_GPOS_LOOKUP_SINGLE:\t\tFree_SinglePos\t\t( st ); return;\n    case HB_GPOS_LOOKUP_PAIR:\t\tFree_PairPos\t\t( st ); return;\n    case HB_GPOS_LOOKUP_CURSIVE:\tFree_CursivePos\t\t( st ); return;\n    case HB_GPOS_LOOKUP_MARKBASE:\tFree_MarkBasePos\t( st ); return;\n    case HB_GPOS_LOOKUP_MARKLIG:\tFree_MarkLigPos\t\t( st ); return;\n    case HB_GPOS_LOOKUP_MARKMARK:\tFree_MarkMarkPos\t( st ); return;\n    case HB_GPOS_LOOKUP_CONTEXT:\tFree_ContextPos\t\t( st ); return;\n    case HB_GPOS_LOOKUP_CHAIN:\t\tFree_ChainContextPos\t( st ); return;\n  /*case HB_GPOS_LOOKUP_EXTENSION:\tFree_ExtensionPos\t( st ); return;*/\n    default:\t\t\t\t\t\t\t\t\treturn;\n  }\n}\n",
        "output": "0",
        "index": 13613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> cachedValueAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestSerializedScriptValueInterface.cachedValue._get\");\n    v8::Handle<v8::String> propertyName = v8::String::NewSymbol(\"cachedValue\");\n    v8::Handle<v8::Value> value = info.Holder()->GetHiddenValue(propertyName);\n    if (!value.IsEmpty())\n        return value;\n    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(info.Holder());\n    SerializedScriptValue* serialized = imp->cachedValue();\n    value = serialized ? serialized->deserialize() : v8::Handle<v8::Value>(v8::Null());\n    info.Holder()->SetHiddenValue(propertyName, value);\n    return value;\n}\n",
        "output": "0",
        "index": 117925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getPathInfo)\n{\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tzend_class_entry *ce = intern->info_class;\n \tzend_error_handling error_handling;\n \tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n \n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n",
        "output": "1",
        "index": 180215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool IsSelecting() { return window_selector_controller()->IsSelecting(); }\n",
        "output": "0",
        "index": 145896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MojoVideoEncodeAccelerator::Encode(const scoped_refptr<VideoFrame>& frame,\n                                        bool force_keyframe) {\n  DVLOG(2) << __func__ << \" tstamp=\" << frame->timestamp();\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK_EQ(PIXEL_FORMAT_I420, frame->format());\n  DCHECK_EQ(VideoFrame::STORAGE_SHMEM, frame->storage_type());\n  DCHECK(frame->shared_memory_handle().IsValid());\n\n  const size_t allocation_size = frame->shared_memory_handle().GetSize();\n \n  mojo::ScopedSharedBufferHandle handle =\n      mojo::WrapSharedMemoryHandle(frame->shared_memory_handle().Duplicate(),\n                                   allocation_size, true /* read_only */);\n \n   const size_t y_offset = frame->shared_memory_offset();\n   const size_t u_offset = y_offset + frame->data(VideoFrame::kUPlane) -\n                          frame->data(VideoFrame::kYPlane);\n  const size_t v_offset = y_offset + frame->data(VideoFrame::kVPlane) -\n                          frame->data(VideoFrame::kYPlane);\n  scoped_refptr<MojoSharedBufferVideoFrame> mojo_frame =\n      MojoSharedBufferVideoFrame::Create(\n          frame->format(), frame->coded_size(), frame->visible_rect(),\n          frame->natural_size(), std::move(handle), allocation_size, y_offset,\n          u_offset, v_offset, frame->stride(VideoFrame::kYPlane),\n          frame->stride(VideoFrame::kUPlane),\n          frame->stride(VideoFrame::kVPlane), frame->timestamp());\n\n  DCHECK(vea_.is_bound());\n  vea_->Encode(mojo_frame, force_keyframe,\n               base::Bind(&KeepVideoFrameAlive, frame));\n}\n",
        "output": "1",
        "index": 186850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 2:5 are resrved, Should be zero */\n\tif (data & 0x3c)\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_val = data;\n\n\tif (!(data & KVM_ASYNC_PF_ENABLED)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tkvm_async_pf_wakeup_all(vcpu);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 20799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool new_idmap_permitted(const struct file *file,\n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tconst struct cred *cred = file->f_cred;\n\t/* Don't allow mappings that would allow anything that wouldn't\n\t * be allowed without the establishment of unprivileged mappings.\n\t */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1) &&\n\t    uid_eq(ns->owner, cred->euid)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, cred->euid))\n\t\t\t\treturn true;\n\t\t} else if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (!(ns->flags & USERNS_SETGROUPS_ALLOWED) &&\n\t\t\t    gid_eq(gid, cred->egid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n\t * And the opener of the id file also had the approprpiate capability.\n\t */\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}\n",
        "output": "0",
        "index": 76191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __be32 confirm_addr_indev(struct in_device *in_dev, __be32 dst,\n\t\t\t      __be32 local, int scope)\n{\n\tint same = 0;\n\t__be32 addr = 0;\n\n\tfor_ifa(in_dev) {\n\t\tif (!addr &&\n\t\t    (local == ifa->ifa_local || !local) &&\n\t\t    ifa->ifa_scope <= scope) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tif (same)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!same) {\n\t\t\tsame = (!local || inet_ifa_match(local, ifa)) &&\n\t\t\t\t(!dst || inet_ifa_match(dst, ifa));\n\t\t\tif (same && addr) {\n\t\t\t\tif (local || !dst)\n\t\t\t\t\tbreak;\n\t\t\t\t/* Is the selected addr into dst subnet? */\n\t\t\t\tif (inet_ifa_match(addr, ifa))\n\t\t\t\t\tbreak;\n\t\t\t\t/* No, then can we use new local src? */\n\t\t\t\tif (ifa->ifa_scope <= scope) {\n\t\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* search for large dst subnet for addr */\n\t\t\t\tsame = 0;\n\t\t\t}\n\t\t}\n\t} endfor_ifa(in_dev);\n\n\treturn same ? addr : 0;\n}\n",
        "output": "0",
        "index": 54054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TestLifecycleUnit::Load() {\n  return false;\n}\n",
        "output": "0",
        "index": 144857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAndroid::SendGestureEvent(\n    const WebKit::WebGestureEvent& event) {\n  if (host_)\n    host_->ForwardGestureEvent(event);\n}\n",
        "output": "0",
        "index": 123120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf14_open(gx_device *dev)\n{\n    pdf14_device *pdev = (pdf14_device *)dev;\n    gs_int_rect rect;\n\n    if_debug2m('v', dev->memory, \"[v]pdf14_open: width = %d, height = %d\\n\",\n               dev->width, dev->height);\n    rect.p.x = 0;\n    rect.p.y = 0;\n    rect.q.x = dev->width;\n    rect.q.y = dev->height;\n    pdev->ctx = pdf14_ctx_new(&rect, dev->color_info.num_components,\n        pdev->color_info.polarity != GX_CINFO_POLARITY_SUBTRACTIVE, dev);\n    if (pdev->ctx == NULL)\n        return_error(gs_error_VMerror);\n    pdev->free_devicen = true;\n    return 0;\n}\n",
        "output": "0",
        "index": 13323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataFile::SetFileNameFromTitle() {\n  if (is_hosted_document_) {\n    file_name_ = EscapeUtf8FileName(title_ + document_extension_);\n  } else {\n    GDataEntry::SetFileNameFromTitle();\n  }\n}\n",
        "output": "0",
        "index": 111658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extend_abbrs (char *abbrs, char const *abbr, size_t abbr_size)\n{\n  memcpy (abbrs, abbr, abbr_size);\n  abbrs[abbr_size] = '\\0';\n}\n",
        "output": "0",
        "index": 7539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pmcraid_change_queue_type(struct scsi_device *scsi_dev, int tag)\n{\n\tstruct pmcraid_resource_entry *res;\n\n\tres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\n\n\tif ((res) && scsi_dev->tagged_supported &&\n\t    (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\n\t\tscsi_set_tag_type(scsi_dev, tag);\n\n\t\tif (tag)\n\t\t\tscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t\telse\n\t\t\tscsi_deactivate_tcq(scsi_dev, scsi_dev->queue_depth);\n\t} else\n\t\ttag = 0;\n\n\treturn tag;\n}\n",
        "output": "0",
        "index": 26422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_NXAST_RAW_BUNDLE(const struct nx_action_bundle *nab,\n                        enum ofp_version ofp_version OVS_UNUSED,\n                        struct ofpbuf *out)\n{\n    return decode_bundle(false, nab, NULL, NULL, out);\n}\n",
        "output": "0",
        "index": 76787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Layer::SetNeedsDisplayRect(const gfx::RectF& dirty_rect) {\n  if (dirty_rect.IsEmpty())\n    return;\n\n  SetNeedsPushProperties();\n  update_rect_.Union(dirty_rect);\n\n  if (DrawsContent())\n    SetNeedsUpdate();\n}\n",
        "output": "0",
        "index": 120173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScriptPromise ReadableStream::cancel(ScriptState* scriptState)\n{\n    return cancel(scriptState, ScriptValue(scriptState, v8::Undefined(scriptState->isolate())));\n}\n",
        "output": "0",
        "index": 128748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HeadlessWebContentsImpl::AddObserver(Observer* observer) {\n  observers_.AddObserver(observer);\n}\n",
        "output": "0",
        "index": 137735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::NeedsLayoutTreeUpdateForNode(const Node& node,\n                                            bool ignore_adjacent_style) const {\n  if (!node.CanParticipateInFlatTree())\n    return false;\n  if (!NeedsLayoutTreeUpdate())\n    return false;\n  if (!node.isConnected())\n    return false;\n\n  if (NeedsFullLayoutTreeUpdate() || node.NeedsStyleRecalc() ||\n      node.NeedsStyleInvalidation())\n    return true;\n  for (const ContainerNode* ancestor = LayoutTreeBuilderTraversal::Parent(node);\n       ancestor; ancestor = LayoutTreeBuilderTraversal::Parent(*ancestor)) {\n    if (ShadowRoot* root = ancestor->GetShadowRoot()) {\n      if (root->NeedsStyleRecalc() || root->NeedsStyleInvalidation() ||\n          root->NeedsAdjacentStyleRecalc()) {\n        return true;\n      }\n    }\n    if (ancestor->NeedsStyleRecalc() || ancestor->NeedsStyleInvalidation() ||\n        (ancestor->NeedsAdjacentStyleRecalc() && !ignore_adjacent_style)) {\n      return true;\n    }\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 141165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init aesni_init(void)\n{\n\tint err;\n\n\tif (!x86_match_cpu(aesni_cpu_id))\n\t\treturn -ENODEV;\n#ifdef CONFIG_X86_64\n#ifdef CONFIG_AS_AVX2\n\tif (boot_cpu_has(X86_FEATURE_AVX2)) {\n\t\tpr_info(\"AVX2 version of gcm_enc/dec engaged.\\n\");\n\t\taesni_gcm_enc_tfm = aesni_gcm_enc_avx2;\n\t\taesni_gcm_dec_tfm = aesni_gcm_dec_avx2;\n\t} else\n#endif\n#ifdef CONFIG_AS_AVX\n\tif (boot_cpu_has(X86_FEATURE_AVX)) {\n\t\tpr_info(\"AVX version of gcm_enc/dec engaged.\\n\");\n\t\taesni_gcm_enc_tfm = aesni_gcm_enc_avx;\n\t\taesni_gcm_dec_tfm = aesni_gcm_dec_avx;\n\t} else\n#endif\n\t{\n\t\tpr_info(\"SSE version of gcm_enc/dec engaged.\\n\");\n\t\taesni_gcm_enc_tfm = aesni_gcm_enc;\n\t\taesni_gcm_dec_tfm = aesni_gcm_dec;\n\t}\n\taesni_ctr_enc_tfm = aesni_ctr_enc;\n#ifdef CONFIG_AS_AVX\n\tif (cpu_has_avx) {\n\t\t/* optimize performance of ctr mode encryption transform */\n\t\taesni_ctr_enc_tfm = aesni_ctr_enc_avx_tfm;\n\t\tpr_info(\"AES CTR mode by8 optimization enabled\\n\");\n\t}\n#endif\n#endif\n\n\terr = crypto_fpu_init();\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_register_algs(aesni_algs, ARRAY_SIZE(aesni_algs));\n}\n",
        "output": "0",
        "index": 43468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderProcessHostImpl::RemovePendingView() {\n  DCHECK(pending_views_);\n  pending_views_--;\n  UpdateProcessPriority();\n}\n",
        "output": "0",
        "index": 162137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void  Ins_CEILING( INS_ARG )\n  { (void)exc;\n    args[0] = (args[0] + 63) & (-64);\n  }\n",
        "output": "0",
        "index": 5367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n                               Jpeg2000Component *comp,\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = (src[i] * band->i_stepsize + (1 << 14)) >> 15;\n    }\n}\n",
        "output": "0",
        "index": 27995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool P2PSocketDispatcherHost::OnMessageReceived(const IPC::Message& message,\n                                                bool* message_was_ok) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(P2PSocketDispatcherHost, message, *message_was_ok)\n    IPC_MESSAGE_HANDLER(P2PHostMsg_GetNetworkList, OnGetNetworkList)\n    IPC_MESSAGE_HANDLER(P2PHostMsg_CreateSocket, OnCreateSocket)\n    IPC_MESSAGE_HANDLER(P2PHostMsg_AcceptIncomingTcpConnection,\n                        OnAcceptIncomingTcpConnection)\n    IPC_MESSAGE_HANDLER(P2PHostMsg_Send, OnSend)\n    IPC_MESSAGE_HANDLER(P2PHostMsg_DestroySocket, OnDestroySocket)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP_EX()\n  return handled;\n}\n",
        "output": "0",
        "index": 103344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SimulateMouseEvent(WebContents* web_contents,\n                        blink::WebInputEvent::Type type,\n                        const gfx::Point& point) {\n  blink::WebMouseEvent mouse_event(type, blink::WebInputEvent::kNoModifiers,\n                                   ui::EventTimeForNow());\n  mouse_event.SetPositionInWidget(point.x(), point.y());\n  web_contents->GetRenderViewHost()->GetWidget()->ForwardMouseEvent(\n      mouse_event);\n}\n",
        "output": "0",
        "index": 169339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fep_client_close (FepClient *client)\n{\n  close (client->control);\n  free (client);\n}\n",
        "output": "0",
        "index": 36960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int allocate_cmdlines_buffer(unsigned int val,\n\t\t\t\t    struct saved_cmdlines_buffer *s)\n{\n\ts->map_cmdline_to_pid = kmalloc_array(val,\n\t\t\t\t\t      sizeof(*s->map_cmdline_to_pid),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!s->map_cmdline_to_pid)\n\t\treturn -ENOMEM;\n\n\ts->saved_cmdlines = kmalloc_array(TASK_COMM_LEN, val, GFP_KERNEL);\n\tif (!s->saved_cmdlines) {\n\t\tkfree(s->map_cmdline_to_pid);\n\t\treturn -ENOMEM;\n\t}\n\n\ts->cmdline_idx = 0;\n\ts->cmdline_num = val;\n\tmemset(&s->map_pid_to_cmdline, NO_CMDLINE_MAP,\n\t       sizeof(s->map_pid_to_cmdline));\n\tmemset(s->map_cmdline_to_pid, NO_CMDLINE_MAP,\n\t       val * sizeof(*s->map_cmdline_to_pid));\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 81250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void InitializeStatisticsRecorder() {\n    DCHECK(!statistics_recorder_);\n    statistics_recorder_ = StatisticsRecorder::CreateTemporaryForTesting();\n    auto record_checker = std::make_unique<TestRecordHistogramChecker>();\n    StatisticsRecorder::SetRecordChecker(std::move(record_checker));\n  }\n",
        "output": "0",
        "index": 143774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Wait() {\n    run_loop_.reset(new base::RunLoop());\n    run_loop_->Run();\n    run_loop_.reset();\n  }\n",
        "output": "0",
        "index": 156732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CrosMock::TearDownMocks() {\n  if (loader_)\n    test_api()->SetLibraryLoader(NULL, false);\n  if (mock_cryptohome_library_)\n    test_api()->SetCryptohomeLibrary(NULL, false);\n  if (mock_network_library_)\n    test_api()->SetNetworkLibrary(NULL, false);\n  if (mock_power_library_)\n    test_api()->SetPowerLibrary(NULL, false);\n  if (mock_screen_lock_library_)\n    test_api()->SetScreenLockLibrary(NULL, false);\n  if (mock_speech_synthesis_library_)\n    test_api()->SetSpeechSynthesisLibrary(NULL, false);\n  if (mock_touchpad_library_)\n    test_api()->SetTouchpadLibrary(NULL, false);\n}\n",
        "output": "0",
        "index": 104511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\tunsigned char *buf = dest;\n\tint count;\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf + KLSI_HDR_LEN, size,\n\t\t\t\t\t\t\t\t&port->lock);\n\tput_unaligned_le16(count, buf);\n\n\treturn count + KLSI_HDR_LEN;\n}\n",
        "output": "0",
        "index": 68758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t TestWebKitPlatformSupport::audioHardwareBufferSize() {\n  return 128;\n}\n",
        "output": "0",
        "index": 116867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    int numberOfTimesChecked() const { return m_numberOfTimesChecked; }\n",
        "output": "0",
        "index": 119531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int SpdyProxyClientSocket::DoGenerateAuthToken() {\n  next_state_ = STATE_GENERATE_AUTH_TOKEN_COMPLETE;\n  return auth_->MaybeGenerateAuthToken(\n      &request_,\n      base::Bind(&SpdyProxyClientSocket::OnIOComplete,\n                 weak_factory_.GetWeakPtr()),\n      net_log_);\n}\n",
        "output": "0",
        "index": 140542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GURL ChromeContentBrowserClient::GetEffectiveURL(Profile* profile,\n                                                 const GURL& url) {\n  if (!profile || !profile->GetExtensionService())\n    return url;\n\n  const Extension* extension =\n      profile->GetExtensionService()->GetExtensionByWebExtent(url);\n  if (!extension)\n    return url;\n\n  return extension->GetResourceURL(url.path());\n}\n",
        "output": "0",
        "index": 103615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HTMLInputElement::isMouseFocusable() const\n{\n    return m_inputType->isMouseFocusable();\n}\n",
        "output": "0",
        "index": 121178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "metadata_show(struct mddev *mddev, char *page)\n{\n\tif (mddev->persistent)\n\t\treturn sprintf(page, \"%d.%d\\n\",\n\t\t\t       mddev->major_version, mddev->minor_version);\n\telse if (mddev->external)\n\t\treturn sprintf(page, \"external:%s\\n\", mddev->metadata_type);\n\telse\n\t\treturn sprintf(page, \"none\\n\");\n}\n",
        "output": "0",
        "index": 42496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::PluginFocusChanged(bool focused, int plugin_id) {\n  Send(new ViewHostMsg_PluginFocusChanged(routing_id(), focused, plugin_id));\n}\n",
        "output": "0",
        "index": 109011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void reference_32x32_dct_2d(const int16_t input[kNumCoeffs],\n double output[kNumCoeffs]) {\n for (int i = 0; i < 32; ++i) {\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = input[j*32 + i];\n    reference_32x32_dct_1d(temp_in, temp_out, 1);\n     for (int j = 0; j < 32; ++j)\n       output[j * 32 + i] = temp_out[j];\n   }\n for (int i = 0; i < 32; ++i) {\n\n     double temp_in[32], temp_out[32];\n     for (int j = 0; j < 32; ++j)\n       temp_in[j] = output[j + i*32];\n    reference_32x32_dct_1d(temp_in, temp_out, 1);\n     for (int j = 0; j < 32; ++j)\n       output[j + i * 32] = temp_out[j] / 4;\n   }\n }\n",
        "output": "1",
        "index": 188555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init acpi_initrd_initialize_tables(void)\n{\n}\n",
        "output": "0",
        "index": 53825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserEventRouter::DispatchTabUpdatedEvent(\n    WebContents* contents, DictionaryValue* changed_properties) {\n  DCHECK(changed_properties);\n  DCHECK(contents);\n\n  scoped_ptr<ListValue> args_base(new ListValue());\n\n  args_base->AppendInteger(ExtensionTabUtil::GetTabId(contents));\n\n  args_base->Append(changed_properties);\n\n  Profile* profile = Profile::FromBrowserContext(contents->GetBrowserContext());\n\n  const EventListenerMap::ListenerList& listeners(\n      ExtensionSystem::Get(profile)->event_router()->\n      listeners().GetEventListenersByName(events::kOnTabUpdated));\n  for (EventListenerMap::ListenerList::const_iterator it = listeners.begin();\n       it != listeners.end();\n       ++it) {\n    scoped_ptr<ListValue> args(args_base->DeepCopy());\n    DictionaryValue* tab_value = ExtensionTabUtil::CreateTabValue(\n        contents,\n        profile->GetExtensionService()->extensions()->GetByID(\n            (*it)->extension_id));\n    args->Append(tab_value);\n    DispatchEventToExtension(profile, (*it)->extension_id,\n                             events::kOnTabUpdated, args.Pass(),\n                             EventRouter::USER_GESTURE_UNKNOWN);\n  }\n}\n",
        "output": "0",
        "index": 126121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ExecuteMoveRight(LocalFrame& frame,\n                             Event*,\n                             EditorCommandSource,\n                             const String&) {\n  return frame.Selection().Modify(\n      SelectionModifyAlteration::kMove, SelectionModifyDirection::kRight,\n      TextGranularity::kCharacter, SetSelectionBy::kUser);\n}\n",
        "output": "0",
        "index": 139464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool pfn_range_is_mapped(unsigned long start_pfn, unsigned long end_pfn)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_pfn_mapped; i++)\n\t\tif ((start_pfn >= pfn_mapped[i].start) &&\n\t\t    (end_pfn <= pfn_mapped[i].end))\n\t\t\treturn true;\n\n\treturn false;\n}\n",
        "output": "0",
        "index": 66866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InputMethodIBus::DeleteSurroundingText(int32 offset, uint32 length) {\n  if (!composition_.text.empty())\n    return;  // do nothing if there is ongoing composition.\n  if (offset < 0 && static_cast<uint32>(-1 * offset) != length)\n    return;  // only preceding text can be deletable.\n  if (GetTextInputClient())\n    GetTextInputClient()->ExtendSelectionAndDelete(length, 0U);\n}\n",
        "output": "0",
        "index": 134100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Size WebContentsImpl::GetSizeForNewRenderView() const {\n  gfx::Size size;\n  if (delegate_)\n    size = delegate_->GetSizeForNewRenderView(this);\n  if (size.IsEmpty())\n    size = view_->GetContainerSize();\n  return size;\n}\n",
        "output": "0",
        "index": 118923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void longMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::longMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 131474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int squashfs_readdir(struct dir *dir, char **name, unsigned int *start_block,\nunsigned int *offset, unsigned int *type)\n{\n\tif(dir->cur_entry == dir->dir_count)\n\t\treturn FALSE;\n\n\t*name = dir->dirs[dir->cur_entry].name;\n\t*start_block = dir->dirs[dir->cur_entry].start_block;\n\t*offset = dir->dirs[dir->cur_entry].offset;\n\t*type = dir->dirs[dir->cur_entry].type;\n\tdir->cur_entry ++;\n\n\treturn TRUE;\n}\n",
        "output": "0",
        "index": 74307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOLEAN btm_sec_is_upgrade_possible(tBTM_SEC_DEV_REC  *p_dev_rec, BOOLEAN is_originator)\n{\n    UINT16              mtm_check = is_originator ? BTM_SEC_OUT_MITM : BTM_SEC_IN_MITM;\n    BOOLEAN             is_possible = TRUE;\n\n if (p_dev_rec->sec_flags & BTM_SEC_LINK_KEY_KNOWN)\n {\n        is_possible = FALSE;\n if(p_dev_rec->p_cur_service)\n {\n        BTM_TRACE_DEBUG (\"btm_sec_is_upgrade_possible id:%d, link_key_typet:%d, rmt_io_caps:%d, chk flags:x%x, flags:x%x\",\n                          p_dev_rec->p_cur_service->service_id, p_dev_rec->link_key_type, p_dev_rec->rmt_io_caps,\n                          mtm_check, p_dev_rec->p_cur_service->security_flags);\n }\n else\n {\n            BTM_TRACE_DEBUG (\"btm_sec_is_upgrade_possible link_key_typet:%d, rmt_io_caps:%d, chk flags:x%x, \",\n                          p_dev_rec->link_key_type, p_dev_rec->rmt_io_caps, mtm_check);\n }\n /* Already have a link key to the connected peer. Is the link key secure enough?\n        ** Is a link key upgrade even possible?\n        */\n if ((p_dev_rec->security_required & mtm_check) /* needs MITM */\n && (p_dev_rec->link_key_type == BTM_LKEY_TYPE_UNAUTH_COMB) /* has unauthenticated link key */\n && (p_dev_rec->rmt_io_caps < BTM_IO_CAP_MAX) /* a valid peer IO cap */\n && (btm_sec_io_map[p_dev_rec->rmt_io_caps][btm_cb.devcb.loc_io_caps])) /* authenticated link key is possible */\n {\n /* upgrade is possible: check if the application wants the upgrade.\n             * If the application is configured to use a global MITM flag,\n             * it probably would not want to upgrade the link key based on the security level database */\n            is_possible = TRUE;\n }\n }\n    BTM_TRACE_DEBUG (\"btm_sec_is_upgrade_possible is_possible:%d sec_flags:0x%x\", is_possible, p_dev_rec->sec_flags);\n return is_possible;\n}\n",
        "output": "0",
        "index": 174620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::RestoreTab() {\n  UserMetrics::RecordAction(UserMetricsAction(\"RestoreTab\"));\n  TabRestoreService* service =\n      TabRestoreServiceFactory::GetForProfile(profile_);\n  if (!service)\n    return;\n\n  service->RestoreMostRecentEntry(tab_restore_service_delegate());\n}\n",
        "output": "0",
        "index": 101789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkzfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n",
        "output": "0",
        "index": 60217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " JSObject* createURIError(ExecState* exec, const UString& message)\n {\n     return createURIError(exec->lexicalGlobalObject(), message);\n}\n",
        "output": "0",
        "index": 105891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_all_descbuffers(struct b43_dmaring *ring)\n{\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tint i;\n\n\tif (!ring->used_slots)\n\t\treturn;\n\tfor (i = 0; i < ring->nr_slots; i++) {\n\t\tdesc = ring->ops->idx2desc(ring, i, &meta);\n\n\t\tif (!meta->skb || b43_dma_ptr_is_poisoned(meta->skb)) {\n\t\t\tB43_WARN_ON(!ring->tx);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ring->tx) {\n\t\t\tunmap_descbuffer(ring, meta->dmaaddr,\n\t\t\t\t\t meta->skb->len, 1);\n\t\t} else {\n\t\t\tunmap_descbuffer(ring, meta->dmaaddr,\n\t\t\t\t\t ring->rx_buffersize, 0);\n\t\t}\n\t\tfree_descriptor_buffer(ring, meta);\n\t}\n}\n",
        "output": "0",
        "index": 24549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {\n  size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);\n  icu::UnicodeString ustr_host(FALSE, hostname.data(), hostname_length);\n  if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==\n      ustr_host.length())\n    transliterator_.get()->transliterate(ustr_host);\n\n  UErrorCode status = U_ZERO_ERROR;\n  icu::UnicodeString ustr_skeleton;\n  uspoof_getSkeletonUnicodeString(checker_, 0, ustr_host, ustr_skeleton,\n                                  &status);\n  if (U_FAILURE(status))\n    return false;\n  std::string skeleton;\n  ustr_skeleton.toUTF8String(skeleton);\n  return LookupMatchInTopDomains(skeleton);\n}\n",
        "output": "0",
        "index": 149159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int page_not_mapped(struct page *page)\n{\n\treturn !page_mapped(page);\n};\n",
        "output": "0",
        "index": 38314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoUniformMatrix3fv(\n    GLint fake_location, GLsizei count, GLboolean transpose,\n    const GLfloat* value) {\n  GLenum type = 0;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(fake_location,\n                                   \"glUniformMatrix3fv\",\n                                   Program::kUniformMatrix3f,\n                                   &real_location,\n                                   &type,\n                                   &count)) {\n    return;\n  }\n  glUniformMatrix3fv(real_location, count, transpose, value);\n}\n",
        "output": "0",
        "index": 129332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void trace_access_lock(int cpu)\n{\n\tif (cpu == RING_BUFFER_ALL_CPUS) {\n\t\t/* gain it for accessing the whole ring buffer. */\n\t\tdown_write(&all_cpu_access_lock);\n\t} else {\n\t\t/* gain it for accessing a cpu ring buffer. */\n\n\t\t/* Firstly block other trace_access_lock(RING_BUFFER_ALL_CPUS). */\n\t\tdown_read(&all_cpu_access_lock);\n\n\t\t/* Secondly block other access to this @cpu ring buffer. */\n\t\tmutex_lock(&per_cpu(cpu_access_lock, cpu));\n\t}\n}\n",
        "output": "0",
        "index": 81362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void P2PQuicStreamImpl::OnDataAvailable() {\n  sequencer()->MarkConsumed(sequencer()->ReadableBytes());\n  if (sequencer()->IsClosed()) {\n    OnFinRead();\n   }\n }\n",
        "output": "0",
        "index": 145388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}\n",
        "output": "0",
        "index": 55646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(getpgid, pid_t, pid)\n{\n struct task_struct *p;\n struct pid *grp;\n int retval;\n\n\trcu_read_lock();\n if (!pid)\n\t\tgrp = task_pgrp(current);\n else {\n\t\tretval = -ESRCH;\n\t\tp = find_task_by_vpid(pid);\n if (!p)\n goto out;\n\t\tgrp = task_pgrp(p);\n if (!grp)\n goto out;\n\n\t\tretval = security_task_getpgid(p);\n if (retval)\n goto out;\n }\n\tretval = pid_vnr(grp);\nout:\n\trcu_read_unlock();\n return retval;\n}\n",
        "output": "0",
        "index": 175192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_check_entry(struct arpt_entry *e, const char *name, unsigned int size)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tint ret;\n\n\te->counters.pcnt = xt_percpu_counter_alloc();\n\tif (IS_ERR_VALUE(e->counters.pcnt))\n\t\treturn -ENOMEM;\n\n\tt = arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"find_check_entry: `%s' not found\\n\", t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\tret = check_target(e, name);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\txt_percpu_counter_free(e->counters.pcnt);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 52257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int StreamTcpTest06 (void)\n{\n    Packet *p = SCMalloc(SIZE_OF_PACKET);\n    if (unlikely(p == NULL))\n        return 0;\n    Flow f;\n    TcpSession ssn;\n    ThreadVars tv;\n    StreamTcpThread stt;\n    TCPHdr tcph;\n    memset(p, 0, SIZE_OF_PACKET);\n    PacketQueue pq;\n    memset(&pq,0,sizeof(PacketQueue));\n    memset (&f, 0, sizeof(Flow));\n    memset(&ssn, 0, sizeof (TcpSession));\n    memset(&tv, 0, sizeof (ThreadVars));\n    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n    int ret = 0;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n\n    tcph.th_flags = TH_FIN;\n    p->tcph = &tcph;\n\n    /* StreamTcpPacket returns -1 on unsolicited FIN */\n    if (StreamTcpPacket(&tv, p, &stt, &pq) != -1) {\n        printf(\"StreamTcpPacket failed: \");\n        goto end;\n    }\n\n    if (((TcpSession *)(p->flow->protoctx)) != NULL) {\n        printf(\"we have a ssn while we shouldn't: \");\n        goto end;\n    }\n\n    p->tcph->th_flags = TH_RST;\n    /* StreamTcpPacket returns -1 on unsolicited RST */\n    if (StreamTcpPacket(&tv, p, &stt, &pq) != -1) {\n        printf(\"StreamTcpPacket failed (2): \");\n        goto end;\n    }\n\n    if (((TcpSession *)(p->flow->protoctx)) != NULL) {\n        printf(\"we have a ssn while we shouldn't (2): \");\n        goto end;\n    }\n\n    ret = 1;\nend:\n    SCFree(p);\n    FLOW_DESTROY(&f);\n    StreamTcpUTDeinit(stt.ra_ctx);\n    return ret;\n}\n",
        "output": "0",
        "index": 79236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int socket_send(int fd, void *data, size_t length)\n{\n\treturn send(fd, data, length, 0);\n}\n",
        "output": "0",
        "index": 52142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    explicit DeferredTaskSetPageVisibilityState(WebPagePrivate* webPagePrivate)\n        : DeferredTaskType(webPagePrivate)\n    {\n    }\n",
        "output": "0",
        "index": 111048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 53309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long vma_compute_subtree_gap(struct vm_area_struct *vma)\n{\n\tunsigned long max, prev_end, subtree_gap;\n\n\t/*\n\t * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we\n\t * allow two stack_guard_gaps between them here, and when choosing\n\t * an unmapped area; whereas when expanding we only require one.\n\t * That's a little inconsistent, but keeps the code here simpler.\n\t */\n\tmax = vm_start_gap(vma);\n\tif (vma->vm_prev) {\n\t\tprev_end = vm_end_gap(vma->vm_prev);\n\t\tif (max > prev_end)\n\t\t\tmax -= prev_end;\n\t\telse\n\t\t\tmax = 0;\n\t}\n\tif (vma->vm_rb.rb_left) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_left,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\tif (vma->vm_rb.rb_right) {\n\t\tsubtree_gap = rb_entry(vma->vm_rb.rb_right,\n\t\t\t\tstruct vm_area_struct, vm_rb)->rb_subtree_gap;\n\t\tif (subtree_gap > max)\n\t\t\tmax = subtree_gap;\n\t}\n\treturn max;\n}\n",
        "output": "0",
        "index": 90608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool VaapiWrapper::GetMaxResolution_Locked(\n    VAProfile va_profile,\n    VAEntrypoint entrypoint,\n    std::vector<VAConfigAttrib>& required_attribs,\n    gfx::Size* resolution) {\n  va_lock_->AssertAcquired();\n  VAConfigID va_config_id;\n  VAStatus va_res = vaCreateConfig(\n      va_display_,\n      va_profile,\n      entrypoint,\n      &required_attribs[0],\n      required_attribs.size(),\n      &va_config_id);\n  VA_SUCCESS_OR_RETURN(va_res, \"vaCreateConfig failed\", false);\n\n  unsigned int num_attribs;\n  va_res = vaQuerySurfaceAttributes(\n      va_display_, va_config_id, nullptr, &num_attribs);\n  VA_SUCCESS_OR_RETURN(va_res, \"vaQuerySurfaceAttributes failed\", false);\n  if (!num_attribs)\n    return false;\n\n  std::vector<VASurfaceAttrib> attrib_list(\n      base::checked_cast<size_t>(num_attribs));\n\n  va_res = vaQuerySurfaceAttributes(\n      va_display_, va_config_id, &attrib_list[0], &num_attribs);\n  VA_SUCCESS_OR_RETURN(va_res, \"vaQuerySurfaceAttributes failed\", false);\n\n  resolution->SetSize(0, 0);\n  for (const auto& attrib : attrib_list) {\n    if (attrib.type == VASurfaceAttribMaxWidth)\n      resolution->set_width(attrib.value.value.i);\n    else if (attrib.type == VASurfaceAttribMaxHeight)\n      resolution->set_height(attrib.value.value.i);\n  }\n  if (resolution->IsEmpty()) {\n    LOG(ERROR) << \"Codec resolution \" << resolution->ToString()\n               << \" cannot be zero.\";\n    return false;\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 99697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void HTMLElementAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueFast(info, WTF::GetPtr(impl->htmlElementAttribute()), impl);\n}\n",
        "output": "0",
        "index": 147409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vrend_blend_enable(struct vrend_context *ctx, bool blend_enable)\n{\n   if (ctx->sub->blend_enabled != blend_enable) {\n      ctx->sub->blend_enabled = blend_enable;\n      if (blend_enable)\n         glEnable(GL_BLEND);\n      else\n         glDisable(GL_BLEND);\n   }\n}\n",
        "output": "0",
        "index": 8825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual int WritePacketToWire(QuicPacketSequenceNumber number,\n                                const QuicEncryptedPacket& packet,\n                                bool resend,\n                                int* error) {\n    QuicFramer framer(QuicDecrypter::Create(kNULL),\n                      QuicEncrypter::Create(kNULL));\n    FramerVisitorCapturingAcks visitor;\n    framer.set_visitor(&visitor);\n    EXPECT_TRUE(framer.ProcessPacket(IPEndPoint(), IPEndPoint(), packet));\n    header_ = *visitor.header();\n    return packet.length();\n  }\n",
        "output": "0",
        "index": 123789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  base::TaskQueue& work_queue() { return work_queue_; }\n",
        "output": "0",
        "index": 133263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline GLenum convert_min_filter(unsigned int filter, unsigned int mip_filter)\n{\n   if (mip_filter == PIPE_TEX_MIPFILTER_NONE)\n      return convert_mag_filter(filter);\n   else if (mip_filter == PIPE_TEX_MIPFILTER_LINEAR) {\n      if (filter == PIPE_TEX_FILTER_NEAREST)\n         return GL_NEAREST_MIPMAP_LINEAR;\n      else\n         return GL_LINEAR_MIPMAP_LINEAR;\n   } else if (mip_filter == PIPE_TEX_MIPFILTER_NEAREST) {\n      if (filter == PIPE_TEX_FILTER_NEAREST)\n         return GL_NEAREST_MIPMAP_NEAREST;\n      else\n         return GL_LINEAR_MIPMAP_NEAREST;\n   }\n   assert(0);\n   return 0;\n}\n",
        "output": "0",
        "index": 8796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void VideoCaptureImpl::StopCapture(int client_id) {\n  DCHECK(io_thread_checker_.CalledOnValidThread());\n  if (!RemoveClient(client_id, &clients_pending_on_restart_)) {\n    RemoveClient(client_id, &clients_);\n  }\n\n  if (!clients_.empty())\n    return;\n  DVLOG(1) << \"StopCapture: No more client, stopping ...\";\n  StopDevice();\n  client_buffers_.clear();\n  weak_factory_.InvalidateWeakPtrs();\n}\n",
        "output": "0",
        "index": 162202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebContents* WebContentsImpl::Clone() {\n  CreateParams create_params(GetBrowserContext(), GetSiteInstance());\n  create_params.initial_size = view_->GetContainerSize();\n  WebContentsImpl* tc = CreateWithOpener(create_params, opener_);\n  tc->GetController().CopyStateFrom(controller_);\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    DidCloneToNewWebContents(this, tc));\n  return tc;\n}\n",
        "output": "0",
        "index": 118821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CStarter::publishJobInfoAd(List<UserProc>* proc_list, ClassAd* ad)\n{\n\tbool found_one = false;\n\tif( pre_script && pre_script->PublishUpdateAd(ad) ) {\n\t\tfound_one = true;\n\t}\n\t\n\tif (m_deferred_job_update)\n\t{\n\t\tMyString buf;\n\t\tbuf.sprintf( \"%s=\\\"Exited\\\"\", ATTR_JOB_STATE );\n\t}\n\t\n\tUserProc *job;\n\tproc_list->Rewind();\n\twhile ((job = proc_list->Next()) != NULL) {\n\t\tif( job->PublishUpdateAd(ad) ) {\n\t\t\tfound_one = true;\n\t\t}\n\t}\n\tif( post_script && post_script->PublishUpdateAd(ad) ) {\n\t\tfound_one = true;\n\t}\n\treturn found_one;\n}\n",
        "output": "0",
        "index": 16430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_read_raw\t\t(SNDFILE *sndfile, void *ptr, sf_count_t bytes)\n{\tSF_PRIVATE \t*psf ;\n\tsf_count_t\tcount, extra ;\n\tint\t\t\tbytewidth, blockwidth ;\n\n\tVALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, 1) ;\n\n\tbytewidth = (psf->bytewidth > 0) ? psf->bytewidth : 1 ;\n\tblockwidth = (psf->blockwidth > 0) ? psf->blockwidth : 1 ;\n\n\tif (psf->file.mode == SFM_WRITE)\n\t{\tpsf->error = SFE_NOT_READMODE ;\n\t\treturn\t0 ;\n\t\t} ;\n\n\tif (bytes < 0 || psf->read_current >= psf->sf.frames)\n\t{\tpsf_memset (ptr, 0, bytes) ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (bytes % (psf->sf.channels * bytewidth))\n\t{\tpsf->error = SFE_BAD_READ_ALIGN ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif (psf->last_op != SFM_READ)\n\t\tif (psf->seek (psf, SFM_READ, psf->read_current) < 0)\n\t\t\treturn 0 ;\n\n\tcount = psf_fread (ptr, 1, bytes, psf) ;\n\n\tif (psf->read_current + count / blockwidth <= psf->sf.frames)\n\t\tpsf->read_current += count / blockwidth ;\n\telse\n\t{\tcount = (psf->sf.frames - psf->read_current) * blockwidth ;\n\t\textra = bytes - count ;\n\t\tpsf_memset (((char *) ptr) + count, 0, extra) ;\n\t\tpsf->read_current = psf->sf.frames ;\n\t\t} ;\n\n\tpsf->last_op = SFM_READ ;\n\n\treturn count ;\n} /* sf_read_raw */\n",
        "output": "0",
        "index": 95372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ImageTokenizer::createDocumentStructure()\n{\n    ExceptionCode ec;\n    \n    RefPtr<Element> rootElement = m_doc->createElementNS(xhtmlNamespaceURI, \"html\", ec);\n    m_doc->appendChild(rootElement, ec);\n    \n    RefPtr<Element> body = m_doc->createElementNS(xhtmlNamespaceURI, \"body\", ec);\n    body->setAttribute(styleAttr, \"margin: 0px;\");\n    \n    rootElement->appendChild(body, ec);\n    \n    RefPtr<Element> imageElement = m_doc->createElementNS(xhtmlNamespaceURI, \"img\", ec);\n    \n    m_imageElement = static_cast<HTMLImageElement *>(imageElement.get());\n    m_imageElement->setAttribute(styleAttr, \"-webkit-user-select: none\");        \n    m_imageElement->setLoadManually(true);\n    m_imageElement->setSrc(m_doc->URL());\n    \n    body->appendChild(imageElement, ec);    \n}\n",
        "output": "0",
        "index": 99395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void whiteheat_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tfirm_set_break(port, break_state);\n}\n",
        "output": "0",
        "index": 38096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n \t\tgoto out;\n \t}\n \n \tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n \t\tgoto out;\n \t}\n \n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n \t\tpte_t pte = *ptep;\n \n \t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n \t\telse if (pte_present(pte))\n \t\t\t*vec = 1;\n \t\telse { /* pte is a swap entry */\n \t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n \n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t/*\n\t\t\t\t * migration or hwpoison entries are always\n\t\t\t\t * uptodate\n\t\t\t\t */\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n \t\t}\n \t\tvec++;\n \t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}\n",
        "output": "1",
        "index": 182919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t PPB_URLLoader_Impl::FillUserBuffer() {\n  DCHECK(user_buffer_);\n  DCHECK(user_buffer_size_);\n\n  size_t bytes_to_copy = std::min(buffer_.size(), user_buffer_size_);\n  std::copy(buffer_.begin(), buffer_.begin() + bytes_to_copy, user_buffer_);\n  buffer_.erase(buffer_.begin(), buffer_.begin() + bytes_to_copy);\n\n  DCHECK(!is_asynchronous_load_suspended_ || request_info_);\n  if (is_asynchronous_load_suspended_ &&\n      buffer_.size() <= static_cast<size_t>(\n          request_info_->prefetch_buffer_lower_threshold())) {\n    DVLOG(1) << \"Resuming async load - buffer size: \" << buffer_.size();\n    loader_->setDefersLoading(false);\n    is_asynchronous_load_suspended_ = false;\n  }\n\n  user_buffer_ = NULL;\n  user_buffer_size_ = 0;\n  return bytes_to_copy;\n}\n",
        "output": "0",
        "index": 104883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void twofish_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\ttwofish_enc_blk(crypto_tfm_ctx(tfm), dst, src);\n}\n",
        "output": "0",
        "index": 47078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  tt_cmap0_validate( FT_Byte*      table,\n                     FT_Validator  valid )\n  {\n    FT_Byte*  p      = table + 2;\n    FT_UInt   length = TT_NEXT_USHORT( p );\n\n\n    if ( table + length > valid->limit || length < 262 )\n      FT_INVALID_TOO_SHORT;\n\n    /* check glyph indices whenever necessary */\n    if ( valid->level >= FT_VALIDATE_TIGHT )\n    {\n      FT_UInt  n, idx;\n\n\n      p = table + 6;\n      for ( n = 0; n < 256; n++ )\n      {\n        idx = *p++;\n        if ( idx >= TT_VALID_GLYPH_COUNT( valid ) )\n          FT_INVALID_GLYPH_ID;\n      }\n    }\n\n    return SFNT_Err_Ok;\n  }\n",
        "output": "0",
        "index": 4174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ConstrainedWidthView::ConstrainedWidthView(views::View* child, int max_width)\n    : max_width_(max_width) {\n  SetLayoutManager(std::make_unique<views::FillLayout>());\n  AddChildView(child);\n}\n",
        "output": "0",
        "index": 141898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::ByteAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_byteAttribute_Getter\");\n\n  test_object_v8_internal::ByteAttributeAttributeGetter(info);\n}\n",
        "output": "0",
        "index": 147222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors, bool use_integrity)\n{\n\tint status;\n\tstruct nfs4_secinfo_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors     = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct rpc_clnt *clnt = NFS_SERVER(dir)->client;\n\tstruct rpc_cred *cred = NULL;\n\n\tif (use_integrity) {\n\t\tclnt = NFS_SERVER(dir)->nfs_client->cl_rpcclient;\n\t\tcred = nfs4_get_clid_cred(NFS_SERVER(dir)->nfs_client);\n\t\tmsg.rpc_cred = cred;\n\t}\n\n\tdprintk(\"NFS call  secinfo %s\\n\", name->name);\n\n\tnfs4_state_protect(NFS_SERVER(dir)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_SECINFO, &clnt, &msg);\n\n\tstatus = nfs4_call_sync(clnt, NFS_SERVER(dir), &msg, &args.seq_args,\n\t\t\t\t&res.seq_res, 0);\n\tdprintk(\"NFS reply  secinfo: %d\\n\", status);\n\n\tif (cred)\n\t\tput_rpccred(cred);\n\n\treturn status;\n}\n",
        "output": "0",
        "index": 57063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SkiaOutputSurfaceImpl::ScheduleOutputSurfaceAsOverlay(\n    OverlayProcessor::OutputSurfaceOverlayPlane output_surface_plane) {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  auto callback = base::BindOnce(\n      &SkiaOutputSurfaceImplOnGpu::ScheduleOutputSurfaceAsOverlay,\n      base::Unretained(impl_on_gpu_.get()), std::move(output_surface_plane));\n  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n}\n",
        "output": "0",
        "index": 148664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::RemoveKeyboardListener(\n    KeyboardListener* listener) {\n  keyboard_listeners_.remove(listener);\n}\n",
        "output": "0",
        "index": 123036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ws_send_binary(nw_ses *ses, void *data, size_t size)\n{\n    return send_reply(ses, 0x2, data, size);\n}\n",
        "output": "0",
        "index": 76589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGLRenderingContextBase::ValidateCompressedTexFormat(\n    const char* function_name,\n    GLenum format) {\n  if (!compressed_texture_formats_.Contains(format)) {\n    SynthesizeGLError(GL_INVALID_ENUM, function_name, \"invalid format\");\n    return false;\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 146403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_enable_quotas(struct super_block *sb)\n{\n\tint type, err = 0;\n\tunsigned long qf_inums[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)\n\t};\n\n\tsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;\n\tfor (type = 0; type < EXT4_MAXQUOTAS; type++) {\n\t\tif (qf_inums[type]) {\n\t\t\terr = ext4_quota_enable(sb, type, QFMT_VFS_V1,\n\t\t\t\t\t\tDQUOT_USAGE_ENABLED);\n\t\t\tif (err) {\n\t\t\t\text4_warning(sb,\n\t\t\t\t\t\"Failed to enable quota tracking \"\n\t\t\t\t\t\"(type=%d, err=%d). Please run \"\n\t\t\t\t\t\"e2fsck to fix.\", type, err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 94984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " _dbus_header_byteswap (DBusHeader *header,\n                        int         new_order)\n {\n   if (header->byte_order == new_order)\n     return;\n \n   _dbus_marshal_byteswap (&_dbus_header_signature_str,\n                           0, header->byte_order,\n                           new_order,\n                           &header->data, 0);\n \n   header->byte_order = new_order;\n }\n",
        "output": "1",
        "index": 177858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void SwapPreferredSizeTo(bool use_a) {\n    if (use_a)\n      SetPreferredSize(a_);\n    else\n      SetPreferredSize(b_);\n  }\n",
        "output": "0",
        "index": 144221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_proc_renew(struct nfs_client *clp, struct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tunsigned long now = jiffies;\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\tif (status < 0)\n\t\treturn status;\n\tdo_renew_lease(clp, now);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 57213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_mount(const struct lxc_rootfs *rootfs, const char *fstab,\n\tconst char *lxc_name)\n{\n\tFILE *file;\n\tint ret;\n\n\tif (!fstab)\n\t\treturn 0;\n\n\tfile = setmntent(fstab, \"r\");\n\tif (!file) {\n\t\tSYSERROR(\"failed to use '%s'\", fstab);\n\t\treturn -1;\n\t}\n\n\tret = mount_file_entries(rootfs, file, lxc_name);\n\n\tendmntent(file);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 44639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string_tolower (char *string)\n{\n    while (string && string[0])\n    {\n        if ((string[0] >= 'A') && (string[0] <= 'Z'))\n            string[0] += ('a' - 'A');\n        string = utf8_next_char (string);\n    }\n}\n",
        "output": "0",
        "index": 7337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OMX::binderDied(const wp<IBinder> &the_late_who) {\n OMXNodeInstance *instance;\n\n {\n\n         Mutex::Autolock autoLock(mLock);\n \n         ssize_t index = mLiveNodes.indexOfKey(the_late_who);\n        CHECK(index >= 0);\n \n         instance = mLiveNodes.editValueAt(index);\n         mLiveNodes.removeItemsAt(index);\n\n        index = mDispatchers.indexOfKey(instance->nodeID());\n        CHECK(index >= 0);\n        mDispatchers.removeItemsAt(index);\n\n        invalidateNodeID_l(instance->nodeID());\n }\n\n    instance->onObserverDied(mMaster);\n}\n",
        "output": "1",
        "index": 187903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void destroy_phar_data_only(zval *zv) /* {{{ */\n{\n\tphar_archive_data *phar_data = (phar_archive_data *) Z_PTR_P(zv);\n\n\tif (EG(exception) || --phar_data->refcount < 0) {\n\t\tphar_destroy_phar_data(phar_data);\n\t}\n}\n/* }}}*/\n",
        "output": "0",
        "index": 11105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "scoped_refptr<base::FieldTrial> CreateFieldTrial(\n    const std::string& trial_name,\n    int total_probability,\n    const std::string& default_group_name,\n    int* default_group_number) {\n  return FieldTrialList::FactoryGetFieldTrial(\n      trial_name, total_probability, default_group_name,\n      base::FieldTrialList::kNoExpirationYear, 1, 1,\n      base::FieldTrial::SESSION_RANDOMIZED, default_group_number);\n}\n",
        "output": "0",
        "index": 119120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CronTab::~CronTab() {\n\tint ctr;\n\tfor ( ctr = 0; ctr < CRONTAB_FIELDS; ctr++ ) {\n\t\tif ( this->ranges[ctr] )\t\tdelete this->ranges[ctr];\n\t\tif ( this->parameters[ctr] )\tdelete this->parameters[ctr];\n\t} // FOR\n}\n",
        "output": "0",
        "index": 16549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TabStrip::~TabStrip() {\n  StopAnimating(false);\n\n  drag_context_->DestroyDragController();\n\n  RemoveMessageLoopObserver();\n\n  RemoveAllChildViews(true);\n}\n",
        "output": "0",
        "index": 153510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __net_init ip_tables_net_init(struct net *net)\n{\n\treturn xt_proto_init(net, NFPROTO_IPV4);\n}\n",
        "output": "0",
        "index": 52309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FlagsState::SetExperimentEnabled(\n    PrefService* prefs, const std::string& internal_name, bool enable) {\n  needs_restart_ = true;\n\n  size_t at_index = internal_name.find(about_flags::testing::kMultiSeparator);\n  if (at_index != std::string::npos) {\n    DCHECK(enable);\n    DCHECK_NE(at_index, 0u);\n    const std::string experiment_name = internal_name.substr(0, at_index);\n    SetExperimentEnabled(prefs, experiment_name, false);\n\n    if (internal_name != experiment_name + \"@0\") {\n      std::set<std::string> enabled_experiments;\n      GetSanitizedEnabledFlags(prefs, &enabled_experiments);\n      enabled_experiments.insert(internal_name);\n      SetEnabledFlags(prefs, enabled_experiments);\n    }\n    return;\n  }\n\n  std::set<std::string> enabled_experiments;\n  GetSanitizedEnabledFlags(prefs, &enabled_experiments);\n\n  const Experiment* e = NULL;\n  for (size_t i = 0; i < num_experiments; ++i) {\n    if (experiments[i].internal_name == internal_name) {\n      e = experiments + i;\n      break;\n    }\n  }\n  DCHECK(e);\n\n  if (e->type == Experiment::SINGLE_VALUE) {\n    if (enable)\n      enabled_experiments.insert(internal_name);\n    else\n      enabled_experiments.erase(internal_name);\n  } else {\n    if (enable) {\n      enabled_experiments.insert(NameForChoice(*e, 0));\n    } else {\n      for (int i = 0; i < e->num_choices; ++i) {\n        std::string choice_name = NameForChoice(*e, i);\n        if (enabled_experiments.find(choice_name) !=\n            enabled_experiments.end()) {\n          enabled_experiments.erase(choice_name);\n        }\n      }\n    }\n  }\n\n  SetEnabledFlags(prefs, enabled_experiments);\n}\n",
        "output": "0",
        "index": 111771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void classAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::classAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 131274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\t__vmcs_writel(field, value);\n}\n",
        "output": "0",
        "index": 48104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ExtensionOptionsGuest::IsPreferredSizeModeEnabled() const {\n  return true;\n}\n",
        "output": "0",
        "index": 145660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ne2000_mem_writeb(NE2000State *s, uint32_t addr,\n                                     uint32_t val)\n{\n    if (addr < 32 ||\n        (addr >= NE2000_PMEM_START && addr < NE2000_MEM_SIZE)) {\n        s->mem[addr] = val;\n    }\n}\n",
        "output": "0",
        "index": 12576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "send_msg(struct sshbuf *m)\n{\n\tint r;\n\n\tif ((r = sshbuf_put_stringb(oqueue, m)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tsshbuf_reset(m);\n}\n",
        "output": "0",
        "index": 60378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TabStrip::FileSupported(const GURL& url, bool supported) {\n  if (drop_info_.get() && drop_info_->url == url)\n    drop_info_->file_supported = supported;\n}\n",
        "output": "0",
        "index": 134331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FloatSize HTMLCanvasElement::ElementSize(const FloatSize&) const {\n  if (context_ && HasImageBitmapContext()) {\n    scoped_refptr<Image> image = context_->GetImage(kPreferNoAcceleration);\n    if (image)\n      return FloatSize(image->width(), image->height());\n    return FloatSize(0, 0);\n  }\n  if (PlaceholderFrame())\n    return FloatSize(PlaceholderFrame()->Size());\n  return FloatSize(width(), height());\n}\n",
        "output": "0",
        "index": 164994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::vector<gfx::Image> GetImagesForAccounts(\n    const std::vector<AccountInfo>& accounts,\n    Profile* profile) {\n  AccountTrackerService* tracker_service =\n      AccountTrackerServiceFactory::GetForProfile(profile);\n  std::vector<gfx::Image> images;\n  for (auto account : accounts) {\n    images.push_back(tracker_service->GetAccountImage(account.account_id));\n  }\n  return images;\n}\n",
        "output": "0",
        "index": 155891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HomePageUndoBubble::WindowClosing() {\n  DCHECK_EQ(this, home_page_undo_bubble_);\n  home_page_undo_bubble_ = NULL;\n}\n",
        "output": "0",
        "index": 134478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_spurious_interrupt_bug(struct pt_regs *regs, long error_code)\n{\n\tconditional_sti(regs);\n#if 0\n\t/* No need to warn about this any longer. */\n\tpr_info(\"Ignoring P6 Local APIC Spurious Interrupt Bug...\\n\");\n#endif\n}\n",
        "output": "0",
        "index": 35417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double filter_bicubic(const double t)\n{\n\tconst double abs_t = (double)fabs(t);\n\tconst double abs_t_sq = abs_t * abs_t;\n\tif (abs_t<1) return 1-2*abs_t_sq+abs_t_sq*abs_t;\n\tif (abs_t<2) return 4 - 8*abs_t +5*abs_t_sq - abs_t_sq*abs_t;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 56316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CommandBufferProxyImpl::OnUpdateVSyncParameters(base::TimeTicks timebase,\n                                                     base::TimeDelta interval) {\n  DCHECK(!gl::IsPresentationCallbackEnabled());\n  if (!update_vsync_parameters_completion_callback_.is_null())\n    update_vsync_parameters_completion_callback_.Run(timebase, interval);\n}\n",
        "output": "0",
        "index": 162280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 65586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_write_cached_acl(struct inode *inode, const char *buf, size_t acl_len)\n{\n\tstruct nfs4_cached_acl *acl;\n\n\tif (buf && acl_len <= PAGE_SIZE) {\n\t\tacl = kmalloc(sizeof(*acl) + acl_len, GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 1;\n\t\tmemcpy(acl->data, buf, acl_len);\n\t} else {\n\t\tacl = kmalloc(sizeof(*acl), GFP_KERNEL);\n\t\tif (acl == NULL)\n\t\t\tgoto out;\n\t\tacl->cached = 0;\n\t}\n\tacl->len = acl_len;\nout:\n \tnfs4_set_cached_acl(inode, acl);\n }\n",
        "output": "0",
        "index": 23248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ShelfLayoutManager::State::State()\n    : visibility_state(SHELF_VISIBLE),\n      auto_hide_state(SHELF_AUTO_HIDE_HIDDEN),\n      window_state(wm::WORKSPACE_WINDOW_STATE_DEFAULT),\n      pre_lock_screen_animation_active(false),\n      session_state(session_manager::SessionState::UNKNOWN) {}\n",
        "output": "0",
        "index": 142486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoBufferData(GLenum target,\n                                                       GLsizeiptr size,\n                                                       const void* data,\n                                                       GLenum usage) {\n  CheckErrorCallbackState();\n  api()->glBufferDataFn(target, size, data, usage);\n  if (CheckErrorCallbackState()) {\n    return error::kNoError;\n  }\n\n  resources_->mapped_buffer_map.erase(bound_buffers_[target]);\n\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 154582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MessageService::~MessageService() {\n  STLDeleteContainerPairSecondPointers(channels_.begin(), channels_.end());\n  channels_.clear();\n}\n",
        "output": "0",
        "index": 124354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionSettingsHandler::GetActivePagesForExtensionProcess(\n    const std::set<RenderViewHost*>& views,\n    std::vector<ExtensionPage> *result) {\n  for (std::set<RenderViewHost*>::const_iterator iter = views.begin();\n       iter != views.end(); ++iter) {\n    RenderViewHost* host = *iter;\n    int host_type = host->delegate()->GetRenderViewType();\n    if (host == deleting_rvh_ ||\n        chrome::VIEW_TYPE_EXTENSION_POPUP == host_type ||\n        chrome::VIEW_TYPE_EXTENSION_DIALOG == host_type)\n      continue;\n\n    GURL url = host->delegate()->GetURL();\n    content::RenderProcessHost* process = host->process();\n    result->push_back(\n        ExtensionPage(url, process->GetID(), host->routing_id(),\n                      process->GetBrowserContext()->IsOffTheRecord()));\n  }\n}\n",
        "output": "0",
        "index": 116058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int softnet_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct netif_rx_stats *s = v;\n\n\tseq_printf(seq, \"%08x %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\t   s->total, s->dropped, s->time_squeeze, 0,\n\t\t   0, 0, 0, 0, /* was fastroute */\n\t\t   s->cpu_collision);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 32231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PHP_METHOD(PDOStatement, rowCount)\n{\n\tPHP_STMT_GET_OBJ;\n\n\tRETURN_LONG(stmt->row_count);\n}\n",
        "output": "0",
        "index": 72394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebContentsImpl::NavigateToEntry(\n    const NavigationEntryImpl& entry,\n    NavigationController::ReloadType reload_type) {\n  TRACE_EVENT0(\"browser\", \"WebContentsImpl::NavigateToEntry\");\n\n  if (entry.GetURL().spec().size() > kMaxURLChars) {\n    LOG(WARNING) << \"Refusing to load URL as it exceeds \" << kMaxURLChars\n                 << \" characters.\";\n    return false;\n  }\n\n  RenderViewHostImpl* dest_render_view_host =\n      static_cast<RenderViewHostImpl*>(render_manager_.Navigate(entry));\n  if (!dest_render_view_host)\n    return false;  // Unable to create the desired render view host.\n\n  int enabled_bindings = dest_render_view_host->GetEnabledBindings();\n  bool data_urls_allowed = delegate_ && delegate_->CanLoadDataURLsInWebUI();\n  bool is_allowed_in_web_ui_renderer =\n      WebUIControllerFactoryRegistry::GetInstance()->IsURLAcceptableForWebUI(\n          GetBrowserContext(), entry.GetURL(), data_urls_allowed);\n  if ((enabled_bindings & BINDINGS_POLICY_WEB_UI) &&\n      !is_allowed_in_web_ui_renderer) {\n    GetContentClient()->SetActiveURL(entry.GetURL());\n    CHECK(0);\n  }\n\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    AboutToNavigateRenderView(dest_render_view_host));\n\n  current_load_start_ = base::TimeTicks::Now();\n\n  ViewMsg_Navigate_Params navigate_params;\n  MakeNavigateParams(entry, controller_, delegate_, reload_type,\n                     &navigate_params);\n  dest_render_view_host->Navigate(navigate_params);\n\n  if (entry.GetPageID() == -1) {\n    if (entry.GetURL().SchemeIs(kJavaScriptScheme))\n      return false;\n  }\n\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    NavigateToPendingEntry(entry.GetURL(), reload_type));\n\n  if (delegate_)\n    delegate_->DidNavigateToPendingEntry(this);\n\n  return true;\n}\n",
        "output": "0",
        "index": 118958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ipa_region_paint(wmfAPI * API, wmfPolyRectangle_t * poly_rect)\n{\n\n  if (poly_rect->count == 0)\n    return;\n\n  /* Save graphic wand */\n  (void) PushDrawingWand(WmfDrawingWand);\n\n  if (TO_FILL (poly_rect))\n    {\n      long\n        i;\n\n      draw_stroke_color_string(WmfDrawingWand,\"none\");\n      util_set_brush(API, poly_rect->dc, BrushApplyFill);\n\n      for (i = 0; i < (long) poly_rect->count; i++)\n        {\n          DrawRectangle(WmfDrawingWand,\n                         XC(poly_rect->TL[i].x), YC(poly_rect->TL[i].y),\n                         XC(poly_rect->BR[i].x), YC(poly_rect->BR[i].y));\n        }\n    }\n\n  /* Restore graphic wand */\n  (void) PopDrawingWand(WmfDrawingWand);\n}\n",
        "output": "0",
        "index": 71836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderPassthroughImpl::BindPendingImagesForSamplers() {\n  for (TexturePendingBinding& pending : textures_pending_binding_)\n    BindOnePendingImage(pending.target, pending.texture.get());\n\n  textures_pending_binding_.clear();\n}\n",
        "output": "0",
        "index": 154421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_read_raw_data(cinfo,data,max_lines);\n\t\treturn 1;\n\t}\n}\n",
        "output": "0",
        "index": 70327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}\n",
        "output": "0",
        "index": 45386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CurrentHistoryCleaner::DidStopLoading(\n    content::RenderViewHost* render_view_host) {\n  content::NavigationController& nc = web_contents()->GetController();\n  if (history_index_to_remove_ < nc.GetLastCommittedEntryIndex()) {\n    nc.RemoveEntryAtIndex(history_index_to_remove_);\n    delete this;  /* success */\n  }\n}\n",
        "output": "0",
        "index": 120839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_xdr_enc_remove(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst struct nfs_removeargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_remove(xdr, &args->name, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}\n",
        "output": "0",
        "index": 23487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gstd_get_mech(gss_OID mech_oid)\n{\n#ifdef HAVE_GSS_OID_TO_STR\n\tOM_uint32\tmaj;\n\tOM_uint32\tmin;\n#endif\n\tgss_buffer_desc\tbuf;\n\tunsigned char   *bufp;\n\tunsigned char   nibble;\n\tchar\t\t*ret;\n\tsize_t\t\ti, k;\n\n\tif (mech_oid->length == sizeof(KNC_KRB5_MECH_OID) - 1 &&\n\t    memcmp(mech_oid->elements, KNC_KRB5_MECH_OID,\n\t\t   sizeof(KNC_KRB5_MECH_OID) - 1) == 0) {\n\t\tif ((ret = strdup(\"krb5\")) == NULL) {\n\t\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ret;\n\t}\n\n#ifdef HAVE_GSS_OID_TO_STR\n\tmaj = gss_oid_to_str(&min, mech_oid, &buf);\n\tif (maj != GSS_S_COMPLETE) {\n\t\tLOG(LOG_ERR, (\"unable to display mechanism OID\"));\n\t\treturn NULL;\n\t}\n\tret = strndup(buf.value, buf.length);\n#else\n\tret = strdup(\"\");\n#endif\n\tif (!ret)\n\t\tLOG(LOG_ERR, (\"unable to malloc\"));\n\treturn ret;\n}\n",
        "output": "0",
        "index": 86475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_feature_set_ok(struct super_block *sb, int readonly)\n{\n\tif (EXT4_HAS_INCOMPAT_FEATURE(sb, ~EXT4_FEATURE_INCOMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR,\n\t\t\t\"Couldn't mount because of \"\n\t\t\t\"unsupported optional features (%x)\",\n\t\t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_incompat) &\n\t\t\t~EXT4_FEATURE_INCOMPAT_SUPP));\n\t\treturn 0;\n\t}\n\n\tif (readonly)\n\t\treturn 1;\n\n\t/* Check that feature set is OK for a read-write mount */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, ~EXT4_FEATURE_RO_COMPAT_SUPP)) {\n\t\text4_msg(sb, KERN_ERR, \"couldn't mount RDWR because of \"\n\t\t\t \"unsupported optional features (%x)\",\n\t\t\t (le32_to_cpu(EXT4_SB(sb)->s_es->s_feature_ro_compat) &\n\t\t\t\t~EXT4_FEATURE_RO_COMPAT_SUPP));\n\t\treturn 0;\n\t}\n\t/*\n\t * Large file size enabled file system can only be mounted\n\t * read-write on 32-bit systems if kernel is built with CONFIG_LBDAF\n\t */\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_HUGE_FILE)) {\n\t\tif (sizeof(blkcnt_t) < sizeof(u64)) {\n\t\t\text4_msg(sb, KERN_ERR, \"Filesystem with huge files \"\n\t\t\t\t \"cannot be mounted RDWR without \"\n\t\t\t\t \"CONFIG_LBDAF\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n",
        "output": "0",
        "index": 26938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "call_refresh(struct rpc_task *task)\n{\n\tdprint_status(task);\n\n\ttask->tk_action = call_refreshresult;\n\ttask->tk_status = 0;\n\ttask->tk_client->cl_stats->rpcauthrefresh++;\n\trpcauth_refreshcred(task);\n}\n",
        "output": "0",
        "index": 34884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::RectF RenderViewImpl::ElementBoundsInWindow(\n    const blink::WebElement& element) {\n  blink::WebRect bounding_box_in_window = element.BoundsInViewport();\n  WidgetClient()->ConvertViewportToWindow(&bounding_box_in_window);\n  return gfx::RectF(bounding_box_in_window);\n}\n",
        "output": "0",
        "index": 157921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const Vector<double>& BaseRenderingContext2D::getLineDash() const {\n  return GetState().LineDash();\n}\n",
        "output": "0",
        "index": 162735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DiskCacheBackendTest::BackendTrimInvalidEntry2() {\n  SetMask(0xf);  // 16-entry table.\n\n  const int kSize = 0x3000;  // 12 kB\n  SetMaxSize(kSize * 40);\n  InitCache();\n\n  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(kSize));\n  memset(buffer->data(), 0, kSize);\n  disk_cache::Entry* entry;\n\n  for (int i = 0; i < 32; i++) {\n    std::string key(base::StringPrintf(\"some key %d\", i));\n    ASSERT_THAT(CreateEntry(key, &entry), IsOk());\n    EXPECT_EQ(kSize, WriteData(entry, 0, 0, buffer.get(), kSize, false));\n    entry->Close();\n    ASSERT_THAT(OpenEntry(key, &entry), IsOk());\n  }\n\n  SimulateCrash();\n\n  ASSERT_THAT(CreateEntry(\"Something else\", &entry), IsOk());\n  EXPECT_EQ(kSize, WriteData(entry, 0, 0, buffer.get(), kSize, false));\n\n  FlushQueueForTest();\n  EXPECT_EQ(33, cache_->GetEntryCount());\n  SetMaxSize(kSize);\n\n  if (new_eviction_) {\n    EXPECT_THAT(DoomAllEntries(), IsOk());\n  }\n\n  entry->Close();  // Trim the cache.\n  FlushQueueForTest();\n\n  base::RunLoop().RunUntilIdle();\n  FlushQueueForTest();\n  ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN();\n  EXPECT_GE(30, cache_->GetEntryCount());\n  ANNOTATE_IGNORE_READS_AND_WRITES_END();\n\n  size_ = 0;\n}\n",
        "output": "0",
        "index": 159993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void check_class_changed(struct rq *rq, struct task_struct *p,\n\t\t\t\t       const struct sched_class *prev_class,\n\t\t\t\t       int oldprio)\n{\n\tif (prev_class != p->sched_class) {\n\t\tif (prev_class->switched_from)\n\t\t\tprev_class->switched_from(rq, p);\n\t\tp->sched_class->switched_to(rq, p);\n\t} else if (oldprio != p->prio || dl_task(p))\n\t\tp->sched_class->prio_changed(rq, p, oldprio);\n}\n",
        "output": "0",
        "index": 58135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint16_t full_header_get_msg_type(SpiceDataHeaderOpaque *header)\n{\n    return ((SpiceDataHeader *)header->data)->type;\n}\n",
        "output": "0",
        "index": 2062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\n\tstruct xfrm_userpolicy_info *p = &up->pol;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err = -ENOENT;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir,\n\t\t\t\t\t   &p->sel, ctx, 0, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (unlikely(xp->walk.dead))\n\t\tgoto out;\n\n\terr = 0;\n\tif (up->hard) {\n\t\txfrm_policy_delete(xp, p->dir);\n\t\txfrm_audit_policy_delete(xp, 1, true);\n\t}\n\tkm_policy_expired(xp, p->dir, up->hard, nlh->nlmsg_pid);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n",
        "output": "0",
        "index": 59349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cdrom_ram_open_write(struct cdrom_device_info *cdi)\n{\n\tstruct rwrt_feature_desc rfd;\n\tint ret;\n\n\tif ((ret = cdrom_has_defect_mgt(cdi)))\n\t\treturn ret;\n\n\tif ((ret = cdrom_get_random_writable(cdi, &rfd)))\n\t\treturn ret;\n\telse if (CDF_RWRT == be16_to_cpu(rfd.feature_code))\n\t\tret = !rfd.curr;\n\n\tcd_dbg(CD_OPEN, \"can open for random write\\n\");\n\treturn ret;\n}\n",
        "output": "0",
        "index": 76265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Element::setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool flag)\n{\n    Element* element = this;\n    while ((element = parentCrossingFrameBoundaries(element)))\n        element->setContainsFullScreenElement(flag);\n}\n",
        "output": "0",
        "index": 120641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 normalize_cfs_quota(struct task_group *tg,\n\t\t\t       struct cfs_schedulable_data *d)\n{\n\tu64 quota, period;\n\n\tif (tg == d->tg) {\n\t\tperiod = d->period;\n\t\tquota = d->quota;\n\t} else {\n\t\tperiod = tg_get_cfs_period(tg);\n\t\tquota = tg_get_cfs_quota(tg);\n\t}\n\n\t/* note: these should typically be equivalent */\n\tif (quota == RUNTIME_INF || quota == -1)\n\t\treturn RUNTIME_INF;\n\n\treturn to_ratio(period, quota);\n}\n",
        "output": "0",
        "index": 55564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void address_space_stw_le(AddressSpace *as, hwaddr addr, uint32_t val,\n                       MemTxAttrs attrs, MemTxResult *result)\n{\n    address_space_stw_internal(as, addr, val, attrs, result,\n                               DEVICE_LITTLE_ENDIAN);\n}\n",
        "output": "0",
        "index": 14313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StyleResolver::matchUARules(ElementRuleCollector& collector, RuleSet* rules)\n{\n    collector.clearMatchedRules();\n    collector.matchedResult().ranges.lastUARule = collector.matchedResult().matchedProperties.size() - 1;\n\n    RuleRange ruleRange = collector.matchedResult().ranges.UARuleRange();\n    collector.collectMatchingRules(MatchRequest(rules), ruleRange);\n\n    collector.sortAndTransferMatchedRules();\n}\n",
        "output": "0",
        "index": 127395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void DeleteFromArguments(Handle<JSObject> obj, uint32_t entry) {\n Handle<FixedArray> parameter_map(FixedArray::cast(obj->elements()));\n Handle<SeededNumberDictionary> dict(\n SeededNumberDictionary::cast(parameter_map->get(1)));\n uint32_t index = GetIndexForEntryImpl(*dict, entry);\n Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);\n    USE(result);\n    DCHECK(result->IsTrue(dict->GetIsolate()));\n Handle<FixedArray> new_elements =\n SeededNumberDictionary::Shrink(dict, index);\n    parameter_map->set(1, *new_elements);\n }\n",
        "output": "0",
        "index": 176237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool AddCallback(GetUsageAndQuotaCallback* callback, bool unlimited) {\n    if (unlimited)\n      unlimited_callbacks_.push_back(callback);\n    else\n      callbacks_.push_back(callback);\n    return (callbacks_.size() + unlimited_callbacks_.size() == 1);\n  }\n",
        "output": "0",
        "index": 100986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ppp_find_channel(struct ppp_net *pn, int unit)\n{\n\tstruct channel *pch;\n\n\tlist_for_each_entry(pch, &pn->new_channels, list) {\n\t\tif (pch->file.index == unit) {\n\t\t\tlist_move(&pch->list, &pn->all_channels);\n\t\t\treturn pch;\n\t\t}\n\t}\n\n\tlist_for_each_entry(pch, &pn->all_channels, list) {\n\t\tif (pch->file.index == unit)\n\t\t\treturn pch;\n\t}\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 52627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ptaaAddPt(PTAA      *ptaa,\n          l_int32    ipta,\n          l_float32  x,\n          l_float32  y)\n{\nPTA  *pta;\n\n    PROCNAME(\"ptaaAddPt\");\n\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (ipta < 0 || ipta >= ptaa->n)\n        return ERROR_INT(\"index ipta not valid\", procName, 1);\n\n    pta = ptaaGetPta(ptaa, ipta, L_CLONE);\n    ptaAddPt(pta, x, y);\n    ptaDestroy(&pta);\n    return 0;\n}\n",
        "output": "0",
        "index": 84185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_read_comp_null (gnutls_session_t session)\n{\n  record_parameters_st *record_params;\n\n  _gnutls_epoch_get (session, EPOCH_READ_CURRENT, &record_params);\n  if (record_params->compression_algorithm == GNUTLS_COMP_NULL)\n    return 0;\n\n  return 1;\n}\n",
        "output": "0",
        "index": 11312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Local<v8::FunctionTemplate> V8TestInterfaceNode::domTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world)\n{\n    return V8DOMConfiguration::domClassTemplate(isolate, world, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8TestInterfaceNodeTemplate);\n}\n",
        "output": "0",
        "index": 127671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PGTYPESdate_free(date * d)\n{\n\tfree(d);\n}\n",
        "output": "0",
        "index": 40040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PageInfoWindowGtk::ModelChanged() {\n  InitContents();\n}\n",
        "output": "0",
        "index": 99036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SWFShape_setLineStyle_internal(SWFShape shape, unsigned short width,\n                      byte r, byte g, byte b, byte a)\n{\n\tint line;\n\t\t\n\tif ( shape->isEnded )\n\t\treturn;\n\t\n\tfor ( line=0; line<shape->nLines; ++line )\n\t{\n\t\tif ( SWFLineStyle_equals(shape->lines[line], width, r, g, b, a, 0) )\n\t\t\tbreak;\n\t}\n\n\tif ( line == shape->nLines )\n\t\tline = SWFShape_addLineStyle(shape, width, r, g, b, a);\n\telse\n\t\t++line;\n\t\n\tfinishSetLine(shape, line, width);\n}\n",
        "output": "0",
        "index": 89523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void activityLoggedAttrGetter1AttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    V8PerContextData* contextData = V8PerContextData::from(info.GetIsolate()->GetCurrentContext());\n    if (contextData && contextData->activityLogger())\n        contextData->activityLogger()->log(\"TestObject.activityLoggedAttrGetter1\", 0, 0, \"Getter\");\n    TestObjectV8Internal::activityLoggedAttrGetter1AttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 130577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebView::windowReceivedMessage(HWND, UINT message, WPARAM wParam, LPARAM)\n{\n    switch (message) {\n    case WM_NCACTIVATE:\n        updateActiveStateSoon();\n        break;\n    case WM_SETTINGCHANGE:\n        break;\n    }\n}\n",
        "output": "0",
        "index": 106778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtr<Range> findPlainText(const Range* range, const String& target, FindOptions options)\n{\n    range->ownerDocument()->updateLayout();\n\n    size_t matchStart;\n    size_t matchLength;\n    {\n        CharacterIterator findIterator(range, TextIteratorEntersTextControls);\n        matchLength = findPlainText(findIterator, target, options, matchStart);\n        if (!matchLength)\n            return collapsedToBoundary(range, !(options & Backwards));\n    }\n\n    CharacterIterator computeRangeIterator(range, TextIteratorEntersTextControls);\n    return characterSubrange(computeRangeIterator, matchStart, matchLength);\n}\n",
        "output": "0",
        "index": 121593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *CL_RefMallocDebug( int size, char *label, char *file, int line ) {\n\treturn Z_TagMallocDebug( size, TAG_RENDERER, label, file, line );\n}\n",
        "output": "0",
        "index": 95704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::ExecuteJavaScript(const base::string16& javascript) {\n  OnJavaScriptExecuteRequest(javascript, 0, false);\n}\n",
        "output": "0",
        "index": 118405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pmcraid_expose_resource(u16 fw_version,\n\t\t\t\t   struct pmcraid_config_table_entry *cfgte)\n{\n\tint retval = 0;\n\n\tif (cfgte->resource_type == RES_TYPE_VSET) {\n\t\tif (fw_version <= PMCRAID_FW_VERSION_1)\n\t\t\tretval = ((cfgte->unique_flags1 & 0x80) == 0);\n\t\telse\n\t\t\tretval = ((cfgte->unique_flags0 & 0x80) == 0 &&\n\t\t\t\t  (cfgte->unique_flags1 & 0x80) == 0);\n\n\t} else if (cfgte->resource_type == RES_TYPE_GSCSI)\n\t\tretval = (RES_BUS(cfgte->resource_address) !=\n\t\t\t\tPMCRAID_VIRTUAL_ENCL_BUS_ID);\n\treturn retval;\n}\n",
        "output": "0",
        "index": 26441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2Implementation::StencilThenCoverFillPathInstancedCHROMIUM(\n    GLsizei num_paths,\n    GLenum path_name_type,\n    const GLvoid* paths,\n    GLuint path_base,\n    GLenum fill_mode,\n    GLuint mask,\n    GLenum cover_mode,\n    GLenum transform_type,\n    const GLfloat* transform_values) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\n      \"[\" << GetLogPrefix() << \"] glStencilThenCoverFillPathInstancedCHROMIUM(\"\n          << num_paths << \", \" << path_name_type << \", \" << paths << \", \"\n          << path_base << \", \" << cover_mode << \", \" << fill_mode << \", \"\n          << mask << \", \" << transform_type << \", \" << transform_values << \")\");\n\n  ScopedTransferBufferPtr buffer(helper_, transfer_buffer_);\n  uint32_t paths_shm_id = 0;\n  uint32_t paths_offset = 0;\n  uint32_t transforms_shm_id = 0;\n  uint32_t transforms_offset = 0;\n  if (!PrepareInstancedPathCommand(\n          \"glStencilThenCoverFillPathInstancedCHROMIUM\", num_paths,\n          path_name_type, paths, transform_type, transform_values, &buffer,\n          &paths_shm_id, &paths_offset, &transforms_shm_id,\n          &transforms_offset)) {\n    return;\n  }\n\n  helper_->StencilThenCoverFillPathInstancedCHROMIUM(\n      num_paths, path_name_type, paths_shm_id, paths_offset, path_base,\n      fill_mode, mask, cover_mode, transform_type, transforms_shm_id,\n      transforms_offset);\n\n  CheckGLError();\n}\n",
        "output": "0",
        "index": 153819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderProcessHostPrivilege GetPrivilegeRequiredByUrl(\n    const GURL& url,\n    ExtensionRegistry* registry) {\n  if (!url.is_valid())\n    return PRIV_NORMAL;\n\n  if (!url.SchemeIs(kExtensionScheme))\n    return PRIV_NORMAL;\n\n  const Extension* extension =\n      registry->enabled_extensions().GetByID(url.host());\n  if (extension && AppIsolationInfo::HasIsolatedStorage(extension))\n    return PRIV_ISOLATED;\n  if (extension && extension->is_hosted_app())\n    return PRIV_HOSTED;\n  return PRIV_EXTENSION;\n}\n",
        "output": "0",
        "index": 163809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ActivityLoggingAccessForAllWorldsLongAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueInt(info, impl->activityLoggingAccessForAllWorldsLongAttribute());\n}\n",
        "output": "0",
        "index": 147143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void OnGetDocument(std::unique_ptr<dom::GetDocumentResult> result) {\n    devtools_client_->GetDOM()->QuerySelector(\n        dom::QuerySelectorParams::Builder()\n            .SetNodeId(result->GetRoot()->GetNodeId())\n            .SetSelector(\"<o_O>\")\n            .Build(),\n        base::BindOnce(&HeadlessDevToolsMethodCallErrorTest::OnQuerySelector,\n                       base::Unretained(this)));\n  }\n",
        "output": "0",
        "index": 157571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IndexedDBConnection::VersionChangeIgnored() {\n  if (!database_.get())\n    return;\n  database_->VersionChangeIgnored();\n}\n",
        "output": "0",
        "index": 149340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long vhost_dev_set_owner(struct vhost_dev *dev)\n{\n\tstruct task_struct *worker;\n\tint err;\n\n\t/* Is there an owner already? */\n\tif (dev->mm) {\n\t\terr = -EBUSY;\n\t\tgoto err_mm;\n\t}\n\n\t/* No owner, become one */\n\tdev->mm = get_task_mm(current);\n\tworker = kthread_create(vhost_worker, dev, \"vhost-%d\", current->pid);\n\tif (IS_ERR(worker)) {\n\t\terr = PTR_ERR(worker);\n\t\tgoto err_worker;\n\t}\n\n\tdev->worker = worker;\n\twake_up_process(worker);\t/* avoid contributing to loadavg */\n\n\terr = vhost_attach_cgroups(dev);\n\tif (err)\n\t\tgoto err_cgroup;\n\n\terr = vhost_dev_alloc_iovecs(dev);\n\tif (err)\n\t\tgoto err_cgroup;\n\n\treturn 0;\nerr_cgroup:\n\tkthread_stop(worker);\n\tdev->worker = NULL;\nerr_worker:\n\tif (dev->mm)\n\t\tmmput(dev->mm);\n\tdev->mm = NULL;\nerr_mm:\n\treturn err;\n}\n",
        "output": "0",
        "index": 33787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void set_got_dom(bool got_dom) {\n    got_dom_ = got_dom;\n  }\n",
        "output": "0",
        "index": 115811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit PackagedAppTest(const std::string& toolchain)\n      : toolchain_(toolchain) { }\n",
        "output": "0",
        "index": 143752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderViewImpl::RenderViewImpl(RenderViewImplParams* params)\n    : RenderWidget(WebKit::WebPopupTypeNone,\n                   params->screen_info,\n                   params->swapped_out),\n      webkit_preferences_(params->webkit_prefs),\n      send_content_state_immediately_(false),\n      enabled_bindings_(0),\n      send_preferred_size_changes_(false),\n      auto_resize_mode_(false),\n      is_loading_(false),\n      navigation_gesture_(NavigationGestureUnknown),\n      opened_by_user_gesture_(true),\n      opener_suppressed_(false),\n      page_id_(-1),\n      last_page_id_sent_to_browser_(-1),\n      next_page_id_(params->next_page_id),\n      history_list_offset_(-1),\n      history_list_length_(0),\n      target_url_status_(TARGET_NONE),\n      selection_text_offset_(0),\n      selection_range_(ui::Range::InvalidRange()),\n      cached_is_main_frame_pinned_to_left_(false),\n      cached_is_main_frame_pinned_to_right_(false),\n      cached_has_main_frame_horizontal_scrollbar_(false),\n      cached_has_main_frame_vertical_scrollbar_(false),\n      ALLOW_THIS_IN_INITIALIZER_LIST(cookie_jar_(this)),\n      notification_provider_(NULL),\n      geolocation_dispatcher_(NULL),\n      input_tag_speech_dispatcher_(NULL),\n      speech_recognition_dispatcher_(NULL),\n      device_orientation_dispatcher_(NULL),\n      media_stream_dispatcher_(NULL),\n      browser_plugin_manager_(NULL),\n      media_stream_impl_(NULL),\n      devtools_agent_(NULL),\n      accessibility_mode_(AccessibilityModeOff),\n      renderer_accessibility_(NULL),\n      java_bridge_dispatcher_(NULL),\n      mouse_lock_dispatcher_(NULL),\n      favicon_helper_(NULL),\n#if defined(OS_ANDROID)\n      body_background_color_(SK_ColorWHITE),\n      update_frame_info_scheduled_(false),\n      expected_content_intent_id_(0),\n      media_player_proxy_(NULL),\n      synchronous_find_active_match_ordinal_(-1),\n      enumeration_completion_id_(0),\n      ALLOW_THIS_IN_INITIALIZER_LIST(\n          load_progress_tracker_(new LoadProgressTracker(this))),\n#endif\n      session_storage_namespace_id_(params->session_storage_namespace_id),\n      decrement_shared_popup_at_destruction_(false),\n      handling_select_range_(false),\n      next_snapshot_id_(0),\n#if defined(OS_WIN)\n      focused_plugin_id_(-1),\n#endif\n      updating_frame_tree_(false),\n      pending_frame_tree_update_(false),\n      target_process_id_(0),\n      target_routing_id_(0) {\n}\n",
        "output": "0",
        "index": 123931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XRRSetProviderOffloadSink(Display *dpy, XID provider,\n\t\t\t  XID sink_provider)\n{\n    XExtDisplayInfo\t    *info = XRRFindDisplay(dpy);\n    xRRSetProviderOffloadSinkReq *req;\n\n    RRCheckExtension (dpy, info, 0);\n    LockDisplay (dpy);\n    GetReq (RRSetProviderOffloadSink, req);\n    req->reqType = info->codes->major_opcode;\n    req->randrReqType = X_RRSetProviderOffloadSink;\n    req->provider = provider;\n    req->sink_provider = sink_provider;\n    UnlockDisplay (dpy);\n    SyncHandle ();\n    return 0;\n}\n",
        "output": "0",
        "index": 8299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CACHE_LIMITER_FUNC(nocache) /* {{{ */\n{\n\tADD_HEADER(\"Expires: Thu, 19 Nov 1981 08:52:00 GMT\");\n\n\t/* For HTTP/1.1 conforming clients and the rest (MSIE 5) */\n\tADD_HEADER(\"Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\");\n\n\t/* For HTTP/1.0 conforming clients */\n\tADD_HEADER(\"Pragma: no-cache\");\n}\n/* }}} */\n",
        "output": "0",
        "index": 9577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AutocompleteInput::NumNonHostComponents(const url_parse::Parsed& parts) {\n  int num_nonhost_components = 0;\n  if (parts.scheme.is_nonempty())\n    ++num_nonhost_components;\n  if (parts.username.is_nonempty())\n    ++num_nonhost_components;\n  if (parts.password.is_nonempty())\n    ++num_nonhost_components;\n  if (parts.port.is_nonempty())\n    ++num_nonhost_components;\n  if (parts.path.is_nonempty())\n    ++num_nonhost_components;\n  if (parts.query.is_nonempty())\n    ++num_nonhost_components;\n  if (parts.ref.is_nonempty())\n    ++num_nonhost_components;\n  return num_nonhost_components;\n}\n",
        "output": "0",
        "index": 110742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n\n  bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() ||\n                               delegate_->ShouldPreserveAbortedURLs();\n  if (pending_entry != controller_->GetVisibleEntry() ||\n      !should_preserve_entry) {\n    controller_->DiscardPendingEntry(true);\n\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}\n",
        "output": "0",
        "index": 148843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MediaStreamManager::AddLogMessageOnIOThread(const std::string& message) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  for (const auto& callback : log_callbacks_)\n    callback.second.Run(message);\n}\n",
        "output": "0",
        "index": 161095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_net_set_config_size(VirtIONet *n, uint32_t host_features)\n{\n    int i, config_size = 0;\n    host_features |= (1 << VIRTIO_NET_F_MAC);\n    for (i = 0; feature_sizes[i].flags != 0; i++) {\n        if (host_features & feature_sizes[i].flags) {\n            config_size = MAX(feature_sizes[i].end, config_size);\n        }\n    }\n    n->config_size = config_size;\n}\n",
        "output": "0",
        "index": 15852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void SetUp() {\n     url_util::AddStandardScheme(\"tabcontentstest\");\n \n     old_browser_client_ = content::GetContentClient()->browser();\n     content::GetContentClient()->set_browser(&browser_client_);\n     RenderViewHostTestHarness::SetUp();\n   }\n",
        "output": "1",
        "index": 184706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}\n",
        "output": "0",
        "index": 65554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::hidden() const {\n  return !IsPageVisible();\n}\n",
        "output": "0",
        "index": 141336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::popFullscreenElementStack()\n{\n    if (m_fullScreenElementStack.isEmpty())\n        return;\n\n    m_fullScreenElementStack.removeLast();\n}\n",
        "output": "0",
        "index": 112510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CastDetailedView::CastDetailedView(SystemTrayItem* owner,\n                                   CastConfigDelegate* cast_config_delegate,\n                                   user::LoginStatus login)\n    : TrayDetailsView(owner),\n      cast_config_delegate_(cast_config_delegate),\n      login_(login),\n      options_(nullptr) {\n  CreateItems();\n  UpdateReceiverList();\n}\n",
        "output": "0",
        "index": 128124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ChildProcessSecurityPolicyImpl::CanReadRequestBody(\n    SiteInstance* site_instance,\n    const scoped_refptr<network::ResourceRequestBody>& body) {\n  DCHECK(site_instance);\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  int child_id = site_instance->GetProcess()->GetID();\n\n  StoragePartition* storage_partition = BrowserContext::GetStoragePartition(\n      site_instance->GetBrowserContext(), site_instance);\n  const storage::FileSystemContext* file_system_context =\n      storage_partition->GetFileSystemContext();\n\n  return CanReadRequestBody(child_id, file_system_context, body);\n}\n",
        "output": "0",
        "index": 156527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_move_mount(struct path *path, const char *old_name)\n{\n\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\terr = lock_mount(path);\n\tif (err < 0)\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (d_unlinked(path->dentry))\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (S_ISDIR(path->dentry->d_inode->i_mode) !=\n\t      S_ISDIR(old_path.dentry->d_inode->i_mode))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, path, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(path);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n\tpath_put(&old_path);\n\treturn err;\n}\n",
        "output": "0",
        "index": 32346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int btrfs_set_inode_index_count(struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tkey.objectid = btrfs_ino(inode);\n\tbtrfs_set_key_type(&key, BTRFS_DIR_INDEX_KEY);\n\tkey.offset = (u64)-1;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\t/* FIXME: we should be able to handle this */\n\tif (ret == 0)\n\t\tgoto out;\n\tret = 0;\n\n\t/*\n\t * MAGIC NUMBER EXPLANATION:\n\t * since we search a directory based on f_pos we have to start at 2\n\t * since '.' and '..' have f_pos of 0 and 1 respectively, so everybody\n\t * else has to start at 2\n\t */\n\tif (path->slots[0] == 0) {\n\t\tBTRFS_I(inode)->index_cnt = 2;\n\t\tgoto out;\n\t}\n\n\tpath->slots[0]--;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\tif (found_key.objectid != btrfs_ino(inode) ||\n\t    btrfs_key_type(&found_key) != BTRFS_DIR_INDEX_KEY) {\n\t\tBTRFS_I(inode)->index_cnt = 2;\n\t\tgoto out;\n\t}\n\n\tBTRFS_I(inode)->index_cnt = found_key.offset + 1;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 34343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestingAutomationProvider::PerformActionOnInfobar(\n    Browser* browser,\n    DictionaryValue* args,\n    IPC::Message* reply_message) {\n  AutomationJSONReply reply(this, reply_message);\n  int tab_index;\n  int infobar_index_int;\n  std::string action;\n  if (!args->GetInteger(\"tab_index\", &tab_index) ||\n      !args->GetInteger(\"infobar_index\", &infobar_index_int) ||\n      !args->GetString(\"action\", &action)) {\n    reply.SendError(\"Invalid or missing args\");\n    return;\n  }\n\n  TabContentsWrapper* tab_contents =\n      browser->GetTabContentsWrapperAt(tab_index);\n  if (!tab_contents) {\n    reply.SendError(StringPrintf(\"No such tab at index %d\", tab_index));\n    return;\n  }\n  InfoBarTabHelper* infobar_helper = tab_contents->infobar_tab_helper();\n\n  InfoBarDelegate* infobar = NULL;\n  size_t infobar_index = static_cast<size_t>(infobar_index_int);\n  if (infobar_index >= infobar_helper->infobar_count()) {\n    reply.SendError(StringPrintf(\"No such infobar at index %\" PRIuS,\n                                 infobar_index));\n    return;\n  }\n  infobar = infobar_helper->GetInfoBarDelegateAt(infobar_index);\n\n  if (\"dismiss\" == action) {\n    infobar->InfoBarDismissed();\n    infobar_helper->RemoveInfoBar(infobar);\n    reply.SendSuccess(NULL);\n    return;\n  }\n  if (\"accept\" == action || \"cancel\" == action) {\n    ConfirmInfoBarDelegate* confirm_infobar;\n    if (!(confirm_infobar = infobar->AsConfirmInfoBarDelegate())) {\n      reply.SendError(\"Not a confirm infobar\");\n      return;\n    }\n    if (\"accept\" == action) {\n      if (confirm_infobar->Accept())\n        infobar_helper->RemoveInfoBar(infobar);\n    } else if (\"cancel\" == action) {\n      if (confirm_infobar->Cancel())\n        infobar_helper->RemoveInfoBar(infobar);\n    }\n    reply.SendSuccess(NULL);\n    return;\n  }\n  reply.SendError(\"Invalid action\");\n}\n",
        "output": "0",
        "index": 115001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ring_buffer_record_off(struct ring_buffer *buffer)\n{\n\tunsigned int rd;\n\tunsigned int new_rd;\n\n\tdo {\n\t\trd = atomic_read(&buffer->record_disabled);\n\t\tnew_rd = rd | RB_BUFFER_OFF;\n\t} while (atomic_cmpxchg(&buffer->record_disabled, rd, new_rd) != rd);\n}\n",
        "output": "0",
        "index": 72629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pfault_fini(void)\n{\n\tstruct pfault_refbk refbk = {\n\t\t.refdiagc = 0x258,\n\t\t.reffcode = 1,\n\t\t.refdwlen = 5,\n\t\t.refversn = 2,\n\t};\n\n\tif (!MACHINE_IS_VM || pfault_disable)\n\t\treturn;\n\tasm volatile(\n\t\t\"\tdiag\t%0,0,0x258\\n\"\n\t\t\"0:\\n\"\n\t\tEX_TABLE(0b,0b)\n\t\t: : \"a\" (&refbk), \"m\" (refbk) : \"cc\");\n}\n",
        "output": "0",
        "index": 25520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop through all the program headers.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t * in the section.\n\t\t */\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 35668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nested_svm_inject_npf_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct x86_exception *fault)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->vmcb->control.exit_code != SVM_EXIT_NPF) {\n\t\t/*\n\t\t * TODO: track the cause of the nested page fault, and\n\t\t * correctly fill in the high bits of exit_info_1.\n\t\t */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_NPF;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1 = (1ULL << 32);\n\t\tsvm->vmcb->control.exit_info_2 = fault->address;\n\t}\n\n\tsvm->vmcb->control.exit_info_1 &= ~0xffffffffULL;\n\tsvm->vmcb->control.exit_info_1 |= fault->error_code;\n\n\t/*\n\t * The present bit is always zero for page structure faults on real\n\t * hardware.\n\t */\n\tif (svm->vmcb->control.exit_info_1 & (2ULL << 32))\n\t\tsvm->vmcb->control.exit_info_1 &= ~1;\n\n\tnested_svm_vmexit(svm);\n}\n",
        "output": "0",
        "index": 37786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IndexedDBTransaction::TaskQueue::clear() {\n  while (!queue_.empty())\n    queue_.pop();\n}\n",
        "output": "0",
        "index": 168663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VideoCaptureManager::LookupControllerByMediaTypeAndDeviceId(\n    MediaStreamType type,\n    const std::string& device_id) const {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  for (const auto& entry : controllers_) {\n    if (type == entry->stream_type() && device_id == entry->device_id())\n      return entry.get();\n  }\n  return nullptr;\n}\n",
        "output": "0",
        "index": 166271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dut_mode_send(uint16_t opcode, uint8_t* buf, uint8_t len)\n{\n    LOG_INFO(\"dut_mode_send\");\n\n /* sanity check */\n if (interface_ready() == FALSE)\n return BT_STATUS_NOT_READY;\n\n return btif_dut_mode_send(opcode, buf, len);\n}\n",
        "output": "0",
        "index": 172805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_trans_huge(*src_pmd)) {\n\t\t\tint err;\n\t\t\tVM_BUG_ON(next-addr != HPAGE_PMD_SIZE);\n\t\t\terr = copy_huge_pmd(dst_mm, src_mm,\n\t\t\t\t\t    dst_pmd, src_pmd, addr, vma);\n\t\t\tif (err == -ENOMEM)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 21213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QQuickWebView::stop()\n{\n    Q_D(QQuickWebView);\n    d->webPageProxy->stopLoading();\n}\n",
        "output": "0",
        "index": 107078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TabStrip::MaySetClip() {\n  return touch_layout_ || drag_context_->IsStackingDraggedTabs();\n}\n",
        "output": "0",
        "index": 153437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u8 *ushort2bebytes(u8 *buf, unsigned short x)\n{\n\tif (buf != NULL) {\n\t\tbuf[1] = (u8) (x & 0xff);\n\t\tbuf[0] = (u8) ((x >> 8) & 0xff);\n\t}\n\treturn buf;\n}\n",
        "output": "0",
        "index": 78864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLFormControlElement::updateAncestorDisabledState() const\n{\n    HTMLFieldSetElement* fieldSetAncestor = 0;\n    ContainerNode* legendAncestor = 0;\n    for (ContainerNode* ancestor = parentNode(); ancestor; ancestor = ancestor->parentNode()) {\n        if (!legendAncestor && ancestor->hasTagName(legendTag))\n            legendAncestor = ancestor;\n        if (ancestor->hasTagName(fieldsetTag)) {\n            fieldSetAncestor = toHTMLFieldSetElement(ancestor);\n            break;\n        }\n    }\n    m_ancestorDisabledState = (fieldSetAncestor && fieldSetAncestor->isDisabledFormControl() && !(legendAncestor && legendAncestor == fieldSetAncestor->legend())) ? AncestorDisabledStateDisabled : AncestorDisabledStateEnabled;\n}\n",
        "output": "0",
        "index": 122296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "on_mouse_down(void *user_data, Evas *e, Evas_Object *webview, void *event_info)\n{\n    Browser_Window *window = (Browser_Window *)user_data;\n    Evas_Event_Mouse_Down *ev = (Evas_Event_Mouse_Down *)event_info;\n\n    /* Clear selection from the URL bar */\n    elm_entry_select_none(window->url_bar);\n\n    if (ev->button == 1)\n        view_focus_set(window, EINA_TRUE);\n    else if (ev->button == 2)\n        view_focus_set(window, !evas_object_focus_get(webview));\n}\n",
        "output": "0",
        "index": 114127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\tstruct rb_node *n;\n\n\tn = key_serial_next(p, v);\n\tif (n)\n\t\t*_pos = key_node_serial(n);\n\treturn n;\n}\n",
        "output": "0",
        "index": 60271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_label_init_security(struct inode *dir, struct dentry *dentry,\n\tstruct iattr *sattr, struct nfs4_label *label)\n{\n\tint err;\n\n\tif (label == NULL)\n\t\treturn NULL;\n\n\tif (nfs_server_capable(dir, NFS_CAP_SECURITY_LABEL) == 0)\n\t\treturn NULL;\n\n\terr = security_dentry_init_security(dentry, sattr->ia_mode,\n\t\t\t\t&dentry->d_name, (void **)&label->label, &label->len);\n\tif (err == 0)\n\t\treturn label;\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 57141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __cdecl DebugOnStart::Init() {\n  if (FindArgument(GetCommandLine(), switches::kDebugOnStart)) {\n\n    base::debug::SpawnDebuggerOnProcess(GetCurrentProcessId());\n\n    base::debug::WaitForDebugger(60, false);\n  } else if (FindArgument(GetCommandLine(), switches::kWaitForDebugger)) {\n    base::debug::WaitForDebugger(60, true);\n  }\n  return 0;\n}\n",
        "output": "0",
        "index": 107161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2Implementation::GetQueryObjecti64vEXT(GLuint id,\n                                                GLenum pname,\n                                                GLint64* params) {\n  GLuint64 result = 0;\n  if (GetQueryObjectValueHelper(\"glGetQueryObjectiv64vEXT\", id, pname, &result))\n    *params = base::saturated_cast<GLint64>(result);\n}\n",
        "output": "0",
        "index": 153712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ThumbnailGenerator::WidgetHidden(RenderWidgetHost* widget) {\n  WidgetThumbnail* wt = GetDataForHost(widget);\n  wt->last_hidden = base::TimeTicks::Now();\n\n  EraseHostFromShownList(widget);\n\n  if (!wt->thumbnail.isNull())\n    return;\n  wt->thumbnail = GetThumbnailForRenderer(widget);\n}\n",
        "output": "0",
        "index": 98625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserInit::LaunchWithProfile::AddCrashedInfoBarIfNecessary(\n    TabContents* tab) {\n  if (!profile_->DidLastSessionExitCleanly() &&\n      !profile_->IsOffTheRecord()) {\n    tab->AddInfoBar(new SessionCrashedInfoBarDelegate(tab));\n  }\n}\n",
        "output": "0",
        "index": 100155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CaptivePortalDetector::CaptivePortalDetector(\n    const scoped_refptr<net::URLRequestContextGetter>& request_context)\n    : request_context_(request_context) {\n}\n",
        "output": "0",
        "index": 140153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::WindowAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_windowAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::WindowAttributeAttributeSetter(v8_value, info);\n}\n",
        "output": "0",
        "index": 148200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGL2RenderingContextBase::uniform4fv(\n    const WebGLUniformLocation* location,\n    Vector<GLfloat>& v) {\n  WebGLRenderingContextBase::uniform4fv(location, v);\n}\n",
        "output": "0",
        "index": 146204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot )\n  {\n    if ( slot && slot->format == FT_GLYPH_FORMAT_BITMAP   &&\n         !( slot->internal->flags & FT_GLYPH_OWN_BITMAP ) )\n    {\n      FT_Bitmap  bitmap;\n      FT_Error   error;\n\n\n      FT_Bitmap_New( &bitmap );\n      error = FT_Bitmap_Copy( slot->library, &slot->bitmap, &bitmap );\n      if ( error )\n        return error;\n\n      slot->bitmap = bitmap;\n      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;\n    }\n\n    return FT_Err_Ok;\n  }\n",
        "output": "0",
        "index": 7005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tput_page(pages[i]);\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 85511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(openssl_pkey_export_to_file)\n{\n\tstruct php_x509_request req;\n\tzval ** zpkey, * args = NULL;\n\tchar * passphrase = NULL; int passphrase_len = 0;\n\tchar * filename = NULL; int filename_len = 0;\n\tlong key_resource = -1;\n\tEVP_PKEY * key;\n\tBIO * bio_out = NULL;\n\tconst EVP_CIPHER * cipher;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zp|s!a!\", &zpkey, &filename, &filename_len, &passphrase, &passphrase_len, &args) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_FALSE;\n\n\tkey = php_openssl_evp_from_zval(zpkey, 0, passphrase, 0, &key_resource TSRMLS_CC);\n\n\tif (key == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"cannot get key from parameter 1\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_openssl_open_base_dir_chk(filename TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_SSL_REQ_INIT(&req);\n\n\tif (PHP_SSL_REQ_PARSE(&req, args) == SUCCESS) {\n\t\tbio_out = BIO_new_file(filename, \"w\");\n\n\t\tif (passphrase && req.priv_key_encrypt) {\n\t\t\tif (req.priv_key_encrypt_cipher) {\n\t\t\t\tcipher = req.priv_key_encrypt_cipher;\n\t\t\t} else {\n\t\t\t\tcipher = (EVP_CIPHER *) EVP_des_ede3_cbc();\n\t\t\t}\n\t\t} else {\n\t\t\tcipher = NULL;\n\t\t}\n\t\tif (PEM_write_bio_PrivateKey(bio_out, key, cipher, (unsigned char *)passphrase, passphrase_len, NULL, NULL)) {\n\t\t\t/* Success!\n\t\t\t * If returning the output as a string, do so now */\n\t\t\tRETVAL_TRUE;\n\t\t}\n\t}\n\tPHP_SSL_REQ_DISPOSE(&req);\n\n\tif (key_resource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (bio_out) {\n\t\tBIO_free(bio_out);\n\t}\n}\n",
        "output": "0",
        "index": 14212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GpuCommandBufferStub::HasUnprocessedCommands() {\n  if (command_buffer_.get()) {\n    gpu::CommandBuffer::State state = command_buffer_->GetLastState();\n    return state.put_offset != state.get_offset &&\n        !gpu::error::IsError(state.error);\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 114383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WORD32 ih264d_access_unit_delimiter_rbsp(dec_struct_t * ps_dec)\n{\n    UWORD8 u1_primary_pic_type;\n    u1_primary_pic_type = ih264d_get_bits_h264(ps_dec->ps_bitstrm, 3);\n switch(u1_primary_pic_type)\n {\n case I_PIC:\n case SI_PIC:\n case ISI_PIC:\n            ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_I;\n break;\n default:\n            ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN;\n }\n return (0);\n}\n",
        "output": "0",
        "index": 172724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t floppy_cmos_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *p = to_platform_device(dev);\n\tint drive;\n\n\tdrive = p->id;\n\treturn sprintf(buf, \"%X\\n\", UDP->cmos);\n}\n",
        "output": "0",
        "index": 39361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mk_vhost_get(mk_ptr_t host, struct host **vhost, struct host_alias **alias)\n{\n    struct host *entry_host;\n    struct host_alias *entry_alias;\n    struct mk_list *head_vhost, *head_alias;\n\n    mk_list_foreach(head_vhost, &config->hosts) {\n        entry_host = mk_list_entry(head_vhost, struct host, _head);\n        mk_list_foreach(head_alias, &entry_host->server_names) {\n            entry_alias = mk_list_entry(head_alias, struct host_alias, _head);\n            if (entry_alias->len == host.len &&\n                strncmp(entry_alias->name, host.data, host.len) == 0) {\n                *vhost = entry_host;\n                *alias = entry_alias;\n                return 0;\n            }\n        }\n    }\n\n    return -1;\n}\n",
        "output": "0",
        "index": 36172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderProcessHostImpl::OnUnregisterAecDumpConsumer(int id) {\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::BindOnce(\n          &RenderProcessHostImpl::UnregisterAecDumpConsumerOnUIThread,\n          weak_factory_.GetWeakPtr(), id));\n}\n",
        "output": "0",
        "index": 162122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\treturn __do_kmalloc(size, flags, _RET_IP_);\n}\n",
        "output": "0",
        "index": 68818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScopedBindGLESAPI::~ScopedBindGLESAPI() {\n  if (!has_egl_) {\n    return;\n  }\n\n  DCHECK(egl_lib_.is_valid());\n  DCHECK_NE(orig_api_, static_cast<EGLenum>(EGL_NONE));\n\n  _eglBindAPI eglBindAPI = reinterpret_cast<_eglBindAPI>(\n      egl_lib_.GetFunctionPointer(\"eglBindAPI\"));\n  DCHECK(eglBindAPI);\n\n  eglBindAPI(orig_api_);\n}\n",
        "output": "0",
        "index": 17228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_pcd_read(void)\n{\n\tpcd_busy = 1;\n\tpcd_retries = 0;\n\tpcd_transfer();\n\tif (!pcd_count) {\n\t\tnext_request(0);\n\t\treturn;\n\t}\n\n\tpi_do_claimed(pcd_current->pi, pcd_start);\n}\n",
        "output": "0",
        "index": 87958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit TabTime(base::TimeTicks started)\n      : load_start_time_(started) {\n  }\n",
        "output": "0",
        "index": 126059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_hardware_setup(void)\n{\n\treturn 0;\n}\n",
        "output": "0",
        "index": 20587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Gfx::opSetLineJoin(Object args[], int numArgs) {\n  state->setLineJoin(args[0].getInt());\n  out->updateLineJoin(state);\n}\n",
        "output": "0",
        "index": 8152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SessionModelAssociator::SyncLocalWindowToSyncModel(\n    const SessionWindow& window) {\n  DCHECK(CalledOnValidThread());\n  DCHECK(tab_map_.empty());\n  for (size_t i = 0; i < window.tabs.size(); ++i) {\n    SessionTab* tab = window.tabs[i];\n    int64 id = tab_pool_.GetFreeTabNode();\n    if (id == sync_api::kInvalidId) {\n      LOG(ERROR) << \"Failed to find/generate free sync node for tab.\";\n      return false;\n    }\n\n    sync_api::WriteTransaction trans(FROM_HERE, sync_service_->GetUserShare());\n    if (!WriteSessionTabToSyncModel(*tab, id, &trans)) {\n      return false;\n    }\n\n    TabLinks t(id, tab);\n    tab_map_[tab->tab_id.id()] = t;\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 101355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::ToggleFullscreenModeForTab(TabContents* tab,\n    bool enter_fullscreen) {\n  if (tab != GetSelectedTabContents())\n     return;\n   fullscreened_tab_ = enter_fullscreen ?\n       TabContentsWrapper::GetCurrentWrapperForContents(tab) : NULL;\n  if (enter_fullscreen && !window_->IsFullscreen())\n     tab_caused_fullscreen_ = true;\n  if (tab_caused_fullscreen_)\n     ToggleFullscreenMode();\n }\n",
        "output": "1",
        "index": 183691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebURLLoaderImpl::loadSynchronously(const WebURLRequest& request,\n                                         WebURLResponse& response,\n                                         WebURLError& error,\n                                         WebData& data) {\n  ResourceLoaderBridge::SyncLoadResponse sync_load_response;\n  context_->Start(request, &sync_load_response, platform_);\n\n  const GURL& final_url = sync_load_response.url;\n\n  int error_code = sync_load_response.error_code;\n  if (error_code != net::OK) {\n    response.setURL(final_url);\n    error.domain = WebString::fromUTF8(net::kErrorDomain);\n    error.reason = error_code;\n    error.unreachableURL = final_url;\n    return;\n  }\n\n  PopulateURLResponse(final_url, sync_load_response, &response);\n\n  data.assign(sync_load_response.data.data(),\n              sync_load_response.data.size());\n}\n",
        "output": "0",
        "index": 121333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebPagePrivate::dispatchTouchEventToFullScreenPlugin(PluginView* plugin, const Platform::TouchEvent& event)\n{\n    if (!event.neverHadMultiTouch())\n        return false;\n\n    if (event.isDoubleTap() || event.isTouchHold() || event.m_type == Platform::TouchEvent::TouchCancel) {\n        NPTouchEvent npTouchEvent;\n\n        if (event.isDoubleTap())\n            npTouchEvent.type = TOUCH_EVENT_DOUBLETAP;\n        else if (event.isTouchHold())\n            npTouchEvent.type = TOUCH_EVENT_TOUCHHOLD;\n        else if (event.m_type == Platform::TouchEvent::TouchCancel)\n            npTouchEvent.type = TOUCH_EVENT_CANCEL;\n\n        npTouchEvent.points = 0;\n        npTouchEvent.size = event.m_points.size();\n        if (npTouchEvent.size) {\n            npTouchEvent.points = new NPTouchPoint[npTouchEvent.size];\n            for (int i = 0; i < npTouchEvent.size; i++) {\n                npTouchEvent.points[i].touchId = event.m_points[i].id();\n                npTouchEvent.points[i].clientX = event.m_points[i].screenPosition().x();\n                npTouchEvent.points[i].clientY = event.m_points[i].screenPosition().y();\n                npTouchEvent.points[i].screenX = event.m_points[i].screenPosition().x();\n                npTouchEvent.points[i].screenY = event.m_points[i].screenPosition().y();\n                npTouchEvent.points[i].pageX = event.m_points[i].pixelViewportPosition().x();\n                npTouchEvent.points[i].pageY = event.m_points[i].pixelViewportPosition().y();\n            }\n        }\n\n        NPEvent npEvent;\n        npEvent.type = NP_TouchEvent;\n        npEvent.data = &npTouchEvent;\n\n        plugin->dispatchFullScreenNPEvent(npEvent);\n        delete[] npTouchEvent.points;\n        return true;\n    }\n\n    dispatchTouchPointAsMouseEventToFullScreenPlugin(plugin, event.m_points[0]);\n    return true;\n}\n",
        "output": "0",
        "index": 113482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMX_ERRORTYPE SoftMP3::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamStandardComponentRole:\n {\n const OMX_PARAM_COMPONENTROLETYPE *roleParams =\n (const OMX_PARAM_COMPONENTROLETYPE *)params;\n\n if (!isValidOMXParam(roleParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (strncmp((const char *)roleParams->cRole,\n \"audio_decoder.mp3\",\n                        OMX_MAX_STRINGNAME_SIZE - 1)) {\n return OMX_ErrorUndefined;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n (const OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n\n if (!isValidOMXParam(pcmParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (pcmParams->nPortIndex != 1) {\n return OMX_ErrorUndefined;\n }\n\n            mNumChannels = pcmParams->nChannels;\n            mSamplingRate = pcmParams->nSamplingRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalSetParameter(index, params);\n }\n}\n",
        "output": "0",
        "index": 171514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " gfx::ScrollOffset SynchronousCompositorImpl::GetTotalScrollOffset() {\n   DCHECK(CalledOnValidThread());\n   DCHECK(compositor_client_);\n   return gfx::ScrollOffset(\n      compositor_client_->GetTotalRootLayerScrollOffset());\n}\n",
        "output": "1",
        "index": 185589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_all_variants)\n{\n\tconst char*  \tloc_name        = NULL;\n\tint    \t\tloc_name_len    = 0;\n\n\tint\tresult\t\t= 0;\n\tchar*\ttoken\t\t= NULL;\n\tchar*\tvariant\t\t= NULL;\n\tchar*\tsaved_ptr\t= NULL;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name, &loc_name_len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t     \"locale_parse: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\n\tarray_init( return_value );\n\n\t/* If the locale is grandfathered, stop, no variants */\n\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n\t\t/* (\"Grandfathered Tag. No variants.\"); */\n\t}\n\telse {\n\t/* Call ICU variant */\n\t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n\t\tif( result > 0 && variant){\n\t\t\t/* Tokenize on the \"_\" or \"-\" */\n\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\n\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*/\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n \t\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t}\n\t\t}\n\t\tif( variant ){\n\t\t\tefree( variant );\n\t\t}\n\t}\n\n\n}\n",
        "output": "0",
        "index": 9569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_netscape_format(const struct Cookie *co)\n{\n  return aprintf(\n    \"%s\"     /* httponly preamble */\n    \"%s%s\\t\" /* domain */\n    \"%s\\t\"   /* tailmatch */\n    \"%s\\t\"   /* path */\n    \"%s\\t\"   /* secure */\n    \"%\" FORMAT_OFF_T \"\\t\"   /* expires */\n    \"%s\\t\"   /* name */\n    \"%s\",    /* value */\n    co->httponly?\"#HttpOnly_\":\"\",\n    /* Make sure all domains are prefixed with a dot if they allow\n       tailmatching. This is Mozilla-style. */\n    (co->tailmatch && co->domain && co->domain[0] != '.')? \".\":\"\",\n    co->domain?co->domain:\"unknown\",\n    co->tailmatch?\"TRUE\":\"FALSE\",\n    co->path?co->path:\"/\",\n    co->secure?\"TRUE\":\"FALSE\",\n    co->expires,\n    co->name,\n    co->value?co->value:\"\");\n}\n",
        "output": "0",
        "index": 32455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool FormAssociatedElement::tooLong() const\n{\n    return false;\n}\n",
        "output": "0",
        "index": 133907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ldm_parse_dsk4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name  = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tlen     = r_name;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\tmemcpy (disk->disk_id, buffer + 0x18 + r_name, GUID_SIZE);\n\treturn true;\n}\n",
        "output": "0",
        "index": 27320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IndexedDBDispatcher::OnSuccessCursorPrefetch(\n    const IndexedDBMsg_CallbacksSuccessCursorPrefetch_Params& p) {\n  DCHECK_EQ(p.thread_id, CurrentWorkerId());\n  int32 response_id = p.response_id;\n  int32 cursor_id = p.cursor_id;\n  const std::vector<IndexedDBKey>& keys = p.keys;\n  const std::vector<IndexedDBKey>& primary_keys = p.primary_keys;\n  const std::vector<content::SerializedScriptValue>& values = p.values;\n  RendererWebIDBCursorImpl* cursor = cursors_[cursor_id];\n  DCHECK(cursor);\n  cursor->SetPrefetchData(keys, primary_keys, values);\n\n  WebIDBCallbacks* callbacks = pending_callbacks_.Lookup(response_id);\n  DCHECK(callbacks);\n  cursor->CachedContinue(callbacks);\n  pending_callbacks_.Remove(response_id);\n}\n",
        "output": "0",
        "index": 116941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QDECL FS_Printf( fileHandle_t h, const char *fmt, ... ) {\n\tva_list argptr;\n\tchar msg[MAXPRINTMSG];\n\n\tva_start( argptr,fmt );\n\tQ_vsnprintf( msg, sizeof( msg ), fmt, argptr );\n\tva_end( argptr );\n\n\tFS_Write( msg, strlen( msg ), h );\n}\n",
        "output": "0",
        "index": 95810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void  Ins_RS( INS_ARG )\n  {\n    if ( BOUNDS( args[0], CUR.storeSize ) )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    args[0] = CUR.storage[args[0]];\n  }\n",
        "output": "0",
        "index": 5433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType TraceCircle(MVGInfo *mvg_info,const PointInfo start,\n  const PointInfo end)\n{\n  double\n    alpha,\n    beta,\n    radius;\n\n  PointInfo\n    offset,\n    degrees;\n\n  alpha=end.x-start.x;\n  beta=end.y-start.y;\n  radius=hypot((double) alpha,(double) beta);\n  offset.x=(double) radius;\n  offset.y=(double) radius;\n  degrees.x=0.0;\n  degrees.y=360.0;\n  return(TraceEllipse(mvg_info,start,offset,degrees));\n}\n",
        "output": "0",
        "index": 87289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip_vs_svc_unhash(struct ip_vs_service *svc)\n{\n\tif (!(svc->flags & IP_VS_SVC_F_HASHED)) {\n\t\tpr_err(\"%s(): request for unhash flagged, called from %pF\\n\",\n\t\t       __func__, __builtin_return_address(0));\n\t\treturn 0;\n\t}\n\n\tif (svc->fwmark == 0) {\n\t\t/* Remove it from the svc_table table */\n\t\tlist_del(&svc->s_list);\n\t} else {\n\t\t/* Remove it from the svc_fwm_table table */\n\t\tlist_del(&svc->f_list);\n\t}\n\n\tsvc->flags &= ~IP_VS_SVC_F_HASHED;\n\tatomic_dec(&svc->refcnt);\n\treturn 1;\n}\n",
        "output": "0",
        "index": 34235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,\n\t\t\t\t\t\t\tenum migrate_mode mode)\n{\n\treturn true;\n}\n",
        "output": "0",
        "index": 54467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jpc_quantize(jas_matrix_t *data, jpc_fix_t stepsize)\n{\n\tint i;\n\tint j;\n\tjpc_fix_t t;\n\n\tif (stepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(data); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(data); ++j) {\n\t\t\tt = jas_matrix_get(data, i, j);\n\n{\n\tif (t < 0) {\n\t\tt = jpc_fix_neg(jpc_fix_div(jpc_fix_neg(t), stepsize));\n\t} else {\n\t\tt = jpc_fix_div(t, stepsize);\n\t}\n}\n\n\t\t\tjas_matrix_set(data, i, j, t);\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 72924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static s32 atl2_reset_hw(struct atl2_hw *hw)\n{\n\tu32 icr;\n\tu16 pci_cfg_cmd_word;\n\tint i;\n\n\t/* Workaround for PCI problem when BIOS sets MMRBC incorrectly. */\n\tatl2_read_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);\n\tif ((pci_cfg_cmd_word &\n\t\t(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) !=\n\t\t(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER)) {\n\t\tpci_cfg_cmd_word |=\n\t\t\t(CMD_IO_SPACE|CMD_MEMORY_SPACE|CMD_BUS_MASTER);\n\t\tatl2_write_pci_cfg(hw, PCI_REG_COMMAND, &pci_cfg_cmd_word);\n\t}\n\n\t/* Clear Interrupt mask to stop board from generating\n\t * interrupts & Clear any pending interrupt events\n\t */\n\t/* FIXME */\n\t/* ATL2_WRITE_REG(hw, REG_IMR, 0); */\n\t/* ATL2_WRITE_REG(hw, REG_ISR, 0xffffffff); */\n\n\t/* Issue Soft Reset to the MAC.  This will reset the chip's\n\t * transmit, receive, DMA.  It will not effect\n\t * the current PCI configuration.  The global reset bit is self-\n\t * clearing, and should clear within a microsecond.\n\t */\n\tATL2_WRITE_REG(hw, REG_MASTER_CTRL, MASTER_CTRL_SOFT_RST);\n\twmb();\n\tmsleep(1); /* delay about 1ms */\n\n\t/* Wait at least 10ms for All module to be Idle */\n\tfor (i = 0; i < 10; i++) {\n\t\ticr = ATL2_READ_REG(hw, REG_IDLE_STATUS);\n\t\tif (!icr)\n\t\t\tbreak;\n\t\tmsleep(1); /* delay 1 ms */\n\t\tcpu_relax();\n\t}\n\n\tif (icr)\n\t\treturn icr;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 55332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline size_t Max(size_t one, size_t two)\n{\n  if (one > two)\n    return one;\n  return two;\n}\n",
        "output": "0",
        "index": 71480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_FLIPRGON( INS_ARG )\n  {\n    FT_UShort  I, K, L;\n\n\n    K = (FT_UShort)args[1];\n    L = (FT_UShort)args[0];\n\n    if ( BOUNDS( K, CUR.pts.n_points ) ||\n         BOUNDS( L, CUR.pts.n_points ) )\n    {\n      if ( CUR.pedantic_hinting )\n        CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    for ( I = L; I <= K; I++ )\n      CUR.pts.tags[I] |= FT_CURVE_TAG_ON;\n  }\n",
        "output": "0",
        "index": 10106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderViewHostManager::InitRenderView(RenderViewHost* render_view_host,\n                                           int opener_route_id) {\n  if (pending_web_ui())\n    render_view_host->AllowBindings(pending_web_ui()->GetBindings());\n\n  return delegate_->CreateRenderViewForRenderManager(render_view_host,\n                                                     opener_route_id);\n}\n",
        "output": "0",
        "index": 124154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "showhelp(argv)\n    char **argv;\n{\n    if (phase == PHASE_INITIALIZE) {\n\tusage();\n\texit(0);\n    }\n    return 0;\n}\n",
        "output": "0",
        "index": 38178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BaseRenderingContext2D::CheckOverdraw(\n    const SkRect& rect,\n    const PaintFlags* flags,\n    CanvasRenderingContext2DState::ImageType image_type,\n    DrawType draw_type) {\n  PaintCanvas* c = DrawingCanvas();\n  if (!c)\n    return;\n\n  SkRect device_rect;\n  if (draw_type == kUntransformedUnclippedFill) {\n    device_rect = rect;\n  } else {\n    DCHECK_EQ(draw_type, kClipFill);\n    if (GetState().HasComplexClip())\n      return;\n\n    SkIRect sk_i_bounds;\n    if (!c->getDeviceClipBounds(&sk_i_bounds))\n      return;\n    device_rect = SkRect::Make(sk_i_bounds);\n  }\n\n  const SkImageInfo& image_info = c->imageInfo();\n  if (!device_rect.contains(\n          SkRect::MakeWH(image_info.width(), image_info.height())))\n    return;\n\n  bool is_source_over = true;\n  unsigned alpha = 0xFF;\n  if (flags) {\n    if (flags->getLooper() || flags->getImageFilter() || flags->getMaskFilter())\n      return;\n\n    SkBlendMode mode = flags->getBlendMode();\n    is_source_over = mode == SkBlendMode::kSrcOver;\n    if (!is_source_over && mode != SkBlendMode::kSrc &&\n        mode != SkBlendMode::kClear)\n      return;  // The code below only knows how to handle Src, SrcOver, and\n\n    alpha = flags->getAlpha();\n\n    if (is_source_over &&\n        image_type == CanvasRenderingContext2DState::kNoImage) {\n      if (flags->HasShader()) {\n        if (flags->ShaderIsOpaque() && alpha == 0xFF)\n          this->WillOverwriteCanvas();\n        return;\n      }\n    }\n  }\n\n  if (is_source_over) {\n    if (image_type == CanvasRenderingContext2DState::kNonOpaqueImage)\n      return;\n    if (alpha < 0xFF)\n      return;\n  }\n\n  this->WillOverwriteCanvas();\n}\n",
        "output": "0",
        "index": 162681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "on_tooltip_text_unset(void *user_data, Evas_Object *obj, void *event_info)\n{\n    Browser_Window *window = (Browser_Window *)user_data;\n\n    elm_object_tooltip_unset(window->webview);\n}\n",
        "output": "0",
        "index": 114134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SessionStore::~SessionStore() {}\n",
        "output": "0",
        "index": 156604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)\n{\n\tstruct dentry *temp;\n\tchar name[20];\n\n\tsnprintf(name, sizeof(name), \"#%lx\", (unsigned long) dentry);\n\n\ttemp = lookup_one_len(name, workdir, strlen(name));\n\tif (!IS_ERR(temp) && temp->d_inode) {\n\t\tpr_err(\"overlayfs: workdir/%s already exists\\n\", name);\n\t\tdput(temp);\n\t\ttemp = ERR_PTR(-EIO);\n\t}\n\n\treturn temp;\n}\n",
        "output": "0",
        "index": 51064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType IsBlobExempt(const Image *image)\n{\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  return(image->blob->exempt);\n}\n",
        "output": "0",
        "index": 88528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\t--sp->unsync_children;\n\t\tWARN_ON((int)sp->unsync_children < 0);\n\t\t__clear_bit(idx, sp->unsync_child_bitmap);\n\t\tlevel++;\n\t} while (level < PT64_ROOT_LEVEL-1 && !sp->unsync_children);\n}\n",
        "output": "0",
        "index": 37532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n",
        "output": "0",
        "index": 85478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_zip_write2(unsigned short i, FILE *fp)\n{\n    putc(i&0xff, fp);\n    putc((i>>8)&0xff, fp);\n\n    return;\n}\n",
        "output": "0",
        "index": 4349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}\n",
        "output": "0",
        "index": 65401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DiskCacheBackendTest::BackendShutdownWithPendingDoom() {\n  net::TestCompletionCallback cb;\n  {\n    ASSERT_TRUE(CleanupCacheDir());\n\n    disk_cache::BackendFlags flags = disk_cache::kNoRandom;\n    CreateBackend(flags);\n\n    disk_cache::Entry* entry;\n    int rv = cache_->CreateEntry(\"some key\", &entry, cb.callback());\n    ASSERT_THAT(cb.GetResult(rv), IsOk());\n    entry->Close();\n    entry = nullptr;\n\n    rv = cache_->DoomEntry(\"some key\", cb.callback());\n    ASSERT_THAT(rv, IsError(net::ERR_IO_PENDING));\n\n    cache_.reset();\n    EXPECT_FALSE(cb.have_result());\n  }\n\n  base::RunLoop().RunUntilIdle();\n  EXPECT_FALSE(cb.have_result());\n}\n",
        "output": "0",
        "index": 159987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _wc_ecc_curve_free(ecc_curve_spec* curve)\n{\n    if (curve == NULL) {\n        return;\n    }\n\n    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)\n        mp_clear(curve->prime);\n    if (curve->load_mask & ECC_CURVE_FIELD_AF)\n        mp_clear(curve->Af);\n#ifdef USE_ECC_B_PARAM\n    if (curve->load_mask & ECC_CURVE_FIELD_BF)\n        mp_clear(curve->Bf);\n#endif\n    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)\n        mp_clear(curve->order);\n    if (curve->load_mask & ECC_CURVE_FIELD_GX)\n        mp_clear(curve->Gx);\n    if (curve->load_mask & ECC_CURVE_FIELD_GY)\n        mp_clear(curve->Gy);\n\n    curve->load_mask = 0;\n}\n",
        "output": "0",
        "index": 81825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RendererSchedulerImpl::MaybeAdvanceVirtualTime(\n    base::TimeTicks new_virtual_time) {\n  if (virtual_time_domain_)\n    virtual_time_domain_->MaybeAdvanceVirtualTime(new_virtual_time);\n}\n",
        "output": "0",
        "index": 156219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TopSitesImpl::AddForcedURL(const GURL& url, const base::Time& time) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n\n  if (!loaded_) {\n    return false;\n  }\n\n  size_t num_forced = cache_->GetNumForcedURLs();\n  MostVisitedURLList new_list(cache_->top_sites());\n  MostVisitedURL new_url;\n\n  if (cache_->IsKnownURL(url)) {\n    size_t index = cache_->GetURLIndex(url);\n    if (new_list[index].last_forced_time.is_null())\n      return false;\n\n    new_url = new_list[index];\n    new_list.erase(new_list.begin() + index);\n    num_forced--;\n  } else {\n    new_url.url = url;\n    new_url.redirects.push_back(url);\n  }\n  new_url.last_forced_time = time;\n  MostVisitedURLList::iterator mid = new_list.begin() + num_forced;\n  mid = new_list.insert(mid, new_url);\n  std::inplace_merge(new_list.begin(), mid, mid + 1, ForcedURLComparator);\n  SetTopSites(new_list, CALL_LOCATION_FROM_FORCED_URLS);\n  return true;\n}\n",
        "output": "0",
        "index": 159865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2DecoderImpl::DoIsBuffer(GLuint client_id) {\n  const BufferManager::BufferInfo* info = GetBufferInfo(client_id);\n  return info && info->IsValid();\n}\n",
        "output": "0",
        "index": 104032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int btrfs_update_time(struct inode *inode, struct timespec *now,\n\t\t\t     int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tif (btrfs_root_readonly(root))\n\t\treturn -EROFS;\n\n\tif (flags & S_VERSION)\n\t\tinode_inc_iversion(inode);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *now;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *now;\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *now;\n\treturn btrfs_dirty_inode(inode);\n}\n",
        "output": "0",
        "index": 34362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  NonAccessibleView* button_row() const {\n    return media_controls_view_->button_row_;\n  }\n",
        "output": "0",
        "index": 149199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "channel_pre_open_13(Channel *c, fd_set *readset, fd_set *writeset)\n{\n\tif (buffer_len(&c->input) < packet_get_maxsize())\n\t\tFD_SET(c->sock, readset);\n\tif (buffer_len(&c->output) > 0)\n\t\tFD_SET(c->sock, writeset);\n}\n",
        "output": "0",
        "index": 2252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int em_movdqu(struct x86_emulate_ctxt *ctxt)\n{\n\tmemcpy(&ctxt->dst.vec_val, &ctxt->src.vec_val, ctxt->op_bytes);\n\treturn X86EMUL_CONTINUE;\n}\n",
        "output": "0",
        "index": 21766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::VoidMethodDefaultStringArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodDefaultStringArg\");\n\n  test_object_v8_internal::VoidMethodDefaultStringArgMethod(info);\n}\n",
        "output": "0",
        "index": 148064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode)\n{\n\tbtrfs_set_inode_uid(leaf, item, i_uid_read(inode));\n\tbtrfs_set_inode_gid(leaf, item, i_gid_read(inode));\n\tbtrfs_set_inode_size(leaf, item, BTRFS_I(inode)->disk_i_size);\n\tbtrfs_set_inode_mode(leaf, item, inode->i_mode);\n\tbtrfs_set_inode_nlink(leaf, item, inode->i_nlink);\n\n\tbtrfs_set_timespec_sec(leaf, btrfs_inode_atime(item),\n\t\t\t       inode->i_atime.tv_sec);\n\tbtrfs_set_timespec_nsec(leaf, btrfs_inode_atime(item),\n\t\t\t\tinode->i_atime.tv_nsec);\n\n\tbtrfs_set_timespec_sec(leaf, btrfs_inode_mtime(item),\n\t\t\t       inode->i_mtime.tv_sec);\n\tbtrfs_set_timespec_nsec(leaf, btrfs_inode_mtime(item),\n\t\t\t\tinode->i_mtime.tv_nsec);\n\n\tbtrfs_set_timespec_sec(leaf, btrfs_inode_ctime(item),\n\t\t\t       inode->i_ctime.tv_sec);\n\tbtrfs_set_timespec_nsec(leaf, btrfs_inode_ctime(item),\n\t\t\t\tinode->i_ctime.tv_nsec);\n\n\tbtrfs_set_inode_nbytes(leaf, item, inode_get_bytes(inode));\n\tbtrfs_set_inode_generation(leaf, item, BTRFS_I(inode)->generation);\n\tbtrfs_set_inode_sequence(leaf, item, inode->i_version);\n\tbtrfs_set_inode_transid(leaf, item, trans->transid);\n\tbtrfs_set_inode_rdev(leaf, item, inode->i_rdev);\n\tbtrfs_set_inode_flags(leaf, item, BTRFS_I(inode)->flags);\n\tbtrfs_set_inode_block_group(leaf, item, 0);\n}\n",
        "output": "0",
        "index": 34378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InitializeNetworkPortalDetector() {\n  if (network_portal_detector::SetForTesting())\n    return;\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          ::switches::kTestType)) {\n    network_portal_detector::SetNetworkPortalDetector(\n        new NetworkPortalDetectorStub());\n  } else {\n    network_portal_detector::SetNetworkPortalDetector(\n        new NetworkPortalDetectorImpl(\n            g_browser_process->system_network_context_manager()\n                ->GetURLLoaderFactory()));\n  }\n}\n",
        "output": "0",
        "index": 134905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    ::Cursor cursor() const { return cursor_; }\n",
        "output": "0",
        "index": 127643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RendererSchedulerImpl::EndIdlePeriodForTesting(\n    const base::Closure& callback,\n    base::TimeTicks time_remaining) {\n  main_thread_only().in_idle_period_for_testing = false;\n  EndIdlePeriod();\n  callback.Run();\n}\n",
        "output": "0",
        "index": 156193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_fin(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tinet_csk_schedule_ack(sk);\n\n\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\tsock_set_flag(sk, SOCK_DONE);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_RECV:\n\tcase TCP_ESTABLISHED:\n\t\t/* Move to CLOSE_WAIT */\n\t\ttcp_set_state(sk, TCP_CLOSE_WAIT);\n\t\tinet_csk(sk)->icsk_ack.pingpong = 1;\n\t\tbreak;\n\n\tcase TCP_CLOSE_WAIT:\n\tcase TCP_CLOSING:\n\t\t/* Received a retransmission of the FIN, do\n\t\t * nothing.\n\t\t */\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\t/* RFC793: Remain in the LAST-ACK state. */\n\t\tbreak;\n\n\tcase TCP_FIN_WAIT1:\n\t\t/* This case occurs when a simultaneous close\n\t\t * happens, we must ack the received FIN and\n\t\t * enter the CLOSING state.\n\t\t */\n\t\ttcp_send_ack(sk);\n\t\ttcp_set_state(sk, TCP_CLOSING);\n\t\tbreak;\n\tcase TCP_FIN_WAIT2:\n\t\t/* Received a FIN -- send ACK and enter TIME_WAIT. */\n\t\ttcp_send_ack(sk);\n\t\ttcp_time_wait(sk, TCP_TIME_WAIT, 0);\n\t\tbreak;\n\tdefault:\n\t\t/* Only TCP_LISTEN and TCP_CLOSE are left, in these\n\t\t * cases we should never reach this piece of code.\n\t\t */\n\t\tprintk(KERN_ERR \"%s: Impossible, sk->sk_state=%d\\n\",\n\t\t       __func__, sk->sk_state);\n\t\tbreak;\n\t}\n\n\t/* It _is_ possible, that we have something out-of-order _after_ FIN.\n\t * Probably, we should reset in this case. For now drop them.\n\t */\n\t__skb_queue_purge(&tp->out_of_order_queue);\n\tif (tcp_is_sack(tp))\n\t\ttcp_sack_reset(&tp->rx_opt);\n\tsk_mem_reclaim(sk);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\n\t\t/* Do not send POLL_HUP for half duplex close. */\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t\t    sk->sk_state == TCP_CLOSE)\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\t\telse\n\t\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\t}\n}\n",
        "output": "0",
        "index": 41154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PlatformSensorLinux::StartSensor(\n    const PlatformSensorConfiguration& configuration) {\n  DCHECK(task_runner_->BelongsToCurrentThread());\n  polling_thread_task_runner_->PostTask(\n      FROM_HERE,\n      base::Bind(&SensorReader::StartFetchingData,\n                 base::Unretained(sensor_reader_.get()), configuration));\n  return true;\n}\n",
        "output": "0",
        "index": 161784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_asn1_set_right (asn1_node node, asn1_node right)\n{\n  if (node == NULL)\n    return node;\n  node->right = right;\n  if (right)\n    {\n      right->left = node;\n      if (right->up == NULL)\n        right->up = node->up;\n    }\n  return node;\n}\n",
        "output": "0",
        "index": 3884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {\n  scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();\n  if (!va_surface)\n    return nullptr;\n\n  return new VaapiVP8Picture(va_surface);\n}\n",
        "output": "0",
        "index": 99624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void yr_object_destroy(\n    YR_OBJECT* object)\n{\n  YR_STRUCTURE_MEMBER* member;\n  YR_STRUCTURE_MEMBER* next_member;\n  YR_ARRAY_ITEMS* array_items;\n  YR_DICTIONARY_ITEMS* dict_items;\n\n  SIZED_STRING* str;\n  int i;\n\n  if (object == NULL)\n    return;\n\n  switch(object->type)\n  {\n    case OBJECT_TYPE_STRUCTURE:\n      member = ((YR_OBJECT_STRUCTURE*) object)->members;\n\n      while (member != NULL)\n      {\n        next_member = member->next;\n        yr_object_destroy(member->object);\n        yr_free(member);\n        member = next_member;\n      }\n      break;\n\n    case OBJECT_TYPE_STRING:\n      str = ((YR_OBJECT_STRING*) object)->value;\n      if (str != NULL)\n        yr_free(str);\n      break;\n\n    case OBJECT_TYPE_ARRAY:\n      if (((YR_OBJECT_ARRAY*) object)->prototype_item != NULL)\n        yr_object_destroy(((YR_OBJECT_ARRAY*) object)->prototype_item);\n\n      array_items = ((YR_OBJECT_ARRAY*) object)->items;\n\n      if (array_items != NULL)\n      {\n        for (i = 0; i < array_items->count; i++)\n          if (array_items->objects[i] != NULL)\n            yr_object_destroy(array_items->objects[i]);\n      }\n\n      yr_free(array_items);\n      break;\n\n    case OBJECT_TYPE_DICTIONARY:\n      if (((YR_OBJECT_DICTIONARY*) object)->prototype_item != NULL)\n        yr_object_destroy(((YR_OBJECT_DICTIONARY*) object)->prototype_item);\n\n      dict_items = ((YR_OBJECT_DICTIONARY*) object)->items;\n\n      if (dict_items != NULL)\n      {\n        for (i = 0; i < dict_items->used; i++)\n        {\n          if (dict_items->objects[i].key != NULL)\n            yr_free(dict_items->objects[i].key);\n\n          if (dict_items->objects[i].obj != NULL)\n            yr_object_destroy(dict_items->objects[i].obj);\n        }\n      }\n\n      yr_free(dict_items);\n      break;\n\n    case OBJECT_TYPE_FUNCTION:\n      yr_object_destroy(((YR_OBJECT_FUNCTION*) object)->return_obj);\n      break;\n  }\n\n  yr_free((void*) object->identifier);\n  yr_free(object);\n}\n",
        "output": "0",
        "index": 66043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dispersion(const datapoint_t *dp)\n{\n\treturn dp->d_dispersion + FREQ_TOLERANCE * (G.cur_time - dp->d_recv_time);\n}\n",
        "output": "0",
        "index": 9488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::IsSlotAssignmentOrLegacyDistributionDirty() {\n  if (ChildNeedsDistributionRecalc())\n    return true;\n  if (GetSlotAssignmentEngine().HasPendingSlotAssignmentRecalc()) {\n    return true;\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 156812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Microtask::enqueueMicrotask(PassOwnPtr<WebThread::Task> callback)\n{\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    isolate->EnqueueMicrotask(&microtaskFunctionCallback, callback.leakPtr());\n}\n",
        "output": "0",
        "index": 138466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t tun_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tssize_t len = iov_iter_count(to), ret;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\tret = tun_do_read(tun, tfile, to, file->f_flags & O_NONBLOCK, NULL);\n\tret = min_t(ssize_t, ret, len);\n\tif (ret > 0)\n\t\tiocb->ki_pos = ret;\n\ttun_put(tun);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 93269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IDNSpoofChecker::RestoreTrieParamsForTesting() {\n  g_trie_params = HuffmanTrieParams{\n      kTopDomainsHuffmanTree, sizeof(kTopDomainsHuffmanTree), kTopDomainsTrie,\n      kTopDomainsTrieBits, kTopDomainsRootPosition};\n}\n",
        "output": "0",
        "index": 157503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void  Ins_GC( INS_ARG )\n  {\n    Long  L;\n\n    L = args[0];\n\n    if ( BOUNDS( L, CUR.zp2.n_points ) )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    switch ( CUR.opcode & 1 )\n    {\n    case 0:\n      L = CUR_Func_project( CUR.zp2.cur_x[L],\n                            CUR.zp2.cur_y[L] );\n      break;\n\n    case 1:\n      L = CUR_Func_dualproj( CUR.zp2.org_x[L],\n                             CUR.zp2.org_y[L] );\n      break;\n    }\n\n    args[0] = L;\n  }\n",
        "output": "0",
        "index": 5387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::SetZoomLevel(double zoom_level) {\n  page_zoom_level_ = zoom_level;\n\n  webview()->SetZoomLevel(zoom_level);\n  for (auto& observer : observers_)\n    observer.OnZoomLevelChanged();\n}\n",
        "output": "0",
        "index": 157996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::EnableOrDisable(GLenum capability,\n                                                bool enable) {\n  if (isContextLost())\n    return;\n  if (enable)\n    ContextGL()->Enable(capability);\n  else\n    ContextGL()->Disable(capability);\n}\n",
        "output": "0",
        "index": 146287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Gfx::~Gfx() {\n  while (stateGuards.size()) {\n    popStateGuard();\n  }\n  while (state->hasSaves()) {\n    error(-1, \"Found state under last state guard. Popping.\");\n    restoreState();\n  }\n  if (!subPage) {\n    out->endPage();\n  }\n  while (res) {\n    popResources();\n  }\n  if (state) {\n    delete state;\n  }\n  while (mcStack) {\n    popMarkedContent();\n  }\n}\n",
        "output": "0",
        "index": 8183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JSValue jsTestObjConstructor(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* domObject = jsCast<JSTestObj*>(asObject(slotBase));\n    return JSTestObj::getConstructor(exec, domObject->globalObject());\n}\n",
        "output": "0",
        "index": 106109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setcos_activate_file(sc_card_t *card)\n{\n\tint r;\n\tu8 sbuf[2];\n\tsc_apdu_t apdu;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x44, 0x00, 0x00);\n\tapdu.data = sbuf;\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"ACTIVATE_FILE returned error\");\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}\n",
        "output": "0",
        "index": 78691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_cs_entry(cs_entry *cs)\n{\n    cs->data = NULL;\n    cs->name = NULL;\n    cs->len = 0;\n    cs->cslen = 0;\n    cs->used = false;\n    cs->valid = false;\n}\n",
        "output": "0",
        "index": 76642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gsm_xsmp_client_init (GsmXSMPClient *client)\n{\n        client->priv = GSM_XSMP_CLIENT_GET_PRIVATE (client);\n\n        client->priv->props = g_ptr_array_new ();\n        client->priv->current_save_yourself = -1;\n        client->priv->next_save_yourself = -1;\n        client->priv->next_save_yourself_allow_interact = FALSE;\n}\n",
        "output": "0",
        "index": 63567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MojoResult DataPipeProducerDispatcher::CloseNoLock() {\n  lock_.AssertAcquired();\n  if (is_closed_ || in_transit_)\n    return MOJO_RESULT_INVALID_ARGUMENT;\n  is_closed_ = true;\n  ring_buffer_mapping_ = base::WritableSharedMemoryMapping();\n  shared_ring_buffer_ = base::UnsafeSharedMemoryRegion();\n\n  watchers_.NotifyClosed();\n  if (!transferred_) {\n    base::AutoUnlock unlock(lock_);\n    node_controller_->ClosePort(control_port_);\n  }\n\n  return MOJO_RESULT_OK;\n}\n",
        "output": "0",
        "index": 167493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RootWindowHostWin::ToggleFullScreen() {\n  gfx::Rect target_rect;\n  if (!fullscreen_) {\n    fullscreen_ = true;\n    saved_window_style_ = GetWindowLong(hwnd(), GWL_STYLE);\n    saved_window_ex_style_ = GetWindowLong(hwnd(), GWL_EXSTYLE);\n    GetWindowRect(hwnd(), &saved_window_rect_);\n    SetWindowLong(hwnd(), GWL_STYLE,\n                  saved_window_style_ & ~(WS_CAPTION | WS_THICKFRAME));\n    SetWindowLong(hwnd(), GWL_EXSTYLE,\n                  saved_window_ex_style_ & ~(WS_EX_DLGMODALFRAME |\n                      WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE));\n\n    MONITORINFO mi;\n    mi.cbSize = sizeof(mi);\n    GetMonitorInfo(MonitorFromWindow(hwnd(), MONITOR_DEFAULTTONEAREST), &mi);\n    target_rect = mi.rcMonitor;\n  } else {\n    fullscreen_ = false;\n    SetWindowLong(hwnd(), GWL_STYLE, saved_window_style_);\n    SetWindowLong(hwnd(), GWL_EXSTYLE, saved_window_ex_style_);\n    target_rect = saved_window_rect_;\n  }\n  SetWindowPos(hwnd(),\n               NULL,\n               target_rect.x(),\n               target_rect.y(),\n               target_rect.width(),\n               target_rect.height(),\n               SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);\n}\n",
        "output": "0",
        "index": 110990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t ZSTD_compressContinue (ZSTD_CCtx* cctx,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize)\n{\n    DEBUGLOG(5, \"ZSTD_compressContinue (srcSize=%u)\", (U32)srcSize);\n    return ZSTD_compressContinue_internal(cctx, dst, dstCapacity, src, srcSize, 1 /* frame mode */, 0 /* last chunk */);\n}\n",
        "output": "0",
        "index": 90018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chunk_free_unchecked(chunk_t *chunk)\n{\n  if (!chunk)\n    return;\n#ifdef DEBUG_CHUNK_ALLOC\n  tor_assert(CHUNK_ALLOC_SIZE(chunk->memlen) == chunk->DBG_alloc);\n#endif\n  tor_assert(total_bytes_allocated_in_chunks >=\n             CHUNK_ALLOC_SIZE(chunk->memlen));\n  total_bytes_allocated_in_chunks -= CHUNK_ALLOC_SIZE(chunk->memlen);\n  tor_free(chunk);\n}\n",
        "output": "0",
        "index": 73162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Handle<v8::Value> V8ThrowException::createReferenceError(v8::Isolate* isolate, const String& message)\n{\n    return v8::Exception::ReferenceError(v8String(isolate, message.isNull() ? \"Reference error\" : message));\n}\n",
        "output": "0",
        "index": 140866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AutofillDialogViews::OverlayView::GetHeightForContentsForWidth(int width) {\n  if (!message_view_->visible())\n    return 0;\n\n  return kOverlayImageBottomMargin +\n      views::kButtonVEdgeMarginNew +\n      message_view_->GetHeightForWidth(width) +\n      image_view_->GetHeightForWidth(width);\n}\n",
        "output": "0",
        "index": 118227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int raw_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_ioctl(sk, cmd, (void __user *)arg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n",
        "output": "0",
        "index": 59212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zswapcolors(i_ctx_t * i_ctx_p)\n{\n    ref_colorspace tmp_cs;\n    ref            tmp_pat;\n\n    tmp_cs                = istate->colorspace[0];\n    istate->colorspace[0] = istate->colorspace[1];\n    istate->colorspace[1] = tmp_cs;\n\n    tmp_pat            = istate->pattern[0];\n    istate->pattern[0] = istate->pattern[1];\n    istate->pattern[1] = tmp_pat;\n\n    return gs_swapcolors(igs);\n}\n",
        "output": "0",
        "index": 3193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(snmpwalk)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, (SNMP_CMD_WALK | SNMP_NUMERIC_KEYS), SNMP_VERSION_1);\n}\n",
        "output": "0",
        "index": 11197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HostNPScriptObject::HostNPScriptObject(\n    NPP plugin,\n    NPObject* parent,\n    PluginMessageLoopProxy::Delegate* plugin_thread_delegate)\n    : plugin_(plugin),\n      parent_(parent),\n      state_(kDisconnected),\n      np_thread_id_(base::PlatformThread::CurrentId()),\n      plugin_message_loop_proxy_(\n          new PluginMessageLoopProxy(plugin_thread_delegate)),\n      host_context_(plugin_message_loop_proxy_),\n      failed_login_attempts_(0),\n      disconnected_event_(true, false),\n      am_currently_logging_(false),\n      nat_traversal_enabled_(false),\n      policy_received_(false) {\n}\n",
        "output": "0",
        "index": 115682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "table_colspan(struct table *t, int row, int col)\n{\n    int i;\n    for (i = col + 1; i <= t->maxcol && (t->tabattr[row][i] & HTT_X); i++) ;\n    return i - col;\n}\n",
        "output": "0",
        "index": 84653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool ChangeFilePermissions(const FilePath& file_path, mode_t permissions) {\n   if (HANDLE_EINTR(chmod(file_path.value().c_str(), permissions)) != 0) {\n    PLOG(ERROR) << \"Error changing permissions of \" << file_path.value();\n    return false;\n  }\n  DVLOG(1) << \"Changed permissions of \" << file_path.value();\n   return true;\n }\n",
        "output": "0",
        "index": 112914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void VoidMethodShortArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodShortArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  int16_t short_arg;\n  short_arg = NativeValueTraits<IDLShort>::NativeValue(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->voidMethodShortArg(short_arg);\n}\n",
        "output": "0",
        "index": 148151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vrend_set_constants(struct vrend_context *ctx,\n                         uint32_t shader,\n                         uint32_t index,\n                         uint32_t num_constant,\n                         float *data)\n{\n   struct vrend_constants *consts;\n   int i;\n\n   consts = &ctx->sub->consts[shader];\n   ctx->sub->const_dirty[shader] = true;\n\n   consts->consts = realloc(consts->consts, num_constant * sizeof(float));\n   if (!consts->consts)\n      return;\n\n   consts->num_consts = num_constant;\n   for (i = 0; i < num_constant; i++)\n      consts->consts[i] = ((unsigned int *)data)[i];\n}\n",
        "output": "0",
        "index": 8933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLvoid StubGLUniform1fv(GLint location, GLsizei count, const GLfloat* v) {\n  glUniform1fv(location, count, v);\n}\n",
        "output": "0",
        "index": 104476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool DownloadProtectionService::IsSupportedDownload(\n    const content::DownloadItem& item,\n    const base::FilePath& target_path) const {\n#if defined(OS_WIN) || defined(OS_MACOSX)\n  DownloadCheckResultReason reason = REASON_MAX;\n  ClientDownloadRequest::DownloadType type =\n      ClientDownloadRequest::WIN_EXECUTABLE;\n  return (CheckClientDownloadRequest::IsSupportedDownload(\n              item, target_path, &reason, &type) &&\n          (ClientDownloadRequest::CHROME_EXTENSION != type));\n#else\n  return false;\n#endif\n}\n",
        "output": "0",
        "index": 133813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GaiaCookieManagerService::StartFetchingListAccounts() {\n  VLOG(1) << \"GaiaCookieManagerService::ListAccounts\";\n  gaia_auth_fetcher_.reset(signin_client_->CreateGaiaAuthFetcher(\n      this, GetSourceForRequest(requests_.front()),\n      signin_client_->GetURLRequestContext()));\n  gaia_auth_fetcher_->StartListAccounts();\n}\n",
        "output": "0",
        "index": 140200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n",
        "output": "1",
        "index": 181613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TraceEvent::~TraceEvent() {\n}\n",
        "output": "0",
        "index": 129835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void uvesafb_reset(struct uvesafb_ktask *task)\n{\n\tstruct completion *cpl = task->done;\n\n\tmemset(task, 0, sizeof(*task));\n\ttask->done = cpl;\n}\n",
        "output": "0",
        "index": 79786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned WebGraphicsContext3DDefaultImpl::createRenderbuffer()\n{\n    makeContextCurrent();\n    GLuint o;\n    glGenRenderbuffersEXT(1, &o);\n    return o;\n}\n",
        "output": "0",
        "index": 98980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ChromeContentBrowserClient::GetTtsControllerDelegate() {\n  TtsControllerDelegateImpl* delegate =\n      TtsControllerDelegateImpl::GetInstance();\n#if !defined(OS_ANDROID)\n  TtsExtensionEngine* tts_extension_engine = TtsExtensionEngine::GetInstance();\n  delegate->SetTtsEngineDelegate(tts_extension_engine);\n#endif\n  return delegate;\n}\n",
        "output": "0",
        "index": 155376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLvoid StubGLUseProgram(GLuint program) {\n  glUseProgram(program);\n}\n",
        "output": "0",
        "index": 104494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hns_nic_maybe_stop_tx(\n\tstruct sk_buff **out_skb, int *bnum, struct hnae_ring *ring)\n{\n\tstruct sk_buff *skb = *out_skb;\n\tstruct sk_buff *new_skb = NULL;\n\tint buf_num;\n\n\t/* no. of segments (plus a header) */\n\tbuf_num = skb_shinfo(skb)->nr_frags + 1;\n\n\tif (unlikely(buf_num > ring->max_desc_num_per_pkt)) {\n\t\tif (ring_space(ring) < 1)\n\t\t\treturn -EBUSY;\n\n\t\tnew_skb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!new_skb)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_kfree_skb_any(skb);\n\t\t*out_skb = new_skb;\n\t\tbuf_num = 1;\n\t} else if (buf_num > ring_space(ring)) {\n\t\treturn -EBUSY;\n\t}\n\n\t*bnum = buf_num;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 85694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoRenderbufferStorageMultisampleAdvancedAMD(\n    GLenum target,\n    GLsizei samples,\n    GLsizei storageSamples,\n    GLenum internalformat,\n    GLsizei width,\n    GLsizei height) {\n  Renderbuffer* renderbuffer = GetRenderbufferInfoForTarget(GL_RENDERBUFFER);\n  if (!renderbuffer) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n                       \"glRenderbufferStorageMultisampleAdvancedAMD\",\n                       \"no renderbuffer bound\");\n    return;\n  }\n\n  if (!ValidateRenderbufferStorageMultisampleAMD(\n          samples, storageSamples, internalformat, width, height)) {\n    return;\n  }\n\n  GLenum impl_format =\n      renderbuffer_manager()->InternalRenderbufferFormatToImplFormat(\n          internalformat);\n  LOCAL_COPY_REAL_GL_ERRORS_TO_WRAPPER(\n      \"glRenderbufferStorageMultisampleAdvancedAMD\");\n  RenderbufferStorageMultisampleHelperAMD(\n      target, samples, storageSamples, impl_format, width, height, kDoNotForce);\n  GLenum error =\n      LOCAL_PEEK_GL_ERROR(\"glRenderbufferStorageMultisampleAdvancedAMD\");\n  if (error == GL_NO_ERROR) {\n    if (workarounds().validate_multisample_buffer_allocation) {\n      if (!VerifyMultisampleRenderbufferIntegrity(renderbuffer->service_id(),\n                                                  impl_format)) {\n        LOCAL_SET_GL_ERROR(GL_OUT_OF_MEMORY,\n                           \"glRenderbufferStorageMultisampleAdvancedAMD\",\n                           \"out of memory\");\n        return;\n      }\n    }\n\n    renderbuffer_manager()->SetInfoAndInvalidate(renderbuffer, samples,\n                                                 internalformat, width, height);\n  }\n}\n",
        "output": "0",
        "index": 154053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::updatePlaybackRate() {\n  if (m_webMediaPlayer && potentiallyPlaying())\n    webMediaPlayer()->setRate(playbackRate());\n}\n",
        "output": "0",
        "index": 140139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline MagickBooleanType AcquireCacheNexusPixels(\n  const CacheInfo *magick_restrict cache_info,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  if (nexus_info->length != (MagickSizeType) ((size_t) nexus_info->length))\n    return(MagickFalse);\n  nexus_info->mapped=MagickFalse;\n  nexus_info->cache=(Quantum *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    (size_t) nexus_info->length));\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      nexus_info->mapped=MagickTrue;\n      nexus_info->cache=(Quantum *) MapBlob(-1,IOMode,0,(size_t)\n        nexus_info->length);\n    }\n  if (nexus_info->cache == (Quantum *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        cache_info->filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n",
        "output": "0",
        "index": 94758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xilinx_ethlite_reset(DeviceState *dev)\n{\n    struct xlx_ethlite *s = XILINX_ETHLITE(dev);\n\n    s->rxbuf = 0;\n}\n",
        "output": "0",
        "index": 8635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RFlagItem *r_flag_set_next(RFlag *f, const char *name, ut64 off, ut32 size) {\n\tif (!r_flag_get (f, name)) {\n\t\treturn r_flag_set (f, name, off, size);\n\t}\n\tint i, newNameSize = strlen (name);\n\tchar *newName = malloc (newNameSize + 16);\n\tstrcpy (newName, name);\n\tfor (i = 0; ; i++) {\n\t\tsnprintf (newName + newNameSize, 15, \".%d\", i);\n\t\tif (!r_flag_get (f, newName)) {\n\t\t\tRFlagItem *fi = r_flag_set (f, newName, off, size);\n\t\t\tfree (newName);\n\t\t\treturn fi;\n\t\t}\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 60488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::InitSecureContextState() {\n  DCHECK_EQ(secure_context_state_, SecureContextState::kUnknown);\n  if (!GetSecurityOrigin()->IsPotentiallyTrustworthy()) {\n    secure_context_state_ = SecureContextState::kNonSecure;\n  } else if (SchemeRegistry::SchemeShouldBypassSecureContextCheck(\n                 GetSecurityOrigin()->Protocol())) {\n    secure_context_state_ = SecureContextState::kSecure;\n  } else if (frame_) {\n    Frame* parent = frame_->Tree().Parent();\n    while (parent) {\n      if (!parent->GetSecurityContext()\n               ->GetSecurityOrigin()\n               ->IsPotentiallyTrustworthy()) {\n        secure_context_state_ = SecureContextState::kNonSecure;\n        break;\n      }\n      parent = parent->Tree().Parent();\n    }\n    if (secure_context_state_ == SecureContextState::kUnknown)\n      secure_context_state_ = SecureContextState::kSecure;\n  } else {\n    secure_context_state_ = SecureContextState::kNonSecure;\n  }\n  DCHECK_NE(secure_context_state_, SecureContextState::kUnknown);\n}\n",
        "output": "0",
        "index": 141122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  InputMethodResultAuraTest() {}\n",
        "output": "0",
        "index": 158418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Verify_FindMainResponseWithMultipleHits3() {\n    EXPECT_EQ(kEntryUrl, delegate()->found_url_);\n    EXPECT_EQ(kManifestUrl2, delegate()->found_manifest_url_);\n    EXPECT_EQ(2, delegate()->found_cache_id_);\n    EXPECT_EQ(2, delegate()->found_group_id_);\n    EXPECT_EQ(2, delegate()->found_entry_.response_id());\n    EXPECT_TRUE(delegate()->found_entry_.IsExplicit());\n    EXPECT_FALSE(delegate()->found_fallback_entry_.has_response_id());\n\n    delegate_.reset(new MockStorageDelegate(this));\n    PushNextTask(base::BindOnce(\n        &AppCacheStorageImplTest::Verify_FindMainResponseWithMultipleHits4,\n        base::Unretained(this)));\n    storage()->FindResponseForMainRequest(kFallbackTestUrl, GURL(), delegate());\n    EXPECT_NE(kFallbackTestUrl, delegate()->found_url_);\n  }\n",
        "output": "0",
        "index": 164216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "keyword_alloc(vector_t *keywords_vec, const char *string, void (*handler) (vector_t *), bool active)\n{\n\tkeyword_t *keyword;\n\n\tvector_alloc_slot(keywords_vec);\n\n\tkeyword = (keyword_t *) MALLOC(sizeof(keyword_t));\n\tkeyword->string = string;\n\tkeyword->handler = handler;\n\tkeyword->active = active;\n\n\tvector_set_slot(keywords_vec, keyword);\n}\n",
        "output": "0",
        "index": 76169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gsicc_initialize_iccsmask(gsicc_manager_t *icc_manager)\n{\n    gs_memory_t *stable_mem = icc_manager->memory->stable_memory;\n\n    /* Allocations need to be done in stable memory.  We want to maintain\n       the smask_profiles object */\n    icc_manager->smask_profiles = gsicc_new_iccsmask(stable_mem);\n    if (icc_manager->smask_profiles == NULL)\n        return gs_throw(gs_error_VMerror, \"insufficient memory to allocate smask profiles\");\n    /* Load the gray, rgb, and cmyk profiles */\n    if ((icc_manager->smask_profiles->smask_gray =\n        gsicc_set_iccsmaskprofile(SMASK_GRAY_ICC, strlen(SMASK_GRAY_ICC),\n        icc_manager, stable_mem) ) == NULL) {\n        return gs_throw(-1, \"failed to load gray smask profile\");\n    }\n    if ((icc_manager->smask_profiles->smask_rgb =\n        gsicc_set_iccsmaskprofile(SMASK_RGB_ICC, strlen(SMASK_RGB_ICC),\n        icc_manager, stable_mem)) == NULL) {\n        return gs_throw(-1, \"failed to load rgb smask profile\");\n    }\n    if ((icc_manager->smask_profiles->smask_cmyk =\n        gsicc_set_iccsmaskprofile(SMASK_CMYK_ICC, strlen(SMASK_CMYK_ICC),\n        icc_manager, stable_mem)) == NULL) {\n        return gs_throw(-1, \"failed to load cmyk smask profile\");\n    }\n    /* Set these as \"default\" so that pdfwrite or other high level devices\n       will know that these are manufactured profiles, and default spaces\n       should be used */\n    icc_manager->smask_profiles->smask_gray->default_match = DEFAULT_GRAY;\n    icc_manager->smask_profiles->smask_rgb->default_match = DEFAULT_RGB;\n    icc_manager->smask_profiles->smask_cmyk->default_match = DEFAULT_CMYK;\n    return 0;\n}\n",
        "output": "0",
        "index": 13975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t Parcel::ipcDataSize() const\n{\n return (mDataSize > mDataPos ? mDataSize : mDataPos);\n}\n",
        "output": "0",
        "index": 170449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unwrap(struct magic_set *ms, const char *fn)\n{\n\tFILE *f;\n\tssize_t len;\n\tchar *line = NULL;\n\tsize_t llen = 0;\n\tint wid = 0, cwid;\n\tint e = 0;\n\n\tif (strcmp(\"-\", fn) == 0) {\n\t\tf = stdin;\n\t\twid = 1;\n\t} else {\n\t\tif ((f = fopen(fn, \"r\")) == NULL) {\n\t\t\t(void)fprintf(stderr, \"%s: Cannot open `%s' (%s).\\n\",\n\t\t\t    progname, fn, strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\n\t\twhile ((len = getline(&line, &llen, f)) > 0) {\n\t\t\tif (line[len - 1] == '\\n')\n\t\t\t\tline[len - 1] = '\\0';\n\t\t\tcwid = file_mbswidth(line);\n\t\t\tif (cwid > wid)\n\t\t\t\twid = cwid;\n\t\t}\n\n\t\trewind(f);\n\t}\n\n\twhile ((len = getline(&line, &llen, f)) > 0) {\n\t\tif (line[len - 1] == '\\n')\n\t\t\tline[len - 1] = '\\0';\n\t\te |= process(ms, line, wid);\n\t\tif(nobuffer)\n\t\t\t(void)fflush(stdout);\n\t}\n\n\tfree(line);\n\t(void)fclose(f);\n\treturn e;\n}\n",
        "output": "0",
        "index": 45967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void brcmf_free_wiphy(struct wiphy *wiphy)\n{\n\tint i;\n\n\tif (!wiphy)\n\t\treturn;\n\n\tif (wiphy->iface_combinations) {\n\t\tfor (i = 0; i < wiphy->n_iface_combinations; i++)\n\t\t\tkfree(wiphy->iface_combinations[i].limits);\n\t}\n\tkfree(wiphy->iface_combinations);\n\tif (wiphy->bands[NL80211_BAND_2GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_2GHZ]);\n\t}\n\tif (wiphy->bands[NL80211_BAND_5GHZ]) {\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]->channels);\n\t\tkfree(wiphy->bands[NL80211_BAND_5GHZ]);\n\t}\n\twiphy_free(wiphy);\n}\n",
        "output": "0",
        "index": 49074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx (size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromTgaCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n",
        "output": "0",
        "index": 50409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(36);\n\tlgp->lg_signal = be32_to_cpup(p++);\n\tlgp->lg_layout_type = be32_to_cpup(p++);\n\tlgp->lg_seg.iomode = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.offset);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.length);\n\tp = xdr_decode_hyper(p, &lgp->lg_minlength);\n\n\tstatus = nfsd4_decode_stateid(argp, &lgp->lg_sid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tlgp->lg_maxcount = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}\n",
        "output": "0",
        "index": 65752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static js_Ast *arrayelement(js_State *J)\n{\n\tif (J->lookahead == ',')\n\t\treturn EXP0(UNDEF);\n\treturn assignment(J, 0);\n}\n",
        "output": "0",
        "index": 11879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FilterRows(uint8* ybuf, const uint8* y0_ptr, const uint8* y1_ptr,\n                       int source_width, int source_y_fraction) {\n  __m128i zero = _mm_setzero_si128();\n  __m128i y1_fraction = _mm_set1_epi16(source_y_fraction);\n  __m128i y0_fraction = _mm_set1_epi16(256 - source_y_fraction);\n\n  const __m128i* y0_ptr128 = reinterpret_cast<const __m128i*>(y0_ptr);\n  const __m128i* y1_ptr128 = reinterpret_cast<const __m128i*>(y1_ptr);\n  __m128i* dest128 = reinterpret_cast<__m128i*>(ybuf);\n  __m128i* end128 = reinterpret_cast<__m128i*>(ybuf + source_width);\n\n  do {\n    __m128i y0 = _mm_loadu_si128(y0_ptr128);\n    __m128i y1 = _mm_loadu_si128(y1_ptr128);\n    __m128i y2 = _mm_unpackhi_epi8(y0, zero);\n    __m128i y3 = _mm_unpackhi_epi8(y1, zero);\n    y0 = _mm_unpacklo_epi8(y0, zero);\n    y1 = _mm_unpacklo_epi8(y1, zero);\n    y0 = _mm_mullo_epi16(y0, y0_fraction);\n    y1 = _mm_mullo_epi16(y1, y1_fraction);\n    y2 = _mm_mullo_epi16(y2, y0_fraction);\n    y3 = _mm_mullo_epi16(y3, y1_fraction);\n    y0 = _mm_add_epi16(y0, y1);\n    y2 = _mm_add_epi16(y2, y3);\n    y0 = _mm_srli_epi16(y0, 8);\n    y2 = _mm_srli_epi16(y2, 8);\n    y0 = _mm_packus_epi16(y0, y2);\n    *dest128++ = y0;\n    ++y0_ptr128;\n    ++y1_ptr128;\n  } while (dest128 < end128);\n}\n",
        "output": "0",
        "index": 103361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void __sock_tx_timestamp(__u16 tsflags, __u8 *tx_flags)\n{\n\tu8 flags = *tx_flags;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_HARDWARE)\n\t\tflags |= SKBTX_HW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SOFTWARE)\n\t\tflags |= SKBTX_SW_TSTAMP;\n\n\tif (tsflags & SOF_TIMESTAMPING_TX_SCHED)\n\t\tflags |= SKBTX_SCHED_TSTAMP;\n\n\t*tx_flags = flags;\n}\n",
        "output": "0",
        "index": 82234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipmi_si_remove_by_data(int addr_space, enum si_type si_type,\n\t\t\t    unsigned long addr)\n{\n\t/* remove */\n\tstruct smi_info *e, *tmp_e;\n\n\tmutex_lock(&smi_infos_lock);\n\tlist_for_each_entry_safe(e, tmp_e, &smi_infos, link) {\n\t\tif (e->io.addr_type != addr_space)\n\t\t\tcontinue;\n\t\tif (e->io.si_type != si_type)\n\t\t\tcontinue;\n\t\tif (e->io.addr_data == addr)\n\t\t\tcleanup_one_si(e);\n\t}\n\tmutex_unlock(&smi_infos_lock);\n}\n",
        "output": "0",
        "index": 90231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::OnFrameDidCallFocus() {\n  delegate_->DidCallFocus();\n}\n",
        "output": "0",
        "index": 152035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\t/* See if the full key description matches as is */\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\t/* All tests from here on break the criterion description into a\n\t * specifier, a colon and then an identifier.\n\t */\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
        "output": "1",
        "index": 181608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "content::OpenURLParams GetOpenParams(const char* url) {\n  return content::OpenURLParams(GURL(url), content::Referrer(),\n                                WindowOpenDisposition::NEW_FOREGROUND_TAB,\n                                ui::PAGE_TRANSITION_LINK, false);\n}\n",
        "output": "0",
        "index": 157637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SVGStyleElement::NotifyLoadedSheetAndAllCriticalSubresources(\n    LoadedSheetErrorStatus error_status) {\n  if (error_status != kNoErrorLoadingSubresource) {\n    GetDocument()\n        .GetTaskRunner(TaskType::kDOMManipulation)\n        ->PostTask(FROM_HERE, WTF::Bind(&SVGStyleElement::DispatchPendingEvent,\n                                        WrapPersistent(this)));\n  }\n}\n",
        "output": "0",
        "index": 167437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit)\n\t\treturn -EINVAL;\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target))\n\t\treturn -EINVAL;\n\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 84983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func)\n{\n    xmlDeregisterNodeFunc old = xmlDeregisterNodeDefaultValue;\n    \n    __xmlRegisterCallbacks = 1;\n    xmlDeregisterNodeDefaultValue = func;\n    return(old);\n}\n",
        "output": "0",
        "index": 114818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct f_hid_opts *to_f_hid_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_hid_opts,\n\t\t\t    func_inst.group);\n}\n",
        "output": "0",
        "index": 96692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err mdia_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, mdia_AddBox);\n\tif (e) return e;\n\tif (!((GF_MediaBox *)s)->information) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaInformationBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->handler) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing HandlerBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (!((GF_MediaBox *)s)->mediaHeader) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing MediaHeaderBox\\n\"));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int phar_update_cached_entry(void *data, void *argument) /* {{{ */\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\tTSRMLS_FETCH();\n\n\tentry->phar = (phar_archive_data *)argument;\n\n\tif (entry->link) {\n\t\tentry->link = estrdup(entry->link);\n\t}\n\n\tif (entry->tmp) {\n\t\tentry->tmp = estrdup(entry->tmp);\n\t}\n\n\tentry->metadata_str.c = 0;\n\tentry->filename = estrndup(entry->filename, entry->filename_len);\n\tentry->is_persistent = 0;\n\n\tif (entry->metadata) {\n\t\tif (entry->metadata_len) {\n\t\t\tchar *buf = estrndup((char *) entry->metadata, entry->metadata_len);\n\t\t\t/* assume success, we would have failed before */\n\t\t\tphar_parse_metadata((char **) &buf, &entry->metadata, entry->metadata_len TSRMLS_CC);\n\t\t\tefree(buf);\n\t\t} else {\n\t\t\tzval *t;\n\n\t\t\tt = entry->metadata;\n\t\t\tALLOC_ZVAL(entry->metadata);\n\t\t\t*entry->metadata = *t;\n\t\t\tzval_copy_ctor(entry->metadata);\n\t\t\tZ_SET_REFCOUNT_P(entry->metadata, 1);\n\t\t\tentry->metadata_str.c = NULL;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\t}\n\treturn ZEND_HASH_APPLY_KEEP;\n}\n/* }}} */\n",
        "output": "0",
        "index": 210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "InputDispatcher::DispatchEntry::~DispatchEntry() {\n    eventEntry->release();\n}\n",
        "output": "0",
        "index": 177034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GC_API void * GC_CALL GC_malloc_atomic_ignore_off_page(size_t lb)\n{\n    return((void *)GC_generic_malloc_ignore_off_page(lb, PTRFREE));\n}\n",
        "output": "0",
        "index": 94296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsNonCharacter(int character) {\n  return character >= kNonCharacter3 && character <= kNonCharacter1;\n}\n",
        "output": "0",
        "index": 156347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AtomicString makeVisibleEmptyValue(const Vector<String>& symbols)\n{\n    unsigned maximumLength = 0;\n    for (unsigned index = 0; index < symbols.size(); ++index)\n        maximumLength = std::max(maximumLength, numGraphemeClusters(symbols[index]));\n    StringBuilder builder;\n    builder.reserveCapacity(maximumLength);\n    for (unsigned length = 0; length < maximumLength; ++length)\n        builder.append('-');\n    return builder.toAtomicString();\n}\n",
        "output": "0",
        "index": 110194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual gfx::GLSurface* GetGLSurface() { return surface_.get(); }\n",
        "output": "0",
        "index": 104096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char* AudioPlayingStateToString(bool is_audio_playing) {\n  if (is_audio_playing) {\n    return \"playing\";\n  } else {\n    return \"muted\";\n  }\n}\n",
        "output": "0",
        "index": 156165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "armv6pmu_disable_event(struct hw_perf_event *hwc,\n\t\t       int idx)\n{\n\tunsigned long val, mask, evt, flags;\n\n\tif (ARMV6_CYCLE_COUNTER == idx) {\n\t\tmask\t= ARMV6_PMCR_CCOUNT_IEN;\n\t\tevt\t= 0;\n\t} else if (ARMV6_COUNTER0 == idx) {\n\t\tmask\t= ARMV6_PMCR_COUNT0_IEN | ARMV6_PMCR_EVT_COUNT0_MASK;\n\t\tevt\t= ARMV6_PERFCTR_NOP << ARMV6_PMCR_EVT_COUNT0_SHIFT;\n\t} else if (ARMV6_COUNTER1 == idx) {\n\t\tmask\t= ARMV6_PMCR_COUNT1_IEN | ARMV6_PMCR_EVT_COUNT1_MASK;\n\t\tevt\t= ARMV6_PERFCTR_NOP << ARMV6_PMCR_EVT_COUNT1_SHIFT;\n\t} else {\n\t\tWARN_ONCE(1, \"invalid counter number (%d)\\n\", idx);\n\t\treturn;\n\t}\n\n\t/*\n\t * Mask out the current event and set the counter to count the number\n\t * of ETM bus signal assertion cycles. The external reporting should\n\t * be disabled and so this should never increment.\n\t */\n\traw_spin_lock_irqsave(&pmu_lock, flags);\n\tval = armv6_pmcr_read();\n\tval &= ~mask;\n\tval |= evt;\n\tarmv6_pmcr_write(val);\n\traw_spin_unlock_irqrestore(&pmu_lock, flags);\n}\n",
        "output": "0",
        "index": 25246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ehci_state_execute(EHCIQueue *q)\n{\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n    int again = 0;\n\n    assert(p != NULL);\n    assert(p->qtdaddr == q->qtdaddr);\n\n    if (ehci_qh_do_overlay(q) != 0) {\n        return -1;\n    }\n\n\n    /* 4.10.3, bottom of page 82, go horizontal on transaction counter == 0 */\n    if (!q->async && q->transact_ctr == 0) {\n        ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n        again = 1;\n        goto out;\n    }\n\n    if (q->async) {\n        ehci_set_usbsts(q->ehci, USBSTS_REC);\n    }\n\n    again = ehci_execute(p, \"process\");\n    if (again == -1) {\n        goto out;\n    }\n    if (p->packet.status == USB_RET_ASYNC) {\n        ehci_flush_qh(q);\n        trace_usb_ehci_packet_action(p->queue, p, \"async\");\n        p->async = EHCI_ASYNC_INFLIGHT;\n        ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n        if (q->async) {\n            again = ehci_fill_queue(p);\n        } else {\n            again = 1;\n        }\n        goto out;\n    }\n\n    ehci_set_state(q->ehci, q->async, EST_EXECUTING);\n    again = 1;\n\nout:\n    return again;\n}\n",
        "output": "0",
        "index": 5817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HTMLTextAreaElement::isPresentationAttribute(const QualifiedName& name) const\n{\n    if (name == alignAttr) {\n        return false;\n    }\n\n    if (name == wrapAttr)\n        return true;\n    return HTMLTextFormControlElement::isPresentationAttribute(name);\n}\n",
        "output": "0",
        "index": 122435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RAnalBlock *r_anal_bb_from_offset(RAnal *anal, ut64 off) {\n\tRListIter *iter, *iter2;\n\tRAnalFunction *fcn;\n\tRAnalBlock *bb;\n\tr_list_foreach (anal->fcns, iter, fcn) {\n\t\tr_list_foreach (fcn->bbs, iter2, bb) {\n\t\t\tif (r_anal_bb_is_in_offset (bb, off)) {\n\t\t\t\treturn bb;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 82029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "storage::FileSystemContext* StoragePartitionImpl::GetFileSystemContext() {\n  return filesystem_context_.get();\n}\n",
        "output": "0",
        "index": 165392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_duration_warn(struct irq_work *w)\n{\n\tprintk_ratelimited(KERN_INFO\n\t\t\"perf: interrupt took too long (%lld > %lld), lowering \"\n\t\t\"kernel.perf_event_max_sample_rate to %d\\n\",\n\t\t__report_avg, __report_allowed,\n\t\tsysctl_perf_event_sample_rate);\n}\n",
        "output": "0",
        "index": 68344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ShelfWidget::PostCreateShelf() {\n  SetFocusCycler(Shell::Get()->focus_cycler());\n\n  shelf_layout_manager_->LayoutShelf();\n  shelf_layout_manager_->UpdateAutoHideState();\n  ShowIfHidden();\n}\n",
        "output": "0",
        "index": 142566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtnet_set_channels(struct net_device *dev,\n\t\t\t\tstruct ethtool_channels *channels)\n{\n\tstruct virtnet_info *vi = netdev_priv(dev);\n\tu16 queue_pairs = channels->combined_count;\n\tint err;\n\n\t/* We don't support separate rx/tx channels.\n\t * We don't allow setting 'other' channels.\n\t */\n\tif (channels->rx_count || channels->tx_count || channels->other_count)\n\t\treturn -EINVAL;\n\n\tif (queue_pairs > vi->max_queue_pairs || queue_pairs == 0)\n\t\treturn -EINVAL;\n\n\tget_online_cpus();\n\terr = virtnet_set_queues(vi, queue_pairs);\n\tif (!err) {\n\t\tnetif_set_real_num_tx_queues(dev, queue_pairs);\n\t\tnetif_set_real_num_rx_queues(dev, queue_pairs);\n\n\t\tvirtnet_set_affinity(vi);\n\t}\n\tput_online_cpus();\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 43011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoaderClient::dispatchDidCancelClientRedirect()\n{\n    notImplemented();\n}\n",
        "output": "0",
        "index": 98298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spawn_sync(WebKitWebView *web_view, GArray *argv, GString *result) {\n    (void)web_view; (void)result;\n    gchar *path = NULL;\n\n    if (argv_idx(argv, 0) &&\n            ((path = find_existing_file(argv_idx(argv, 0)))) ) {\n        run_command(path, 0,\n                ((const gchar **) (argv->data + sizeof(gchar*))),\n                    TRUE, &uzbl.comm.sync_stdout);\n        g_free(path);\n    }\n}\n",
        "output": "0",
        "index": 18408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebPage::isAtInitialZoom() const\n{\n    return (d->currentScale() == d->initialScale()) || !d->isUserScalable();\n}\n",
        "output": "0",
        "index": 111188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnDomOperationResponse(const std::string& json_string) {\n  std::string json = json_string;\n  NotificationService::current()->Notify(NOTIFICATION_DOM_OPERATION_RESPONSE,\n                                         Source<WebContents>(this),\n                                         Details<std::string>(&json));\n}\n",
        "output": "0",
        "index": 144601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SkColor AutofillPopupBaseView::GetFooterBackgroundColor() {\n  return GetNativeTheme()->GetSystemColor(\n      ui::NativeTheme::kColorId_HighlightedMenuItemBackgroundColor);\n}\n",
        "output": "0",
        "index": 141869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "content::WebContents* DevToolsWindow::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (!params.url.SchemeIs(chrome::kChromeDevToolsScheme)) {\n    content::WebContents* inspected_web_contents = GetInspectedWebContents();\n    return inspected_web_contents ?\n        inspected_web_contents->OpenURL(params) : NULL;\n  }\n\n  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();\n  scoped_refptr<DevToolsAgentHost> agent_host(\n      manager->GetDevToolsAgentHostFor(frontend_host_.get()));\n  if (!agent_host.get())\n    return NULL;\n  manager->ClientHostClosing(frontend_host_.get());\n  manager->RegisterDevToolsClientHostFor(agent_host.get(),\n                                         frontend_host_.get());\n\n  chrome::NavigateParams nav_params(profile_, params.url, params.transition);\n  FillNavigateParamsFromOpenURLParams(&nav_params, params);\n  nav_params.source_contents = source;\n  nav_params.tabstrip_add_types = TabStripModel::ADD_NONE;\n  nav_params.window_action = chrome::NavigateParams::SHOW_WINDOW;\n  nav_params.user_gesture = params.user_gesture;\n  chrome::Navigate(&nav_params);\n  return nav_params.target_contents;\n}\n",
        "output": "0",
        "index": 121447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}\n",
        "output": "0",
        "index": 48462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE\t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n",
        "output": "0",
        "index": 97051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BluetoothSocketListenUsingL2capFunction::CreateResults() {\n  return bluetooth_socket::ListenUsingL2cap::Results::Create();\n}\n",
        "output": "0",
        "index": 167091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ChildProcessSecurityPolicy::CanRequestURL(\n    int renderer_id, const GURL& url) {\n  if (!url.is_valid())\n    return false;  // Can't request invalid URLs.\n\n  if (IsWebSafeScheme(url.scheme()))\n    return true;  // The scheme has been white-listed for every renderer.\n\n  if (IsPseudoScheme(url.scheme())) {\n\n     if (url.SchemeIs(chrome::kViewSourceScheme) ||\n         url.SchemeIs(chrome::kPrintScheme)) {\n      return CanRequestURL(renderer_id, GURL(url.path()));\n     }\n \n     if (LowerCaseEqualsASCII(url.spec(), chrome::kAboutBlankURL))\n      return true;  // Every renderer can request <about:blank>.\n\n    return false;\n  }\n\n  if (!URLRequest::IsHandledURL(url))\n    return true;  // This URL request is destined for ShellExecute.\n\n  {\n    AutoLock lock(lock_);\n\n    SecurityStateMap::iterator state = security_state_.find(renderer_id);\n    if (state == security_state_.end())\n      return false;\n\n    return state->second->CanRequestURL(url);\n  }\n}\n",
        "output": "1",
        "index": 183623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Referrer RenderViewImpl::GetReferrerFromRequest(\n    WebFrame* frame,\n    const WebURLRequest& request) {\n  return Referrer(blink::WebStringToGURL(\n                      request.HttpHeaderField(WebString::FromUTF8(\"Referer\"))),\n                  request.GetReferrerPolicy());\n}\n",
        "output": "0",
        "index": 157933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   static void SetUpTestCase() {\n     mb_ = reinterpret_cast<MACROBLOCKD*>(\n        vpx_memalign(32, sizeof(MACROBLOCKD)));\n    mi_ = reinterpret_cast<MODE_INFO*>(\n        vpx_memalign(32, sizeof(MODE_INFO)));\n    data_array_ = reinterpret_cast<uint8_t*>(\n        vpx_memalign(kDataAlignment, kDataBufferSize));\n }\n",
        "output": "0",
        "index": 177648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceMessageFilter::OnGetPreferredExtensionForMimeType(\n    const std::string& mime_type, FilePath::StringType* ext) {\n  net::GetPreferredExtensionForMimeType(mime_type, ext);\n}\n",
        "output": "0",
        "index": 99312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_ksba_cert_get_subject_dn_ptr (ksba_cert_t cert,\n                               unsigned char const **ptr, size_t *length)\n{\n  asn_node_t n;\n\n  if (!cert || !cert->initialized || !ptr || !length)\n    return gpg_error (GPG_ERR_INV_VALUE);\n\n  n = _ksba_asn_find_node (cert->root, \"Certificate.tbsCertificate.subject\");\n  if (!n || !n->down)\n    return gpg_error (GPG_ERR_NO_VALUE); /* oops - should be there */\n  n = n->down; /* dereference the choice node */\n  if (n->off == -1)\n    return gpg_error (GPG_ERR_NO_VALUE);\n  *ptr = cert->image + n->off;\n  *length = n->nhdr + n->len;\n  return 0;\n}\n",
        "output": "0",
        "index": 10884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nonpaging_new_cr3(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n}\n",
        "output": "0",
        "index": 37557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> sequenceAttrAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.sequenceAttr._get\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    return v8Array(imp->sequenceAttr(), info.GetIsolate());\n}\n",
        "output": "0",
        "index": 117865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoGetUniformsES3CHROMIUM(\n    GLuint program,\n    std::vector<uint8_t>* data) {\n  GLuint service_program = 0;\n  if (!resources_->program_id_map.GetServiceID(program, &service_program)) {\n    return error::kNoError;\n  }\n\n  GLint num_uniforms = 0;\n  api()->glGetProgramivFn(service_program, GL_ACTIVE_UNIFORMS, &num_uniforms);\n\n  UniformsES3Header header;\n  header.num_uniforms = num_uniforms;\n  AppendValueToBuffer(data, header);\n\n  for (GLuint uniform_index = 0;\n       uniform_index < static_cast<GLuint>(num_uniforms); uniform_index++) {\n    UniformES3Info uniform_info;\n\n    GLint uniform_block_index = 0;\n    api()->glGetActiveUniformsivFn(service_program, 1, &uniform_index,\n                                   GL_UNIFORM_BLOCK_INDEX,\n                                   &uniform_block_index);\n    uniform_info.block_index = uniform_block_index;\n\n    GLint uniform_offset = 0;\n    api()->glGetActiveUniformsivFn(service_program, 1, &uniform_index,\n                                   GL_UNIFORM_OFFSET, &uniform_offset);\n    uniform_info.offset = uniform_offset;\n\n    GLint uniform_array_stride = 0;\n    api()->glGetActiveUniformsivFn(service_program, 1, &uniform_index,\n                                   GL_UNIFORM_ARRAY_STRIDE,\n                                   &uniform_array_stride);\n    uniform_info.array_stride = uniform_array_stride;\n\n    GLint uniform_matrix_stride = 0;\n    api()->glGetActiveUniformsivFn(service_program, 1, &uniform_index,\n                                   GL_UNIFORM_MATRIX_STRIDE,\n                                   &uniform_matrix_stride);\n    uniform_info.matrix_stride = uniform_matrix_stride;\n\n    GLint uniform_is_row_major = 0;\n    api()->glGetActiveUniformsivFn(service_program, 1, &uniform_index,\n                                   GL_UNIFORM_IS_ROW_MAJOR,\n                                   &uniform_is_row_major);\n    uniform_info.is_row_major = uniform_is_row_major;\n\n    AppendValueToBuffer(data, uniform_info);\n  }\n\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 154721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tprintk(KERN_ERR \"sock_release: fasync list not empty!\\n\");\n\n\tpercpu_sub(sockets_in_use, 1);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\n",
        "output": "0",
        "index": 22734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_vma_resv_set(struct vm_area_struct *vma, unsigned long flag)\n{\n\tVM_BUG_ON(!is_vm_hugetlb_page(vma));\n\n\treturn (get_vma_private_data(vma) & flag) != 0;\n}\n",
        "output": "0",
        "index": 19728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init relocate_initrd(void)\n{\n\t/* Assume only end is not page aligned */\n\tu64 ramdisk_image = get_ramdisk_image();\n\tu64 ramdisk_size  = get_ramdisk_size();\n\tu64 area_size     = PAGE_ALIGN(ramdisk_size);\n\n\t/* We need to move the initrd down into directly mapped mem */\n\trelocated_ramdisk = memblock_find_in_range(0, PFN_PHYS(max_pfn_mapped),\n\t\t\t\t\t\t   area_size, PAGE_SIZE);\n\n\tif (!relocated_ramdisk)\n\t\tpanic(\"Cannot find place for new RAMDISK of size %lld\\n\",\n\t\t      ramdisk_size);\n\n\t/* Note: this includes all the mem currently occupied by\n\t   the initrd, we rely on that fact to keep the data intact. */\n\tmemblock_reserve(relocated_ramdisk, area_size);\n\tinitrd_start = relocated_ramdisk + PAGE_OFFSET;\n\tinitrd_end   = initrd_start + ramdisk_size;\n\tprintk(KERN_INFO \"Allocated new RAMDISK: [mem %#010llx-%#010llx]\\n\",\n\t       relocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);\n\n\tcopy_from_early_mem((void *)initrd_start, ramdisk_image, ramdisk_size);\n\n\tprintk(KERN_INFO \"Move RAMDISK from [mem %#010llx-%#010llx] to\"\n\t\t\" [mem %#010llx-%#010llx]\\n\",\n\t\tramdisk_image, ramdisk_image + ramdisk_size - 1,\n\t\trelocated_ramdisk, relocated_ramdisk + ramdisk_size - 1);\n}\n",
        "output": "0",
        "index": 53797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\tsvm->vmcb->save.cpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\n \tmark_dirty(svm->vmcb, VMCB_SEG);\n }\n",
        "output": "0",
        "index": 41917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __ldsem_wake_writer(struct ld_semaphore *sem)\n{\n\tstruct ldsem_waiter *waiter;\n\n\twaiter = list_entry(sem->write_wait.next, struct ldsem_waiter, list);\n\twake_up_process(waiter->task);\n}\n",
        "output": "0",
        "index": 57835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ToUpperCase(\n\t/*! Input string to be converted. */\n\tchar *s)\n{\n\twhile (*s) {\n\t\t*s = (char)toupper(*s);\n\t\t++s;\n\t}\n}\n",
        "output": "0",
        "index": 73799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq)\n{\n\tswitch (qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\tcase MLX5_IB_QPT_REG_UMR:\n\tcase IB_QPT_XRC_INI:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_RAW_IPV6:\n\tcase IB_QPT_RAW_ETHERTYPE:\n\tcase IB_QPT_RAW_PACKET:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = ib_recv_cq ? to_mcq(ib_recv_cq) : NULL;\n\t\tbreak;\n\n\tcase IB_QPT_MAX:\n\tdefault:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\t}\n}\n",
        "output": "0",
        "index": 92112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n \t\t\tjas_free(siz->comps);\n \t\t\treturn -1;\n \t\t}\n \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n \t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
        "output": "1",
        "index": 181932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cqspi_erase(struct spi_nor *nor, loff_t offs)\n{\n\tint ret;\n\n\tret = cqspi_set_protocol(nor, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Send write enable, then erase commands. */\n\tret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Set up command buffer. */\n\tret = cqspi_command_write_addr(nor, nor->erase_opcode, offs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 93667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\treturn __vmcs_readl(field);\n}\n",
        "output": "0",
        "index": 48099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GetEntriesString(Entries *entries, char *str)\n{\n    Buffer buff;\n\n    if (str && *str) {\n\tbuff.buff = str;\n\tbuff.used = strlen(str);\n\tGetEntries(entries, &buff, 1);\n    }\n}\n",
        "output": "0",
        "index": 5065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HTMLButtonElement::canBeSuccessfulSubmitButton() const\n{\n    return m_type == SUBMIT;\n}\n",
        "output": "0",
        "index": 122237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dispatchImsSms(Parcel &p, RequestInfo *pRI) {\n int32_t  t;\n status_t status = p.readInt32(&t);\n    RIL_RadioTechnologyFamily format;\n uint8_t retry;\n int32_t messageRef;\n\n    RLOGD(\"dispatchImsSms\");\n if (status != NO_ERROR) {\n goto invalid;\n }\n    format = (RIL_RadioTechnologyFamily) t;\n\n    status = p.read(&retry,sizeof(retry));\n if (status != NO_ERROR) {\n goto invalid;\n }\n    status = p.read(&messageRef,sizeof(messageRef));\n if (status != NO_ERROR) {\n goto invalid;\n }\n\n if (RADIO_TECH_3GPP == format) {\n        dispatchImsGsmSms(p, pRI, retry, messageRef);\n } else if (RADIO_TECH_3GPP2 == format) {\n        dispatchImsCdmaSms(p, pRI, retry, messageRef);\n } else {\n        ALOGE(\"requestImsSendSMS invalid format value =%d\", format);\n }\n\n return;\n\ninvalid:\n    invalidCommandBlock(pRI);\n return;\n}\n",
        "output": "0",
        "index": 175271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ati_remote2_resume(struct usb_interface *interface)\n{\n\tstruct ati_remote2 *ar2;\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tint r = 0;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tar2 = usb_get_intfdata(interface);\n\n\tdev_dbg(&ar2->intf[0]->dev, \"%s()\\n\", __func__);\n\n\tmutex_lock(&ati_remote2_mutex);\n\n\tif (ar2->flags & ATI_REMOTE2_OPENED)\n\t\tr = ati_remote2_submit_urbs(ar2);\n\n\tif (!r)\n\t\tar2->flags &= ~ATI_REMOTE2_SUSPENDED;\n\n\tmutex_unlock(&ati_remote2_mutex);\n\n\treturn r;\n}\n",
        "output": "0",
        "index": 55223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::ResumeBlockedRequestsForFrame() {\n  if (base::FeatureList::IsEnabled(network::features::kNetworkService)) {\n    ForEachFrame(\n        this, base::BindRepeating([](RenderFrameHostImpl* render_frame_host) {\n          if (render_frame_host->frame_)\n            render_frame_host->frame_->ResumeBlockedRequests();\n        }));\n  } else {\n    NotifyForEachFrameFromUI(\n        this, base::BindRepeating(\n                  &ResourceDispatcherHostImpl::ResumeBlockedRequestsForRoute));\n  }\n}\n",
        "output": "0",
        "index": 152075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}\n",
        "output": "0",
        "index": 37732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_EVEN( TT_ExecContext  exc,\n            FT_Long*        args )\n  {\n    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 0 );\n  }\n",
        "output": "0",
        "index": 10595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lock_mutex(pthread_mutex_t *l)\n{\n\tint ret;\n\n\tif ((ret = pthread_mutex_lock(l)) != 0) {\n\t\tfprintf(stderr, \"pthread_mutex_lock returned:%d %s\\n\", ret, strerror(ret));\n\t\tdump_stacktrace();\n\t\texit(1);\n\t}\n}\n",
        "output": "0",
        "index": 44765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string DownloadItemImpl::GetSuggestedFilename() const {\n  return request_info_.suggested_filename;\n}\n",
        "output": "0",
        "index": 159142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void delayed_calls_add(int type, gpointer data)\n{\n  DelayedCall *dcall = NPW_MemNew(DelayedCall, 1);\n  if (dcall == NULL)\n\treturn;\n  dcall->type = type;\n  dcall->data = data;\n  g_delayed_calls = g_list_append(g_delayed_calls, dcall);\n\n  if (g_delayed_calls_id == 0)\n\tg_delayed_calls_id = g_idle_add_full(G_PRIORITY_LOW,\n\t\t\t\t\t\t\t\t\t\t delayed_calls_process_cb, NULL, NULL);\n}\n",
        "output": "0",
        "index": 27024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)\n{\n\tstruct page *page;\n\tint r;\n\n\tmutex_init(&vcpu->mutex);\n\tvcpu->cpu = -1;\n\tvcpu->kvm = kvm;\n\tvcpu->vcpu_id = id;\n\tvcpu->pid = NULL;\n\tinit_waitqueue_head(&vcpu->wq);\n\tkvm_async_pf_vcpu_init(vcpu);\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!page) {\n\t\tr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tvcpu->run = page_address(page);\n\n\tkvm_vcpu_set_in_spin_loop(vcpu, false);\n\tkvm_vcpu_set_dy_eligible(vcpu, false);\n\tvcpu->preempted = false;\n\n\tr = kvm_arch_vcpu_init(vcpu);\n\tif (r < 0)\n\t\tgoto fail_free_run;\n\treturn 0;\n\nfail_free_run:\n\tfree_page((unsigned long)vcpu->run);\nfail:\n\treturn r;\n}\n",
        "output": "0",
        "index": 29353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)\n{\n\tif (!crypto_str)\n\t\treturn;\n\tkfree(crypto_str->name);\n\tcrypto_str->name = NULL;\n}\n",
        "output": "0",
        "index": 67653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestingAutomationProvider::GetTab(int win_handle,\n                                       int tab_index,\n                                       int* tab_handle) {\n  *tab_handle = 0;\n  if (browser_tracker_->ContainsHandle(win_handle) && (tab_index >= 0)) {\n    Browser* browser = browser_tracker_->GetResource(win_handle);\n    if (tab_index < browser->tab_count()) {\n      WebContents* web_contents = browser->GetWebContentsAt(tab_index);\n      *tab_handle = tab_tracker_->Add(&web_contents->GetController());\n    }\n  }\n}\n",
        "output": "0",
        "index": 114950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Textfield::OnBlur() {\n  gfx::RenderText* render_text = GetRenderText();\n  render_text->set_focused(false);\n\n  if (PlatformStyle::kTextfieldScrollsToStartOnFocusChange)\n    model_->MoveCursorTo(gfx::SelectionModel(0, gfx::CURSOR_FORWARD));\n\n  if (GetInputMethod()) {\n    GetInputMethod()->DetachTextInputClient(this);\n#if defined(OS_CHROMEOS)\n    wm::RestoreWindowBoundsOnClientFocusLost(\n        GetNativeView()->GetToplevelWindow());\n#endif  // defined(OS_CHROMEOS)\n  }\n  StopBlinkingCursor();\n  cursor_view_.SetVisible(false);\n\n  DestroyTouchSelection();\n\n  if (use_focus_ring_)\n     FocusRing::Uninstall(this);\n   SchedulePaint();\n   View::OnBlur();\n }\n",
        "output": "1",
        "index": 185737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NavigationController::NavigateToPendingEntry(bool reload) {\n  if (!pending_entry_) {\n    DCHECK(pending_entry_index_ != -1);\n    pending_entry_ = entries_[pending_entry_index_].get();\n  }\n\n  if (!tab_contents_->NavigateToPendingEntry(reload))\n    DiscardNonCommittedEntries();\n}\n",
        "output": "0",
        "index": 97127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}\n",
        "output": "0",
        "index": 67351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n \t};\n \tstruct rpc_cred *cred;\n \tstruct nfs4_state *state;\n \n \tcred = rpc_lookup_cred();\n \tif (IS_ERR(cred))\n \t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n \tput_rpccred(cred);\n \tif (IS_ERR(state)) {\n \t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n \t}\n \tif (state->inode == dentry->d_inode) {\n \t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n \t\treturn 1;\n \t}\n\tnfs4_close_sync(&path, state, openflags);\n out_drop:\n \td_drop(dentry);\n \treturn 0;\n}\n",
        "output": "1",
        "index": 178871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "filter_show_space(fz_context *ctx, pdf_filter_processor *p, float tadj)\n{\n\tfilter_gstate *gstate = p->gstate;\n\tpdf_font_desc *fontdesc = gstate->pending.text.font;\n\n\tif (fontdesc->wmode == 0)\n\t\tp->tos.tm = fz_pre_translate(p->tos.tm, tadj * gstate->pending.text.scale, 0);\n\telse\n\t\tp->tos.tm = fz_pre_translate(p->tos.tm, 0, tadj);\n}\n",
        "output": "0",
        "index": 1824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ResetOverlapped(LPOVERLAPPED overlapped)\n{\n    HANDLE io_event = overlapped->hEvent;\n    if (!ResetEvent(io_event))\n    {\n        return FALSE;\n    }\n    ZeroMemory(overlapped, sizeof(OVERLAPPED));\n    overlapped->hEvent = io_event;\n    return TRUE;\n}\n",
        "output": "0",
        "index": 83413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Resource* ResourceFetcher::ResourceForStaticData(\n    const FetchRequest& request,\n    const ResourceFactory& factory,\n    const SubstituteData& substitute_data) {\n  const KURL& url = request.GetResourceRequest().Url();\n  DCHECK(url.ProtocolIsData() || substitute_data.IsValid() || archive_);\n\n  if (!archive_ && !substitute_data.IsValid() &&\n      (factory.GetType() == Resource::kMainResource ||\n       factory.GetType() == Resource::kRaw))\n    return nullptr;\n\n  const String cache_identifier = GetCacheIdentifier();\n  if (Resource* old_resource =\n          GetMemoryCache()->ResourceForURL(url, cache_identifier)) {\n    if (request.Options().data_buffering_policy != kDoNotBufferData)\n      return old_resource;\n    GetMemoryCache()->Remove(old_resource);\n  }\n\n  ResourceResponse response;\n  RefPtr<SharedBuffer> data;\n  if (substitute_data.IsValid()) {\n    data = substitute_data.Content();\n    response.SetURL(url);\n    response.SetMimeType(substitute_data.MimeType());\n    response.SetExpectedContentLength(data->size());\n    response.SetTextEncodingName(substitute_data.TextEncoding());\n  } else if (url.ProtocolIsData()) {\n    data = NetworkUtils::ParseDataURLAndPopulateResponse(url, response);\n    if (!data)\n      return nullptr;\n  } else {\n    ArchiveResource* archive_resource =\n        archive_->SubresourceForURL(request.Url());\n    if (!archive_resource)\n      return nullptr;\n    data = archive_resource->Data();\n    response.SetURL(url);\n    response.SetMimeType(archive_resource->MimeType());\n    response.SetExpectedContentLength(data->size());\n    response.SetTextEncodingName(archive_resource->TextEncoding());\n  }\n\n  Resource* resource = factory.Create(request.GetResourceRequest(),\n                                      request.Options(), request.Charset());\n  resource->SetNeedsSynchronousCacheHit(substitute_data.ForceSynchronousLoad());\n  resource->ResponseReceived(response, nullptr);\n  resource->SetDataBufferingPolicy(kBufferData);\n  if (data->size())\n    resource->SetResourceBuffer(data);\n  resource->SetIdentifier(CreateUniqueIdentifier());\n  resource->SetCacheIdentifier(cache_identifier);\n  resource->Finish();\n\n  if (!substitute_data.IsValid())\n    GetMemoryCache()->Add(resource);\n\n  return resource;\n}\n",
        "output": "0",
        "index": 139745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void XMLHttpRequest::resume()\n{\n    m_progressEventThrottle.resume();\n}\n",
        "output": "0",
        "index": 119198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static loff_t shmem_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tpgoff_t start, end;\n\tloff_t new_offset;\n\n\tif (whence != SEEK_DATA && whence != SEEK_HOLE)\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\tMAX_LFS_FILESIZE, i_size_read(inode));\n\tmutex_lock(&inode->i_mutex);\n\t/* We're holding i_mutex so we can access i_size directly */\n\n\tif (offset < 0)\n\t\toffset = -EINVAL;\n\telse if (offset >= inode->i_size)\n\t\toffset = -ENXIO;\n\telse {\n\t\tstart = offset >> PAGE_CACHE_SHIFT;\n\t\tend = (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\t\tnew_offset = shmem_seek_hole_data(mapping, start, end, whence);\n\t\tnew_offset <<= PAGE_CACHE_SHIFT;\n\t\tif (new_offset > offset) {\n\t\t\tif (new_offset < inode->i_size)\n\t\t\t\toffset = new_offset;\n\t\t\telse if (whence == SEEK_DATA)\n\t\t\t\toffset = -ENXIO;\n\t\t\telse\n\t\t\t\toffset = inode->i_size;\n\t\t}\n\t}\n\n\tif (offset >= 0 && offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\treturn offset;\n}\n",
        "output": "0",
        "index": 33499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::WebContentsTreeNode::ConnectToOuterWebContents(\n    WebContentsImpl* outer_web_contents,\n    RenderFrameHostImpl* outer_contents_frame) {\n  outer_web_contents_ = outer_web_contents;\n  outer_contents_frame_tree_node_id_ =\n      outer_contents_frame->frame_tree_node()->frame_tree_node_id();\n\n  if (!outer_web_contents_->node_)\n    outer_web_contents_->node_.reset(new WebContentsTreeNode());\n\n  outer_web_contents_->node_->inner_web_contents_tree_nodes_.insert(this);\n}\n",
        "output": "0",
        "index": 144447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Color correctedTextColor(Color textColor, Color backgroundColor) \n{\n    \n    int d = differenceSquared(textColor, backgroundColor);\n    if (d > 65025) {\n        return textColor;\n    }\n    \n    int distanceFromWhite = differenceSquared(textColor, Color::white);\n    int distanceFromBlack = differenceSquared(textColor, Color::black);\n\n    if (distanceFromWhite < distanceFromBlack) {\n        return textColor.dark();\n    }\n    \n    return textColor.light();\n}\n",
        "output": "0",
        "index": 108011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "content::RenderFrameHost* GetMainFrame(content::RenderFrameHost* rfh) {\n  while (rfh->GetParent() != nullptr)\n    rfh = rfh->GetParent();\n  return rfh;\n}\n",
        "output": "0",
        "index": 152827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tcp_done(struct sock *sk)\n{\n\tstruct request_sock *req = tcp_sk(sk)->fastopen_rsk;\n\n\tif (sk->sk_state == TCP_SYN_SENT || sk->sk_state == TCP_SYN_RECV)\n\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_ATTEMPTFAILS);\n\n\ttcp_set_state(sk, TCP_CLOSE);\n\ttcp_clear_xmit_timers(sk);\n\tif (req)\n\t\treqsk_fastopen_remove(sk, req, false);\n\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_state_change(sk);\n\telse\n\t\tinet_csk_destroy_sock(sk);\n}\n",
        "output": "0",
        "index": 61738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ExtensionInstallPrompt::~ExtensionInstallPrompt() {\n}\n",
        "output": "0",
        "index": 144399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}\n",
        "output": "0",
        "index": 65685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mwifiex_ie_index_used_by_other_intf(struct mwifiex_private *priv, u16 idx)\n{\n\tint i;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_ie *ie;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tif (adapter->priv[i] != priv) {\n\t\t\tie = &adapter->priv[i]->mgmt_ie[idx];\n\t\t\tif (ie->mgmt_subtype_mask && ie->ie_length)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 88605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HTMLPreloadScanner::HTMLPreloadScanner(Document* document, const HTMLParserOptions& options)\n    : m_document(document)\n     , m_cssScanner(document)\n     , m_tokenizer(HTMLTokenizer::create(options))\n     , m_inStyle(false)\n {\n }\n",
        "output": "1",
        "index": 184495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_warc_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *hdr;\n\tssize_t nrd;\n\tunsigned int ver;\n\n\t(void)best_bid; /* UNUSED */\n\n\t/* check first line of file, it should be a record already */\n\tif ((hdr = __archive_read_ahead(a, 12U, &nrd)) == NULL) {\n\t\t/* no idea what to do */\n\t\treturn -1;\n\t} else if (nrd < 12) {\n\t\t/* nah, not for us, our magic cookie is at least 12 bytes */\n\t\treturn -1;\n\t}\n\n\t/* otherwise snarf the record's version number */\n\tver = _warc_rdver(hdr, nrd);\n\tif (ver < 1200U || ver > 10000U) {\n\t\t/* we only support WARC 0.12 to 1.0 */\n\t\treturn -1;\n\t}\n\n\t/* otherwise be confident */\n\treturn (64);\n}\n",
        "output": "0",
        "index": 74904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Sg_device *sg_lookup_dev(int dev)\n{\n\treturn idr_find(&sg_index_idr, dev);\n}\n",
        "output": "0",
        "index": 42273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsmp_end_session (GsmClient *client,\n                  guint      flags,\n                  GError   **error)\n{\n        gboolean phase2;\n\n        if (GSM_XSMP_CLIENT (client)->priv->conn == NULL) {\n                g_set_error (error,\n                             GSM_CLIENT_ERROR,\n                             GSM_CLIENT_ERROR_NOT_REGISTERED,\n                             \"Client is not registered\");\n                return FALSE;\n        }\n\n        phase2 = (flags & GSM_CLIENT_END_SESSION_FLAG_LAST);\n\n        if (phase2) {\n                xsmp_save_yourself_phase2 (client);\n        } else {\n                gboolean allow_interact;\n                int      save_type;\n\n                /* we gave a chance to interact to the app during\n                 * xsmp_query_end_session(), now it's too late to interact */\n                allow_interact = FALSE;\n\n                if (flags & GSM_CLIENT_END_SESSION_FLAG_SAVE) {\n                        save_type = SmSaveBoth;\n                } else {\n                        save_type = SmSaveGlobal;\n                }\n\n                do_save_yourself (GSM_XSMP_CLIENT (client),\n                                  save_type, allow_interact);\n        }\n\n        return TRUE;\n}\n",
        "output": "0",
        "index": 63581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    explicit MockServiceObserver(AppCacheStorageImplTest* test) : test_(test) {}\n",
        "output": "0",
        "index": 164188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OxideQQuickWebView::setCanTemporarilyRunInsecureContent(bool allow) {\n  Q_D(OxideQQuickWebView);\n\n  if (!d->proxy_) {\n    return;\n  }\n\n  d->proxy_->setCanTemporarilyRunInsecureContent(allow);\n}\n",
        "output": "0",
        "index": 17159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit sha1_mod_fini(void)\n{\n\tcrypto_unregister_shash(&alg);\n}\n",
        "output": "0",
        "index": 46604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBlockFlow::clearFloats(EClear clear)\n{\n    positionNewFloats();\n    LayoutUnit newY = 0;\n    switch (clear) {\n    case CLEFT:\n        newY = lowestFloatLogicalBottom(FloatingObject::FloatLeft);\n        break;\n    case CRIGHT:\n        newY = lowestFloatLogicalBottom(FloatingObject::FloatRight);\n        break;\n    case CBOTH:\n        newY = lowestFloatLogicalBottom();\n    default:\n        break;\n    }\n    if (height() < newY)\n        setLogicalHeight(newY);\n}\n",
        "output": "0",
        "index": 124686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t ThreadHeap::ObjectPayloadSizeForTesting() {\n  ThreadState::AtomicPauseScope atomic_pause_scope(thread_state_);\n  size_t object_payload_size = 0;\n  thread_state_->SetGCPhase(ThreadState::GCPhase::kMarking);\n  thread_state_->Heap().MakeConsistentForGC();\n  thread_state_->Heap().PrepareForSweep();\n  for (int i = 0; i < BlinkGC::kNumberOfArenas; ++i)\n    object_payload_size += arenas_[i]->ObjectPayloadSizeForTesting();\n  MakeConsistentForMutator();\n  thread_state_->SetGCPhase(ThreadState::GCPhase::kSweeping);\n  thread_state_->SetGCPhase(ThreadState::GCPhase::kNone);\n  return object_payload_size;\n}\n",
        "output": "0",
        "index": 166696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebContents* PrintPreviewMessageHandler::GetPrintPreviewDialog() {\n  PrintPreviewDialogController* dialog_controller =\n      PrintPreviewDialogController::GetInstance();\n  if (!dialog_controller)\n    return nullptr;\n  return dialog_controller->GetPrintPreviewForContents(web_contents());\n}\n",
        "output": "0",
        "index": 137688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_entries(struct net *net, struct ip6t_get_entries __user *uptr,\n\t    const int *len)\n{\n\tint ret;\n\tstruct ip6t_get_entries get;\n\tstruct xt_table *t;\n\n\tif (*len < sizeof(get))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&get, uptr, sizeof(get)) != 0)\n\t\treturn -EFAULT;\n\tif (*len != sizeof(struct ip6t_get_entries) + get.size)\n\t\treturn -EINVAL;\n\n\tget.name[sizeof(get.name) - 1] = '\\0';\n\n\tt = xt_find_table_lock(net, AF_INET6, get.name);\n\tif (!IS_ERR(t)) {\n\t\tstruct xt_table_info *private = t->private;\n\t\tif (get.size == private->size)\n\t\t\tret = copy_entries_to_user(private->size,\n\t\t\t\t\t\t   t, uptr->entrytable);\n\t\telse\n\t\t\tret = -EAGAIN;\n\n\t\tmodule_put(t->me);\n\t\txt_table_unlock(t);\n\t} else\n\t\tret = PTR_ERR(t);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 85028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_elf_states(struct user_ta_ctx *utc)\n{\n\tstruct user_ta_elf *elf;\n\n\tTAILQ_FOREACH(elf, &utc->elfs, link)\n\t\t\telf_load_final(elf->elf_state);\n}\n",
        "output": "0",
        "index": 86935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "circuit_resume_edge_reading(circuit_t *circ, crypt_path_t *layer_hint)\n{\n  if (circuit_queue_streams_are_blocked(circ)) {\n    log_debug(layer_hint?LD_APP:LD_EXIT,\"Too big queue, no resuming\");\n    return;\n  }\n  log_debug(layer_hint?LD_APP:LD_EXIT,\"resuming\");\n\n  if (CIRCUIT_IS_ORIGIN(circ))\n    circuit_resume_edge_reading_helper(TO_ORIGIN_CIRCUIT(circ)->p_streams,\n                                       circ, layer_hint);\n  else\n    circuit_resume_edge_reading_helper(TO_OR_CIRCUIT(circ)->n_streams,\n                                       circ, layer_hint);\n}\n",
        "output": "0",
        "index": 69849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SecurityFunctionTableA* SEC_ENTRY InitSecurityInterfaceA(void)\n{\n\treturn &SSPI_SecurityFunctionTableA;\n}\n",
        "output": "0",
        "index": 58586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline float harfBuzzPositionToFloat(hb_position_t value)\n{\n    return static_cast<float>(value) / (1 << 16);\n}\n",
        "output": "0",
        "index": 139312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool fb_do_apertures_overlap(struct apertures_struct *gena,\n\t\t\t\t    struct apertures_struct *hwa)\n{\n\tint i, j;\n\tif (!hwa || !gena)\n\t\treturn false;\n\n\tfor (i = 0; i < hwa->count; ++i) {\n\t\tstruct aperture *h = &hwa->ranges[i];\n\t\tfor (j = 0; j < gena->count; ++j) {\n\t\t\tstruct aperture *g = &gena->ranges[j];\n\t\t\tprintk(KERN_DEBUG \"checking generic (%llx %llx) vs hw (%llx %llx)\\n\",\n\t\t\t\t(unsigned long long)g->base,\n\t\t\t\t(unsigned long long)g->size,\n\t\t\t\t(unsigned long long)h->base,\n\t\t\t\t(unsigned long long)h->size);\n\t\t\tif (apertures_overlap(g, h))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n",
        "output": "0",
        "index": 31129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BookmarkManagerView::PrepareForShow() {\n  int split_x = g_browser_process->local_state()->GetInteger(\n      prefs::kBookmarkManagerSplitLocation);\n  if (split_x == -1) {\n    split_x = split_view_->width() / 3;\n  }\n  int min_split_size = split_view_->width() / 8;\n  split_x = std::min(split_view_->width() - min_split_size,\n                     std::max(min_split_size, split_x));\n  split_view_->set_divider_x(split_x);\n  if (!GetBookmarkModel()->IsLoaded()) {\n    search_tf_->SetReadOnly(true);\n    return;\n  }\n\n  LoadedImpl();\n}\n",
        "output": "0",
        "index": 117373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::DidNavigateWithinPage(\n    const blink::WebHistoryItem& item,\n    blink::WebHistoryCommitType commit_type,\n    bool content_initiated) {\n  TRACE_EVENT1(\"navigation,rail\", \"RenderFrameImpl::didNavigateWithinPage\",\n               \"id\", routing_id_);\n  DocumentState* document_state =\n      DocumentState::FromDocumentLoader(frame_->GetDocumentLoader());\n  UpdateNavigationState(document_state, true /* was_within_same_document */,\n                        content_initiated);\n  static_cast<NavigationStateImpl*>(document_state->navigation_state())\n      ->set_was_within_same_document(true);\n\n  DidCommitProvisionalLoad(item, commit_type,\n                           blink::WebGlobalObjectReusePolicy::kUseExisting);\n}\n",
        "output": "0",
        "index": 160591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_set_key_length(VALUE self, VALUE key_length)\n{\n    int len = NUM2INT(key_length);\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n    if (EVP_CIPHER_CTX_set_key_length(ctx, len) != 1)\n        ossl_raise(eCipherError, NULL);\n\n    return key_length;\n}\n",
        "output": "0",
        "index": 73424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)\n{\n  if (length < 7)\n    return(MagickFalse);\n  if (memcmp(magick,\"#define\",7) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n",
        "output": "0",
        "index": 61494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dm_lock_md_type(struct mapped_device *md)\n{\n\tmutex_lock(&md->type_lock);\n}\n",
        "output": "0",
        "index": 85914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void idt_invalidate(void *addr)\n{\n\tstruct desc_ptr idt = { .address = (unsigned long) addr, .size = 0 };\n\n\tload_idt(&idt);\n}\n",
        "output": "0",
        "index": 83472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (parent && !jsvIsFunction(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}\n",
        "output": "0",
        "index": 82325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "String HTMLFormElement::name() const\n{\n    return getNameAttribute();\n}\n",
        "output": "0",
        "index": 119254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Resource::WillFollowRedirect(const ResourceRequest& new_request,\n                                  const ResourceResponse& redirect_response) {\n  if (is_revalidating_)\n    RevalidationFailed();\n  redirect_chain_.push_back(RedirectPair(new_request, redirect_response));\n  return true;\n}\n",
        "output": "0",
        "index": 162590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::WasHidden() {\n  is_hidden_ = true;\n\n  StopHangMonitorTimeout();\n\n  Send(new ViewMsg_WasHidden(routing_id_));\n\n  process_->WidgetHidden();\n\n  bool is_visible = false;\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED,\n      Source<RenderWidgetHost>(this),\n      Details<bool>(&is_visible));\n}\n",
        "output": "0",
        "index": 123075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\n\tmutex_lock(&kvm->lock);\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}\n",
        "output": "0",
        "index": 20407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PSOutputDev::clip(GfxState *state) {\n  doPath(state->getPath());\n  writePS(\"W\\n\");\n}\n",
        "output": "0",
        "index": 1223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_stop_nmi_watchdog(void *unused)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\tstop_nmi_watchdog(NULL);\n\tcpuc->pcr = pcr_ops->read();\n}\n",
        "output": "0",
        "index": 25657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}\n",
        "output": "0",
        "index": 39995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "png_zlib_inflate(png_structrp png_ptr, int flush)\n{\n   if (png_ptr->zstream_start && png_ptr->zstream.avail_in > 0)\n   {\n      if ((*png_ptr->zstream.next_in >> 4) > 7)\n      {\n         png_ptr->zstream.msg = \"invalid window size (libpng)\";\n         return Z_DATA_ERROR;\n      }\n\n      png_ptr->zstream_start = 0;\n   }\n\n   return inflate(&png_ptr->zstream, flush);\n}\n",
        "output": "0",
        "index": 79767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GuestViewBase::DispatchEventToGuestProxy(GuestViewEvent* event) {\n  event->Dispatch(this, guest_instance_id_);\n}\n",
        "output": "0",
        "index": 134719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdImagePtr gdImageScaleBilinear(gdImagePtr im, const unsigned int new_width, const unsigned int new_height)\n{\n\tif (im->trueColor) {\n\t\treturn gdImageScaleBilinearTC(im, new_width, new_height);\n\t} else {\n\t\treturn gdImageScaleBilinearPalette(im, new_width, new_height);\n\t}\n}\n",
        "output": "0",
        "index": 58412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,\n\t\tunsigned int id)\n{\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long vm_base = kvm->arch.vm_base;\n\tint r;\n\tint cpu;\n\n\tBUG_ON(sizeof(struct kvm_vcpu) > VCPU_STRUCT_SIZE/2);\n\n\tr = -EINVAL;\n\tif (id >= KVM_MAX_VCPUS) {\n\t\tprintk(KERN_ERR\"kvm: Can't configure vcpus > %ld\",\n\t\t\t\tKVM_MAX_VCPUS);\n\t\tgoto fail;\n\t}\n\n\tr = -ENOMEM;\n\tif (!vm_base) {\n\t\tprintk(KERN_ERR\"kvm: Create vcpu[%d] error!\\n\", id);\n\t\tgoto fail;\n\t}\n\tvcpu = (struct kvm_vcpu *)(vm_base + offsetof(struct kvm_vm_data,\n\t\t\t\t\tvcpu_data[id].vcpu_struct));\n\tvcpu->kvm = kvm;\n\n\tcpu = get_cpu();\n\tr = vti_vcpu_setup(vcpu, id);\n\tput_cpu();\n\n\tif (r) {\n\t\tprintk(KERN_DEBUG\"kvm: vcpu_setup error!!\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn vcpu;\nfail:\n\treturn ERR_PTR(r);\n}\n",
        "output": "0",
        "index": 20593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n{\n    tcg_gen_ext16u_tl(cpu_T0, cpu_T0);\n    tcg_gen_st32_tl(cpu_T0, cpu_env,\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n    tcg_gen_shli_tl(cpu_seg_base[seg_reg], cpu_T0, 4);\n}\n",
        "output": "0",
        "index": 66376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ResourceError WebFrameLoaderClient::cannotShowURLError(const ResourceRequest&) {\n  return ResourceError();\n}\n",
        "output": "0",
        "index": 97161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}\n",
        "output": "0",
        "index": 26911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AtomicString Document::convertLocalName(const AtomicString& name)\n{\n    return isHTMLDocument() ? name.lower() : name;\n}\n",
        "output": "0",
        "index": 135173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL transport_connect(rdpTransport* transport, const char* hostname, UINT16 port)\n{\n\tBOOL status = FALSE;\n\trdpSettings* settings = transport->settings;\n\n\ttransport->async = transport->settings->AsyncTransport;\n\n\tif (transport->async)\n\t{\n\t\ttransport->stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->thread = CreateThread(NULL, 0,\n\t\t\t\t(LPTHREAD_START_ROUTINE) transport_client_thread, transport, 0, NULL);\n\t}\n\n\tif (transport->settings->GatewayUsageMethod)\n\t{\n\t\ttransport->layer = TRANSPORT_LAYER_TSG;\n\t\ttransport->TcpOut = tcp_new(settings);\n\n\t\tstatus = tcp_connect(transport->TcpIn, settings->GatewayHostname, 443);\n\n\t\tif (status)\n\t\t\tstatus = tcp_connect(transport->TcpOut, settings->GatewayHostname, 443);\n\n\t\tif (status)\n\t\t\tstatus = transport_tsg_connect(transport, hostname, port);\n\t}\n\telse\n\t{\n\t\tstatus = tcp_connect(transport->TcpIn, hostname, port);\n\n\t\ttransport->SplitInputOutput = FALSE;\n\t\ttransport->TcpOut = transport->TcpIn;\n\t}\n\n\treturn status;\n}\n",
        "output": "0",
        "index": 58555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_set_rto(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\t/* Old crap is replaced with new one. 8)\n\t *\n\t * More seriously:\n\t * 1. If rtt variance happened to be less 50msec, it is hallucination.\n\t *    It cannot be less due to utterly erratic ACK generation made\n\t *    at least by solaris and freebsd. \"Erratic ACKs\" has _nothing_\n\t *    to do with delayed acks, because at cwnd>2 true delack timeout\n\t *    is invisible. Actually, Linux-2.4 also generates erratic\n\t *    ACKs in some circumstances.\n\t */\n\tinet_csk(sk)->icsk_rto = __tcp_set_rto(tp);\n\n\t/* 2. Fixups made earlier cannot be right.\n\t *    If we do not estimate RTO correctly without them,\n\t *    all the algo is pure shit and should be replaced\n\t *    with correct one. It is exactly, which we pretend to do.\n\t */\n\n\t/* NOTE: clamping at TCP_RTO_MIN is not required, current algo\n\t * guarantees that rto is higher.\n\t */\n\ttcp_bound_rto(sk);\n}\n",
        "output": "0",
        "index": 51611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ChromeRenderProcessObserver::OnSetFieldTrialGroup(\n     const std::string& field_trial_name,\n     const std::string& group_name) {\n  base::FieldTrialList::CreateFieldTrial(field_trial_name, group_name);\n  chrome_variations::SetChildProcessLoggingVariationList();\n}\n",
        "output": "0",
        "index": 108459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CCThreadProxy::initializeImplOnCCThread(CCCompletionEvent* completion)\n{\n    TRACE_EVENT(\"CCThreadProxy::initializeImplOnCCThread\", this, 0);\n    ASSERT(isImplThread());\n    m_layerTreeHostImpl = m_layerTreeHost->createLayerTreeHostImpl();\n    m_schedulerClientOnCCThread = CCThreadProxySchedulerClient::create(this);\n    m_schedulerOnCCThread = CCScheduler::create(m_schedulerClientOnCCThread.get());\n    completion->signal();\n}\n",
        "output": "0",
        "index": 102714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initiate_graceful_shutdown(h2o_context_t *ctx)\n{\n    /* draft-16 6.8\n     * A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last stream\n     * identifier set to 231-1 and a NO_ERROR code. This signals to the client that a shutdown is imminent and that no further\n     * requests can be initiated. After waiting at least one round trip time, the server can send another GOAWAY frame with an\n     * updated last stream identifier. This ensures that a connection can be cleanly shut down without losing requests.\n     */\n    h2o_linklist_t *node;\n\n    /* only doit once */\n    if (ctx->http2._graceful_shutdown_timeout.cb != NULL)\n        return;\n    ctx->http2._graceful_shutdown_timeout.cb = graceful_shutdown_resend_goaway;\n\n    for (node = ctx->http2._conns.next; node != &ctx->http2._conns; node = node->next) {\n        h2o_http2_conn_t *conn = H2O_STRUCT_FROM_MEMBER(h2o_http2_conn_t, _conns, node);\n        if (conn->state < H2O_HTTP2_CONN_STATE_HALF_CLOSED) {\n            h2o_http2_encode_goaway_frame(&conn->_write.buf, INT32_MAX, H2O_HTTP2_ERROR_NONE,\n                                          (h2o_iovec_t){H2O_STRLIT(\"graceful shutdown\")});\n            h2o_http2_conn_request_write(conn);\n        }\n    }\n    h2o_timeout_link(ctx->loop, &ctx->one_sec_timeout, &ctx->http2._graceful_shutdown_timeout);\n}\n",
        "output": "0",
        "index": 52571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pfkey_sockaddr_len(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sizeof(struct sockaddr_in);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\treturn sizeof(struct sockaddr_in6);\n#endif\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 31464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int show_bisect_vars(struct rev_list_info *info, int reaches, int all)\n{\n\tint cnt, flags = info->flags;\n\tchar hex[GIT_SHA1_HEXSZ + 1] = \"\";\n\tstruct commit_list *tried;\n\tstruct rev_info *revs = info->revs;\n\n\tif (!revs->commits)\n\t\treturn 1;\n\n\trevs->commits = filter_skipped(revs->commits, &tried,\n\t\t\t\t       flags & BISECT_SHOW_ALL,\n\t\t\t\t       NULL, NULL);\n\n\t/*\n\t * revs->commits can reach \"reaches\" commits among\n\t * \"all\" commits.  If it is good, then there are\n\t * (all-reaches) commits left to be bisected.\n\t * On the other hand, if it is bad, then the set\n\t * to bisect is \"reaches\".\n\t * A bisect set of size N has (N-1) commits further\n\t * to test, as we already know one bad one.\n\t */\n\tcnt = all - reaches;\n\tif (cnt < reaches)\n\t\tcnt = reaches;\n\n\tif (revs->commits)\n\t\tsha1_to_hex_r(hex, revs->commits->item->object.oid.hash);\n\n\tif (flags & BISECT_SHOW_ALL) {\n\t\ttraverse_commit_list(revs, show_commit, show_object, info);\n\t\tprintf(\"------\\n\");\n\t}\n\n\tprint_var_str(\"bisect_rev\", hex);\n\tprint_var_int(\"bisect_nr\", cnt - 1);\n\tprint_var_int(\"bisect_good\", all - reaches - 1);\n\tprint_var_int(\"bisect_bad\", reaches - 1);\n\tprint_var_int(\"bisect_all\", all);\n\tprint_var_int(\"bisect_steps\", estimate_bisect_steps(all));\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 54892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ssl3_take_mac(SSL *s)\n{\n    const char *sender;\n    int slen;\n    /*\n     * If no new cipher setup return immediately: other functions will set\n     * the appropriate error.\n     */\n    if (s->s3->tmp.new_cipher == NULL)\n        return;\n    if (!s->server) {\n        sender = s->method->ssl3_enc->server_finished_label;\n        slen = s->method->ssl3_enc->server_finished_label_len;\n    } else {\n        sender = s->method->ssl3_enc->client_finished_label;\n        slen = s->method->ssl3_enc->client_finished_label_len;\n    }\n\n    s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n                                                                          sender,\n                                                                          slen,\n                                                                          s->s3->tmp.peer_finish_md);\n}\n",
        "output": "0",
        "index": 9380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tdisable_forwarding();\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}\n",
        "output": "0",
        "index": 50590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GpuProcessHost::Init() {\n  init_start_time_ = base::TimeTicks::Now();\n\n  TRACE_EVENT_INSTANT0(\"gpu\", \"LaunchGpuProcess\");\n\n  std::string channel_id = process_->GetHost()->CreateChannel();\n  if (channel_id.empty())\n    return false;\n\n  if (in_process_) {\n    CommandLine::ForCurrentProcess()->AppendSwitch(\n        switches::kDisableGpuWatchdog);\n\n    in_process_gpu_thread_.reset(new GpuMainThread(channel_id));\n\n    base::Thread::Options options;\n#if defined(OS_WIN)\n  options.message_loop_type = MessageLoop::TYPE_UI;\n#else\n  options.message_loop_type = MessageLoop::TYPE_IO;\n#endif\n    in_process_gpu_thread_->StartWithOptions(options);\n\n    OnProcessLaunched();  // Fake a callback that the process is ready.\n  } else if (!LaunchGpuProcess(channel_id)) {\n    return false;\n  }\n\n  if (!Send(new GpuMsg_Initialize()))\n    return false;\n\n  return Send(new GpuMsg_SetVideoMemoryWindowCount(\n      GpuDataManagerImpl::GetInstance()->GetWindowCount()));\n}\n",
        "output": "0",
        "index": 122793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionService::UnloadAllExtensions() {\n  profile_->GetExtensionSpecialStoragePolicy()->\n      RevokeRightsForAllExtensions();\n\n  extensions_.clear();\n  disabled_extensions_.clear();\n  terminated_extension_ids_.clear();\n  terminated_extensions_.clear();\n  extension_runtime_data_.clear();\n\n}\n",
        "output": "0",
        "index": 103531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init hugetlb_default_setup(char *s)\n{\n\tdefault_hstate_size = memparse(s, &s);\n\treturn 1;\n}\n",
        "output": "0",
        "index": 19697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_dbus_header_set_serial (DBusHeader    *header,\n                         dbus_uint32_t  serial)\n{\n  /* we use this function to set the serial on outgoing\n   * messages, and to reset the serial in dbus_message_copy;\n   * this assertion should catch a double-set on outgoing.\n   */\n  _dbus_assert (_dbus_header_get_serial (header) == 0 ||\n                serial == 0);\n\n  _dbus_marshal_set_uint32 (&header->data,\n                            SERIAL_OFFSET,\n\t\t\t    serial,\n                            header->byte_order);\n}\n",
        "output": "0",
        "index": 2756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long jas_stream_seek(jas_stream_t *stream, long offset, int origin)\n{\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"jas_stream_seek(%p, %ld, %d)\\n\", stream, offset,\n\t  origin));\n\n\t/* The buffer cannot be in use for both reading and writing. */\n\tassert(!((stream->bufmode_ & JAS_STREAM_RDBUF) && (stream->bufmode_ &\n\t  JAS_STREAM_WRBUF)));\n\n\t/* Reset the EOF indicator (since we may not be at the EOF anymore). */\n\tstream->flags_ &= ~JAS_STREAM_EOF;\n\n\tif (stream->bufmode_ & JAS_STREAM_RDBUF) {\n\t\tif (origin == SEEK_CUR) {\n\t\t\toffset -= stream->cnt_;\n\t\t}\n\t} else if (stream->bufmode_ & JAS_STREAM_WRBUF) {\n\t\tif (jas_stream_flush(stream)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstream->cnt_ = 0;\n\tstream->ptr_ = stream->bufstart_;\n\tstream->bufmode_ &= ~(JAS_STREAM_RDBUF | JAS_STREAM_WRBUF);\n\n\tif ((newpos = (*stream->ops_->seek_)(stream->obj_, offset, origin))\n\t  < 0) {\n\t\treturn -1;\n\t}\n\n\treturn newpos;\n}\n",
        "output": "0",
        "index": 67930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ExtensionContextMenuModel::IsCommandIdChecked(int command_id) const {\n  return false;\n}\n",
        "output": "0",
        "index": 115987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "htmlcdataDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *ch, int len)\n{\n    unsigned char output[40];\n    int inlen = len, outlen = 30;\n\n    htmlEncodeEntities(output, &outlen, ch, &inlen, 0);\n    output[outlen] = 0;\n\n    fprintf(SAXdebug, \"SAX.cdata(%s, %d)\\n\", output, len);\n}\n",
        "output": "0",
        "index": 59589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ehci_update_halt(EHCIState *s)\n{\n    if (s->usbcmd & USBCMD_RUNSTOP) {\n        ehci_clear_usbsts(s, USBSTS_HALT);\n    } else {\n        if (s->astate == EST_INACTIVE && s->pstate == EST_INACTIVE) {\n            ehci_set_usbsts(s, USBSTS_HALT);\n        }\n    }\n}\n",
        "output": "0",
        "index": 5834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ContentSecurityPolicy::AllowFormAction(\n    const KURL& url,\n    RedirectStatus redirect_status,\n    SecurityViolationReportingPolicy reporting_policy,\n    CheckHeaderType check_header_type) const {\n  if (ShouldBypassContentSecurityPolicy(url, execution_context_))\n    return true;\n\n  bool is_allowed = true;\n  for (const auto& policy : policies_) {\n    if (!CheckHeaderTypeMatches(check_header_type, policy->HeaderType()))\n      continue;\n    is_allowed &=\n        policy->AllowFormAction(url, redirect_status, reporting_policy);\n  }\n\n  return is_allowed;\n}\n",
        "output": "0",
        "index": 165481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::ToggleFullscreenMode() {\n#if !defined(OS_MACOSX)\n  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode) &&\n      window_->IsFullscreen())\n    return;\n#endif\n\n  UserMetrics::RecordAction(UserMetricsAction(\"ToggleFullscreen\"));\n  window_->SetFullscreen(!window_->IsFullscreen());\n\n\n#if defined(OS_MACOSX)\n  WindowFullscreenStateChanged();\n#endif\n}\n",
        "output": "0",
        "index": 101851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int HttpStreamParser::DoSendHeaders(int result) {\n  request_headers_->DidConsume(result);\n  int bytes_remaining = request_headers_->BytesRemaining();\n  if (bytes_remaining > 0) {\n    if (bytes_remaining == request_headers_->size()) {\n      response_->request_time = base::Time::Now();\n    }\n    result = connection_->socket()->Write(request_headers_,\n                                          bytes_remaining,\n                                          io_callback_);\n  } else if (request_->upload_data_stream != NULL &&\n             (request_->upload_data_stream->is_chunked() ||\n              (request_->upload_data_stream->size() > 0 &&\n               !request_->upload_data_stream->IsEOF()))) {\n    net_log_.AddEvent(\n        NetLog::TYPE_HTTP_TRANSACTION_SEND_REQUEST_BODY,\n        base::Bind(&NetLogSendRequestBodyCallback,\n                   request_->upload_data_stream->size(),\n                   request_->upload_data_stream->is_chunked(),\n                   false /* not merged */));\n    io_state_ = STATE_SENDING_BODY;\n    result = OK;\n  } else {\n    io_state_ = STATE_REQUEST_SENT;\n  }\n  return result;\n}\n",
        "output": "0",
        "index": 121037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "net::Error NavigationRequest::CheckCSPDirectives(\n    RenderFrameHostImpl* parent,\n    bool has_followed_redirect,\n    bool url_upgraded_after_redirect,\n    bool is_response_check,\n    CSPContext::CheckCSPDisposition disposition) {\n  bool navigate_to_allowed = IsAllowedByCSPDirective(\n      initiator_csp_context_.get(), CSPDirective::NavigateTo,\n      has_followed_redirect, url_upgraded_after_redirect, is_response_check,\n      disposition);\n\n  bool frame_src_allowed = true;\n  if (parent) {\n    frame_src_allowed = IsAllowedByCSPDirective(\n        parent, CSPDirective::FrameSrc, has_followed_redirect,\n        url_upgraded_after_redirect, is_response_check, disposition);\n  }\n\n  if (navigate_to_allowed && frame_src_allowed)\n    return net::OK;\n\n  if (!frame_src_allowed)\n    return net::ERR_BLOCKED_BY_CLIENT;\n\n  return net::ERR_ABORTED;\n}\n",
        "output": "0",
        "index": 165258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_chdir(struct bsdtar *bsdtar)\n{\n\tif (bsdtar->pending_chdir == NULL)\n\t\treturn;\n\n\tif (chdir(bsdtar->pending_chdir) != 0) {\n\t\tlafe_errc(1, 0, \"could not chdir to '%s'\\n\",\n\t\t    bsdtar->pending_chdir);\n\t}\n\tfree(bsdtar->pending_chdir);\n\tbsdtar->pending_chdir = NULL;\n}\n",
        "output": "0",
        "index": 73239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool EnterpriseEnrollmentScreen::GetInitialUser(std::string* user) {\n  chromeos::CryptohomeLibrary* cryptohome =\n      chromeos::CrosLibrary::Get()->GetCryptohomeLibrary();\n  if (cryptohome &&\n      cryptohome->InstallAttributesIsReady() &&\n      !cryptohome->InstallAttributesIsFirstInstall()) {\n    std::string value;\n    if (cryptohome->InstallAttributesGet(\"enterprise.owned\", &value) &&\n        value == \"true\") {\n      if (cryptohome->InstallAttributesGet(\"enterprise.user\", &value)) {\n        *user = value;\n        actor_->SetEditableUser(false);\n        return true;\n      }\n    }\n    LOG(ERROR) << \"Enrollment will not finish because the InstallAttrs has \"\n               << \"been locked already but does not contain valid data.\";\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 102584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void windowAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(DOMWindow*, cppValue, toDOMWindow(jsValue, info.GetIsolate()));\n    imp->setWindowAttribute(WTF::getPtr(cppValue));\n}\n",
        "output": "0",
        "index": 132002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int srpt_post_recv(struct srpt_device *sdev,\n\t\t\t  struct srpt_recv_ioctx *ioctx)\n{\n\tstruct ib_sge list;\n\tstruct ib_recv_wr wr, *bad_wr;\n\n\tBUG_ON(!sdev);\n\tlist.addr = ioctx->ioctx.dma;\n\tlist.length = srp_max_req_size;\n\tlist.lkey = sdev->pd->local_dma_lkey;\n\n\tioctx->ioctx.cqe.done = srpt_recv_done;\n\twr.wr_cqe = &ioctx->ioctx.cqe;\n\twr.next = NULL;\n\twr.sg_list = &list;\n\twr.num_sge = 1;\n\n\treturn ib_post_srq_recv(sdev->srq, &wr, &bad_wr);\n}\n",
        "output": "0",
        "index": 50681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "command_send_text (Fep *fep,\n\t\t   FepControlMessage *request)\n{\n  _fep_output_send_text (fep, request->args[0].str);\n}\n",
        "output": "0",
        "index": 36953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool jsvMoreFreeVariablesThan(unsigned int vars) {\n  if (!vars) return false;\n  JsVarRef r = jsVarFirstEmpty;\n  while (r) {\n    if (!vars--) return true;\n    r = jsvGetNextSibling(jsvGetAddressOf(r));\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 82509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CameraService::Client::notifyError() {\n    mRemoteCallback->notifyCallback(CAMERA_MSG_ERROR, CAMERA_ERROR_RELEASED, 0);\n}\n",
        "output": "0",
        "index": 174861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~CreateRootHelper() {}\n",
        "output": "0",
        "index": 114773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    PassRefPtr<BlobDataHandle> getOrCreateBlobDataHandle(const String& uuid, const String& type, long long size = -1)\n    {\n        BlobDataHandleMap::const_iterator it = m_blobDataHandles.find(uuid);\n        if (it != m_blobDataHandles.end()) {\n            return it->value;\n        }\n        return BlobDataHandle::create(uuid, type, size);\n    }\n",
        "output": "0",
        "index": 128949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImportSingleTIFF_Float ( const TIFF_Manager::TagInfo & tagInfo, const bool nativeEndian,\n\t\t\t\t\t\t SXMPMeta * xmp, const char * xmpNS, const char * xmpProp )\n{\n\ttry {\t// Don't let errors with one stop the others.\n\n\t\tfloat binValue = *((float*)tagInfo.dataPtr);\n\t\tif ( ! nativeEndian ) Flip4 ( &binValue );\n\n\t\txmp->SetProperty_Float ( xmpNS, xmpProp, binValue );\n\n\t} catch ( ... ) {\n\t}\n\n}\t// ImportSingleTIFF_Float\n",
        "output": "0",
        "index": 15973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sock *__raw_v4_lookup(struct net *net, struct sock *sk,\n\t\t\t     unsigned short num, __be32 raddr, __be32 laddr,\n\t\t\t     int dif, int sdif)\n{\n\tsk_for_each_from(sk) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tif (net_eq(sock_net(sk), net) && inet->inet_num == num\t&&\n\t\t    !(inet->inet_daddr && inet->inet_daddr != raddr) \t&&\n\t\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif &&\n\t\t      sk->sk_bound_dev_if != sdif))\n\t\t\tgoto found; /* gotcha */\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n",
        "output": "0",
        "index": 59205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::OnTextSurroundingSelectionResponse(\n    const base::string16& content,\n    uint32_t start_offset,\n    uint32_t end_offset) {\n  if (text_surrounding_selection_callback_.is_null())\n    return;\n\n  text_surrounding_selection_callback_.Run(content, start_offset, end_offset);\n  text_surrounding_selection_callback_.Reset();\n}\n",
        "output": "0",
        "index": 152051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n}\n",
        "output": "0",
        "index": 26220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned WebGLRenderingContextBase::GetWebGLVersion(\n    const CanvasRenderingContext* context) {\n  if (!context->Is3d())\n    return 0;\n  return static_cast<const WebGLRenderingContextBase*>(context)->Version();\n}\n",
        "output": "0",
        "index": 146320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QQuickWebViewFlickablePrivate::~QQuickWebViewFlickablePrivate()\n{\n    interactionEngine->disconnect();\n}\n",
        "output": "0",
        "index": 107092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  SafeBeginInstallHelper(BeginInstallWithManifestFunction* client,\n                         const std::string& icon_data,\n                         const std::string& manifest)\n      : client_(client),\n        icon_data_(icon_data),\n        manifest_(manifest),\n        utility_host_(NULL),\n        icon_decode_complete_(false),\n        manifest_parse_complete_(false),\n        parse_error_(BeginInstallWithManifestFunction::UNKNOWN_ERROR) {}\n",
        "output": "0",
        "index": 104729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init perf_workqueue_init(void)\n{\n\tperf_wq = create_singlethread_workqueue(\"perf\");\n\tWARN(!perf_wq, \"failed to create perf workqueue\\n\");\n\treturn perf_wq ? 0 : -1;\n}\n",
        "output": "0",
        "index": 50526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObjectPython::derefObject(void* object)\n{\n    fromInternalPointer(object)->deref();\n}\n",
        "output": "0",
        "index": 131344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "POINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 83567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool  WriteMatrix(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsStage* mpe)\n{\n    _cmsStageMatrixData* m = (_cmsStageMatrixData*) mpe -> Data;\n\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[0])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[1])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[2])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[3])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[4])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[5])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[6])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[7])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Double[8])) return FALSE;\n\n    if (m ->Offset != NULL) {\n\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[0])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[1])) return FALSE;\n    if (!_cmsWrite15Fixed16Number(io, m -> Offset[2])) return FALSE;\n    }\n    else {\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n        if (!_cmsWrite15Fixed16Number(io, 0)) return FALSE;\n\n    }\n\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(self);\n}\n",
        "output": "0",
        "index": 71089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CustomButton::SetState(ButtonState state) {\n  if (state == state_)\n    return;\n\n  if (animate_on_state_change_ &&\n      (!is_throbbing_ || !hover_animation_->is_animating())) {\n    is_throbbing_ = false;\n    if ((state_ == STATE_HOVERED) && (state == STATE_NORMAL)) {\n      hover_animation_->Hide();\n    } else if (state != STATE_HOVERED) {\n      hover_animation_->Reset();\n    } else if (state_ == STATE_NORMAL) {\n      hover_animation_->Show();\n    } else {\n      hover_animation_->Reset(1);\n    }\n  }\n\n  state_ = state;\n  StateChanged();\n  SchedulePaint();\n}\n",
        "output": "0",
        "index": 145025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "authz_status oidc_authz_checker_claim(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args,\n\t\t\toidc_authz_match_claim);\n}\n",
        "output": "0",
        "index": 87052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderLayerCompositor::applyUpdateLayerCompositingStateChickenEggHacks(RenderLayer* layer, CompositingStateTransitionType compositedLayerUpdate)\n{\n    if (compositedLayerUpdate != NoCompositingStateChange)\n        allocateOrClearCompositedLayerMapping(layer);\n}\n",
        "output": "0",
        "index": 122114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int peer_has_ufo(VirtIONet *n)\n{\n    if (!peer_has_vnet_hdr(n))\n        return 0;\n\n    n->has_ufo = qemu_has_ufo(qemu_get_queue(n->nic)->peer);\n\n    return n->has_ufo;\n}\n",
        "output": "0",
        "index": 15817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const PaintController* GetInternalPaintController(\n      const GraphicsLayer& layer) {\n    return layer.paint_controller_.get();\n  }\n",
        "output": "0",
        "index": 136485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "String BaseAudioContext::state() const {\n  switch (context_state_) {\n    case kSuspended:\n      return \"suspended\";\n    case kRunning:\n      return \"running\";\n    case kClosed:\n      return \"closed\";\n  }\n  NOTREACHED();\n  return \"\";\n}\n",
        "output": "0",
        "index": 143058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_orig)\n{\n\tstruct rtable *ort = (struct rtable *) dst_orig;\n\tstruct rtable *rt;\n\n\trt = dst_alloc(&ipv4_dst_blackhole_ops, NULL, 1, DST_OBSOLETE_DEAD, 0);\n\tif (rt) {\n\t\tstruct dst_entry *new = &rt->dst;\n\n\t\tnew->__use = 1;\n\t\tnew->input = dst_discard;\n\t\tnew->output = dst_discard_out;\n\n\t\tnew->dev = net->loopback_dev;\n\t\tif (new->dev)\n\t\t\tdev_hold(new->dev);\n\n\t\trt->rt_is_input = ort->rt_is_input;\n\t\trt->rt_iif = ort->rt_iif;\n\t\trt->rt_pmtu = ort->rt_pmtu;\n\t\trt->rt_mtu_locked = ort->rt_mtu_locked;\n\n\t\trt->rt_genid = rt_genid_ipv4(net);\n\t\trt->rt_flags = ort->rt_flags;\n\t\trt->rt_type = ort->rt_type;\n\t\trt->rt_gateway = ort->rt_gateway;\n\t\trt->rt_uses_gateway = ort->rt_uses_gateway;\n\n\t\tINIT_LIST_HEAD(&rt->rt_uncached);\n\t}\n\n\tdst_release(dst_orig);\n\n\treturn rt ? &rt->dst : ERR_PTR(-ENOMEM);\n}\n",
        "output": "0",
        "index": 91135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceFetcher::HandleLoaderFinish(Resource* resource,\n                                         double finish_time,\n                                         LoaderFinishType type) {\n  DCHECK(resource);\n\n  ResourceLoader* loader = resource->Loader();\n  if (type == kDidFinishFirstPartInMultipart) {\n    MoveResourceLoaderToNonBlocking(loader);\n  } else {\n    RemoveResourceLoader(loader);\n    DCHECK(!non_blocking_loaders_.Contains(loader));\n  }\n  DCHECK(!loaders_.Contains(loader));\n\n  const int64_t encoded_data_length =\n      resource->GetResponse().EncodedDataLength();\n\n  if (resource->GetType() == Resource::kMainResource) {\n    DCHECK(navigation_timing_info_);\n    AddRedirectsToTimingInfo(resource, navigation_timing_info_.Get());\n    if (resource->GetResponse().IsHTTP()) {\n      PopulateTimingInfo(navigation_timing_info_.Get(), resource);\n      navigation_timing_info_->AddFinalTransferSize(\n          encoded_data_length == -1 ? 0 : encoded_data_length);\n    }\n  }\n  if (RefPtr<ResourceTimingInfo> info =\n          resource_timing_info_map_.Take(resource)) {\n    AddRedirectsToTimingInfo(resource, info.Get());\n\n    if (resource->GetResponse().IsHTTP() &&\n        resource->GetResponse().HttpStatusCode() < 400) {\n      PopulateTimingInfo(info.Get(), resource);\n      info->SetLoadFinishTime(finish_time);\n      info->AddFinalTransferSize(\n          encoded_data_length == -1 ? 0 : encoded_data_length);\n\n      if (resource->Options().request_initiator_context == kDocumentContext)\n        Context().AddResourceTiming(*info);\n      resource->ReportResourceTimingToClients(*info);\n    }\n  }\n\n  Context().DispatchDidFinishLoading(\n      resource->Identifier(), finish_time, encoded_data_length,\n      resource->GetResponse().DecodedBodyLength());\n\n  if (type == kDidFinishLoading)\n    resource->Finish(finish_time);\n\n  HandleLoadCompletion(resource);\n}\n",
        "output": "0",
        "index": 139728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CoreGrabInterferes(DeviceIntPtr device, GrabPtr grab)\n{\n    DeviceIntPtr other;\n    BOOL interfering = FALSE;\n\n    for (other = inputInfo.devices; other; other = other->next) {\n        GrabPtr othergrab = other->deviceGrab.grab;\n\n        if (othergrab && othergrab->grabtype == CORE &&\n            SameClient(grab, rClient(othergrab)) &&\n            ((IsPointerDevice(grab->device) &&\n              IsPointerDevice(othergrab->device)) ||\n             (IsKeyboardDevice(grab->device) &&\n              IsKeyboardDevice(othergrab->device)))) {\n            interfering = TRUE;\n            break;\n        }\n    }\n\n    return interfering;\n}\n",
        "output": "0",
        "index": 4806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "search_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_CANONICALIZE;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n",
        "output": "0",
        "index": 63448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InspectorController::didBeginFrame(int frameId)\n{\n    if (InspectorTimelineAgent* timelineAgent = m_instrumentingAgents->inspectorTimelineAgent())\n        timelineAgent->didBeginFrame(frameId);\n    if (InspectorCanvasAgent* canvasAgent = m_instrumentingAgents->inspectorCanvasAgent())\n        canvasAgent->didBeginFrame();\n}\n",
        "output": "0",
        "index": 122467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionApiTest::EmbeddedTestServerAcceptConnections() {\n  embedded_test_server()->StartAcceptingConnections();\n}\n",
        "output": "0",
        "index": 159371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::registerNodeListWithIdNameCache(const LiveNodeListBase* list)\n{\n#if ENABLE(OILPAN)\n    m_nodeLists[InvalidateOnIdNameAttrChange].add(list);\n#else\n    m_nodeListCounts[InvalidateOnIdNameAttrChange]++;\n#endif\n}\n",
        "output": "0",
        "index": 135341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeClientImpl::OpenFileChooser(\n    LocalFrame* frame,\n    scoped_refptr<FileChooser> file_chooser) {\n  NotifyPopupOpeningObservers();\n  WebFrameClient* client = WebLocalFrameImpl::FromFrame(frame)->Client();\n  if (!client)\n    return;\n\n  const WebFileChooserParams& params = file_chooser->Params();\n  WebFileChooserCompletionImpl* chooser_completion =\n      new WebFileChooserCompletionImpl(std::move(file_chooser));\n  if (client->RunFileChooser(params, chooser_completion))\n    return;\n  chooser_completion->DidChooseFile(WebVector<WebString>());\n}\n",
        "output": "0",
        "index": 160976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcXF86DRIGetDeviceInfo(register ClientPtr client)\n{\n    xXF86DRIGetDeviceInfoReply rep = {\n        .type = X_Reply,\n        .sequenceNumber = client->sequence,\n        .length = 0\n    };\n    drm_handle_t hFrameBuffer;\n    void *pDevPrivate;\n\n    REQUEST(xXF86DRIGetDeviceInfoReq);\n    REQUEST_SIZE_MATCH(xXF86DRIGetDeviceInfoReq);\n    if (stuff->screen >= screenInfo.numScreens) {\n        client->errorValue = stuff->screen;\n        return BadValue;\n    }\n\n    if (!DRIGetDeviceInfo(screenInfo.screens[stuff->screen],\n                          &hFrameBuffer,\n                          (int *) &rep.framebufferOrigin,\n                          (int *) &rep.framebufferSize,\n                          (int *) &rep.framebufferStride,\n                          (int *) &rep.devPrivateSize, &pDevPrivate)) {\n        return BadValue;\n    }\n\n    rep.hFrameBufferLow = (CARD32) (hFrameBuffer & 0xffffffff);\n#if defined(LONG64) && !defined(__linux__)\n    rep.hFrameBufferHigh = (CARD32) (hFrameBuffer >> 32);\n#else\n    rep.hFrameBufferHigh = 0;\n#endif\n\n    if (rep.devPrivateSize) {\n        rep.length = bytes_to_int32(SIZEOF(xXF86DRIGetDeviceInfoReply) -\n                                    SIZEOF(xGenericReply) +\n                                    pad_to_int32(rep.devPrivateSize));\n    }\n\n    WriteToClient(client, sizeof(xXF86DRIGetDeviceInfoReply), &rep);\n    if (rep.length) {\n        WriteToClient(client, rep.devPrivateSize, pDevPrivate);\n    }\n    return Success;\n}\n",
        "output": "0",
        "index": 17739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::DispatchDocumentElementAvailable() {\n  ScriptForbiddenScope forbid_scripts;\n  Client()->DocumentElementAvailable();\n}\n",
        "output": "0",
        "index": 107748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderLayerScrollableArea::setTopmostScrollChild(RenderLayer* scrollChild)\n{\n    if (!hasOverlayScrollbars())\n        return;\n    m_nextTopmostScrollChild = scrollChild;\n}\n",
        "output": "0",
        "index": 128448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::SetNavigationRequest(\n    std::unique_ptr<NavigationRequest> navigation_request) {\n  navigation_request_ = std::move(navigation_request);\n}\n",
        "output": "0",
        "index": 160486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " Player* DocumentTimeline::play(TimedItem* child)\n {\n     Player* player = createPlayer(child);\n    player->setStartTime(currentTime());\n     return player;\n }\n",
        "output": "1",
        "index": 185178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t iov_iter_get_pages_alloc(struct iov_iter *i,\n\t\t   struct page ***pages, size_t maxsize,\n\t\t   size_t *start)\n{\n\tsize_t offset = i->iov_offset;\n\tconst struct iovec *iov = i->iov;\n\tsize_t len;\n\tunsigned long addr;\n\tvoid *p;\n\tint n;\n\tint res;\n\n\tlen = iov->iov_len - offset;\n\tif (len > i->count)\n\t\tlen = i->count;\n\tif (len > maxsize)\n\t\tlen = maxsize;\n\taddr = (unsigned long)iov->iov_base + offset;\n\tlen += *start = addr & (PAGE_SIZE - 1);\n\taddr &= ~(PAGE_SIZE - 1);\n\tn = (len + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\n\tp = kmalloc(n * sizeof(struct page *), GFP_KERNEL);\n\tif (!p)\n\t\tp = vmalloc(n * sizeof(struct page *));\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tres = get_user_pages_fast(addr, n, (i->type & WRITE) != WRITE, p);\n\tif (unlikely(res < 0)) {\n\t\tkvfree(p);\n\t\treturn res;\n\t}\n\t*pages = p;\n\treturn (res == n ? len : res * PAGE_SIZE) - *start;\n}\n",
        "output": "0",
        "index": 44168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GfxState::setCTM(double a, double b, double c,\n\t\t      double d, double e, double f) {\n  int i;\n\n  ctm[0] = a;\n  ctm[1] = b;\n  ctm[2] = c;\n  ctm[3] = d;\n  ctm[4] = e;\n  ctm[5] = f;\n\n  for (i = 0; i < 6; ++i) {\n    if (ctm[i] > 1e10) {\n      ctm[i] = 1e10;\n    } else if (ctm[i] < -1e10) {\n      ctm[i] = -1e10;\n    }\n  }\n}\n",
        "output": "0",
        "index": 1112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChildProcessSecurityPolicyImpl::GrantWebUIBindings(int child_id) {\n  base::AutoLock lock(lock_);\n\n  SecurityStateMap::iterator state = security_state_.find(child_id);\n  if (state == security_state_.end())\n    return;\n\n  state->second->GrantBindings(BINDINGS_POLICY_WEB_UI);\n\n  state->second->GrantScheme(chrome::kChromeUIScheme);\n\n  state->second->GrantScheme(chrome::kFileScheme);\n}\n",
        "output": "0",
        "index": 108793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n \t\tconst gss_buffer_t value)\n {\n \tOM_uint32 ret;\n \tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n \t\t\t    desired_object,\n \t\t\t    value);\n \treturn (ret);\n}\n",
        "output": "1",
        "index": 179837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::Core::DoStartSyncing() {\n  DCHECK_EQ(MessageLoop::current(), sync_loop_);\n  sync_manager_->StartSyncingNormally();\n}\n",
        "output": "0",
        "index": 111790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs_close(struct device_d *dev, FILE *file)\n{\n\tstruct file_priv *priv = file->priv;\n\n\tnfs_do_close(priv);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 1335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n",
        "output": "0",
        "index": 81395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_handle_conference(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *xns_conference = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CONFERENCE);\n\n    const char *from = xmpp_stanza_get_from(stanza);\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    Jid *jidp = jid_create(from);\n    if (!jidp) {\n        return;\n    }\n\n    const char *room = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_JID);\n    if (!room) {\n        jid_destroy(jidp);\n        return;\n    }\n\n    const char *reason = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_REASON);\n    const char *password = xmpp_stanza_get_attribute(xns_conference, STANZA_ATTR_PASSWORD);\n\n    sv_ev_room_invite(INVITE_DIRECT, jidp->barejid, room, reason, password);\n    jid_destroy(jidp);\n}\n",
        "output": "0",
        "index": 68657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoUniform1i(GLint fake_location, GLint v0) {\n  GLenum type = 0;\n  GLsizei count = 1;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(fake_location,\n                                   \"glUniform1i\",\n                                   Program::kUniform1i,\n                                   &real_location,\n                                   &type,\n                                   &count)) {\n    return;\n  }\n  if (!state_.current_program->SetSamplers(\n      state_.texture_units.size(), fake_location, 1, &v0)) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_VALUE, \"glUniform1i\", \"texture unit out of range\");\n    return;\n  }\n  api()->glUniform1iFn(real_location, v0);\n}\n",
        "output": "0",
        "index": 154079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vips_foreign_load_gif_scan_extension( VipsForeignLoadGif *gif )\n{\n\tGifByteType *extension;\n\tint ext_code;\n\n\tif( DGifGetExtension( gif->file, &ext_code, &extension ) == \n\t\tGIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 ); \n\t}\n\n\tif( extension ) \n\t\tswitch( ext_code ) { \n\t\tcase GRAPHICS_EXT_FUNC_CODE: \n\t\t\tif( extension[0] == 4 &&\n\t\t\t\textension[1] & 0x1 ) {\n\t\t\t\tVIPS_DEBUG_MSG( \"gifload: has transp.\\n\" ); \n\t\t\t\tgif->has_transparency = TRUE;\n\t\t\t}\n\n\t\t\tif( !gif->has_delay ) { \n\t\t\t\tVIPS_DEBUG_MSG( \"gifload: has delay\\n\" ); \n\t\t\t\tgif->has_delay = TRUE;\n\t\t\t\tgif->delay = extension[2] | (extension[3] << 8);\n\t\t\t}\n\n\t\t\twhile( extension != NULL ) \n\t\t\t\tif( vips_foreign_load_gif_ext_next( gif, \n\t\t\t\t\t&extension ) )\n\t\t\t\t\treturn( -1 ); \n\n\t\t\tbreak;\n\n\t\tcase APPLICATION_EXT_FUNC_CODE: \n\t\t\tif( vips_foreign_load_gif_scan_application_ext( gif, \n\t\t\t\textension ) )\n\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\n\t\tcase COMMENT_EXT_FUNC_CODE:\n\t\t\tif( vips_foreign_load_gif_scan_comment_ext( gif, \n\t\t\t\textension ) )\n\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* Step over any NEXT blocks for unknown extensions.\n\t\t\t */\n\t\t\twhile( extension != NULL ) \n\t\t\t\tif( vips_foreign_load_gif_ext_next( gif, \n\t\t\t\t\t&extension ) )\n\t\t\t\t\treturn( -1 ); \n\t\t\tbreak;\n\t\t}\n\n\treturn( 0 );\n}\n",
        "output": "0",
        "index": 87369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPB_URLLoader_Impl::UpdateStatus() {\n  if (status_callback_ &&\n      (RecordDownloadProgress() || RecordUploadProgress())) {\n    status_callback_(\n        pp_instance(), pp_resource(),\n        RecordUploadProgress() ? bytes_sent_ : -1,\n        RecordUploadProgress() ?  total_bytes_to_be_sent_ : -1,\n        RecordDownloadProgress() ? bytes_received_ : -1,\n        RecordDownloadProgress() ? total_bytes_to_be_received_ : -1);\n  }\n}\n",
        "output": "0",
        "index": 108690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtr<TreeWalker> Document::createTreeWalker(Node* root, unsigned whatToShow, PassRefPtr<NodeFilter> filter, bool expandEntityReferences, ExceptionState& es)\n{\n    UNUSED_PARAM(expandEntityReferences);\n    if (!root) {\n        es.throwUninformativeAndGenericDOMException(NotSupportedError);\n        return 0;\n    }\n    return TreeWalker::create(root, whatToShow, filter);\n}\n",
        "output": "0",
        "index": 109625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}\n",
        "output": "0",
        "index": 44152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OMXNodeInstance::invalidateBufferID(OMX::buffer_id buffer) {\n if (buffer == 0) {\n return;\n }\n Mutex::Autolock autoLock(mBufferIDLock);\n ssize_t index = mBufferIDToBufferHeader.indexOfKey(buffer);\n if (index < 0) {\n        CLOGW(\"invalidateBufferID: buffer %u not found\", buffer);\n return;\n }\n    mBufferHeaderToBufferID.removeItem(mBufferIDToBufferHeader.valueAt(index));\n    mBufferIDToBufferHeader.removeItemsAt(index);\n}\n",
        "output": "0",
        "index": 170904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RTCPeerConnectionHandler::FindReceiver(uintptr_t id) {\n  for (auto it = rtp_receivers_.begin(); it != rtp_receivers_.end(); ++it) {\n    if ((*it)->Id() == id)\n      return it;\n  }\n  return rtp_receivers_.end();\n}\n",
        "output": "0",
        "index": 165971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void phar_write_32(char buffer[4], php_uint32 value)\n{\n\tbuffer[3] = (unsigned char) ((value & 0xff000000) >> 24);\n\tbuffer[2] = (unsigned char) ((value & 0xff0000) >> 16);\n\tbuffer[1] = (unsigned char) ((value & 0xff00) >> 8);\n\tbuffer[0] = (unsigned char) (value & 0xff);\n}\n",
        "output": "0",
        "index": 12317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void VirtualizerGetSpeakerAngles(audio_channel_mask_t channelMask __unused,\n audio_devices_t deviceType __unused, int32_t *pSpeakerAngles) {\n *pSpeakerAngles++ = (int32_t) AUDIO_CHANNEL_OUT_FRONT_LEFT;\n *pSpeakerAngles++ = -90; // azimuth\n *pSpeakerAngles++ = 0; // elevation\n *pSpeakerAngles++ = (int32_t) AUDIO_CHANNEL_OUT_FRONT_RIGHT;\n *pSpeakerAngles++ = 90; // azimuth\n *pSpeakerAngles   = 0; // elevation\n}\n",
        "output": "0",
        "index": 170582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(void) iw_reorient_image(struct iw_context *ctx, unsigned int x)\n{\n\tstatic const unsigned int transpose_tbl[8] = { 4,6,5,7,0,2,1,3 };\n\tint tmpi;\n\tdouble tmpd;\n\n\tx = x & 0x07;\n\n\tif(x&0x04) {\n\t\tctx->img1.orient_transform = transpose_tbl[ctx->img1.orient_transform];\n\n\t\ttmpi = ctx->img1.width;\n\t\tctx->img1.width = ctx->img1.height;\n\t\tctx->img1.height = tmpi;\n\n\t\ttmpd = ctx->img1.density_x;\n\t\tctx->img1.density_x = ctx->img1.density_y;\n\t\tctx->img1.density_y = tmpd;\n\t}\n\n\tctx->img1.orient_transform ^= (x&0x03);\n}\n",
        "output": "0",
        "index": 64980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jbd2_buffer_abort_trigger(struct journal_head *jh,\n\t\t\t       struct jbd2_buffer_trigger_type *triggers)\n{\n\tif (!triggers || !triggers->t_abort)\n\t\treturn;\n\n\ttriggers->t_abort(triggers, jh2bh(jh));\n}\n",
        "output": "0",
        "index": 24371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual status_t setMacAlgorithm(Vector<uint8_t> const &sessionId,\n String8 const &algorithm) {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n\n        writeVector(data, sessionId);\n        data.writeString8(algorithm);\n status_t status = remote()->transact(SET_MAC_ALGORITHM, data, &reply);\n if (status != OK) {\n return status;\n }\n return reply.readInt32();\n }\n",
        "output": "0",
        "index": 174476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool MdFeedbackEnabled() {\n  return base::CommandLine::ForCurrentProcess()->HasSwitch(\n      ::switches::kEnableMaterialDesignFeedback);\n}\n",
        "output": "0",
        "index": 128679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SProcXvQueryExtension(ClientPtr client)\n{\n    REQUEST(xvQueryExtensionReq);\n    REQUEST_SIZE_MATCH(xvQueryExtensionReq);\n    swaps(&stuff->length);\n    return XvProcVector[xv_QueryExtension] (client);\n}\n",
        "output": "0",
        "index": 17492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtrWillBeRawPtr<Element> Document::createElementNS(const AtomicString& namespaceURI, const AtomicString& qualifiedName, const AtomicString& typeExtension, ExceptionState& exceptionState)\n{\n    QualifiedName qName(createQualifiedName(namespaceURI, qualifiedName, exceptionState));\n    if (qName == QualifiedName::null())\n        return nullptr;\n\n    RefPtrWillBeRawPtr<Element> element;\n    if (CustomElement::isValidName(qName.localName()) && registrationContext())\n        element = registrationContext()->createCustomTagElement(*this, qName);\n    else\n        element = createElement(qName, false);\n\n    if (!typeExtension.isEmpty())\n        CustomElementRegistrationContext::setIsAttributeAndTypeExtension(element.get(), typeExtension);\n\n    return element.release();\n}\n",
        "output": "0",
        "index": 135185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init sha512_neon_mod_init(void)\n{\n\tif (!cpu_has_neon())\n\t\treturn -ENODEV;\n\n\treturn crypto_register_shashes(algs, ARRAY_SIZE(algs));\n}\n",
        "output": "0",
        "index": 46623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit ipip_fini(void)\n{\n\tif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\n\t\tprintk(KERN_INFO \"ipip close: can't deregister tunnel\\n\");\n\n\tunregister_pernet_device(&ipip_net_ops);\n}\n",
        "output": "0",
        "index": 27380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool ShouldSwapProcesses(RenderViewHostManager* manager,\n                           const NavigationEntryImpl* cur_entry,\n                           const NavigationEntryImpl* new_entry) const {\n    return manager->ShouldSwapProcessesForNavigation(cur_entry, new_entry);\n  }\n",
        "output": "0",
        "index": 125081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__xmlLineNumbersDefaultValue(void) {\n    if (IS_MAIN_THREAD)\n\treturn (&xmlLineNumbersDefaultValue);\n    else\n\treturn (&xmlGetGlobalState()->xmlLineNumbersDefaultValue);\n}\n",
        "output": "0",
        "index": 114800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPagePrivate::exitFullscreenForNode(Node* node)\n{\n#if ENABLE(VIDEO)\n    if (m_fullscreenNode.get()) {\n        m_client->fullscreenStop();\n        m_fullscreenNode = 0;\n    }\n\n    if (!node || !node->hasTagName(HTMLNames::videoTag))\n        return;\n\n    MediaPlayer* player = static_cast<HTMLMediaElement*>(node)->player();\n    if (!player)\n        return;\n\n    MediaPlayerPrivate* mmrPlayer = static_cast<MediaPlayerPrivate*>(player->implementation());\n    if (!mmrPlayer)\n        return;\n\n    mmrPlayer->setFullscreenWebPageClient(0);\n#endif\n}\n",
        "output": "0",
        "index": 113487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __init udp4_proc_init(void)\n{\n\treturn register_pernet_subsys(&udp4_net_ops);\n}\n",
        "output": "0",
        "index": 19073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void btsnoop_net_write(const void *data, size_t length) {\n#if (!defined(BT_NET_DEBUG) || (BT_NET_DEBUG != TRUE))\n return; // Disable using network sockets for security reasons\n#endif\n\n \n   pthread_mutex_lock(&client_socket_lock_);\n   if (client_socket_ != -1) {\n    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {\n       safe_close_(&client_socket_);\n     }\n   }\n  pthread_mutex_unlock(&client_socket_lock_);\n}\n",
        "output": "1",
        "index": 187496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Intel SDM 11.11.2.2: all MTRRs are disabled when\n\t * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC\n\t * memory type is applied to all of physical memory.\n\t *\n\t * However, virtual machines can be run with CPUID such that\n\t * there are no MTRRs.  In that case, the firmware will never\n\t * enable MTRRs and it is obviously undesirable to run the\n\t * guest entirely with UC memory and we use WB.\n\t */\n\tif (guest_cpuid_has_mtrr(vcpu))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\telse\n\t\treturn MTRR_TYPE_WRBACK;\n}\n",
        "output": "0",
        "index": 53765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void broadcast_packet(const node_t *from, vpn_packet_t *packet) {\n\tavl_node_t *node;\n\tconnection_t *c;\n\tnode_t *n;\n\n\tif(from != myself)\n\t\tsend_packet(myself, packet);\n\n\tif(tunnelserver || broadcast_mode == BMODE_NONE)\n\t\treturn;\n\n\tifdebug(TRAFFIC) logger(LOG_INFO, \"Broadcasting packet of %d bytes from %s (%s)\",\n\t\t\t   packet->len, from->name, from->hostname);\n\n\tswitch(broadcast_mode) {\n\t\tcase BMODE_MST:\n\t\t\tfor(node = connection_tree->head; node; node = node->next) {\n\t\t\t\tc = node->data;\n\n\t\t\t\tif(c->status.active && c->status.mst && c != from->nexthop->connection)\n\t\t\t\t\tsend_packet(c->node, packet);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BMODE_DIRECT:\n\t\t\tif(from != myself)\n\t\t\t\tbreak;\n\n\t\t\tfor(node = node_udp_tree->head; node; node = node->next) {\n\t\t\t\tn = node->data;\n\n\t\t\t\tif(n->status.reachable && ((n->via == myself && n->nexthop == n) || n->via == n))\n\t\t\t\t\tsend_packet(n, packet);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}\n",
        "output": "0",
        "index": 33580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssh_closing(Plug plug, const char *error_msg, int error_code,\n\t\t       int calling_back)\n{\n    Ssh ssh = (Ssh) plug;\n    int need_notify = ssh_do_close(ssh, FALSE);\n\n    if (!error_msg) {\n\tif (!ssh->close_expected)\n\t    error_msg = \"Server unexpectedly closed network connection\";\n\telse\n\t    error_msg = \"Server closed network connection\";\n    }\n\n    if (ssh->close_expected && ssh->clean_exit && ssh->exitcode < 0)\n\tssh->exitcode = 0;\n\n    if (need_notify)\n        notify_remote_exit(ssh->frontend);\n\n    if (error_msg)\n\tlogevent(error_msg);\n    if (!ssh->close_expected || !ssh->clean_exit)\n\tconnection_fatal(ssh->frontend, \"%s\", error_msg);\n    return 0;\n}\n",
        "output": "0",
        "index": 8556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Instance::NotifySelectedFindResultChanged(int current_find_index) {\n  SelectedFindResultChanged(current_find_index);\n}\n",
        "output": "0",
        "index": 128600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLFormControlElement::parseAttribute(const QualifiedName& name,\n                                            const AtomicString& oldValue,\n                                            const AtomicString& value) {\n  if (name == formAttr) {\n    formAttributeChanged();\n    UseCounter::count(document(), UseCounter::FormAttribute);\n  } else if (name == disabledAttr) {\n    if (oldValue.isNull() != value.isNull())\n      disabledAttributeChanged();\n  } else if (name == readonlyAttr) {\n    if (oldValue.isNull() != value.isNull()) {\n      setNeedsWillValidateCheck();\n      pseudoStateChanged(CSSSelector::PseudoReadOnly);\n      pseudoStateChanged(CSSSelector::PseudoReadWrite);\n      if (layoutObject())\n        LayoutTheme::theme().controlStateChanged(*layoutObject(),\n                                                 ReadOnlyControlState);\n    }\n  } else if (name == requiredAttr) {\n    if (oldValue.isNull() != value.isNull())\n      requiredAttributeChanged();\n    UseCounter::count(document(), UseCounter::RequiredAttribute);\n  } else if (name == autofocusAttr) {\n    HTMLElement::parseAttribute(name, oldValue, value);\n    UseCounter::count(document(), UseCounter::AutoFocusAttribute);\n  } else {\n    HTMLElement::parseAttribute(name, oldValue, value);\n  }\n}\n",
        "output": "0",
        "index": 152659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8Console::clearCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ConsoleHelper(info).reportCallWithDefaultArgument(ConsoleAPIType::kClear, String16(\"console.clear\"));\n}\n",
        "output": "0",
        "index": 141653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderThreadImpl::IsMainThread() {\n  return !!current();\n}\n",
        "output": "0",
        "index": 114590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool OmniboxViewViews::SkipDefaultKeyEventProcessing(\n    const ui::KeyEvent& event) {\n  if (views::FocusManager::IsTabTraversalKeyEvent(event) &&\n      ((model()->is_keyword_hint() && !event.IsShiftDown()) ||\n       model()->popup_model()->IsOpen())) {\n    return true;\n  }\n  if (event.key_code() == ui::VKEY_ESCAPE)\n    return model()->WillHandleEscapeKey();\n  return Textfield::SkipDefaultKeyEventProcessing(event);\n}\n",
        "output": "0",
        "index": 155172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int netsnmp_session_set_contextEngineID(struct snmp_session *s, char * contextEngineID TSRMLS_DC)\n{\n\tsize_t\tebuf_len = 32, eout_len = 0;\n\tu_char\t*ebuf = (u_char *) emalloc(ebuf_len);\n\n\tif (ebuf == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"malloc failure setting contextEngineID\");\n\t\treturn (-1);\n\t}\n\tif (!snmp_hex_to_binary(&ebuf, &ebuf_len, &eout_len, 1, contextEngineID)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Bad engine ID value '%s'\", contextEngineID);\n\t\tefree(ebuf);\n\t\treturn (-1);\n\t}\n\n\tif (s->contextEngineID) {\n\t\tefree(s->contextEngineID);\n\t}\n\n\ts->contextEngineID = ebuf;\n\ts->contextEngineIDLen = eout_len;\n\treturn (0);\n}\n",
        "output": "0",
        "index": 9547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LayerTreeHost::CommitRequested() const {\n  return proxy_->CommitRequested();\n}\n",
        "output": "0",
        "index": 120211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_openssl_validate_iv(char **piv, size_t *piv_len, size_t iv_required_len,\n\t\tzend_bool *free_iv, EVP_CIPHER_CTX *cipher_ctx, struct php_openssl_cipher_mode *mode) /* {{{ */\n{\n\tchar *iv_new;\n\n\t/* Best case scenario, user behaved */\n\tif (*piv_len == iv_required_len) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (mode->is_aead) {\n\t\tif (EVP_CIPHER_CTX_ctrl(cipher_ctx, mode->aead_ivlen_flag, *piv_len, NULL) != 1) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Setting of IV length for AEAD mode failed\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tiv_new = ecalloc(1, iv_required_len + 1);\n\n\tif (*piv_len == 0) {\n\t\t/* BC behavior */\n\t\t*piv_len = iv_required_len;\n\t\t*piv = iv_new;\n\t\t*free_iv = 1;\n\t\treturn SUCCESS;\n\n\t}\n\n\tif (*piv_len < iv_required_len) {\n\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\"IV passed is only %zd bytes long, cipher expects an IV of precisely %zd bytes, padding with \\\\0\",\n\t\t\t\t*piv_len, iv_required_len);\n\t\tmemcpy(iv_new, *piv, *piv_len);\n\t\t*piv_len = iv_required_len;\n\t\t*piv = iv_new;\n\t\t*free_iv = 1;\n\t\treturn SUCCESS;\n\t}\n\n\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\"IV passed is %zd bytes long which is longer than the %zd expected by selected cipher, truncating\",\n\t\t\t*piv_len, iv_required_len);\n\tmemcpy(iv_new, *piv, iv_required_len);\n\t*piv_len = iv_required_len;\n\t*piv = iv_new;\n\t*free_iv = 1;\n\treturn SUCCESS;\n\n}\n/* }}} */\n",
        "output": "0",
        "index": 4641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void String8::toLower(size_t start, size_t length)\n{\n const size_t len = size();\n if (start >= len) {\n return;\n }\n if (start+length > len) {\n        length = len-start;\n }\n char* buf = lockBuffer(len);\n    buf += start;\n while (length > 0) {\n *buf = tolower(*buf);\n        buf++;\n        length--;\n }\n    unlockBuffer(len);\n}\n",
        "output": "0",
        "index": 171588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Plugin::~Plugin() {\n  int64_t shutdown_start = NaClGetTimeOfDayMicroseconds();\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, scriptable_plugin=%p)\\n\",\n                 static_cast<void*>(this),\n                 static_cast<void*>(scriptable_plugin())));\n  pnacl_coordinator_.reset(NULL);\n  if (ppapi_proxy_ != NULL) {\n    HistogramTimeLarge(\n        \"NaCl.ModuleUptime.Normal\",\n        (shutdown_start - ready_time_) / NACL_MICROS_PER_MILLI);\n  }\n\n  url_downloaders_.erase(url_downloaders_.begin(), url_downloaders_.end());\n\n  ShutdownProxy();\n  ScriptablePlugin* scriptable_plugin_ = scriptable_plugin();\n  ScriptablePlugin::Unref(&scriptable_plugin_);\n\n  ShutDownSubprocesses();\n\n  delete wrapper_factory_;\n  delete[] argv_;\n  delete[] argn_;\n\n  HistogramTimeSmall(\n      \"NaCl.Perf.ShutdownTime.Total\",\n      (NaClGetTimeOfDayMicroseconds() - shutdown_start)\n          / NACL_MICROS_PER_MILLI);\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, return)\\n\",\n                 static_cast<void*>(this)));\n}\n",
        "output": "0",
        "index": 110361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::didChangeSelection(bool is_empty_selection) {\n  if (!handling_input_event_ && !handling_select_range_)\n      return;\n  handling_select_range_ = false;\n\n  SyncSelectionIfRequired();\n}\n",
        "output": "0",
        "index": 116678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void irqtime_account_idle_ticks(int ticks) {}\n",
        "output": "0",
        "index": 26303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_cookie_freelist(struct Cookie *co, bool cookiestoo)\n{\n  struct Cookie *next;\n  if(co) {\n    while(co) {\n      next = co->next;\n      if(cookiestoo)\n        freecookie(co);\n      else\n        free(co); /* we only free the struct since the \"members\" are all just\n                     pointed out in the main cookie list! */\n      co = next;\n    }\n  }\n}\n",
        "output": "0",
        "index": 32447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gfn_t pse36_gfn_delta(u32 gpte)\n{\n\tint shift = 32 - PT32_DIR_PSE36_SHIFT - PAGE_SHIFT;\n\n\treturn (gpte & PT32_DIR_PSE36_MASK) << shift;\n}\n",
        "output": "0",
        "index": 37569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uintptr_t Parcel::ipcData() const\n{\n return reinterpret_cast<uintptr_t>(mData);\n}\n",
        "output": "0",
        "index": 170448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<SendTabToSelfEntry> SendTabToSelfEntry::FromProto(\n    const sync_pb::SendTabToSelfSpecifics& pb_entry,\n    base::Time now) {\n  std::string guid(pb_entry.guid());\n  if (guid.empty()) {\n    return nullptr;\n  }\n\n  GURL url(pb_entry.url());\n\n  if (!url.is_valid()) {\n    return nullptr;\n  }\n\n  base::Time shared_time = ProtoTimeToTime(pb_entry.shared_time_usec());\n  if (shared_time > now) {\n    shared_time = now;\n  }\n\n  base::Time navigation_time;\n  if (pb_entry.has_navigation_time_usec()) {\n    navigation_time = ProtoTimeToTime(pb_entry.navigation_time_usec());\n  }\n\n  return std::make_unique<SendTabToSelfEntry>(\n      guid, url, pb_entry.title(), shared_time, navigation_time,\n      pb_entry.device_name(), pb_entry.target_device_sync_cache_guid());\n}\n",
        "output": "0",
        "index": 155080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* node = re_ast->root_node;\n\n  int i, length = 0;\n  char tmp;\n\n  while (node != NULL)\n  {\n    length++;\n\n    if (node->type == RE_NODE_LITERAL)\n      break;\n\n    if (node->type != RE_NODE_CONCAT)\n      return NULL;\n\n    if (node->right == NULL ||\n        node->right->type != RE_NODE_LITERAL)\n      return NULL;\n\n    node = node->left;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = 0;\n\n  node = re_ast->root_node;\n\n  while (node->type == RE_NODE_CONCAT)\n  {\n    string->c_string[string->length++] = node->right->value;\n    node = node->left;\n  }\n\n  string->c_string[string->length++] = node->value;\n\n\n  for (i = 0; i < length / 2; i++)\n  {\n    tmp = string->c_string[i];\n    string->c_string[i] = string->c_string[length - i - 1];\n    string->c_string[length - i - 1] = tmp;\n  }\n\n  return string;\n}\n",
        "output": "0",
        "index": 64571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool isEnterKeyKeydownEvent(Event* event)\n{\n    return event->type() == EventTypeNames::keydown && event->isKeyboardEvent() && toKeyboardEvent(event)->keyIdentifier() == \"Enter\" && !toKeyboardEvent(event)->repeat();\n}\n",
        "output": "0",
        "index": 145333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iowarrior_write_callback(struct urb *urb)\n{\n\tstruct iowarrior *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\t/* sync/async unlink faults aren't errors */\n\tif (status &&\n\t    !(status == -ENOENT ||\n\t      status == -ECONNRESET || status == -ESHUTDOWN)) {\n\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\"nonzero write bulk status received: %d\\n\", status);\n\t}\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t/* tell a waiting writer the interrupt-out-pipe is available again */\n\tatomic_dec(&dev->write_busy);\n\twake_up_interruptible(&dev->write_wait);\n}\n",
        "output": "0",
        "index": 55190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AudioContext::disposeOutputs(AudioNode& node)\n{\n    ASSERT(isGraphOwner());\n    ASSERT(isMainThread());\n    for (unsigned i = 0; i < node.numberOfOutputs(); ++i)\n        node.output(i)->dispose();\n}\n",
        "output": "0",
        "index": 139654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void opl3_controller (int dev, int voice, int ctrl_num, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tswitch (ctrl_num)\n\t{\n\t\tcase CTRL_PITCH_BENDER:\n\t\t\tbend_pitch(dev, voice, value);\n\t\t\tbreak;\n\n\t\tcase CTRL_PITCH_BENDER_RANGE:\n\t\t\tdevc->voc[voice].bender_range = value;\n\t\t\tbreak;\n\n\t\tcase CTL_MAIN_VOLUME:\n\t\t\tdevc->voc[voice].volume = value / 128;\n\t\t\tbreak;\n\n\t\tcase CTL_PAN:\n\t\t\tdevc->voc[voice].panning = (value * 2) - 128;\n\t\t\tbreak;\n\t}\n}\n",
        "output": "0",
        "index": 27562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChildProcessSecurityPolicyImpl::GrantScheme(int child_id,\n                                                 const std::string& scheme) {\n  base::AutoLock lock(lock_);\n\n  SecurityStateMap::iterator state = security_state_.find(child_id);\n  if (state == security_state_.end())\n    return;\n\n  state->second->GrantScheme(scheme);\n}\n",
        "output": "0",
        "index": 108792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}\n",
        "output": "0",
        "index": 57720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_b_cbp(MpegEncContext *s, int16_t block[6][64],\n                            int motion_x, int motion_y, int mb_type)\n{\n    int cbp = 0, i;\n\n    if (s->mpv_flags & FF_MPV_FLAG_CBP_RD) {\n        int score        = 0;\n        const int lambda = s->lambda2 >> (FF_LAMBDA_SHIFT - 6);\n\n        for (i = 0; i < 6; i++) {\n            if (s->coded_score[i] < 0) {\n                score += s->coded_score[i];\n                cbp   |= 1 << (5 - i);\n            }\n        }\n\n        if (cbp) {\n            int zero_score = -6;\n            if ((motion_x | motion_y | s->dquant | mb_type) == 0)\n                zero_score -= 4;  // 2 * MV + mb_type + cbp bit\n\n            zero_score *= lambda;\n            if (zero_score <= score)\n                cbp = 0;\n        }\n\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0 && ((cbp >> (5 - i)) & 1) == 0) {\n                s->block_last_index[i] = -1;\n                s->bdsp.clear_block(s->block[i]);\n            }\n        }\n    } else {\n        for (i = 0; i < 6; i++) {\n            if (s->block_last_index[i] >= 0)\n                cbp |= 1 << (5 - i);\n        }\n    }\n    return cbp;\n}\n",
        "output": "0",
        "index": 81768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\tmtspr(SPRN_DAC1, dabr);\n#ifdef CONFIG_PPC_47x\n\tisync();\n#endif\n\treturn 0;\n}\n",
        "output": "0",
        "index": 38607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int apparmor_capable(struct task_struct *task, const struct cred *cred,\n\t\t\t    struct user_namespace *ns, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\t/* cap_capable returns 0 on success, else -EPERM */\n\tint error = cap_capable(task, cred, ns, cap, audit);\n\tif (!error) {\n\t\tprofile = aa_cred_profile(cred);\n\t\tif (!unconfined(profile))\n\t\t\terror = aa_capable(task, profile, cap, audit);\n\t}\n\treturn error;\n}\n",
        "output": "0",
        "index": 34780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WindowsCreateFunction::ShouldOpenIncognitoWindow(\n    const base::DictionaryValue* args,\n    std::vector<GURL>* urls,\n    bool* is_error) {\n  *is_error = false;\n  const IncognitoModePrefs::Availability incognito_availability =\n      IncognitoModePrefs::GetAvailability(profile_->GetPrefs());\n  bool incognito = false;\n  if (args && args->HasKey(keys::kIncognitoKey)) {\n    EXTENSION_FUNCTION_VALIDATE(args->GetBoolean(keys::kIncognitoKey,\n                                                 &incognito));\n    if (incognito && incognito_availability == IncognitoModePrefs::DISABLED) {\n      error_ = keys::kIncognitoModeIsDisabled;\n      *is_error = true;\n      return false;\n    }\n    if (!incognito && incognito_availability == IncognitoModePrefs::FORCED) {\n      error_ = keys::kIncognitoModeIsForced;\n      *is_error = true;\n      return false;\n    }\n  } else if (incognito_availability == IncognitoModePrefs::FORCED) {\n    incognito = true;\n  }\n\n  if (incognito && !profile_->IsGuestSession()) {\n    std::string first_url_erased;\n    for (size_t i = 0; i < urls->size();) {\n      if (chrome::IsURLAllowedInIncognito((*urls)[i], profile())) {\n        i++;\n      } else {\n        if (first_url_erased.empty())\n          first_url_erased = (*urls)[i].spec();\n        urls->erase(urls->begin() + i);\n      }\n    }\n    if (urls->empty() && !first_url_erased.empty()) {\n      error_ = ErrorUtils::FormatErrorMessage(\n          keys::kURLsNotAllowedInIncognitoError, first_url_erased);\n      *is_error = true;\n      return false;\n    }\n  }\n  return incognito;\n}\n",
        "output": "0",
        "index": 121528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long __sys_sendmsg(int fd, struct msghdr __user *msg, unsigned flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n",
        "output": "0",
        "index": 40690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct NntpData *mutt_newsgroup_uncatchup(struct NntpServer *nserv, char *group)\n{\n  struct NntpData *nntp_data = NULL;\n\n  if (!nserv || !nserv->groups_hash || !group || !*group)\n    return NULL;\n\n  nntp_data = mutt_hash_find(nserv->groups_hash, group);\n  if (!nntp_data)\n    return NULL;\n\n  if (nntp_data->newsrc_ent)\n  {\n    mutt_mem_realloc(&nntp_data->newsrc_ent, sizeof(struct NewsrcEntry));\n    nntp_data->newsrc_len = 1;\n    nntp_data->newsrc_ent[0].first = 1;\n    nntp_data->newsrc_ent[0].last = nntp_data->first_message - 1;\n  }\n  if (Context && Context->data == nntp_data)\n  {\n    nntp_data->unread = Context->msgcount;\n    for (unsigned int i = 0; i < Context->msgcount; i++)\n      mutt_set_flag(Context, Context->hdrs[i], MUTT_READ, 0);\n  }\n  else\n  {\n    nntp_data->unread = nntp_data->last_message;\n    if (nntp_data->newsrc_ent)\n      nntp_data->unread -= nntp_data->newsrc_ent[0].last;\n  }\n  return nntp_data;\n}\n",
        "output": "0",
        "index": 79456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int InfoBar::GetAvailableWidth() const {\n  return close_button_->x() - kCloseButtonSpacing;\n}\n",
        "output": "0",
        "index": 107939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  chromeos::NoteTakingLockScreenSupport GetAppLockScreenStatus(\n      const std::string& app_id) {\n    std::unique_ptr<chromeos::NoteTakingAppInfo> info =\n        chromeos::NoteTakingHelper::Get()->GetPreferredChromeAppInfo(\n            browser()->profile());\n    if (!info || info->app_id != app_id)\n      return chromeos::NoteTakingLockScreenSupport::kNotSupported;\n    return info->lock_screen_support;\n  }\n",
        "output": "0",
        "index": 170219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct vrend_resource *vrend_renderer_ctx_res_lookup(struct vrend_context *ctx, int res_handle)\n{\n   struct vrend_resource *res = vrend_object_lookup(ctx->res_hash, res_handle, 1);\n\n   return res;\n}\n",
        "output": "0",
        "index": 8896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FileDescriptorSet::GetDescriptors(int* buffer) const {\n  for (std::vector<base::FileDescriptor>::const_iterator\n       i = descriptors_.begin(); i != descriptors_.end(); ++i) {\n    *(buffer++) = i->fd;\n   }\n }\n",
        "output": "0",
        "index": 99418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void webkit_web_view_clear_resources(WebKitWebView* webView)\n{\n    WebKitWebViewPrivate* priv = webView->priv;\n\n    if (priv->subResources)\n        g_hash_table_remove_all(priv->subResources.get());\n}\n",
        "output": "0",
        "index": 105405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t get_free_space_available(const char *path)\n{\n    struct statvfs stat;\n    if (statvfs(path, &stat) != 0) {\n        syslog(LOG_WARNING, \"file-xfer: failed to get free space, statvfs error: %s\",\n               strerror(errno));\n        return G_MAXUINT64;\n    }\n    return stat.f_bsize * stat.f_bavail;\n}\n",
        "output": "0",
        "index": 17302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::string16 ScreenLayoutObserverTest::GetMirroringDisplayName() {\n  return base::UTF8ToUTF16(display_manager()->GetDisplayNameForId(\n      display_manager()->mirroring_display_id()));\n}\n",
        "output": "0",
        "index": 140693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BIO *cms_EnvelopedData_init_bio(CMS_ContentInfo *cms)\n{\n    CMS_EncryptedContentInfo *ec;\n    STACK_OF(CMS_RecipientInfo) *rinfos;\n    CMS_RecipientInfo *ri;\n    int i, ok = 0;\n    BIO *ret;\n\n    /* Get BIO first to set up key */\n\n    ec = cms->d.envelopedData->encryptedContentInfo;\n    ret = cms_EncryptedContent_init_bio(ec);\n\n    /* If error or no cipher end of processing */\n\n    if (!ret || !ec->cipher)\n        return ret;\n\n    /* Now encrypt content key according to each RecipientInfo type */\n\n    rinfos = cms->d.envelopedData->recipientInfos;\n\n    for (i = 0; i < sk_CMS_RecipientInfo_num(rinfos); i++) {\n        ri = sk_CMS_RecipientInfo_value(rinfos, i);\n        if (CMS_RecipientInfo_encrypt(cms, ri) <= 0) {\n            CMSerr(CMS_F_CMS_ENVELOPEDDATA_INIT_BIO,\n                   CMS_R_ERROR_SETTING_RECIPIENTINFO);\n            goto err;\n        }\n    }\n    cms_env_set_version(cms->d.envelopedData);\n\n    ok = 1;\n\n err:\n    ec->cipher = NULL;\n    OPENSSL_clear_free(ec->key, ec->keylen);\n    ec->key = NULL;\n    ec->keylen = 0;\n    if (ok)\n        return ret;\n    BIO_free(ret);\n    return NULL;\n\n}\n",
        "output": "0",
        "index": 11918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}\n",
        "output": "0",
        "index": 37052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__skb_to_sgvec(struct sk_buff *skb, struct scatterlist *sg, int offset, int len)\n{\n\tint start = skb_headlen(skb);\n\tint i, copy = start - offset;\n\tstruct sk_buff *frag_iter;\n\tint elt = 0;\n\n\tif (copy > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tsg_set_buf(sg, skb->data + offset, copy);\n\t\telt++;\n\t\tif ((len -= copy) == 0)\n\t\t\treturn elt;\n\t\toffset += copy;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tsg_set_page(&sg[elt], skb_frag_page(frag), copy,\n\t\t\t\t\tfrag->page_offset+offset-start);\n\t\t\telt++;\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn elt;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\telt += __skb_to_sgvec(frag_iter, sg+elt, offset - start,\n\t\t\t\t\t      copy);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn elt;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\tBUG_ON(len);\n\treturn elt;\n}\n",
        "output": "0",
        "index": 39857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WORD32 ih264d_get_num_rec(void *pv_api_ip, void *pv_api_op)\n{\n iv_num_mem_rec_ip_t *ps_mem_q_ip;\n iv_num_mem_rec_op_t *ps_mem_q_op;\n    ps_mem_q_ip = (iv_num_mem_rec_ip_t *)pv_api_ip;\n    ps_mem_q_op = (iv_num_mem_rec_op_t *)pv_api_op;\n    UNUSED(ps_mem_q_ip);\n    ps_mem_q_op->u4_num_mem_rec = MEM_REC_CNT;\n\n return IV_SUCCESS;\n\n}\n",
        "output": "0",
        "index": 175785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "POINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 83570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const struct rtnl_link_stats64 *dev_get_stats(struct net_device *dev)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\tif (ops->ndo_get_stats64)\n\t\treturn ops->ndo_get_stats64(dev);\n\tif (ops->ndo_get_stats)\n\t\treturn (struct rtnl_link_stats64 *)ops->ndo_get_stats(dev);\n\n\tdev_txq_stats_fold(dev, &dev->stats);\n\treturn &dev->stats64;\n}\n",
        "output": "0",
        "index": 37993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int PreProcessingFx_GetDescriptor(effect_handle_t   self,\n effect_descriptor_t *pDescriptor)\n{\n preproc_effect_t * effect = (preproc_effect_t *) self;\n\n if (effect == NULL || pDescriptor == NULL) {\n return -EINVAL;\n }\n\n *pDescriptor = *sDescriptors[effect->procId];\n\n return 0;\n}\n",
        "output": "0",
        "index": 170652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_qtdemux_get_type (void)\n{\n  static GType qtdemux_type = 0;\n\n  if (!qtdemux_type) {\n    static const GTypeInfo qtdemux_info = {\n      sizeof (GstQTDemuxClass),\n      (GBaseInitFunc) gst_qtdemux_base_init, NULL,\n      (GClassInitFunc) gst_qtdemux_class_init,\n      NULL, NULL, sizeof (GstQTDemux), 0,\n      (GInstanceInitFunc) gst_qtdemux_init,\n    };\n\n    qtdemux_type =\n        g_type_register_static (GST_TYPE_ELEMENT, \"GstQTDemux\", &qtdemux_info,\n        0);\n  }\n  return qtdemux_type;\n}\n",
        "output": "0",
        "index": 4943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JSTestEventTargetConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    return getStaticValueSlot<JSTestEventTargetConstructor, JSDOMWrapper>(exec, &JSTestEventTargetConstructorTable, jsCast<JSTestEventTargetConstructor*>(cell), propertyName, slot);\n}\n",
        "output": "0",
        "index": 105980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n \n \tif (bitmapUpdate->number > bitmapUpdate->count)\n \t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n \n \t\tif (!newdata)\n \t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n",
        "output": "1",
        "index": 182465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int module_initialize(\n    YR_MODULE* module)\n{\n  return ERROR_SUCCESS;\n}\n",
        "output": "0",
        "index": 63460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProfileKeyedService* TestExtensionSystem::Build(Profile* profile) {\n  return new TestExtensionSystem(profile);\n}\n",
        "output": "0",
        "index": 124315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::ClearInitialScrollState() {\n  document_loader_->GetInitialScrollState().was_scrolled_by_user = false;\n}\n",
        "output": "0",
        "index": 165583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void range_decode_update(APEContext *ctx, int sy_f, int lt_f)\n{\n    ctx->rc.low  -= ctx->rc.help * lt_f;\n    ctx->rc.range = ctx->rc.help * sy_f;\n}\n",
        "output": "0",
        "index": 63432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_reg_read(const struct bpf_verifier_state *state, u32 regno)\n{\n\tstruct bpf_verifier_state *parent = state->parent;\n\n\tif (regno == BPF_REG_FP)\n\t\t/* We don't need to worry about FP liveness because it's read-only */\n\t\treturn;\n\n\twhile (parent) {\n\t\t/* if read wasn't screened by an earlier write ... */\n\t\tif (state->regs[regno].live & REG_LIVE_WRITTEN)\n\t\t\tbreak;\n\t\t/* ... then we depend on parent's value */\n\t\tparent->regs[regno].live |= REG_LIVE_READ;\n\t\tstate = parent;\n\t\tparent = state->parent;\n\t}\n}\n",
        "output": "0",
        "index": 59150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\t/*\n\t\t * the demux thread can exit on its own while still in CifsNew\n\t\t * so don't accept any sockets in that state. Since the\n\t\t * tcpStatus never changes back to CifsNew it's safe to check\n\t\t * for this without a lock.\n\t\t */\n\t\tif (server->tcpStatus == CifsNew)\n\t\t\tcontinue;\n\n\t\tif (!match_address(server, addr))\n\t\t\tcontinue;\n\n\t\tif (!match_security(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\tcFYI(1, \"Existing tcp session with server found\");\n\t\treturn server;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 35143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API int zend_disable_class(char *class_name, uint class_name_length TSRMLS_DC) /* {{{ */\n{\n\tzend_class_entry **disabled_class;\n\n\tzend_str_tolower(class_name, class_name_length);\n\tif (zend_hash_find(CG(class_table), class_name, class_name_length+1, (void **)&disabled_class)==FAILURE) {\n\t\treturn FAILURE;\n\t}\n\tINIT_CLASS_ENTRY_INIT_METHODS((**disabled_class), disabled_class_new, NULL, NULL, NULL, NULL, NULL);\n\t(*disabled_class)->create_object = display_disabled_class;\n\tzend_hash_clean(&((*disabled_class)->function_table));\n\treturn SUCCESS;\n}\n/* }}} */\n",
        "output": "0",
        "index": 13787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsWindow::LoadCompleted() {\n  Show(action_on_load_);\n  action_on_load_ = DevToolsToggleAction::NoOp();\n  if (!load_completed_callback_.is_null()) {\n    load_completed_callback_.Run();\n    load_completed_callback_ = base::Closure();\n  }\n}\n",
        "output": "0",
        "index": 151084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n {\n \tu32 data;\n\tvoid *vapic;\n \n \tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n \t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n \n \tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n \t\treturn;\n \n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n \n \tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n }\n",
        "output": "1",
        "index": 179117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XML_SetNotationDeclHandler(XML_Parser parser,\n                           XML_NotationDeclHandler handler)\n{\n  if (parser != NULL)\n    parser->m_notationDeclHandler = handler;\n}\n",
        "output": "0",
        "index": 92285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void classMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectV8Internal::classMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 130673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ocfs2_figure_cluster_boundaries(struct ocfs2_super *osb,\n\t\t\t\t\t    u32 cpos,\n\t\t\t\t\t    unsigned int *start,\n\t\t\t\t\t    unsigned int *end)\n{\n\tunsigned int cluster_start = 0, cluster_end = PAGE_SIZE;\n\n\tif (unlikely(PAGE_SHIFT > osb->s_clustersize_bits)) {\n\t\tunsigned int cpp;\n\n\t\tcpp = 1 << (PAGE_SHIFT - osb->s_clustersize_bits);\n\n\t\tcluster_start = cpos % cpp;\n\t\tcluster_start = cluster_start << osb->s_clustersize_bits;\n\n\t\tcluster_end = cluster_start + osb->s_clustersize;\n\t}\n\n\tBUG_ON(cluster_start > PAGE_SIZE);\n\tBUG_ON(cluster_end > PAGE_SIZE);\n\n\tif (start)\n\t\t*start = cluster_start;\n\tif (end)\n\t\t*end = cluster_end;\n}\n",
        "output": "0",
        "index": 85493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoStencilThenCoverStrokePathCHROMIUM(\n    GLuint path,\n    GLint reference,\n    GLuint mask,\n    GLenum coverMode) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 154811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int entersafe_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data,\n\t\t\t   int *tries_left)\n{\n\t int r;\n\t SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t entersafe_init_pin_info(&data->pin1,0);\n\t entersafe_init_pin_info(&data->pin2,1);\n\t data->flags |= SC_PIN_CMD_NEED_PADDING;\n\n\t if(data->cmd!=SC_PIN_CMD_UNBLOCK)\n\t {\n\t\t  r = iso_ops->pin_cmd(card,data,tries_left);\n\t\t  sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Verify rv:%i\", r);\n\t }\n\t else\n\t {\n\t\t  {/*verify*/\n\t\t\t   sc_apdu_t apdu;\n\t\t\t   u8 sbuf[0x10]={0};\n\n\t\t\t   memcpy(sbuf,data->pin1.data,data->pin1.len);\n\t\t\t   sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0x20,0x00,data->pin_reference+1);\n\t\t\t   apdu.lc = apdu.datalen = sizeof(sbuf);\n\t\t\t   apdu.data = sbuf;\n\n\t\t\t   r = entersafe_transmit_apdu(card, &apdu,0,0,0,0);\n\t\t\t   SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\t  }\n\n\t\t  {/*change*/\n\t\t\t   sc_apdu_t apdu;\n\t\t\t   u8 sbuf[0x12]={0};\n\t\t\t   \n\t\t\t   sbuf[0] = 0x33;\n\t\t\t   sbuf[1] = 0x00;\n\t\t\t   memcpy(sbuf+2,data->pin2.data,data->pin2.len);\n\t\t\t   sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT,0xF4,0x0B,data->pin_reference);\n\t\t\t   apdu.cla = 0x84;\n\t\t\t   apdu.lc = apdu.datalen = sizeof(sbuf);\n\t\t\t   apdu.data = sbuf;\n\n\t\t\t   r = entersafe_transmit_apdu(card, &apdu,key_maintain,sizeof(key_maintain),1,1);\n\t\t\t   SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\t  }\n\t }\n\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n",
        "output": "0",
        "index": 78348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tty_free_file(struct file *file)\n{\n\tstruct tty_file_private *priv = file->private_data;\n\n\tfile->private_data = NULL;\n\tkfree(priv);\n}\n",
        "output": "0",
        "index": 55917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::OpenHistoryWindow(Profile* profile) {\n  Browser* browser = Browser::Create(profile);\n  browser->ShowHistoryTab();\n  browser->window()->Show();\n}\n",
        "output": "0",
        "index": 101740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserContextDestroyer::DestroyContext(BrowserContext* context) {\n  CHECK(context->IsOffTheRecord() || !context->HasOffTheRecordContext());\n \n  content::BrowserContext::NotifyWillBeDestroyed(context);\n  std::set<content::RenderProcessHost*> hosts;\n \n  for (content::RenderProcessHost::iterator it =\n           content::RenderProcessHost::AllHostsIterator();\n       !it.IsAtEnd(); it.Advance()) {\n    content::RenderProcessHost* host = it.GetCurrentValue();\n    if (host->GetBrowserContext() != context) {\n      continue;\n     }\n \n    hosts.insert(host);\n//// static\n   }\n \n \n  if (hosts.empty()) {\n    delete context;\n  } else {\n    new BrowserContextDestroyer(context, hosts);\n   }\n }\n",
        "output": "1",
        "index": 178591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SchedulerHelper::IsQueueEmpty(size_t queue_index) const {\n  CheckOnValidThread();\n  return task_queue_manager_->IsQueueEmpty(queue_index);\n}\n",
        "output": "0",
        "index": 133197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CompositorImpl::SetRequiresAlphaChannel(bool flag) {\n  requires_alpha_channel_ = flag;\n}\n",
        "output": "0",
        "index": 143531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HTMLInputElement::shouldAutocomplete() const\n{\n    if (m_autocomplete != Uninitialized)\n        return m_autocomplete == On;\n    return HTMLTextFormControlElement::shouldAutocomplete();\n}\n",
        "output": "0",
        "index": 121273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void relocs_by_sym_free(HtKv *kv) {\n\tfree (kv->key);\n\tfree (kv->value);\n}\n",
        "output": "0",
        "index": 82942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool DataPipeConsumerDispatcher::InitializeNoLock() {\n  lock_.AssertAcquired();\n  if (!shared_ring_buffer_.IsValid())\n    return false;\n\n  DCHECK(!ring_buffer_mapping_.IsValid());\n  ring_buffer_mapping_ = shared_ring_buffer_.Map();\n  if (!ring_buffer_mapping_.IsValid()) {\n    DLOG(ERROR) << \"Failed to map shared buffer.\";\n    shared_ring_buffer_ = base::UnsafeSharedMemoryRegion();\n    return false;\n  }\n\n  base::AutoUnlock unlock(lock_);\n  node_controller_->SetPortObserver(\n      control_port_, base::MakeRefCounted<PortObserverThunk>(this));\n\n  return true;\n}\n",
        "output": "0",
        "index": 167480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void OnShowCreatedWindow(int pending_widget_routing_id,\n                           WindowOpenDisposition disposition,\n                           const gfx::Rect& initial_rect,\n                           bool user_gesture) {\n    content::BrowserThread::PostTask(\n        content::BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&PendingWidgetMessageFilter::OnReceivedRoutingIDOnUI,\n                       this, pending_widget_routing_id));\n  }\n",
        "output": "0",
        "index": 167632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _store_resource_sdb(struct PE_(r_bin_pe_obj_t) *bin) {\n\tRListIter *iter;\n\tr_pe_resource *rs;\n\tint index = 0;\n\tut64 vaddr = 0;\n\tchar *key;\n\tSdb *sdb = sdb_new0 ();\n\tif (!sdb) {\n\t\treturn;\n\t}\n\tr_list_foreach (bin->resources, iter, rs) {\n\t\tkey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tsdb_set (sdb, key, rs->timestr, 0);\n\t\tkey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tvaddr = bin_pe_rva_to_va (bin, rs->data->OffsetToData);\n\t\tsdb_num_set (sdb, key, vaddr, 0);\n\t\tkey = sdb_fmt (\"resource.%d.name\", index);\n\t\tsdb_num_set (sdb, key, rs->name, 0);\n\t\tkey = sdb_fmt (\"resource.%d.size\", index);\n\t\tsdb_num_set (sdb, key, rs->data->Size, 0);\n\t\tkey = sdb_fmt (\"resource.%d.type\", index);\n\t\tsdb_set (sdb, key, rs->type, 0);\n\t\tkey = sdb_fmt (\"resource.%d.language\", index);\n\t\tsdb_set (sdb, key, rs->language, 0);\n\t\tindex++;\n\t}\n\tsdb_ns_set (bin->kv, \"pe_resource\", sdb);\n}\n",
        "output": "0",
        "index": 82871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::OnCrossDocumentCommitProcessed(\n    int64_t navigation_id,\n    blink::mojom::CommitResult result) {\n  DCHECK_NE(blink::mojom::CommitResult::RestartCrossDocument, result);\n  if (result == blink::mojom::CommitResult::Ok) {\n    auto find_request = navigation_requests_.find(navigation_id);\n    if (find_request != navigation_requests_.end()) {\n      navigation_request_ = std::move(find_request->second);\n    } else {\n      DCHECK(is_attaching_inner_delegate_);\n    }\n  }\n  navigation_requests_.erase(navigation_id);\n}\n",
        "output": "0",
        "index": 166142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "send_data(u_int32_t id, const u_char *data, int dlen)\n{\n\tdebug(\"request %u: sent data len %d\", id, dlen);\n\tsend_data_or_handle(SSH2_FXP_DATA, id, data, dlen);\n}\n",
        "output": "0",
        "index": 60375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {\n    if (s->cgroups == NULL) s->cgroups = raxNew();\n    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)\n        return NULL;\n\n    streamCG *cg = zmalloc(sizeof(*cg));\n    cg->pel = raxNew();\n    cg->consumers = raxNew();\n    cg->last_id = *id;\n    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);\n    return cg;\n}\n",
        "output": "0",
        "index": 81786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API ut64 r_bin_java_annotation_calc_size(RBinJavaAnnotation *annotation) {\n\tut64 sz = 0;\n\tRListIter *iter, *iter_tmp;\n\tRBinJavaElementValuePair *ev_pairs = NULL;\n\tif (!annotation) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tsz += 2;\n\tr_list_foreach_safe (annotation->element_value_pairs, iter, iter_tmp, ev_pairs) {\n\t\tif (ev_pairs) {\n\t\t\tsz += r_bin_java_element_pair_calc_size (ev_pairs);\n\t\t}\n\t}\n\treturn sz;\n}\n",
        "output": "0",
        "index": 79671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int git_index_reuc_remove(git_index *index, size_t position)\n{\n\tint error;\n\tgit_index_reuc_entry *reuc;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treuc = git_vector_get(&index->reuc, position);\n\terror = git_vector_remove(&index->reuc, position);\n\n\tif (!error)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}\n",
        "output": "0",
        "index": 83702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebUI* WebContentsImpl::GetWebUI() const {\n  return GetRenderManager()->web_ui() ? GetRenderManager()->web_ui()\n      : GetRenderManager()->pending_web_ui();\n}\n",
        "output": "0",
        "index": 133581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2Implementation::CoverFillPathInstancedCHROMIUM(\n    GLsizei num_paths,\n    GLenum path_name_type,\n    const GLvoid* paths,\n    GLuint path_base,\n    GLenum cover_mode,\n    GLenum transform_type,\n    const GLfloat* transform_values) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] glCoverFillPathInstancedCHROMIUM(\"\n                     << num_paths << \", \" << path_name_type << \", \" << paths\n                     << \", \" << path_base << \", \" << cover_mode << \", \"\n                     << transform_type << \", \" << transform_values << \")\");\n\n  ScopedTransferBufferPtr buffer(helper_, transfer_buffer_);\n  uint32_t paths_shm_id = 0;\n  uint32_t paths_offset = 0;\n  uint32_t transforms_shm_id = 0;\n  uint32_t transforms_offset = 0;\n  if (!PrepareInstancedPathCommand(\n          \"glCoverFillPathInstancedCHROMIUM\", num_paths, path_name_type, paths,\n          transform_type, transform_values, &buffer, &paths_shm_id,\n          &paths_offset, &transforms_shm_id, &transforms_offset)) {\n    return;\n  }\n\n  helper_->CoverFillPathInstancedCHROMIUM(\n      num_paths, path_name_type, paths_shm_id, paths_offset, path_base,\n      cover_mode, transform_type, transforms_shm_id, transforms_offset);\n\n  CheckGLError();\n}\n",
        "output": "0",
        "index": 153597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "blink::WebWidget* RenderViewImpl::GetWebWidgetForWidget() const {\n  return frame_widget_;\n}\n",
        "output": "0",
        "index": 157940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PaintController::LastDisplayItemIsSubsequenceEnd() const {\n  return !new_cached_subsequences_.IsEmpty() &&\n         last_cached_subsequence_end_ == new_display_item_list_.size();\n}\n",
        "output": "0",
        "index": 136537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n}\n",
        "output": "0",
        "index": 18275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_WM_initMDI(void) {\n    struct _mdi *mdi;\n\n    mdi = malloc(sizeof(struct _mdi));\n    memset(mdi, 0, (sizeof(struct _mdi)));\n\n    mdi->extra_info.copyright = NULL;\n    mdi->extra_info.mixer_options = _WM_MixerOptions;\n\n    _WM_load_patch(mdi, 0x0000);\n\n    mdi->events_size = MEM_CHUNK;\n    mdi->events = malloc(mdi->events_size * sizeof(struct _event));\n    mdi->event_count = 0;\n    mdi->current_event = mdi->events;\n\n    mdi->samples_to_mix = 0;\n    mdi->extra_info.current_sample = 0;\n    mdi->extra_info.total_midi_time = 0;\n    mdi->extra_info.approx_total_samples = 0;\n\n    mdi->dyn_vol = 1.0;\n    mdi->dyn_vol_adjust = 0.0;\n    mdi->dyn_vol_peak = 0;\n    mdi->dyn_vol_to_reach = 1.0;\n\n    mdi->is_type2 = 0;\n\n    mdi->lyric = NULL;\n\n    _WM_do_sysex_gm_reset(mdi, NULL);\n\n    return (mdi);\n}\n",
        "output": "0",
        "index": 63266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebUILoginView::OnLocaleChanged() {\n}\n",
        "output": "0",
        "index": 110412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *ubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 46418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MetricsWebContentsObserver::AddTestingObserver(TestingObserver* observer) {\n  if (!testing_observers_.HasObserver(observer))\n    testing_observers_.AddObserver(observer);\n}\n",
        "output": "0",
        "index": 152818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cpu_function_call(int cpu, int (*func) (void *info), void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= NULL,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -ENXIO, /* No such CPU */\n\t};\n\n\tsmp_call_function_single(cpu, remote_function, &data, 1);\n\n\treturn data.ret;\n}\n",
        "output": "0",
        "index": 25988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _free_ptr(zend_resource *rsrc)\n{\n\tpgLofp *lofp = (pgLofp *)rsrc->ptr;\n\tefree(lofp);\n}\n",
        "output": "0",
        "index": 5211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "encode_STACK_POP(const struct ofpact_stack *stack,\n                 enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    encode_STACK_op(stack, put_NXAST_STACK_POP(out));\n}\n",
        "output": "0",
        "index": 76904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "e1000e_write_ext_rx_descr(E1000ECore *core, uint8_t *desc,\n                          struct NetRxPkt *pkt,\n                          const E1000E_RSSInfo *rss_info,\n                          uint16_t length)\n{\n    union e1000_rx_desc_extended *d = (union e1000_rx_desc_extended *) desc;\n\n    memset(&d->wb, 0, sizeof(d->wb));\n\n    d->wb.upper.length = cpu_to_le16(length);\n\n    e1000e_build_rx_metadata(core, pkt, pkt != NULL,\n                             rss_info,\n                             &d->wb.lower.hi_dword.rss,\n                             &d->wb.lower.mrq,\n                             &d->wb.upper.status_error,\n                             &d->wb.lower.hi_dword.csum_ip.ip_id,\n                             &d->wb.upper.vlan);\n}\n",
        "output": "0",
        "index": 6098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_DEPTH( INS_ARG )\n  {\n    DO_DEPTH\n  }\n",
        "output": "0",
        "index": 10095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bs_read (Bitstream *bs)\n{\n    bs->ptr = bs->buf;\n    bs->error = 1;\n}\n",
        "output": "0",
        "index": 70886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _xml_externalEntityRefHandler(XML_Parser parserPtr,\n\t\t\t\t\t\t\t\t   const XML_Char *openEntityNames,\n\t\t\t\t\t\t\t\t   const XML_Char *base,\n\t\t\t\t\t\t\t\t   const XML_Char *systemId,\n\t\t\t\t\t\t\t\t   const XML_Char *publicId)\n{\n\txml_parser *parser = XML_GetUserData(parserPtr);\n\tint ret = 0; /* abort if no handler is set (should be configurable?) */\n\n\tif (parser && parser->externalEntityRefHandler) {\n\t\tzval *retval, *args[5];\n\n\t\targs[0] = _xml_resource_zval(parser->index);\n\t\targs[1] = _xml_xmlchar_zval(openEntityNames, 0, parser->target_encoding);\n\t\targs[2] = _xml_xmlchar_zval(base, 0, parser->target_encoding);\n\t\targs[3] = _xml_xmlchar_zval(systemId, 0, parser->target_encoding);\n\t\targs[4] = _xml_xmlchar_zval(publicId, 0, parser->target_encoding);\n\t\tif ((retval = xml_call_handler(parser, parser->externalEntityRefHandler, parser->externalEntityRefPtr, 5, args))) {\n\t\t\tconvert_to_long(retval);\n\t\t\tret = Z_LVAL_P(retval);\n\t\t\tefree(retval);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n",
        "output": "0",
        "index": 10990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PluginServiceImpl::GetPluginsInternal(\n     base::MessageLoopProxy* target_loop,\n     const PluginService::GetPluginsCallback& callback) {\n  DCHECK(BrowserThread::GetBlockingPool()->IsRunningSequenceOnCurrentThread(\n      plugin_list_token_));\n\n  std::vector<webkit::WebPluginInfo> plugins;\n  plugin_list_->GetPlugins(&plugins);\n\n  target_loop->PostTask(FROM_HERE,\n      base::Bind(callback, plugins));\n}\n",
        "output": "0",
        "index": 125132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::InitTextureMaxAnisotropyIfNeeded(\n    GLenum target, GLenum pname) {\n  if (!workarounds().init_texture_max_anisotropy)\n    return;\n  if (pname != GL_TEXTURE_MAX_ANISOTROPY_EXT ||\n      !validators_->texture_parameter.IsValid(pname)) {\n    return;\n  }\n\n  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(\n      &state_, target);\n  if (!texture_ref) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION,\n        \"glGetTexParamter{fi}v\", \"unknown texture for target\");\n    return;\n  }\n  Texture* texture = texture_ref->texture();\n  texture->InitTextureMaxAnisotropyIfNeeded(target);\n}\n",
        "output": "0",
        "index": 129447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const HTMLElement& toHTMLElement(const FormAssociatedElement& associatedElement)\n{\n    if (associatedElement.isFormControlElement())\n        return toHTMLFormControlElement(associatedElement);\n    return toHTMLObjectElement(associatedElement);\n}\n",
        "output": "0",
        "index": 133903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void RunTwoClientMigrationTest(const MigrationList& migration_list,\n                                    TriggerMethod trigger_method) {\n    if (!ShouldRunMigrationTest()) {\n      return;\n    }\n    ASSERT_TRUE(SetupSync());\n\n    VerifyPrefSync();\n\n    RunMigrationTest(migration_list, trigger_method);\n\n    VerifyPrefSync();\n  }\n",
        "output": "0",
        "index": 111969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AudioContext::isAudioThread() const\n{\n    return currentThread() == m_audioThread;\n}\n",
        "output": "0",
        "index": 139666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::DidLoadAllScriptBlockingResources() {\n  execute_scripts_waiting_for_resources_task_handle_ =\n      GetTaskRunner(TaskType::kNetworking)\n          ->PostCancellableTask(\n              BLINK_FROM_HERE,\n              WTF::Bind(&Document::ExecuteScriptsWaitingForResources,\n                        WrapWeakPersistent(this)));\n\n  if (IsHTMLDocument() && body()) {\n    BeginLifecycleUpdatesIfRenderingReady();\n  } else if (!IsHTMLDocument() && documentElement()) {\n    BeginLifecycleUpdatesIfRenderingReady();\n  }\n}\n",
        "output": "0",
        "index": 159559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void build_skb_flow_key(struct flowi4 *fl4, const struct sk_buff *skb,\n\t\t\t       const struct sock *sk)\n{\n\tconst struct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tint oif = skb->dev->ifindex;\n\tu8 tos = RT_TOS(iph->tos);\n\tu8 prot = iph->protocol;\n\tu32 mark = skb->mark;\n\n\t__build_flow_key(net, fl4, sk, iph, oif, tos, prot, mark, 0);\n}\n",
        "output": "0",
        "index": 62045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool InputMethodLinuxX11::DispatchKeyEvent(\n    const base::NativeEvent& native_key_event) {\n  EventType event_type = EventTypeFromNative(native_key_event);\n  DCHECK(event_type == ET_KEY_PRESSED || event_type == ET_KEY_RELEASED);\n  DCHECK(system_toplevel_window_focused());\n\n  if (!GetTextInputClient())\n    return DispatchKeyEventPostIME(native_key_event);\n\n  if (input_method_context_->DispatchKeyEvent(native_key_event)) {\n    if (event_type == ET_KEY_PRESSED)\n      DispatchFabricatedKeyEventPostIME(ET_KEY_PRESSED, VKEY_PROCESSKEY,\n                                        EventFlagsFromNative(native_key_event));\n    return true;\n  }\n\n  const bool handled = DispatchKeyEventPostIME(native_key_event);\n  if (event_type == ET_KEY_PRESSED && GetTextInputClient()) {\n    uint16 ch = 0;\n    const int flags = EventFlagsFromNative(native_key_event);\n    if (!(flags & EF_CONTROL_DOWN))\n      ch = GetCharacterFromXEvent(native_key_event);\n    if (!ch)\n      ch = GetCharacterFromKeyCode(KeyboardCodeFromNative(native_key_event),\n                                   flags);\n    if (ch) {\n      GetTextInputClient()->InsertChar(ch, flags);\n      return true;\n    }\n  }\n  return handled;\n}\n",
        "output": "0",
        "index": 134142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::didUpdateCurrentHistoryItem(blink::WebLocalFrame* frame) {\n  DCHECK(!frame_ || frame_ == frame);\n  render_view_->didUpdateCurrentHistoryItem(frame);\n}\n",
        "output": "0",
        "index": 118519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Element* ContainerNode::getElementById(const AtomicString& id) const\n{\n    if (isInTreeScope()) {\n        Element* element = treeScope().getElementById(id);\n        if (!element)\n            return nullptr;\n        if (element->isDescendantOf(this))\n            return element;\n    }\n\n    for (Element& element : ElementTraversal::descendantsOf(*this)) {\n        if (element.getIdAttribute() == id)\n            return &element;\n    }\n    return nullptr;\n}\n",
        "output": "0",
        "index": 135941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vbf_stp_condfetch(struct worker *wrk, struct busyobj *bo)\n{\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tCHECK_OBJ_NOTNULL(bo, BUSYOBJ_MAGIC);\n\n\tAZ(vbf_beresp2obj(bo));\n\n\tif (ObjHasAttr(bo->wrk, bo->stale_oc, OA_ESIDATA))\n\t\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc,\n\t\t    OA_ESIDATA));\n\n\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc, OA_FLAGS));\n\tAZ(ObjCopyAttr(bo->wrk, bo->fetch_objcore, bo->stale_oc, OA_GZIPBITS));\n\n\tif (bo->do_stream) {\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_PREP_STREAM);\n\t\tHSH_Unbusy(wrk, bo->fetch_objcore);\n\t\tObjSetState(wrk, bo->fetch_objcore, BOS_STREAM);\n\t}\n\n\tif (ObjIterate(wrk, bo->stale_oc, bo, vbf_objiterator, 0))\n\t\t(void)VFP_Error(bo->vfc, \"Template object failed\");\n\n\tif (bo->stale_oc->flags & OC_F_FAILED)\n\t\t(void)VFP_Error(bo->vfc, \"Template object failed\");\n\tif (bo->vfc->failed) {\n\t\tVDI_Finish(bo->wrk, bo);\n\t\twrk->stats->fetch_failed++;\n\t\treturn (F_STP_FAIL);\n\t}\n\treturn (F_STP_FETCHEND);\n}\n",
        "output": "0",
        "index": 66257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "StatusBubble* Browser::GetStatusBubble() {\n#if !defined(OS_MACOSX)\n  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))\n    return NULL;\n#endif\n  return window_ ? window_->GetStatusBubble() : NULL;\n}\n",
        "output": "0",
        "index": 101673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MemBackendImpl::~MemBackendImpl() {\n  DCHECK(CheckLRUListOrder(lru_list_));\n  while (!entries_.empty())\n    entries_.begin()->second->Doom();\n\n  if (!post_cleanup_callback_.is_null())\n    base::SequencedTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE, std::move(post_cleanup_callback_));\n}\n",
        "output": "0",
        "index": 160196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op = {0};\n\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n",
        "output": "0",
        "index": 82800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsUIBindings::CloseWindow() {\n  delegate_->CloseWindow();\n}\n",
        "output": "0",
        "index": 150970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Persistent<v8::FunctionTemplate> V8TestEventConstructor::GetTemplate()\n{\n    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();\n    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);\n    if (result != data->templateMap().end())\n        return result->second;\n\n    v8::HandleScope handleScope;\n    v8::Persistent<v8::FunctionTemplate> templ =\n        ConfigureV8TestEventConstructorTemplate(GetRawTemplate());\n    data->templateMap().add(&info, templ);\n    return templ;\n}\n",
        "output": "0",
        "index": 117730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void daemonize(SERVER* serve) {\n\tFILE*pidf;\n\n\tif(serve && !(serve->port)) {\n\t\treturn;\n\t}\n\tif(daemon(0,0)<0) {\n\t\terr(\"daemon\");\n\t}\n\tif(!*pidftemplate) {\n\t\tif(serve) {\n\t\t\tstrncpy(pidftemplate, \"/var/run/nbd-server.%d.pid\", 255);\n\t\t} else {\n\t\t\tstrncpy(pidftemplate, \"/var/run/nbd-server.pid\", 255);\n\t\t}\n\t}\n\tsnprintf(pidfname, 255, pidftemplate, serve ? serve->port : 0);\n\tpidf=fopen(pidfname, \"w\");\n\tif(pidf) {\n\t\tfprintf(pidf,\"%d\\n\", (int)getpid());\n\t\tfclose(pidf);\n\t} else {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Not fatal; continuing\");\n\t}\n}\n",
        "output": "0",
        "index": 18425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t OMX::createPersistentInputSurface(\n        sp<IGraphicBufferProducer> *bufferProducer,\n        sp<IGraphicBufferConsumer> *bufferConsumer) {\n return OMXNodeInstance::createPersistentInputSurface(\n            bufferProducer, bufferConsumer);\n}\n",
        "output": "0",
        "index": 174140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t\tvoid CWebServer::CleanSessions() {\n\t\t\tm_sql.safe_query(\n\t\t\t\t\"DELETE FROM UserSessions WHERE ExpirationDate < datetime('now', 'localtime')\");\n\t\t}\n",
        "output": "0",
        "index": 90960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4_stateid *stateid, int issync)\n{\n\tstruct nfs4_delegreturndata *data;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DELEGRETURN],\n\t\t.rpc_cred = cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_delegreturn_ops,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = 0;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->args.fhandle = &data->fh;\n\tdata->args.stateid = &data->stateid;\n\tdata->args.bitmask = server->attr_bitmask;\n\tnfs_copy_fh(&data->fh, NFS_FH(inode));\n\tmemcpy(&data->stateid, stateid, sizeof(data->stateid));\n\tdata->res.fattr = &data->fattr;\n\tdata->res.server = server;\n\tnfs_fattr_init(data->res.fattr);\n\tdata->timestamp = jiffies;\n\tdata->rpc_status = 0;\n\n\ttask_setup_data.callback_data = data;\n\tmsg.rpc_argp = &data->args,\n\tmsg.rpc_resp = &data->res,\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (!issync)\n\t\tgoto out;\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status != 0)\n\t\tgoto out;\n\tstatus = data->rpc_status;\n\tif (status != 0)\n\t\tgoto out;\n\tnfs_refresh_inode(inode, &data->fattr);\nout:\n\trpc_put_task(task);\n\treturn status;\n}\n",
        "output": "0",
        "index": 22840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void draw_pattern_push( wmfAPI* API,\n                               unsigned long id,\n                               unsigned long columns,\n                               unsigned long rows )\n{\n  char\n    pattern_id[30];\n\n  (void) FormatLocaleString(pattern_id,MaxTextExtent,\"brush_%lu\",id);\n  (void) DrawPushPattern(WmfDrawingWand,pattern_id,0,0,columns,rows);\n}\n",
        "output": "0",
        "index": 71807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t WebProcessProxy::frameCountInPage(WebPageProxy* page) const\n{\n    size_t result = 0;\n    for (HashMap<uint64_t, RefPtr<WebFrameProxy> >::const_iterator iter = m_frameMap.begin(); iter != m_frameMap.end(); ++iter) {\n        if (iter->value->page() == page)\n            ++result;\n    }\n    return result;\n}\n",
        "output": "0",
        "index": 113394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t CameraClient::autoFocus() {\n    LOG1(\"autoFocus (pid %d)\", getCallingPid());\n\n Mutex::Autolock lock(mLock);\n status_t result = checkPidAndHardware();\n if (result != NO_ERROR) return result;\n\n return mHardware->autoFocus();\n}\n",
        "output": "0",
        "index": 174935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ftrace_hash *alloc_ftrace_hash(int size_bits)\n{\n\tstruct ftrace_hash *hash;\n\tint size;\n\n\thash = kzalloc(sizeof(*hash), GFP_KERNEL);\n\tif (!hash)\n\t\treturn NULL;\n\n\tsize = 1 << size_bits;\n\thash->buckets = kcalloc(size, sizeof(*hash->buckets), GFP_KERNEL);\n\n\tif (!hash->buckets) {\n\t\tkfree(hash);\n\t\treturn NULL;\n\t}\n\n\thash->size_bits = size_bits;\n\n\treturn hash;\n}\n",
        "output": "0",
        "index": 30115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_network(struct lxc_list *network)\n{\n\tstruct lxc_list *iterator;\n\tstruct lxc_netdev *netdev;\n\n\tlxc_list_for_each(iterator, network) {\n\n\t\tnetdev = iterator->elem;\n\n\t\tif (setup_netdev(netdev)) {\n\t\t\tERROR(\"failed to setup netdev\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!lxc_list_empty(network))\n\t\tINFO(\"network has been setup\");\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 44642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "follow_link(struct path *link, struct nameidata *nd, void **p)\n{\n\tstruct dentry *dentry = link->dentry;\n\tint error;\n\tchar *s;\n\n\tBUG_ON(nd->flags & LOOKUP_RCU);\n\n\tif (link->mnt == nd->path.mnt)\n\t\tmntget(link->mnt);\n\n\terror = -ELOOP;\n\tif (unlikely(current->total_link_count >= 40))\n\t\tgoto out_put_nd_path;\n\n\tcond_resched();\n\tcurrent->total_link_count++;\n\n\ttouch_atime(link);\n\tnd_set_link(nd, NULL);\n\n\terror = security_inode_follow_link(link->dentry, nd);\n\tif (error)\n\t\tgoto out_put_nd_path;\n\n\tnd->last_type = LAST_BIND;\n\t*p = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(*p);\n\tif (IS_ERR(*p))\n\t\tgoto out_put_nd_path;\n\n\terror = 0;\n\ts = nd_get_link(nd);\n\tif (s) {\n\t\tif (unlikely(IS_ERR(s))) {\n\t\t\tpath_put(&nd->path);\n\t\t\tput_link(nd, link, *p);\n\t\t\treturn PTR_ERR(s);\n\t\t}\n\t\tif (*s == '/') {\n\t\t\tset_root(nd);\n\t\t\tpath_put(&nd->path);\n\t\t\tnd->path = nd->root;\n\t\t\tpath_get(&nd->root);\n\t\t\tnd->flags |= LOOKUP_JUMPED;\n\t\t}\n\t\tnd->inode = nd->path.dentry->d_inode;\n\t\terror = link_path_walk(s, nd);\n\t\tif (unlikely(error))\n\t\t\tput_link(nd, link, *p);\n\t}\n\n\treturn error;\n\nout_put_nd_path:\n\t*p = NULL;\n\tpath_put(&nd->path);\n\tpath_put(link);\n\treturn error;\n}\n",
        "output": "0",
        "index": 36315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *FS_LoadedPakPureChecksums( void ) {\n\tstatic char\tinfo[BIG_INFO_STRING];\n\tsearchpath_t\t*search;\n\n\tinfo[0] = 0;\n\n\tfor ( search = fs_searchpaths ; search ; search = search->next ) {\n\t\tif ( !search->pack ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tQ_strcat( info, sizeof( info ), va(\"%i \", search->pack->pure_checksum ) );\n\t}\n\n\treturn info;\n}\n",
        "output": "0",
        "index": 96040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */\n         /* libpthread allocated some memory that is only pointed to by  */\n        /* mmapped thread stacks.  Make sure it's not collectable.      */\n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          /* This test does not need to ensure memory visibility, since */\n          /* the bounds will be set when/if we create another thread.   */\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          /* The two ranges are actually usually adjacent, so there may */\n          /* be a way to speed this up.                                 */\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}\n",
        "output": "1",
        "index": 183053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mmap_mem(struct file *file, struct vm_area_struct *vma)\n{\n\tsize_t size = vma->vm_end - vma->vm_start;\n\n\tif (!valid_mmap_phys_addr_range(vma->vm_pgoff, size))\n\t\treturn -EINVAL;\n\n\tif (!private_mapping_ok(vma))\n\t\treturn -ENOSYS;\n\n\tif (!range_is_allowed(vma->vm_pgoff, size))\n\t\treturn -EPERM;\n\n\tif (!phys_mem_access_prot_allowed(file, vma->vm_pgoff, size,\n\t\t\t\t\t\t&vma->vm_page_prot))\n\t\treturn -EINVAL;\n\n\tvma->vm_page_prot = phys_mem_access_prot(file, vma->vm_pgoff,\n\t\t\t\t\t\t size,\n\t\t\t\t\t\t vma->vm_page_prot);\n\n\tvma->vm_ops = &mmap_mem_ops;\n\n\t/* Remap-pfn-range will mark the range VM_IO */\n\tif (remap_pfn_range(vma,\n\t\t\t    vma->vm_start,\n\t\t\t    vma->vm_pgoff,\n\t\t\t    size,\n\t\t\t    vma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 66880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderLayerScrollableArea::isActive() const\n{\n    Page* page = box().frame()->page();\n    return page && page->focusController().isActive();\n}\n",
        "output": "0",
        "index": 128408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "String HTMLMediaElement::preload() const {\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return PreloadTypeToString(WebMediaPlayer::kPreloadNone);\n  return PreloadTypeToString(PreloadType());\n}\n",
        "output": "0",
        "index": 142964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderFrameHostImpl* RenderFrameHostImpl::GetParent() {\n  return parent_;\n}\n",
        "output": "0",
        "index": 138695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SetRedirects(const std::vector<GURL>& redirects,\n                  FrameHostMsg_DidCommitProvisionalLoad_Params* params) {\n  params->redirects = redirects;\n}\n",
        "output": "0",
        "index": 157694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dissect_dch_ul_node_synchronisation(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, int offset)\n{\n    return dissect_common_ul_node_synchronisation(pinfo, tree, tvb, offset);\n}\n",
        "output": "0",
        "index": 51862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TabletModeWindowState::AttachState(\n    wm::WindowState* window_state,\n    wm::WindowState::State* previous_state) {\n  current_state_type_ = previous_state->GetType();\n\n  gfx::Rect restore_bounds = GetRestoreBounds(window_state);\n  if (!restore_bounds.IsEmpty()) {\n    SetWindowRestoreOverrides(window_state->window(), restore_bounds,\n                              window_state->GetShowState());\n  }\n\n  if (current_state_type_ != WindowStateType::kMaximized &&\n      current_state_type_ != WindowStateType::kMinimized &&\n      current_state_type_ != WindowStateType::kFullscreen &&\n      current_state_type_ != WindowStateType::kPinned &&\n      current_state_type_ != WindowStateType::kTrustedPinned) {\n    UpdateWindow(window_state, state_type_on_attach_,\n                 animate_bounds_on_attach_);\n  }\n}\n",
        "output": "0",
        "index": 150234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::OnSetAccessibilityMode(AccessibilityMode new_mode) {\n  if (accessibility_mode_ == new_mode)\n    return;\n  accessibility_mode_ = new_mode;\n  if (renderer_accessibility_) {\n    delete renderer_accessibility_;\n    renderer_accessibility_ = NULL;\n  }\n  if (accessibility_mode_ == AccessibilityModeComplete)\n    renderer_accessibility_ = new RendererAccessibilityComplete(this);\n  else if (accessibility_mode_ == AccessibilityModeEditableTextOnly)\n    renderer_accessibility_ = new RendererAccessibilityFocusOnly(this);\n}\n",
        "output": "0",
        "index": 108968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DiskCacheBackendTest::BackendRecoverWithEviction() {\n  success_ = false;\n  ASSERT_TRUE(CopyTestCache(\"insert_load1\"));\n  DisableFirstCleanup();\n\n  SetMask(0xf);\n  SetMaxSize(0x1000);\n\n  InitCache();\n  DisableIntegrityCheck();\n}\n",
        "output": "0",
        "index": 159984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, NULL);\n}\n",
        "output": "0",
        "index": 33428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    CSPSourceListTest()\n        : csp(ContentSecurityPolicy::create())\n    {\n    }\n",
        "output": "0",
        "index": 136266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "apply_socktype_protocol_hack(struct evutil_addrinfo *ai)\n{\n\tstruct evutil_addrinfo *ai_new;\n\tfor (; ai; ai = ai->ai_next) {\n\t\tevutil_getaddrinfo_infer_protocols(ai);\n\t\tif (ai->ai_socktype || ai->ai_protocol)\n\t\t\tcontinue;\n\t\tai_new = mm_malloc(sizeof(*ai_new));\n\t\tif (!ai_new)\n\t\t\treturn -1;\n\t\tmemcpy(ai_new, ai, sizeof(*ai_new));\n\t\tai->ai_socktype = SOCK_STREAM;\n\t\tai->ai_protocol = IPPROTO_TCP;\n\t\tai_new->ai_socktype = SOCK_DGRAM;\n\t\tai_new->ai_protocol = IPPROTO_UDP;\n\n\t\tai_new->ai_next = ai->ai_next;\n\t\tai->ai_next = ai_new;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 70711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PaintLayerScrollableArea::InvalidateStickyConstraintsFor(\n    PaintLayer* layer,\n    bool needs_compositing_update) {\n  if (PaintLayerScrollableAreaRareData* d = RareData()) {\n    d->sticky_constraints_map_.erase(layer);\n    if (needs_compositing_update &&\n        layer->GetLayoutObject().StyleRef().HasStickyConstrainedPosition()) {\n      layer->SetNeedsCompositingInputsUpdate();\n      layer->GetLayoutObject().SetNeedsPaintPropertyUpdate();\n    }\n  }\n}\n",
        "output": "0",
        "index": 141436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf);\n#endif /* CONFIG_FUNCTION_GRAPH_TRACER */\n}\n",
        "output": "0",
        "index": 30269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_context_sched_in(struct perf_event_context *ctx,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\tcpuctx = __get_cpu_context(ctx);\n\tif (cpuctx->task_ctx == ctx)\n\t\treturn;\n\n\tperf_ctx_lock(cpuctx, ctx);\n\tperf_pmu_disable(ctx->pmu);\n\t/*\n\t * We want to keep the following priority order:\n\t * cpu pinned (that don't need to move), task pinned,\n\t * cpu flexible, task flexible.\n\t */\n\tcpu_ctx_sched_out(cpuctx, EVENT_FLEXIBLE);\n\n\tperf_event_sched_in(cpuctx, ctx, task);\n\n\tcpuctx->task_ctx = ctx;\n\n\tperf_pmu_enable(ctx->pmu);\n\tperf_ctx_unlock(cpuctx, ctx);\n\n\t/*\n\t * Since these rotations are per-cpu, we need to ensure the\n\t * cpu-context we got scheduled on is actually rotating.\n\t */\n\tperf_pmu_rotate_start(ctx->pmu);\n}\n",
        "output": "0",
        "index": 26065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vrend_renderer_create_fence(int client_fence_id, uint32_t ctx_id)\n{\n   struct vrend_fence *fence;\n\n   fence = malloc(sizeof(struct vrend_fence));\n   if (!fence)\n      return ENOMEM;\n\n   fence->ctx_id = ctx_id;\n   fence->fence_id = client_fence_id;\n   fence->syncobj = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);\n\n   if (fence->syncobj == NULL)\n      goto fail;\n\n   if (vrend_state.sync_thread) {\n      pipe_mutex_lock(vrend_state.fence_mutex);\n      list_addtail(&fence->fences, &vrend_state.fence_wait_list);\n      pipe_mutex_unlock(vrend_state.fence_mutex);\n      pipe_condvar_signal(vrend_state.fence_cond);\n   } else\n      list_addtail(&fence->fences, &vrend_state.fence_list);\n   return 0;\n\n fail:\n   fprintf(stderr, \"failed to create fence sync object\\n\");\n   free(fence);\n   return ENOMEM;\n}\n",
        "output": "0",
        "index": 8894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __attribute__ ((format (printf, 2, 3))) void QDECL CL_RefPrintf( int print_level, const char *fmt, ...) {\n\tva_list\targptr;\n\tchar\tmsg[MAXPRINTMSG];\n\n\tva_start( argptr,fmt );\n\tQ_vsnprintf( msg, sizeof ( msg ), fmt, argptr );\n\tva_end( argptr );\n\n\tif ( print_level == PRINT_ALL ) {\n\t\tCom_Printf( \"%s\", msg );\n\t} else if ( print_level == PRINT_WARNING ) {\n\t\tCom_Printf( S_COLOR_YELLOW \"%s\", msg );\t\t// yellow\n\t} else if ( print_level == PRINT_DEVELOPER ) {\n\t\tCom_DPrintf( S_COLOR_RED \"%s\", msg );\t\t// red\n\t}\n}\n",
        "output": "0",
        "index": 95705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "each_scalar(void *state, char *token, JsonTokenType tokentype)\n{\n\tEachState  *_state = (EachState *) state;\n\n\t/* json structure check */\n\tif (_state->lex->lex_level == 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"cannot deconstruct a scalar\")));\n\n\t/* supply de-escaped value if required */\n\tif (_state->next_scalar)\n\t\t_state->normalized_scalar = token;\n}\n",
        "output": "0",
        "index": 2571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const HttpResponseInfo* HttpProxyClientSocket::GetConnectResponseInfo() const {\n  return response_.headers.get() ? &response_ : NULL;\n}\n",
        "output": "0",
        "index": 140511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n    return UNDEFINED;\n\n  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,\n          \"type of \\\"%s\\\" is not integer\\n\", field);\n\n  return ((YR_OBJECT_INTEGER*) integer_obj)->value;\n}\n",
        "output": "0",
        "index": 66048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void remove_pidfile(const char *pid_file) {\n  if (pid_file == NULL)\n      return;\n\n  if (unlink(pid_file) != 0) {\n      vperror(\"Could not remove the pid file %s\", pid_file);\n  }\n\n}\n",
        "output": "0",
        "index": 75206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NavigationControllerImpl::PruneAllButVisibleInternal() {\n  CHECK(CanPruneAllButVisible());\n\n  entries_.erase(entries_.begin(),\n                 entries_.begin() + last_committed_entry_index_);\n  entries_.erase(entries_.begin() + 1, entries_.end());\n  last_committed_entry_index_ = 0;\n}\n",
        "output": "0",
        "index": 119804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const std::string& CSPInfo::GetContentSecurityPolicy(\n    const Extension* extension) {\n  CSPInfo* csp_info = static_cast<CSPInfo*>(\n          extension->GetManifestData(keys::kContentSecurityPolicy));\n  return csp_info ? csp_info->content_security_policy : base::EmptyString();\n}\n",
        "output": "0",
        "index": 136239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void ImageLoader::dispatchErrorEvent() {\n  m_hasPendingErrorEvent = true;\n  errorEventSender().dispatchEventSoon(this);\n}\n",
        "output": "0",
        "index": 139014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mp_put_chars(struct tty_struct *tty)\n{\n\tmp_start(tty);\n}\n",
        "output": "0",
        "index": 29393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chkURLBuffer(Buffer *buf)\n{\n    static char *url_like_pat[] = {\n\t\"https?://[a-zA-Z0-9][a-zA-Z0-9:%\\\\-\\\\./?=~_\\\\&+@#,\\\\$;]*[a-zA-Z0-9_/=\\\\-]\",\n\t\"file:/[a-zA-Z0-9:%\\\\-\\\\./=_\\\\+@#,\\\\$;]*\",\n#ifdef USE_GOPHER\n\t\"gopher://[a-zA-Z0-9][a-zA-Z0-9:%\\\\-\\\\./_]*\",\n#endif\t\t\t\t/* USE_GOPHER */\n\t\"ftp://[a-zA-Z0-9][a-zA-Z0-9:%\\\\-\\\\./=_+@#,\\\\$]*[a-zA-Z0-9_/]\",\n#ifdef USE_NNTP\n\t\"news:[^<> \t][^<> \t]*\",\n\t\"nntp://[a-zA-Z0-9][a-zA-Z0-9:%\\\\-\\\\./_]*\",\n#endif\t\t\t\t/* USE_NNTP */\n#ifndef USE_W3MMAILER\t\t/* see also chkExternalURIBuffer() */\n\t\"mailto:[^<> \t][^<> \t]*@[a-zA-Z0-9][a-zA-Z0-9\\\\-\\\\._]*[a-zA-Z0-9]\",\n#endif\n#ifdef INET6\n\t\"https?://[a-zA-Z0-9:%\\\\-\\\\./_@]*\\\\[[a-fA-F0-9:][a-fA-F0-9:\\\\.]*\\\\][a-zA-Z0-9:%\\\\-\\\\./?=~_\\\\&+@#,\\\\$;]*\",\n\t\"ftp://[a-zA-Z0-9:%\\\\-\\\\./_@]*\\\\[[a-fA-F0-9:][a-fA-F0-9:\\\\.]*\\\\][a-zA-Z0-9:%\\\\-\\\\./=_+@#,\\\\$]*\",\n#endif\t\t\t\t/* INET6 */\n\tNULL\n    };\n    int i;\n    for (i = 0; url_like_pat[i]; i++) {\n\treAnchor(buf, url_like_pat[i]);\n    }\n#ifdef USE_EXTERNAL_URI_LOADER\n    chkExternalURIBuffer(buf);\n#endif\n    buf->check_url |= CHK_URL;\n}\n",
        "output": "0",
        "index": 84471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SSL_CTX_flush_sessions(SSL_CTX *s, long t)\n{\n    unsigned long i;\n    TIMEOUT_PARAM tp;\n\n    tp.ctx = s;\n    tp.cache = s->sessions;\n    if (tp.cache == NULL)\n        return;\n    tp.time = t;\n    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\n    i = CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load;\n    CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load = 0;\n    lh_SSL_SESSION_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout),\n                             TIMEOUT_PARAM, &tp);\n    CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load = i;\n    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\n}\n",
        "output": "0",
        "index": 12767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::SendFailedProvisionalLoad(\n    const blink::WebURLRequest& request,\n    const WebURLError& error,\n    blink::WebLocalFrame* frame) {\n  bool show_repost_interstitial =\n      (error.reason() == net::ERR_CACHE_MISS &&\n       base::EqualsASCII(request.HttpMethod().Utf16(), \"POST\"));\n\n  FrameHostMsg_DidFailProvisionalLoadWithError_Params params;\n  params.error_code = error.reason();\n  GetContentClient()->renderer()->GetErrorDescription(\n      request, error, &params.error_description);\n  params.url = error.url(),\n  params.showing_repost_interstitial = show_repost_interstitial;\n  Send(new FrameHostMsg_DidFailProvisionalLoadWithError(routing_id_, params));\n}\n",
        "output": "0",
        "index": 165935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gtco_input_open(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\tdevice->urbinfo->dev = device->usbdev;\n\tif (usb_submit_urb(device->urbinfo, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 55195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int HttpProxyClientSocket::GetLocalAddress(IPEndPoint* address) const {\n  return transport_->socket()->GetLocalAddress(address);\n}\n",
        "output": "0",
        "index": 140512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::Optional<base::TimeDelta> DataReductionProxyConfig::GetHttpRttEstimate()\n    const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return http_rtt_;\n}\n",
        "output": "0",
        "index": 150551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Chunk::write(WEBP_MetaHandler* handler)\n{\n    XMP_IO* file = handler->parent->ioRef;\n    if (this->needsRewrite) {\n        this->pos = file->Offset();\n        XIO::WriteUns32_LE(file, this->tag);\n        XIO::WriteUns32_LE(file, (XMP_Uns32) this->size);\n        file->Write(this->data.data(), (XMP_Int32) this->size);\n    }\n    else {\n        file->Seek(this->pos + this->size + 8, kXMP_SeekFromStart);\n    }\n    if (this->size & 1) {\n        const XMP_Uns8 zero = 0;\n        file->Write(&zero, 1);\n    }\n}\n",
        "output": "0",
        "index": 9955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_ftrace_alive(struct seq_file *m)\n{\n\tif (!ftrace_is_dead())\n\t\treturn;\n\tseq_puts(m, \"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\"\n\t\t    \"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n}\n",
        "output": "0",
        "index": 81361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ModuleExport void UnregisterHALDImage(void)\n{\n  (void) UnregisterMagickInfo(\"HALD\");\n}\n",
        "output": "0",
        "index": 71564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int snd_interval_refine(struct snd_interval *i, const struct snd_interval *v)\n{\n\tint changed = 0;\n\tif (snd_BUG_ON(snd_interval_empty(i)))\n\t\treturn -EINVAL;\n\tif (i->min < v->min) {\n\t\ti->min = v->min;\n\t\ti->openmin = v->openmin;\n\t\tchanged = 1;\n\t} else if (i->min == v->min && !i->openmin && v->openmin) {\n\t\ti->openmin = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->max > v->max) {\n\t\ti->max = v->max;\n\t\ti->openmax = v->openmax;\n\t\tchanged = 1;\n\t} else if (i->max == v->max && !i->openmax && v->openmax) {\n\t\ti->openmax = 1;\n\t\tchanged = 1;\n\t}\n\tif (!i->integer && v->integer) {\n\t\ti->integer = 1;\n\t\tchanged = 1;\n\t}\n\tif (i->integer) {\n\t\tif (i->openmin) {\n\t\t\ti->min++;\n\t\t\ti->openmin = 0;\n\t\t}\n\t\tif (i->openmax) {\n\t\t\ti->max--;\n\t\t\ti->openmax = 0;\n\t\t}\n\t} else if (!i->openmin && !i->openmax && i->min == i->max)\n\t\ti->integer = 1;\n\tif (snd_interval_checkempty(i)) {\n\t\tsnd_interval_none(i);\n\t\treturn -EINVAL;\n\t}\n\treturn changed;\n}\n",
        "output": "0",
        "index": 47799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void efx_remove_all(struct efx_nic *efx)\n{\n\tefx_remove_filters(efx);\n\tefx_remove_channels(efx);\n\tefx_remove_port(efx);\n\tefx_remove_nic(efx);\n}\n",
        "output": "0",
        "index": 19417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_replay_iv_consistency (const struct key_type *kt, bool packet_id, bool use_iv)\n{\n  if (cfb_ofb_mode (kt) && !(packet_id && use_iv))\n    msg (M_FATAL, \"--no-replay or --no-iv cannot be used with a CFB or OFB mode cipher\");\n}\n",
        "output": "0",
        "index": 32003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMX_ERRORTYPE OMXNodeInstance::OnEvent(\n        OMX_IN OMX_HANDLETYPE /* hComponent */,\n        OMX_IN OMX_PTR pAppData,\n        OMX_IN OMX_EVENTTYPE eEvent,\n        OMX_IN OMX_U32 nData1,\n        OMX_IN OMX_U32 nData2,\n        OMX_IN OMX_PTR pEventData) {\n OMXNodeInstance *instance = static_cast<OMXNodeInstance *>(pAppData);\n if (instance->mDying) {\n return OMX_ErrorNone;\n }\n return instance->owner()->OnEvent(\n            instance->nodeID(), eEvent, nData1, nData2, pEventData);\n}\n",
        "output": "0",
        "index": 170715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderLayerCompositor::has3DContent() const\n{\n    return layerHas3DContent(rootRenderLayer());\n}\n",
        "output": "0",
        "index": 122154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lxcfs_getattr(const char *path, struct stat *sb)\n{\n\tif (strcmp(path, \"/\") == 0) {\n\t\tsb->st_mode = S_IFDIR | 00755;\n\t\tsb->st_nlink = 2;\n\t\treturn 0;\n\t}\n\tif (strncmp(path, \"/cgroup\", 7) == 0) {\n\t\treturn cg_getattr(path, sb);\n\t}\n\tif (strncmp(path, \"/proc\", 5) == 0) {\n\t\treturn proc_getattr(path, sb);\n\t}\n\treturn -EINVAL;\n}\n",
        "output": "0",
        "index": 44411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " jas_stream_t *jas_stream_fopen(const char *filename, const char *mode)\n {\n \tjas_stream_t *stream;\n\tjas_stream_fileobj_t *obj;\n\tint openflags;\n\n\t/* Allocate a stream object. */\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* Parse the mode string. */\n\tstream->openmode_ = jas_strtoopenmode(mode);\n\n\t/* Determine the correct flags to use for opening the file. */\n\tif ((stream->openmode_ & JAS_STREAM_READ) &&\n\t  (stream->openmode_ & JAS_STREAM_WRITE)) {\n\t\topenflags = O_RDWR;\n\t} else if (stream->openmode_ & JAS_STREAM_READ) {\n\t\topenflags = O_RDONLY;\n\t} else if (stream->openmode_ & JAS_STREAM_WRITE) {\n\t\topenflags = O_WRONLY;\n\t} else {\n\t\topenflags = 0;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_APPEND) {\n\t\topenflags |= O_APPEND;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_BINARY) {\n\t\topenflags |= O_BINARY;\n\t}\n\tif (stream->openmode_ & JAS_STREAM_CREATE) {\n\t\topenflags |= O_CREAT | O_TRUNC;\n\t}\n\n\t/* Allocate space for the underlying file stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_fileobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tobj->fd = -1;\n\tobj->flags = 0;\n\tobj->pathname[0] = '\\0';\n\tstream->obj_ = (void *) obj;\n\n\t/* Select the operations for a file stream object. */\n\tstream->ops_ = &jas_stream_fileops;\n\n\t/* Open the underlying file. */\n\tif ((obj->fd = open(filename, openflags, JAS_STREAM_PERMS)) < 0) {\n\t\tjas_free(obj);\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\n\t/* By default, use full buffering for this type of stream. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\treturn stream;\n}\n",
        "output": "0",
        "index": 73124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "val_wrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    int *conf_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n",
        "output": "0",
        "index": 63356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_cbc_remove_padding(const SSL* s,\n\t\t\t    SSL3_RECORD *rec,\n\t\t\t    unsigned block_size,\n\t\t\t    unsigned mac_size)\n\t{\n\tunsigned padding_length, good;\n\tconst unsigned overhead = 1 /* padding length byte */ + mac_size;\n\n\t/* These lengths are all public so we can test them in non-constant\n\t * time. */\n\tif (overhead > rec->length)\n\t\treturn 0;\n\n\tpadding_length = rec->data[rec->length-1];\n\tgood = constant_time_ge(rec->length, padding_length+overhead);\n\t/* SSLv3 requires that the padding is minimal. */\n\tgood &= constant_time_ge(block_size, padding_length+1);\n\tpadding_length = good & (padding_length+1);\n\trec->length -= padding_length;\n\trec->type |= padding_length<<8;\t/* kludge: pass padding length */\n\treturn (int)((good & 1) | (~good & -1));\n}\n",
        "output": "0",
        "index": 7179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GfxCalGrayColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk) {\n  GfxRGB rgb;\n  GfxColorComp c, m, y, k;\n\n#ifdef USE_CMS\n  if (XYZ2DisplayTransform != NULL && displayPixelType == PT_CMYK) {\n    double in[gfxColorMaxComps];\n    Guchar out[gfxColorMaxComps];\n    double X, Y, Z;\n    \n    getXYZ(color,&X,&Y,&Z);\n    in[0] = clip01(X);\n    in[1] = clip01(Y);\n    in[2] = clip01(Z);\n    \n    XYZ2DisplayTransform->doTransform(in,out,1);\n    cmyk->c = byteToCol(out[0]);\n    cmyk->m = byteToCol(out[1]);\n    cmyk->y = byteToCol(out[2]);\n    cmyk->k = byteToCol(out[3]);\n    return;\n  }\n#endif\n  getRGB(color, &rgb);\n  c = clip01(gfxColorComp1 - rgb.r);\n  m = clip01(gfxColorComp1 - rgb.g);\n  y = clip01(gfxColorComp1 - rgb.b);\n  k = c;\n  if (m < k) {\n    k = m;\n  }\n  if (y < k) {\n    k = y;\n  }\n  cmyk->c = c - k;\n  cmyk->m = m - k;\n  cmyk->y = y - k;\n  cmyk->k = k;\n}\n",
        "output": "0",
        "index": 1012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void AcceleratedStaticBitmapImage::Abandon() {\n   texture_holder_->Abandon();\n }\n",
        "output": "1",
        "index": 186563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ResetMonitoredUrls() {\n    base::AutoLock lock(lock_);\n    monitored_urls_.clear();\n  }\n",
        "output": "0",
        "index": 150525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void md_reap_sync_thread(struct mddev *mddev)\n{\n\tstruct md_rdev *rdev;\n\n\t/* resync has finished, collect result */\n\tmd_unregister_thread(&mddev->sync_thread);\n\tif (!test_bit(MD_RECOVERY_INTR, &mddev->recovery) &&\n\t    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery)) {\n\t\t/* success...*/\n\t\t/* activate any spares */\n\t\tif (mddev->pers->spare_active(mddev)) {\n\t\t\tsysfs_notify(&mddev->kobj, NULL,\n\t\t\t\t     \"degraded\");\n\t\t\tset_bit(MD_CHANGE_DEVS, &mddev->flags);\n\t\t}\n\t}\n\tif (mddev_is_clustered(mddev))\n\t\tmd_cluster_ops->metadata_update_start(mddev);\n\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n\t    mddev->pers->finish_reshape)\n\t\tmddev->pers->finish_reshape(mddev);\n\n\t/* If array is no-longer degraded, then any saved_raid_disk\n\t * information must be scrapped.\n\t */\n\tif (!mddev->degraded)\n\t\trdev_for_each(rdev, mddev)\n\t\t\trdev->saved_raid_disk = -1;\n\n\tmd_update_sb(mddev, 1);\n\tif (mddev_is_clustered(mddev))\n\t\tmd_cluster_ops->metadata_update_finish(mddev);\n\tclear_bit(MD_RECOVERY_RUNNING, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_DONE, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_SYNC, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_RESHAPE, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_REQUESTED, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_CHECK, &mddev->recovery);\n\twake_up(&resync_wait);\n\t/* flag recovery needed just to double check */\n\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\tsysfs_notify_dirent_safe(mddev->sysfs_action);\n\tmd_new_event(mddev);\n\tif (mddev->event_work.func)\n\t\tqueue_work(md_misc_wq, &mddev->event_work);\n}\n",
        "output": "0",
        "index": 42455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API int _object_and_properties_init(zval *arg, zend_class_entry *class_type, HashTable *properties ZEND_FILE_LINE_DC TSRMLS_DC) /* {{{ */\n{\n\tzend_object *object;\n\n\tif (class_type->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) {\n\t\tchar *what =   (class_type->ce_flags & ZEND_ACC_INTERFACE)                ? \"interface\"\n\t\t\t\t\t :((class_type->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) ? \"trait\"\n\t\t\t\t\t :                                                              \"abstract class\";\n\t\tzend_error(E_ERROR, \"Cannot instantiate %s %s\", what, class_type->name);\n\t}\n\n\tzend_update_class_constants(class_type TSRMLS_CC);\n\n\tZ_TYPE_P(arg) = IS_OBJECT;\n\tif (class_type->create_object == NULL) {\n\t\tZ_OBJVAL_P(arg) = zend_objects_new(&object, class_type TSRMLS_CC);\n\t\tif (properties) {\n\t\t\tobject->properties = properties;\n\t\t\tobject->properties_table = NULL;\n\t\t} else {\n\t\t\tobject_properties_init(object, class_type);\n\t\t}\n\t} else {\n\t\tZ_OBJVAL_P(arg) = class_type->create_object(class_type TSRMLS_CC);\n\t}\n\treturn SUCCESS;\n}\n/* }}} */\n",
        "output": "0",
        "index": 13712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool ResizeGripper::OnMousePressed(const views::MouseEvent& event) {\n   if (!event.IsOnlyLeftMouseButton())\n     return false;\n\n  gfx::Point point(event.x(), 0);\n  View::ConvertPointToScreen(this, &point);\n  initial_position_ = point.x();\n\n  return true;\n}\n",
        "output": "0",
        "index": 98440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ftp_putcmd(ftpbuf_t *ftp, const char *cmd, const char *args)\n{\n\tint\t\tsize;\n\tchar\t\t*data;\n\n\tif (strpbrk(cmd, \"\\r\\n\")) {\n\t\treturn 0;\n\t}\n\t/* build the output buffer */\n\tif (args && args[0]) {\n\t\t/* \"cmd args\\r\\n\\0\" */\n\t\tif (strlen(cmd) + strlen(args) + 4 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (strpbrk(args, \"\\r\\n\")) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s %s\\r\\n\", cmd, args);\n\t} else {\n\t\t/* \"cmd\\r\\n\\0\" */\n\t\tif (strlen(cmd) + 3 > FTP_BUFSIZE) {\n\t\t\treturn 0;\n\t\t}\n\t\tsize = slprintf(ftp->outbuf, sizeof(ftp->outbuf), \"%s\\r\\n\", cmd);\n\t}\n\n\tdata = ftp->outbuf;\n\n\t/* Clear the extra-lines buffer */\n\tftp->extra = NULL;\n\n\tif (my_send(ftp, ftp->fd, data, size) != size) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n",
        "output": "0",
        "index": 14802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "populate_recordset_array_element_start(void *state, bool isnull)\n{\n\tPopulateRecordsetState *_state = (PopulateRecordsetState *) state;\n\n\tif (_state->lex->lex_level == 1 &&\n\t\t_state->lex->token_type != JSON_TOKEN_OBJECT_START)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"argument of %s must be an array of objects\",\n\t\t\t\t\t\t_state->function_name)));\n}\n",
        "output": "0",
        "index": 2640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int usbip_recv(struct socket *sock, void *buf, int size)\n{\n\tint result;\n\tstruct msghdr msg;\n\tstruct kvec iov;\n\tint total = 0;\n\n\t/* for blocks of if (usbip_dbg_flag_xmit) */\n\tchar *bp = buf;\n\tint osize = size;\n\n\tusbip_dbg_xmit(\"enter\\n\");\n\n\tif (!sock || !buf || !size) {\n\t\tpr_err(\"invalid arg, sock %p buff %p size %d\\n\", sock, buf,\n\t\t       size);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tsock->sk->sk_allocation = GFP_NOIO;\n\t\tiov.iov_base    = buf;\n\t\tiov.iov_len     = size;\n\t\tmsg.msg_name    = NULL;\n\t\tmsg.msg_namelen = 0;\n\t\tmsg.msg_control = NULL;\n\t\tmsg.msg_controllen = 0;\n\t\tmsg.msg_flags      = MSG_NOSIGNAL;\n\n\t\tresult = kernel_recvmsg(sock, &msg, &iov, 1, size, MSG_WAITALL);\n\t\tif (result <= 0) {\n\t\t\tpr_debug(\"receive sock %p buf %p size %u ret %d total %d\\n\",\n\t\t\t\t sock, buf, size, result, total);\n\t\t\tgoto err;\n\t\t}\n\n\t\tsize -= result;\n\t\tbuf += result;\n\t\ttotal += result;\n\t} while (size > 0);\n\n\tif (usbip_dbg_flag_xmit) {\n\t\tif (!in_interrupt())\n\t\t\tpr_debug(\"%-10s:\", current->comm);\n\t\telse\n\t\t\tpr_debug(\"interrupt  :\");\n\n\t\tpr_debug(\"receiving....\\n\");\n\t\tusbip_dump_buffer(bp, osize);\n\t\tpr_debug(\"received, osize %d ret %d size %d total %d\\n\",\n\t\t\t osize, result, size, total);\n\t}\n\n\treturn total;\n\nerr:\n\treturn result;\n}\n",
        "output": "0",
        "index": 53605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sctp_chunk *sctp_make_cwr(const struct sctp_association *asoc,\n\t\t\t    const __u32 lowest_tsn,\n\t\t\t    const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_cwrhdr_t cwr;\n\n\tcwr.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_CWR, 0,\n\t\t\t\t   sizeof(sctp_cwrhdr_t));\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.ecn_cwr_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(cwr), &cwr);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [Report a reduced congestion window back to where the ECNE\n\t * came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n",
        "output": "0",
        "index": 35862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "InvalidationNotifier::InvalidationNotifier(\n    scoped_ptr<notifier::PushClient> push_client,\n    const InvalidationVersionMap& initial_max_invalidation_versions,\n    const std::string& initial_invalidation_state,\n    const WeakHandle<InvalidationStateTracker>& invalidation_state_tracker,\n    const std::string& client_info)\n    : state_(STOPPED),\n      initial_max_invalidation_versions_(initial_max_invalidation_versions),\n      invalidation_state_tracker_(invalidation_state_tracker),\n      client_info_(client_info),\n      invalidation_state_(initial_invalidation_state),\n      invalidation_client_(push_client.Pass()) {\n}\n",
        "output": "0",
        "index": 113923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void SetCookieStore(net::CookieStore* cookie_store) {\n    cookie_store_ = cookie_store;\n  }\n",
        "output": "0",
        "index": 167378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BluetoothAdapter::UpdateDiscoveryState(bool is_error) {\n  if (is_error) {\n    if (internal_discovery_state_ == DiscoveryState::kStarting)\n      internal_discovery_state_ = DiscoveryState::kIdle;\n    if (internal_discovery_state_ == DiscoveryState::kStopping)\n      internal_discovery_state_ = DiscoveryState::kIdle;\n    return;\n  }\n\n  if (internal_discovery_state_ == DiscoveryState::kStarting)\n    internal_discovery_state_ = DiscoveryState::kDiscovering;\n  if (internal_discovery_state_ == DiscoveryState::kStopping)\n    internal_discovery_state_ = DiscoveryState::kIdle;\n}\n",
        "output": "0",
        "index": 150889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  GraphicsLayerTest() {\n    clip_layer_ = std::make_unique<FakeGraphicsLayer>(client_);\n    scroll_elasticity_layer_ = std::make_unique<FakeGraphicsLayer>(client_);\n    page_scale_layer_ = std::make_unique<FakeGraphicsLayer>(client_);\n    graphics_layer_ = std::make_unique<FakeGraphicsLayer>(client_);\n    graphics_layer_->SetDrawsContent(true);\n    clip_layer_->AddChild(scroll_elasticity_layer_.get());\n    scroll_elasticity_layer_->AddChild(page_scale_layer_.get());\n    page_scale_layer_->AddChild(graphics_layer_.get());\n    graphics_layer_->CcLayer()->SetScrollable(clip_layer_->CcLayer()->bounds());\n    cc_layer_ = graphics_layer_->CcLayer();\n    layer_tree_view_ = std::make_unique<WebLayerTreeViewImplForTesting>();\n    DCHECK(layer_tree_view_);\n    layer_tree_view_->SetRootLayer(clip_layer_->CcLayer());\n    WebLayerTreeView::ViewportLayers viewport_layers;\n    viewport_layers.overscroll_elasticity = scroll_elasticity_layer_->CcLayer();\n    viewport_layers.page_scale = page_scale_layer_->CcLayer();\n    viewport_layers.inner_viewport_container = clip_layer_->CcLayer();\n    viewport_layers.inner_viewport_scroll = graphics_layer_->CcLayer();\n    layer_tree_view_->RegisterViewportLayers(viewport_layers);\n    layer_tree_view_->SetViewportSize(WebSize(1, 1));\n\n      graphics_layer_->SetLayerState(\n          PropertyTreeState(PropertyTreeState::Root()), IntPoint());\n  }\n",
        "output": "0",
        "index": 136487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reload_tss(void)\n{\n\t/*\n\t * VT restores TR but not its size.  Useless.\n\t */\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; /* available TSS */\n\tload_TR_desc();\n}\n",
        "output": "0",
        "index": 37168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enforcedRangeLongAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"enforcedRangeLongAttr\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, EnforceRange, exceptionState), exceptionState);\n    imp->setEnforcedRangeLongAttr(cppValue);\n}\n",
        "output": "0",
        "index": 130751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const struct perf_event_map *niagara2_event_map(int event_id)\n{\n\treturn &niagara2_perfmon_event_map[event_id];\n}\n",
        "output": "0",
        "index": 25645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void icmp_redirect(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\n\tif (skb->len < sizeof(struct iphdr))\n\t\tgoto out_err;\n\n\t/*\n\t *\tGet the copied header of the packet that caused the redirect\n\t */\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto out;\n\n\tiph = (const struct iphdr *)skb->data;\n\n\tswitch (icmp_hdr(skb)->code & 7) {\n\tcase ICMP_REDIR_NET:\n\tcase ICMP_REDIR_NETTOS:\n\t\t/*\n\t\t * As per RFC recommendations now handle it as a host redirect.\n\t\t */\n\tcase ICMP_REDIR_HOST:\n\tcase ICMP_REDIR_HOSTTOS:\n\t\tip_rt_redirect(ip_hdr(skb)->saddr, iph->daddr,\n\t\t\t       icmp_hdr(skb)->un.gateway,\n\t\t\t       iph->saddr, skb->dev);\n\t\tbreak;\n\t}\nout:\n\treturn;\nout_err:\n\tICMP_INC_STATS_BH(dev_net(skb->dev), ICMP_MIB_INERRORS);\n\tgoto out;\n}\n",
        "output": "0",
        "index": 18860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::AbortCommitNavigation(\n    mojom::FrameNavigationControl::CommitNavigationCallback callback,\n    blink::mojom::CommitResult reason) {\n  DCHECK(callback || IsPerNavigationMojoInterfaceEnabled());\n  if (callback) {\n    std::move(callback).Run(reason);\n  } else {\n    navigation_client_impl_.reset();\n  }\n}\n",
        "output": "0",
        "index": 152184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reflectedURLAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.reflectedURLAttr._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK_VOID(V8Parameter<WithNullCheck>, v, value);\n    imp->setAttribute(WebCore::HTMLNames::reflectedurlattrAttr, v);\n    return;\n}\n",
        "output": "0",
        "index": 117861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mlx5_ib_destroy_qp(struct ib_qp *qp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\n\tif (unlikely(qp->qp_type == IB_QPT_GSI))\n\t\treturn mlx5_ib_gsi_destroy_qp(qp);\n\n\tif (mqp->qp_sub_type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_destroy_dct(mqp);\n\n\tdestroy_qp_common(dev, mqp);\n\n\tkfree(mqp);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 92146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool MediaControlVolumeSliderElement::willRespondToMouseClickEvents() {\n  if (!isConnected() || !document().isActive())\n    return false;\n\n  return MediaControlInputElement::willRespondToMouseClickEvents();\n}\n",
        "output": "0",
        "index": 137894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::allowInlineEventHandlers(Node* node, EventListener* listener, const String& contextURL, const WTF::OrdinalNumber& contextLine)\n{\n    if (!contentSecurityPolicy()->allowInlineEventHandlers(contextURL, contextLine))\n        return false;\n\n    if (!m_frame)\n        return false;\n    if (!m_frame->script()->canExecuteScripts(NotAboutToExecuteScript))\n        return false;\n    if (node && node->document() != this && !node->document().allowInlineEventHandlers(node, listener, contextURL, contextLine))\n        return false;\n\n    return true;\n}\n",
        "output": "0",
        "index": 109570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(env, \"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t/* pop all elements and return */\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 76420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ReadBlobFloatsMSB(Image * image, size_t len, float *data)\n{\n  while (len >= 4)\n  {\n    *data++ = ReadBlobFloat(image);\n    len -= sizeof(float);\n  }\n  if (len > 0)\n    (void) SeekBlob(image, len, SEEK_CUR);\n}\n",
        "output": "0",
        "index": 62091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_fatal_signal(int signr)\n{\n\tstruct pt_regs *regs = signal_pt_regs();\n\tprintk(KERN_INFO \"%s/%d: potentially unexpected fatal signal %d.\\n\",\n\t\tcurrent->comm, task_pid_nr(current), signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tprintk(KERN_INFO \"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_CONT \"%02x \", insn);\n\t\t}\n\t}\n\tprintk(KERN_CONT \"\\n\");\n#endif\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}\n",
        "output": "0",
        "index": 31779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init snd_compress_init(void)\n{\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::NoneSupported(const String& input_message) {\n  BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\"\n                  << input_message << \"')\";\n\n  StopPeriodicTimers();\n  load_state_ = kWaitingForSource;\n  current_source_node_ = nullptr;\n\n  String empty_string;\n  const String& message = MediaShouldBeOpaque() ? empty_string : input_message;\n\n\n  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);\n\n  ForgetResourceSpecificTracks();\n\n  SetNetworkState(kNetworkNoSource);\n\n  UpdateDisplayState();\n\n  ScheduleEvent(event_type_names::kError);\n\n  ScheduleRejectPlayPromises(DOMExceptionCode::kNotSupportedError);\n\n  CloseMediaSource();\n\n  SetShouldDelayLoadEvent(false);\n\n  if (GetLayoutObject())\n    GetLayoutObject()->UpdateFromElement();\n}\n",
        "output": "0",
        "index": 142843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}\n",
        "output": "0",
        "index": 79833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CParaNdisTX::NBLMappingDone(CNBL *NBLHolder)\n{\n    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);\n\n    if (NBLHolder->MappingSuceeded())\n    {\n        DoWithTXLock([NBLHolder, this](){ m_SendList.PushBack(NBLHolder); });\n        DoPendingTasks(false);\n    }\n    else\n    {\n        NBLHolder->SetStatus(NDIS_STATUS_FAILURE);\n        NBLHolder->Release();\n    }\n}\n",
        "output": "0",
        "index": 96317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t NuPlayer::GenericSource::seekTo(int64_t seekTimeUs) {\n    sp<AMessage> msg = new AMessage(kWhatSeek, this);\n    msg->setInt64(\"seekTimeUs\", seekTimeUs);\n\n    sp<AMessage> response;\n status_t err = msg->postAndAwaitResponse(&response);\n if (err == OK && response != NULL) {\n        CHECK(response->findInt32(\"err\", &err));\n }\n\n return err;\n}\n",
        "output": "0",
        "index": 173606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OmniboxViewViews::~OmniboxViewViews() {\n#if defined(OS_CHROMEOS)\n  chromeos::input_method::InputMethodManager::Get()->\n      RemoveCandidateWindowObserver(this);\n#endif\n\n  popup_view_.reset();\n}\n",
        "output": "0",
        "index": 134306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void oidc_clean_expired_state_cookies(request_rec *r, oidc_cfg *c) {\n\tchar *cookie, *tokenizerCtx;\n\tchar *cookies = apr_pstrdup(r->pool,\n\t\t\t(char *) apr_table_get(r->headers_in, \"Cookie\"));\n\tif (cookies != NULL) {\n\t\tcookie = apr_strtok(cookies, \";\", &tokenizerCtx);\n\t\tdo {\n\t\t\twhile (cookie != NULL && *cookie == ' ')\n\t\t\t\tcookie++;\n\t\t\tif (strstr(cookie, OIDCStateCookiePrefix) == cookie) {\n\t\t\t\tchar *cookieName = cookie;\n\t\t\t\twhile (cookie != NULL && *cookie != '=')\n\t\t\t\t\tcookie++;\n\t\t\t\tif (*cookie == '=') {\n\t\t\t\t\t*cookie = '\\0';\n\t\t\t\t\tcookie++;\n\t\t\t\t\tjson_t *state = oidc_get_state_from_cookie(r, c, cookie);\n\t\t\t\t\tif (state != NULL) {\n\t\t\t\t\t\tjson_t *v = json_object_get(state, \"timestamp\");\n\t\t\t\t\t\tapr_time_t now = apr_time_sec(apr_time_now());\n\t\t\t\t\t\tif (now > json_integer_value(v) + c->state_timeout) {\n\t\t\t\t\t\t\toidc_error(r, \"state has expired\");\n\t\t\t\t\t\t\toidc_util_set_cookie(r, cookieName, \"\", 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjson_decref(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcookie = apr_strtok(NULL, \";\", &tokenizerCtx);\n\t\t} while (cookie != NULL);\n\t}\n}\n",
        "output": "0",
        "index": 68126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string PathWithoutParams(const std::string& path) {\n  return GURL(std::string(\"chrome-devtools://devtools/\") + path)\n       .path().substr(1);\n }\n",
        "output": "0",
        "index": 151132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FloatAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"floatAttribute\");\n\n  float cpp_value = NativeValueTraits<IDLFloat>::NativeValue(info.GetIsolate(), v8_value, exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->setFloatAttribute(cpp_value);\n}\n",
        "output": "0",
        "index": 147399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void writeNull() { append(NullTag); }\n",
        "output": "0",
        "index": 129033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool CompareData(const CompoundBuffer& buffer, char* data, int size) {\n    scoped_refptr<IOBuffer> buffer_data = buffer.ToIOBufferWithSize();\n    return buffer.total_bytes() == size &&\n        memcmp(buffer_data->data(), data, size) == 0;\n  }\n",
        "output": "0",
        "index": 105866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool StartsWith(const uint8* buffer,\n                       size_t buffer_size,\n                       const char* prefix) {\n  size_t prefix_size = strlen(prefix);\n  return (prefix_size <= buffer_size &&\n          memcmp(buffer, prefix, prefix_size) == 0);\n}\n",
        "output": "0",
        "index": 127882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmd_compress(char *tag, char *alg)\n{\n    if (imapd_compress_done) {\n        prot_printf(imapd_out,\n                    \"%s BAD [COMPRESSIONACTIVE] DEFLATE active via COMPRESS\\r\\n\",\n                    tag);\n    }\n#if defined(HAVE_SSL) && (OPENSSL_VERSION_NUMBER >= 0x0090800fL)\n    else if (imapd_tls_comp) {\n        prot_printf(imapd_out,\n                    \"%s NO [COMPRESSIONACTIVE] %s active via TLS\\r\\n\",\n                    tag, SSL_COMP_get_name(imapd_tls_comp));\n    }\n#endif // defined(HAVE_SSL) && (OPENSSL_VERSION_NUMBER >= 0x0090800fL)\n    else if (strcasecmp(alg, \"DEFLATE\")) {\n        prot_printf(imapd_out,\n                    \"%s NO Unknown COMPRESS algorithm: %s\\r\\n\", tag, alg);\n    }\n    else if (ZLIB_VERSION[0] != zlibVersion()[0]) {\n        prot_printf(imapd_out,\n                    \"%s NO Error initializing %s (incompatible zlib version)\\r\\n\",\n                    tag, alg);\n    }\n    else {\n        prot_printf(imapd_out,\n                    \"%s OK %s active\\r\\n\", tag, alg);\n\n        /* enable (de)compression for the prot layer */\n        prot_setcompress(imapd_in);\n        prot_setcompress(imapd_out);\n\n        imapd_compress_done = 1;\n    }\n}\n",
        "output": "0",
        "index": 95136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ZIPARCHIVE_METHOD(locateName)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tchar *name;\n\tint name_len;\n\tlong flags = 0;\n\tlong idx = -1;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|l\",\n\t\t\t&name, &name_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (name_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tidx = (long)zip_name_locate(intern, (const char *)name, flags);\n\n\tif (idx >= 0) {\n\t\tRETURN_LONG(idx);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n",
        "output": "0",
        "index": 51267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_image_filter_contrast(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong contrast, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &SIM, &tmp, &contrast) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageContrast(im_src, (int)contrast) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n",
        "output": "0",
        "index": 15197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::OnDeviceScaleFactorChanged(\n    float device_scale_factor) {\n  if (!window_->GetRootWindow())\n    return;\n\n  RenderWidgetHostImpl* host =\n      RenderWidgetHostImpl::From(GetRenderWidgetHost());\n  if (host && host->delegate())\n    host->delegate()->UpdateDeviceScaleFactor(device_scale_factor);\n\n  device_scale_factor_ = device_scale_factor;\n  const display::Display display =\n      display::Screen::GetScreen()->GetDisplayNearestWindow(window_);\n  DCHECK_EQ(device_scale_factor, display.device_scale_factor());\n  current_cursor_.SetDisplayInfo(display);\n  SnapToPhysicalPixelBoundary();\n}\n",
        "output": "0",
        "index": 144942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fslib_copy_dir(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_dir %s\\n\", full_path);\n\n\tstruct stat s;\n\tif (stat(full_path, &s) != 0 || s.st_uid != 0 || !S_ISDIR(s.st_mode) || access(full_path, R_OK))\n\t\treturn;\n\n\tchar *dir_name = strrchr(full_path, '/');\n\tassert(dir_name);\n\tdir_name++;\n\tassert(*dir_name != '\\0');\n\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/%s\", build_dest_dir(full_path), dir_name) == -1)\n\t\terrExit(\"asprintf\");\n\tif (stat(dest, &s) == 0) {\n\t\tfree(dest);\n\t\treturn;\n\t}\n\n\tmkdir_attr(dest, 0755, 0, 0);\n\n\tif (mount(full_path, dest, NULL, MS_BIND|MS_REC, NULL) < 0 ||\n\t\tmount(NULL, dest, NULL, MS_BIND|MS_REMOUNT|MS_NOSUID|MS_NODEV|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"clone\", full_path);\n\tfs_logger2(\"mount\", full_path);\n\tdir_cnt++;\n\tfree(dest);\n}\n",
        "output": "0",
        "index": 89745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HeadlessPrintManager::ReleaseJob(PrintResult result) {\n  if (!callback_) {\n    DLOG(ERROR) << \"ReleaseJob is called when callback_ is null. Check whether \"\n                   \"ReleaseJob is called more than once.\";\n    return;\n  }\n\n  if (result == PRINT_SUCCESS)\n    callback_.Run(result, std::move(data_));\n  else\n    callback_.Run(result, std::string());\n  printing_rfh_->Send(new PrintMsg_PrintingDone(printing_rfh_->GetRoutingID(),\n                                                result == PRINT_SUCCESS));\n  Reset();\n}\n",
        "output": "0",
        "index": 162650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sk_buff *cfg80211_testmode_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t\t  int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);\n\n\tif (WARN_ON(!rdev->testmode_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_testmode_alloc_skb(rdev, approxlen,\n\t\t\t\trdev->testmode_info->snd_pid,\n\t\t\t\trdev->testmode_info->snd_seq,\n\t\t\t\tGFP_KERNEL);\n}\n",
        "output": "0",
        "index": 26655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_video_get_event(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_event __user *up)\n{\n\tstruct video_event kevent;\n\tmm_segment_t old_fs = get_fs();\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sys_ioctl(fd, cmd, (unsigned long) &kevent);\n\tset_fs(old_fs);\n\n\tif (!err) {\n\t\terr  = put_user(kevent.type, &up->type);\n\t\terr |= put_user(kevent.timestamp, &up->timestamp);\n\t\terr |= put_user(kevent.u.size.w, &up->u.size.w);\n\t\terr |= put_user(kevent.u.size.h, &up->u.size.h);\n\t\terr |= put_user(kevent.u.size.aspect_ratio,\n\t\t\t\t&up->u.size.aspect_ratio);\n\t\tif (err)\n\t\t\terr = -EFAULT;\n\t}\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 32818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   virtual ~ExtensionTtsPlatformImplWin() {}\n",
        "output": "0",
        "index": 104554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 SlidingWindowRefPicMarking(dpbStorage_t *dpb)\n{\n\n/* Variables */\n\n    i32 index, picNum;\n    u32 i;\n\n/* Code */\n\n if (dpb->numRefFrames < dpb->maxRefFrames)\n {\n return(HANTRO_OK);\n }\n else\n {\n        index = -1;\n        picNum = 0;\n /* find the oldest short term picture */\n for (i = 0; i < dpb->numRefFrames; i++)\n if (IS_SHORT_TERM(dpb->buffer[i]))\n if (dpb->buffer[i].picNum < picNum || index == -1)\n {\n                    index = (i32)i;\n                    picNum = dpb->buffer[i].picNum;\n }\n if (index >= 0)\n {\n            SET_UNUSED(dpb->buffer[index]);\n            dpb->numRefFrames--;\n if (!dpb->buffer[index].toBeDisplayed)\n                dpb->fullness--;\n\n return(HANTRO_OK);\n }\n }\n\n return(HANTRO_NOK);\n\n}\n",
        "output": "0",
        "index": 172752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeDownloadManagerDelegate::OnItemAddedToPersistentStore(\n    int32 download_id, int64 db_handle) {\n  if (db_handle == DownloadItem::kUninitializedHandle)\n    db_handle = download_history_->GetNextFakeDbHandle();\n  download_manager_->OnItemAddedToPersistentStore(download_id, db_handle);\n}\n",
        "output": "0",
        "index": 112960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lxcfs_release(const char *path, struct fuse_file_info *fi)\n{\n\tif (strncmp(path, \"/cgroup\", 7) == 0)\n\t\treturn cg_release(path, fi);\n\tif (strncmp(path, \"/proc\", 5) == 0)\n\t\treturn proc_release(path, fi);\n\n\treturn -EINVAL;\n}\n",
        "output": "0",
        "index": 44417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserRenderProcessHost::CrossSiteSwapOutACK(\n    const ViewMsg_SwapOut_Params& params) {\n  widget_helper_->CrossSiteSwapOutACK(params);\n}\n",
        "output": "0",
        "index": 103664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"\", *a2 = \"\", *a3 = \"\", *a4 = \"\", *a5 = \"\", *a6 = \"\", *a7 = \"\";\n\tsize_t a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n\tint argc = ZEND_NUM_ARGS();\n\n\tsnmp_object = Z_SNMP_P(object);\n\n\tif (zend_parse_parameters(argc, \"s|ssssss\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7)) {\n\t\t/* Warning message sent already, just bail out */\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n",
        "output": "0",
        "index": 11214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xt_compat_match_offset(const struct xt_match *match)\n{\n\tu_int16_t csize = match->compatsize ? : match->matchsize;\n\treturn XT_ALIGN(match->matchsize) - COMPAT_XT_ALIGN(csize);\n}\n",
        "output": "0",
        "index": 52408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LogoService::LogoService(\n    const base::FilePath& cache_directory,\n    TemplateURLService* template_url_service,\n    std::unique_ptr<image_fetcher::ImageDecoder> image_decoder,\n    scoped_refptr<net::URLRequestContextGetter> request_context_getter,\n    bool use_gray_background)\n    : cache_directory_(cache_directory),\n      template_url_service_(template_url_service),\n      request_context_getter_(request_context_getter),\n      use_gray_background_(use_gray_background),\n      image_decoder_(std::move(image_decoder)) {}\n",
        "output": "1",
        "index": 185833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot,\n\t\t\t\t gfn_t gfn)\n{\n\treturn gfn_to_hva_many(slot, gfn, NULL);\n}\n",
        "output": "0",
        "index": 29063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_clear_machine_cred(struct nfs_client *clp)\n{\n\tstruct rpc_cred *cred;\n\n\tspin_lock(&clp->cl_lock);\n\tcred = clp->cl_machine_cred;\n\tclp->cl_machine_cred = NULL;\n\tspin_unlock(&clp->cl_lock);\n\tif (cred != NULL)\n\t\tput_rpccred(cred);\n}\n",
        "output": "0",
        "index": 22926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AutoFillManager::FindCachedForm(const FormData& form,\n                                     FormStructure** form_structure) {\n  *form_structure = NULL;\n  for (std::vector<FormStructure*>::const_iterator iter =\n       form_structures_.begin();\n       iter != form_structures_.end(); ++iter) {\n    if (**iter == form) {\n      *form_structure = *iter;\n      break;\n    }\n  }\n\n  if (!(*form_structure))\n    return false;\n\n  return true;\n}\n",
        "output": "0",
        "index": 107170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImageLoader::~ImageLoader() {}\n",
        "output": "0",
        "index": 139039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPAPITestBase::SetUpCommandLine(CommandLine* command_line) {\n  command_line->AppendSwitch(switches::kEnableFileCookies);\n\n  command_line->AppendSwitch(switches::kEnablePepperTesting);\n\n  command_line->AppendSwitch(switches::kDisableSmoothScrolling);\n}\n",
        "output": "0",
        "index": 114753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeContentBrowserClient::GetURLRequestAutoMountHandlers(\n    std::vector<storage::URLRequestAutoMountHandler>* handlers) {\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->GetURLRequestAutoMountHandlers(handlers);\n}\n",
        "output": "0",
        "index": 155378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *icmpv6_route_lookup(struct net *net,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct sock *sk,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst, *dst2;\n\tstruct flowi6 fl2;\n\tint err;\n\n\terr = ip6_dst_lookup(net, sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/*\n\t * We won't send icmp if the destination is known\n\t * anycast.\n\t */\n\tif (ipv6_anycast_destination(dst, &fl6->daddr)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: acast source\\n\");\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* No need to clone since we're just using its address. */\n\tdst2 = dst;\n\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), sk, 0);\n\tif (!IS_ERR(dst)) {\n\t\tif (dst != dst2)\n\t\t\treturn dst;\n\t} else {\n\t\tif (PTR_ERR(dst) == -EPERM)\n\t\t\tdst = NULL;\n\t\telse\n\t\t\treturn dst;\n\t}\n\n\terr = xfrm_decode_session_reverse(skb, flowi6_to_flowi(&fl2), AF_INET6);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\terr = ip6_dst_lookup(net, sk, &dst2, &fl2);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tdst2 = xfrm_lookup(net, dst2, flowi6_to_flowi(&fl2), sk, XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(dst2)) {\n\t\tdst_release(dst);\n\t\tdst = dst2;\n\t} else {\n\t\terr = PTR_ERR(dst2);\n\t\tif (err == -EPERM) {\n\t\t\tdst_release(dst);\n\t\t\treturn dst2;\n\t\t} else\n\t\t\tgoto relookup_failed;\n\t}\n\nrelookup_failed:\n\tif (dst)\n\t\treturn dst;\n\treturn ERR_PTR(err);\n}\n",
        "output": "0",
        "index": 47687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_fillstate(xfs_da_state_t *state)\n{\n\txfs_da_state_path_t *path;\n\txfs_da_state_blk_t *blk;\n\tint level;\n\n\ttrace_xfs_attr_fillstate(state->args);\n\n\t/*\n\t * Roll down the \"path\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"path\".\n\t */\n\tpath = &state->path;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Roll down the \"altpath\" in the state structure, storing the on-disk\n\t * block number for those buffers in the \"altpath\".\n\t */\n\tpath = &state->altpath;\n\tASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\n\t\tif (blk->bp) {\n\t\t\tblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\n\t\t\tblk->bp = NULL;\n\t\t} else {\n\t\t\tblk->disk_blkno = 0;\n\t\t}\n\t}\n\n\treturn(0);\n}\n",
        "output": "0",
        "index": 44911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Scrollbar::mouseUp()\n{\n    setPressedPart(NoPart);\n    m_pressedPos = 0;\n    stopTimerIfNeeded();\n\n    if (parent() && parent()->isFrameView())\n        static_cast<FrameView*>(parent())->frame()->eventHandler()->setMousePressed(false);\n\n    return true;\n}\n",
        "output": "0",
        "index": 107394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewGuest::Blur() {\n  NOTIMPLEMENTED();\n}\n",
        "output": "0",
        "index": 123359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t ResourceMultiBufferDataProvider::AvailableBytes() const {\n  int64_t bytes = 0;\n  for (const auto i : fifo_) {\n    if (i->end_of_stream())\n      break;\n    bytes += i->data_size();\n  }\n  return bytes;\n}\n",
        "output": "0",
        "index": 157113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int iov_iter_npages(const struct iov_iter *i, int maxpages)\n{\n\tsize_t offset = i->iov_offset;\n\tsize_t size = i->count;\n\tconst struct iovec *iov = i->iov;\n\tint npages = 0;\n\tint n;\n\n\tfor (n = 0; size && n < i->nr_segs; n++, iov++) {\n\t\tunsigned long addr = (unsigned long)iov->iov_base + offset;\n\t\tsize_t len = iov->iov_len - offset;\n\t\toffset = 0;\n\t\tif (unlikely(!len))\t/* empty segment */\n\t\t\tcontinue;\n\t\tif (len > size)\n\t\t\tlen = size;\n\t\tnpages += (addr + len + PAGE_SIZE - 1) / PAGE_SIZE\n\t\t\t  - addr / PAGE_SIZE;\n\t\tif (npages >= maxpages)\t/* don't bother going further */\n\t\t\treturn maxpages;\n\t\tsize -= len;\n\t\toffset = 0;\n\t}\n\treturn min(npages, maxpages);\n}\n",
        "output": "0",
        "index": 44170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gpc_unpc(Pixel *out, const Pixel *in, const Background *back)\n{\n (void)back;\n\n if (in->a <= 128)\n {\n      out->r = out->g = out->b = 255;\n      out->a = 0;\n }\n\n else\n {\n      out->r = sRGB((double)in->r / in->a);\n      out->g = sRGB((double)in->g / in->a);\n      out->b = sRGB((double)in->b / in->a);\n      out->a = u8d(in->a / 257.);\n }\n}\n",
        "output": "0",
        "index": 173096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AXLayoutObject::isVisited() const {\n  return m_layoutObject->style()->isLink() &&\n         m_layoutObject->style()->insideLink() ==\n             EInsideLink::kInsideVisitedLink;\n}\n",
        "output": "0",
        "index": 137964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "grub_disk_dev_iterate (int (*hook) (const char *name, void *closure),\n\t\t       void *closure)\n{\n  grub_disk_dev_t p;\n\n  for (p = grub_disk_dev_list; p; p = p->next)\n    if (p->iterate && (p->iterate) (hook, closure))\n      return 1;\n\n  return 0;\n}\n",
        "output": "0",
        "index": 63714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::ResizeWebWidgetForWidget(\n    const gfx::Size& size,\n    float top_controls_height,\n    float bottom_controls_height,\n    bool browser_controls_shrink_blink_size) {\n  webview()->ResizeWithBrowserControls(size, top_controls_height,\n                                       bottom_controls_height,\n                                       browser_controls_shrink_blink_size);\n}\n",
        "output": "0",
        "index": 157975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const base::FilePath& BrowserPpapiHostImpl::GetProfileDataDirectory() {\n  return profile_data_directory_;\n}\n",
        "output": "0",
        "index": 148238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Smb4KGlobal::addWorkgroup( Smb4KWorkgroup *workgroup )\n{\n  Q_ASSERT( workgroup );\n\n  bool added = false;\n\n  mutex.lock();\n\n  if ( !findWorkgroup( workgroup->workgroupName() ) )\n  {\n    p->workgroupsList.append( workgroup );\n    added = true;\n  }\n  else\n  {\n  }\n\n  mutex.unlock();\n\n  return added;\n}\n",
        "output": "0",
        "index": 6555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_pmu_start_txn(struct pmu *pmu)\n{\n\tperf_pmu_disable(pmu);\n}\n",
        "output": "0",
        "index": 26151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RenderBlock::heightForLineCount(int l)\n{\n    int count = 0;\n    return getHeightForLineCount(this, l, true, count);\n}\n",
        "output": "0",
        "index": 124560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gsicc_set_gscs_profile(gs_color_space *pcs, cmm_profile_t *icc_profile,\n                       gs_memory_t * mem)\n{\n    if (pcs == NULL)\n        return -1;\n#if ICC_DUMP\n    if (icc_profile->buffer) {\n        dump_icc_buffer(icc_profile->buffer_size, \"set_gscs\",\n                        icc_profile->buffer);\n        global_icc_index++;\n    }\n#endif\n\n    rc_increment(icc_profile);\n    if (pcs->cmm_icc_profile_data != NULL) {\n        /* There is already a profile set there */\n        /* free it and then set to the new one.  */\n        /* should we check the hash code and retain if the same\n           or place this job on the caller?  */\n        rc_decrement(pcs->cmm_icc_profile_data, \"gsicc_set_gscs_profile\");\n    }\n    pcs->cmm_icc_profile_data = icc_profile;\n    return 0;\n}\n",
        "output": "0",
        "index": 13998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int verify_source_vc(char **ret_path, const char *src_vc) {\n        _cleanup_close_ int fd = -1;\n        char *path;\n        int r;\n\n        fd = open_terminal(src_vc, O_RDWR|O_CLOEXEC|O_NOCTTY);\n        if (fd < 0)\n                return log_error_errno(fd, \"Failed to open %s: %m\", src_vc);\n\n        r = verify_vc_device(fd);\n        if (r < 0)\n                return log_error_errno(r, \"Device %s is not a virtual console: %m\", src_vc);\n\n        r = verify_vc_allocation_byfd(fd);\n         if (r < 0)\n                 return log_error_errno(r, \"Virtual console %s is not allocated: %m\", src_vc);\n \n        r = verify_vc_kbmode(fd);\n         if (r < 0)\n                 return log_error_errno(r, \"Virtual console %s is not in K_XLATE or K_UNICODE: %m\", src_vc);\n \n        path = strdup(src_vc);\n        if (!path)\n                return log_oom();\n\n        *ret_path = path;\n        return TAKE_FD(fd);\n}\n",
        "output": "1",
        "index": 182952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UINT8 btif_hl_get_next_app_id(){\n    UINT8 next_app_id = btif_hl_cb.next_app_id;\n\n    btif_hl_cb.next_app_id++;\n return next_app_id;\n}\n",
        "output": "0",
        "index": 171878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InputType::SetValueAsDouble(double double_value,\n                                 TextFieldEventBehavior event_behavior,\n                                 ExceptionState& exception_state) const {\n  exception_state.ThrowDOMException(\n      kInvalidStateError, \"This input element does not support Number values.\");\n}\n",
        "output": "0",
        "index": 137105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static XMP_Uns32 GatherInt ( const char * strPtr, size_t count )\n{\n\tXMP_Uns32 value = 0;\n\tconst char * strEnd = strPtr + count;\n\n\twhile ( strPtr < strEnd ) {\n\t\tchar ch = *strPtr;\n\t\tif ( (ch < '0') || (ch > '9') ) break;\n\t\tvalue = value*10 + (ch - '0');\n\t\t++strPtr;\n\t}\n\n\treturn value;\n\n}\t// GatherInt\n",
        "output": "0",
        "index": 15952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EventHandler::install()\n{\n\tNameTableIterator next_sig( SigNames );\n\tstruct sigaction action;\n\tint\t\ti;\n\tint\t\tsigno;\n\n\tdprintf( D_FULLDEBUG, \"EventHandler::install() {\\n\" );\n\n\tif( is_installed ) {\n\t\tEXCEPT( \"ERROR EventHandler::install(), already installed\" );\n\t}\n\n\n\tfor( i=0; i<N_POSIX_SIGS; i++ ) {\n\t\tsigno = next_sig();\n\t\tif( sigismember(&mask,signo) ) {\n#if (defined(LINUX) && !defined(GLIBC20) && !defined(GLIBC21)) || defined(AIX) || defined(HPUX11) || defined(CONDOR_FREEBSD) || defined(Darwin) || defined(Solaris)\n\t\t\taction.sa_handler = func;\n#else\n\t\t\taction.sa_handler = (void (*)(...)) func;\n#endif\n\n\t\t\taction.sa_mask = mask;\n\t\t\taction.sa_flags = SA_NOCLDSTOP;\n\t\t\tif( sigaction(signo,&action,&o_action[i]) < 0 ) {\n\t\t\t\tperror( \"sigaction\" );\n\t\t\t\texit( 1 );\n\t\t\t}\n\t\t\tdprintf( D_FULLDEBUG,\n\t\t\t\t\"\\t*FSM* Installed handler %p for signal %s, flags = 0x%x\\n\",\n\t\t\t\taction.sa_handler, SigNames.get_name(signo), action.sa_flags\n\t\t\t);\n\t\t}\n\t}\n\tis_installed = TRUE;\n\n\tdprintf( D_FULLDEBUG, \"}\\n\" );\n}\n",
        "output": "0",
        "index": 16559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HWNDMessageHandler::OnDisplayChange(UINT bits_per_pixel,\n                                         const CSize& screen_size) {\n  delegate_->HandleDisplayChange();\n}\n",
        "output": "0",
        "index": 133113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ModuleSystem::Invalidate() {\n  {\n    v8::HandleScope scope(GetIsolate());\n    v8::Local<v8::Object> global = context()->v8_context()->Global();\n    DeletePrivate(global, kModulesField);\n    DeletePrivate(global, kModuleSystem);\n  }\n\n  for (const auto& handler : native_handler_map_)\n    handler.second->Invalidate();\n  for (const auto& clobbered_handler : clobbered_native_handlers_)\n    clobbered_handler->Invalidate();\n\n  ObjectBackedNativeHandler::Invalidate();\n}\n",
        "output": "0",
        "index": 169502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::dispatchUnloadEvents()\n{\n    PluginScriptForbiddenScope forbidPluginDestructorScripting;\n    if (m_parser)\n        m_parser->stopParsing();\n\n    if (m_loadEventProgress == LoadEventNotRun)\n        return;\n\n    if (m_loadEventProgress <= UnloadEventInProgress) {\n        Element* currentFocusedElement = focusedElement();\n        if (isHTMLInputElement(currentFocusedElement))\n            toHTMLInputElement(*currentFocusedElement).endEditing();\n        if (m_loadEventProgress < PageHideInProgress) {\n            m_loadEventProgress = PageHideInProgress;\n            if (LocalDOMWindow* window = domWindow())\n                window->dispatchEvent(PageTransitionEvent::create(EventTypeNames::pagehide, false), this);\n            if (!m_frame)\n                return;\n\n            PageVisibilityState visibilityState = pageVisibilityState();\n            m_loadEventProgress = UnloadVisibilityChangeInProgress;\n            if (visibilityState != PageVisibilityStateHidden && RuntimeEnabledFeatures::visibilityChangeOnUnloadEnabled()) {\n                dispatchEvent(Event::createBubble(EventTypeNames::visibilitychange));\n                dispatchEvent(Event::createBubble(EventTypeNames::webkitvisibilitychange));\n            }\n            if (!m_frame)\n                return;\n\n            DocumentLoader* documentLoader = m_frame->loader().provisionalDocumentLoader();\n            m_loadEventProgress = UnloadEventInProgress;\n            Event* unloadEvent(Event::create(EventTypeNames::unload));\n            if (documentLoader && !documentLoader->timing().unloadEventStart() && !documentLoader->timing().unloadEventEnd()) {\n                DocumentLoadTiming& timing = documentLoader->timing();\n                DCHECK(timing.navigationStart());\n                timing.markUnloadEventStart();\n                m_frame->localDOMWindow()->dispatchEvent(unloadEvent, this);\n                timing.markUnloadEventEnd();\n            } else {\n                m_frame->localDOMWindow()->dispatchEvent(unloadEvent, m_frame->document());\n            }\n        }\n        m_loadEventProgress = UnloadEventHandled;\n    }\n\n    if (!m_frame)\n        return;\n\n    bool keepEventListeners = m_frame->loader().provisionalDocumentLoader()\n        && m_frame->shouldReuseDefaultView(m_frame->loader().provisionalDocumentLoader()->url());\n    if (!keepEventListeners)\n        removeAllEventListenersRecursively();\n}\n",
        "output": "0",
        "index": 143177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameSelection::LayoutBlockWillBeDestroyed(const LayoutBlock& block) {\n  frame_caret_->LayoutBlockWillBeDestroyed(block);\n}\n",
        "output": "0",
        "index": 135646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void schedule_deferred_open_smb_message(uint16 mid)\n{\n\tstruct pending_message_list *pml;\n\tint i = 0;\n\n\tfor (pml = deferred_open_queue; pml; pml = pml->next) {\n\t\tuint16 msg_mid = SVAL(pml->buf.data,smb_mid);\n\n\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: [%d] msg_mid = %u\\n\", i++,\n\t\t\t(unsigned int)msg_mid ));\n\n\t\tif (mid == msg_mid) {\n\t\t\tstruct timed_event *te;\n\n\t\t\tif (pml->processed) {\n\t\t\t\t/* A processed message should not be\n\t\t\t\t * rescheduled. */\n\t\t\t\tDEBUG(0,(\"schedule_deferred_open_smb_message: LOGIC ERROR \"\n\t\t\t\t\t\"message mid %u was already processed\\n\",\n\t\t\t\t\tmsg_mid ));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: scheduling mid %u\\n\",\n\t\t\t\tmid ));\n\n\t\t\tte = event_add_timed(smbd_event_context(),\n\t\t\t\t\t     pml,\n\t\t\t\t\t     timeval_zero(),\n\t\t\t\t\t     smbd_deferred_open_timer,\n\t\t\t\t\t     pml);\n\t\t\tif (!te) {\n\t\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: \"\n\t\t\t\t\t  \"event_add_timed() failed, skipping mid %u\\n\",\n\t\t\t\t\t  mid ));\n\t\t\t}\n\n\t\t\tTALLOC_FREE(pml->te);\n\t\t\tpml->te = te;\n\t\t\tDLIST_PROMOTE(deferred_open_queue, pml);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDEBUG(10,(\"schedule_deferred_open_smb_message: failed to find message mid %u\\n\",\n\t\tmid ));\n}\n",
        "output": "0",
        "index": 11074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const ChildProcessData& BrowserChildProcessHostImpl::GetData() const {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  return data_;\n}\n",
        "output": "0",
        "index": 162013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual status_t openSession(Vector<uint8_t> &sessionId) {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n\n status_t status = remote()->transact(OPEN_SESSION, data, &reply);\n if (status != OK) {\n return status;\n }\n        readVector(reply, sessionId);\n\n return reply.readInt32();\n }\n",
        "output": "0",
        "index": 174465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(fchmod, unsigned int, fd, umode_t, mode)\n{\n\tstruct fd f = fdget(fd);\n\tint err = -EBADF;\n\n\tif (f.file) {\n\t\taudit_inode(NULL, f.file->f_path.dentry, 0);\n\t\terr = chmod_common(&f.file->f_path, mode);\n\t\tfdput(f);\n\t}\n\treturn err;\n}\n",
        "output": "0",
        "index": 46142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sched_init_numa(void) { }\n",
        "output": "0",
        "index": 55614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::DidInitiatePaint() {\n  pepper_helper_->ViewInitiatedPaint();\n}\n",
        "output": "0",
        "index": 123851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ShelfAlignment Shell::GetShelfAlignment(const aura::Window* root_window) {\n  ShelfWidget* shelf_widget = GetRootWindowController(root_window)->shelf();\n  return shelf_widget->shelf_layout_manager()->GetAlignment();\n}\n",
        "output": "0",
        "index": 139823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unlink_heap_page(mrb_gc *gc, mrb_heap_page *page)\n{\n  if (page->prev)\n    page->prev->next = page->next;\n  if (page->next)\n    page->next->prev = page->prev;\n  if (gc->heaps == page)\n    gc->heaps = page->next;\n  page->prev = NULL;\n  page->next = NULL;\n}\n",
        "output": "0",
        "index": 64464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltWithParamComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemWithParamPtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemWithParamPtr) xsltNewStylePreComp(style, XSLT_FUNC_WITHPARAM);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_WITHPARAM);\n#endif\n\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n\n    /*\n    * Attribute \"name\".\n    */\n    xsltGetQNameProperty(style, inst, BAD_CAST \"name\",\n\t1, &(comp->has_name), &(comp->ns), &(comp->name));\n    if (comp->ns)\n\tcomp->has_ns = 1;\n    /*\n    * Attribute \"select\".\n    */\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select != NULL) {\n\tcomp->comp = xsltXPathCompile(style, comp->select);\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t \"XSLT-with-param: Failed to compile select \"\n\t\t \"expression '%s'\\n\", comp->select);\n\t    style->errors++;\n\t}\n\tif (inst->children != NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-with-param: The content should be empty since \"\n\t\t\"the attribute select is present.\\n\");\n\t    style->warnings++;\n\t}\n    }\n}\n",
        "output": "0",
        "index": 169970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderFrameProxyHost* RenderFrameHostManager::CreateRenderFrameProxyHost(\n    SiteInstance* site_instance,\n    RenderViewHostImpl* rvh) {\n  int site_instance_id = site_instance->GetId();\n  CHECK(proxy_hosts_.find(site_instance_id) == proxy_hosts_.end())\n      << \"A proxy already existed for this SiteInstance.\";\n  RenderFrameProxyHost* proxy_host =\n      new RenderFrameProxyHost(site_instance, rvh, frame_tree_node_);\n  proxy_hosts_[site_instance_id] = base::WrapUnique(proxy_host);\n  static_cast<SiteInstanceImpl*>(site_instance)->AddObserver(this);\n  return proxy_host;\n}\n",
        "output": "0",
        "index": 148870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType WriteFAXImage(const ImageInfo *image_info,Image *image)\n{\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->magick,\"FAX\",MaxTextExtent);\n  scene=0;\n  do\n  {\n    /*\n      Convert MIFF to monochrome.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    status=HuffmanEncodeImage(write_info,image,image);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(status);\n}\n",
        "output": "0",
        "index": 71539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::UpdateActiveState(const HitTestRequest& request,\n                                 Element* inner_element_in_document) {\n  Element* old_active_element = GetActiveElement();\n  if (old_active_element && !request.Active()) {\n    for (Element* element = old_active_element; element;\n         element = FlatTreeTraversal::ParentElement(*element)) {\n      element->SetActive(false);\n      user_action_elements_.SetInActiveChain(element, false);\n    }\n    SetActiveElement(nullptr);\n  } else {\n    Element* new_active_element = inner_element_in_document;\n    if (!old_active_element && new_active_element &&\n        !new_active_element->IsDisabledFormControl() && request.Active() &&\n        !request.TouchMove()) {\n      for (Element* element = new_active_element; element;\n           element = FlatTreeTraversal::ParentElement(*element)) {\n        user_action_elements_.SetInActiveChain(element, true);\n      }\n      SetActiveElement(new_active_element);\n    }\n  }\n\n  bool allow_active_changes = !old_active_element && GetActiveElement();\n  if (!allow_active_changes)\n    return;\n\n  bool must_be_in_active_chain = request.Active() && request.Move();\n\n  Element* new_element =\n      SkipDisplayNoneAncestors(inner_element_in_document);\n\n  for (Element* curr = new_element; curr;\n       curr = FlatTreeTraversal::ParentElement(*curr)) {\n    if (!must_be_in_active_chain || curr->InActiveChain())\n      curr->SetActive(true);\n  }\n}\n",
        "output": "0",
        "index": 146857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "eth_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    struct xlx_ethlite *s = opaque;\n    uint32_t r = 0;\n\n    addr >>= 2;\n\n    switch (addr)\n    {\n        case R_TX_GIE0:\n        case R_TX_LEN0:\n        case R_TX_LEN1:\n        case R_TX_CTRL1:\n        case R_TX_CTRL0:\n        case R_RX_CTRL1:\n        case R_RX_CTRL0:\n            r = s->regs[addr];\n            D(qemu_log(\"%s \" TARGET_FMT_plx \"=%x\\n\", __func__, addr * 4, r));\n            break;\n\n        default:\n            r = tswap32(s->regs[addr]);\n            break;\n    }\n    return r;\n}\n",
        "output": "0",
        "index": 8629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void simple_free_urb(struct urb *urb)\n{\n\tunsigned long offset = buffer_offset(urb->transfer_buffer);\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\tusb_free_coherent(\n\t\t\turb->dev,\n\t\t\turb->transfer_buffer_length + offset,\n\t\t\turb->transfer_buffer - offset,\n\t\t\turb->transfer_dma - offset);\n\telse\n\t\tkfree(urb->transfer_buffer - offset);\n\tusb_free_urb(urb);\n}\n",
        "output": "0",
        "index": 59866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    WebContentsImpl::GetLastCommittedNavigationEntryForRenderManager() {\n  return controller_.GetLastCommittedEntry();\n}\n",
        "output": "0",
        "index": 118895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_str8(AVIOContext *pb, char *buf, int buf_size)\n{\n    get_strl(pb, buf, buf_size, avio_r8(pb));\n}\n",
        "output": "0",
        "index": 61847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JsVar *jsvNewEmptyArray() {\n  return jsvNewWithFlags(JSV_ARRAY);\n}\n",
        "output": "0",
        "index": 82516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int test_mul(BIO *bp)\n\t{\n\tBIGNUM a,b,c,d,e;\n\tint i;\n\tBN_CTX *ctx;\n\n\tctx = BN_CTX_new();\n\tif (ctx == NULL) EXIT(1);\n\t\n\tBN_init(&a);\n\tBN_init(&b);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0+num1; i++)\n\t\t{\n\t\tif (i <= num1)\n\t\t\t{\n\t\t\tBN_bntest_rand(&a,100,0,0);\n\t\t\tBN_bntest_rand(&b,100,0,0);\n\t\t\t}\n\t\telse\n\t\t\tBN_bntest_rand(&b,i-num1,0,0);\n\t\ta.neg=rand_neg();\n\t\tb.neg=rand_neg();\n\t\tBN_mul(&c,&a,&b,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&b);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Multiplication test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&b);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\tBN_CTX_free(ctx);\n\treturn(1);\n\t}\n",
        "output": "0",
        "index": 46519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iperf_get_test_blksize(struct iperf_test *ipt)\n{\n    return ipt->settings->blksize;\n}\n",
        "output": "0",
        "index": 53378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<base::SharedMemory> AllocateSharedMemory(size_t buf_size) {\n  mojo::ScopedSharedBufferHandle mojo_buf =\n      mojo::SharedBufferHandle::Create(buf_size);\n  if (!mojo_buf->is_valid()) {\n    LOG(WARNING) << \"Browser failed to allocate shared memory\";\n    return nullptr;\n  }\n\n  base::SharedMemoryHandle shared_buf;\n  if (mojo::UnwrapSharedMemoryHandle(std::move(mojo_buf), &shared_buf, nullptr,\n                                     nullptr) != MOJO_RESULT_OK) {\n    LOG(WARNING) << \"Browser failed to allocate shared memory\";\n    return nullptr;\n  }\n\n  return std::make_unique<base::SharedMemory>(shared_buf, false);\n}\n",
        "output": "0",
        "index": 161995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_get_cues (SF_PRIVATE * psf, void * data, size_t datasize)\n{\n\tif (psf->cues)\n\t{\tuint32_t cue_count = (datasize - sizeof (uint32_t)) / sizeof (SF_CUE_POINT) ;\n\n\t\tcue_count = SF_MIN (cue_count, psf->cues->cue_count) ;\n\t\tmemcpy (data, psf->cues, SF_CUES_VAR_SIZE (cue_count)) ;\n\t\t((SF_CUES*) data)->cue_count = cue_count ;\n\t\t} ;\n\n\treturn ;\n} /* psf_get_cues */\n",
        "output": "0",
        "index": 95334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void DestroyPersistentMemoryAllocator() {\n    allocator_ = nullptr;\n    GlobalHistogramAllocator::ReleaseForTesting();\n  }\n",
        "output": "0",
        "index": 143818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vmci_transport_is_trusted(struct vsock_sock *vsock, u32 peer_cid)\n{\n\treturn vsock->trusted ||\n\t       vmci_is_context_owner(peer_cid, vsock->owner->uid);\n}\n",
        "output": "0",
        "index": 30384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASCII85Encoder::~ASCII85Encoder() {\n  if (str->isEncoder())\n    delete str;\n}\n",
        "output": "0",
        "index": 4059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "monitor_permit_authentications(int permit)\n{\n\tstruct mon_table *ent = mon_dispatch;\n\n\twhile (ent->f != NULL) {\n\t\tif (ent->flags & MON_AUTH) {\n\t\t\tent->flags &= ~MON_PERMIT;\n\t\t\tent->flags |= permit ? MON_PERMIT : 0;\n\t\t}\n\t\tent++;\n\t}\n}\n",
        "output": "0",
        "index": 42125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t cuse_class_waiting_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct cuse_conn *cc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", atomic_read(&cc->fc.num_waiting));\n}\n",
        "output": "0",
        "index": 58054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport void SetQuantumPack(QuantumInfo *quantum_info,\n  const MagickBooleanType pack)\n{\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n   quantum_info->pack=pack;\n }\n",
        "output": "0",
        "index": 73563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mmtimer_setup_int_2(int cpu, u64 expires)\n{\n\tu64 val;\n\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_ENABLE), 0UL);\n\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPD), -1L);\n\n\tmmtimer_clr_int_pending(2);\n\n\tval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC3_INT_CONFIG_IDX_SHFT) |\n\t\t((u64)cpu_physical_id(cpu) <<\n\t\t\tSH_RTC3_INT_CONFIG_PID_SHFT);\n\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_CONFIG), val);\n\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_ENABLE), 1UL);\n\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPD), expires);\n}\n",
        "output": "0",
        "index": 24658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &read->rd_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &read->rd_offset);\n\tread->rd_length = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}\n",
        "output": "0",
        "index": 65767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}\n",
        "output": "0",
        "index": 65533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __maybe_unused uint64_t h2_get_n64(const struct buffer *b, int o)\n{\n\treturn readv_n64(b_ptr(b, o), b_end(b) - b_ptr(b, o), b->data);\n}\n",
        "output": "0",
        "index": 7766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int send_ttys_to_parent(struct lxc_handler *handler)\n{\n\tstruct lxc_conf *conf = handler->conf;\n\tconst struct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i;\n\tint sock = handler->ttysock[0];\n\n\tfor (i = 0; i < tty_info->nbtty; i++) {\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\t\tif (send_fd(sock, pty_info->slave) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->slave);\n\t\tpty_info->slave = -1;\n\t\tif (send_fd(sock, pty_info->master) < 0)\n\t\t\tgoto bad;\n\t\tclose(pty_info->master);\n\t\tpty_info->master = -1;\n\t}\n\n\tclose(handler->ttysock[0]);\n\tclose(handler->ttysock[1]);\n\n\treturn 0;\n\nbad:\n\tERROR(\"Error writing tty fd to parent\");\n\treturn -1;\n}\n",
        "output": "0",
        "index": 44629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *AllocateMemoryWithTimeout (size_t size, int retryDelay, int timeout)\n{\n\tLARGE_INTEGER waitInterval;\n\twaitInterval.QuadPart = retryDelay * -10000;\n\n\tASSERT (KeGetCurrentIrql() <= APC_LEVEL);\n\tASSERT (retryDelay > 0 && retryDelay <= timeout);\n\n\twhile (TRUE)\n\t{\n\t\tvoid *memory = TCalloc (size);\n\t\tif (memory)\n\t\t\treturn memory;\n\n\t\ttimeout -= retryDelay;\n\t\tif (timeout <= 0)\n\t\t\tbreak;\n\n\t\tKeDelayExecutionThread (KernelMode, FALSE, &waitInterval);\n\t}\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 87165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void encrypt_callback(void *priv, u8 *srcdst, unsigned int nbytes)\n{\n\tconst unsigned int bsize = CAST6_BLOCK_SIZE;\n\tstruct crypt_priv *ctx = priv;\n\tint i;\n\n\tctx->fpu_enabled = cast6_fpu_begin(ctx->fpu_enabled, nbytes);\n\n\tif (nbytes == bsize * CAST6_PARALLEL_BLOCKS) {\n\t\tcast6_ecb_enc_8way(ctx->ctx, srcdst, srcdst);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nbytes / bsize; i++, srcdst += bsize)\n\t\t__cast6_encrypt(ctx->ctx, srcdst, srcdst);\n}\n",
        "output": "0",
        "index": 46914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int validate_table_offset(BlockDriverState *bs, uint64_t offset,\n                                 uint64_t entries, size_t entry_len)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t size;\n\n    /* Use signed INT64_MAX as the maximum even for uint64_t header fields,\n     * because values will be passed to qemu functions taking int64_t. */\n    if (entries > INT64_MAX / entry_len) {\n        return -EINVAL;\n    }\n\n    size = entries * entry_len;\n\n    if (INT64_MAX - size < offset) {\n        return -EINVAL;\n    }\n\n    /* Tables must be cluster aligned */\n    if (offset & (s->cluster_size - 1)) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 16834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void RunTestcases(const Testcase* testcases, size_t num_testcases) {\n    for (size_t i = 0; i < num_testcases; ++i) {\n      LoadAndExpectError(testcases[i].manifest, testcases[i].expected_error);\n    }\n  }\n",
        "output": "0",
        "index": 104676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "layout_show(struct mddev *mddev, char *page)\n{\n\t/* just a number, not meaningful for all levels */\n\tif (mddev->reshape_position != MaxSector &&\n\t    mddev->layout != mddev->new_layout)\n\t\treturn sprintf(page, \"%d (%d)\\n\",\n\t\t\t       mddev->new_layout, mddev->layout);\n\treturn sprintf(page, \"%d\\n\", mddev->layout);\n}\n",
        "output": "0",
        "index": 42400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderPassthroughImpl::VerifyServiceTextureObjectsExist() {\n  resources_->texture_object_map.ForEach(\n      [this](GLuint client_id, scoped_refptr<TexturePassthrough> texture) {\n        DCHECK_EQ(GL_TRUE, api()->glIsTextureFn(texture->service_id()));\n      });\n}\n",
        "output": "0",
        "index": 154538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::string16 ScreenLayoutObserverTest::GetFirstDisplayName() {\n  return base::UTF8ToUTF16(display_manager()->GetDisplayNameForId(\n      display_manager()->first_display_id()));\n}\n",
        "output": "0",
        "index": 140692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ACodec::IdleToLoadedState::stateEntered() {\n    ALOGV(\"[%s] Now Idle->Loaded\", mCodec->mComponentName.c_str());\n}\n",
        "output": "0",
        "index": 177340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Splash::setTransfer(Guchar *red, Guchar *green, Guchar *blue,\n\t\t\t Guchar *gray) {\n  state->setTransfer(red, green, blue, gray);\n}\n",
        "output": "0",
        "index": 4148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLboolean StubGLUnmapBuffer(GLenum target) {\n  return glUnmapBuffer(target);\n}\n",
        "output": "0",
        "index": 104493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t nr_hugepages_mempolicy_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn nr_hugepages_show_common(kobj, attr, buf);\n}\n",
        "output": "0",
        "index": 19735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void VoidMethodTestInterfaceEmptyOrNullArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"voidMethodTestInterfaceEmptyOrNullArg\", \"TestObject\", ExceptionMessages::NotEnoughArguments(1, info.Length())));\n    return;\n  }\n\n  TestInterfaceEmpty* nullable_test_interface_empty_arg;\n  nullable_test_interface_empty_arg = V8TestInterfaceEmpty::ToImplWithTypeCheck(info.GetIsolate(), info[0]);\n  if (!nullable_test_interface_empty_arg && !IsUndefinedOrNull(info[0])) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"voidMethodTestInterfaceEmptyOrNullArg\", \"TestObject\", ExceptionMessages::ArgumentNotOfType(0, \"TestInterfaceEmpty\")));\n    return;\n  }\n\n  impl->voidMethodTestInterfaceEmptyOrNullArg(nullable_test_interface_empty_arg);\n}\n",
        "output": "0",
        "index": 148175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainMigratePerform3(virDomainPtr domain,\n                         const char *xmlin,\n                         const char *cookiein,\n                         int cookieinlen,\n                         char **cookieout,\n                         int *cookieoutlen,\n                         const char *dconnuri,\n                         const char *uri,\n                         unsigned long flags,\n                         const char *dname,\n                         unsigned long bandwidth)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"xmlin=%s cookiein=%p, cookieinlen=%d, \"\n                     \"cookieout=%p, cookieoutlen=%p, dconnuri=%s, \"\n                     \"uri=%s, flags=%lx, dname=%s, bandwidth=%lu\",\n                     NULLSTR(xmlin), cookiein, cookieinlen,\n                     cookieout, cookieoutlen, NULLSTR(dconnuri),\n                     NULLSTR(uri), flags, NULLSTR(dname), bandwidth);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigratePerform3) {\n        int ret;\n        ret = conn->driver->domainMigratePerform3(domain, xmlin,\n                                                  cookiein, cookieinlen,\n                                                  cookieout, cookieoutlen,\n                                                  dconnuri, uri,\n                                                  flags, dname, bandwidth);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n",
        "output": "0",
        "index": 93863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_proc_access(struct inode *inode, struct nfs_access_entry *entry)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_accessargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.bitmask = server->attr_bitmask,\n\t};\n\tstruct nfs4_accessres res = {\n\t\t.server = server,\n\t\t.fattr = &fattr,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ACCESS],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = entry->cred,\n\t};\n\tint mode = entry->mask;\n\tint status;\n\n\t/*\n\t * Determine which access bits we want to ask for...\n\t */\n\tif (mode & MAY_READ)\n\t\targs.access |= NFS4_ACCESS_READ;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_LOOKUP;\n\t} else {\n\t\tif (mode & MAY_WRITE)\n\t\t\targs.access |= NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND;\n\t\tif (mode & MAY_EXEC)\n\t\t\targs.access |= NFS4_ACCESS_EXECUTE;\n\t}\n\tnfs_fattr_init(&fattr);\n\tstatus = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);\n\tif (!status) {\n\t\tentry->mask = 0;\n\t\tif (res.access & NFS4_ACCESS_READ)\n\t\t\tentry->mask |= MAY_READ;\n\t\tif (res.access & (NFS4_ACCESS_MODIFY | NFS4_ACCESS_EXTEND | NFS4_ACCESS_DELETE))\n\t\t\tentry->mask |= MAY_WRITE;\n\t\tif (res.access & (NFS4_ACCESS_LOOKUP|NFS4_ACCESS_EXECUTE))\n\t\t\tentry->mask |= MAY_EXEC;\n\t\tnfs_refresh_inode(inode, &fattr);\n\t}\n\treturn status;\n}\n",
        "output": "0",
        "index": 22839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2Implementation::DeleteSamplersHelper(GLsizei n,\n                                               const GLuint* samplers) {\n  if (!GetIdHandler(SharedIdNamespaces::kSamplers)\n           ->FreeIds(this, n, samplers,\n                     &GLES2Implementation::DeleteSamplersStub)) {\n    SetGLError(GL_INVALID_VALUE, \"glDeleteSamplers\",\n               \"id not created by this context.\");\n    return;\n  }\n}\n",
        "output": "0",
        "index": 153615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int macvlan_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\t/* Just copy in the new address */\n\t\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\t} else {\n\t\t/* Rehash and update the device filters */\n\t\tif (macvlan_addr_busy(vlan->port, addr->sa_data))\n\t\t\treturn -EBUSY;\n\n\t\terr = dev_uc_add(lowerdev, addr->sa_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdev_uc_del(lowerdev, dev->dev_addr);\n\n\t\tmacvlan_hash_change_addr(vlan, addr->sa_data);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 23824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Editor::writeSelectionToPasteboard() {\n  KURL url = frame().document()->url();\n  String html = frame().selection().selectedHTMLForClipboard();\n  String plainText = frame().selectedTextForClipboard();\n  Pasteboard::generalPasteboard()->writeHTML(html, url, plainText,\n                                             canSmartCopyOrDelete());\n}\n",
        "output": "0",
        "index": 140380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool HasLoadListener(Element* element) {\n  if (element->HasEventListeners(event_type_names::kLoad))\n    return true;\n\n  for (element = element->ParentOrShadowHostElement(); element;\n       element = element->ParentOrShadowHostElement()) {\n    EventListenerVector* entry =\n        element->GetEventListeners(event_type_names::kLoad);\n    if (!entry)\n      continue;\n    for (wtf_size_t i = 0; i < entry->size(); ++i) {\n      if (entry->at(i).Capture())\n        return true;\n    }\n  }\n\n  return false;\n}\n",
        "output": "0",
        "index": 165792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BytesConsumer::Error ReadableStreamBytesConsumer::GetError() const {\n  return Error(\"Failed to read from a ReadableStream.\");\n}\n",
        "output": "0",
        "index": 168509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TouchpadLibrary* CrosLibrary::GetTouchpadLibrary() {\n  return touchpad_lib_.GetDefaultImpl(use_stub_impl_);\n}\n",
        "output": "1",
        "index": 184101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::SetImportance(ChildProcessImportance importance) {\n  if (importance_ == importance)\n    return;\n  importance_ = importance;\n  process_->UpdateClientPriority(this);\n}\n",
        "output": "0",
        "index": 158362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void markForFullLayout() { m_isFullLayout = true; }\n",
        "output": "0",
        "index": 119635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BookmarkManagerView::~BookmarkManagerView() {\n  if (select_file_dialog_.get())\n    select_file_dialog_->ListenerDestroyed();\n\n  if (!GetBookmarkModel()->IsLoaded()) {\n    GetBookmarkModel()->RemoveObserver(this);\n  } else {\n    table_view_->SetModel(NULL);\n    tree_view_->SetModel(NULL);\n  }\n  manager = NULL;\n  open_window = NULL;\n}\n",
        "output": "0",
        "index": 117386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BlinkTestRunner::CloseRemainingWindows() {\n  NavigateAwayVisitor visitor(render_view());\n  RenderView::ForEach(&visitor);\n  Send(new ShellViewHostMsg_CloseRemainingWindows(routing_id()));\n}\n",
        "output": "0",
        "index": 132631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(shutdown, int, fd, int, how)\n{\n\treturn __sys_shutdown(fd, how);\n}\n",
        "output": "0",
        "index": 82214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Bool revert_cache_file(void *cbck, char *item_name, char *item_path, GF_FileEnumInfo *file_info)\n{\n\tconst char *url;\n\tchar *sep;\n\tGF_Config *cached;\n\tif (strncmp(item_name, \"gpac_cache_\", 11)) return GF_FALSE;\n\tcached = gf_cfg_new(NULL, item_path);\n\turl = gf_cfg_get_key(cached, \"cache\", \"url\");\n\tif (url) url = strstr(url, \"://\");\n\tif (url) {\n\t\tu32 i, len, dir_len=0, k=0;\n\t\tchar *dst_name;\n\t\tsep = strstr(item_path, \"gpac_cache_\");\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\tdir_len = (u32) strlen(item_path);\n\t\t\tsep[0] = 'g';\n\t\t}\n\t\turl+=3;\n\t\tlen = (u32) strlen(url);\n\t\tdst_name = gf_malloc(len+dir_len+1);\n\t\tmemset(dst_name, 0, len+dir_len+1);\n\n\t\tstrncpy(dst_name, item_path, dir_len);\n\t\tk=dir_len;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tdst_name[k] = url[i];\n\t\t\tif (dst_name[k]==':') dst_name[k]='_';\n\t\t\telse if (dst_name[k]=='/') {\n\t\t\t\tif (!gf_dir_exists(dst_name))\n\t\t\t\t\tgf_mkdir(dst_name);\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\tsep = strrchr(item_path, '.');\n\t\tif (sep) {\n\t\t\tsep[0]=0;\n\t\t\tif (gf_file_exists(item_path)) {\n\t\t\t\tgf_move_file(item_path, dst_name);\n\t\t\t}\n\t\t\tsep[0]='.';\n\t\t}\n\t\tgf_free(dst_name);\n\t}\n\tgf_cfg_del(cached);\n\tgf_delete_file(item_path);\n\treturn GF_FALSE;\n}\n",
        "output": "0",
        "index": 92827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofproto_delete(const char *name, const char *type)\n{\n    const struct ofproto_class *class = ofproto_class_find__(type);\n    return (!class ? EAFNOSUPPORT\n            : !class->del ? EACCES\n            : class->del(type, name));\n}\n",
        "output": "0",
        "index": 77303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_handle_receipt_received(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *receipt = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_RECEIPTS);\n    const char *name = xmpp_stanza_get_name(receipt);\n    if (g_strcmp0(name, \"received\") != 0) {\n        return;\n    }\n\n    const char *id = xmpp_stanza_get_id(receipt);\n    if (!id) {\n        return;\n    }\n\n    const char *fulljid = xmpp_stanza_get_from(stanza);\n    if (!fulljid) {\n        return;\n    }\n\n    Jid *jidp = jid_create(fulljid);\n    sv_ev_message_receipt(jidp->barejid, id);\n    jid_destroy(jidp);\n}\n",
        "output": "0",
        "index": 68660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool GetCoverMode(const Cmd& cmd, GLenum* out_cover_mode) {\n    GLenum cover_mode = static_cast<GLuint>(cmd.coverMode);\n    if (!validators_->path_instanced_cover_mode.IsValid(cover_mode)) {\n      ERRORSTATE_SET_GL_ERROR_INVALID_ENUM(error_state_, function_name_,\n                                           cover_mode, \"coverMode\");\n      return false;\n    }\n    *out_cover_mode = cover_mode;\n    return true;\n  }\n",
        "output": "0",
        "index": 154156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestController::setMockGeolocationPositionUnavailableError(WKStringRef errorMessage)\n{\n    m_geolocationProvider->setPositionUnavailableError(errorMessage);\n}\n",
        "output": "0",
        "index": 115542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserOpenedWithExistingProfileNotificationObserver::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  if (!automation_) {\n    delete this;\n    return;\n  }\n\n  if (type == chrome::NOTIFICATION_BROWSER_OPENED) {\n    new_window_id_ = ExtensionTabUtil::GetWindowId(\n        content::Source<Browser>(source).ptr());\n  } else if (type == content::NOTIFICATION_LOAD_STOP) {\n    NavigationController* controller =\n        content::Source<NavigationController>(source).ptr();\n    SessionTabHelper* session_tab_helper =\n        SessionTabHelper::FromWebContents(controller->GetWebContents());\n    int window_id = session_tab_helper ? session_tab_helper->window_id().id()\n                                       : -1;\n    if (window_id == new_window_id_ && --num_loads_ == 0) {\n      if (automation_) {\n        AutomationJSONReply(automation_, reply_message_.release())\n            .SendSuccess(NULL);\n      }\n      delete this;\n    }\n  } else {\n    NOTREACHED();\n  }\n}\n",
        "output": "0",
        "index": 126009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScriptPromise ImageCapture::getPhotoSettings(ScriptState* script_state) {\n  ScriptPromiseResolver* resolver = ScriptPromiseResolver::Create(script_state);\n  ScriptPromise promise = resolver->Promise();\n\n  if (!service_) {\n    resolver->Reject(DOMException::Create(kNotFoundError, kNoServiceError));\n    return promise;\n  }\n  service_requests_.insert(resolver);\n\n  auto resolver_cb =\n      WTF::Bind(&ImageCapture::ResolveWithPhotoSettings, WrapPersistent(this));\n\n  service_->GetPhotoState(\n      stream_track_->Component()->Source()->Id(),\n      ConvertToBaseCallback(WTF::Bind(\n          &ImageCapture::OnMojoGetPhotoState, WrapPersistent(this),\n          WrapPersistent(resolver), WTF::Passed(std::move(resolver_cb)),\n          false /* trigger_take_photo */)));\n  return promise;\n}\n",
        "output": "0",
        "index": 163916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataFileSystem::GetEntryInfoByResourceIdOnUIThread(\n    const std::string& resource_id,\n    const GetEntryInfoWithFilePathCallback& callback) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  directory_service_->GetEntryByResourceIdAsync(resource_id,\n      base::Bind(&GDataFileSystem::GetEntryInfoByEntryOnUIThread,\n                 ui_weak_ptr_,\n                 callback));\n}\n",
        "output": "0",
        "index": 125366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ux500_cryp_remove(struct platform_device *pdev)\n{\n\tstruct resource *res = NULL;\n\tstruct resource *res_irq = NULL;\n\tstruct cryp_device_data *device_data;\n\n\tdev_dbg(&pdev->dev, \"[%s]\", __func__);\n\tdevice_data = platform_get_drvdata(pdev);\n\tif (!device_data) {\n\t\tdev_err(&pdev->dev, \"[%s]: platform_get_drvdata() failed!\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Try to decrease the number of available devices. */\n\tif (down_trylock(&driver_data.device_allocation))\n\t\treturn -EBUSY;\n\n\t/* Check that the device is free */\n\tspin_lock(&device_data->ctx_lock);\n\t/* current_ctx allocates a device, NULL = unallocated */\n\tif (device_data->current_ctx) {\n\t\t/* The device is busy */\n\t\tspin_unlock(&device_data->ctx_lock);\n\t\t/* Return the device to the pool. */\n\t\tup(&driver_data.device_allocation);\n\t\treturn -EBUSY;\n\t}\n\n\tspin_unlock(&device_data->ctx_lock);\n\n\t/* Remove the device from the list */\n\tif (klist_node_attached(&device_data->list_node))\n\t\tklist_remove(&device_data->list_node);\n\n\t/* If this was the last device, remove the services */\n\tif (list_empty(&driver_data.device_list.k_list))\n\t\tcryp_algs_unregister_all();\n\n\tres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!res_irq)\n\t\tdev_err(&pdev->dev, \"[%s]: IORESOURCE_IRQ, unavailable\",\n\t\t\t__func__);\n\telse {\n\t\tdisable_irq(res_irq->start);\n\t\tfree_irq(res_irq->start, device_data);\n\t}\n\n\tif (cryp_disable_power(&pdev->dev, device_data, false))\n\t\tdev_err(&pdev->dev, \"[%s]: cryp_disable_power() failed\",\n\t\t\t__func__);\n\n\tclk_unprepare(device_data->clk);\n\tclk_put(device_data->clk);\n\tregulator_put(device_data->pwr_regulator);\n\n\tiounmap(device_data->base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res)\n\t\trelease_mem_region(res->start, resource_size(res));\n\n\tkfree(device_data);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 47514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Element::scheduleSyntheticStyleChange()\n{\n    if (postAttachCallbacksAreSuspended())\n        queuePostAttachCallback(needsSyntheticStyleChangeCallback, this);\n    else\n        setNeedsStyleRecalc(SyntheticStyleChange);\n}\n",
        "output": "0",
        "index": 120616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ahci_start_transfer(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    IDEState *s = &ad->port.ifs[0];\n    uint32_t size = (uint32_t)(s->data_end - s->data_ptr);\n    /* write == ram -> device */\n    uint32_t opts = le32_to_cpu(ad->cur_cmd->opts);\n    int is_write = opts & AHCI_CMD_WRITE;\n    int is_atapi = opts & AHCI_CMD_ATAPI;\n    int has_sglist = 0;\n\n    if (is_atapi && !ad->done_atapi_packet) {\n        /* already prepopulated iobuffer */\n        ad->done_atapi_packet = true;\n        goto out;\n    }\n\n    if (!ahci_populate_sglist(ad, &s->sg, 0)) {\n        has_sglist = 1;\n    }\n\n    DPRINTF(ad->port_no, \"%sing %d bytes on %s w/%s sglist\\n\",\n            is_write ? \"writ\" : \"read\", size, is_atapi ? \"atapi\" : \"ata\",\n            has_sglist ? \"\" : \"o\");\n\n    if (has_sglist && size) {\n        if (is_write) {\n            dma_buf_write(s->data_ptr, size, &s->sg);\n        } else {\n            dma_buf_read(s->data_ptr, size, &s->sg);\n        }\n    }\n\n    /* update number of transferred bytes */\n    ad->cur_cmd->status = cpu_to_le32(le32_to_cpu(ad->cur_cmd->status) + size);\n\nout:\n    /* declare that we processed everything */\n    s->data_ptr = s->data_end;\n\n    if (has_sglist) {\n        qemu_sglist_destroy(&s->sg);\n    }\n\n    s->end_transfer_func(s);\n\n    if (!(s->status & DRQ_STAT)) {\n        /* done with DMA */\n        ahci_trigger_irq(ad->hba, ad, PORT_IRQ_STAT_DSS);\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 15777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserView::SetTranslateIconToggled(bool is_lit) {\n}\n",
        "output": "0",
        "index": 168354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int insert_exceptions(struct pstore *ps,\n\t\t\t     int (*callback)(void *callback_context,\n\t\t\t\t\t     chunk_t old, chunk_t new),\n\t\t\t     void *callback_context,\n\t\t\t     int *full)\n{\n\tint r;\n\tunsigned int i;\n\tstruct core_exception e;\n\n\t/* presume the area is full */\n\t*full = 1;\n\n\tfor (i = 0; i < ps->exceptions_per_area; i++) {\n\t\tread_exception(ps, i, &e);\n\n\t\t/*\n\t\t * If the new_chunk is pointing at the start of\n\t\t * the COW device, where the first metadata area\n\t\t * is we know that we've hit the end of the\n\t\t * exceptions.  Therefore the area is not full.\n\t\t */\n\t\tif (e.new_chunk == 0LL) {\n\t\t\tps->current_committed = i;\n\t\t\t*full = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Keep track of the start of the free chunks.\n\t\t */\n\t\tif (ps->next_free <= e.new_chunk)\n\t\t\tps->next_free = e.new_chunk + 1;\n\n\t\t/*\n\t\t * Otherwise we add the exception to the snapshot.\n\t\t */\n\t\tr = callback(callback_context, e.old_chunk, e.new_chunk);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 29674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gpc_gprq(Pixel *out, const Pixel *in, const Background *back)\n{\n (void)back;\n\n if (in->r == in->g && in->g == in->b)\n      out->r = out->g = out->b = ilineara(in->g, in->a);\n\n else\n      out->r = out->g = out->b = u16d(in->a * 257 *\n YfromRGB(sRGB_to_d[in->r], sRGB_to_d[in->g], sRGB_to_d[in->b]));\n\n   out->a = 65535;\n}\n",
        "output": "0",
        "index": 173085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOLEAN AnalyzeIP6DestinationExtension(\n    PVOID destHdr,\n    ULONG dataLength,\n    IPV6_ADDRESS **homeAddr)\n{\n    while(dataLength != 0)\n    {\n        PIP6_EXT_HDR_OPTION optHdr = (PIP6_EXT_HDR_OPTION) destHdr;\n        ULONG optionLen;\n\n        switch(optHdr->Type)\n        {\n        case IP6_EXT_HDR_OPTION_HOME_ADDR:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            if(optHdr->Length != sizeof(IPV6_ADDRESS))\n                return FALSE;\n\n            *homeAddr = (IPV6_ADDRESS*) RtlOffsetToPointer(optHdr, sizeof(IP6_EXT_HDR_OPTION));\n            break;\n\n        case IP6_EXT_HDR_OPTION_PAD1:\n            optionLen = RTL_SIZEOF_THROUGH_FIELD(IP6_EXT_HDR_OPTION, Type);\n            break;\n\n        default:\n            if(dataLength < sizeof(IP6_EXT_HDR_OPTION))\n                return FALSE;\n\n            optionLen = optHdr->Length + sizeof(IP6_EXT_HDR_OPTION);\n            break;\n        }\n\n        destHdr = RtlOffsetToPointer(destHdr, optionLen);\n        if(dataLength < optionLen)\n            return FALSE;\n\n        dataLength -= optionLen;\n    }\n\n    return TRUE;\n}\n",
        "output": "0",
        "index": 74414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderView* RenderFrameImpl::GetRenderView() {\n  return render_view_;\n}\n",
        "output": "0",
        "index": 152362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionPrefs::SetIdleInstallInfo(const std::string& extension_id,\n                                        const FilePath& crx_path,\n                                        const std::string& version,\n                                        const base::Time& fetch_time) {\n  DictionaryValue* info = new DictionaryValue();\n  info->SetString(kIdleInstallInfoCrxPath, crx_path.value());\n  info->SetString(kIdleInstallInfoVersion, version);\n  info->SetString(kIdleInstallInfoFetchTime,\n                  base::Int64ToString(fetch_time.ToInternalValue()));\n  UpdateExtensionPref(extension_id, kIdleInstallInfo, info);\n}\n",
        "output": "0",
        "index": 102330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_mac_perms_from_lookup(pid_t spid, uid_t uid, const char *perm, const char *name)\n{\n bool allowed;\n char *tctx = NULL;\n\n if (selinux_enabled <= 0) {\n return true;\n }\n\n if (!sehandle) {\n        ALOGE(\"SELinux: Failed to find sehandle. Aborting service_manager.\\n\");\n        abort();\n }\n\n if (selabel_lookup(sehandle, &tctx, name, 0) != 0) {\n        ALOGE(\"SELinux: No match for %s in service_contexts.\\n\", name);\n return false;\n }\n\n    allowed = check_mac_perms(spid, uid, tctx, perm, name);\n    freecon(tctx);\n return allowed;\n}\n",
        "output": "0",
        "index": 171290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stroke_terminate(private_stroke_socket_t *this, stroke_msg_t *msg, FILE *out)\n{\n\tpop_string(msg, &msg->terminate.name);\n\tDBG1(DBG_CFG, \"received stroke: terminate '%s'\", msg->terminate.name);\n\n\tthis->control->terminate(this->control, msg, out);\n}\n",
        "output": "0",
        "index": 12224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPagePrivate::restoreHistoryViewState(Platform::IntSize contentsSize, Platform::IntPoint scrollPosition, double scale, bool shouldReflowBlock)\n{\n    if (!m_mainFrame) {\n        m_backingStore->d->resumeBackingStoreUpdates();\n        m_backingStore->d->resumeScreenUpdates(BackingStore::RenderAndBlit);\n        return;\n    }\n\n    m_mainFrame->view()->setContentsSizeFromHistory(contentsSize);\n\n    bool oldConstrainsScrollingToContentEdge = m_mainFrame->view()->constrainsScrollingToContentEdge();\n    m_mainFrame->view()->setConstrainsScrollingToContentEdge(false);\n    setScrollPosition(scrollPosition);\n    m_mainFrame->view()->setConstrainsScrollingToContentEdge(oldConstrainsScrollingToContentEdge);\n\n    m_shouldReflowBlock = shouldReflowBlock;\n\n    bool didZoom = zoomAboutPoint(scale, m_mainFrame->view()->scrollPosition(), true /* enforceScaleClamping */, true /*forceRendering*/, true /*isRestoringZoomLevel*/);\n    m_backingStore->d->resumeBackingStoreUpdates();\n    m_backingStore->d->resumeScreenUpdates(BackingStore::RenderAndBlit);\n\n    if (!didZoom) {\n        notifyTransformedContentsSizeChanged();\n        notifyTransformedScrollChanged();\n    }\n}\n",
        "output": "0",
        "index": 111311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hv_kvp_deinit(void)\n{\n\tcn_del_callback(&kvp_id);\n\tcancel_delayed_work_sync(&kvp_work);\n\tcancel_work_sync(&kvp_sendkey_work);\n}\n",
        "output": "0",
        "index": 33374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err mvhd_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_MovieHeaderBox *ptr = (GF_MovieHeaderBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tif (ptr->version == 1) {\n\t\tptr->creationTime = gf_bs_read_u64(bs);\n\t\tptr->modificationTime = gf_bs_read_u64(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u64(bs);\n\t} else {\n\t\tptr->creationTime = gf_bs_read_u32(bs);\n\t\tptr->modificationTime = gf_bs_read_u32(bs);\n\t\tptr->timeScale = gf_bs_read_u32(bs);\n\t\tptr->duration = gf_bs_read_u32(bs);\n\t}\n\tif (!ptr->timeScale) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Movie header timescale is invalid (0) - defaulting to 600\\n\" ));\n\t\tptr->timeScale = 600;\n\t}\n\tptr->preferredRate = gf_bs_read_u32(bs);\n\tptr->preferredVolume = gf_bs_read_u16(bs);\n\tgf_bs_read_data(bs, ptr->reserved, 10);\n\tptr->matrixA = gf_bs_read_u32(bs);\n\tptr->matrixB = gf_bs_read_u32(bs);\n\tptr->matrixU = gf_bs_read_u32(bs);\n\tptr->matrixC = gf_bs_read_u32(bs);\n\tptr->matrixD = gf_bs_read_u32(bs);\n\tptr->matrixV = gf_bs_read_u32(bs);\n\tptr->matrixX = gf_bs_read_u32(bs);\n\tptr->matrixY = gf_bs_read_u32(bs);\n\tptr->matrixW = gf_bs_read_u32(bs);\n\tptr->previewTime = gf_bs_read_u32(bs);\n\tptr->previewDuration = gf_bs_read_u32(bs);\n\tptr->posterTime = gf_bs_read_u32(bs);\n\tptr->selectionTime = gf_bs_read_u32(bs);\n\tptr->selectionDuration = gf_bs_read_u32(bs);\n\tptr->currentTime = gf_bs_read_u32(bs);\n\tptr->nextTrackID = gf_bs_read_u32(bs);\n\tptr->original_duration = ptr->duration;\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}\n",
        "output": "1",
        "index": 179455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void SADs(unsigned int *results) {\n    const uint8_t* refs[] = {GetReference(0), GetReference(1),\n                             GetReference(2), GetReference(3)};\n \n    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,\n                                      refs, reference_stride_,\n                                      results));\n   }\n",
        "output": "1",
        "index": 188598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RedLinkInfo *reds_init_client_ssl_connection(int socket)\n{\n    RedLinkInfo *link;\n    int return_code;\n    int ssl_error;\n    BIO *sbio;\n\n    link = reds_init_client_connection(socket);\n    if (link == NULL)\n        goto error;\n\n    if (!(sbio = BIO_new_socket(link->stream->socket, BIO_NOCLOSE))) {\n        spice_warning(\"could not allocate ssl bio socket\");\n        goto error;\n    }\n\n    link->stream->ssl = SSL_new(reds->ctx);\n    if (!link->stream->ssl) {\n        spice_warning(\"could not allocate ssl context\");\n        BIO_free(sbio);\n        goto error;\n    }\n\n    SSL_set_bio(link->stream->ssl, sbio, sbio);\n\n    link->stream->write = stream_ssl_write_cb;\n    link->stream->read = stream_ssl_read_cb;\n    link->stream->writev = NULL;\n\n    return_code = SSL_accept(link->stream->ssl);\n    if (return_code == 1) {\n        reds_handle_new_link(link);\n        return link;\n    }\n\n    ssl_error = SSL_get_error(link->stream->ssl, return_code);\n    if (return_code == -1 && (ssl_error == SSL_ERROR_WANT_READ ||\n                              ssl_error == SSL_ERROR_WANT_WRITE)) {\n        int eventmask = ssl_error == SSL_ERROR_WANT_READ ?\n            SPICE_WATCH_EVENT_READ : SPICE_WATCH_EVENT_WRITE;\n        link->stream->watch = core->watch_add(link->stream->socket, eventmask,\n                                            reds_handle_ssl_accept, link);\n        return link;\n    }\n\n    ERR_print_errors_fp(stderr);\n    spice_warning(\"SSL_accept failed, error=%d\", ssl_error);\n    SSL_free(link->stream->ssl);\n\nerror:\n    free(link->stream);\n    BN_free(link->tiTicketing.bn);\n    free(link);\n    return NULL;\n}\n",
        "output": "0",
        "index": 1889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IndexedDBTransaction::IndexedDBTransaction(\n    int64_t id,\n    IndexedDBConnection* connection,\n    const std::set<int64_t>& object_store_ids,\n    blink::WebIDBTransactionMode mode,\n    IndexedDBBackingStore::Transaction* backing_store_transaction)\n     : id_(id),\n       object_store_ids_(object_store_ids),\n       mode_(mode),\n      connection_(connection),\n       transaction_(backing_store_transaction),\n       ptr_factory_(this) {\n   IDB_ASYNC_TRACE_BEGIN(\"IndexedDBTransaction::lifetime\", this);\n  callbacks_ = connection_->callbacks();\n  database_ = connection_->database();\n\n  diagnostics_.tasks_scheduled = 0;\n  diagnostics_.tasks_completed = 0;\n  diagnostics_.creation_time = base::Time::Now();\n}\n",
        "output": "1",
        "index": 187242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}\n",
        "output": "0",
        "index": 37721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltStyleStylesheetLevelGetExtData(xsltStylesheetPtr style,\n\t\t\t\t   const xmlChar * URI)\n{\n    xsltExtDataPtr dataContainer = NULL;\n\n    if ((style == NULL) || (URI == NULL) ||\n\t(xsltExtensionsHash == NULL))\n\treturn (NULL);\n\n    if (style->extInfos != NULL) {\n\tdataContainer = (xsltExtDataPtr) xmlHashLookup(style->extInfos, URI);\n\t/*\n\t* The module was already initialized in the context\n\t* of this stylesheet; just return the user-data that\n\t* comes with it.\n\t*/\n\tif (dataContainer)\n\t    return(dataContainer->extData);\n    }\n\n    dataContainer =\n        xsltStyleInitializeStylesheetModule(style, URI);\n    if (dataContainer != NULL)\n\treturn (dataContainer->extData);\n    return(NULL);\n}\n",
        "output": "0",
        "index": 169889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jv_parser_set_buf(struct jv_parser* p, const char* buf, int length, int is_partial) {\n  assert((p->curr_buf == 0 || p->curr_buf_pos == p->curr_buf_length)\n         && \"previous buffer not exhausted\");\n  while (length > 0 && p->bom_strip_position < sizeof(UTF8_BOM)) {\n    if ((unsigned char)*buf == UTF8_BOM[p->bom_strip_position]) {\n      buf++;\n      length--;\n      p->bom_strip_position++;\n    } else {\n      if (p->bom_strip_position == 0) {\n        p->bom_strip_position = sizeof(UTF8_BOM);\n      } else {\n        p->bom_strip_position = 0xff;\n      }\n    }\n  }\n  p->curr_buf = buf;\n  p->curr_buf_length = length;\n  p->curr_buf_pos = 0;\n  p->curr_buf_is_partial = is_partial;\n}\n",
        "output": "0",
        "index": 56388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "midi_synth_controller(int dev, int channel, int ctrl_num, int value)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tint             chn, msg;\n\n\tif (ctrl_num < 0 || ctrl_num > 127)\n\t\treturn;\n\tif (channel < 0 || channel > 15)\n\t\treturn;\n\n\tleave_sysex(dev);\n\n\tmsg = prev_out_status[orig_dev] & 0xf0;\n\tchn = prev_out_status[orig_dev] & 0x0f;\n\n\tif (msg != 0xb0 || chn != channel)\n\t  {\n\t\t  if (!prefix_cmd(orig_dev, 0xb0 | (channel & 0x0f)))\n\t\t\t  return;\n\t\t  midi_outc(orig_dev, 0xb0 | (channel & 0x0f));\n\t} else if (!prefix_cmd(orig_dev, ctrl_num))\n\t\treturn;\n\n\tmidi_outc(orig_dev, ctrl_num);\n\tmidi_outc(orig_dev, value & 0x7f);\n}\n",
        "output": "0",
        "index": 27582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool is_number(const std::string& s)\n{\n\tstd::string::const_iterator it = s.begin();\n\twhile (it != s.end() && (isdigit(*it) || (*it == '.') || (*it == '-') || (*it == ' ') || (*it == 0x00))) ++it;\n\treturn !s.empty() && it == s.end();\n}\n",
        "output": "0",
        "index": 90942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_proc_async_renew(struct nfs_client *clp, struct rpc_cred *cred, unsigned renew_flags)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_RENEW],\n\t\t.rpc_argp\t= clp,\n\t\t.rpc_cred\t= cred,\n\t};\n\tstruct nfs4_renewdata *data;\n\n\tif (renew_flags == 0)\n\t\treturn 0;\n\tif (!atomic_inc_not_zero(&clp->cl_count))\n\t\treturn -EIO;\n\tdata = kmalloc(sizeof(*data), GFP_NOFS);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\tdata->client = clp;\n\tdata->timestamp = jiffies;\n\treturn rpc_call_async(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT,\n\t\t\t&nfs4_renew_ops, data);\n}\n",
        "output": "0",
        "index": 57180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Rect BrowserView::GetRestoredBounds() const {\n  return frame_->GetRestoredBounds();\n}\n",
        "output": "0",
        "index": 126780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::UpdateEncoding(const std::string& encoding_name) {\n  delegate_->UpdateEncoding(this, encoding_name);\n}\n",
        "output": "0",
        "index": 152105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline MagickBooleanType IsPoint(const char *point)\n{\n  char\n    *p;\n\n  double\n    value;\n\n  value=StringToDouble(point,&p);\n  return((value == 0.0) && (p == point) ? MagickFalse : MagickTrue);\n}\n",
        "output": "0",
        "index": 53013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MediaControlOverlayPlayButtonElement::create(MediaControls& mediaControls) {\n  MediaControlOverlayPlayButtonElement* button =\n      new MediaControlOverlayPlayButtonElement(mediaControls);\n  button->ensureUserAgentShadowRoot();\n  button->setType(InputTypeNames::button);\n  button->setShadowPseudoId(\n      AtomicString(\"-webkit-media-controls-overlay-play-button\"));\n  return button;\n}\n",
        "output": "0",
        "index": 137833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mon_st_callback(stonith_t *st, stonith_event_t *e)\n{\n    char *desc = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); \n\n    if (snmp_target) {\n        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (crm_mail_to) {\n        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (external_agent) {\n        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    g_free(desc);\n}\n",
        "output": "0",
        "index": 33943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iscsi_co_generic_cb(struct iscsi_context *iscsi, int status,\n                        void *command_data, void *opaque)\n{\n    struct IscsiTask *iTask = opaque;\n    struct scsi_task *task = command_data;\n\n    iTask->status = status;\n    iTask->do_retry = 0;\n    iTask->task = task;\n\n    if (status != SCSI_STATUS_GOOD) {\n        if (iTask->retries++ < ISCSI_CMD_RETRIES) {\n            if (status == SCSI_STATUS_CHECK_CONDITION\n                && task->sense.key == SCSI_SENSE_UNIT_ATTENTION) {\n                error_report(\"iSCSI CheckCondition: %s\",\n                             iscsi_get_error(iscsi));\n                iTask->do_retry = 1;\n                goto out;\n            }\n            if (status == SCSI_STATUS_BUSY ||\n                status == SCSI_STATUS_TIMEOUT ||\n                status == SCSI_STATUS_TASK_SET_FULL) {\n                unsigned retry_time =\n                    exp_random(iscsi_retry_times[iTask->retries - 1]);\n                if (status == SCSI_STATUS_TIMEOUT) {\n                    /* make sure the request is rescheduled AFTER the\n                     * reconnect is initiated */\n                    retry_time = EVENT_INTERVAL * 2;\n                    iTask->iscsilun->request_timed_out = true;\n                }\n                error_report(\"iSCSI Busy/TaskSetFull/TimeOut\"\n                             \" (retry #%u in %u ms): %s\",\n                             iTask->retries, retry_time,\n                             iscsi_get_error(iscsi));\n                aio_timer_init(iTask->iscsilun->aio_context,\n                               &iTask->retry_timer, QEMU_CLOCK_REALTIME,\n                               SCALE_MS, iscsi_retry_timer_expired, iTask);\n                timer_mod(&iTask->retry_timer,\n                          qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + retry_time);\n                iTask->do_retry = 1;\n                return;\n            }\n        }\n        iTask->err_code = iscsi_translate_sense(&task->sense);\n        error_report(\"iSCSI Failure: %s\", iscsi_get_error(iscsi));\n    }\n\nout:\n    if (iTask->co) {\n        iTask->bh = aio_bh_new(iTask->iscsilun->aio_context,\n                               iscsi_co_generic_bh_cb, iTask);\n        qemu_bh_schedule(iTask->bh);\n    } else {\n        iTask->complete = 1;\n    }\n}\n",
        "output": "0",
        "index": 10504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "float ComputeRedirectConfidence(const predictors::RedirectStat& redirect) {\n  return (redirect.number_of_hits() + 0.0) /\n         (redirect.number_of_hits() + redirect.number_of_misses());\n}\n",
        "output": "0",
        "index": 149618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *npck_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_NPCKBox, GF_ISOM_BOX_TYPE_NPCK);\n\treturn (GF_Box *)tmp;\n}\n",
        "output": "0",
        "index": 80292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Local<v8::Object> RectToV8Object(v8::Isolate* isolate,\n                                     const gfx::Rect& rect) {\n  v8::Local<v8::Object> result(v8::Object::New(isolate));\n  result->Set(CreateV8String(isolate, \"left\"),\n              v8::Integer::New(isolate, rect.x()));\n  result->Set(CreateV8String(isolate, \"top\"),\n              v8::Integer::New(isolate, rect.y()));\n  result->Set(CreateV8String(isolate, \"width\"),\n              v8::Integer::New(isolate, rect.width()));\n  result->Set(CreateV8String(isolate, \"height\"),\n              v8::Integer::New(isolate, rect.height()));\n  return result;\n}\n",
        "output": "0",
        "index": 169541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void computeYMD(DateTime *p){\n  int Z, A, B, C, D, E, X1;\n  if( p->validYMD ) return;\n  if( !p->validJD ){\n    p->Y = 2000;\n    p->M = 1;\n    p->D = 1;\n  }else{\n    assert( validJulianDay(p->iJD) );\n    Z = (int)((p->iJD + 43200000)/86400000);\n    A = (int)((Z - 1867216.25)/36524.25);\n    A = Z + 1 + A - (A/4);\n    B = A + 1524;\n    C = (int)((B - 122.1)/365.25);\n    D = (36525*(C&32767))/100;\n    E = (int)((B-D)/30.6001);\n    X1 = (int)(30.6001*E);\n    p->D = B - D - X1;\n    p->M = E<14 ? E-1 : E-13;\n    p->Y = p->M>2 ? C - 4716 : C - 4715;\n  }\n  p->validYMD = 1;\n}\n",
        "output": "0",
        "index": 149115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebPagePrivate::handleMouseEvent(PlatformMouseEvent& mouseEvent)\n{\n    EventHandler* eventHandler = m_mainFrame->eventHandler();\n\n    if (mouseEvent.type() == WebCore::PlatformEvent::MouseMoved)\n        return eventHandler->mouseMoved(mouseEvent);\n\n    if (mouseEvent.type() == WebCore::PlatformEvent::MouseScroll)\n        return true;\n\n    Node* node = 0;\n    if (mouseEvent.inputMethod() == TouchScreen) {\n        const FatFingersResult lastFatFingersResult = m_touchEventHandler->lastFatFingersResult();\n\n        node = lastFatFingersResult.node(FatFingersResult::ShadowContentNotAllowed);\n    }\n\n    if (!node) {\n        HitTestResult result = eventHandler->hitTestResultAtPoint(mapFromViewportToContents(mouseEvent.position()), false /*allowShadowContent*/);\n        node = result.innerNode();\n    }\n\n    if (mouseEvent.type() == WebCore::PlatformEvent::MousePressed) {\n        m_inputHandler->setInputModeEnabled();\n        if (m_inputHandler->willOpenPopupForNode(node)) {\n\n            ASSERT(node->isElementNode());\n            if (node->isElementNode()) {\n                Element* element = static_cast<Element*>(node);\n                element->focus();\n            }\n        } else\n            eventHandler->handleMousePressEvent(mouseEvent);\n    } else if (mouseEvent.type() == WebCore::PlatformEvent::MouseReleased) {\n        if (!m_inputHandler->didNodeOpenPopup(node))\n            eventHandler->handleMouseReleaseEvent(mouseEvent);\n    }\n\n    return true;\n}\n",
        "output": "0",
        "index": 111171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool isHexadecimal(char ch) {\n    return ((ch>='0') && (ch<='9')) ||\n           ((ch>='a') && (ch<='f')) ||\n           ((ch>='A') && (ch<='F'));\n}\n",
        "output": "0",
        "index": 82607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __choose_pgpath(struct multipath *m, size_t nr_bytes)\n{\n\tstruct priority_group *pg;\n\tunsigned bypassed = 1;\n\n\tif (!m->nr_valid_paths)\n\t\tgoto failed;\n\n\t/* Were we instructed to switch PG? */\n\tif (m->next_pg) {\n\t\tpg = m->next_pg;\n\t\tm->next_pg = NULL;\n\t\tif (!__choose_path_in_pg(m, pg, nr_bytes))\n\t\t\treturn;\n\t}\n\n\t/* Don't change PG until it has no remaining paths */\n\tif (m->current_pg && !__choose_path_in_pg(m, m->current_pg, nr_bytes))\n\t\treturn;\n\n\t/*\n\t * Loop through priority groups until we find a valid path.\n\t * First time we skip PGs marked 'bypassed'.\n\t * Second time we only try the ones we skipped.\n\t */\n\tdo {\n\t\tlist_for_each_entry(pg, &m->priority_groups, list) {\n\t\t\tif (pg->bypassed == bypassed)\n\t\t\t\tcontinue;\n\t\t\tif (!__choose_path_in_pg(m, pg, nr_bytes))\n\t\t\t\treturn;\n\t\t}\n\t} while (bypassed--);\n\nfailed:\n\tm->current_pgpath = NULL;\n\tm->current_pg = NULL;\n}\n",
        "output": "0",
        "index": 23569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void defense_work_handler(struct work_struct *work)\n{\n\tstruct netns_ipvs *ipvs =\n\t\tcontainer_of(work, struct netns_ipvs, defense_work.work);\n\n\tupdate_defense_level(ipvs);\n\tif (atomic_read(&ipvs->dropentry))\n\t\tip_vs_random_dropentry(ipvs->net);\n\tschedule_delayed_work(&ipvs->defense_work, DEFENSE_TIMER_PERIOD);\n}\n",
        "output": "0",
        "index": 34182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RendererSchedulerImpl::MaybeUpdatePolicy() {\n  helper_.CheckOnValidThread();\n  if (policy_may_need_update_.IsSet()) {\n    UpdatePolicy();\n  }\n}\n",
        "output": "0",
        "index": 156220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGLRenderingContextBase::DeleteObject(WebGLObject* object) {\n  if (isContextLost() || !object)\n    return false;\n  if (!object->Validate(ContextGroup(), this)) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"delete\",\n                      \"object does not belong to this context\");\n    return false;\n  }\n  if (object->MarkedForDeletion()) {\n    return false;\n  }\n  if (object->HasObject()) {\n    object->DeleteObject(ContextGL());\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 154926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char** WM_LC_Tokenize_Line(char *line_data) {\n    int line_length = (int) strlen(line_data);\n    int token_data_length = 0;\n    int line_ofs = 0;\n    int token_start = 0;\n    char **token_data = NULL;\n    int token_count = 0;\n\n    if (!line_length) return (NULL);\n\n    do {\n        /* ignore everything after #  */\n        if (line_data[line_ofs] == '#') {\n            break;\n        }\n\n        if ((line_data[line_ofs] == ' ') || (line_data[line_ofs] == '\\t')) {\n            /* whitespace means we aren't in a token */\n            if (token_start) {\n                token_start = 0;\n                line_data[line_ofs] = '\\0';\n            }\n        } else {\n            if (!token_start) {\n                /* the start of a token in the line */\n                token_start = 1;\n                if (token_count >= token_data_length) {\n                    token_data_length += TOKEN_CNT_INC;\n                    token_data = realloc(token_data, token_data_length * sizeof(char *));\n                    if (token_data == NULL) {\n                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM,\"to parse config\", errno);\n                        return (NULL);\n                    }\n                }\n\n                token_data[token_count] = &line_data[line_ofs];\n                token_count++;\n            }\n        }\n        line_ofs++;\n    } while (line_ofs != line_length);\n\n    /* if we have found some tokens then add a null token to the end */\n    if (token_count) {\n        if (token_count >= token_data_length) {\n            token_data = realloc(token_data,\n                ((token_count + 1) * sizeof(char *)));\n        }\n        token_data[token_count] = NULL;\n    }\n\n    return (token_data);\n}\n",
        "output": "0",
        "index": 85097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *memslot,\n\t\t\t\tstruct kvm_memory_slot old,\n\t\t\t\tstruct kvm_userspace_memory_region *mem,\n\t\t\t\tint user_alloc)\n{\n\tint npages = memslot->npages;\n\tint map_flags = MAP_PRIVATE | MAP_ANONYMOUS;\n\n\t/* Prevent internal slot pages from being moved by fork()/COW. */\n\tif (memslot->id >= KVM_MEMORY_SLOTS)\n\t\tmap_flags = MAP_SHARED | MAP_ANONYMOUS;\n\n\t/*To keep backward compatibility with older userspace,\n\t *x86 needs to hanlde !user_alloc case.\n\t */\n\tif (!user_alloc) {\n\t\tif (npages && !old.rmap) {\n\t\t\tunsigned long userspace_addr;\n\n\t\t\tdown_write(&current->mm->mmap_sem);\n\t\t\tuserspace_addr = do_mmap(NULL, 0,\n\t\t\t\t\t\t npages * PAGE_SIZE,\n\t\t\t\t\t\t PROT_READ | PROT_WRITE,\n\t\t\t\t\t\t map_flags,\n\t\t\t\t\t\t 0);\n\t\t\tup_write(&current->mm->mmap_sem);\n\n\t\t\tif (IS_ERR((void *)userspace_addr))\n\t\t\t\treturn PTR_ERR((void *)userspace_addr);\n\n\t\t\tmemslot->userspace_addr = userspace_addr;\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 20727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void withScriptStateVoidExceptionMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectV8Internal::withScriptStateVoidExceptionMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 131148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ChromeContentBrowserClient::WillCreateURLLoaderFactory(\n    content::BrowserContext* browser_context,\n    content::RenderFrameHost* frame,\n    int render_process_id,\n    bool is_navigation,\n    bool is_download,\n    const url::Origin& request_initiator,\n    network::mojom::URLLoaderFactoryRequest* factory_request,\n    network::mojom::TrustedURLLoaderHeaderClientPtrInfo* header_client,\n    bool* bypass_redirect_checks) {\n  DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService));\n  bool use_proxy = false;\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  auto* web_request_api =\n      extensions::BrowserContextKeyedAPIFactory<extensions::WebRequestAPI>::Get(\n          browser_context);\n\n  if (web_request_api) {\n    bool use_proxy_for_web_request =\n        web_request_api->MaybeProxyURLLoaderFactory(\n            browser_context, frame, render_process_id, is_navigation,\n            is_download, factory_request, header_client);\n    if (bypass_redirect_checks)\n      *bypass_redirect_checks = use_proxy_for_web_request;\n    use_proxy |= use_proxy_for_web_request;\n  }\n#endif\n\n  use_proxy |= signin::ProxyingURLLoaderFactory::MaybeProxyRequest(\n      frame, is_navigation, request_initiator, factory_request);\n\n  return use_proxy;\n}\n",
        "output": "0",
        "index": 155467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const AXObject::AXObjectVector& AXObject::children() {\n  updateChildrenIfNecessary();\n\n  return m_children;\n}\n",
        "output": "0",
        "index": 138133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ClearFromBOS()\n{\n  register int y = curr->w_y, x = curr->w_x;\n\n  LClearArea(&curr->w_layer, 0, 0, x, y, CURR_BCE, 1);\n  MClearArea(curr, 0, 0, x, y, CURR_BCE);\n  RestorePosRendition();\n}\n",
        "output": "0",
        "index": 735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CheckConfigsCountForClient(const scoped_refptr<PlatformSensor>& sensor,\n                                PlatformSensor::Client* client,\n                                size_t expected_count) {\n  auto client_entry = sensor->GetConfigMapForTesting().find(client);\n  if (sensor->GetConfigMapForTesting().end() == client_entry) {\n    EXPECT_EQ(0u, expected_count);\n    return;\n  }\n  EXPECT_EQ(expected_count, client_entry->second.size());\n}\n",
        "output": "0",
        "index": 161772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_write_trex_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x20); /* size */\n    ffio_wfourcc(pb, \"trex\");\n    avio_wb32(pb, 0);   /* version & flags */\n    avio_wb32(pb, track->track_id); /* track ID */\n    avio_wb32(pb, 1);   /* default sample description index */\n    avio_wb32(pb, 0);   /* default sample duration */\n    avio_wb32(pb, 0);   /* default sample size */\n    avio_wb32(pb, 0);   /* default sample flags */\n    return 0;\n}\n",
        "output": "0",
        "index": 79427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<HttpNetworkSession> SetupSessionForGroupNameTests(\n    SpdySessionDependencies* session_deps_) {\n  std::unique_ptr<HttpNetworkSession> session(CreateSession(session_deps_));\n\n  HttpServerProperties* http_server_properties =\n      session->http_server_properties();\n  AlternativeService alternative_service(kProtoHTTP2, \"\", 444);\n  base::Time expiration = base::Time::Now() + base::TimeDelta::FromDays(1);\n  http_server_properties->SetHttp2AlternativeService(\n      url::SchemeHostPort(\"https\", \"host.with.alternate\", 443),\n      alternative_service, expiration);\n\n  return session;\n}\n",
        "output": "0",
        "index": 157621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NewTabButton::OnMouseReleased(const ui::MouseEvent& event) {\n  if (event.IsOnlyRightMouseButton()) {\n    gfx::Point point = event.location();\n    views::View::ConvertPointToScreen(this, &point);\n    bool destroyed = false;\n    destroyed_ = &destroyed;\n    gfx::ShowSystemMenuAtPoint(views::HWNDForView(this), point);\n    if (destroyed)\n      return;\n\n    destroyed_ = NULL;\n    SetState(views::CustomButton::STATE_NORMAL);\n    return;\n  }\n  views::ImageButton::OnMouseReleased(event);\n}\n",
        "output": "0",
        "index": 134396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *__d_instantiate_unique(struct dentry *entry,\n\t\t\t\t\t     struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint len = entry->d_name.len;\n\tconst char *name = entry->d_name.name;\n\tunsigned int hash = entry->d_name.hash;\n\n\tif (!inode) {\n\t\t__d_instantiate(entry, NULL);\n\t\treturn NULL;\n\t}\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\t/*\n\t\t * Don't need alias->d_lock here, because aliases with\n\t\t * d_parent == entry->d_parent are not subject to name or\n\t\t * parent changes, because the parent inode i_mutex is held.\n\t\t */\n\t\tif (alias->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (alias->d_parent != entry->d_parent)\n\t\t\tcontinue;\n\t\tif (alias->d_name.len != len)\n\t\t\tcontinue;\n\t\tif (dentry_cmp(alias, name, len))\n\t\t\tcontinue;\n\t\t__dget(alias);\n\t\treturn alias;\n\t}\n\n\t__d_instantiate(entry, inode);\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 94574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AutoFillXmlParser::AutoFillXmlParser()\n    : succeeded_(true) {\n}\n",
        "output": "0",
        "index": 107216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int WebContentsImpl::GetEmbeddedInstanceID() const {\n  BrowserPluginGuest* guest = GetBrowserPluginGuest();\n  if (guest)\n    return guest->instance_id();\n  return 0;\n}\n",
        "output": "0",
        "index": 118889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::ToggleEncodingAutoDetect() {\n  content::RecordAction(UserMetricsAction(\"AutoDetectChange\"));\n  encoding_auto_detect_.SetValue(!encoding_auto_detect_.GetValue());\n  if (encoding_auto_detect_.GetValue()) {\n    WebContents* contents = chrome::GetActiveWebContents(this);\n    if (contents)\n      contents->ResetOverrideEncoding();\n  }\n}\n",
        "output": "0",
        "index": 126249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BaseMultipleFieldsDateAndTimeInputType::didFocusOnControl()\n{\n\n    element()->setFocus(true);\n}\n",
        "output": "0",
        "index": 121087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::captionPreferencesChanged()\n{\n    HashSet<Element*>::iterator end = m_captionPreferencesChangedElements.end();\n    for (HashSet<Element*>::iterator it = m_captionPreferencesChangedElements.begin(); it != end; ++it)\n        (*it)->captionPreferencesChanged();\n}\n",
        "output": "0",
        "index": 112399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_destruct_scm(struct sk_buff *skb)\n{\n\tstruct scm_cookie scm;\n\tmemset(&scm, 0, sizeof(scm));\n\tscm.pid  = UNIXCB(skb).pid;\n\tscm.cred = UNIXCB(skb).cred;\n\tif (UNIXCB(skb).fp)\n\t\tunix_detach_fds(&scm, skb);\n\n\t/* Alas, it calls VFS */\n\t/* So fscking what? fput() had been SMP-safe since the last Summer */\n\tscm_destroy(&scm);\n\tsock_wfree(skb);\n}\n",
        "output": "0",
        "index": 19289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SynchronousCompositorImpl::UpdateRootLayerState(\n    const gfx::ScrollOffset& total_scroll_offset,\n    const gfx::ScrollOffset& max_scroll_offset,\n    const gfx::SizeF& scrollable_size,\n    float page_scale_factor,\n    float min_page_scale_factor,\n    float max_page_scale_factor) {\n  DCHECK(CalledOnValidThread());\n\n  if (registered_with_client_) {\n    compositor_client_->UpdateRootLayerState(\n        gfx::ScrollOffsetToVector2dF(total_scroll_offset),\n        gfx::ScrollOffsetToVector2dF(max_scroll_offset),\n        scrollable_size,\n        page_scale_factor,\n        min_page_scale_factor,\n        max_page_scale_factor);\n  }\n}\n",
        "output": "0",
        "index": 128095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdiodev = bus->mdio_map[addr];\n\n\tif (!mdiodev)\n\t\treturn NULL;\n\n\tif (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))\n\t\treturn NULL;\n\n\treturn container_of(mdiodev, struct phy_device, mdio);\n}\n",
        "output": "0",
        "index": 89644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location,\n                                          GLfloat x,\n                                          GLfloat y,\n                                          GLfloat z,\n                                          GLfloat w) {\n  if (isContextLost() || !location)\n    return;\n\n  if (location->Program() != current_program_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"uniform4f\",\n                      \"location not for current program\");\n    return;\n  }\n\n  ContextGL()->Uniform4f(location->Location(), x, y, z, w);\n}\n",
        "output": "0",
        "index": 146574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void RunCSSTest(const base::FilePath::CharType* file_path) {\n    base::FilePath test_path = GetTestFilePath(\"accessibility\", \"css\");\n    {\n      base::ScopedAllowBlockingForTesting allow_blocking;\n      ASSERT_TRUE(base::PathExists(test_path)) << test_path.LossyDisplayName();\n    }\n    base::FilePath css_file = test_path.Append(base::FilePath(file_path));\n\n    RunTest(css_file, \"accessibility/css\");\n  }\n",
        "output": "0",
        "index": 141607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  sfnt_find_encoding( int  platform_id,\n                      int  encoding_id )\n  {\n    typedef struct  TEncoding_\n    {\n      int          platform_id;\n      int          encoding_id;\n      FT_Encoding  encoding;\n\n    } TEncoding;\n\n    static\n    const TEncoding  tt_encodings[] =\n    {\n      { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },\n\n      { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },\n\n      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },\n\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_SJIS },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_GB2312,     FT_ENCODING_GB2312 },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_BIG5 },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_WANSUNG },\n      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_JOHAB }\n    };\n\n    const TEncoding  *cur, *limit;\n\n\n    cur   = tt_encodings;\n    limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );\n\n    for ( ; cur < limit; cur++ )\n    {\n      if ( cur->platform_id == platform_id )\n      {\n        if ( cur->encoding_id == encoding_id ||\n             cur->encoding_id == -1          )\n          return cur->encoding;\n      }\n    }\n\n    return FT_ENCODING_NONE;\n  }\n",
        "output": "0",
        "index": 6983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Observe(int type,\n      const content::NotificationSource& source,\n      const content::NotificationDetails& details) {\n    switch (type) {\n      case chrome::NOTIFICATION_FOREIGN_SESSION_UPDATED:\n        notified_of_update_ = true;\n        break;\n      case chrome::NOTIFICATION_SYNC_REFRESH:\n        notified_of_refresh_ = true;\n        break;\n      default:\n        NOTREACHED();\n        break;\n    }\n  }\n",
        "output": "0",
        "index": 114766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void igmp_start_timer(struct ip_mc_list *im, int max_delay)\n{\n\tint tv = net_random() % max_delay;\n\n\tim->tm_running = 1;\n\tif (!mod_timer(&im->timer, jiffies+tv+2))\n\t\tatomic_inc(&im->refcnt);\n}\n",
        "output": "0",
        "index": 21612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   scoped_refptr<UsbDeviceHandle> WaitForResult() {\n     run_loop_.Run();\n     return device_handle_;\n   }\n",
        "output": "0",
        "index": 139045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AXObjectCacheImpl::listboxActiveIndexChanged(HTMLSelectElement* select) {\n  AXObject* obj = get(select);\n  if (!obj || !obj->isAXListBox())\n    return;\n\n  toAXListBox(obj)->activeIndexChanged();\n}\n",
        "output": "0",
        "index": 138266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err oinf_dump(GF_Box *a, FILE * trace)\n{\n\tGF_OINFPropertyBox *ptr = (GF_OINFPropertyBox *)a;\n\tgf_isom_box_dump_start(a, \"OperatingPointsInformationPropertyBox\", trace);\n\tfprintf(trace, \">\\n\");\n\n\toinf_entry_dump(ptr->oinf, trace);\n\n\tgf_isom_box_dump_done(\"OperatingPointsInformationPropertyBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::OnAccessibilityDoDefaultAction(int acc_obj_id) {\n  if (!accessibility_.get())\n    return;\n\n  WebAccessibilityObject obj = accessibility_->getObjectById(acc_obj_id);\n  if (!obj.isValid())\n    return;\n\n  obj.performDefaultAction();\n}\n",
        "output": "0",
        "index": 103798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RenderLayerScrollableArea::pixelSnappedScrollHeight() const\n{\n    return snapSizeToPixel(scrollHeight(), box().clientTop() + box().y());\n}\n",
        "output": "0",
        "index": 128429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t CameraClient::storeMetaDataInBuffers(bool enabled)\n{\n    LOG1(\"storeMetaDataInBuffers: %s\", enabled? \"true\": \"false\");\n Mutex::Autolock lock(mLock);\n if (checkPidAndHardware() != NO_ERROR) {\n return UNKNOWN_ERROR;\n }\n return mHardware->storeMetaDataInBuffers(enabled);\n}\n",
        "output": "0",
        "index": 174976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ims_pcu_suspend(struct usb_interface *intf,\n\t\t\t   pm_message_t message)\n{\n\tstruct ims_pcu *pcu = usb_get_intfdata(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\n\tif (alt->desc.bInterfaceClass == USB_CLASS_COMM)\n\t\tims_pcu_stop_io(pcu);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 54039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)\n{\n\tstatic struct in6_addr prefix;\n\tstruct __nd_opt_route_info *ri =\n\t\t\tndp_msg_payload_opts_offset(msg, offset);\n\n\tmemset(&prefix, 0, sizeof(prefix));\n\tmemcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);\n\treturn &prefix;\n}\n",
        "output": "0",
        "index": 53937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Eina_Bool ewk_frame_mixed_content_run_get(const Evas_Object* ewkFrame)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    return smartData->hasRunMixedContent;\n}\n",
        "output": "0",
        "index": 115933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fill_post_wcc(struct svc_fh *fhp)\n{\n\t__be32 err;\n\n\tif (fhp->fh_post_saved)\n\t\tprintk(\"nfsd: inode locked twice during operation.\\n\");\n\n\terr = fh_getattr(fhp, &fhp->fh_post_attr);\n\tfhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;\n\tif (err) {\n\t\tfhp->fh_post_saved = false;\n\t\t/* Grab the ctime anyway - set_change_info might use it */\n\t\tfhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;\n\t} else\n\t\tfhp->fh_post_saved = true;\n}\n",
        "output": "0",
        "index": 65264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBlock::setMarginsForRubyRun(BidiRun* run, RenderRubyRun* renderer, RenderObject* previousObject, const LineInfo& lineInfo)\n{\n    int startOverhang;\n    int endOverhang;\n    RenderObject* nextObject = 0;\n    for (BidiRun* runWithNextObject = run->next(); runWithNextObject; runWithNextObject = runWithNextObject->next()) {\n        if (!runWithNextObject->m_object->isOutOfFlowPositioned() && !runWithNextObject->m_box->isLineBreak()) {\n            nextObject = runWithNextObject->m_object;\n            break;\n        }\n    }\n    renderer->getOverhang(lineInfo.isFirstLine(), renderer->style()->isLeftToRightDirection() ? previousObject : nextObject, renderer->style()->isLeftToRightDirection() ? nextObject : previousObject, startOverhang, endOverhang);\n    setMarginStartForChild(renderer, -startOverhang);\n    setMarginEndForChild(renderer, -endOverhang);\n}\n",
        "output": "0",
        "index": 119667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RenderFrameHostManager::GetRoutingIdForSiteInstance(\n    SiteInstance* site_instance) {\n  if (render_frame_host_->GetSiteInstance() == site_instance)\n    return render_frame_host_->GetRoutingID();\n\n  RenderFrameProxyHost* proxy = GetRenderFrameProxyHost(site_instance);\n  if (proxy)\n    return proxy->GetRoutingID();\n\n  return MSG_ROUTING_NONE;\n}\n",
        "output": "0",
        "index": 148887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DraggedTabGtk::Attach(int selected_width) {\n  attached_ = true;\n  Resize(selected_width);\n\n  if (gtk_util::IsScreenComposited())\n    gdk_window_set_opacity(container_->window, kOpaqueAlpha);\n}\n",
        "output": "0",
        "index": 98590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sha384_neon_final(struct shash_desc *desc, u8 *hash)\n{\n\tu8 D[SHA512_DIGEST_SIZE];\n\n\tsha512_neon_final(desc, D);\n\n\tmemcpy(hash, D, SHA384_DIGEST_SIZE);\n\tmemset(D, 0, SHA512_DIGEST_SIZE);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 46616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<NavigationEntry> NavigationController::CreateNavigationEntry(\n    const GURL& url,\n    const Referrer& referrer,\n    ui::PageTransition transition,\n    bool is_renderer_initiated,\n    const std::string& extra_headers,\n    BrowserContext* browser_context) {\n  GURL dest_url(url);\n  BrowserURLHandlerImpl::GetInstance()->FixupURLBeforeRewrite(&dest_url,\n                                                              browser_context);\n\n  GURL loaded_url(dest_url);\n  bool reverse_on_redirect = false;\n  BrowserURLHandlerImpl::GetInstance()->RewriteURLIfNecessary(\n      &loaded_url, browser_context, &reverse_on_redirect);\n\n  NavigationEntryImpl* entry = new NavigationEntryImpl(\n      NULL,  // The site instance for tabs is sent on navigation\n      loaded_url,\n      referrer,\n      base::string16(),\n      transition,\n      is_renderer_initiated);\n  entry->SetVirtualURL(dest_url);\n  entry->set_user_typed_url(dest_url);\n  entry->set_update_virtual_url_with_url(reverse_on_redirect);\n  entry->set_extra_headers(extra_headers);\n  return base::WrapUnique(entry);\n}\n",
        "output": "0",
        "index": 150444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stop_reading (ProxySide *side)\n{\n  if (side->in_source)\n    {\n      g_source_destroy (side->in_source);\n      side->in_source = NULL;\n    }\n}\n",
        "output": "0",
        "index": 84430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool FramebufferManager::GetClientId(\n    GLuint service_id, GLuint* client_id) const {\n  for (FramebufferMap::const_iterator it = framebuffers_.begin();\n       it != framebuffers_.end(); ++it) {\n    if (it->second->service_id() == service_id) {\n      *client_id = it->first;\n      return true;\n    }\n  }\n  return false;\n}\n",
        "output": "0",
        "index": 129154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofproto_init_tables(struct ofproto *ofproto, int n_tables)\n{\n    struct oftable *table;\n\n    ovs_assert(!ofproto->n_tables);\n    ovs_assert(n_tables >= 1 && n_tables <= 255);\n\n    ofproto->n_tables = n_tables;\n    ofproto->tables = xmalloc(n_tables * sizeof *ofproto->tables);\n    OFPROTO_FOR_EACH_TABLE (table, ofproto) {\n        oftable_init(table);\n    }\n}\n",
        "output": "0",
        "index": 77331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VaapiVideoDecodeAccelerator::VaapiVideoDecodeAccelerator(\n    const MakeGLContextCurrentCallback& make_context_current_cb,\n    const BindGLImageCallback& bind_image_cb)\n    : state_(kUninitialized),\n      input_ready_(&lock_),\n      vaapi_picture_factory_(new VaapiPictureFactory()),\n      surfaces_available_(&lock_),\n      task_runner_(base::ThreadTaskRunnerHandle::Get()),\n      decoder_thread_(\"VaapiDecoderThread\"),\n      num_frames_at_client_(0),\n      finish_flush_pending_(false),\n      awaiting_va_surfaces_recycle_(false),\n      requested_num_pics_(0),\n      output_format_(gfx::BufferFormat::BGRX_8888),\n      profile_(VIDEO_CODEC_PROFILE_UNKNOWN),\n      make_context_current_cb_(make_context_current_cb),\n      bind_image_cb_(bind_image_cb),\n      weak_this_factory_(this) {\n  weak_this_ = weak_this_factory_.GetWeakPtr();\n  va_surface_release_cb_ = BindToCurrentLoop(\n      base::Bind(&VaapiVideoDecodeAccelerator::RecycleVASurfaceID, weak_this_));\n}\n",
        "output": "0",
        "index": 161704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string DownloadItemImpl::GetContentDisposition() const {\n  return content_disposition_;\n}\n",
        "output": "0",
        "index": 113028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SessionService::BuildCommandsForTab(\n    const SessionID& window_id,\n    TabContentsWrapper* tab,\n    int index_in_window,\n    bool is_pinned,\n    std::vector<SessionCommand*>* commands,\n    IdToRange* tab_to_available_range) {\n  DCHECK(tab && commands && window_id.id());\n  const SessionID& session_id(tab->restore_tab_helper()->session_id());\n  commands->push_back(CreateSetTabWindowCommand(window_id, session_id));\n  const int current_index =\n      tab->web_contents()->GetController().GetCurrentEntryIndex();\n  const int min_index = std::max(0,\n                                 current_index - max_persist_navigation_count);\n  const int max_index =\n      std::min(current_index + max_persist_navigation_count,\n               tab->web_contents()->GetController().GetEntryCount());\n  const int pending_index =\n      tab->web_contents()->GetController().GetPendingEntryIndex();\n  if (tab_to_available_range) {\n    (*tab_to_available_range)[session_id.id()] =\n        std::pair<int, int>(min_index, max_index);\n  }\n  if (is_pinned) {\n    commands->push_back(CreatePinnedStateCommand(session_id, true));\n  }\n  TabContentsWrapper* wrapper =\n      TabContentsWrapper::GetCurrentWrapperForContents(tab->web_contents());\n  if (wrapper->extension_tab_helper()->extension_app()) {\n    commands->push_back(\n        CreateSetTabExtensionAppIDCommand(\n            kCommandSetExtensionAppID, session_id.id(),\n            wrapper->extension_tab_helper()->extension_app()->id()));\n  }\n  for (int i = min_index; i < max_index; ++i) {\n    const NavigationEntry* entry = (i == pending_index) ?\n        tab->web_contents()->GetController().GetPendingEntry() :\n        tab->web_contents()->GetController().GetEntryAtIndex(i);\n    DCHECK(entry);\n    if (ShouldTrackEntry(entry->GetVirtualURL())) {\n      commands->push_back(\n          CreateUpdateTabNavigationCommand(\n              kCommandUpdateTabNavigation, session_id.id(), i, *entry));\n    }\n  }\n  commands->push_back(\n      CreateSetSelectedNavigationIndexCommand(session_id, current_index));\n\n  if (index_in_window != -1) {\n    commands->push_back(\n        CreateSetTabIndexInWindowCommand(session_id, index_in_window));\n  }\n}\n",
        "output": "0",
        "index": 117056
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool virtnet_validate_features(struct virtio_device *vdev)\n{\n\tif (!virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ) &&\n\t    (VIRTNET_FAIL_ON(vdev, VIRTIO_NET_F_CTRL_RX,\n\t\t\t     \"VIRTIO_NET_F_CTRL_VQ\") ||\n\t     VIRTNET_FAIL_ON(vdev, VIRTIO_NET_F_CTRL_VLAN,\n\t\t\t     \"VIRTIO_NET_F_CTRL_VQ\") ||\n\t     VIRTNET_FAIL_ON(vdev, VIRTIO_NET_F_GUEST_ANNOUNCE,\n\t\t\t     \"VIRTIO_NET_F_CTRL_VQ\") ||\n\t     VIRTNET_FAIL_ON(vdev, VIRTIO_NET_F_MQ, \"VIRTIO_NET_F_CTRL_VQ\") ||\n\t     VIRTNET_FAIL_ON(vdev, VIRTIO_NET_F_CTRL_MAC_ADDR,\n\t\t\t     \"VIRTIO_NET_F_CTRL_VQ\"))) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "output": "0",
        "index": 43016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AutocompletePopupViewGtk::AcceptLine(size_t line,\n                                          WindowOpenDisposition disposition) {\n  const AutocompleteMatch& match = model_->result().match_at(line);\n  const GURL url(match.destination_url);\n  std::wstring keyword;\n  const bool is_keyword_hint = model_->GetKeywordForMatch(match, &keyword);\n  edit_view_->OpenURL(url, disposition, match.transition, GURL(), line,\n                      is_keyword_hint ? std::wstring() : keyword);\n}\n",
        "output": "0",
        "index": 98507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SProcRenderCreateLinearGradient (ClientPtr client)\n{\n    register int n;\n    int len;\n    REQUEST (xRenderCreateLinearGradientReq);\n    REQUEST_AT_LEAST_SIZE (xRenderCreateLinearGradientReq);\n\n    swaps(&stuff->length, n);\n    swapl(&stuff->pid, n);\n    swapl(&stuff->p1.x, n);\n    swapl(&stuff->p1.y, n);\n    swapl(&stuff->p2.x, n);\n    swapl(&stuff->p2.y, n);\n    swapl(&stuff->nStops, n);\n\n    len = (client->req_len << 2) - sizeof(xRenderCreateLinearGradientReq);\n    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))\n\treturn BadLength;\n    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n\n    swapStops(stuff+1, stuff->nStops);\n\n    return (*ProcRenderVector[stuff->renderReqType]) (client);\n}\n",
        "output": "0",
        "index": 14102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WorkerFetchContext::IsSVGImageChromeClient() const {\n  return false;\n}\n",
        "output": "0",
        "index": 151507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestingAutomationProvider::OmniboxAcceptInput(\n    Browser* browser,\n    DictionaryValue* args,\n    IPC::Message* reply_message) {\n  NavigationController& controller =\n      browser->GetSelectedWebContents()->GetController();\n  new OmniboxAcceptNotificationObserver(&controller, this, reply_message);\n  browser->window()->GetLocationBar()->AcceptInput();\n}\n",
        "output": "0",
        "index": 114989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void strstore(char **str, const char *newstr)\n{\n  if(*str)\n    free(*str);\n  *str = strdup(newstr);\n}\n",
        "output": "0",
        "index": 32456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SProcPseudoramiXQueryScreens(ClientPtr client)\n{\n    REQUEST(xXineramaQueryScreensReq);\n\n    TRACE;\n\n    swaps(&stuff->length);\n    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);\n    return ProcPseudoramiXQueryScreens(client);\n}\n",
        "output": "0",
        "index": 17548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OmniboxViewViews::ApplyCaretVisibility() {\n  SetCursorEnabled(model()->is_caret_visible());\n\n  if (location_bar_view_)\n    location_bar_view_->OnOmniboxFocused();\n}\n",
        "output": "0",
        "index": 155102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __glXDisp_WaitGL(__GLXclientState *cl, GLbyte *pc)\n{\n    xGLXWaitGLReq *req = (xGLXWaitGLReq *)pc;\n    GLXContextTag tag = req->contextTag;\n    __GLXcontext *glxc = NULL;\n    int error;\n\n    if (tag) {\n\tglxc = __glXLookupContextByTag(cl, tag);\n\tif (!glxc)\n\t    return __glXError(GLXBadContextTag);\n    \n\tif (!__glXForceCurrent(cl, req->contextTag, &error))\n\t    return error;\n\n\tCALL_Finish( GET_DISPATCH(), () );\n    }\n\n    if (glxc && glxc->drawPriv->waitGL)\n\t(*glxc->drawPriv->waitGL)(glxc->drawPriv);\n\n    return Success;\n}\n",
        "output": "0",
        "index": 14180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sync_with_option(void)\n{\n    if (PagerMax < LINES)\n\tPagerMax = LINES;\n    WrapSearch = WrapDefault;\n    parse_proxy();\n#ifdef USE_COOKIE\n    parse_cookie();\n#endif\n    initMailcap();\n    initMimeTypes();\n#ifdef USE_EXTERNAL_URI_LOADER\n    initURIMethods();\n#endif\n#ifdef USE_MIGEMO\n    init_migemo();\n#endif\n#ifdef USE_IMAGE\n    if (fmInitialized && displayImage)\n\tinitImage();\n#else\n    displayImage = FALSE;\t/* XXX */\n#endif\n    loadPasswd();\n    loadPreForm();\n    loadSiteconf();\n\n    if (AcceptLang == NULL || *AcceptLang == '\\0') {\n\t/* TRANSLATORS: \n\t * AcceptLang default: this is used in Accept-Language: HTTP request \n\t * header. For example, ja.po should translate it as\n\t * \"ja;q=1.0, en;q=0.5\" like that.\n\t */\n\tAcceptLang = _(\"en;q=1.0\");\n    }\n    if (AcceptEncoding == NULL || *AcceptEncoding == '\\0')\n\tAcceptEncoding = acceptableEncoding();\n    if (AcceptMedia == NULL || *AcceptMedia == '\\0')\n\tAcceptMedia = acceptableMimeTypes();\n#ifdef USE_UNICODE\n    update_utf8_symbol();\n#endif\n    if (fmInitialized) {\n\tinitKeymap(FALSE);\n#ifdef USE_MOUSE\n\tinitMouseAction();\n#endif\t\t\t\t/* MOUSE */\n#ifdef USE_MENU\n\tinitMenu();\n#endif\t\t\t\t/* MENU */\n    }\n}\n",
        "output": "0",
        "index": 84575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int git_index_entry_stage(const git_index_entry *entry)\n{\n\treturn GIT_IDXENTRY_STAGE(entry);\n}\n",
        "output": "0",
        "index": 83675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void udf_update_extent_cache(struct inode *inode, loff_t estart,\n\t\t\t\t    struct extent_position *pos, int next_epos)\n{\n\tstruct udf_inode_info *iinfo = UDF_I(inode);\n\n\tspin_lock(&iinfo->i_extent_cache_lock);\n\t/* Invalidate previously cached extent */\n\t__udf_clear_extent_cache(inode);\n\tif (pos->bh)\n\t\tget_bh(pos->bh);\n\tmemcpy(&iinfo->cached_extent.epos, pos,\n\t       sizeof(struct extent_position));\n\tiinfo->cached_extent.lstart = estart;\n\tif (next_epos)\n\t\tswitch (iinfo->i_alloc_type) {\n\t\tcase ICBTAG_FLAG_AD_SHORT:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct short_ad);\n\t\t\tbreak;\n\t\tcase ICBTAG_FLAG_AD_LONG:\n\t\t\tiinfo->cached_extent.epos.offset -=\n\t\t\tsizeof(struct long_ad);\n\t\t}\n\tspin_unlock(&iinfo->i_extent_cache_lock);\n}\n",
        "output": "0",
        "index": 36065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ParseOpenTag(XMLTreeRoot *root,char *tag,char **attributes)\n{\n  XMLTreeInfo\n    *xml_info;\n\n  xml_info=root->node;\n  if (xml_info->tag == (char *) NULL)\n    xml_info->tag=ConstantString(tag);\n  else\n    xml_info=AddChildToXMLTree(xml_info,tag,strlen(xml_info->content));\n  if (xml_info != (XMLTreeInfo *) NULL)\n    xml_info->attributes=attributes;\n  root->node=xml_info;\n}\n",
        "output": "0",
        "index": 71980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool MainThreadFrameObserver::OnMessageReceived(const IPC::Message& msg) {\n  if (msg.type() == ViewHostMsg_WaitForNextFrameForTests_ACK::ID &&\n      msg.routing_id() == routing_id_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&MainThreadFrameObserver::Quit, base::Unretained(this)));\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 169281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "scoped_refptr<EntryImpl> BackendImpl::OpenNextEntryImpl(\n    Rankings::Iterator* iterator) {\n  if (disabled_)\n    return NULL;\n\n  const int kListsToSearch = 3;\n  scoped_refptr<EntryImpl> entries[kListsToSearch];\n  if (!iterator->my_rankings) {\n    iterator->my_rankings = &rankings_;\n    bool ret = false;\n\n    for (int i = 0; i < kListsToSearch; i++) {\n      ret |= OpenFollowingEntryFromList(static_cast<Rankings::List>(i),\n                                        &iterator->nodes[i], &entries[i]);\n    }\n    if (!ret) {\n      iterator->Reset();\n      return NULL;\n    }\n  } else {\n    for (int i = 0; i < kListsToSearch; i++) {\n      if (iterator->list == i) {\n        OpenFollowingEntryFromList(iterator->list, &iterator->nodes[i],\n                                   &entries[i]);\n      } else {\n        entries[i] = GetEnumeratedEntry(iterator->nodes[i],\n                                        static_cast<Rankings::List>(i));\n      }\n    }\n  }\n\n  int newest = -1;\n  int oldest = -1;\n  Time access_times[kListsToSearch];\n  for (int i = 0; i < kListsToSearch; i++) {\n    if (entries[i].get()) {\n      access_times[i] = entries[i]->GetLastUsed();\n      if (newest < 0) {\n        DCHECK_LT(oldest, 0);\n        newest = oldest = i;\n        continue;\n      }\n      if (access_times[i] > access_times[newest])\n        newest = i;\n      if (access_times[i] < access_times[oldest])\n        oldest = i;\n    }\n  }\n\n  if (newest < 0 || oldest < 0) {\n    iterator->Reset();\n    return NULL;\n  }\n\n  scoped_refptr<EntryImpl> next_entry = entries[newest];\n  iterator->list = static_cast<Rankings::List>(newest);\n  return next_entry;\n}\n",
        "output": "0",
        "index": 160077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "integer_to_BN(krb5_context context, const char *field, const heim_integer *f)\n{\n    BIGNUM *bn;\n\n    bn = BN_bin2bn((const unsigned char *)f->data, f->length, NULL);\n    if (bn == NULL) {\n\tkrb5_set_error_message(context, ENOMEM,\n\t\t\t       N_(\"PKINIT: parsing BN failed %s\", \"\"), field);\n\treturn NULL;\n    }\n    BN_set_negative(bn, f->negative);\n    return bn;\n}\n",
        "output": "0",
        "index": 89968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int csum_len_for_type(int cst)\n{\n\tswitch (cst) {\n\t  case CSUM_NONE:\n\t\treturn 1;\n\t  case CSUM_MD4_ARCHAIC:\n\t\treturn 2;\n\t  case CSUM_MD4:\n\t  case CSUM_MD4_OLD:\n\t  case CSUM_MD4_BUSTED:\n\t\treturn MD4_DIGEST_LEN;\n\t  case CSUM_MD5:\n\t\treturn MD5_DIGEST_LEN;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 1626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidget::OnWasRestored(bool needs_repainting) {\n  if (!webwidget_)\n    return;\n\n  SetHidden(false);\n\n  if (!needs_repainting && !needs_repainting_on_restore_)\n    return;\n  needs_repainting_on_restore_ = false;\n\n  set_next_paint_is_restore_ack();\n\n  didInvalidateRect(gfx::Rect(size_.width(), size_.height()));\n}\n",
        "output": "0",
        "index": 98652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_recv_NPSetWindowCallbackStruct(rpc_message_t *message, void *p_value)\n{\n  NPSetWindowCallbackStruct **ws_info_p = (NPSetWindowCallbackStruct **)p_value;\n  NPSetWindowCallbackStruct *ws_info;\n  int32_t type;\n  uint32_t has_ws_info, visual_id, colormap, depth;\n  int error;\n\n  if (ws_info_p)\n\t*ws_info_p = NULL;\n\n  if ((error = rpc_message_recv_uint32(message, &has_ws_info)) < 0)\n\treturn error;\n\n  if (has_ws_info) {\n\tif ((error = rpc_message_recv_int32(message, &type)) < 0)\n\t  return error;\n\tif ((error = rpc_message_recv_uint32(message, &visual_id)) < 0)\n\t  return error;\n\tif ((error = rpc_message_recv_uint32(message, &colormap)) < 0)\n\t  return error;\n\tif ((error = rpc_message_recv_uint32(message, &depth)) < 0)\n\t  return error;\n\n\tif (ws_info_p) {\n\t  if ((ws_info = calloc(1, sizeof(*ws_info))) == NULL)\n\t\treturn RPC_ERROR_NO_MEMORY;\n\t  ws_info->type = type;\n\t  ws_info->visual = (void *)(uintptr_t)visual_id;\n\t  ws_info->colormap = colormap;\n\t  ws_info->depth = depth;\n\t  *ws_info_p = ws_info;\n\t}\n  }\n\n  return RPC_ERROR_NO_ERROR;\n}\n",
        "output": "0",
        "index": 26970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void region16_init(REGION16* region)\n{\n\tassert(region);\n\tZeroMemory(region, sizeof(REGION16));\n\tregion->data = &empty_region;\n}\n",
        "output": "0",
        "index": 87412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *av_calloc(size_t nmemb, size_t size)\n{\n    if (size <= 0 || nmemb >= INT_MAX / size)\n        return NULL;\n    return av_mallocz(nmemb * size);\n}\n",
        "output": "0",
        "index": 29697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PrintViewManagerBase::OnMessageReceived(\n    const IPC::Message& message,\n    content::RenderFrameHost* render_frame_host) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(PrintViewManagerBase, message)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPrintPage, OnDidPrintPage)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_ShowInvalidPrinterSettingsError,\n                        OnShowInvalidPrinterSettingsError)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  return handled || PrintManager::OnMessageReceived(message, render_frame_host);\n}\n",
        "output": "0",
        "index": 137703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_absolute_bodysid_offset(MXFContext *mxf, int body_sid, int64_t offset, int64_t *offset_out, MXFPartition **partition_out)\n{\n    MXFPartition *last_p = NULL;\n    int a, b, m, m0;\n\n    if (offset < 0)\n        return AVERROR(EINVAL);\n\n    a = -1;\n    b = mxf->partitions_count;\n\n    while (b - a > 1) {\n        m0 = m = (a + b) >> 1;\n\n        while (m < b && mxf->partitions[m].body_sid != body_sid)\n            m++;\n\n        if (m < b && mxf->partitions[m].body_offset <= offset)\n            a = m;\n        else\n            b = m0;\n    }\n\n    if (a >= 0)\n        last_p = &mxf->partitions[a];\n\n    if (last_p && (!last_p->essence_length || last_p->essence_length > (offset - last_p->body_offset))) {\n        *offset_out = last_p->essence_offset + (offset - last_p->body_offset);\n        if (partition_out)\n            *partition_out = last_p;\n        return 0;\n    }\n\n    av_log(mxf->fc, AV_LOG_ERROR,\n           \"failed to find absolute offset of %\"PRIX64\" in BodySID %i - partial file?\\n\",\n           offset, body_sid);\n\n    return AVERROR_INVALIDDATA;\n}\n",
        "output": "0",
        "index": 74824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "media::AudioCodec CodecIdToMediaAudioCodec(AudioTrackRecorder::CodecId id) {\n  switch (id) {\n    case AudioTrackRecorder::CodecId::PCM:\n      return media::kCodecPCM;\n    case AudioTrackRecorder::CodecId::OPUS:\n      return media::kCodecOpus;\n    case AudioTrackRecorder::CodecId::LAST:\n      return media::kUnknownAudioCodec;\n  }\n  NOTREACHED() << \"Unsupported audio codec\";\n  return media::kUnknownAudioCodec;\n}\n",
        "output": "0",
        "index": 156296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (cfg->wowl.active) {\n\t\tbrcmf_report_wowl_wakeind(wiphy, ifp);\n\t\tbrcmf_fil_iovar_int_set(ifp, \"wowl_clear\", 0);\n\t\tbrcmf_config_wowl_pattern(ifp, \"clr\", NULL, 0, NULL, 0);\n\t\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM,\n\t\t\t\t      cfg->wowl.pre_pmmode);\n\t\tcfg->wowl.active = false;\n\t\tif (cfg->wowl.nd_enabled) {\n\t\t\tbrcmf_cfg80211_sched_scan_stop(cfg->wiphy, ifp->ndev);\n\t\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t\t    brcmf_notify_sched_scan_results);\n\t\t\tcfg->wowl.nd_enabled = false;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 49032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OrdinalNumber HTMLDocumentParser::lineNumber() const\n{\n    return m_input.current().currentLine();\n}\n",
        "output": "0",
        "index": 113892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_timers_open(struct inode *inode, struct file *file)\n{\n\tstruct timers_private *tp;\n\n\ttp = __seq_open_private(file, &proc_timers_seq_ops,\n\t\t\tsizeof(struct timers_private));\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->pid = proc_pid(inode);\n\ttp->ns = inode->i_sb->s_fs_info;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 49460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_destroy_vm(struct kvm *kvm)\n{\n\tint i;\n\tstruct mm_struct *mm = kvm->mm;\n\n\tkvm_arch_sync_events(kvm);\n\tspin_lock(&kvm_lock);\n\tlist_del(&kvm->vm_list);\n\tspin_unlock(&kvm_lock);\n\tkvm_free_irq_routing(kvm);\n\tfor (i = 0; i < KVM_NR_BUSES; i++)\n\t\tkvm_io_bus_destroy(kvm->buses[i]);\n\tkvm_coalesced_mmio_free(kvm);\n#if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)\n\tmmu_notifier_unregister(&kvm->mmu_notifier, kvm->mm);\n#else\n\tkvm_arch_flush_shadow_all(kvm);\n#endif\n\tkvm_arch_destroy_vm(kvm);\n\tkvm_destroy_devices(kvm);\n\tkvm_free_physmem(kvm);\n\tcleanup_srcu_struct(&kvm->srcu);\n\tkvm_arch_free_vm(kvm);\n\thardware_disable_all();\n\tmmdrop(mm);\n}\n",
        "output": "0",
        "index": 29316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::OnTouchEventAck(\n    const TouchEventWithLatencyInfo& event,\n    InputEventAckSource ack_source,\n    InputEventAckState ack_result) {\n  latency_tracker_.OnInputEventAck(event.event, &event.latency, ack_result);\n  for (auto& input_event_observer : input_event_observers_)\n    input_event_observer.OnInputEventAck(ack_source, ack_result, event.event);\n\n  if (touch_emulator_ &&\n      touch_emulator_->HandleTouchEventAck(event.event, ack_result)) {\n    return;\n  }\n\n  if (view_)\n    view_->ProcessAckedTouchEvent(event, ack_result);\n}\n",
        "output": "0",
        "index": 168767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const gl::GLVersionInfo& gl_version_info() {\n    return feature_info_->gl_version_info();\n  }\n",
        "output": "0",
        "index": 154401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CStarter::Reaper(int pid, int exit_status)\n{\n\tint handled_jobs = 0;\n\tint all_jobs = 0;\n\tUserProc *job;\n\n\tif( WIFSIGNALED(exit_status) ) {\n\t\tdprintf( D_ALWAYS, \"Process exited, pid=%d, signal=%d\\n\", pid,\n\t\t\t\t WTERMSIG(exit_status) );\n\t} else {\n\t\tdprintf( D_ALWAYS, \"Process exited, pid=%d, status=%d\\n\", pid,\n\t\t\t\t WEXITSTATUS(exit_status) );\n\t}\n\n\tif( pre_script && pre_script->JobReaper(pid, exit_status) ) {\t\t\n\t\t\n\t\tif( ! SpawnJob() ) {\n\t\t\tdprintf( D_ALWAYS, \"Failed to start main job, exiting\\n\" );\n\t\t\tmain_shutdown_fast();\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\n\tif( post_script && post_script->JobReaper(pid, exit_status) ) {\n\t\tallJobsDone();\n\t\treturn TRUE;\n\t}\n\n\n\tm_job_list.Rewind();\n\twhile ((job = m_job_list.Next()) != NULL) {\n\t\tall_jobs++;\n\t\tif( job->GetJobPid()==pid && job->JobReaper(pid, exit_status) ) {\n\t\t\thandled_jobs++;\n\t\t\tm_job_list.DeleteCurrent();\n\t\t\tm_reaped_job_list.Append(job);\n\t\t}\n\t}\n\n\tdprintf( D_FULLDEBUG, \"Reaper: all=%d handled=%d ShuttingDown=%d\\n\",\n\t\t\t all_jobs, handled_jobs, ShuttingDown );\n\n\tif( handled_jobs == 0 ) {\n\t\tdprintf( D_ALWAYS, \"unhandled job exit: pid=%d, status=%d\\n\",\n\t\t\t\t pid, exit_status );\n\t}\n\tif( all_jobs - handled_jobs == 0 ) {\n\t\tif( post_script ) {\n\t\t\tpost_script->StartJob();\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tif( !allJobsDone() ) {\n\t\t\t\tdprintf(D_ALWAYS, \"Returning from CStarter::JobReaper()\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ShuttingDown && (all_jobs - handled_jobs == 0) ) {\n\t\tdprintf(D_ALWAYS,\"Last process exited, now Starter is exiting\\n\");\n\t\tStarterExit(0);\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 16392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}\n",
        "output": "0",
        "index": 28727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int ipqhashfn(__be16 id, __be32 saddr, __be32 daddr, u8 prot)\n{\n\treturn jhash_3words((__force u32)id << 16 | prot,\n\t\t\t    (__force u32)saddr, (__force u32)daddr,\n\t\t\t    ip4_frags.rnd) & (INETFRAGS_HASHSZ - 1);\n}\n",
        "output": "0",
        "index": 27355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evdns_server_request_set_flags(struct evdns_server_request *exreq, int flags)\n{\n\tstruct server_request *req = TO_SERVER_REQUEST(exreq);\n\treq->base.flags &= ~(EVDNS_FLAGS_AA|EVDNS_FLAGS_RD);\n\treq->base.flags |= flags;\n}\n",
        "output": "0",
        "index": 70650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TabStrip::OnMouseReleased(const ui::MouseEvent& event) {\n  EndDrag(END_DRAG_COMPLETE);\n  UpdateLayoutTypeFromMouseEvent(this, event);\n}\n",
        "output": "0",
        "index": 134397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int utf8_check(const uint8_t *str)\n{\n    const uint8_t *byte;\n    uint32_t codepoint, min;\n\n    while (*str) {\n        byte = str;\n        GET_UTF8(codepoint, *(byte++), return 0;);\n        min = byte - str == 1 ? 0 : byte - str == 2 ? 0x80 :\n              1 << (5 * (byte - str) - 4);\n        if (codepoint < min || codepoint >= 0x110000 ||\n            codepoint == 0xFFFE /* BOM */ ||\n            codepoint >= 0xD800 && codepoint <= 0xDFFF /* surrogates */)\n            return 0;\n        str = byte;\n    }\n    return 1;\n}\n",
        "output": "0",
        "index": 67061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeWebContentsDelegateAndroid::AddNewContents(\n    WebContents* source,\n    WebContents* new_contents,\n    WindowOpenDisposition disposition,\n    const gfx::Rect& initial_rect,\n    bool user_gesture,\n    bool* was_blocked) {\n  DCHECK_NE(disposition, SAVE_TO_DISK);\n  DCHECK_NE(disposition, CURRENT_TAB);\n\n  TabHelpers::AttachTabHelpers(new_contents);\n \n   JNIEnv* env = AttachCurrentThread();\n   ScopedJavaLocalRef<jobject> obj = GetJavaDelegate(env);\n  AddWebContentsResult add_result =\n      ADD_WEB_CONTENTS_RESULT_STOP_LOAD_AND_DELETE;\n   if (!obj.is_null()) {\n     ScopedJavaLocalRef<jobject> jsource;\n     if (source)\n      jsource = source->GetJavaWebContents();\n    ScopedJavaLocalRef<jobject> jnew_contents;\n     if (new_contents)\n       jnew_contents = new_contents->GetJavaWebContents();\n \n    add_result = static_cast<AddWebContentsResult>(\n        Java_ChromeWebContentsDelegateAndroid_addNewContents(\n            env,\n            obj.obj(),\n            jsource.obj(),\n            jnew_contents.obj(),\n            static_cast<jint>(disposition),\n            NULL,\n            user_gesture));\n   }\n \n   if (was_blocked)\n    *was_blocked = !(add_result == ADD_WEB_CONTENTS_RESULT_PROCEED);\n  if (add_result == ADD_WEB_CONTENTS_RESULT_STOP_LOAD_AND_DELETE)\n     delete new_contents;\n }\n",
        "output": "1",
        "index": 184829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void webkit_web_frame_stop_loading(WebKitWebFrame* frame)\n{\n    g_return_if_fail(WEBKIT_IS_WEB_FRAME(frame));\n\n    Frame* coreFrame = core(frame);\n    if (!coreFrame)\n        return;\n\n    coreFrame->loader()->stopAllLoaders();\n}\n",
        "output": "0",
        "index": 98416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rpcap_frame_end (void)\n{\n  info_added = FALSE;\n}\n",
        "output": "0",
        "index": 51764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool_t auth_gssapi_unseal_seq(\n     gss_ctx_id_t context,\n     gss_buffer_t in_buf,\n     uint32_t *seq_num)\n{\n     gss_buffer_desc out_buf;\n     OM_uint32 gssstat, minor_stat;\n     uint32_t nl_seq_num;\n\n     gssstat = gss_unseal(&minor_stat, context, in_buf, &out_buf,\n\t\t\t  NULL, NULL);\n     if (gssstat != GSS_S_COMPLETE) {\n\t  PRINTF((\"gssapi_unseal_seq: failed\\n\"));\n\t  AUTH_GSSAPI_DISPLAY_STATUS((\"unsealing sequence number\",\n\t\t\t\t      gssstat, minor_stat));\n\t  return FALSE;\n     } else if (out_buf.length != sizeof(uint32_t)) {\n\t  PRINTF((\"gssapi_unseal_seq: unseal gave %d bytes\\n\",\n\t\t  (int) out_buf.length));\n\t  gss_release_buffer(&minor_stat, &out_buf);\n\t  return FALSE;\n     }\n\n     nl_seq_num = *((uint32_t *) out_buf.value);\n     *seq_num = (uint32_t) ntohl(nl_seq_num);\n     gss_release_buffer(&minor_stat, &out_buf);\n\n     return TRUE;\n}\n",
        "output": "0",
        "index": 46095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_handle_external_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\tif ((exit_intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR)) {\n\t\tunsigned int vector;\n\t\tunsigned long entry;\n\t\tgate_desc *desc;\n\t\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n#ifdef CONFIG_X86_64\n\t\tunsigned long tmp;\n#endif\n\n\t\tvector =  exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\tdesc = (gate_desc *)vmx->host_idt_base + vector;\n\t\tentry = gate_offset(desc);\n\t\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\t\"push $%c[ss]\\n\\t\"\n\t\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\t\"pushf\\n\\t\"\n\t\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\t\tCALL_NOSPEC\n\t\t\t:\n#ifdef CONFIG_X86_64\n\t\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\t\tASM_CALL_CONSTRAINT\n\t\t\t:\n\t\t\tTHUNK_TARGET(entry),\n\t\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t\t[cs]\"i\"(__KERNEL_CS)\n\t\t\t);\n\t}\n}\n",
        "output": "0",
        "index": 81041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_filter(struct tap_filter *filter, void __user *arg)\n{\n\tstruct { u8 u[ETH_ALEN]; } *addr;\n\tstruct tun_filter uf;\n\tint err, alen, n, nexact;\n\n\tif (copy_from_user(&uf, arg, sizeof(uf)))\n\t\treturn -EFAULT;\n\n\tif (!uf.count) {\n\t\t/* Disabled */\n\t\tfilter->count = 0;\n\t\treturn 0;\n\t}\n\n\talen = ETH_ALEN * uf.count;\n\taddr = memdup_user(arg + sizeof(uf), alen);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\n\t/* The filter is updated without holding any locks. Which is\n\t * perfectly safe. We disable it first and in the worst\n\t * case we'll accept a few undesired packets. */\n\tfilter->count = 0;\n\twmb();\n\n\t/* Use first set of addresses as an exact filter */\n\tfor (n = 0; n < uf.count && n < FLT_EXACT_COUNT; n++)\n\t\tmemcpy(filter->addr[n], addr[n].u, ETH_ALEN);\n\n\tnexact = n;\n\n\t/* Remaining multicast addresses are hashed,\n\t * unicast will leave the filter disabled. */\n\tmemset(filter->mask, 0, sizeof(filter->mask));\n\tfor (; n < uf.count; n++) {\n\t\tif (!is_multicast_ether_addr(addr[n].u)) {\n\t\t\terr = 0; /* no filter */\n\t\t\tgoto free_addr;\n\t\t}\n\t\taddr_hash_set(filter->mask, addr[n].u);\n\t}\n\n\t/* For ALLMULTI just set the mask to all ones.\n\t * This overrides the mask populated above. */\n\tif ((uf.flags & TUN_FLT_ALLMULTI))\n\t\tmemset(filter->mask, ~0, sizeof(filter->mask));\n\n\t/* Now enable the filter */\n\twmb();\n\tfilter->count = nexact;\n\n\t/* Return the number of exact filters */\n\terr = nexact;\nfree_addr:\n\tkfree(addr);\n\treturn err;\n}\n",
        "output": "0",
        "index": 93339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)\n{\n    if (!parent())\n        return;\n\n    if ((style()->borderImage().image() && style()->borderImage().image()->data() == image) ||\n        (style()->maskBoxImage().image() && style()->maskBoxImage().image()->data() == image)) {\n        repaint();\n        return;\n    }\n\n    bool didFullRepaint = repaintLayerRectsForImage(image, style()->backgroundLayers(), true);\n    if (!didFullRepaint)\n        repaintLayerRectsForImage(image, style()->maskLayers(), false);\n\n\n#if USE(ACCELERATED_COMPOSITING)\n    if (hasLayer() && layer()->hasCompositedMask() && layersUseImage(image, style()->maskLayers()))\n        layer()->contentChanged(RenderLayer::MaskImageChanged);\n#endif\n}\n",
        "output": "0",
        "index": 106877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int FlateStream::getChar() {\n  if (pred) {\n    return pred->getChar();\n  }\n  return doGetRawChar();\n}\n",
        "output": "0",
        "index": 3944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ring_buffer_init(struct ring_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->writable = 1;\n\n\tatomic_set(&rb->refcount, 1);\n}\n",
        "output": "0",
        "index": 26241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void InputMethodTSF::CancelComposition(const TextInputClient* client) {\n  if (IsTextInputClientFocused(client) && IsWindowFocused(client))\n    ui::TSFBridge::GetInstance()->CancelComposition();\n}\n",
        "output": "0",
        "index": 134157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserActionsContainer::AnimationProgressed(const Animation* animation) {\n  DCHECK(animation == resize_animation_.get());\n\n  double e = resize_animation_->GetCurrentValue();\n  int difference = container_size_.width() - animation_target_size_;\n\n  resize_amount_ = static_cast<int>(e * difference);\n\n  OnBrowserActionVisibilityChanged();\n}\n",
        "output": "0",
        "index": 100100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "oxide::qt::RestoreType ToInternalRestoreType(\n    OxideQQuickWebView::RestoreType type) {\n  switch (type) {\n    case OxideQQuickWebView::RestoreCurrentSession:\n      return oxide::qt::RESTORE_CURRENT_SESSION;\n    case OxideQQuickWebView::RestoreLastSessionExitedCleanly:\n      return oxide::qt::RESTORE_LAST_SESSION_EXITED_CLEANLY;\n    case OxideQQuickWebView::RestoreLastSessionCrashed:\n      return oxide::qt::RESTORE_LAST_SESSION_CRASHED;\n  }\n}\n",
        "output": "0",
        "index": 17058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LayerTreeCoordinator::notifyAnimationStarted(const WebCore::GraphicsLayer*, double time)\n{\n}\n",
        "output": "0",
        "index": 102467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nautilus_directory_set_up_request (NautilusFileAttributes file_attributes)\n{\n    Request request;\n\n    request = 0;\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_COUNT) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_DIRECTORY_COUNT);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DEEP_COUNTS) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_DEEP_COUNT);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_DIRECTORY_ITEM_MIME_TYPES) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_MIME_LIST);\n    }\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_INFO) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_LINK_INFO)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n        REQUEST_SET_TYPE (request, REQUEST_LINK_INFO);\n    }\n\n    if ((file_attributes & NAUTILUS_FILE_ATTRIBUTE_EXTENSION_INFO) != 0)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_EXTENSION_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_THUMBNAIL)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_THUMBNAIL);\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_MOUNT)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_MOUNT);\n        REQUEST_SET_TYPE (request, REQUEST_FILE_INFO);\n    }\n\n    if (file_attributes & NAUTILUS_FILE_ATTRIBUTE_FILESYSTEM_INFO)\n    {\n        REQUEST_SET_TYPE (request, REQUEST_FILESYSTEM_INFO);\n    }\n\n    return request;\n}\n",
        "output": "0",
        "index": 60977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::DidNavigateToPendingEntry(TabContents* tab) {\n  if (tab == GetSelectedTabContents())\n    UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_TAB_STATE);\n}\n",
        "output": "0",
        "index": 101626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "list_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tif (is_software_event(event))\n\t\t\tevent->group_flags |= PERF_GROUP_SOFTWARE;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tctx->nr_cgroups++;\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tif (!ctx->nr_events)\n\t\tperf_pmu_rotate_start(ctx->pmu);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n}\n",
        "output": "0",
        "index": 26017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnDidFailLoadWithError(\n    int64 frame_id,\n    const GURL& url,\n    bool is_main_frame,\n    int error_code,\n    const string16& error_description) {\n  GURL validated_url(url);\n  RenderProcessHost* render_process_host = message_source_->GetProcess();\n  RenderViewHost::FilterURL(render_process_host, false, &validated_url);\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidFailLoad(frame_id, validated_url, is_main_frame,\n                                error_code, error_description,\n                                message_source_));\n}\n",
        "output": "0",
        "index": 118974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ftp_get_listing (struct url *u, ccon *con, struct fileinfo **f)\n{\n  uerr_t err;\n  char *uf;                     /* url file name */\n  char *lf;                     /* list file name */\n  char *old_target = con->target;\n\n  con->st &= ~ON_YOUR_OWN;\n  con->cmd |= (DO_LIST | LEAVE_PENDING);\n  con->cmd &= ~DO_RETR;\n\n  /* Find the listing file name.  We do it by taking the file name of\n     the URL and replacing the last component with the listing file\n     name.  */\n  uf = url_file_name (u, NULL);\n  lf = file_merge (uf, LIST_FILENAME);\n  xfree (uf);\n  DEBUGP ((_(\"Using %s as listing tmp file.\\n\"), quote (lf)));\n\n  con->target = xstrdup (lf);\n  xfree (lf);\n  err = ftp_loop_internal (u, NULL, con, NULL, false);\n  lf = xstrdup (con->target);\n  xfree (con->target);\n  con->target = old_target;\n\n  if (err == RETROK)\n    {\n      *f = ftp_parse_ls (lf, con->rs);\n      if (opt.remove_listing)\n        {\n          if (unlink (lf))\n            logprintf (LOG_NOTQUIET, \"unlink: %s\\n\", strerror (errno));\n          else\n            logprintf (LOG_VERBOSE, _(\"Removed %s.\\n\"), quote (lf));\n        }\n    }\n  else\n    *f = NULL;\n  xfree (lf);\n  con->cmd &= ~DO_LIST;\n  return err;\n}\n",
        "output": "0",
        "index": 218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltNewDecimalFormat(xmlChar *name)\n{\n    xsltDecimalFormatPtr self;\n    /* UTF-8 for 0x2030 */\n    static const xmlChar permille[4] = {0xe2, 0x80, 0xb0, 0};\n\n    self = xmlMalloc(sizeof(xsltDecimalFormat));\n    if (self != NULL) {\n\tself->next = NULL;\n\tself->name = name;\n\n\t/* Default values */\n\tself->digit = xmlStrdup(BAD_CAST(\"#\"));\n\tself->patternSeparator = xmlStrdup(BAD_CAST(\";\"));\n\tself->decimalPoint = xmlStrdup(BAD_CAST(\".\"));\n\tself->grouping = xmlStrdup(BAD_CAST(\",\"));\n\tself->percent = xmlStrdup(BAD_CAST(\"%\"));\n\tself->permille = xmlStrdup(BAD_CAST(permille));\n\tself->zeroDigit = xmlStrdup(BAD_CAST(\"0\"));\n\tself->minusSign = xmlStrdup(BAD_CAST(\"-\"));\n\tself->infinity = xmlStrdup(BAD_CAST(\"Infinity\"));\n\tself->noNumber = xmlStrdup(BAD_CAST(\"NaN\"));\n    }\n    return self;\n}\n",
        "output": "0",
        "index": 170083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "abort_job (CommonJob *job)\n{\n    /* destroy the undo action data too */\n    g_clear_object (&job->undo_info);\n\n    g_cancellable_cancel (job->cancellable);\n}\n",
        "output": "0",
        "index": 61010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BrowserClosedNotificationObserver::BrowserClosedNotificationObserver(\n    Browser* browser,\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    bool use_json_interface)\n    : automation_(automation->AsWeakPtr()),\n      reply_message_(reply_message),\n      use_json_interface_(use_json_interface),\n      for_browser_command_(false) {\n  registrar_.Add(this, chrome::NOTIFICATION_BROWSER_CLOSED,\n                 content::Source<Browser>(browser));\n}\n",
        "output": "0",
        "index": 125921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::NativeView RenderFrameHostImpl::GetNativeView() {\n  RenderWidgetHostView* view = render_view_host_->GetWidget()->GetView();\n  if (!view)\n    return nullptr;\n  return view->GetNativeView();\n}\n",
        "output": "0",
        "index": 151969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_xdr_dec_open_noattr(struct rpc_rqst *rqstp,\n\t\t\t\t    struct xdr_stream *xdr,\n\t\t\t\t    struct nfs_openres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_open(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tdecode_getfattr(xdr, res->f_attr, res->server,\n\t\t\t!RPC_IS_ASYNC(rqstp->rq_task));\nout:\n\treturn status;\n}\n",
        "output": "0",
        "index": 23431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FreeWaitHandles(LPHANDLE h)\n{\n    free(h);\n}\n",
        "output": "0",
        "index": 83400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AutofillDialogViews::SuggestionView::CanUseVerticallyCompactText(\n    int available_width,\n    int* resulting_height) const {\n  if (!calculated_heights_.count(available_width)) {\n    SuggestionView sizing_view(NULL);\n    sizing_view.SetLabelText(state_.vertically_compact_text);\n    sizing_view.SetIcon(state_.icon);\n    sizing_view.SetTextfield(state_.extra_text, state_.extra_icon);\n    sizing_view.label_->SetSize(gfx::Size(available_width, 0));\n    sizing_view.label_line_2_->SetSize(gfx::Size(available_width, 0));\n\n    views::LayoutManager* layout = sizing_view.GetLayoutManager();\n    if (layout->GetPreferredSize(&sizing_view).width() <= available_width) {\n      calculated_heights_[available_width] = std::make_pair(\n          true,\n          layout->GetPreferredHeightForWidth(&sizing_view, available_width));\n    } else {\n      sizing_view.SetLabelText(state_.horizontally_compact_text);\n      calculated_heights_[available_width] = std::make_pair(\n          false,\n          layout->GetPreferredHeightForWidth(&sizing_view, available_width));\n    }\n  }\n\n  const std::pair<bool, int>& values = calculated_heights_[available_width];\n  *resulting_height = values.second;\n  return values.first;\n}\n",
        "output": "0",
        "index": 118197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IOThread::Init() {\n}\n",
        "output": "0",
        "index": 121862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PermissionsData::~PermissionsData() {\n}\n",
        "output": "0",
        "index": 129128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TestLifecycleUnit::Discard(DiscardReason discard_reason) {\n  return false;\n}\n",
        "output": "0",
        "index": 144843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void re_yyrestart  (FILE * input_file , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! YY_CURRENT_BUFFER ){\n        re_yyensure_buffer_stack (yyscanner);\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            re_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n\t}\n\n\tre_yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);\n\tre_yy_load_buffer_state(yyscanner );\n}\n",
        "output": "0",
        "index": 70498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~SystemURLRequestContext() {\n#if defined(USE_NSS) || defined(OS_IOS)\n    net::SetURLRequestContextForNSSHttpIO(NULL);\n#endif\n  }\n",
        "output": "0",
        "index": 121884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void assemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\treturn;\n}\n",
        "output": "0",
        "index": 84933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntRect ChromeClientImpl::PageRect() {\n   return RootWindowRect();\n }\n",
        "output": "0",
        "index": 160984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int android_net_wifi_getInterfaces(JNIEnv *env, jclass cls) {\n int n = 0;\n\n JNIHelper helper(env);\n\n    wifi_handle halHandle = getWifiHandle(helper, cls);\n    wifi_interface_handle *ifaceHandles = NULL;\n int result = hal_fn.wifi_get_ifaces(halHandle, &n, &ifaceHandles);\n if (result < 0) {\n return result;\n }\n\n if (n < 0) {\n        THROW(helper,\"android_net_wifi_getInterfaces no interfaces\");\n return 0;\n }\n\n if (ifaceHandles == NULL) {\n       THROW(helper,\"android_net_wifi_getInterfaces null interface array\");\n return 0;\n }\n\n if (n > 8) {\n        THROW(helper,\"Too many interfaces\");\n return 0;\n }\n\n    jlongArray array = (env)->NewLongArray(n);\n if (array == NULL) {\n        THROW(helper,\"Error in accessing array\");\n return 0;\n }\n\n    jlong elems[8];\n for (int i = 0; i < n; i++) {\n        elems[i] = reinterpret_cast<jlong>(ifaceHandles[i]);\n }\n\n    helper.setLongArrayRegion(array, 0, n, elems);\n    helper.setStaticLongArrayField(cls, WifiIfaceHandleVarName, array);\n\n return (result < 0) ? result : n;\n}\n",
        "output": "0",
        "index": 172245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _server_handle_s(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {\n\tchar message[64];\n\tif (send_ack (g) < 0) {\n\t\treturn -1;\n\t}\n\tif (g->data_len > 1) {\n\t\treturn send_msg (g, \"E01\");\n\t}\n\tif (cmd_cb (core_ptr, \"ds\", NULL, 0) < 0) {\n\t\tsend_msg (g, \"E01\");\n\t\treturn -1;\n\t}\n\tsnprintf (message, sizeof (message) - 1, \"T05thread:%x;\", cmd_cb (core_ptr, \"dptr\", NULL, 0));\n\treturn send_msg (g, message);\n}\n",
        "output": "0",
        "index": 64150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static String ValueDefaultParagraphSeparator(const EditorInternalCommand&,\n                                             LocalFrame& frame,\n                                             Event*) {\n  switch (frame.GetEditor().DefaultParagraphSeparator()) {\n    case kEditorParagraphSeparatorIsDiv:\n      return divTag.LocalName();\n    case kEditorParagraphSeparatorIsP:\n      return pTag.LocalName();\n  }\n\n  NOTREACHED();\n  return String();\n}\n",
        "output": "0",
        "index": 139567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Element::scrollIntoView(bool alignToTop) \n{\n    document()->updateLayoutIgnorePendingStylesheets();\n\n    if (!renderer())\n        return;\n\n    LayoutRect bounds = boundingBox();\n    if (alignToTop)\n        renderer()->scrollRectToVisible(bounds, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignTopAlways);\n    else\n        renderer()->scrollRectToVisible(bounds, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignBottomAlways);\n}\n",
        "output": "0",
        "index": 120621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool xmp_files_free(XmpFilePtr xf)\n{\n    CHECK_PTR(xf, false);\n    RESET_ERROR;\n    auto txf = reinterpret_cast<SXMPFiles *>(xf);\n    try {\n        delete txf;\n    }\n    catch (const XMP_Error &e) {\n        set_error(e);\n        return false;\n    }\n    return true;\n}\n",
        "output": "0",
        "index": 16013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void part_round_stats(struct request_queue *q, int cpu, struct hd_struct *part)\n{\n\tstruct hd_struct *part2 = NULL;\n\tunsigned long now = jiffies;\n\tunsigned int inflight[2];\n\tint stats = 0;\n\n\tif (part->stamp != now)\n\t\tstats |= 1;\n\n\tif (part->partno) {\n\t\tpart2 = &part_to_disk(part)->part0;\n\t\tif (part2->stamp != now)\n\t\t\tstats |= 2;\n\t}\n\n\tif (!stats)\n\t\treturn;\n\n\tpart_in_flight(q, part, inflight);\n\n\tif (stats & 2)\n\t\tpart_round_stats_single(q, cpu, part2, now, inflight[1]);\n\tif (stats & 1)\n\t\tpart_round_stats_single(q, cpu, part, now, inflight[0]);\n}\n",
        "output": "0",
        "index": 92061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PacketFreeOrRelease(Packet *p)\n{\n    if (p->flags & PKT_ALLOC)\n        PacketFree(p);\n    else\n        PacketPoolReturnPacket(p);\n}\n",
        "output": "0",
        "index": 87040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsmp_get_unix_process_id (GsmClient *client)\n{\n        SmProp  *prop;\n        guint    pid;\n        gboolean res;\n\n        g_debug (\"GsmXSMPClient: getting pid\");\n\n        prop = find_property (GSM_XSMP_CLIENT (client), SmProcessID, NULL);\n\n        if (!prop || strcmp (prop->type, SmARRAY8) != 0) {\n                return 0;\n        }\n\n        pid = 0;\n        res = _parse_value_as_uint ((char *)prop->vals[0].value, &pid);\n        if (! res) {\n                pid = 0;\n        }\n\n        return pid;\n}\n",
        "output": "0",
        "index": 63586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LayerTreeHost::SetTaskRunnerProviderForTesting(\n    std::unique_ptr<TaskRunnerProvider> task_runner_provider) {\n  DCHECK(!task_runner_provider_);\n  task_runner_provider_ = std::move(task_runner_provider);\n}\n",
        "output": "0",
        "index": 149860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SupervisedUserService::UpdateManualHosts() {\n  const base::DictionaryValue* dict =\n      profile_->GetPrefs()->GetDictionary(prefs::kSupervisedUserManualHosts);\n  std::map<std::string, bool> host_map;\n  for (base::DictionaryValue::Iterator it(*dict); !it.IsAtEnd(); it.Advance()) {\n    bool allow = false;\n    bool result = it.value().GetAsBoolean(&allow);\n    DCHECK(result);\n    host_map[it.key()] = allow;\n  }\n  url_filter_.SetManualHosts(std::move(host_map));\n\n  for (SupervisedUserServiceObserver& observer : observer_list_)\n    observer.OnURLFilterChanged();\n}\n",
        "output": "0",
        "index": 155863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGL2RenderingContextBase::uniform2fv(\n    const WebGLUniformLocation* location,\n    const FlexibleFloat32ArrayView& v,\n    GLuint src_offset,\n    GLuint src_length) {\n  if (isContextLost() ||\n      !ValidateUniformParameters<WTF::Float32Array>(\"uniform2fv\", location, v,\n                                                    2, src_offset, src_length))\n    return;\n\n  ContextGL()->Uniform2fv(\n      location->Location(),\n      (src_length ? src_length : (v.length() - src_offset)) >> 1,\n      v.DataMaybeOnStack() + src_offset);\n}\n",
        "output": "0",
        "index": 146180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeBrowserMainPartsChromeos::PreMainMessageLoopRun() {\n  chromeos::AudioHandler::Initialize();\n\n  if (chromeos::system::runtime_environment::IsRunningOnChromeOS() &&\n      !parameters().ui_task) {  // ui_task is non-NULL when running tests.\n    chromeos::SystemKeyEventListener::Initialize();\n  }\n\n  chromeos::XInputHierarchyChangedEventListener::GetInstance();\n\n  ChromeBrowserMainPartsLinux::PreMainMessageLoopRun();\n}\n",
        "output": "0",
        "index": 117541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OfflinePageDownloadBridge::~OfflinePageDownloadBridge() {}\n",
        "output": "0",
        "index": 135511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::didDestroyScriptContext(WebFrame* frame) {\n  content::GetContentClient()->renderer()->DidDestroyScriptContext(frame);\n}\n",
        "output": "0",
        "index": 103884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtrWillBeRawPtr<Attr> Document::createAttribute(const AtomicString& name, ExceptionState& exceptionState)\n{\n    return createAttributeNS(nullAtom, name, exceptionState, true);\n}\n",
        "output": "0",
        "index": 138410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sn_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)\n\t{ return(strcmp((*a)->sn,nid_objs[*b].sn)); }\n",
        "output": "0",
        "index": 12487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init setup_slub_max_order(char *str)\n{\n\tget_option(&str, &slub_max_order);\n\n\treturn 1;\n}\n",
        "output": "0",
        "index": 24890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   std::unique_ptr<FakeMediaStreamUIProxy> CreateMockUI(bool expect_started) {\n     std::unique_ptr<MockMediaStreamUIProxy> fake_ui =\n         std::make_unique<MockMediaStreamUIProxy>();\n     if (expect_started)\n       EXPECT_CALL(*fake_ui, MockOnStarted(_));\n     return fake_ui;\n  }\n",
        "output": "1",
        "index": 187083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int getJobAdExitSignal(ClassAd *jad, int &exit_signal)\n{\n\tif( ! jad->LookupInteger(ATTR_ON_EXIT_SIGNAL, exit_signal) ) {\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n",
        "output": "0",
        "index": 16330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void faad_endbits(bitfile *ld)\n{\n}\n",
        "output": "0",
        "index": 88355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CastStreamingNativeHandler::DestroyCastRtpStream(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK_EQ(1, args.Length());\n  CHECK(args[0]->IsInt32());\n\n  const int transport_id = args[0]->ToInt32(args.GetIsolate())->Value();\n  if (!GetRtpStreamOrThrow(transport_id))\n    return;\n  rtp_stream_map_.erase(transport_id);\n}\n",
        "output": "0",
        "index": 169574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ubifs_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err;\n\n\tdbg_gen(\"syncing inode %lu\", inode->i_ino);\n\n\tif (c->ro_mount)\n\t\t/*\n\t\t * For some really strange reasons VFS does not filter out\n\t\t * 'fsync()' for R/O mounted file-systems as per 2.6.39.\n\t\t */\n\t\treturn 0;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* Synchronize the inode unless this is a 'datasync()' call. */\n\tif (!datasync || (inode->i_state & I_DIRTY_DATASYNC)) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Nodes related to this inode may still sit in a write-buffer. Flush\n\t * them.\n\t */\n\terr = ubifs_sync_wbufs_by_inode(c, inode);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}\n",
        "output": "0",
        "index": 46419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long compat_sock_ioctl(struct file *file, unsigned cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct socket *sock = file->private_data;\n\tint ret = -ENOIOCTLCMD;\n\tstruct sock *sk;\n\tstruct net *net;\n\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\tif (sock->ops->compat_ioctl)\n\t\tret = sock->ops->compat_ioctl(sock, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD &&\n\t    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))\n\t\tret = compat_wext_handle_ioctl(net, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = compat_sock_ioctl_trans(file, sock, cmd, arg);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 22724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ndisc_solicit(struct neighbour *neigh, struct sk_buff *skb)\n{\n\tstruct in6_addr *saddr = NULL;\n\tstruct in6_addr mcaddr;\n\tstruct net_device *dev = neigh->dev;\n\tstruct in6_addr *target = (struct in6_addr *)&neigh->primary_key;\n\tint probes = atomic_read(&neigh->probes);\n\n\tif (skb && ipv6_chk_addr_and_flags(dev_net(dev), &ipv6_hdr(skb)->saddr,\n\t\t\t\t\t   dev, 1,\n\t\t\t\t\t   IFA_F_TENTATIVE|IFA_F_OPTIMISTIC))\n\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\tprobes -= NEIGH_VAR(neigh->parms, UCAST_PROBES);\n\tif (probes < 0) {\n\t\tif (!(neigh->nud_state & NUD_VALID)) {\n\t\t\tND_PRINTK(1, dbg,\n\t\t\t\t  \"%s: trying to ucast probe in NUD_INVALID: %pI6\\n\",\n\t\t\t\t  __func__, target);\n\t\t}\n\t\tndisc_send_ns(dev, neigh, target, target, saddr);\n\t} else if ((probes -= NEIGH_VAR(neigh->parms, APP_PROBES)) < 0) {\n\t\tneigh_app_ns(neigh);\n\t} else {\n\t\taddrconf_addr_solict_mult(target, &mcaddr);\n\t\tndisc_send_ns(dev, NULL, target, &mcaddr, saddr);\n\t}\n}\n",
        "output": "0",
        "index": 43727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_putrootfh(struct xdr_stream *xdr)\n{\n\treturn decode_op_hdr(xdr, OP_PUTROOTFH);\n}\n",
        "output": "0",
        "index": 23035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_move_mount(struct path *path, const char *old_name)\n{\n\tstruct path old_path, parent_path;\n\tstruct mount *p;\n\tstruct mount *old;\n\tstruct mountpoint *mp;\n\tint err;\n\tif (!old_name || !*old_name)\n\t\treturn -EINVAL;\n\terr = kern_path(old_name, LOOKUP_FOLLOW, &old_path);\n\tif (err)\n\t\treturn err;\n\n\tmp = lock_mount(path);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto out;\n\n\told = real_mount(old_path.mnt);\n\tp = real_mount(path->mnt);\n\n\terr = -EINVAL;\n\tif (!check_mnt(p) || !check_mnt(old))\n\t\tgoto out1;\n\n\tif (old->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto out1;\n\n\terr = -EINVAL;\n\tif (old_path.dentry != old_path.mnt->mnt_root)\n\t\tgoto out1;\n\n\tif (!mnt_has_parent(old))\n\t\tgoto out1;\n\n\tif (d_is_dir(path->dentry) !=\n\t      d_is_dir(old_path.dentry))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount residing in a shared parent.\n\t */\n\tif (IS_MNT_SHARED(old->mnt_parent))\n\t\tgoto out1;\n\t/*\n\t * Don't move a mount tree containing unbindable mounts to a destination\n\t * mount which is shared.\n\t */\n\tif (IS_MNT_SHARED(p) && tree_contains_unbindable(old))\n\t\tgoto out1;\n\terr = -ELOOP;\n\tfor (; mnt_has_parent(p); p = p->mnt_parent)\n\t\tif (p == old)\n\t\t\tgoto out1;\n\n\terr = attach_recursive_mnt(old, real_mount(path->mnt), mp, &parent_path);\n\tif (err)\n\t\tgoto out1;\n\n\t/* if the mount is moved, it should no longer be expire\n\t * automatically */\n\tlist_del_init(&old->mnt_expire);\nout1:\n\tunlock_mount(mp);\nout:\n\tif (!err)\n\t\tpath_put(&parent_path);\n\tpath_put(&old_path);\n\treturn err;\n}\n",
        "output": "0",
        "index": 50939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __net_init ip6mr_net_init(struct net *net)\n{\n\tint err;\n\n\terr = ip6mr_rules_init(net);\n\tif (err < 0)\n\t\tgoto fail;\n\n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (!proc_create(\"ip6_mr_vif\", 0, net->proc_net, &ip6mr_vif_fops))\n\t\tgoto proc_vif_fail;\n\tif (!proc_create(\"ip6_mr_cache\", 0, net->proc_net, &ip6mr_mfc_fops))\n\t\tgoto proc_cache_fail;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_PROC_FS\nproc_cache_fail:\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\nproc_vif_fail:\n\tip6mr_rules_exit(net);\n#endif\nfail:\n\treturn err;\n}\n",
        "output": "0",
        "index": 93538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_SPVTL( INS_ARG )\n  {\n    DO_SPVTL\n  }\n",
        "output": "0",
        "index": 10178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "process_locals( const char* param_name, const char* host )\n{\n\tStringList sources_to_process, sources_done;\n\tchar *source, *sources_value;\n\tint local_required;\n\n\tlocal_required = param_boolean_crufty(\"REQUIRE_LOCAL_CONFIG_FILE\", true);\n\n\tsources_value = param( param_name );\n\tif( sources_value ) {\n\t\tif ( is_piped_command( sources_value ) ) {\n\t\t\tsources_to_process.insert( sources_value );\n\t\t} else {\n\t\t\tsources_to_process.initializeFromString( sources_value );\n\t\t}\n\t\tsources_to_process.rewind();\n\t\twhile( (source = sources_to_process.next()) ) {\n\t\t\tprocess_config_source( source, \"config source\", host,\n\t\t\t\t\t\t\t\t   local_required );\n\t\t\tlocal_config_sources.append( source );\n\n\t\t\tsources_done.append(source);\n\n\t\t\tchar* new_sources_value = param(param_name);\n\t\t\tif(new_sources_value) {\n\t\t\t\tif(strcmp(sources_value, new_sources_value) ) {\n\t\t\t\t\tsources_to_process.clearAll();\n\t\t\t\t\tif ( is_piped_command( new_sources_value ) ) {\n\t\t\t\t\t\tsources_to_process.insert( new_sources_value );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsources_to_process.initializeFromString(new_sources_value);\n\t\t\t\t\t}\n\n                \tsources_done.rewind();\n                \twhile( (source = sources_done.next()) ) {\n\t\t\t\t\t\tsources_to_process.remove(source);\n\t\t\t\t\t}\n\t\t\t\t\tsources_to_process.rewind();\n\t\t\t\t\tfree(sources_value);\n\t\t\t\t\tsources_value = new_sources_value;\n\t\t\t\t} else {\n\t\t\t\t\tfree(new_sources_value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(sources_value);\n\t}\n}\n",
        "output": "0",
        "index": 16524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t Parcel::readInt32(int32_t *pArg) const\n{\n return readAligned(pArg);\n}\n",
        "output": "0",
        "index": 170472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ecall(mrb_state *mrb)\n{\n  struct RProc *p;\n  struct mrb_context *c = mrb->c;\n  mrb_callinfo *ci = c->ci;\n  struct RObject *exc;\n  struct REnv *env;\n  ptrdiff_t cioff;\n  int ai = mrb_gc_arena_save(mrb);\n  int i = --c->eidx;\n  int nregs;\n\n  if (i<0) return;\n  if (ci - c->cibase > MRB_ECALL_DEPTH_MAX) {\n    mrb_exc_raise(mrb, mrb_obj_value(mrb->stack_err));\n  }\n  p = c->ensure[i];\n  if (!p) return;\n  mrb_assert(!MRB_PROC_CFUNC_P(p));\n  c->ensure[i] = NULL;\n  nregs = p->upper->body.irep->nregs;\n  if (ci->proc && !MRB_PROC_CFUNC_P(ci->proc) &&\n      ci->proc->body.irep->nregs > nregs) {\n    nregs = ci->proc->body.irep->nregs;\n  }\n  cioff = ci - c->cibase;\n  ci = cipush(mrb);\n  ci->stackent = mrb->c->stack;\n  ci->mid = ci[-1].mid;\n  ci->acc = CI_ACC_SKIP;\n  ci->argc = 0;\n  ci->proc = p;\n  ci->nregs = p->body.irep->nregs;\n  ci->target_class = MRB_PROC_TARGET_CLASS(p);\n  env = MRB_PROC_ENV(p);\n  mrb_assert(env);\n  c->stack += nregs;\n  exc = mrb->exc; mrb->exc = 0;\n  if (exc) {\n    mrb_gc_protect(mrb, mrb_obj_value(exc));\n  }\n  mrb_run(mrb, p, env->stack[0]);\n  mrb->c = c;\n  c->ci = c->cibase + cioff;\n  if (!mrb->exc) mrb->exc = exc;\n  mrb_gc_arena_restore(mrb, ai);\n}\n",
        "output": "0",
        "index": 83172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Extension::ShouldDisplayInAppLauncher() const {\n  return is_app() && display_in_launcher_;\n}\n",
        "output": "0",
        "index": 122720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int transfer_size(int ssize, int max_sector, int max_size)\n{\n\tSUPBOUND(max_sector, fsector_t + max_size);\n\n\t/* alignment */\n\tmax_sector -= (max_sector % _floppy->sect) % ssize;\n\n\t/* transfer size, beginning not aligned */\n\tcurrent_count_sectors = max_sector - fsector_t;\n\n\treturn max_sector;\n}\n",
        "output": "0",
        "index": 39443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::ConfigureDataTypes(\n    const syncable::ModelTypeSet& types_to_add,\n    const syncable::ModelTypeSet& types_to_remove,\n    sync_api::ConfigureReason reason,\n    base::Callback<void(bool)> ready_task,\n    bool enable_nigori) {\n  syncable::ModelTypeSet types_to_add_with_nigori = types_to_add;\n  syncable::ModelTypeSet types_to_remove_with_nigori = types_to_remove;\n  if (enable_nigori) {\n    types_to_add_with_nigori.insert(syncable::NIGORI);\n    types_to_remove_with_nigori.erase(syncable::NIGORI);\n  } else {\n    types_to_add_with_nigori.erase(syncable::NIGORI);\n    types_to_remove_with_nigori.insert(syncable::NIGORI);\n  }\n  DCHECK(!pending_config_mode_state_.get());\n  DCHECK(!pending_download_state_.get());\n  DCHECK_GT(initialization_state_, NOT_INITIALIZED);\n\n  pending_config_mode_state_.reset(new PendingConfigureDataTypesState());\n  pending_config_mode_state_->ready_task = ready_task;\n  pending_config_mode_state_->types_to_add = types_to_add_with_nigori;\n  pending_config_mode_state_->added_types =\n      registrar_->ConfigureDataTypes(types_to_add_with_nigori,\n                                     types_to_remove_with_nigori);\n  pending_config_mode_state_->reason = reason;\n\n  if (!types_to_remove_with_nigori.empty()) {\n    sync_thread_.message_loop()->PostTask(\n        FROM_HERE,\n        NewRunnableMethod(\n            core_.get(),\n            &SyncBackendHost::Core::DoRequestCleanupDisabledTypes));\n  }\n\n  StartConfiguration(NewCallback(core_.get(),\n      &SyncBackendHost::Core::FinishConfigureDataTypes));\n}\n",
        "output": "0",
        "index": 102037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reflectedCustomURLAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    imp->setAttribute(HTMLNames::customContentURLAttrAttr, cppValue);\n}\n",
        "output": "0",
        "index": 130997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void readonlyLongAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValueInt(info, imp->readonlyLongAttribute());\n}\n",
        "output": "0",
        "index": 131642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IPCThreadState::setLastTransactionBinderFlags(int32_t flags)\n{\n    mLastTransactionBinderFlags = flags;\n}\n",
        "output": "0",
        "index": 174335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SyncManager::ExtraPasswordChangeRecordData::ExtraPasswordChangeRecordData() {}\n",
        "output": "0",
        "index": 102124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n \tif (!addr)\n \t\treturn -ENODEV;\n \n\tio->io_cleanup = mem_cleanup;\n \t/*\n \t * Figure out the actual readb/readw/readl/etc routine to use based\n \t * upon the register size.\n\t */\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Some BIOSes reserve disjoint memory regions in their ACPI\n\t * tables.  This causes problems when trying to request the\n\t * entire region.  Therefore we must request each register\n\t * separately.\n\t */\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\t/* Undo allocations */\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the total amount of memory to claim.  This is an\n\t * unusual looking calculation, but it avoids claiming any\n\t * more memory than it has to.  It will claim everything\n\t * between the first address to the end of the last full\n\t * register.\n\t */\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n \t\tmem_region_cleanup(io, io->io_size);\n \t\treturn -EIO;\n \t}\n \treturn 0;\n }\n",
        "output": "1",
        "index": 182853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)\n{\n    SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);\n     info->num_memslots = NUM_MEMSLOTS;\n     info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;\n     info->internal_groupslot_id = 0;\n    info->qxl_ram_size = ssd->bufsize;\n     info->n_surfaces = ssd->num_surfaces;\n }\n",
        "output": "1",
        "index": 178322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "search_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n",
        "output": "0",
        "index": 33599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "json_typeof(PG_FUNCTION_ARGS)\n{\n\ttext\t   *json;\n\n\tJsonLexContext *lex;\n\tJsonTokenType tok;\n\tchar\t   *type;\n\n\tjson = PG_GETARG_TEXT_P(0);\n\tlex = makeJsonLexContext(json, false);\n\n\t/* Lex exactly one token from the input and check its type. */\n\tjson_lex(lex);\n\ttok = lex_peek(lex);\n\tswitch (tok)\n\t{\n\t\tcase JSON_TOKEN_OBJECT_START:\n\t\t\ttype = \"object\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_ARRAY_START:\n\t\t\ttype = \"array\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_STRING:\n\t\t\ttype = \"string\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NUMBER:\n\t\t\ttype = \"number\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_TRUE:\n\t\tcase JSON_TOKEN_FALSE:\n\t\t\ttype = \"boolean\";\n\t\t\tbreak;\n\t\tcase JSON_TOKEN_NULL:\n\t\t\ttype = \"null\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected json token: %d\", tok);\n\t}\n\n\tPG_RETURN_TEXT_P(cstring_to_text(type));\n}\n",
        "output": "0",
        "index": 2542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "map_engine_persons(void)\n{\n\tint i;\n\n\tif (s_person_list == NULL)\n\t\ts_person_list = vector_new(sizeof(person_t*));\n\tvector_clear(s_person_list);\n\tfor (i = 0; i < s_num_persons; ++i)\n\t\tvector_push(s_person_list, &s_persons[i]);\n\treturn s_person_list;\n}\n",
        "output": "0",
        "index": 75038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltLocalVariablePush(xsltTransformContextPtr ctxt,\n\t\t      xsltStackElemPtr variable,\n\t\t      int level)\n{\n    if (ctxt->varsMax == 0) {\n\tctxt->varsMax = 10;\n\tctxt->varsTab =\n\t    (xsltStackElemPtr *) xmlMalloc(ctxt->varsMax *\n\t    sizeof(ctxt->varsTab[0]));\n\tif (ctxt->varsTab == NULL) {\n\t    xmlGenericError(xmlGenericErrorContext, \"malloc failed !\\n\");\n\t    return (-1);\n\t}\n    }\n    if (ctxt->varsNr >= ctxt->varsMax) {\n\tctxt->varsMax *= 2;\n\tctxt->varsTab =\n\t    (xsltStackElemPtr *) xmlRealloc(ctxt->varsTab,\n\t    ctxt->varsMax *\n\t    sizeof(ctxt->varsTab[0]));\n\tif (ctxt->varsTab == NULL) {\n\t    xmlGenericError(xmlGenericErrorContext, \"realloc failed !\\n\");\n\t    return (-1);\n\t}\n    }\n    ctxt->varsTab[ctxt->varsNr++] = variable;\n    ctxt->vars = variable;\n    variable->level = level;\n    return(0);\n}\n",
        "output": "0",
        "index": 170001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cypress_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irq(&priv->lock);\n\tpriv->rx_flags = THROTTLED;\n\tspin_unlock_irq(&priv->lock);\n}\n",
        "output": "0",
        "index": 54246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void BooleanAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueBool(info, impl->booleanAttribute());\n}\n",
        "output": "0",
        "index": 147210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (lds) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n",
        "output": "0",
        "index": 82913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n {\n \tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n \tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n \tint err;\n \n \tinode_lock_nested(dir, I_MUTEX_PARENT);\n \terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\t/* Don't let d_delete() think it can reset d_inode */\n\t\tdget(upper);\n \t\tif (is_dir)\n \t\t\terr = vfs_rmdir(dir, upper);\n \t\telse\n \t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n \t\tovl_dentry_version_inc(dentry->d_parent);\n \t}\n \n \t/*\n \t * Keeping this dentry hashed would mean having to release\n\t * upperpath/lowerpath, which could only be done if we are the\n\t * sole user of this dentry.  Too tricky...  Just unhash for\n\t * now.\n \t */\n \tif (!err)\n \t\td_drop(dentry);\n \tinode_unlock(dir);\n \n \treturn err;\n}\n",
        "output": "1",
        "index": 180186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!test_bit(VCPU_EXREG_PDPTR,\n\t\t      (unsigned long *)&vcpu->arch.regs_dirty))\n\t\treturn;\n\n\tif (is_paging(vcpu) && is_pae(vcpu) && !is_long_mode(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n",
        "output": "0",
        "index": 37039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "option_to_fd(mrb_state *mrb, mrb_value obj, const char *key)\n{\n  mrb_value opt = mrb_funcall(mrb, obj, \"[]\", 1, mrb_symbol_value(mrb_intern_static(mrb, key, strlen(key))));\n  if (mrb_nil_p(opt)) {\n    return -1;\n  }\n\n  switch (mrb_type(opt)) {\n    case MRB_TT_DATA: /* IO */\n      return (int)mrb_fixnum(mrb_io_fileno(mrb, opt));\n    case MRB_TT_FIXNUM:\n      return (int)mrb_fixnum(opt);\n    default:\n      mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong exec redirect action\");\n      break;\n  }\n  return -1; /* never reached */\n}\n",
        "output": "0",
        "index": 83166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " WebstoreBindings::WebstoreBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\",\n                 base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n }\n",
        "output": "1",
        "index": 186213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void EditorClientBlackBerry::learnWord(const WTF::String&)\n{\n    notImplemented();\n}\n",
        "output": "0",
        "index": 111702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScriptPromise WebGLRenderingContextBase::commit(\n    ScriptState* script_state,\n    ExceptionState& exception_state) {\n  WebFeature feature = WebFeature::kOffscreenCanvasCommitWebGL;\n  UseCounter::Count(ExecutionContext::From(script_state), feature);\n  int width = GetDrawingBuffer()->Size().Width();\n  int height = GetDrawingBuffer()->Size().Height();\n  if (!GetDrawingBuffer()) {\n    return Host()->Commit(nullptr, SkIRect::MakeWH(width, height), script_state,\n                          exception_state);\n  }\n\n  scoped_refptr<StaticBitmapImage> image = GetStaticBitmapImage();\n\n  return Host()->Commit(\n      std::move(image), SkIRect::MakeWH(width, height),\n      script_state, exception_state);\n}\n",
        "output": "0",
        "index": 159331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "String XMLHttpRequest::uppercaseKnownHTTPMethod(const String& method)\n{\n    if (equalIgnoringCase(method, \"COPY\") || equalIgnoringCase(method, \"DELETE\") || equalIgnoringCase(method, \"GET\")\n        || equalIgnoringCase(method, \"HEAD\") || equalIgnoringCase(method, \"INDEX\") || equalIgnoringCase(method, \"LOCK\")\n        || equalIgnoringCase(method, \"M-POST\") || equalIgnoringCase(method, \"MKCOL\") || equalIgnoringCase(method, \"MOVE\")\n        || equalIgnoringCase(method, \"OPTIONS\") || equalIgnoringCase(method, \"POST\") || equalIgnoringCase(method, \"PROPFIND\")\n        || equalIgnoringCase(method, \"PROPPATCH\") || equalIgnoringCase(method, \"PUT\") || equalIgnoringCase(method, \"UNLOCK\")) {\n        return method.upper();\n    }\n    return method;\n}\n",
        "output": "0",
        "index": 119218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool lockdep_rtnl_is_held(void)\n{\n\treturn lockdep_is_held(&rtnl_mutex);\n}\n",
        "output": "0",
        "index": 53127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tg3_get_5906_nvram_info(struct tg3 *tp)\n{\n\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n}\n",
        "output": "0",
        "index": 32550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipmi_destroy_user(struct ipmi_user *user)\n {\n \t_ipmi_destroy_user(user);\n \n\tcleanup_srcu_struct(&user->release_barrier);\n \tkref_put(&user->refcount, free_user);\n \n \treturn 0;\n}\n",
        "output": "1",
        "index": 182898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nid_cb(const char *elem, int len, void *arg)\n{\n    nid_cb_st *narg = arg;\n    size_t i;\n    int nid;\n    char etmp[20];\n    if (elem == NULL)\n        return 0;\n    if (narg->nidcnt == MAX_CURVELIST)\n        return 0;\n    if (len > (int)(sizeof(etmp) - 1))\n        return 0;\n    memcpy(etmp, elem, len);\n    etmp[len] = 0;\n    nid = EC_curve_nist2nid(etmp);\n    if (nid == NID_undef)\n        nid = OBJ_sn2nid(etmp);\n    if (nid == NID_undef)\n        nid = OBJ_ln2nid(etmp);\n    if (nid == NID_undef)\n        return 0;\n    for (i = 0; i < narg->nidcnt; i++)\n        if (narg->nid_arr[i] == nid)\n            return 0;\n    narg->nid_arr[narg->nidcnt++] = nid;\n    return 1;\n}\n",
        "output": "0",
        "index": 6133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CustomScrollableView() {}\n",
        "output": "0",
        "index": 144413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    virtual PassOwnPtr<CCLayerTreeHostImpl> createLayerTreeHostImpl()\n    {\n        return MockLayerTreeHostImpl::create(m_testHooks, settings());\n    }\n",
        "output": "0",
        "index": 102775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<ProxyLookupClientImpl> PreconnectManager::LookupProxyForUrl(\n    const GURL& url,\n    ProxyLookupCallback callback) const {\n  DCHECK(url.GetOrigin() == url);\n  DCHECK(url.SchemeIsHTTPOrHTTPS());\n\n  auto* network_context = GetNetworkContext();\n  if (!network_context) {\n    std::move(callback).Run(false);\n    return nullptr;\n  }\n\n  return std::make_unique<ProxyLookupClientImpl>(url, std::move(callback),\n                                                 network_context);\n}\n",
        "output": "0",
        "index": 149597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvp_release_lock(int pool)\n{\n\tstruct flock fl = {F_UNLCK, SEEK_SET, 0, 0, 0};\n\tfl.l_pid = getpid();\n\n\tif (fcntl(kvp_file_info[pool].fd, F_SETLK, &fl) == -1) {\n\t\tperror(\"fcntl\");\n\t\tsyslog(LOG_ERR, \"Failed to release the lock pool: %d\", pool);\n\t\texit(EXIT_FAILURE);\n\t}\n}\n",
        "output": "0",
        "index": 18476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FileSystemOperation::SyncGetPlatformPath(const GURL& path_url,\n                                              FilePath* platform_path) {\n  DCHECK(SetPendingOperationType(kOperationGetLocalPath));\n\n  base::PlatformFileError result = SetUpFileSystemPath(\n      path_url, &src_path_, &src_util_, PATH_FOR_READ);\n  if (result != base::PLATFORM_FILE_OK) {\n    delete this;\n    return;\n  }\n\n  src_util_->GetLocalFilePath(\n      &operation_context_, src_path_, platform_path);\n\n  delete this;\n}\n",
        "output": "0",
        "index": 111032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HostCache::Entry::Entry(const HostCache::Entry& entry,\n                        base::TimeTicks now,\n                        base::TimeDelta ttl,\n                        int network_changes)\n    : error_(entry.error()),\n      addresses_(entry.addresses()),\n      ttl_(entry.ttl()),\n      expires_(now + ttl),\n      network_changes_(network_changes),\n      total_hits_(0),\n      stale_hits_(0) {}\n",
        "output": "0",
        "index": 139344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\tif (pgoff > rb->nr_pages)\n\t\treturn NULL;\n\n\tif (pgoff == 0)\n\t\treturn virt_to_page(rb->user_page);\n\n\treturn virt_to_page(rb->data_pages[pgoff - 1]);\n}\n",
        "output": "0",
        "index": 26228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SCTP_STATIC void sctp_shutdown(struct sock *sk, int how)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\n\tif (!sctp_style(sk, TCP))\n\t\treturn;\n\n\tif (how & SEND_SHUTDOWN) {\n\t\tep = sctp_sk(sk)->ep;\n\t\tif (!list_empty(&ep->asocs)) {\n\t\t\tasoc = list_entry(ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 33065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item->type & 0xFF) == cJSON_Array;\n}\n",
        "output": "0",
        "index": 87079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebstoreAPI::OnBeginExtensionDownload(const std::string& extension_id) {\n  SendInstallMessageIfObserved(extension_id,\n                               api::webstore::INSTALL_STAGE_DOWNLOADING);\n}\n",
        "output": "0",
        "index": 142586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OomInterventionTabHelper::OomInterventionTabHelper(\n    content::WebContents* web_contents)\n    : content::WebContentsObserver(web_contents),\n      decider_(OomInterventionDecider::GetForBrowserContext(\n          web_contents->GetBrowserContext())),\n      binding_(this),\n      scoped_observer_(this),\n      weak_ptr_factory_(this) {\n  scoped_observer_.Add(crash_reporter::CrashMetricsReporter::GetInstance());\n}\n",
        "output": "0",
        "index": 143573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SSLManager::NotifySSLInternalStateChanged(\n    NavigationControllerImpl* controller) {\n  content::NotificationService::current()->Notify(\n      content::NOTIFICATION_SSL_INTERNAL_STATE_CHANGED,\n      content::Source<content::BrowserContext>(controller->GetBrowserContext()),\n      content::NotificationService::NoDetails());\n}\n",
        "output": "0",
        "index": 116208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t OggExtractor::countTracks() {\n return mInitCheck != OK ? 0 : 1;\n}\n",
        "output": "0",
        "index": 175348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceFetcher::reloadImagesIfNotDeferred()\n{\n    DocumentResourceMap::iterator end = m_documentResources.end();\n    for (DocumentResourceMap::iterator it = m_documentResources.begin(); it != end; ++it) {\n        Resource* resource = it->value.get();\n        if (resource->type() == Resource::Image && resource->stillNeedsLoad() && !clientDefersImage(resource->url()))\n            const_cast<Resource*>(resource)->load(this, defaultResourceOptions());\n    }\n}\n",
        "output": "0",
        "index": 129731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebBluetoothServiceImpl::NotifyCharacteristicValueChanged(\n    const std::string& characteristic_instance_id,\n    const std::vector<uint8_t>& value) {\n  auto iter =\n      characteristic_id_to_notify_session_.find(characteristic_instance_id);\n  if (iter != characteristic_id_to_notify_session_.end()) {\n    iter->second->characteristic_client->RemoteCharacteristicValueChanged(\n        value);\n   }\n }\n",
        "output": "0",
        "index": 150790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsControlKeyModifier(int flags) {\n#if defined(OS_LINUX)\n  return flags & ui::EF_CONTROL_DOWN;\n#else\n  return false;\n#endif\n}\n",
        "output": "0",
        "index": 137236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct inode *nfs_alloc_inode(struct super_block *sb)\n{\n\tstruct nfs_inode *node;\n\n\tnode = xzalloc(sizeof(*node));\n\tif (!node)\n\t\treturn NULL;\n\n\treturn &node->inode;\n}\n",
        "output": "0",
        "index": 1334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CrostiniUpgrader::CrostiniUpgrader(Profile* profile)\n    : profile_(profile), container_id_(\"\", \"\") {\n  CrostiniManager::GetForProfile(profile_)->AddUpgradeContainerProgressObserver(\n      this);\n}\n",
        "output": "0",
        "index": 149267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tg3_rx_prodring_free(struct tg3 *tp,\n\t\t\t\t struct tg3_rx_prodring_set *tpr)\n{\n\tint i;\n\n\tif (tpr != &tp->napi[0].prodring) {\n\t\tfor (i = tpr->rx_std_cons_idx; i != tpr->rx_std_prod_idx;\n\t\t     i = (i + 1) & tp->rx_std_ring_mask)\n\t\t\ttg3_rx_data_free(tp, &tpr->rx_std_buffers[i],\n\t\t\t\t\ttp->rx_pkt_map_sz);\n\n\t\tif (tg3_flag(tp, JUMBO_CAPABLE)) {\n\t\t\tfor (i = tpr->rx_jmb_cons_idx;\n\t\t\t     i != tpr->rx_jmb_prod_idx;\n\t\t\t     i = (i + 1) & tp->rx_jmb_ring_mask) {\n\t\t\t\ttg3_rx_data_free(tp, &tpr->rx_jmb_buffers[i],\n\t\t\t\t\t\tTG3_RX_JMB_MAP_SZ);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (i = 0; i <= tp->rx_std_ring_mask; i++)\n\t\ttg3_rx_data_free(tp, &tpr->rx_std_buffers[i],\n\t\t\t\ttp->rx_pkt_map_sz);\n\n\tif (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS)) {\n\t\tfor (i = 0; i <= tp->rx_jmb_ring_mask; i++)\n\t\t\ttg3_rx_data_free(tp, &tpr->rx_jmb_buffers[i],\n\t\t\t\t\tTG3_RX_JMB_MAP_SZ);\n\t}\n}\n",
        "output": "0",
        "index": 32734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void NotifyUpdatedActions() {\n    media_controls_view_->MediaSessionActionsChanged(\n        std::vector<MediaSessionAction>(actions_.begin(), actions_.end()));\n  }\n",
        "output": "0",
        "index": 149195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutUnit RenderFlexibleBox::mainAxisBorderAndPaddingExtentForChild(RenderBox* child) const\n{\n    return isHorizontalFlow() ? child->borderAndPaddingWidth() : child->borderAndPaddingHeight();\n}\n",
        "output": "0",
        "index": 125036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::DecrementCapturerCount() {\n  --capturer_count_;\n  DVLOG(1) << \"There are now \" << capturer_count_\n           << \" capturing(s) of WebContentsImpl@\" << this;\n  DCHECK_LE(0, capturer_count_);\n\n  if (is_being_destroyed_)\n    return;\n\n  if (capturer_count_ == 0) {\n    const gfx::Size old_size = preferred_size_for_capture_;\n    preferred_size_for_capture_ = gfx::Size();\n    OnPreferredSizeChanged(old_size);\n  }\n\n  if (IsHidden()) {\n    DVLOG(1) << \"Executing delayed WasHidden().\";\n    WasHidden();\n  }\n}\n",
        "output": "0",
        "index": 144466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void BookmarksIOFunction::ShowSelectFileDialog(\n     ui::SelectFileDialog::Type type,\n     const base::FilePath& default_path) {\n   AddRef();\n\n  WebContents* web_contents = dispatcher()->delegate()->\n      GetAssociatedWebContents();\n\n  select_file_dialog_ = ui::SelectFileDialog::Create(\n      this, new ChromeSelectFilePolicy(web_contents));\n  ui::SelectFileDialog::FileTypeInfo file_type_info;\n  file_type_info.extensions.resize(1);\n  file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\"));\n  if (type == ui::SelectFileDialog::SELECT_OPEN_FILE)\n    file_type_info.support_drive = true;\n  select_file_dialog_->SelectFile(type,\n                                  string16(),\n                                  default_path,\n                                  &file_type_info,\n                                  0,\n                                  FILE_PATH_LITERAL(\"\"),\n                                  NULL,\n                                  NULL);\n}\n",
        "output": "1",
        "index": 185133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_tracer_options(struct trace_array *tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__update_tracer_options(tr);\n\tmutex_unlock(&trace_types_lock);\n}\n",
        "output": "0",
        "index": 81547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_write_ctts_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    MOVMuxContext *mov = s->priv_data;\n    MOVStts *ctts_entries;\n    uint32_t entries = 0;\n    uint32_t atom_size;\n    int i;\n\n    ctts_entries = av_malloc_array((track->entry + 1), sizeof(*ctts_entries)); /* worst case */\n    if (!ctts_entries)\n        return AVERROR(ENOMEM);\n    ctts_entries[0].count = 1;\n    ctts_entries[0].duration = track->cluster[0].cts;\n    for (i = 1; i < track->entry; i++) {\n        if (track->cluster[i].cts == ctts_entries[entries].duration) {\n            ctts_entries[entries].count++; /* compress */\n        } else {\n            entries++;\n            ctts_entries[entries].duration = track->cluster[i].cts;\n            ctts_entries[entries].count = 1;\n        }\n    }\n    entries++; /* last one */\n    atom_size = 16 + (entries * 8);\n    avio_wb32(pb, atom_size); /* size */\n    ffio_wfourcc(pb, \"ctts\");\n    if (mov->flags & FF_MOV_FLAG_NEGATIVE_CTS_OFFSETS)\n        avio_w8(pb, 1); /* version */\n    else\n        avio_w8(pb, 0); /* version */\n    avio_wb24(pb, 0); /* flags */\n    avio_wb32(pb, entries); /* entry count */\n    for (i = 0; i < entries; i++) {\n        avio_wb32(pb, ctts_entries[i].count);\n        avio_wb32(pb, ctts_entries[i].duration);\n    }\n    av_free(ctts_entries);\n    return atom_size;\n}\n",
        "output": "0",
        "index": 79336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool btif_get_device_type(const BD_ADDR bd_addr, int *p_device_type)\n{\n if (p_device_type == NULL)\n return FALSE;\n\n bt_bdaddr_t bda;\n    bdcpy(bda.address, bd_addr);\n\n bdstr_t bd_addr_str;\n    bdaddr_to_string(&bda, bd_addr_str, sizeof(bd_addr_str));\n\n if (!btif_config_get_int(bd_addr_str, \"DevType\", p_device_type))\n return FALSE;\n\n    LOG_DEBUG(LOG_TAG, \"%s: Device [%s] type %d\", __FUNCTION__, bd_addr_str, *p_device_type);\n return TRUE;\n}\n",
        "output": "0",
        "index": 174785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMXCodec::~OMXCodec() {\n    mSource.clear();\n\n    CHECK(mState == LOADED || mState == ERROR || mState == LOADED_TO_IDLE);\n\n status_t err = mOMX->freeNode(mNode);\n    CHECK_EQ(err, (status_t)OK);\n\n    mNode = 0;\n    setState(DEAD);\n\n    clearCodecSpecificData();\n\n    free(mComponentName);\n    mComponentName = NULL;\n\n    free(mMIME);\n    mMIME = NULL;\n}\n",
        "output": "0",
        "index": 171385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long tun_get_vnet_be(struct tun_struct *tun, int __user *argp)\n{\n\tint be = !!(tun->flags & TUN_VNET_BE);\n\n\tif (put_user(be, argp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 93299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setcos_create_file(sc_card_t *card, sc_file_t *file)\n{\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || SETCOS_IS_EID_APPLET(card))\n\t\treturn setcos_create_file_44(card, file);\n\n\tif (file->prop_attr_len == 0)\n\t\tsc_file_set_prop_attr(file, (const u8 *) \"\\x03\\x00\\x00\", 3);\n\tif (file->sec_attr_len == 0) {\n\t\tint idx[6], i;\n\t\tu8 buf[6];\n\n\t\tif (file->type == SC_FILE_TYPE_DF) {\n\t\t\tconst int df_idx[6] = {\n\t\t\t\tSC_AC_OP_SELECT, SC_AC_OP_LOCK, SC_AC_OP_DELETE,\n\t\t\t\tSC_AC_OP_CREATE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = df_idx[i];\n\t\t} else {\n\t\t\tconst int ef_idx[6] = {\n\t\t\t\tSC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE,\n\t\t\t\tSC_AC_OP_ERASE, SC_AC_OP_REHABILITATE,\n\t\t\t\tSC_AC_OP_INVALIDATE\n\t\t\t};\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tidx[i] = ef_idx[i];\n\t\t}\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tconst struct sc_acl_entry *entry;\n\t\t\tentry = sc_file_get_acl_entry(file, idx[i]);\n\t\t\tbuf[i] = acl_to_byte(entry);\n\t\t}\n\n\t\tsc_file_set_sec_attr(file, buf, 6);\n\t}\n\n\treturn iso_ops->create_file(card, file);\n}\n",
        "output": "0",
        "index": 78695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " int GlobalConfirmInfoBar::DelegateProxy::GetButtons() const {\n   return global_info_bar_ ? global_info_bar_->delegate_->GetButtons()\n                           : 0;\n}\n",
        "output": "0",
        "index": 167201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::scheduleTextTrackResourceLoad() {\n  BLINK_MEDIA_LOG << \"scheduleTextTrackResourceLoad(\" << (void*)this << \")\";\n\n  m_pendingActionFlags |= LoadTextTrackResource;\n\n  if (!m_loadTimer.isActive())\n    m_loadTimer.startOneShot(0, BLINK_FROM_HERE);\n}\n",
        "output": "0",
        "index": 140083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tfprintf(out, \"compno = %d; csty = 0x%02x; numdlvls = %d;\\n\",\n\t  coc->compno, coc->compparms.csty, coc->compparms.numdlvls);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x; qmfbid = %d;\\n\", coc->compparms.cblkwidthval,\n\t  coc->compparms.cblkheightval, coc->compparms.cblksty, coc->compparms.qmfbid);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 73216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    CompleteGetFileProperties(drive::FileError error) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(0 <= processed_count_ && processed_count_ < properties_list_.size());\n\n  processed_count_++;\n  if (processed_count_ < properties_list_.size())\n    return;\n\n  results_ = extensions::api::file_browser_private::GetDriveEntryProperties::\n      Results::Create(properties_list_);\n  SendResponse(true);\n}\n",
        "output": "0",
        "index": 120013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dm_target_io *alloc_tio(struct clone_info *ci,\n\t\t\t\t      struct dm_target *ti,\n\t\t\t\t      unsigned target_bio_nr)\n{\n\tstruct dm_target_io *tio;\n\tstruct bio *clone;\n\n\tclone = bio_alloc_bioset(GFP_NOIO, 0, ci->md->bs);\n\ttio = container_of(clone, struct dm_target_io, clone);\n\n\ttio->io = ci->io;\n\ttio->ti = ti;\n\ttio->target_bio_nr = target_bio_nr;\n\n\treturn tio;\n}\n",
        "output": "0",
        "index": 85858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool EditorClientBlackBerry::shouldEraseMarkersAfterChangeSelection(TextCheckingType) const\n{\n    return true;\n}\n",
        "output": "0",
        "index": 111716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_SANGW( INS_ARG )\n  {\n    /* instruction not supported anymore */\n  }\n",
        "output": "0",
        "index": 10159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)\n{\n    const char* cLabelFld;\n    char Type[256], Label[256];\n    cmsUInt32Number nTable;\n\n    _cmsAssert(hIT8 != NULL);\n\n    if (cField != NULL && *cField == 0)\n            cField = \"LABEL\";\n\n    if (cField == NULL)\n            cField = \"LABEL\";\n\n    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);\n    if (!cLabelFld) return -1;\n\n    if (sscanf(cLabelFld, \"%255s %u %255s\", Label, &nTable, Type) != 3)\n            return -1;\n\n    if (ExpectedType != NULL && *ExpectedType == 0)\n        ExpectedType = NULL;\n\n    if (ExpectedType) {\n\n        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;\n    }\n\n    return cmsIT8SetTable(hIT8, nTable);\n}\n",
        "output": "0",
        "index": 78090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPage::clearLocalStorage()\n{\n    if (PageGroup* group = d->m_page->groupPtr()) {\n        if (StorageNamespace* storage = group->localStorage())\n            storage->clearAllOriginsForDeletion();\n    }\n}\n",
        "output": "0",
        "index": 111090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msix_sparse_mmap_cap(struct vfio_pci_device *vdev,\n\t\t\t\tstruct vfio_info_cap *caps)\n{\n\tstruct vfio_info_cap_header *header;\n\tstruct vfio_region_info_cap_sparse_mmap *sparse;\n\tsize_t end, size;\n\tint nr_areas = 2, i = 0;\n\n\tend = pci_resource_len(vdev->pdev, vdev->msix_bar);\n\n\t/* If MSI-X table is aligned to the start or end, only one area */\n\tif (((vdev->msix_offset & PAGE_MASK) == 0) ||\n\t    (PAGE_ALIGN(vdev->msix_offset + vdev->msix_size) >= end))\n\t\tnr_areas = 1;\n\n\tsize = sizeof(*sparse) + (nr_areas * sizeof(*sparse->areas));\n\n\theader = vfio_info_cap_add(caps, size,\n\t\t\t\t   VFIO_REGION_INFO_CAP_SPARSE_MMAP, 1);\n\tif (IS_ERR(header))\n\t\treturn PTR_ERR(header);\n\n\tsparse = container_of(header,\n\t\t\t      struct vfio_region_info_cap_sparse_mmap, header);\n\tsparse->nr_areas = nr_areas;\n\n\tif (vdev->msix_offset & PAGE_MASK) {\n\t\tsparse->areas[i].offset = 0;\n\t\tsparse->areas[i].size = vdev->msix_offset & PAGE_MASK;\n\t\ti++;\n\t}\n\n\tif (PAGE_ALIGN(vdev->msix_offset + vdev->msix_size) < end) {\n\t\tsparse->areas[i].offset = PAGE_ALIGN(vdev->msix_offset +\n\t\t\t\t\t\t     vdev->msix_size);\n\t\tsparse->areas[i].size = end - sparse->areas[i].offset;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 48577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void TIFFSetEXIFProperties(TIFF *tiff,Image *image)\n{\n#if defined(MAGICKCORE_HAVE_TIFFREADEXIFDIRECTORY)\n  const char\n    *value;\n\n  register ssize_t\n    i;\n\n  uint32\n    offset;\n\n  /*\n    Write EXIF properties.\n  */\n  offset=0;\n  (void) TIFFSetField(tiff,TIFFTAG_SUBIFD,1,&offset);\n  for (i=0; exif_info[i].tag != 0; i++)\n  {\n    value=GetImageProperty(image,exif_info[i].property);\n    if (value == (const char *) NULL)\n      continue;\n    switch (exif_info[i].type)\n    {\n      case TIFF_ASCII:\n      {\n        (void) TIFFSetField(tiff,exif_info[i].tag,value);\n        break;\n      }\n      case TIFF_SHORT:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_LONG:\n      {\n        uint16\n          field;\n\n        field=(uint16) StringToLong(value);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      case TIFF_RATIONAL:\n      case TIFF_SRATIONAL:\n      {\n        float\n          field;\n\n        field=StringToDouble(value,(char **) NULL);\n        (void) TIFFSetField(tiff,exif_info[i].tag,field);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  /* (void) TIFFSetField(tiff,TIFFTAG_EXIFIFD,offset); */\n#else\n  (void) tiff;\n  (void) image;\n#endif\n}\n",
        "output": "0",
        "index": 69082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 47921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPage::setScreenOrientation(int orientation)\n{\n    d->m_pendingOrientation = orientation;\n}\n",
        "output": "0",
        "index": 111366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t smb2cli_conn_max_write_size(struct smbXcli_conn *conn)\n{\n\treturn conn->smb2.server.max_write_size;\n}\n",
        "output": "0",
        "index": 2435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataCache::Remove(const std::string& resource_id,\n                        base::PlatformFileError* error) {\n  AssertOnSequencedWorkerPool();\n  DCHECK(error);\n\n  scoped_ptr<CacheEntry> cache_entry =\n      GetCacheEntry(resource_id, std::string());\n\n  if (!cache_entry.get() ||\n      cache_entry->IsDirty() ||\n      cache_entry->IsMounted()) {\n    DVLOG(1) << \"Entry is \"\n             << (cache_entry.get() ?\n                 (cache_entry->IsDirty() ? \"dirty\" : \"mounted\") :\n                 \"non-existent\")\n             << \" in cache, not removing\";\n    *error = base::PLATFORM_FILE_OK;\n    return;\n  }\n\n  std::vector<FilePath> paths_to_delete;\n\n  paths_to_delete.push_back(GetCacheFilePath(resource_id,\n                                             util::kWildCard,\n                                             CACHE_TYPE_PERSISTENT,\n                                             CACHED_FILE_FROM_SERVER));\n  paths_to_delete.push_back(GetCacheFilePath(resource_id,\n                                             util::kWildCard,\n                                             CACHE_TYPE_TMP,\n                                             CACHED_FILE_FROM_SERVER));\n\n  paths_to_delete.push_back(GetCacheFilePath(resource_id,\n                                             std::string(),\n                                             CACHE_TYPE_PINNED,\n                                             CACHED_FILE_FROM_SERVER));\n\n  FilePath path_to_keep = GetCacheFilePath(resource_id,\n                                           std::string(),\n                                           CACHE_TYPE_PERSISTENT,\n                                           CACHED_FILE_LOCALLY_MODIFIED);\n\n  for (size_t i = 0; i < paths_to_delete.size(); ++i) {\n    DeleteFilesSelectively(paths_to_delete[i], path_to_keep);\n  }\n\n  metadata_->RemoveFromCache(resource_id);\n\n  *error = base::PLATFORM_FILE_OK;\n}\n",
        "output": "0",
        "index": 112894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool venc_dev::venc_set_session_priority(OMX_U32 priority) {\n struct v4l2_control control;\n\n    control.id = V4L2_CID_MPEG_VIDC_VIDEO_PRIORITY;\n switch(priority) {\n case 0:\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_ENABLE;\n break;\n case 1:\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;\n break;\n default:\n            priority = 1;\n            control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;\n            DEBUG_PRINT_ERROR(\"Unsupported priority level %u\", priority);\n break;\n }\n\n if (ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control)) {\n        DEBUG_PRINT_ERROR(\"Failed to set V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_%s\",\n                priority == 0 ? \"ENABLE\" : \"DISABLE\");\n return false;\n }\n\n    sess_priority.priority = priority;\n\n    DEBUG_PRINT_LOW(\"Success IOCTL set control for id=%x, val=%d\",\n            control.id, control.value);\n return true;\n}\n",
        "output": "0",
        "index": 172479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void append_msg_id(struct strbuf *sb, const char *msg_id)\n{\n\tfor (;;) {\n\t\tchar c = *(msg_id)++;\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (c != '_')\n\t\t\tstrbuf_addch(sb, tolower(c));\n\t\telse {\n\t\t\tassert(*msg_id);\n\t\t\tstrbuf_addch(sb, *(msg_id)++);\n\t\t}\n\t}\n\n\tstrbuf_addstr(sb, \": \");\n}\n",
        "output": "0",
        "index": 76599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPB_URLLoader_Impl::SaveResponse(const WebURLResponse& response) {\n  scoped_refptr<PPB_URLResponseInfo_Impl> response_info(\n      new PPB_URLResponseInfo_Impl(pp_instance()));\n  if (response_info->Initialize(response))\n    response_info_ = response_info;\n}\n",
        "output": "0",
        "index": 108688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string GenerateGetUserMediaWithMandatorySourceID(\n    const std::string& function_name,\n    const std::string& audio_source_id,\n    const std::string& video_source_id) {\n  const std::string audio_constraint =\n      \"audio: {mandatory: { sourceId:\\\"\" + audio_source_id + \"\\\"}}, \";\n\n  const std::string video_constraint =\n      \"video: {mandatory: { sourceId:\\\"\" + video_source_id + \"\\\"}}\";\n  return function_name + \"({\" + audio_constraint + video_constraint + \"});\";\n}\n",
        "output": "0",
        "index": 139278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DownloadItemImpl::SetTotalBytes(int64 total_bytes) {\n  total_bytes_ = total_bytes;\n}\n",
        "output": "0",
        "index": 113104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CopyKeyNamesInfoToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    /* This function trashes keymap on error, but that's OK. */\n    if (!CopyKeyNamesToKeymap(keymap, info) ||\n        !CopyKeyAliasesToKeymap(keymap, info) ||\n        !CopyLedNamesToKeymap(keymap, info))\n        return false;\n\n    keymap->keycodes_section_name = strdup_safe(info->name);\n    XkbEscapeMapName(keymap->keycodes_section_name);\n    return true;\n}\n",
        "output": "0",
        "index": 78961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_recipients (engine_uiserver_t uiserver, gpgme_key_t recp[])\n{\n  gpgme_error_t err = 0;\n  assuan_context_t ctx = uiserver->assuan_ctx;\n  char *line;\n  int linelen;\n  int invalid_recipients = 0;\n  int i;\n\n  linelen = 10 + 40 + 1;\t/* \"RECIPIENT \" + guess + '\\0'.  */\n  line = malloc (10 + 40 + 1);\n  if (!line)\n    return gpg_error_from_syserror ();\n  strcpy (line, \"RECIPIENT \");\n  for (i=0; !err && recp[i]; i++)\n    {\n      char *uid;\n      int newlen;\n\n      /* We use only the first user ID of the key.  */\n      if (!recp[i]->uids || !(uid=recp[i]->uids->uid) || !*uid)\n\t{\n\t  invalid_recipients++;\n\t  continue;\n\t}\n\n      newlen = 11 + strlen (uid);\n      if (linelen < newlen)\n\t{\n\t  char *newline = realloc (line, newlen);\n\t  if (! newline)\n\t    {\n\t      int saved_err = gpg_error_from_syserror ();\n\t      free (line);\n\t      return saved_err;\n\t    }\n\t  line = newline;\n\t  linelen = newlen;\n\t}\n      /* FIXME: need to do proper escaping  */\n      strcpy (&line[10], uid);\n\n      err = uiserver_assuan_simple_command (ctx, line, uiserver->status.fnc,\n                                            uiserver->status.fnc_value);\n      /* FIXME: This might requires more work.  */\n      if (gpg_err_code (err) == GPG_ERR_NO_PUBKEY)\n\tinvalid_recipients++;\n      else if (err)\n\t{\n\t  free (line);\n\t  return err;\n\t}\n    }\n  free (line);\n  return gpg_error (invalid_recipients\n\t\t    ? GPG_ERR_UNUSABLE_PUBKEY : GPG_ERR_NO_ERROR);\n}\n",
        "output": "0",
        "index": 12294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WallpaperManager::GetAppropriateResolution() {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  gfx::Size size = ash::WallpaperController::GetMaxDisplaySizeInNative();\n  return (size.width() > wallpaper::kSmallWallpaperMaxWidth ||\n          size.height() > wallpaper::kSmallWallpaperMaxHeight)\n             ? WALLPAPER_RESOLUTION_LARGE\n             : WALLPAPER_RESOLUTION_SMALL;\n}\n",
        "output": "0",
        "index": 138876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PromoResourceService::ScheduleNotification(double promo_start,\n                                                double promo_end) {\n  if (promo_start > 0 && promo_end > 0) {\n    const int64 ms_until_start =\n        static_cast<int64>((base::Time::FromDoubleT(\n            promo_start) - base::Time::Now()).InMilliseconds());\n    const int64 ms_until_end =\n        static_cast<int64>((base::Time::FromDoubleT(\n            promo_end) - base::Time::Now()).InMilliseconds());\n    if (ms_until_start > 0) {\n       PostNotification(ms_until_start);\n     } else if (ms_until_end > 0) {\n       if (ms_until_start <= 0) {\n         PostNotification(0);\n       }\n       PostNotification(ms_until_end);\n     }\n   }\n }\n",
        "output": "1",
        "index": 184358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_main_lib_open(gs_main_instance * minst, const char *file_name, ref * pfile)\n{\n    /* This is a separate procedure only to avoid tying up */\n    /* extra stack space while running the file. */\n    i_ctx_t *i_ctx_p = minst->i_ctx_p;\n#define maxfn 2048\n    char fn[maxfn];\n    uint len;\n\n    return lib_file_open(&minst->lib_path, imemory,\n                         NULL, /* Don't check permissions here, because permlist\n                                  isn't ready running init files. */\n                          file_name, strlen(file_name), fn, maxfn, &len, pfile);\n}\n",
        "output": "0",
        "index": 2902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "scoped_ptr<LayerTreeHost> LayerTreeHost::CreateSingleThreaded(\n    LayerTreeHostClient* client,\n    LayerTreeHostSingleThreadClient* single_thread_client,\n    SharedBitmapManager* manager,\n    const LayerTreeSettings& settings) {\n  scoped_ptr<LayerTreeHost> layer_tree_host(\n      new LayerTreeHost(client, manager, settings));\n  layer_tree_host->InitializeSingleThreaded(single_thread_client);\n  return layer_tree_host.Pass();\n}\n",
        "output": "0",
        "index": 120215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "exsltCryptoBin2Hex (const unsigned char *bin, int binlen,\n\t\t    unsigned char *hex, int hexlen) {\n    static const char bin2hex[] = { '0', '1', '2', '3',\n\t'4', '5', '6', '7',\n\t'8', '9', 'a', 'b',\n\t'c', 'd', 'e', 'f'\n    };\n\n    unsigned char lo, hi;\n    int i, pos;\n    for (i = 0, pos = 0; (i < binlen && pos < hexlen); i++) {\n\tlo = bin[i] & 0xf;\n\thi = bin[i] >> 4;\n\thex[pos++] = bin2hex[hi];\n\thex[pos++] = bin2hex[lo];\n    }\n\n    hex[pos] = '\\0';\n}\n",
        "output": "0",
        "index": 169734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual status_t setInputSurface(\n            node_id node, OMX_U32 port_index,\n const sp<IGraphicBufferConsumer> &bufferConsumer, MetadataBufferType *type) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n status_t err;\n        data.writeInt32((int32_t)node);\n        data.writeInt32(port_index);\n        data.writeStrongBinder(IInterface::asBinder(bufferConsumer));\n\n        err = remote()->transact(SET_INPUT_SURFACE, data, &reply);\n\n if (err != OK) {\n            ALOGW(\"binder transaction failed: %d\", err);\n return err;\n }\n\n int negotiatedType = reply.readInt32();\n if (type != NULL) {\n *type = (MetadataBufferType)negotiatedType;\n }\n\n return reply.readInt32();\n }\n",
        "output": "0",
        "index": 173863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_io_close(mrb_state *mrb, mrb_value self)\n{\n  struct mrb_io *fptr;\n  fptr = io_get_open_fptr(mrb, self);\n  fptr_finalize(mrb, fptr, FALSE);\n  return mrb_nil_value();\n}\n",
        "output": "0",
        "index": 83139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGL2RenderingContextBase::ValidateTexStorage(\n    const char* function_name,\n    GLenum target,\n    GLsizei levels,\n    GLenum internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    TexStorageType function_type) {\n  if (function_type == kTexStorageType2D) {\n    if (target != GL_TEXTURE_2D && target != GL_TEXTURE_CUBE_MAP) {\n      SynthesizeGLError(GL_INVALID_ENUM, function_name, \"invalid 2D target\");\n      return false;\n    }\n  } else {\n    if (target != GL_TEXTURE_3D && target != GL_TEXTURE_2D_ARRAY) {\n      SynthesizeGLError(GL_INVALID_ENUM, function_name, \"invalid 3D target\");\n      return false;\n    }\n  }\n\n  if (function_type == kTexStorageType3D && target != GL_TEXTURE_2D_ARRAY &&\n      compressed_texture_formats_etc2eac_.find(internalformat) !=\n          compressed_texture_formats_etc2eac_.end()) {\n    SynthesizeGLError(\n        GL_INVALID_OPERATION, function_name,\n        \"target for ETC2/EAC internal formats must be TEXTURE_2D_ARRAY\");\n    return false;\n  }\n\n  if (supported_internal_formats_storage_.find(internalformat) ==\n          supported_internal_formats_storage_.end() &&\n      (function_type == kTexStorageType2D &&\n       !compressed_texture_formats_.Contains(internalformat))) {\n    SynthesizeGLError(GL_INVALID_ENUM, function_name, \"invalid internalformat\");\n    return false;\n  }\n\n  if (width <= 0 || height <= 0 || depth <= 0) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid dimensions\");\n    return false;\n  }\n\n  if (levels <= 0) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid levels\");\n    return false;\n  }\n\n  if (target == GL_TEXTURE_3D) {\n    if (levels > log2(std::max(std::max(width, height), depth)) + 1) {\n      SynthesizeGLError(GL_INVALID_OPERATION, function_name, \"to many levels\");\n      return false;\n    }\n  } else {\n    if (levels > log2(std::max(width, height)) + 1) {\n      SynthesizeGLError(GL_INVALID_OPERATION, function_name, \"to many levels\");\n      return false;\n    }\n  }\n\n  return true;\n}\n",
        "output": "0",
        "index": 146038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::RemoveFromTopLayer(Element* element) {\n  if (!element->IsInTopLayer())\n    return;\n  wtf_size_t position = top_layer_elements_.Find(element);\n  DCHECK_NE(position, kNotFound);\n  top_layer_elements_.EraseAt(position);\n  element->SetIsInTopLayer(false);\n}\n",
        "output": "0",
        "index": 141200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct file *get_mm_exe_file(struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\trcu_read_lock();\n\texe_file = rcu_dereference(mm->exe_file);\n\tif (exe_file && !get_file_rcu(exe_file))\n\t\texe_file = NULL;\n\trcu_read_unlock();\n\treturn exe_file;\n}\n",
        "output": "0",
        "index": 59284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = vcpu->arch.cr3;\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 41361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlBufBackToBuffer(xmlBufPtr buf) {\n    xmlBufferPtr ret;\n\n    if ((buf == NULL) || (buf->error))\n        return(NULL);\n    CHECK_COMPAT(buf)\n    if (buf->buffer == NULL) {\n        xmlBufFree(buf);\n        return(NULL);\n    }\n\n    ret = buf->buffer;\n    /*\n     * What to do in case of error in the buffer ???\n     */\n    if (buf->use > INT_MAX) {\n        /*\n         * Worse case, we really allocated and used more than the\n         * maximum allowed memory for an xmlBuffer on this architecture.\n         * Keep the buffer but provide a truncated size value.\n         */\n        xmlBufOverflowError(buf, \"Used size too big for xmlBuffer\");\n        ret->use = INT_MAX;\n        ret->size = INT_MAX;\n    } else if (buf->size > INT_MAX) {\n        /*\n         * milder case, we allocated more than the maximum allowed memory\n         * for an xmlBuffer on this architecture, but used less than the\n         * limit.\n         * Keep the buffer but provide a truncated size value.\n         */\n        xmlBufOverflowError(buf, \"Allocated size too big for xmlBuffer\");\n        ret->size = INT_MAX;\n    }\n    ret->use = (int) buf->use;\n    ret->size = (int) buf->size;\n    ret->alloc = buf->alloc;\n    ret->content = buf->content;\n    ret->contentIO = buf->contentIO;\n    xmlFree(buf);\n    return(ret);\n}\n",
        "output": "0",
        "index": 163659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual bool Visit(RenderView* render_view) {\n    ExtensionHelper* helper = ExtensionHelper::Get(render_view);\n    if (!ViewTypeMatches(helper->view_type(), view_type_))\n      return true;\n\n    GURL url = render_view->webview()->mainFrame()->document().url();\n    if (!url.SchemeIs(chrome::kExtensionScheme))\n      return true;\n    const std::string& extension_id = url.host();\n    if (extension_id != extension_id_)\n      return true;\n\n    if (browser_window_id_ != extension_misc::kUnknownWindowId &&\n        helper->browser_window_id() != browser_window_id_) {\n      return true;\n    }\n\n    v8::Local<v8::Context> context =\n        render_view->webview()->mainFrame()->mainWorldScriptContext();\n    if (!context.IsEmpty()) {\n      v8::Local<v8::Value> window = context->Global();\n      DCHECK(!window.IsEmpty());\n\n      if (!OnMatchedView(window))\n        return false;\n    }\n    return true;\n  }\n",
        "output": "0",
        "index": 104700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_ssp_fifo_update(PXA2xxSSPState *s)\n{\n    s->sssr &= ~(0xf << 12);\t/* Clear RFL */\n    s->sssr &= ~(0xf << 8);\t/* Clear TFL */\n    s->sssr &= ~SSSR_TFS;\n    s->sssr &= ~SSSR_TNF;\n    if (s->enable) {\n        s->sssr |= ((s->rx_level - 1) & 0xf) << 12;\n        if (s->rx_level >= SSCR1_RFT(s->sscr[1]))\n            s->sssr |= SSSR_RFS;\n        else\n            s->sssr &= ~SSSR_RFS;\n        if (s->rx_level)\n            s->sssr |= SSSR_RNE;\n        else\n            s->sssr &= ~SSSR_RNE;\n        /* TX FIFO is never filled, so it is always in underrun\n           condition if SSP is enabled */\n        s->sssr |= SSSR_TFS;\n        s->sssr |= SSSR_TNF;\n    }\n\n    pxa2xx_ssp_int_update(s);\n}\n",
        "output": "0",
        "index": 15698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct tty_struct *tty_pair_get_pty(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->driver->subtype == PTY_TYPE_MASTER)\n\t    return tty;\n\treturn tty->link;\n}\n",
        "output": "0",
        "index": 58764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OmniboxViewWin::SetFocus() {\n  ::SetFocus(m_hWnd);\n}\n",
        "output": "0",
        "index": 115282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void do_ov(struct pt_regs *regs)\n{\n\tsiginfo_t info;\n\n\tdie_if_kernel(\"Integer overflow\", regs);\n\n\tinfo.si_code = FPE_INTOVF;\n\tinfo.si_signo = SIGFPE;\n\tinfo.si_errno = 0;\n\tinfo.si_addr = (void __user *) regs->cp0_epc;\n\tforce_sig_info(SIGFPE, &info, current);\n}\n",
        "output": "0",
        "index": 25399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int32_t BackendImpl::GetCurrentEntryId() const {\n  return data_->header.this_id;\n}\n",
        "output": "0",
        "index": 160038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QuicStreamHost::OnRemoteReset() {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  PostCrossThreadTask(\n      *proxy_thread(), FROM_HERE,\n      CrossThreadBind(&QuicStreamProxy::OnRemoteReset, stream_proxy_));\n  Delete();\n}\n",
        "output": "0",
        "index": 145452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(setpgid, pid_t, pid, pid_t, pgid)\n{\n\tstruct task_struct *p;\n\tstruct task_struct *group_leader = current->group_leader;\n\tstruct pid *pgrp;\n\tint err;\n\n\tif (!pid)\n\t\tpid = task_pid_vnr(group_leader);\n\tif (!pgid)\n\t\tpgid = pid;\n\tif (pgid < 0)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\n\t/* From this point forward we keep holding onto the tasklist lock\n\t * so that our parent does not change from under us. -DaveM\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\terr = -ESRCH;\n\tp = find_task_by_vpid(pid);\n\tif (!p)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (!thread_group_leader(p))\n\t\tgoto out;\n\n\tif (same_thread_group(p->real_parent, group_leader)) {\n\t\terr = -EPERM;\n\t\tif (task_session(p) != task_session(group_leader))\n\t\t\tgoto out;\n\t\terr = -EACCES;\n\t\tif (p->did_exec)\n\t\t\tgoto out;\n\t} else {\n\t\terr = -ESRCH;\n\t\tif (p != group_leader)\n\t\t\tgoto out;\n\t}\n\n\terr = -EPERM;\n\tif (p->signal->leader)\n\t\tgoto out;\n\n\tpgrp = task_pid(p);\n\tif (pgid != pid) {\n\t\tstruct task_struct *g;\n\n\t\tpgrp = find_vpid(pgid);\n\t\tg = pid_task(pgrp, PIDTYPE_PGID);\n\t\tif (!g || task_session(g) != task_session(group_leader))\n\t\t\tgoto out;\n\t}\n\n\terr = security_task_setpgid(p, pgid);\n\tif (err)\n\t\tgoto out;\n\n\tif (task_pgrp(p) != pgrp)\n\t\tchange_pid(p, PIDTYPE_PGID, pgrp);\n\n\terr = 0;\nout:\n\t/* All paths lead to here, thus we are safe. -DaveM */\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\treturn err;\n}\n",
        "output": "0",
        "index": 21526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sit_tunnel_rcv(struct sk_buff *skb, u8 ipproto)\n{\n\tconst struct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tint sifindex;\n\n\tsifindex = netif_is_l3_master(skb->dev) ? IPCB(skb)->iif : 0;\n\n\tiph = ip_hdr(skb);\n\ttunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\t     iph->saddr, iph->daddr, sifindex);\n\tif (tunnel) {\n\t\tconst struct tnl_ptk_info *tpi;\n\n\t\tif (tunnel->parms.iph.protocol != ipproto &&\n\t\t    tunnel->parms.iph.protocol != 0)\n\t\t\tgoto drop;\n\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop;\n#if IS_ENABLED(CONFIG_MPLS)\n\t\tif (ipproto == IPPROTO_MPLS)\n\t\t\ttpi = &mplsip_tpi;\n\t\telse\n#endif\n\t\t\ttpi = &ipip_tpi;\n\t\tif (iptunnel_pull_header(skb, 0, tpi->proto, false))\n\t\t\tgoto drop;\n\t\treturn ip_tunnel_rcv(tunnel, skb, tpi, NULL, log_ecn_error);\n\t}\n\n\treturn 1;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 87725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AppCacheUpdateJob::FetchUrls() {\n  DCHECK(internal_state_ == DOWNLOADING);\n\n  while (pending_url_fetches_.size() < kMaxConcurrentUrlFetches &&\n         !urls_to_fetch_.empty()) {\n    UrlToFetch url_to_fetch = urls_to_fetch_.front();\n    urls_to_fetch_.pop_front();\n\n    AppCache::EntryMap::iterator it = url_file_list_.find(url_to_fetch.url);\n    DCHECK(it != url_file_list_.end());\n    AppCacheEntry& entry = it->second;\n    if (ShouldSkipUrlFetch(entry)) {\n      NotifyAllProgress(url_to_fetch.url);\n      ++url_fetches_completed_;\n    } else if (AlreadyFetchedEntry(url_to_fetch.url, entry.types())) {\n      NotifyAllProgress(url_to_fetch.url);\n      ++url_fetches_completed_;  // saved a URL request\n    } else if (!url_to_fetch.storage_checked &&\n               MaybeLoadFromNewestCache(url_to_fetch.url, entry)) {\n    } else {\n      URLFetcher* fetcher = new URLFetcher(\n          url_to_fetch.url, URLFetcher::URL_FETCH, this);\n      if (url_to_fetch.existing_response_info.get()) {\n        DCHECK(group_->newest_complete_cache());\n        AppCacheEntry* existing_entry =\n            group_->newest_complete_cache()->GetEntry(url_to_fetch.url);\n        DCHECK(existing_entry);\n        DCHECK(existing_entry->response_id() ==\n               url_to_fetch.existing_response_info->response_id());\n        fetcher->set_existing_response_headers(\n            url_to_fetch.existing_response_info->http_response_info()->headers\n                .get());\n        fetcher->set_existing_entry(*existing_entry);\n      }\n      fetcher->Start();\n      pending_url_fetches_.insert(\n          PendingUrlFetches::value_type(url_to_fetch.url, fetcher));\n    }\n  }\n}\n",
        "output": "0",
        "index": 135001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JSRetainPtr<JSStringRef> AccessibilityUIElement::rangeForPosition(int x, int y)\n{\n    return JSStringCreateWithCharacters(0, 0);\n}\n",
        "output": "0",
        "index": 113613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ip6_frag_init(struct inet_frag_queue *q, void *a)\n {\n \tstruct frag_queue *fq = container_of(q, struct frag_queue, q);\n\tstruct ip6_create_arg *arg = a;\n\n\tfq->id = arg->id;\n\tfq->user = arg->user;\n\tipv6_addr_copy(&fq->saddr, arg->src);\n\tipv6_addr_copy(&fq->daddr, arg->dst);\n}\n",
        "output": "0",
        "index": 18719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateFloatArray( double *numbers, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateFloat( numbers[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}\n",
        "output": "1",
        "index": 180445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GpuProcessHost::OnCommandBufferCreated(const int32 route_id) {\n  if (!create_command_buffer_requests_.empty()) {\n    CreateCommandBufferCallback callback =\n        create_command_buffer_requests_.front();\n    create_command_buffer_requests_.pop();\n    if (route_id == MSG_ROUTING_NONE)\n      CreateCommandBufferError(callback, route_id);\n    else\n      callback.Run(route_id);\n  }\n}\n",
        "output": "0",
        "index": 114202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "isis_clear_checksum_lifetime(void *header)\n{\n    struct isis_lsp_header *header_lsp = (struct isis_lsp_header *) header;\n\n    header_lsp->checksum[0] = 0;\n    header_lsp->checksum[1] = 0;\n    header_lsp->remaining_lifetime[0] = 0;\n    header_lsp->remaining_lifetime[1] = 0;\n}\n",
        "output": "0",
        "index": 62217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int netlink_capable(const struct socket *sock, unsigned int flag)\n{\n\treturn (nl_table[sock->sk->sk_protocol].flags & flag) ||\n\t\tns_capable(sock_net(sock->sk)->user_ns, CAP_NET_ADMIN);\n}\n",
        "output": "0",
        "index": 40519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "format_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)\n{\n    ds_put_format(s, \"%sdebug_recirc%s\", colors.value, colors.end);\n}\n",
        "output": "0",
        "index": 76920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pcnet_ioport_writew(void *opaque, uint32_t addr, uint32_t val)\n{\n    PCNetState *s = opaque;\n    pcnet_poll_timer(s);\n#ifdef PCNET_DEBUG_IO\n    printf(\"pcnet_ioport_writew addr=0x%08x val=0x%04x\\n\", addr, val);\n#endif\n    if (!BCR_DWIO(s)) {\n        switch (addr & 0x0f) {\n        case 0x00: /* RDP */\n            pcnet_csr_writew(s, s->rap, val);\n            break;\n        case 0x02:\n            s->rap = val & 0x7f;\n            break;\n        case 0x06:\n            pcnet_bcr_writew(s, s->rap, val);\n            break;\n        }\n    }\n    pcnet_update_irq(s);\n}\n",
        "output": "0",
        "index": 14522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserChildProcessHostImpl::OnMojoError(\n    base::WeakPtr<BrowserChildProcessHostImpl> process,\n    scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n    const std::string& error) {\n  if (!task_runner->BelongsToCurrentThread()) {\n    task_runner->PostTask(\n        FROM_HERE, base::BindOnce(&BrowserChildProcessHostImpl::OnMojoError,\n                                  process, task_runner, error));\n    return;\n  }\n  if (!process)\n    return;\n  HistogramBadMessageTerminated(\n      static_cast<ProcessType>(process->data_.process_type));\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableKillAfterBadIPC)) {\n    return;\n  }\n  LOG(ERROR) << \"Terminating child process for bad Mojo message: \" << error;\n\n  base::debug::ScopedCrashKeyString scoped_error_key(\n      bad_message::GetMojoErrorCrashKey(), error);\n  base::debug::DumpWithoutCrashing();\n  process->child_process_->GetProcess().Terminate(\n      RESULT_CODE_KILLED_BAD_MESSAGE, false);\n}\n",
        "output": "0",
        "index": 162033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int iwl_sta_tx_modify_enable_tid(struct iwl_priv *priv, int sta_id, int tid)\n{\n\tunsigned long flags;\n\tstruct iwl_addsta_cmd sta_cmd;\n\n\tlockdep_assert_held(&priv->shrd->mutex);\n\n\t/* Remove \"disable\" flag, to enable Tx for this TID */\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tpriv->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\n\tpriv->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\n\tpriv->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\n\tmemcpy(&sta_cmd, &priv->stations[sta_id].sta, sizeof(struct iwl_addsta_cmd));\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\n\treturn iwl_send_add_sta(priv, &sta_cmd, CMD_SYNC);\n}\n",
        "output": "0",
        "index": 94100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FloatRect DragController::ClippedSelection(const LocalFrame& frame) {\n  DCHECK(frame.View());\n  return DataTransfer::ClipByVisualViewport(\n      FloatRect(frame.Selection().UnclippedBoundsInDocument()), frame);\n}\n",
        "output": "0",
        "index": 165175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PixelBufferRasterWorkerPool::PixelBufferRasterWorkerPool(\n    ResourceProvider* resource_provider,\n    ContextProvider* context_provider,\n    size_t num_threads,\n    size_t max_transfer_buffer_usage_bytes)\n    : RasterWorkerPool(resource_provider, context_provider, num_threads),\n      shutdown_(false),\n      scheduled_raster_task_count_(0),\n      bytes_pending_upload_(0),\n      max_bytes_pending_upload_(max_transfer_buffer_usage_bytes),\n      has_performed_uploads_since_last_flush_(false),\n       check_for_completed_raster_tasks_pending_(false),\n       should_notify_client_if_no_tasks_are_pending_(false),\n       should_notify_client_if_no_tasks_required_for_activation_are_pending_(\n          false) {\n }\n",
        "output": "1",
        "index": 184954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NavigatorServiceWorker& NavigatorServiceWorker::from(Navigator& navigator)\n{\n    NavigatorServiceWorker* supplement = toNavigatorServiceWorker(navigator);\n    if (!supplement) {\n        supplement = new NavigatorServiceWorker(navigator);\n        provideTo(navigator, supplementName(), supplement);\n        if (navigator.frame() && navigator.frame()->securityContext()->securityOrigin()->canAccessServiceWorkers()) {\n            supplement->serviceWorker(ASSERT_NO_EXCEPTION);\n        }\n    }\n    return *supplement;\n}\n",
        "output": "0",
        "index": 137421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_SPOOL_PRINTER_INFO(\n\t\ttvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinter_cmd, NULL);\n\n\treturn offset;\n}\n",
        "output": "0",
        "index": 51991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void red_channel_client_send_empty_msg(RedChannelClient *rcc, PipeItem *base)\n{\n    EmptyMsgPipeItem *msg_pipe_item = SPICE_CONTAINEROF(base, EmptyMsgPipeItem, base);\n\n    red_channel_client_init_send_data(rcc, msg_pipe_item->msg, NULL);\n    red_channel_client_begin_send_message(rcc);\n}\n",
        "output": "0",
        "index": 2135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\tstruct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\n\treturn glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,\n\t\t\t\t     XTS_TWEAK_CAST(twofish_enc_blk),\n\t\t\t\t     &ctx->tweak_ctx, &ctx->crypt_ctx);\n}\n",
        "output": "0",
        "index": 47075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Scrollbar::setProportion(int visibleSize, int totalSize)\n{\n    if (visibleSize == m_visibleSize && totalSize == m_totalSize)\n        return;\n\n    m_visibleSize = visibleSize;\n    m_totalSize = totalSize;\n\n    updateThumbProportion();\n}\n",
        "output": "0",
        "index": 107403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static JSValueRef scalePageByCallback(JSContextRef context, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)\n{\n    if (argumentCount < 3)\n        return JSValueMakeUndefined(context);\n\n    float scaleFactor = JSValueToNumber(context, arguments[0], exception);\n    float x = JSValueToNumber(context, arguments[1], exception);\n    float y = JSValueToNumber(context, arguments[2], exception);\n\n    BlackBerry::WebKit::WebPage* page = BlackBerry::WebKit::DumpRenderTree::currentInstance()->page();\n    if (!page)\n        return JSValueMakeUndefined(context);\n\n    DumpRenderTreeSupport::scalePageBy(page, scaleFactor, x, y);\n\n    return JSValueMakeUndefined(context);\n}\n",
        "output": "0",
        "index": 111557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AutofillManager::OnFullCardRequestFailed() {\n  driver()->RendererShouldClearPreviewedForm();\n}\n",
        "output": "0",
        "index": 168069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int airo_get_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\tvwrq->disabled = 0;      /* Can't be disabled */\n\n\treadConfigRid(local, 1);\n\t/* Note : by default, display the min retry number */\n\tif((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\tvwrq->flags = IW_RETRY_LIFETIME;\n\t\tvwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;\n\t} else if((vwrq->flags & IW_RETRY_LONG)) {\n\t\tvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tvwrq->value = le16_to_cpu(local->config.longRetryLimit);\n\t} else {\n\t\tvwrq->flags = IW_RETRY_LIMIT;\n\t\tvwrq->value = le16_to_cpu(local->config.shortRetryLimit);\n\t\tif(local->config.shortRetryLimit != local->config.longRetryLimit)\n\t\t\tvwrq->flags |= IW_RETRY_SHORT;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 23961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, int dest, int dest_mode)\n{\n\tint result = 0;\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == 0)\n\t\t\t/* Physical mode. */\n\t\t\tresult = kvm_apic_match_physical_addr(target, dest);\n\t\telse\n\t\t\t/* Logical mode. */\n\t\t\tresult = kvm_apic_match_logical_addr(target, dest);\n\t\tbreak;\n\tcase APIC_DEST_SELF:\n\t\tresult = (target == source);\n\t\tbreak;\n\tcase APIC_DEST_ALLINC:\n\t\tresult = 1;\n\t\tbreak;\n\tcase APIC_DEST_ALLBUT:\n\t\tresult = (target != source);\n\t\tbreak;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n",
        "output": "0",
        "index": 28752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool GpuChannel::OnMessageReceived(const IPC::Message& message) {\n  if (log_messages_) {\n    DVLOG(1) << \"received message @\" << &message << \" on channel @\" << this\n             << \" with type \" << message.type();\n  }\n\n  if (message.routing_id() == MSG_ROUTING_CONTROL)\n    return OnControlMessageReceived(message);\n\n  if (message.type() == GpuCommandBufferMsg_GetStateFast::ID) {\n    if (processed_get_state_fast_) {\n      std::deque<IPC::Message*>::iterator point = deferred_messages_.begin();\n\n      while (point != deferred_messages_.end() &&\n             (*point)->type() == GpuCommandBufferMsg_GetStateFast::ID) {\n        ++point;\n      }\n\n      if (point != deferred_messages_.end()) {\n        ++point;\n      }\n\n      deferred_messages_.insert(point, new IPC::Message(message));\n    } else {\n      deferred_messages_.push_front(new IPC::Message(message));\n    }\n  } else {\n    deferred_messages_.push_back(new IPC::Message(message));\n  }\n\n  OnScheduled();\n\n  return true;\n}\n",
        "output": "0",
        "index": 114369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void Vp9Parser::UpdateSlots(const Vp9FrameHeader* fhdr) {\n   for (size_t i = 0; i < kVp9NumRefFrames; i++) {\n    if (fhdr->RefreshFlag(i)) {\n       ref_slots_[i].width = fhdr->width;\n       ref_slots_[i].height = fhdr->height;\n     }\n   }\n }\n",
        "output": "1",
        "index": 183546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayerService::AudioOutput::getTimestamp(AudioTimestamp &ts) const\n{\n Mutex::Autolock lock(mLock);\n if (mTrack == 0) return NO_INIT;\n return mTrack->getTimestamp(ts);\n}\n",
        "output": "0",
        "index": 171174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String& httpMethod, FrameLoadType loadType, const KURL& url)\n{\n    return (!isFormSubmission || equalIgnoringCase(httpMethod, HTTPNames::GET))\n        && loadType != FrameLoadTypeReload\n        && loadType != FrameLoadTypeReloadBypassingCache\n        && loadType != FrameLoadTypeReloadMainResource\n        && loadType != FrameLoadTypeBackForward\n        && url.hasFragmentIdentifier()\n        && equalIgnoringFragmentIdentifier(m_frame->document()->url(), url)\n        && !m_frame->document()->isFrameSet();\n}\n",
        "output": "0",
        "index": 142717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OutOfProcessInstance::Email(const std::string& to,\n                                 const std::string& cc,\n                                 const std::string& bcc,\n                                 const std::string& subject,\n                                 const std::string& body) {\n  pp::VarDictionary message;\n  message.Set(pp::Var(kType), pp::Var(kJSEmailType));\n  message.Set(pp::Var(kJSEmailTo),\n              pp::Var(net::EscapeUrlEncodedData(to, false)));\n  message.Set(pp::Var(kJSEmailCc),\n              pp::Var(net::EscapeUrlEncodedData(cc, false)));\n  message.Set(pp::Var(kJSEmailBcc),\n              pp::Var(net::EscapeUrlEncodedData(bcc, false)));\n  message.Set(pp::Var(kJSEmailSubject),\n              pp::Var(net::EscapeUrlEncodedData(subject, false)));\n  message.Set(pp::Var(kJSEmailBody),\n              pp::Var(net::EscapeUrlEncodedData(body, false)));\n  PostMessage(message);\n}\n",
        "output": "0",
        "index": 140610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 70434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void TabHelper::OnReenableComplete(int install_id,\n                                    int return_route_id,\n                                    ExtensionReenabler::ReenableResult result) {\n  extension_reenabler_.reset();\n   webstore_install::Result webstore_result = webstore_install::SUCCESS;\n   std::string error;\n  switch (result) {\n    case ExtensionReenabler::REENABLE_SUCCESS:\n      break;  // already set\n    case ExtensionReenabler::USER_CANCELED:\n      webstore_result = webstore_install::USER_CANCELLED;\n      error = \"User canceled install.\";\n      break;\n    case ExtensionReenabler::NOT_ALLOWED:\n      webstore_result = webstore_install::NOT_PERMITTED;\n      error = \"Install not permitted.\";\n      break;\n    case ExtensionReenabler::ABORTED:\n      webstore_result = webstore_install::ABORTED;\n      error = \"Aborted due to tab closing.\";\n       break;\n   }\n \n  OnInlineInstallComplete(install_id,\n                          return_route_id,\n                          result == ExtensionReenabler::REENABLE_SUCCESS,\n                          error,\n                           webstore_result);\n }\n",
        "output": "1",
        "index": 186048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GetEventFiltersToNotify(Window* target, EventFilters* filters) {\n  while (target) {\n    if (target->event_filter())\n      filters->push_back(target->event_filter());\n    target = target->parent();\n  }\n}\n",
        "output": "0",
        "index": 110875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SynchronizeVisualPropertiesMessageFilter::OnUpdatedFrameRectOnUI(\n    const gfx::Rect& rect) {\n  last_rect_ = rect;\n  if (!screen_space_rect_received_) {\n    screen_space_rect_received_ = true;\n    screen_space_rect_run_loop_->QuitWhenIdle();\n  }\n}\n",
        "output": "0",
        "index": 169289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ShellMainDelegate::RunProcess(\n    const std::string& process_type,\n    const MainFunctionParams& main_function_params) {\n  if (!process_type.empty())\n    return -1;\n\n#if !defined(OS_ANDROID)\n  std::unique_ptr<BrowserMainRunner> browser_runner_;\n#endif\n\n  base::trace_event::TraceLog::GetInstance()->set_process_name(\"Browser\");\n  base::trace_event::TraceLog::GetInstance()->SetProcessSortIndex(\n      kTraceEventBrowserProcessSortIndex);\n\n  browser_runner_.reset(BrowserMainRunner::Create());\n  base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();\n  return command_line.HasSwitch(switches::kRunWebTests) ||\n                 command_line.HasSwitch(switches::kCheckLayoutTestSysDeps)\n             ? LayoutTestBrowserMain(main_function_params, browser_runner_)\n             : ShellBrowserMain(main_function_params, browser_runner_);\n}\n",
        "output": "0",
        "index": 143736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HttpUtil::ParseRanges(const std::string& headers,\n                           std::vector<HttpByteRange>* ranges) {\n  std::string ranges_specifier;\n  HttpUtil::HeadersIterator it(headers.begin(), headers.end(), \"\\r\\n\");\n\n  while (it.GetNext()) {\n    if (!LowerCaseEqualsASCII(it.name(), \"range\"))\n      continue;\n    ranges_specifier = it.values();\n    break;\n  }\n\n  if (ranges_specifier.empty())\n    return false;\n\n  return ParseRangeHeader(ranges_specifier, ranges);\n}\n",
        "output": "0",
        "index": 100847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "connection_exit_begin_resolve(cell_t *cell, or_circuit_t *circ)\n{\n  edge_connection_t *dummy_conn;\n  relay_header_t rh;\n\n  assert_circuit_ok(TO_CIRCUIT(circ));\n  relay_header_unpack(&rh, cell->payload);\n  if (rh.length > RELAY_PAYLOAD_SIZE)\n    return -1;\n\n  /* This 'dummy_conn' only exists to remember the stream ID\n   * associated with the resolve request; and to make the\n   * implementation of dns.c more uniform.  (We really only need to\n   * remember the circuit, the stream ID, and the hostname to be\n   * resolved; but if we didn't store them in a connection like this,\n   * the housekeeping in dns.c would get way more complicated.)\n   */\n  dummy_conn = edge_connection_new(CONN_TYPE_EXIT, AF_INET);\n  dummy_conn->stream_id = rh.stream_id;\n  dummy_conn->base_.address = tor_strndup(\n                                       (char*)cell->payload+RELAY_HEADER_SIZE,\n                                       rh.length);\n  dummy_conn->base_.port = 0;\n  dummy_conn->base_.state = EXIT_CONN_STATE_RESOLVEFAILED;\n  dummy_conn->base_.purpose = EXIT_PURPOSE_RESOLVE;\n\n  dummy_conn->on_circuit = TO_CIRCUIT(circ);\n\n  /* send it off to the gethostbyname farm */\n  switch (dns_resolve(dummy_conn)) {\n    case -1: /* Impossible to resolve; a resolved cell was sent. */\n      /* Connection freed; don't touch it. */\n      return 0;\n    case 1: /* The result was cached; a resolved cell was sent. */\n      if (!dummy_conn->base_.marked_for_close)\n        connection_free(TO_CONN(dummy_conn));\n      return 0;\n    case 0: /* resolve added to pending list */\n      assert_circuit_ok(TO_CIRCUIT(circ));\n      break;\n  }\n  return 0;\n}\n",
        "output": "0",
        "index": 69922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_inq_push(struct sctp_inq *q, struct sctp_chunk *chunk)\n{\n\t/* Directly call the packet handling routine. */\n\tif (chunk->rcvr->dead) {\n\t\tsctp_chunk_free(chunk);\n\t\treturn;\n\t}\n\n\t/* We are now calling this either from the soft interrupt\n\t * or from the backlog processing.\n\t * Eventually, we should clean up inqueue to not rely\n\t * on the BH related data structures.\n\t */\n\tlist_add_tail(&chunk->list, &q->in_chunk_list);\n\tif (chunk->asoc)\n\t\tchunk->asoc->stats.ipackets++;\n\tq->immediate.func(&q->immediate);\n}\n",
        "output": "0",
        "index": 37327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n {\n \tstruct snd_ctl_elem_id id;\n \tunsigned int idx;\n \tint err = -EINVAL;\n \n \tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n \tcard->controls_count += kcontrol->count;\n \tkcontrol->id.numid = card->last_numid + 1;\n \tcard->last_numid += kcontrol->count;\n \tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n \t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n \treturn 0;\n \n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}\n",
        "output": "1",
        "index": 179464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fc_dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nents,\n\t\tenum dma_data_direction dir)\n{\n\tif (dev)\n\t\tdma_unmap_sg(dev, sg, nents, dir);\n}\n",
        "output": "0",
        "index": 93585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntRect Editor::FirstRectForRange(const EphemeralRange& range) const {\n  DCHECK(!GetFrame().GetDocument()->NeedsLayoutTreeUpdate());\n  DocumentLifecycle::DisallowTransitionScope disallow_transition(\n      GetFrame().GetDocument()->Lifecycle());\n\n  LayoutUnit extra_width_to_end_of_line;\n  DCHECK(range.IsNotNull());\n\n  IntRect start_caret_rect =\n      RenderedPosition(\n          CreateVisiblePosition(range.StartPosition()).DeepEquivalent(),\n          TextAffinity::kDownstream)\n          .AbsoluteRect(&extra_width_to_end_of_line);\n  if (start_caret_rect.IsEmpty())\n    return IntRect();\n\n  IntRect end_caret_rect =\n      RenderedPosition(\n          CreateVisiblePosition(range.EndPosition()).DeepEquivalent(),\n          TextAffinity::kUpstream)\n          .AbsoluteRect();\n  if (end_caret_rect.IsEmpty())\n    return IntRect();\n\n  if (start_caret_rect.Y() == end_caret_rect.Y()) {\n    return IntRect(\n        std::min(start_caret_rect.X(), end_caret_rect.X()),\n        start_caret_rect.Y(), abs(end_caret_rect.X() - start_caret_rect.X()),\n        std::max(start_caret_rect.Height(), end_caret_rect.Height()));\n  }\n\n  return IntRect(\n      start_caret_rect.X(), start_caret_rect.Y(),\n      (start_caret_rect.Width() + extra_width_to_end_of_line).ToInt(),\n      start_caret_rect.Height());\n}\n",
        "output": "0",
        "index": 135559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2Implementation::GenSyncTokenCHROMIUM(GLbyte* sync_token) {\n  ImplementationBase::GenSyncToken(sync_token);\n}\n",
        "output": "0",
        "index": 153653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsLocalhost(const std::string& host) {\n  if (host == \"localhost\" ||\n      host == \"localhost.localdomain\" ||\n      host == \"localhost6\" ||\n      host == \"localhost6.localdomain6\")\n    return true;\n\n  IPAddressNumber ip_number;\n  if (ParseIPLiteralToNumber(host, &ip_number)) {\n    size_t size = ip_number.size();\n    switch (size) {\n      case kIPv4AddressSize: {\n        IPAddressNumber localhost_prefix;\n        localhost_prefix.push_back(127);\n        for (int i = 0; i < 3; ++i) {\n          localhost_prefix.push_back(0);\n        }\n        return IPNumberMatchesPrefix(ip_number, localhost_prefix, 8);\n      }\n\n      case kIPv6AddressSize: {\n        struct in6_addr sin6_addr;\n        memcpy(&sin6_addr, &ip_number[0], kIPv6AddressSize);\n        return !!IN6_IS_ADDR_LOOPBACK(&sin6_addr);\n      }\n\n      default:\n        NOTREACHED();\n    }\n  }\n\n  return false;\n}\n",
        "output": "0",
        "index": 102424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BaseAudioContext::ContextDestroyed(ExecutionContext*) {\n  destination()->GetAudioDestinationHandler().ContextDestroyed();\n  Uninitialize();\n}\n",
        "output": "0",
        "index": 157417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DocumentLoader::DispatchLinkHeaderPreloads(\n    ViewportDescriptionWrapper* viewport,\n    LinkLoader::MediaPreloadPolicy media_policy) {\n  DCHECK_GE(state_, kCommitted);\n  LinkLoader::LoadLinksFromHeader(\n      GetResponse().HttpHeaderField(http_names::kLink), GetResponse().Url(),\n      *frame_, frame_->GetDocument(), NetworkHintsInterfaceImpl(),\n      LinkLoader::kOnlyLoadResources, media_policy, viewport);\n}\n",
        "output": "0",
        "index": 165573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameView::removeScrollableArea(ScrollableArea* scrollableArea)\n{\n    if (!m_scrollableAreas)\n        return;\n    m_scrollableAreas->remove(scrollableArea);\n}\n",
        "output": "0",
        "index": 128306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SoftwareEmulation(struct pt_regs *regs)\n{\n\textern int do_mathemu(struct pt_regs *);\n\textern int Soft_emulate_8xx(struct pt_regs *);\n\tint errcode;\n\n\tCHECK_FULL_REGS(regs);\n\n\tif (!user_mode(regs)) {\n\t\tdebugger(regs);\n\t\tdie(\"Kernel Mode Software FPU Emulation\", regs, SIGFPE);\n\t}\n\n#ifdef CONFIG_MATH_EMULATION\n\terrcode = do_mathemu(regs);\n#else\n\terrcode = Soft_emulate_8xx(regs);\n#endif\n\tif (errcode) {\n\t\tif (errcode > 0)\n\t\t\t_exception(SIGFPE, regs, 0, 0);\n\t\telse if (errcode == -EFAULT)\n\t\t\t_exception(SIGSEGV, regs, 0, 0);\n\t\telse\n\t\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t} else\n\t\temulate_single_step(regs);\n}\n",
        "output": "0",
        "index": 74717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void show_state_filter(unsigned long state_filter)\n{\n\tstruct task_struct *g, *p;\n\n#if BITS_PER_LONG == 32\n\tprintk(KERN_INFO\n\t\t\"  task                PC stack   pid father\\n\");\n#else\n\tprintk(KERN_INFO\n\t\t\"  task                        PC stack   pid father\\n\");\n#endif\n\tread_lock(&tasklist_lock);\n\tdo_each_thread(g, p) {\n\t\t/*\n\t\t * reset the NMI-timeout, listing all files on a slow\n\t\t * console might take alot of time:\n\t\t */\n\t\ttouch_nmi_watchdog();\n\t\tif (!state_filter || (p->state & state_filter))\n\t\t\tsched_show_task(p);\n\t} while_each_thread(g, p);\n\n\ttouch_all_softlockup_watchdogs();\n\n#ifdef CONFIG_SCHED_DEBUG\n\tsysrq_sched_debug_show();\n#endif\n\tread_unlock(&tasklist_lock);\n\t/*\n\t * Only show locks if all tasks are dumped:\n\t */\n\tif (!state_filter)\n\t\tdebug_show_all_locks();\n}\n",
        "output": "0",
        "index": 22600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_proc_destroy_clientid(struct nfs_client *clp,\n\t\tstruct rpc_cred *cred)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DESTROY_CLIENTID],\n\t\t.rpc_argp = clp,\n\t\t.rpc_cred = cred,\n\t};\n\tint status;\n\n\tstatus = rpc_call_sync(clp->cl_rpcclient, &msg, RPC_TASK_TIMEOUT);\n\ttrace_nfs4_destroy_clientid(clp, status);\n\tif (status)\n\t\tdprintk(\"NFS: Got error %d from the server %s on \"\n\t\t\t\"DESTROY_CLIENTID.\", status, clp->cl_hostname);\n\treturn status;\n}\n",
        "output": "0",
        "index": 57051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[dr] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tkvm_update_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\tif (val & 0xffffffff00000000ULL)\n\t\t\treturn -1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 57662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long BlinkTestRunner::GetCurrentTimeInMillisecond() {\n  return base::TimeDelta(base::Time::Now() -\n                         base::Time::UnixEpoch()).ToInternalValue() /\n         base::Time::kMicrosecondsPerMillisecond;\n}\n",
        "output": "0",
        "index": 132642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sock_def_error_report(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_poll(&wq->wait, POLLERR);\n\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_ERR);\n\trcu_read_unlock();\n}\n",
        "output": "0",
        "index": 47893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual status_t setConfig(\n            node_id node, OMX_INDEXTYPE index,\n const void *params, size_t size) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32(index);\n        data.writeInt64(size);\n        data.write(params, size);\n        remote()->transact(SET_CONFIG, data, &reply);\n\n return reply.readInt32();\n }\n",
        "output": "0",
        "index": 173862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\n\t/* A hint request must be the first token received. */\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, spcred, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 36695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HTMLInputElement::CanStartSelection() const {\n  if (!IsTextField())\n    return false;\n  return TextControlElement::CanStartSelection();\n}\n",
        "output": "0",
        "index": 136860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}\n",
        "output": "0",
        "index": 31795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vb2_ioctl_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev, file))\n\t\treturn -EBUSY;\n\treturn vb2_streamoff(vdev->queue, i);\n}\n",
        "output": "0",
        "index": 52765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(stream_filter_prepend)\n{\n\tapply_filter_to_stream(0, INTERNAL_FUNCTION_PARAM_PASSTHRU);\n}\n",
        "output": "0",
        "index": 15270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WorkerFetchContext::AddConsoleMessage(ConsoleMessage* message) const {\n  return global_scope_->AddConsoleMessage(message);\n}\n",
        "output": "0",
        "index": 151481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SyncBackendHost::Core::DoInitializeOptions::DoInitializeOptions(\n    const GURL& service_url,\n    sync_api::HttpPostProviderFactory* http_bridge_factory,\n    const sync_api::SyncCredentials& credentials,\n    bool delete_sync_data_folder,\n    const std::string& restored_key_for_bootstrapping,\n    bool setup_for_test_mode)\n    : service_url(service_url),\n      http_bridge_factory(http_bridge_factory),\n      credentials(credentials),\n      delete_sync_data_folder(delete_sync_data_folder),\n      restored_key_for_bootstrapping(restored_key_for_bootstrapping),\n      setup_for_test_mode(setup_for_test_mode) {\n}\n",
        "output": "0",
        "index": 106303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ConvertFromWeb(blink::WebDragOperationsMask ops) {\n  int drag_op = ui::DragDropTypes::DRAG_NONE;\n  if (ops & blink::WebDragOperationCopy)\n    drag_op |= ui::DragDropTypes::DRAG_COPY;\n  if (ops & blink::WebDragOperationMove)\n    drag_op |= ui::DragDropTypes::DRAG_MOVE;\n  if (ops & blink::WebDragOperationLink)\n    drag_op |= ui::DragDropTypes::DRAG_LINK;\n  return drag_op;\n}\n",
        "output": "0",
        "index": 134485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sanitize_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn trap = BPF_JMP_IMM(BPF_JA, 0, 0, -1);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (aux_data[i].seen)\n\t\t\tcontinue;\n\t\tmemcpy(insn + i, &trap, sizeof(trap));\n\t}\n}\n",
        "output": "0",
        "index": 76427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kvm_memslots *kvm_alloc_memslots(void)\n{\n\tint i;\n\tstruct kvm_memslots *slots;\n\n\tslots = kvzalloc(sizeof(struct kvm_memslots), GFP_KERNEL);\n\tif (!slots)\n\t\treturn NULL;\n\n\tfor (i = 0; i < KVM_MEM_SLOTS_NUM; i++)\n\t\tslots->id_to_index[i] = slots->memslots[i].id = i;\n\n\treturn slots;\n}\n",
        "output": "0",
        "index": 91550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PanoramiXRenderTrapezoids(ClientPtr client)\n{\n    PanoramiXRes *src, *dst;\n    int result = Success, j;\n\n    REQUEST(xRenderTrapezoidsReq);\n    char *extra;\n    int extra_len;\n\n    REQUEST_AT_LEAST_SIZE(xRenderTrapezoidsReq);\n\n    VERIFY_XIN_PICTURE(src, stuff->src, client, DixReadAccess);\n    VERIFY_XIN_PICTURE(dst, stuff->dst, client, DixWriteAccess);\n\n    extra_len = (client->req_len << 2) - sizeof(xRenderTrapezoidsReq);\n\n    if (extra_len && (extra = (char *) malloc(extra_len))) {\n        memcpy(extra, stuff + 1, extra_len);\n\n        FOR_NSCREENS_FORWARD(j) {\n            if (j)\n                memcpy(stuff + 1, extra, extra_len);\n            if (dst->u.pict.root) {\n                int x_off = screenInfo.screens[j]->x;\n                int y_off = screenInfo.screens[j]->y;\n\n                if (x_off || y_off) {\n                    xTrapezoid *trap = (xTrapezoid *) (stuff + 1);\n                    int i = extra_len / sizeof(xTrapezoid);\n\n                    while (i--) {\n                        trap->top -= y_off;\n                        trap->bottom -= y_off;\n                        trap->left.p1.x -= x_off;\n                        trap->left.p1.y -= y_off;\n                        trap->left.p2.x -= x_off;\n                        trap->left.p2.y -= y_off;\n                        trap->right.p1.x -= x_off;\n                        trap->right.p1.y -= y_off;\n                        trap->right.p2.x -= x_off;\n                        trap->right.p2.y -= y_off;\n                        trap++;\n                    }\n                }\n            }\n\n            stuff->src = src->info[j].id;\n            stuff->dst = dst->info[j].id;\n            result = (*PanoramiXSaveRenderVector[X_RenderTrapezoids]) (client);\n\n            if (result != Success)\n                break;\n        }\n\n        free(extra);\n    }\n\n    return result;\n}\n",
        "output": "0",
        "index": 17565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Blob* XMLHttpRequest::responseBlob()\n{\n    ASSERT(m_responseTypeCode == ResponseTypeBlob);\n\n    if (m_error || m_state != DONE)\n        return 0;\n\n    if (!m_responseBlob) {\n        OwnPtr<BlobData> blobData = BlobData::create();\n        size_t size = 0;\n        if (m_binaryResponseBuilder) {\n            RefPtr<RawData> rawData = RawData::create();\n            size = m_binaryResponseBuilder->size();\n            rawData->mutableData()->append(m_binaryResponseBuilder->data(), size);\n            blobData->appendData(rawData, 0, BlobDataItem::toEndOfFile);\n            blobData->setContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.\n            m_binaryResponseBuilder.clear();\n        }\n        m_responseBlob = Blob::create(blobData.release(), size);\n    }\n\n    return m_responseBlob.get();\n}\n",
        "output": "0",
        "index": 119191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int query_raw_packet_qp_rq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_rq *rq,\n\t\t\t\t\tu8 *rq_state)\n{\n\tvoid *out;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(query_rq_out);\n\tout = kvzalloc(inlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_query_rq(dev->mdev, rq->base.mqp.qpn, out);\n\tif (err)\n\t\tgoto out;\n\n\trqc = MLX5_ADDR_OF(query_rq_out, out, rq_context);\n\t*rq_state = MLX5_GET(rqc, rqc, state);\n\trq->state = *rq_state;\n\nout:\n\tkvfree(out);\n\treturn err;\n}\n",
        "output": "0",
        "index": 92176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ScreenOrientation::lockOrientation(Screen& screen, const AtomicString& orientationString)\n{\n    blink::WebScreenOrientations orientations = stringToOrientations(orientationString);\n    if (!orientations)\n        return false;\n    ScreenOrientation::from(screen).lockOrientationAsync(orientations);\n    return true;\n}\n",
        "output": "0",
        "index": 124252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    virtual void ReadDirectoryCallback(\n        base::PlatformFileError error,\n        scoped_ptr<GDataDirectoryProto> directory_proto) {\n      last_error_ = error;\n      directory_proto_ = directory_proto.Pass();\n    }\n",
        "output": "0",
        "index": 111592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnSavePage() {\n  if (!IsSavable()) {\n    RecordDownloadSource(INITIATED_BY_SAVE_PACKAGE_ON_NON_HTML);\n    SaveFrame(GetURL(), Referrer());\n    return;\n  }\n\n  Stop();\n\n  save_package_ = new SavePackage(this);\n  save_package_->GetSaveInfo();\n}\n",
        "output": "0",
        "index": 118996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CellularNetwork::Clear() {\n  WirelessNetwork::Clear();\n  activation_state_ = ACTIVATION_STATE_UNKNOWN;\n  roaming_state_ = ROAMING_STATE_UNKNOWN;\n  network_technology_ = NETWORK_TECHNOLOGY_UNKNOWN;\n  restricted_pool_ = false;\n  service_name_.clear();\n  operator_name_.clear();\n  operator_code_.clear();\n  payment_url_.clear();\n  meid_.clear();\n  imei_.clear();\n  imsi_.clear();\n  esn_.clear();\n  mdn_.clear();\n  min_.clear();\n  model_id_.clear();\n  manufacturer_.clear();\n  firmware_revision_.clear();\n  hardware_revision_.clear();\n  last_update_.clear();\n  prl_version_ = 0;\n}\n",
        "output": "0",
        "index": 100215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string16 ShellWindowViews::GetWindowTitle() const {\n  return GetTitle();\n}\n",
        "output": "0",
        "index": 110127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_init_msr_list(void)\n{\n\tu32 dummy[2];\n\tunsigned i, j;\n\n\t/* skip the first msrs in the list. KVM-specific */\n\tfor (i = j = KVM_SAVE_MSRS_BEGIN; i < ARRAY_SIZE(msrs_to_save); i++) {\n\t\tif (rdmsr_safe(msrs_to_save[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\t\tif (j < i)\n\t\t\tmsrs_to_save[j] = msrs_to_save[i];\n\t\tj++;\n\t}\n\tnum_msrs_to_save = j;\n}\n",
        "output": "0",
        "index": 20779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cliOutputGenericHelp(void) {\n    sds version = cliVersion();\n    printf(\n        \"redis-cli %s\\n\"\n        \"To get help about Redis commands type:\\n\"\n        \"      \\\"help @<group>\\\" to get a list of commands in <group>\\n\"\n        \"      \\\"help <command>\\\" for help on <command>\\n\"\n        \"      \\\"help <tab>\\\" to get a list of possible help topics\\n\"\n        \"      \\\"quit\\\" to exit\\n\"\n        \"\\n\"\n        \"To set redis-cli preferences:\\n\"\n        \"      \\\":set hints\\\" enable online hints\\n\"\n        \"      \\\":set nohints\\\" disable online hints\\n\"\n        \"Set your preferences in ~/.redisclirc\\n\",\n        version\n    );\n    sdsfree(version);\n}\n",
        "output": "0",
        "index": 81943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void construct_reply_common_req(struct smb_request *req, char *outbuf)\n{\n\tconstruct_reply_common(req, (char *)req->inbuf, outbuf);\n}\n",
        "output": "0",
        "index": 11051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iscsi_truncate(BlockDriverState *bs, int64_t offset)\n{\n    IscsiLun *iscsilun = bs->opaque;\n    Error *local_err = NULL;\n\n    if (iscsilun->type != TYPE_DISK) {\n        return -ENOTSUP;\n    }\n\n    iscsi_readcapacity_sync(iscsilun, &local_err);\n    if (local_err != NULL) {\n        error_free(local_err);\n        return -EIO;\n    }\n\n    if (offset > iscsi_getlength(bs)) {\n        return -EINVAL;\n    }\n\n    if (iscsilun->allocationmap != NULL) {\n        g_free(iscsilun->allocationmap);\n        iscsilun->allocationmap = iscsi_allocationmap_init(iscsilun);\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 10530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RTCPeerConnectionHandler::CurrentRemoteDescription() {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  TRACE_EVENT0(\"webrtc\", \"RTCPeerConnectionHandler::currentRemoteDescription\");\n  base::OnceCallback<const webrtc::SessionDescriptionInterface*()>\n      description_cb = base::BindOnce(\n          &webrtc::PeerConnectionInterface::current_remote_description,\n          native_peer_connection_);\n  return GetWebRTCSessionDescriptionOnSignalingThread(\n      std::move(description_cb), \"currentRemoteDescription\");\n}\n",
        "output": "0",
        "index": 165968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_cgroup_soft_reclaim(struct mem_cgroup *root_memcg,\n\t\t\t\t   struct zone *zone,\n\t\t\t\t   gfp_t gfp_mask,\n\t\t\t\t   unsigned long *total_scanned)\n{\n\tstruct mem_cgroup *victim = NULL;\n\tint total = 0;\n\tint loop = 0;\n\tunsigned long excess;\n\tunsigned long nr_scanned;\n\tstruct mem_cgroup_reclaim_cookie reclaim = {\n\t\t.zone = zone,\n\t\t.priority = 0,\n\t};\n\n\texcess = res_counter_soft_limit_excess(&root_memcg->res) >> PAGE_SHIFT;\n\n\twhile (1) {\n\t\tvictim = mem_cgroup_iter(root_memcg, victim, &reclaim);\n\t\tif (!victim) {\n\t\t\tloop++;\n\t\t\tif (loop >= 2) {\n\t\t\t\t/*\n\t\t\t\t * If we have not been able to reclaim\n\t\t\t\t * anything, it might because there are\n\t\t\t\t * no reclaimable pages under this hierarchy\n\t\t\t\t */\n\t\t\t\tif (!total)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * We want to do more targeted reclaim.\n\t\t\t\t * excess >> 2 is not to excessive so as to\n\t\t\t\t * reclaim too much, nor too less that we keep\n\t\t\t\t * coming back to reclaim from this cgroup\n\t\t\t\t */\n\t\t\t\tif (total >= (excess >> 2) ||\n\t\t\t\t\t(loop > MEM_CGROUP_MAX_RECLAIM_LOOPS))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mem_cgroup_reclaimable(victim, false))\n\t\t\tcontinue;\n\t\ttotal += mem_cgroup_shrink_node_zone(victim, gfp_mask, false,\n\t\t\t\t\t\t     zone, &nr_scanned);\n\t\t*total_scanned += nr_scanned;\n\t\tif (!res_counter_soft_limit_excess(&root_memcg->res))\n\t\t\tbreak;\n\t}\n\tmem_cgroup_iter_break(root_memcg, victim);\n\treturn total;\n}\n",
        "output": "0",
        "index": 21128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebBluetoothServiceImpl::RemoteServerGetPrimaryServices(\n    const WebBluetoothDeviceId& device_id,\n    blink::mojom::WebBluetoothGATTQueryQuantity quantity,\n    const base::Optional<BluetoothUUID>& services_uuid,\n    RemoteServerGetPrimaryServicesCallback callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  RecordGetPrimaryServicesServices(quantity, services_uuid);\n\n  if (!allowed_devices().IsAllowedToAccessAtLeastOneService(device_id)) {\n    std::move(callback).Run(\n        blink::mojom::WebBluetoothResult::NOT_ALLOWED_TO_ACCESS_ANY_SERVICE,\n        base::nullopt /* service */);\n    return;\n  }\n\n  if (services_uuid &&\n      !allowed_devices().IsAllowedToAccessService(device_id,\n                                                  services_uuid.value())) {\n    std::move(callback).Run(\n        blink::mojom::WebBluetoothResult::NOT_ALLOWED_TO_ACCESS_SERVICE,\n        base::nullopt /* service */);\n    return;\n  }\n\n  const CacheQueryResult query_result = QueryCacheForDevice(device_id);\n\n  if (query_result.outcome == CacheQueryOutcome::BAD_RENDERER) {\n    return;\n  }\n\n  if (query_result.outcome != CacheQueryOutcome::SUCCESS) {\n    RecordGetPrimaryServicesOutcome(quantity, query_result.outcome);\n    std::move(callback).Run(query_result.GetWebResult(),\n                            base::nullopt /* service */);\n    return;\n  }\n\n  const std::string& device_address = query_result.device->GetAddress();\n\n  if (query_result.device->IsGattServicesDiscoveryComplete()) {\n    RemoteServerGetPrimaryServicesImpl(device_id, quantity, services_uuid,\n                                       std::move(callback),\n                                       query_result.device);\n    return;\n  }\n\n  DVLOG(1) << \"Services not yet discovered.\";\n  pending_primary_services_requests_[device_address].push_back(base::BindOnce(\n      &WebBluetoothServiceImpl::RemoteServerGetPrimaryServicesImpl,\n      base::Unretained(this), device_id, quantity, services_uuid,\n      std::move(callback)));\n}\n",
        "output": "0",
        "index": 168207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataFileSystem::OnGetFileCompleteForUpdateFileByEntry(\n    const FileOperationCallback& callback,\n    const std::string& md5,\n    int64 file_size,\n    const FilePath& cache_file_path,\n    GDataEntry* entry) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  if (!entry || !entry->AsGDataFile()) {\n    if (!callback.is_null())\n      callback.Run(GDATA_FILE_ERROR_NOT_FOUND);\n    return;\n  }\n  GDataFile* file = entry->AsGDataFile();\n\n  uploader_->UploadExistingFile(\n      file->upload_url(),\n      file->GetFilePath(),\n      cache_file_path,\n      file_size,\n      file->content_mime_type(),\n      base::Bind(&GDataFileSystem::OnUpdatedFileUploaded,\n                 ui_weak_ptr_,\n                 callback));\n}\n",
        "output": "0",
        "index": 125414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_probe(AVProbeData *p) {\n    const uint8_t *bufp = p->buf;\n    const uint8_t *end = p->buf + p->buf_size;\n\n    if (p->buf_size < sizeof(mxf_header_partition_pack_key))\n        return 0;\n\n    /* Must skip Run-In Sequence and search for MXF header partition pack key SMPTE 377M 5.5 */\n    end -= sizeof(mxf_header_partition_pack_key);\n\n    for (; bufp < end;) {\n        if (!((bufp[13] - 1) & 0xF2)){\n            if (AV_RN32(bufp   ) == AV_RN32(mxf_header_partition_pack_key   ) &&\n                AV_RN32(bufp+ 4) == AV_RN32(mxf_header_partition_pack_key+ 4) &&\n                AV_RN32(bufp+ 8) == AV_RN32(mxf_header_partition_pack_key+ 8) &&\n                AV_RN16(bufp+12) == AV_RN16(mxf_header_partition_pack_key+12))\n                return AVPROBE_SCORE_MAX;\n            bufp ++;\n        } else\n            bufp += 10;\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 61591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::vertexAttrib1fv(\n    GLuint index,\n    MaybeShared<const DOMFloat32Array> v) {\n  if (isContextLost())\n    return;\n  if (!v.View() || v.View()->length() < 1) {\n    SynthesizeGLError(GL_INVALID_VALUE, \"vertexAttrib1fv\", \"invalid array\");\n    return;\n  }\n  ContextGL()->VertexAttrib1fv(index, v.View()->DataMaybeShared());\n  SetVertexAttribType(index, kFloat32ArrayType);\n}\n",
        "output": "0",
        "index": 146589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::willSendSubmitEvent(blink::WebLocalFrame* frame,\n                                          const blink::WebFormElement& form) {\n  DCHECK(!frame_ || frame_ == frame);\n\n  FOR_EACH_OBSERVER(RenderFrameObserver, observers_, WillSendSubmitEvent(form));\n}\n",
        "output": "0",
        "index": 132352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void btsock_rfc_cleanup(void) {\n  pth = -1;\n\n  pthread_mutex_lock(&slot_lock);\n for (size_t i = 0; i < ARRAY_SIZE(rfc_slots); ++i) {\n if (rfc_slots[i].id)\n      cleanup_rfc_slot(&rfc_slots[i]);\n    list_free(rfc_slots[i].incoming_queue);\n }\n  pthread_mutex_unlock(&slot_lock);\n}\n",
        "output": "0",
        "index": 172045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline LayerInfo *DestroyLayerInfo(LayerInfo *layer_info,\n  const ssize_t number_layers)\n{\n  ssize_t\n    i;\n\n  for (i=0; i<number_layers; i++)\n  {\n    if (layer_info[i].image != (Image *) NULL)\n      layer_info[i].image=DestroyImage(layer_info[i].image);\n    if (layer_info[i].mask.image != (Image *) NULL)\n      layer_info[i].mask.image=DestroyImage(layer_info[i].mask.image);\n    if (layer_info[i].info != (StringInfo *) NULL)\n      layer_info[i].info=DestroyStringInfo(layer_info[i].info);\n  }\n\n  return (LayerInfo *) RelinquishMagickMemory(layer_info);\n}\n",
        "output": "0",
        "index": 61502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evdns_server_request_add_ptr_reply(struct evdns_server_request *req, struct in_addr *in, const char *inaddr_name, const char *hostname, int ttl)\n{\n\tu32 a;\n\tchar buf[32];\n\tif (in && inaddr_name)\n\t\treturn -1;\n\telse if (!in && !inaddr_name)\n\t\treturn -1;\n\tif (in) {\n\t\ta = ntohl(in->s_addr);\n\t\tevutil_snprintf(buf, sizeof(buf), \"%d.%d.%d.%d.in-addr.arpa\",\n\t\t\t\t(int)(u8)((a\t)&0xff),\n\t\t\t\t(int)(u8)((a>>8 )&0xff),\n\t\t\t\t(int)(u8)((a>>16)&0xff),\n\t\t\t\t(int)(u8)((a>>24)&0xff));\n\t\tinaddr_name = buf;\n\t}\n\treturn evdns_server_request_add_reply(\n\t\t  req, EVDNS_ANSWER_SECTION, inaddr_name, TYPE_PTR, CLASS_INET,\n\t\t  ttl, -1, 1, hostname);\n}\n",
        "output": "0",
        "index": 70644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    explicit CCThreadProxyScrollControllerAdapter(CCThreadProxy* proxy)\n    {\n        m_proxy = proxy;\n    }\n",
        "output": "0",
        "index": 102699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\n\t\t\t\t\tTALLOC_CTX *ctx, const char *src, size_t n)\n{\n\tsize_t size=0;\n\tchar *dest;\n\n\tif (!src) {\n\t\treturn NULL;\n\t}\n\n\t/* this takes advantage of the fact that upper/lower can't\n\t   change the length of a character by more than 1 byte */\n\tdest = talloc_array(ctx, char, 2*(n+1));\n\tif (dest == NULL) {\n\t\treturn NULL;\n\t}\n \n        while (n-- && *src) {\n                size_t c_size;\n               codepoint_t c = next_codepoint_handle(iconv_handle, src, &c_size);\n                src += c_size;\n \n                c = toupper_m(c);\n\t\tc_size = push_codepoint_handle(iconv_handle, dest+size, c);\n\t\tif (c_size == -1) {\n\t\t\ttalloc_free(dest);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += c_size;\n\t}\n\n\tdest[size] = 0;\n\n\t/* trim it so talloc_append_string() works */\n\tdest = talloc_realloc(ctx, dest, char, size+1);\n\n\ttalloc_set_name_const(dest, dest);\n\n\treturn dest;\n}\n",
        "output": "1",
        "index": 177844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::removeTitle(Element* titleElement)\n{\n    if (m_titleElement != titleElement)\n        return;\n\n    m_titleElement = 0;\n    m_titleSetExplicitly = false;\n\n    if (HTMLElement* headElement = head()) {\n        for (Node* e = headElement->firstChild(); e; e = e->nextSibling())\n            if (e->hasTagName(titleTag)) {\n                HTMLTitleElement* titleElement = static_cast<HTMLTitleElement*>(e);\n                setTitleElement(titleElement->textWithDirection(), titleElement);\n                break;\n            }\n    }\n\n    if (!m_titleElement)\n        updateTitle(StringWithDirection());\n}\n",
        "output": "0",
        "index": 112534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPageProxy::unmarkAllBadGrammar()\n{\n    process()->send(Messages::WebPage::UnmarkAllBadGrammar(), m_pageID);\n}\n",
        "output": "0",
        "index": 106660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::Optional<Gamepad> GamepadBuilder::GetGamepad() const {\n  if (IsValid())\n    return gamepad_;\n\n  return base::nullopt;\n}\n",
        "output": "0",
        "index": 155731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t LayerTreeHostQt::adoptImageBackingStore(Image* image)\n{\n    if (!image)\n        return InvalidWebLayerID;\n    QPixmap* pixmap = image->nativeImageForCurrentFrame();\n\n    if (!pixmap)\n        return InvalidWebLayerID;\n\n    int64_t key = pixmap->cacheKey();\n    HashMap<int64_t, int>::iterator it = m_directlyCompositedImageRefCounts.find(key);\n\n    if (it != m_directlyCompositedImageRefCounts.end()) {\n        ++(it->second);\n        return key;\n    }\n\n    RefPtr<ShareableBitmap> bitmap = ShareableBitmap::createShareable(image->size(), image->currentFrameHasAlpha() ? ShareableBitmap::SupportsAlpha : 0);\n    {\n        OwnPtr<WebCore::GraphicsContext> graphicsContext = bitmap->createGraphicsContext();\n        graphicsContext->drawImage(image, ColorSpaceDeviceRGB, IntPoint::zero());\n    }\n\n    ShareableBitmap::Handle handle;\n    bitmap->createHandle(handle);\n    m_webPage->send(Messages::LayerTreeHostProxy::CreateDirectlyCompositedImage(key, handle));\n    m_directlyCompositedImageRefCounts.add(key, 1);\n    return key;\n}\n",
        "output": "0",
        "index": 107119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void PrintPreviewDataService::GetDataEntry(\n    const std::string& preview_ui_addr_str,\n     int index,\n     scoped_refptr<base::RefCountedBytes>* data_bytes) {\n   *data_bytes = NULL;\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n   if (it != data_store_map_.end())\n     it->second->GetPreviewDataForIndex(index, data_bytes);\n }\n",
        "output": "1",
        "index": 184395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n {\n \tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n \tstruct nat_entry *ne;\n\tint err;\n \n \t/* 0 nid should not be used */\n \tif (unlikely(nid == 0))\n \t\treturn false;\n \n\tif (build) {\n\t\t/* do not add allocated nids */\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n \ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n \ti->nid = nid;\n \ti->state = NID_NEW;\n \n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n \n \tspin_lock(&nm_i->nid_list_lock);\n \terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n \tspin_unlock(&nm_i->nid_list_lock);\n \tradix_tree_preload_end();\n\tif (err) {\n \t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n }\n",
        "output": "1",
        "index": 182551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_pud_range(pgd_t pgd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tunsigned long next;\n\tpud_t *pudp;\n\n\tpudp = pud_offset(&pgd, addr);\n\tdo {\n\t\tpud_t pud = READ_ONCE(*pudp);\n\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_none(pud))\n\t\t\treturn 0;\n\t\tif (unlikely(pud_huge(pud))) {\n\t\t\tif (!gup_huge_pud(pud, pudp, addr, next, write,\n\t\t\t\t\t  pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (unlikely(is_hugepd(__hugepd(pud_val(pud))))) {\n\t\t\tif (!gup_huge_pd(__hugepd(pud_val(pud)), addr,\n\t\t\t\t\t PUD_SHIFT, next, write, pages, nr))\n\t\t\t\treturn 0;\n\t\t} else if (!gup_pmd_range(pud, addr, next, write, pages, nr))\n\t\t\treturn 0;\n\t} while (pudp++, addr = next, addr != end);\n\n\treturn 1;\n}\n",
        "output": "0",
        "index": 52117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderView::runModalPromptDialog(\n    WebFrame* frame, const WebString& message, const WebString& default_value,\n    WebString* actual_value) {\n  std::wstring result;\n  bool ok = RunJavaScriptMessage(MessageBoxFlags::kIsJavascriptPrompt,\n                                 UTF16ToWideHack(message),\n                                 UTF16ToWideHack(default_value),\n                                 frame->url(),\n                                 &result);\n  if (ok)\n    actual_value->assign(WideToUTF16Hack(result));\n  return ok;\n}\n",
        "output": "0",
        "index": 98127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long VideoTrack::GetWidth() const\n{\n    return m_width;\n}\n",
        "output": "1",
        "index": 188404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct page *shmem_alloc_page(gfp_t gfp,\n\t\t\tstruct shmem_inode_info *info, pgoff_t index)\n{\n\treturn alloc_page(gfp);\n}\n",
        "output": "0",
        "index": 33483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "authentic_select_aid(struct sc_card *card, unsigned char *aid, size_t aid_len,\n\t\tunsigned char *out, size_t *out_len)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char apdu_resp[SC_MAX_APDU_BUFFER_SIZE];\n\tint rv;\n\n\t/* Select Card Manager (to deselect previously selected application) */\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xA4, 0x04, 0x00);\n\tapdu.lc = aid_len;\n\tapdu.data = aid;\n\tapdu.datalen = aid_len;\n\tapdu.resplen = sizeof(apdu_resp);\n\tapdu.resp = apdu_resp;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"Cannot select AID\");\n\n\tif (out && out_len)   {\n\t\tif (*out_len < apdu.resplen)\n\t\t\tLOG_TEST_RET(card->ctx, SC_ERROR_BUFFER_TOO_SMALL, \"Cannot select AID\");\n\t\tmemcpy(out, apdu.resp, apdu.resplen);\n\t}\n\n\treturn SC_SUCCESS;\n}\n",
        "output": "0",
        "index": 78209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderViewImpl* RenderViewImpl::Create(\n    gfx::NativeViewId parent_hwnd,\n    int32 opener_id,\n    const content::RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int32 surface_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name,\n    bool is_renderer_created,\n    bool swapped_out,\n    int32 next_page_id,\n    const WebKit::WebScreenInfo& screen_info,\n    content::old::GuestToEmbedderChannel* guest_to_embedder_channel,\n    AccessibilityMode accessibility_mode) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  return new RenderViewImpl(\n      parent_hwnd,\n      opener_id,\n      renderer_prefs,\n      webkit_prefs,\n      counter,\n      routing_id,\n      surface_id,\n      session_storage_namespace_id,\n      frame_name,\n      is_renderer_created,\n      swapped_out,\n      next_page_id,\n      screen_info,\n      guest_to_embedder_channel,\n      accessibility_mode);\n}\n",
        "output": "0",
        "index": 108840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void remove_entity_load_avg(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tunsigned long flags;\n\n\t/*\n\t * tasks cannot exit without having gone through wake_up_new_task() ->\n\t * post_init_entity_util_avg() which will have added things to the\n\t * cfs_rq, so we can remove unconditionally.\n\t *\n\t * Similarly for groups, they will have passed through\n\t * post_init_entity_util_avg() before unregister_sched_fair_group()\n\t * calls this.\n\t */\n\n\tsync_entity_load_avg(se);\n\n\traw_spin_lock_irqsave(&cfs_rq->removed.lock, flags);\n\t++cfs_rq->removed.nr;\n\tcfs_rq->removed.util_avg\t+= se->avg.util_avg;\n\tcfs_rq->removed.load_avg\t+= se->avg.load_avg;\n\tcfs_rq->removed.runnable_sum\t+= se->avg.load_sum; /* == runnable_sum */\n\traw_spin_unlock_irqrestore(&cfs_rq->removed.lock, flags);\n}\n",
        "output": "0",
        "index": 92645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void loop_config_discard(struct loop_device *lo)\n{\n\tstruct file *file = lo->lo_backing_file;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct request_queue *q = lo->lo_queue;\n\n\t/*\n\t * We use punch hole to reclaim the free space used by the\n\t * image a.k.a. discard. However we do not support discard if\n\t * encryption is enabled, because it may give an attacker\n\t * useful information.\n\t */\n\tif ((!file->f_op->fallocate) ||\n\t    lo->lo_encrypt_key_size) {\n\t\tq->limits.discard_granularity = 0;\n\t\tq->limits.discard_alignment = 0;\n\t\tblk_queue_max_discard_sectors(q, 0);\n\t\tblk_queue_max_write_zeroes_sectors(q, 0);\n\t\tqueue_flag_clear_unlocked(QUEUE_FLAG_DISCARD, q);\n\t\treturn;\n\t}\n\n\tq->limits.discard_granularity = inode->i_sb->s_blocksize;\n\tq->limits.discard_alignment = 0;\n\n\tblk_queue_max_discard_sectors(q, UINT_MAX >> 9);\n\tblk_queue_max_write_zeroes_sectors(q, UINT_MAX >> 9);\n\tqueue_flag_set_unlocked(QUEUE_FLAG_DISCARD, q);\n}\n",
        "output": "0",
        "index": 84719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ChromeMetricsServiceClient::FilterBrowserMetricsFiles(\n    const base::FilePath& path) {\n  base::ProcessId pid;\n  if (!base::GlobalHistogramAllocator::ParseFilePath(path, nullptr, nullptr,\n                                                     &pid)) {\n    return metrics::FileMetricsProvider::FILTER_PROCESS_FILE;\n  }\n\n  if (pid == base::GetCurrentProcId())\n    return metrics::FileMetricsProvider::FILTER_ACTIVE_THIS_PID;\n\n  if (IsProcessRunning(pid))\n    return metrics::FileMetricsProvider::FILTER_TRY_LATER;\n\n  return metrics::FileMetricsProvider::FILTER_PROCESS_FILE;\n}\n",
        "output": "0",
        "index": 141778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n",
        "output": "0",
        "index": 26713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OmniboxViewViews::GetAccessibleNodeData(ui::AXNodeData* node_data) {\n  node_data->role = ui::AX_ROLE_TEXT_FIELD;\n  node_data->SetName(l10n_util::GetStringUTF8(IDS_ACCNAME_LOCATION));\n  node_data->SetValue(GetText());\n  node_data->html_attributes.push_back(std::make_pair(\"type\", \"url\"));\n\n  base::string16::size_type entry_start;\n  base::string16::size_type entry_end;\n  if (saved_selection_for_focus_change_.IsValid()) {\n    entry_start = saved_selection_for_focus_change_.start();\n    entry_end = saved_selection_for_focus_change_.end();\n  } else {\n    GetSelectionBounds(&entry_start, &entry_end);\n  }\n  node_data->AddIntAttribute(ui::AX_ATTR_TEXT_SEL_START, entry_start);\n  node_data->AddIntAttribute(ui::AX_ATTR_TEXT_SEL_END, entry_end);\n\n  if (popup_window_mode_) {\n    node_data->AddIntAttribute(ui::AX_ATTR_RESTRICTION,\n                               ui::AX_RESTRICTION_READ_ONLY);\n  } else {\n    node_data->AddState(ui::AX_STATE_EDITABLE);\n  }\n}\n",
        "output": "0",
        "index": 163433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  std::vector<bool> ProduceExpectedActiveStates(\n      int expected_active_panel_index) {\n    std::vector<Panel*> panels = PanelManager::GetInstance()->panels();\n    std::vector<bool> active_states;\n    for (int i = 0; i < static_cast<int>(panels.size()); i++)\n      active_states.push_back(i == expected_active_panel_index);\n    return active_states;\n  }\n",
        "output": "0",
        "index": 115323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HTMLCanvasElement::RenderingContextFactories() {\n  DCHECK(IsMainThread());\n  DEFINE_STATIC_LOCAL(ContextFactoryVector, context_factories,\n                      (CanvasRenderingContext::kMaxValue));\n  return context_factories;\n}\n",
        "output": "0",
        "index": 165031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InputMethodBase::SetDelegate(\n    internal::InputMethodDelegate* delegate) {\n  delegate_ = delegate;\n}\n",
        "output": "0",
        "index": 117434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::registerEventFactory(PassOwnPtr<EventFactoryBase> eventFactory)\n{\n    ASSERT(!eventFactories().contains(eventFactory.get()));\n    eventFactories().add(eventFactory);\n}\n",
        "output": "0",
        "index": 135339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Detach() { shelf_ = nullptr; }\n",
        "output": "0",
        "index": 142432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xml_latest_schema(void)\n{\n    return get_schema_name(xml_latest_schema_index());\n}\n",
        "output": "0",
        "index": 44113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::queryCommandState(const String& commandName, ExceptionState& exceptionState)\n{\n    if (!isHTMLDocument() && !isXHTMLDocument()) {\n        exceptionState.throwDOMException(InvalidStateError, \"queryCommandState is only supported on HTML documents.\");\n        return false;\n    }\n\n    return command(this, commandName).state() == TrueTriState;\n}\n",
        "output": "0",
        "index": 135334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    AutoInstallCurrentThreadPlatformMock()\n    {\n        m_oldPlatform = Platform::current();\n        Platform::initialize(&m_mockPlatform);\n    }\n",
        "output": "0",
        "index": 145092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::RegisterIntentHandler(\n    WebContents* web_contents,\n    const webkit_glue::WebIntentServiceData& data,\n    bool user_gesture) {\n  RegisterIntentHandlerHelper(web_contents, data, user_gesture);\n}\n",
        "output": "0",
        "index": 126221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JSValue jsTestObjCreate(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = jsBoolean(impl->isCreate());\n    return result;\n}\n",
        "output": "0",
        "index": 106114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CNBL::FitsLSO()\n{\n    return (m_MaxDataLength <= PARANDIS_MAX_LSO_SIZE + LsoTcpHeaderOffset() + MAX_TCP_HEADER_SIZE);\n}\n",
        "output": "0",
        "index": 96312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gpu::gles2::Logger* GLES2DecoderPassthroughImpl::GetLogger() {\n  return &logger_;\n}\n",
        "output": "0",
        "index": 154461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf14_grayspot_get_color_comp_index(gx_device * dev, const char * pname,\n    int name_size, int component_type)\n{\n    return pdf14_spot_get_color_comp_index(dev, pname, name_size, component_type, 1);\n}\n",
        "output": "0",
        "index": 13318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Rect TabStripGtk::GetDropBounds(int drop_index,\n                                     bool drop_before,\n                                     bool* is_beneath) {\n  DCHECK_NE(drop_index, -1);\n  int center_x;\n  if (drop_index < GetTabCount()) {\n    TabGtk* tab = GetTabAt(drop_index);\n    gfx::Rect bounds = tab->GetNonMirroredBounds(tabstrip_.get());\n    if (drop_before)\n      center_x = bounds.x() - (kTabHOffset / 2);\n    else\n      center_x = bounds.x() + (bounds.width() / 2);\n  } else {\n    TabGtk* last_tab = GetTabAt(drop_index - 1);\n    gfx::Rect bounds = last_tab->GetNonMirroredBounds(tabstrip_.get());\n    center_x = bounds.x() + bounds.width() + (kTabHOffset / 2);\n  }\n\n  center_x = gtk_util::MirroredXCoordinate(tabstrip_.get(), center_x);\n\n  gfx::Point drop_loc(center_x - drop_indicator_width / 2,\n                      -drop_indicator_height);\n  gtk_util::ConvertWidgetPointToScreen(tabstrip_.get(), &drop_loc);\n  gfx::Rect drop_bounds(drop_loc.x(), drop_loc.y(), drop_indicator_width,\n                        drop_indicator_height);\n\n  *is_beneath = true;\n  if (*is_beneath)\n    drop_bounds.Offset(0, drop_bounds.height() + bounds().height());\n\n  return drop_bounds;\n}\n",
        "output": "0",
        "index": 126504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderMessageFilter::OnGenerateRoutingID(int* route_id) {\n  *route_id = render_widget_helper_->GetNextRoutingID();\n}\n",
        "output": "0",
        "index": 125205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PrintPreviewHandler::HandleGetPrinters(const ListValue* /*args*/) {\n  scoped_refptr<PrintSystemTaskProxy> task =\n      new PrintSystemTaskProxy(AsWeakPtr(),\n                               print_backend_.get(),\n                               has_logged_printers_count_);\n  has_logged_printers_count_ = true;\n\n  BrowserThread::PostTask(\n      BrowserThread::FILE, FROM_HERE,\n      base::Bind(&PrintSystemTaskProxy::EnumeratePrinters, task.get()));\n}\n",
        "output": "0",
        "index": 112751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PHP_MSHUTDOWN_FUNCTION(zip)\n{\n\tzend_hash_destroy(&zip_prop_handlers);\n\tphp_unregister_url_stream_wrapper(\"zip\");\n\treturn SUCCESS;\n}\n",
        "output": "0",
        "index": 54380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ContentSecurityPolicy::allowScriptWithHash(const String& source,\n                                                InlineType type) const {\n  return checkDigest<&CSPDirectiveList::allowScriptHash>(\n      source, type, m_scriptHashAlgorithmsUsed, m_policies);\n}\n",
        "output": "0",
        "index": 149420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long ramfs_nommu_get_unmapped_area(struct file *file,\n\t\t\t\t\t    unsigned long addr, unsigned long len,\n\t\t\t\t\t    unsigned long pgoff, unsigned long flags)\n{\n\tunsigned long maxpages, lpages, nr, loop, ret;\n\tstruct inode *inode = file_inode(file);\n\tstruct page **pages = NULL, **ptr, *page;\n\tloff_t isize;\n\n\tif (!(flags & MAP_SHARED))\n\t\treturn addr;\n\n\t/* the mapping mustn't extend beyond the EOF */\n\tlpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tisize = i_size_read(inode);\n\n\tret = -EINVAL;\n\tmaxpages = (isize + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (pgoff >= maxpages)\n\t\tgoto out;\n\n\tif (maxpages - pgoff < lpages)\n\t\tgoto out;\n\n\t/* gang-find the pages */\n\tret = -ENOMEM;\n\tpages = kzalloc(lpages * sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto out_free;\n\n\tnr = find_get_pages(inode->i_mapping, pgoff, lpages, pages);\n\tif (nr != lpages)\n\t\tgoto out_free_pages; /* leave if some pages were missing */\n\n\t/* check the pages for physical adjacency */\n\tptr = pages;\n\tpage = *ptr++;\n\tpage++;\n\tfor (loop = lpages; loop > 1; loop--)\n\t\tif (*ptr++ != page++)\n\t\t\tgoto out_free_pages;\n\n\t/* okay - all conditions fulfilled */\n\tret = (unsigned long) page_address(pages[0]);\n\nout_free_pages:\n\tptr = pages;\n\tfor (loop = nr; loop > 0; loop--)\n\t\tput_page(*ptr++);\nout_free:\n\tkfree(pages);\nout:\n\treturn ret;\n}\n",
        "output": "0",
        "index": 46349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_update_rtt_min(struct sock *sk, u32 rtt_us)\n{\n\tconst u32 now = tcp_time_stamp, wlen = sysctl_tcp_min_rtt_wlen * HZ;\n\tstruct rtt_meas *m = tcp_sk(sk)->rtt_min;\n\tstruct rtt_meas rttm = { .rtt = (rtt_us ? : 1), .ts = now };\n\tu32 elapsed;\n\n\t/* Check if the new measurement updates the 1st, 2nd, or 3rd choices */\n\tif (unlikely(rttm.rtt <= m[0].rtt))\n\t\tm[0] = m[1] = m[2] = rttm;\n\telse if (rttm.rtt <= m[1].rtt)\n\t\tm[1] = m[2] = rttm;\n\telse if (rttm.rtt <= m[2].rtt)\n\t\tm[2] = rttm;\n\n\telapsed = now - m[0].ts;\n\tif (unlikely(elapsed > wlen)) {\n\t\t/* Passed entire window without a new min so make 2nd choice\n\t\t * the new min & 3rd choice the new 2nd. So forth and so on.\n\t\t */\n\t\tm[0] = m[1];\n\t\tm[1] = m[2];\n\t\tm[2] = rttm;\n\t\tif (now - m[0].ts > wlen) {\n\t\t\tm[0] = m[1];\n\t\t\tm[1] = rttm;\n\t\t\tif (now - m[0].ts > wlen)\n\t\t\t\tm[0] = rttm;\n\t\t}\n\t} else if (m[1].ts == m[0].ts && elapsed > wlen / 4) {\n\t\t/* Passed a quarter of the window without a new min so\n\t\t * take 2nd choice from the 2nd quarter of the window.\n\t\t */\n\t\tm[2] = m[1] = rttm;\n\t} else if (m[2].ts == m[1].ts && elapsed > wlen / 2) {\n\t\t/* Passed half the window without a new min so take the 3rd\n\t\t * choice from the last half of the window.\n\t\t */\n\t\tm[2] = rttm;\n\t}\n}\n",
        "output": "0",
        "index": 55421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit netlink_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tproc_net_remove(net, \"netlink\");\n#endif\n}\n",
        "output": "0",
        "index": 19243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " VaapiVideoDecodeAccelerator::GetSupportedProfiles() {\n  return VaapiWrapper::GetSupportedDecodeProfiles();\n}\n",
        "output": "0",
        "index": 99636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ArrayBuffer* XMLHttpRequest::responseArrayBuffer()\n{\n    ASSERT(m_responseTypeCode == ResponseTypeArrayBuffer);\n\n    if (m_error || m_state != DONE)\n        return 0;\n\n    if (!m_responseArrayBuffer.get()) {\n        if (m_binaryResponseBuilder.get() && m_binaryResponseBuilder->size() > 0) {\n            m_responseArrayBuffer = m_binaryResponseBuilder->getAsArrayBuffer();\n            m_binaryResponseBuilder.clear();\n        } else {\n            m_responseArrayBuffer = ArrayBuffer::create(static_cast<void*>(0), 0);\n        }\n    }\n\n    return m_responseArrayBuffer.get();\n}\n",
        "output": "0",
        "index": 119190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void CreateNewFullscreenWidget(int route_id) {}\n",
        "output": "0",
        "index": 117693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::updateUseShadowTreesIfNeeded()\n{\n    ScriptForbiddenScope forbidScript;\n\n    if (m_useElementsNeedingUpdate.isEmpty())\n        return;\n\n    WillBeHeapVector<RawPtrWillBeMember<SVGUseElement>> elements;\n    copyToVector(m_useElementsNeedingUpdate, elements);\n    m_useElementsNeedingUpdate.clear();\n\n    for (SVGUseElement* element : elements)\n        element->buildPendingResource();\n}\n",
        "output": "0",
        "index": 135435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "map_layer_by_name(const char* name)\n{\n\tint i;\n\n\tfor (i = 0; i < s_map->num_layers; ++i) {\n\t\tif (strcmp(name, lstr_cstr(s_map->layers[0].name)) == 0)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n",
        "output": "0",
        "index": 75050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TabLoader::TabIsLoading(NavigationController* controller) {\n  DCHECK(controller);\n  DCHECK(find(tabs_loading_.begin(), tabs_loading_.end(), controller) ==\n         tabs_loading_.end());\n  tabs_loading_.insert(controller);\n  RenderWidgetHost* render_widget_host = GetRenderWidgetHost(controller);\n  DCHECK(render_widget_host);\n  render_widget_hosts_loading_.insert(render_widget_host);\n  RegisterForNotifications(controller);\n}\n",
        "output": "0",
        "index": 116930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  FT_Stream_GetOffset( FT_Stream  stream )\n  {\n    FT_Byte*  p;\n    FT_Long   result;\n\n\n    FT_ASSERT( stream && stream->cursor );\n\n    result         = 0;\n    p              = stream->cursor;\n    if ( p + 2 < stream->limit )\n      result       = FT_NEXT_OFF3( p );\n    stream->cursor = p;\n    return result;\n  }\n",
        "output": "0",
        "index": 9700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BlobDataHandle::BlobDataHandle(PassOwnPtr<BlobData> data, long long size)\n {\n     UNUSED_PARAM(size);\n     m_internalURL = BlobURL::createInternalURL();\n    ThreadableBlobRegistry::registerBlobURL(m_internalURL, data);\n }\n",
        "output": "1",
        "index": 184268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ap_bus_force_rescan(void)\n{\n\t/* reconfigure the AP bus rescan timer. */\n\tmod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);\n\t/* processing a asynchronous bus rescan */\n\tqueue_work(ap_work_queue, &ap_config_work);\n\tflush_work(&ap_config_work);\n}\n",
        "output": "0",
        "index": 47577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MediaStreamManager::OnStreamStarted(const std::string& label) {\n  DeviceRequest* const request = FindRequest(label);\n  if (!request)\n    return;\n\n  if (request->ui_proxy) {\n    request->ui_proxy->OnStarted(\n        base::BindOnce(&MediaStreamManager::StopMediaStreamFromBrowser,\n                       base::Unretained(this), label),\n        base::BindOnce(&MediaStreamManager::OnMediaStreamUIWindowId,\n                       base::Unretained(this), request->video_type(),\n                       request->devices));\n  }\n}\n",
        "output": "0",
        "index": 161144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    SyncManager::ExtraPasswordChangeRecordData::unencrypted() const {\n  return unencrypted_;\n}\n",
        "output": "0",
        "index": 102212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::EmailPageLocation() {\n  UserMetrics::RecordAction(UserMetricsAction(\"EmailPageLocation\"));\n  TabContents* tc = GetSelectedTabContents();\n  DCHECK(tc);\n\n  std::string title = EscapeQueryParamValue(UTF16ToUTF8(tc->GetTitle()), false);\n  std::string page_url = EscapeQueryParamValue(tc->GetURL().spec(), false);\n  std::string mailto = std::string(\"mailto:?subject=Fwd:%20\") +\n      title + \"&body=%0A%0A\" + page_url;\n  platform_util::OpenExternal(GURL(mailto));\n}\n",
        "output": "0",
        "index": 101630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeContentBrowserClient::ClearCookies(RenderViewHost* rvh) {\n  Profile* profile = Profile::FromBrowserContext(\n      rvh->GetSiteInstance()->GetProcess()->GetBrowserContext());\n  BrowsingDataRemover* remover =\n      BrowsingDataRemover::CreateForUnboundedRange(profile);\n  int remove_mask = BrowsingDataRemover::REMOVE_SITE_DATA;\n  remover->Remove(remove_mask, BrowsingDataHelper::UNPROTECTED_WEB);\n}\n",
        "output": "0",
        "index": 124082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned HTMLMediaElement::webkitVideoDecodedByteCount() const {\n  if (!webMediaPlayer())\n    return 0;\n  return webMediaPlayer()->videoDecodedByteCount();\n}\n",
        "output": "0",
        "index": 140148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bt_status_t init_ctrl(btrc_ctrl_callbacks_t* callbacks )\n{\n    BTIF_TRACE_EVENT(\"## %s ##\", __FUNCTION__);\n bt_status_t result = BT_STATUS_SUCCESS;\n\n if (bt_rc_ctrl_callbacks)\n return BT_STATUS_DONE;\n\n    bt_rc_ctrl_callbacks = callbacks;\n    memset (&btif_rc_cb, 0, sizeof(btif_rc_cb));\n    btif_rc_cb.rc_vol_label=MAX_LABEL;\n    btif_rc_cb.rc_volume=MAX_VOLUME;\n    lbl_init();\n\n return result;\n}\n",
        "output": "0",
        "index": 171995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  int64_t max_buffer_forward() { return loader()->max_buffer_forward_; }\n",
        "output": "0",
        "index": 157101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mf_bitmap_to_of10(const struct mf_bitmap *fields)\n{\n    const struct ofp10_wc_map *p;\n    uint32_t wc10 = 0;\n\n    for (p = ofp10_wc_map; p < &ofp10_wc_map[ARRAY_SIZE(ofp10_wc_map)]; p++) {\n        if (bitmap_is_set(fields->bm, p->mf)) {\n            wc10 |= p->wc10;\n        }\n    }\n    return htonl(wc10);\n}\n",
        "output": "0",
        "index": 77453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::removeFormAssociation(Element* element)\n{\n    auto it = m_associatedFormControls.find(element);\n    if (it == m_associatedFormControls.end())\n        return;\n    m_associatedFormControls.remove(it);\n    if (m_associatedFormControls.isEmpty())\n        m_didAssociateFormControlsTimer.stop();\n}\n",
        "output": "0",
        "index": 135345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n",
        "output": "0",
        "index": 60237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mapInvfMode (INVF_MODE mode,\n             INVF_MODE prevMode,\n             WHITENING_FACTORS whFactors)\n{\n switch (mode) {\n case INVF_LOW_LEVEL:\n if(prevMode == INVF_OFF)\n return whFactors.transitionLevel;\n else\n return whFactors.lowLevel;\n\n case INVF_MID_LEVEL:\n return whFactors.midLevel;\n\n case INVF_HIGH_LEVEL:\n return whFactors.highLevel;\n\n default:\n if(prevMode == INVF_LOW_LEVEL)\n return whFactors.transitionLevel;\n else\n return whFactors.off;\n }\n}\n",
        "output": "0",
        "index": 176499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int addrconf_ifid_gre(u8 *eui, struct net_device *dev)\n{\n\treturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\n}\n",
        "output": "0",
        "index": 41776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfs4_proc_getdevicelist(struct nfs_server *server,\n\t\t\t    const struct nfs_fh *fh,\n\t\t\t    struct pnfs_devicelist *devlist)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\n\tdo {\n\t\terr = nfs4_handle_exception(server,\n\t\t\t\t_nfs4_getdevicelist(server, fh, devlist),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\n\tdprintk(\"%s: err=%d, num_devs=%u\\n\", __func__,\n\t\terr, devlist->num_devs);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 19971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "make_NegHints(OM_uint32 *minor_status, gss_buffer_t *outbuf)\n{\n\tOM_uint32 major_status;\n\tunsigned int tlen = 0;\n\tunsigned int hintNameSize = 0;\n\tunsigned char *ptr;\n\tunsigned char *t;\n\tconst char *hintname = \"not_defined_in_RFC4178@please_ignore\";\n\tconst size_t hintname_len = strlen(hintname);\n\n\t*outbuf = GSS_C_NO_BUFFER;\n\tmajor_status = GSS_S_FAILURE;\n\n\t/* Length of DER encoded GeneralString */\n\ttlen = 1 + gssint_der_length_size(hintname_len) + hintname_len;\n\thintNameSize = tlen;\n\n\t/* Length of DER encoded hintName */\n\ttlen += 1 + gssint_der_length_size(hintNameSize);\n\n\tt = gssalloc_malloc(tlen);\n\tif (t == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tgoto errout;\n\t}\n\n\tptr = t;\n\n\t*ptr++ = CONTEXT | 0x00; /* hintName identifier */\n\tif (gssint_put_der_length(hintNameSize,\n\t\t\t\t  &ptr, tlen - (int)(ptr-t)))\n\t\tgoto errout;\n\n\t*ptr++ = GENERAL_STRING;\n\tif (gssint_put_der_length(hintname_len, &ptr, tlen - (int)(ptr-t)))\n\t\tgoto errout;\n\n\tmemcpy(ptr, hintname, hintname_len);\n\tptr += hintname_len;\n\n\t*outbuf = (gss_buffer_t)malloc(sizeof(gss_buffer_desc));\n\tif (*outbuf == NULL) {\n\t\t*minor_status = ENOMEM;\n\t\tgoto errout;\n\t}\n\t(*outbuf)->value = (void *)t;\n\t(*outbuf)->length = ptr - t;\n\n\tt = NULL; /* don't free */\n\n\t*minor_status = 0;\n\tmajor_status = GSS_S_COMPLETE;\n\nerrout:\n\tif (t != NULL) {\n\t\tfree(t);\n\t}\n\n\treturn (major_status);\n}\n",
        "output": "0",
        "index": 43818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvp_key_delete(int pool, __u8 *key, int key_size)\n{\n\tint i;\n\tint j, k;\n\tint num_records;\n\tstruct kvp_record *record;\n\n\t/*\n\t * First update the in-memory state.\n\t */\n\tkvp_update_mem_state(pool);\n\n\tnum_records = kvp_file_info[pool].num_records;\n\trecord = kvp_file_info[pool].records;\n\n\tfor (i = 0; i < num_records; i++) {\n\t\tif (memcmp(key, record[i].key, key_size))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Found a match; just move the remaining\n\t\t * entries up.\n\t\t */\n\t\tif (i == num_records) {\n\t\t\tkvp_file_info[pool].num_records--;\n\t\t\tkvp_update_file(pool);\n\t\t\treturn 0;\n\t\t}\n\n\t\tj = i;\n\t\tk = j + 1;\n\t\tfor (; k < num_records; k++) {\n\t\t\tstrcpy(record[j].key, record[k].key);\n\t\t\tstrcpy(record[j].value, record[k].value);\n\t\t\tj++;\n\t\t}\n\n\t\tkvp_file_info[pool].num_records--;\n\t\tkvp_update_file(pool);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n",
        "output": "0",
        "index": 18471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Tab* TabStrip::CreateTabForDragging() {\n  Tab* tab = new Tab(NULL);\n  tab->set_theme_provider(GetThemeProvider());\n  return tab;\n}\n",
        "output": "0",
        "index": 134322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flag)\n{\n\tkuid_t euid = current_euid();\n\tint requested_mode, granted_mode;\n\n\taudit_ipc_obj(ipcp);\n\trequested_mode = (flag >> 6) | (flag >> 3) | flag;\n\tgranted_mode = ipcp->mode;\n\tif (uid_eq(euid, ipcp->cuid) ||\n\t    uid_eq(euid, ipcp->uid))\n\t\tgranted_mode >>= 6;\n\telse if (in_group_p(ipcp->cgid) || in_group_p(ipcp->gid))\n\t\tgranted_mode >>= 3;\n\t/* is there some bit set in requested_mode but not in granted_mode? */\n\tif ((requested_mode & ~granted_mode & 0007) &&\n\t    !ns_capable(ns->user_ns, CAP_IPC_OWNER))\n\t\treturn -1;\n\n\treturn security_ipc_permission(ipcp, flag);\n}\n",
        "output": "0",
        "index": 42051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BaseAudioContext::Initialize() {\n  if (IsDestinationInitialized())\n    return;\n\n  FFTFrame::Initialize();\n\n  audio_worklet_ = AudioWorklet::Create(this);\n\n  if (destination_node_) {\n    destination_node_->Handler().Initialize();\n    listener_ = AudioListener::Create(*this);\n  }\n}\n",
        "output": "0",
        "index": 166929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void OnSetWindowBounds(\n      std::unique_ptr<browser::SetWindowBoundsResult> result) {\n    GetWindowBounds(base::Bind(\n        &HeadlessDevToolsClientChangeWindowBoundsTest::OnGetWindowBounds,\n        base::Unretained(this)));\n  }\n",
        "output": "0",
        "index": 157579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BrowserCommandController::BrowserCommandController(Browser* browser)\n    : browser_(browser),\n      ALLOW_THIS_IN_INITIALIZER_LIST(command_updater_(this)),\n      block_command_execution_(false),\n      last_blocked_command_id_(-1),\n      last_blocked_command_disposition_(CURRENT_TAB) {\n  browser_->tab_strip_model()->AddObserver(this);\n  PrefService* local_state = g_browser_process->local_state();\n  if (local_state) {\n    local_pref_registrar_.Init(local_state);\n    local_pref_registrar_.Add(prefs::kAllowFileSelectionDialogs, this);\n    local_pref_registrar_.Add(prefs::kInManagedMode, this);\n  }\n\n  profile_pref_registrar_.Init(profile()->GetPrefs());\n  profile_pref_registrar_.Add(prefs::kDevToolsDisabled, this);\n  profile_pref_registrar_.Add(prefs::kEditBookmarksEnabled, this);\n  profile_pref_registrar_.Add(prefs::kShowBookmarkBar, this);\n  profile_pref_registrar_.Add(prefs::kIncognitoModeAvailability, this);\n  profile_pref_registrar_.Add(prefs::kPrintingEnabled, this);\n\n  InitCommandState();\n\n  TabRestoreService* tab_restore_service =\n      TabRestoreServiceFactory::GetForProfile(profile());\n  if (tab_restore_service) {\n    tab_restore_service->AddObserver(this);\n    TabRestoreServiceChanged(tab_restore_service);\n  }\n\n  ProfileSyncService* service =\n      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile());\n  if (service)\n    service->AddObserver(this);\n}\n",
        "output": "0",
        "index": 126271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLManager::GLManager() {\n  SetupBaseContext();\n}\n",
        "output": "0",
        "index": 162854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLuint WebGL2RenderingContextBase::getUniformBlockIndex(\n    WebGLProgram* program,\n    const String& uniform_block_name) {\n  if (isContextLost() || !ValidateWebGLObject(\"getUniformBlockIndex\", program))\n    return 0;\n  if (!ValidateString(\"getUniformBlockIndex\", uniform_block_name))\n    return 0;\n\n  return ContextGL()->GetUniformBlockIndex(ObjectOrZero(program),\n                                           uniform_block_name.Utf8().data());\n}\n",
        "output": "0",
        "index": 146109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<RasterTilePriorityQueue> LayerTreeHostImpl::BuildRasterQueue(\n    TreePriority tree_priority,\n    RasterTilePriorityQueue::Type type) {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"cc.debug\"),\n               \"LayerTreeHostImpl::BuildRasterQueue\");\n\n  return RasterTilePriorityQueue::Create(active_tree_->picture_layers(),\n                                         pending_tree_\n                                             ? pending_tree_->picture_layers()\n                                             : std::vector<PictureLayerImpl*>(),\n                                         tree_priority, type);\n}\n",
        "output": "0",
        "index": 149904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebContentsImpl::ContainsOrIsFocusedWebContents() {\n  for (WebContentsImpl* focused_contents = GetFocusedWebContents();\n       focused_contents;\n       focused_contents = focused_contents->GetOuterWebContents()) {\n    if (focused_contents == this)\n      return true;\n  }\n\n  return false;\n}\n",
        "output": "0",
        "index": 148321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "png_get_int_32(png_bytep buf)\n{\n   png_int_32 i = ((png_int_32)(*buf) << 24) +\n      ((png_int_32)(*(buf + 1)) << 16) +\n      ((png_int_32)(*(buf + 2)) << 8) +\n      (png_int_32)(*(buf + 3));\n\n   return (i);\n}\n",
        "output": "0",
        "index": 117394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int copy_fpregs_to_sigframe(struct xregs_state __user *buf)\n{\n\tint err;\n\n\tif (use_xsave())\n\t\terr = copy_xregs_to_user(buf);\n\telse if (use_fxsr())\n\t\terr = copy_fxregs_to_user((struct fxregs_state __user *) buf);\n\telse\n\t\terr = copy_fregs_to_user((struct fregs_state __user *) buf);\n\n\tif (unlikely(err) && __clear_user(buf, fpu_user_xstate_size))\n\t\terr = -EFAULT;\n\treturn err;\n}\n",
        "output": "0",
        "index": 60448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataFileSystem::OnTransferCompleted(\n    const FileOperationCallback& callback,\n    GDataFileError error,\n    scoped_ptr<UploadFileInfo> upload_file_info) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(upload_file_info.get());\n\n  if (error == GDATA_FILE_OK && upload_file_info->entry.get()) {\n    AddUploadedFile(UPLOAD_NEW_FILE,\n                    upload_file_info->gdata_path.DirName(),\n                    upload_file_info->entry.Pass(),\n                    upload_file_info->file_path,\n                    GDataCache::FILE_OPERATION_COPY,\n                    base::Bind(&OnAddUploadFileCompleted, callback, error));\n  } else if (!callback.is_null()) {\n    callback.Run(error);\n  }\n}\n",
        "output": "0",
        "index": 125426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t/* Release rx options */\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\t/* Free flowlabels */\n\tfl6_free_socklist(sk);\n \n \t/* Free tx options */\n \n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n }\n",
        "output": "1",
        "index": 180499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "JSValue jsTestObjCONST_VALUE_9(ExecState* exec, JSValue, const Identifier&)\n{\n    UNUSED_PARAM(exec);\n    return jsNumber(static_cast<int>(-1));\n}\n",
        "output": "0",
        "index": 106100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}\n",
        "output": "0",
        "index": 39035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " ACTION_P(ScheduleRenameCallback, new_path) {\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                           base::Bind(arg3, new_path));\n }\n",
        "output": "0",
        "index": 113112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void inetpeer_free_rcu(struct rcu_head *head)\n{\n\tkmem_cache_free(peer_cachep, container_of(head, struct inet_peer, rcu));\n}\n",
        "output": "0",
        "index": 25087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlSAXUserParseMemory(xmlSAXHandlerPtr sax, void *user_data,\n\t\t\t  const char *buffer, int size) {\n    int ret = 0;\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL) return -1;\n    if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n        xmlFree(ctxt->sax);\n    ctxt->sax = sax;\n    xmlDetectSAX2(ctxt);\n\n    if (user_data != NULL)\n\tctxt->userData = user_data;\n\n    xmlParseDocument(ctxt);\n    \n    if (ctxt->wellFormed)\n\tret = 0;\n    else {\n        if (ctxt->errNo != 0)\n\t    ret = ctxt->errNo;\n\telse\n\t    ret = -1;\n    }\n    if (sax != NULL)\n        ctxt->sax = NULL;\n    if (ctxt->myDoc != NULL) {\n        xmlFreeDoc(ctxt->myDoc);\n\tctxt->myDoc = NULL;\n    }\n    xmlFreeParserCtxt(ctxt);\n    \n    return ret;\n}\n",
        "output": "0",
        "index": 100771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void webkit_gc_collect_javascript_objects()\n{\n    gcController().garbageCollectNow();\n}\n",
        "output": "0",
        "index": 98375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void writeFileListIndex(const Vector<int>& blobIndices)\n    {\n        append(FileListIndexTag);\n        uint32_t length = blobIndices.size();\n        doWriteUint32(length);\n        for (unsigned i = 0; i < length; ++i)\n            doWriteUint32(blobIndices[i]);\n    }\n",
        "output": "0",
        "index": 129026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RTCPeerConnectionHandlerDummy::updateIce(PassRefPtr<RTCConfiguration>, PassRefPtr<MediaConstraints>)\n{\n    return false;\n}\n",
        "output": "0",
        "index": 104281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ui::TouchEvent* RootWindow::CreateTouchEvent(ui::EventType type,\n                                             const gfx::Point& location,\n                                             int touch_id,\n                                             base::TimeDelta time_stamp) {\n  return new TouchEvent(type, location, touch_id, time_stamp);\n}\n",
        "output": "0",
        "index": 110860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const ComputedStyle* SVGElement::EnsureComputedStyle(\n    PseudoId pseudo_element_specifier) {\n  if (!HasSVGRareData() || !SvgRareData()->UseOverrideComputedStyle())\n    return Element::EnsureComputedStyle(pseudo_element_specifier);\n\n  const ComputedStyle* parent_style = nullptr;\n  if (Element* parent = ParentOrShadowHostElement()) {\n    if (LayoutObject* layout_object = parent->GetLayoutObject())\n      parent_style = layout_object->Style();\n  }\n\n  return SvgRareData()->OverrideComputedStyle(this, parent_style);\n}\n",
        "output": "0",
        "index": 165786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perWorldBindingsTestInterfaceEmptyMethodOptionalBooleanArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestInterfaceNodeV8Internal::perWorldBindingsTestInterfaceEmptyMethodOptionalBooleanArgMethod(info);\n}\n",
        "output": "0",
        "index": 127691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sock *netlink_seq_socket_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct nl_seq_iter *iter = seq->private;\n\tint i, j;\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\tloff_t off = 0;\n\n\tfor (i = 0; i < MAX_LINKS; i++) {\n\t\tstruct nl_pid_hash *hash = &nl_table[i].hash;\n\n\t\tfor (j = 0; j <= hash->mask; j++) {\n\t\t\tsk_for_each(s, node, &hash->table[j]) {\n\t\t\t\tif (sock_net(s) != seq_file_net(seq))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (off == pos) {\n\t\t\t\t\titer->link = i;\n\t\t\t\t\titer->hash_idx = j;\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t\t++off;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 19257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void swap_guid(ff_asf_guid guid)\n{\n    FFSWAP(unsigned char, guid[0], guid[3]);\n    FFSWAP(unsigned char, guid[1], guid[2]);\n    FFSWAP(unsigned char, guid[4], guid[5]);\n    FFSWAP(unsigned char, guid[6], guid[7]);\n}\n",
        "output": "0",
        "index": 74901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void watchdog_interrupt_count(void) { return; }\n",
        "output": "0",
        "index": 26398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n  /* no implementation yet, fall back to wall-clock time */\n  _dbus_get_real_time (tv_sec, tv_usec);\n}\n",
        "output": "0",
        "index": 3795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OutOfProcessInstance::DidOpen(int32_t result) {\n  if (result == PP_OK) {\n    if (!engine_->HandleDocumentLoad(embed_loader_)) {\n      document_load_state_ = LOAD_STATE_LOADING;\n      DocumentLoadFailed();\n    }\n  } else if (result != PP_ERROR_ABORTED) {  // Can happen in tests.\n    NOTREACHED();\n    DocumentLoadFailed();\n  }\n\n  if (engine_->IsProgressiveLoad()) {\n    pp::VarDictionary message;\n    message.Set(kType, kJSCancelStreamUrlType);\n    PostMessage(message);\n  }\n}\n",
        "output": "0",
        "index": 140602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionStrictFunction(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     ExceptionCode ec = 0;\n     const String& str(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    float a(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toFloat(exec));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    if (exec->argumentCount() > 2 && !exec->argument(2).isUndefinedOrNull() && !exec->argument(2).inherits(&JSint::s_info))\n        return throwVMTypeError(exec);\n    int* b(toint(MAYBE_MISSING_PARAMETER(exec, 2, DefaultIsUndefined)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n\n    JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->strictFunction(str, a, b, ec)));\n    setDOMException(exec, ec);\n    return JSValue::encode(result);\n}\n",
        "output": "1",
        "index": 184066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MojoAudioInputStream::SetVolume(double volume) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  if (volume < 0 || volume > 1) {\n    LOG(ERROR) << \"MojoAudioInputStream::SetVolume(\" << volume\n               << \") out of range.\";\n    OnStreamError(/*not used*/ 0);\n    return;\n  }\n  delegate_->OnSetVolume(volume);\n}\n",
        "output": "0",
        "index": 162344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeRenderProcessObserver::OnGetV8HeapStats() {\n  v8::HeapStatistics heap_stats;\n  v8::V8::GetHeapStatistics(&heap_stats);\n  RenderThread::Get()->Send(new ChromeViewHostMsg_V8HeapStats(\n      heap_stats.total_heap_size(), heap_stats.used_heap_size()));\n}\n",
        "output": "0",
        "index": 108453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tg3_get_eeprom_size(struct tg3 *tp)\n{\n\tu32 cursize, val, magic;\n\n\ttp->nvram_size = EEPROM_CHIP_SIZE;\n\n\tif (tg3_nvram_read(tp, 0, &magic) != 0)\n\t\treturn;\n\n\tif ((magic != TG3_EEPROM_MAGIC) &&\n\t    ((magic & TG3_EEPROM_MAGIC_FW_MSK) != TG3_EEPROM_MAGIC_FW) &&\n\t    ((magic & TG3_EEPROM_MAGIC_HW_MSK) != TG3_EEPROM_MAGIC_HW))\n\t\treturn;\n\n\t/*\n\t * Size the chip by reading offsets at increasing powers of two.\n\t * When we encounter our validation signature, we know the addressing\n\t * has wrapped around, and thus have our chip size.\n\t */\n\tcursize = 0x10;\n\n\twhile (cursize < tp->nvram_size) {\n\t\tif (tg3_nvram_read(tp, cursize, &val) != 0)\n\t\t\treturn;\n\n\t\tif (val == magic)\n\t\t\tbreak;\n\n\t\tcursize <<= 1;\n\t}\n\n\ttp->nvram_size = cursize;\n}\n",
        "output": "0",
        "index": 32559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vfat_hash(const struct dentry *dentry, const struct inode *inode,\n\t\tstruct qstr *qstr)\n{\n\tqstr->hash = full_name_hash(qstr->name, vfat_striptail_len(qstr));\n\treturn 0;\n}\n",
        "output": "0",
        "index": 33397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\terror = vfs_open(path, f, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\n",
        "output": "0",
        "index": 94731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_cbc_setkey(struct crypto_tfm *parent, const u8 *key,\n\t\t\t     unsigned int keylen)\n{\n\tstruct crypto_cbc_ctx *ctx = crypto_tfm_ctx(parent);\n\tstruct crypto_cipher *child = ctx->child;\n\tint err;\n\n\tcrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\n\tcrypto_cipher_set_flags(child, crypto_tfm_get_flags(parent) &\n\t\t\t\t       CRYPTO_TFM_REQ_MASK);\n\terr = crypto_cipher_setkey(child, key, keylen);\n\tcrypto_tfm_set_flags(parent, crypto_cipher_get_flags(child) &\n\t\t\t\t     CRYPTO_TFM_RES_MASK);\n\treturn err;\n}\n",
        "output": "0",
        "index": 45568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}\n",
        "output": "0",
        "index": 50975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int SocketStream::DoReadWrite(int result) {\n  if (result < OK) {\n    next_state_ = STATE_CLOSE;\n    return result;\n  }\n  if (!socket_.get() || !socket_->IsConnected()) {\n    next_state_ = STATE_CLOSE;\n    return ERR_CONNECTION_CLOSED;\n  }\n\n  if (closing_ && !current_write_buf_.get() && pending_write_bufs_.empty()) {\n    socket_->Disconnect();\n    next_state_ = STATE_CLOSE;\n    return OK;\n  }\n\n  next_state_ = STATE_READ_WRITE;\n\n  if (!server_closed_) {\n    if (!read_buf_.get()) {\n      read_buf_ = new IOBuffer(kReadBufferSize);\n      result = socket_->Read(\n          read_buf_.get(),\n          kReadBufferSize,\n          base::Bind(&SocketStream::OnReadCompleted, base::Unretained(this)));\n      if (result > 0) {\n        return DidReceiveData(result);\n      } else if (result == 0) {\n        next_state_ = STATE_CLOSE;\n        server_closed_ = true;\n        return ERR_CONNECTION_CLOSED;\n      }\n      if (result != ERR_IO_PENDING) {\n        next_state_ = STATE_CLOSE;\n        server_closed_ = true;\n        return result;\n      }\n    }\n    DCHECK(read_buf_.get());\n  }\n\n  if (waiting_for_write_completion_)\n    return ERR_IO_PENDING;\n\n  if (!current_write_buf_.get()) {\n    if (pending_write_bufs_.empty()) {\n      return ERR_IO_PENDING;\n    }\n\n    current_write_buf_ = new DrainableIOBuffer(\n        pending_write_bufs_.front().get(), pending_write_bufs_.front()->size());\n    pending_write_bufs_.pop_front();\n  }\n\n  result = socket_->Write(\n      current_write_buf_.get(),\n      current_write_buf_->BytesRemaining(),\n      base::Bind(&SocketStream::OnWriteCompleted, base::Unretained(this)));\n\n  if (result == ERR_IO_PENDING) {\n    waiting_for_write_completion_ = true;\n  } else if (result < 0) {\n    next_state_ = STATE_CLOSE;\n  } else if (result > 0) {\n    DidSendData(result);\n    result = OK;\n  }\n\n  return result;\n}\n",
        "output": "0",
        "index": 120935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void BluetoothDeviceChromeOS::OnPair(\n     const base::Closure& callback,\n     const ConnectErrorCallback& error_callback) {\n   VLOG(1) << object_path_.value() << \": Paired\";\n \n  if (!pairing_delegate_used_)\n    UMA_HISTOGRAM_ENUMERATION(\"Bluetooth.PairingMethod\",\n                              UMA_PAIRING_METHOD_NONE,\n                              UMA_PAIRING_METHOD_COUNT);\n  UnregisterAgent();\n   SetTrusted();\n   ConnectInternal(true, callback, error_callback);\n }\n",
        "output": "1",
        "index": 184919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void FinishVideoTest() {\n    content::MediaStreamRequest request(CreateRequest(\n        content::MEDIA_NO_SERVICE, content::MEDIA_DEVICE_VIDEO_CAPTURE));\n    MediaStreamDevicesController::RequestPermissions(\n        request, base::Bind(&MediaStreamDevicesControllerBrowserTest::Accept,\n                            base::Unretained(this)));\n\n    base::RunLoop::QuitCurrentWhenIdleDeprecated();\n  }\n",
        "output": "0",
        "index": 170217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " base::FilePath GetSetupExeForInstallationLevel(InstallationLevel level) {\n   base::FilePath setup_exe_path(\n      GetSetupExeFromRegistry(level, kBinariesAppGuid));\n  if (setup_exe_path.empty())\n    setup_exe_path = GetSetupExeFromRegistry(level, kBrowserAppGuid);\n  return setup_exe_path;\n}\n",
        "output": "0",
        "index": 122013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void red_channel_client_pipe_add_tail(RedChannelClient *rcc, PipeItem *item)\n{\n    spice_assert(rcc);\n    rcc->pipe_size++;\n    ring_add_before(&item->link, &rcc->pipe);\n    red_channel_client_push(rcc);\n}\n",
        "output": "0",
        "index": 2114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void FlushMonitoring(WaitableEvent* flush_complete_event) {\n    TraceLog::GetInstance()->FlushButLeaveBufferIntact(\n        base::Bind(&TraceEventTestFixture::OnTraceDataCollected,\n                   base::Unretained(static_cast<TraceEventTestFixture*>(this)),\n                   base::Unretained(flush_complete_event)));\n  }\n",
        "output": "0",
        "index": 129857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "views::View* FindFirstOrLastFocusableChild(views::View* root,\n                                           bool find_last_child) {\n  views::FocusSearch search(root, find_last_child /*cycle*/,\n                            false /*accessibility_mode*/);\n  views::FocusTraversable* dummy_focus_traversable;\n  views::View* dummy_focus_traversable_view;\n  return search.FindNextFocusableView(\n      root,\n      find_last_child ? views::FocusSearch::SearchDirection::kBackwards\n                      : views::FocusSearch::SearchDirection::kForwards,\n      views::FocusSearch::TraversalDirection::kDown,\n      views::FocusSearch::StartingViewPolicy::kSkipStartingView,\n      views::FocusSearch::AnchoredDialogPolicy::kCanGoIntoAnchoredDialog,\n      &dummy_focus_traversable, &dummy_focus_traversable_view);\n}\n",
        "output": "0",
        "index": 142540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::Core::set_processing_passphrase() {\n  DCHECK(MessageLoop::current() == host_->frontend_loop_);\n  processing_passphrase_ = true;\n}\n",
        "output": "0",
        "index": 106367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLMediaElement::CancelPendingEventsAndCallbacks() {\n  BLINK_MEDIA_LOG << \"cancelPendingEventsAndCallbacks(\" << (void*)this << \")\";\n  async_event_queue_->CancelAllEvents();\n\n  for (HTMLSourceElement* source =\n           Traversal<HTMLSourceElement>::FirstChild(*this);\n       source; source = Traversal<HTMLSourceElement>::NextSibling(*source))\n    source->CancelPendingErrorEvent();\n}\n",
        "output": "0",
        "index": 142754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8HeapStatsObserver::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  DCHECK(type == chrome::NOTIFICATION_RENDERER_V8_HEAP_STATS_COMPUTED);\n\n  base::ProcessId updated_renderer_id =\n      *(content::Source<base::ProcessId>(source).ptr());\n  if (renderer_id_ != updated_renderer_id)\n    return;\n\n  ChromeRenderMessageFilter::V8HeapStatsDetails* v8_heap_details =\n      content::Details<ChromeRenderMessageFilter::V8HeapStatsDetails>(details)\n          .ptr();\n  scoped_ptr<DictionaryValue> return_value(new DictionaryValue);\n  return_value->SetInteger(\"renderer_id\", updated_renderer_id);\n  return_value->SetInteger(\"v8_memory_allocated\",\n                           v8_heap_details->v8_memory_allocated());\n  return_value->SetInteger(\"v8_memory_used\",\n                           v8_heap_details->v8_memory_used());\n\n  if (automation_) {\n    AutomationJSONReply(automation_, reply_message_.release())\n        .SendSuccess(return_value.get());\n  }\n  delete this;\n}\n",
        "output": "0",
        "index": 126004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(int) iw_is_input_fmt_supported(int fmt)\n{\n\tswitch(fmt) {\n#if IW_SUPPORT_PNG == 1\n\tcase IW_FORMAT_PNG:\n#endif\n#if IW_SUPPORT_JPEG == 1\n\tcase IW_FORMAT_JPEG:\n#endif\n#if IW_SUPPORT_WEBP == 1\n\tcase IW_FORMAT_WEBP:\n#endif\n\tcase IW_FORMAT_MIFF:\n\tcase IW_FORMAT_GIF:\n\tcase IW_FORMAT_BMP:\n\tcase IW_FORMAT_PNM:\n\tcase IW_FORMAT_PAM:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 66275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::RenderWidgetGotFocus(\n    RenderWidgetHostImpl* render_widget_host) {\n  if (delegate_ && render_widget_host && delegate_->EmbedsFullscreenWidget() &&\n      render_widget_host->GetView() == GetFullscreenRenderWidgetHostView()) {\n    NotifyWebContentsFocused();\n  }\n}\n",
        "output": "0",
        "index": 144641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Eina_Bool ewk_view_zoom_weak_set(Evas_Object* ewkView, float zoom, Evas_Coord centerX, Evas_Coord centerY)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET(smartData, priv);\n\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->zoom_weak_set, false);\n\n    if (!priv->settings.zoomRange.userScalable) {\n        WRN(\"userScalable is false\");\n        return false;\n    }\n\n    if (zoom < priv->settings.zoomRange.minScale) {\n        WRN(\"zoom level is < %f : %f\", priv->settings.zoomRange.minScale, zoom);\n        return false;\n    }\n    if (zoom > priv->settings.zoomRange.maxScale) {\n        WRN(\"zoom level is > %f : %f\", priv->settings.zoomRange.maxScale, zoom);\n        return false;\n    }\n\n    smartData->animated_zoom.zoom.start = ewk_frame_page_zoom_get(smartData->main_frame);\n    smartData->animated_zoom.zoom.end = zoom;\n    smartData->animated_zoom.zoom.current = zoom;\n    return smartData->api->zoom_weak_set(smartData, zoom, centerX, centerY);\n}\n",
        "output": "0",
        "index": 107696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct fuse_req *__fuse_get_req(struct fuse_conn *fc, unsigned npages,\n\t\t\t\t       bool for_background)\n{\n\tstruct fuse_req *req;\n\tint err;\n\tatomic_inc(&fc->num_waiting);\n\n\tif (fuse_block_alloc(fc, for_background)) {\n\t\terr = -EINTR;\n\t\tif (wait_event_killable_exclusive(fc->blocked_waitq,\n\t\t\t\t!fuse_block_alloc(fc, for_background)))\n\t\t\tgoto out;\n\t}\n\t/* Matches smp_wmb() in fuse_set_initialized() */\n\tsmp_rmb();\n\n\terr = -ENOTCONN;\n\tif (!fc->connected)\n\t\tgoto out;\n\n\terr = -ECONNREFUSED;\n\tif (fc->conn_error)\n\t\tgoto out;\n\n\treq = fuse_request_alloc(npages);\n\terr = -ENOMEM;\n\tif (!req) {\n\t\tif (for_background)\n\t\t\twake_up(&fc->blocked_waitq);\n\t\tgoto out;\n\t}\n\n\treq->in.h.uid = from_kuid(fc->user_ns, current_fsuid());\n\treq->in.h.gid = from_kgid(fc->user_ns, current_fsgid());\n\treq->in.h.pid = pid_nr_ns(task_pid(current), fc->pid_ns);\n\n\t__set_bit(FR_WAITING, &req->flags);\n\tif (for_background)\n\t\t__set_bit(FR_BACKGROUND, &req->flags);\n\n\tif (unlikely(req->in.h.uid == ((uid_t)-1) ||\n\t\t     req->in.h.gid == ((gid_t)-1))) {\n\t\tfuse_put_request(fc, req);\n\t\treturn ERR_PTR(-EOVERFLOW);\n\t}\n\treturn req;\n\n out:\n\tfuse_drop_waiting(fc);\n\treturn ERR_PTR(err);\n}\n",
        "output": "0",
        "index": 96779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void wake_futex(struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (WARN(q->pi_state || q->rt_waiter, \"refusing to wake PI futex\\n\"))\n\t\treturn;\n\n\t/*\n\t * We set q->lock_ptr = NULL _before_ we wake up the task. If\n\t * a non-futex wake up happens on another CPU then the task\n\t * might exit and p would dereference a non-existing task\n\t * struct. Prevent this by holding a reference on p across the\n\t * wake up.\n\t */\n\tget_task_struct(p);\n\n\t__unqueue_futex(q);\n\t/*\n\t * The waiting task can free the futex_q as soon as\n\t * q->lock_ptr = NULL is written, without taking any locks. A\n\t * memory barrier is required here to prevent the following\n\t * store to lock_ptr from getting ahead of the plist_del.\n\t */\n\tsmp_wmb();\n\tq->lock_ptr = NULL;\n\n\twake_up_state(p, TASK_NORMAL);\n\tput_task_struct(p);\n}\n",
        "output": "0",
        "index": 38230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->data;\n\n\t\tsdd->sd = alloc_percpu(struct sched_domain *);\n\t\tif (!sdd->sd)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sg = alloc_percpu(struct sched_group *);\n\t\tif (!sdd->sg)\n\t\t\treturn -ENOMEM;\n\n\t\tsdd->sgc = alloc_percpu(struct sched_group_capacity *);\n\t\tif (!sdd->sgc)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_cpu(j, cpu_map) {\n\t\t\tstruct sched_domain *sd;\n\t\t\tstruct sched_group *sg;\n\t\t\tstruct sched_group_capacity *sgc;\n\n\t\t\tsd = kzalloc_node(sizeof(struct sched_domain) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sd)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sd, j) = sd;\n\n\t\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sg)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tsg->next = sg;\n\n\t\t\t*per_cpu_ptr(sdd->sg, j) = sg;\n\n\t\t\tsgc = kzalloc_node(sizeof(struct sched_group_capacity) + cpumask_size(),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(j));\n\t\t\tif (!sgc)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t*per_cpu_ptr(sdd->sgc, j) = sgc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 55474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AutoFillManager::FormsSeen(const std::vector<FormData>& forms) {\n  if (!IsAutoFillEnabled())\n    return;\n\n  if (personal_data_->profiles().empty() &&\n      personal_data_->credit_cards().empty())\n    return;\n\n  ParseForms(forms);\n}\n",
        "output": "0",
        "index": 97826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebMediaPlayerImpl::SetTickClockForTest(\n    const base::TickClock* tick_clock) {\n  tick_clock_ = tick_clock;\n  buffered_data_source_host_.SetTickClockForTest(tick_clock);\n}\n",
        "output": "0",
        "index": 157331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TabsDetectLanguageFunction::RunImpl() {\n  int tab_id = 0;\n  Browser* browser = NULL;\n  WebContents* contents = NULL;\n\n  if (HasOptionalArgument(0)) {\n    EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(0, &tab_id));\n    if (!GetTabById(tab_id, profile(), include_incognito(),\n                    &browser, NULL, &contents, NULL, &error_)) {\n      return false;\n    }\n    if (!browser || !contents)\n      return false;\n  } else {\n    browser = GetCurrentBrowser();\n    if (!browser)\n      return false;\n    contents = browser->tab_strip_model()->GetActiveWebContents();\n    if (!contents)\n      return false;\n  }\n\n  if (contents->GetController().NeedsReload()) {\n    error_ = keys::kCannotDetermineLanguageOfUnloadedTab;\n    return false;\n  }\n\n  AddRef();  // Balanced in GotLanguage().\n\n  TranslateTabHelper* translate_tab_helper =\n      TranslateTabHelper::FromWebContents(contents);\n  if (!translate_tab_helper->language_state().original_language().empty()) {\n    MessageLoop::current()->PostTask(FROM_HERE, base::Bind(\n        &TabsDetectLanguageFunction::GotLanguage, this,\n        translate_tab_helper->language_state().original_language()));\n    return true;\n  }\n  registrar_.Add(this, chrome::NOTIFICATION_TAB_LANGUAGE_DETERMINED,\n                 content::Source<WebContents>(contents));\n  registrar_.Add(\n      this, chrome::NOTIFICATION_TAB_CLOSING,\n      content::Source<NavigationController>(&(contents->GetController())));\n  registrar_.Add(\n      this, content::NOTIFICATION_NAV_ENTRY_COMMITTED,\n      content::Source<NavigationController>(&(contents->GetController())));\n  return true;\n}\n",
        "output": "0",
        "index": 121524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lua_auth_checker_harness_first(request_rec *r)\n{\n    return lua_request_rec_hook_harness(r, \"auth_checker\", AP_LUA_HOOK_FIRST);\n}\n",
        "output": "0",
        "index": 35690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncerUtil::CreateNewEntry(syncable::WriteTransaction *trans,\n                                const syncable::Id& id) {\n  syncable::MutableEntry entry(trans, syncable::GET_BY_ID, id);\n  if (!entry.good()) {\n    syncable::MutableEntry new_entry(trans, syncable::CREATE_NEW_UPDATE_ITEM,\n                                     id);\n  }\n}\n",
        "output": "0",
        "index": 101293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n \tout->gd_free(out);\n \treturn rv;\n }\n",
        "output": "1",
        "index": 181992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SavePackage::SaveFailed(const GURL& save_url) {\n  SaveUrlItemMap::iterator it = in_progress_items_.find(save_url.spec());\n  if (it == in_progress_items_.end()) {\n    NOTREACHED();  // Should not exist!\n    return;\n  }\n  SaveItem* save_item = it->second;\n\n  save_item->Finish(0, false);\n\n  PutInProgressItemToSavedMap(save_item);\n\n  if (download_ && download_->IsInProgress())\n    download_->UpdateProgress(completed_count(), CurrentSpeed(), \"\");\n\n  if ((save_type_ == SAVE_PAGE_TYPE_AS_ONLY_HTML) ||\n      (save_type_ == SAVE_PAGE_TYPE_AS_MHTML) ||\n      (save_item->save_source() == SaveFileCreateInfo::SAVE_FILE_FROM_DOM)) {\n    Cancel(true);\n  }\n\n  if (canceled()) {\n    DCHECK(finished_);\n    return;\n  }\n\n  DoSavingProcess();\n\n  CheckFinish();\n}\n",
        "output": "0",
        "index": 123555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dbus_g_proxy_manager_lookup_name_owner (DBusGProxyManager        *manager,\n\t\t\t\t\tconst char               *name,\n\t\t\t\t\tDBusGProxyNameOwnerInfo **info,\n\t\t\t\t\tconst char              **owner)\n{\n  DBusGProxyNameOwnerForeachData foreach_data;\n\n  foreach_data.name = name;\n  foreach_data.owner = NULL;\n  foreach_data.info = NULL;\n  \n  g_hash_table_foreach (manager->owner_names, name_owner_foreach, &foreach_data);\n\n  *info = foreach_data.info;\n  *owner = foreach_data.owner;\n  return *info != NULL;\n}\n",
        "output": "0",
        "index": 5541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_get_name_attribute(OM_uint32 *minor_status,\n\t\t\t      gss_name_t name,\n\t\t\t      gss_buffer_t attr,\n\t\t\t      int *authenticated,\n\t\t\t      int *complete,\n\t\t\t      gss_buffer_t value,\n\t\t\t      gss_buffer_t display_value,\n\t\t\t      int *more)\n{\n\tOM_uint32 ret;\n\tret = gss_get_name_attribute(minor_status,\n\t\t\t\t     name,\n\t\t\t\t     attr,\n\t\t\t\t     authenticated,\n\t\t\t\t     complete,\n\t\t\t\t     value,\n\t\t\t\t     display_value,\n\t\t\t\t     more);\n\treturn (ret);\n}\n",
        "output": "0",
        "index": 36752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void methodWithNonOptionalArgAndOptionalArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"methodWithNonOptionalArgAndOptionalArg\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 1)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, nonOpt, toInt32(info[0], exceptionState), exceptionState);\n    if (UNLIKELY(info.Length() <= 1)) {\n        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);\n        return;\n    }\n    V8TRYCATCH_EXCEPTION_VOID(int, opt, toInt32(info[1], exceptionState), exceptionState);\n    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\n}\n",
        "output": "0",
        "index": 130873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FlashTaskbar(HANDLE handle)\n{\n\tFLASHWINFO pf;\n\n\tif (handle == NULL)\n\t\treturn;\n\tpf.cbSize = sizeof(FLASHWINFO);\n\tpf.hwnd = handle;\n\tpf.dwFlags = FLASHW_TIMER | FLASHW_TRAY;\n\tpf.uCount = 5;\n\tpf.dwTimeout = 75;\n\tFlashWindowEx(&pf);\n}\n",
        "output": "0",
        "index": 62186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void load_ucode_intel_ap(void)\n{\n\tstruct mc_saved_data *mc_saved_data_p;\n\tstruct ucode_cpu_info uci;\n\tunsigned long *mc_saved_in_initrd_p;\n\tunsigned long initrd_start_addr;\n#ifdef CONFIG_X86_32\n\tunsigned long *initrd_start_p;\n\n\tmc_saved_in_initrd_p =\n\t\t(unsigned long *)__pa_nodebug(mc_saved_in_initrd);\n\tmc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&mc_saved_data);\n\tinitrd_start_p = (unsigned long *)__pa_nodebug(&initrd_start);\n\tinitrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);\n#else\n\tmc_saved_data_p = &mc_saved_data;\n\tmc_saved_in_initrd_p = mc_saved_in_initrd;\n\tinitrd_start_addr = initrd_start;\n#endif\n\n\t/*\n\t * If there is no valid ucode previously saved in memory, no need to\n\t * update ucode on this AP.\n\t */\n\tif (mc_saved_data_p->mc_saved_count == 0)\n\t\treturn;\n\n\tcollect_cpu_info_early(&uci);\n\tload_microcode(mc_saved_data_p, mc_saved_in_initrd_p,\n\t\t       initrd_start_addr, &uci);\n\tapply_microcode_early(&uci, true);\n}\n",
        "output": "0",
        "index": 43848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int k90_init_macro_functions(struct hid_device *dev)\n{\n\tint ret;\n\tstruct corsair_drvdata *drvdata = hid_get_drvdata(dev);\n\tstruct k90_drvdata *k90;\n\tsize_t name_sz;\n\tchar *name;\n\n\tk90 = kzalloc(sizeof(struct k90_drvdata), GFP_KERNEL);\n\tif (!k90) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_drvdata;\n\t}\n\tdrvdata->k90 = k90;\n\n\t/* Init LED device for record LED */\n\tname_sz = strlen(dev_name(&dev->dev)) + sizeof(K90_RECORD_LED_SUFFIX);\n\tname = kzalloc(name_sz, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_record_led_alloc;\n\t}\n\tsnprintf(name, name_sz, \"%s\" K90_RECORD_LED_SUFFIX,\n\t\t dev_name(&dev->dev));\n\tk90->record_led.removed = false;\n\tk90->record_led.cdev.name = name;\n\tk90->record_led.cdev.max_brightness = 1;\n\tk90->record_led.cdev.brightness_set = k90_brightness_set;\n\tk90->record_led.cdev.brightness_get = k90_record_led_get;\n\tINIT_WORK(&k90->record_led.work, k90_record_led_work);\n\tk90->record_led.brightness = 0;\n\tret = led_classdev_register(&dev->dev, &k90->record_led.cdev);\n\tif (ret != 0)\n\t\tgoto fail_record_led;\n\n\t/* Init attributes */\n\tret = sysfs_create_group(&dev->dev.kobj, &k90_attr_group);\n\tif (ret != 0)\n\t\tgoto fail_sysfs;\n\n\treturn 0;\n\nfail_sysfs:\n\tk90->record_led.removed = true;\n\tled_classdev_unregister(&k90->record_led.cdev);\n\tcancel_work_sync(&k90->record_led.work);\nfail_record_led:\n\tkfree(k90->record_led.cdev.name);\nfail_record_led_alloc:\n\tkfree(k90);\nfail_drvdata:\n\tdrvdata->k90 = NULL;\n\treturn ret;\n}\n",
        "output": "0",
        "index": 68800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPICE_GNUC_VISIBLE void spice_server_set_seamless_migration(SpiceServer *s, int enable)\n{\n    spice_assert(s == reds);\n    /* seamless migration is not supported with multiple clients */\n    reds->seamless_migration_enabled = enable && !reds->allow_multiple_clients;\n    spice_debug(\"seamless migration enabled=%d\", enable);\n}\n",
        "output": "0",
        "index": 1988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline enum slow_d_compare slow_dentry_cmp(\n\t\tconst struct dentry *parent,\n\t\tstruct dentry *dentry,\n\t\tunsigned int seq,\n\t\tconst struct qstr *name)\n{\n\tint tlen = dentry->d_name.len;\n\tconst char *tname = dentry->d_name.name;\n\n\tif (read_seqcount_retry(&dentry->d_seq, seq)) {\n\t\tcpu_relax();\n\t\treturn D_COMP_SEQRETRY;\n\t}\n\tif (parent->d_op->d_compare(parent, dentry, tlen, tname, name))\n\t\treturn D_COMP_NOMATCH;\n\treturn D_COMP_OK;\n}\n",
        "output": "0",
        "index": 94611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::PromiseOverloadMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_promiseOverloadMethod\");\n\n  test_object_v8_internal::PromiseOverloadMethodMethod(info);\n}\n",
        "output": "0",
        "index": 147714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\n\tif (nfsd4_has_session(cstate) &&\n\t    (cstate->current_fh.fh_export->ex_flags & NFSEXP_PNFS)) {\n\t\topen->op_odstate = alloc_clnt_odstate(clp);\n\t\tif (!open->op_odstate)\n\t\t\treturn nfserr_jukebox;\n\t}\n\n\treturn nfs_ok;\n}\n",
        "output": "0",
        "index": 65618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_ext_try_to_merge(struct inode *inode,\n\t\t\t\t  struct ext4_ext_path *path,\n\t\t\t\t  struct ext4_extent *ex) {\n\tstruct ext4_extent_header *eh;\n\tunsigned int depth;\n\tint merge_done = 0;\n\tint ret = 0;\n\n\tdepth = ext_depth(inode);\n\tBUG_ON(path[depth].p_hdr == NULL);\n\teh = path[depth].p_hdr;\n\n\tif (ex > EXT_FIRST_EXTENT(eh))\n\t\tmerge_done = ext4_ext_try_to_merge_right(inode, path, ex - 1);\n\n\tif (!merge_done)\n\t\tret = ext4_ext_try_to_merge_right(inode, path, ex);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 34771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dump_attr(FILE *ofd, struct nlattr *attr, int prefix)\n{\n\tint len = nla_len(attr);\n\n\tdump_hex(ofd, nla_data(attr), len, prefix);\n}\n",
        "output": "0",
        "index": 12894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool BrowserWindowGtk::IsPanel() const {\n  return false;\n}\n",
        "output": "0",
        "index": 126383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void set_additional_callback_count(int c) { additional_callback_count_ = c; }\n",
        "output": "0",
        "index": 101136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TestGamepadMinimumDataImpl(WebXrVrBrowserTestBase* t) {\n  WebXrControllerInputMock my_mock;\n\n  unsigned int controller_index =\n      my_mock.CreateAndConnectMinimalGamepad(t->GetPrimaryAxisType());\n\n  t->LoadUrlAndAwaitInitialization(\n       t->GetFileUrlForHtmlTestFile(\"test_webxr_gamepad_support\"));\n   t->EnterSessionWithUserGestureOrFail();\n \n   my_mock.TogglePrimaryTrigger(controller_index);\n  my_mock.SetAxes(controller_index, device::XrButtonId::kAxisPrimary, 0.5,\n                  -0.5);\n  my_mock.ToggleButtonTouches(controller_index,\n                              device::XrButtonId::kAxisPrimary);\n\n  t->PollJavaScriptBooleanOrFail(\"isMappingEqualTo('xr-standard')\",\n                                 WebXrVrBrowserTestBase::kPollTimeoutShort);\n  t->PollJavaScriptBooleanOrFail(\"isButtonPressedEqualTo(0, true)\",\n                                 WebXrVrBrowserTestBase::kPollTimeoutShort);\n  t->PollJavaScriptBooleanOrFail(\"areAxesValuesEqualTo(0, 0.5, -0.5)\",\n                                 WebXrVrBrowserTestBase::kPollTimeoutShort);\n  t->RunJavaScriptOrFail(\"done()\");\n  t->EndTest();\n}\n",
        "output": "1",
        "index": 186532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kgdb_correct_hw_break(void)\n{\n\tint breakno;\n\n\tfor (breakno = 0; breakno < HBP_NUM; breakno++) {\n\t\tstruct perf_event *bp;\n\t\tstruct arch_hw_breakpoint *info;\n\t\tint val;\n\t\tint cpu = raw_smp_processor_id();\n\t\tif (!breakinfo[breakno].enabled)\n\t\t\tcontinue;\n\t\tif (dbg_is_early) {\n\t\t\tset_debugreg(breakinfo[breakno].addr, breakno);\n\t\t\tearly_dr7 |= encode_dr7(breakno,\n\t\t\t\t\t\tbreakinfo[breakno].len,\n\t\t\t\t\t\tbreakinfo[breakno].type);\n\t\t\tset_debugreg(early_dr7, 7);\n\t\t\tcontinue;\n\t\t}\n\t\tbp = *per_cpu_ptr(breakinfo[breakno].pev, cpu);\n\t\tinfo = counter_arch_bp(bp);\n\t\tif (bp->attr.disabled != 1)\n\t\t\tcontinue;\n\t\tbp->attr.bp_addr = breakinfo[breakno].addr;\n\t\tbp->attr.bp_len = breakinfo[breakno].len;\n\t\tbp->attr.bp_type = breakinfo[breakno].type;\n\t\tinfo->address = breakinfo[breakno].addr;\n\t\tinfo->len = breakinfo[breakno].len;\n\t\tinfo->type = breakinfo[breakno].type;\n\t\tval = arch_install_hw_breakpoint(bp);\n\t\tif (!val)\n\t\t\tbp->attr.disabled = 0;\n\t}\n\tif (!dbg_is_early)\n\t\thw_breakpoint_restore();\n}\n",
        "output": "0",
        "index": 25877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ProcessAllPendingMessages() {\n    loop_.RunAllPending();\n  }\n",
        "output": "0",
        "index": 113000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static std::string SniffMimeType(const std::string& content,\n                                 const std::string& url,\n                                 const std::string& mime_type_hint) {\n  std::string mime_type;\n  SniffMimeType(content.data(), content.size(), GURL(url),\n                     mime_type_hint, &mime_type);\n  return mime_type;\n}\n",
        "output": "0",
        "index": 161222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)\n\t{\n\tunsigned int ret;\n\tEVP_MD_CTX ctx, *d=NULL;\n\tint i;\n\n\tif (s->s3->handshake_buffer) \n\t\tif (!ssl3_digest_cached_records(s))\n\t\t\treturn 0;\n\n\tfor (i=0;i<SSL_MAX_DIGEST;i++) \n\t\t{\n\t\t  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) \n\t\t  \t{\n\t\t  \td=s->s3->handshake_dgst[i];\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif (!d) {\n\t\tSSLerr(SSL_F_TLS1_CERT_VERIFY_MAC,SSL_R_NO_REQUIRED_DIGEST);\n\t\treturn 0;\n\t}\t\n\n\tEVP_MD_CTX_init(&ctx);\n\tEVP_MD_CTX_copy_ex(&ctx,d);\n\tEVP_DigestFinal_ex(&ctx,out,&ret);\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn((int)ret);\n\t}\n",
        "output": "0",
        "index": 15410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PaintLayerScrollableArea::RestoreScrollAnchor(\n    const SerializedAnchor& serialized_anchor) {\n  return ShouldPerformScrollAnchoring() &&\n         scroll_anchor_.RestoreAnchor(serialized_anchor);\n}\n",
        "output": "0",
        "index": 141472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int media_not_present(struct scsi_disk *sdkp,\n\t\t\t     struct scsi_sense_hdr *sshdr)\n{\n\tif (!scsi_sense_valid(sshdr))\n\t\treturn 0;\n\n\t/* not invoked for commands that could return deferred errors */\n\tswitch (sshdr->sense_key) {\n\tcase UNIT_ATTENTION:\n\tcase NOT_READY:\n\t\t/* medium not present */\n\t\tif (sshdr->asc == 0x3A) {\n\t\t\tset_media_not_present(sdkp);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 94376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void zend_objects_store_add_ref_by_handle(zend_object_handle handle TSRMLS_DC)\n{\n\tEG(objects_store).object_buckets[handle].bucket.obj.refcount++;\n}\n",
        "output": "0",
        "index": 49975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool NetworkActionPredictor::IsPreconnectable(const AutocompleteMatch& match) {\n  switch (match.type) {\n    case AutocompleteMatch::SEARCH_WHAT_YOU_TYPED:\n    case AutocompleteMatch::SEARCH_HISTORY:\n    case AutocompleteMatch::SEARCH_SUGGEST:\n    case AutocompleteMatch::SEARCH_OTHER_ENGINE:\n      return true;\n\n    default:\n      return false;\n  }\n}\n",
        "output": "0",
        "index": 114704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Rect Browser::GetSavedWindowBounds() const {\n  const CommandLine& parsed_command_line = *CommandLine::ForCurrentProcess();\n  bool record_mode = parsed_command_line.HasSwitch(switches::kRecordMode);\n  bool playback_mode = parsed_command_line.HasSwitch(switches::kPlaybackMode);\n  if (record_mode || playback_mode) {\n    return gfx::Rect(0, 0, 800, 600);\n  }\n\n  gfx::Rect restored_bounds = override_bounds_;\n  bool maximized;\n  WindowSizer::GetBrowserWindowBounds(app_name_, restored_bounds, NULL,\n                                      &restored_bounds, &maximized);\n  return restored_bounds;\n}\n",
        "output": "0",
        "index": 107794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_ctxt_info(struct file *fp, void __user *ubase, __u32 len)\n{\n\tstruct hfi1_ctxt_info cinfo;\n\tstruct hfi1_filedata *fd = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tint ret = 0;\n\n\tmemset(&cinfo, 0, sizeof(cinfo));\n\tret = hfi1_get_base_kinfo(uctxt, &cinfo);\n\tif (ret < 0)\n\t\tgoto done;\n\tcinfo.num_active = hfi1_count_active_units();\n\tcinfo.unit = uctxt->dd->unit;\n\tcinfo.ctxt = uctxt->ctxt;\n\tcinfo.subctxt = fd->subctxt;\n\tcinfo.rcvtids = roundup(uctxt->egrbufs.alloced,\n\t\t\t\tuctxt->dd->rcv_entries.group_size) +\n\t\tuctxt->expected_count;\n\tcinfo.credits = uctxt->sc->credits;\n\tcinfo.numa_node = uctxt->numa_id;\n\tcinfo.rec_cpu = fd->rec_cpu_num;\n\tcinfo.send_ctxt = uctxt->sc->hw_context;\n\n\tcinfo.egrtids = uctxt->egrbufs.alloced;\n\tcinfo.rcvhdrq_cnt = uctxt->rcvhdrq_cnt;\n\tcinfo.rcvhdrq_entsize = uctxt->rcvhdrqentsize << 2;\n\tcinfo.sdma_ring_size = fd->cq->nentries;\n\tcinfo.rcvegr_size = uctxt->egrbufs.rcvtid_size;\n\n\ttrace_hfi1_ctxt_info(uctxt->dd, uctxt->ctxt, fd->subctxt, cinfo);\n\tif (copy_to_user(ubase, &cinfo, sizeof(cinfo)))\n\t\tret = -EFAULT;\ndone:\n\treturn ret;\n}\n",
        "output": "0",
        "index": 52962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int passwd_callback(char *buf, int num, int verify, void *data) /* {{{ */\n{\n    php_stream *stream = (php_stream *)data;\n    zval **val = NULL;\n    char *passphrase = NULL;\n    /* TODO: could expand this to make a callback into PHP user-space */\n\n    GET_VER_OPT_STRING(\"passphrase\", passphrase);\n\n    if (passphrase) {\n        if (Z_STRLEN_PP(val) < num - 1) {\n            memcpy(buf, Z_STRVAL_PP(val), Z_STRLEN_PP(val)+1);\n            return Z_STRLEN_PP(val);\n        }\n    }\n    return 0;\n}\n/* }}} */\n",
        "output": "0",
        "index": 147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TestScopedKeyboardHook::IsKeyLocked(ui::DomCode dom_code) {\n  DCHECK(keyboard_lock_active_) << \"Did you forget to reserve keys to lock?\";\n  return !locked_key_ || (locked_key_.value() == dom_code);\n}\n",
        "output": "0",
        "index": 158421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void UserCloudPolicyManagerChromeOS::OnInitializationCompleted(\n    CloudPolicyService* cloud_policy_service) {\n  DCHECK_EQ(service(), cloud_policy_service);\n  cloud_policy_service->RemoveObserver(this);\n\n  time_init_completed_ = base::Time::Now();\n  UMA_HISTOGRAM_MEDIUM_TIMES(kUMADelayInitialization,\n                             time_init_completed_ - time_init_started_);\n\n  if (!client()->is_registered()) {\n    if (wait_for_policy_fetch_) {\n      FetchPolicyOAuthTokenUsingSigninProfile();\n    } else if (!access_token_.empty()) {\n      OnAccessTokenAvailable(access_token_);\n    }\n  }\n\n  if (!wait_for_policy_fetch_) {\n    StartRefreshSchedulerIfReady();\n  }\n}\n",
        "output": "0",
        "index": 118651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels)\n{\n    cmsUInt8Number* Temp = NULL;\n    int i, j;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n    if (nChannels <= 0) return FALSE;\n\n    memset(Tables, 0, sizeof(Tables));\n\n    Temp = (cmsUInt8Number*) _cmsMalloc(ContextID, 256);\n    if (Temp == NULL) return FALSE;\n\n    for (i=0; i < nChannels; i++) {\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, 256, NULL);\n        if (Tables[i] == NULL) goto Error;\n    }\n\n    for (i=0; i < nChannels; i++) {\n\n        if (io ->Read(io, Temp, 256, 1) != 1) goto Error;\n\n        for (j=0; j < 256; j++)\n            Tables[i]->Table16[j] = (cmsUInt16Number) FROM_8_TO_16(Temp[j]);\n    }\n\n    _cmsFree(ContextID, Temp);\n    Temp = NULL;\n\n    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))\n        goto Error;\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    if (Temp) _cmsFree(ContextID, Temp);\n    return FALSE;\n}\n",
        "output": "0",
        "index": 70945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static gboolean OnButtonPressReleaseEvent(\n      GtkWidget* widget,\n      GdkEventButton* event,\n      RenderWidgetHostViewGtk* host_view) {\n    TRACE_EVENT0(\"browser\",\n                 \"RenderWidgetHostViewGtkWidget::OnButtonPressReleaseEvent\");\n\n    if (event->type != GDK_BUTTON_RELEASE)\n      host_view->set_last_mouse_down(event);\n\n    if (!(event->button == 1 || event->button == 2 || event->button == 3))\n      return FALSE;  // We do not forward any other buttons to the renderer.\n    if (event->type == GDK_2BUTTON_PRESS || event->type == GDK_3BUTTON_PRESS)\n      return FALSE;\n\n    if (!gtk_widget_is_focus(widget))\n      host_view->host_->OnPointerEventActivate();\n\n    if (event->type != GDK_BUTTON_RELEASE)\n      host_view->im_context_->ConfirmComposition();\n\n    GtkWidget* event_widget = gtk_get_event_widget(\n        reinterpret_cast<GdkEvent*>(event));\n    if (event_widget != widget) {\n      int x = 0;\n      int y = 0;\n      gtk_widget_get_pointer(widget, &x, &y);\n      GtkAllocation allocation;\n      gtk_widget_get_allocation(widget, &allocation);\n      bool click_in_popup = x >= 0 && y >= 0 && x < allocation.width &&\n          y < allocation.height;\n      if (event->type != GDK_BUTTON_RELEASE && host_view->IsPopup() &&\n          !host_view->is_popup_first_mouse_release_ && !click_in_popup) {\n        host_view->host_->Shutdown();\n        return FALSE;\n      }\n      event->x = x;\n      event->y = y;\n    }\n\n    if (event->type == GDK_BUTTON_PRESS && !gtk_widget_has_focus(widget))\n      gtk_widget_grab_focus(widget);\n\n    host_view->is_popup_first_mouse_release_ = false;\n    RenderWidgetHostImpl* widget_host =\n        RenderWidgetHostImpl::From(host_view->GetRenderWidgetHost());\n    if (widget_host)\n      widget_host->ForwardMouseEvent(WebInputEventFactory::mouseEvent(event));\n\n    return FALSE;\n  }\n",
        "output": "0",
        "index": 123319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int emulator_read_write(struct x86_emulate_ctxt *ctxt, unsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tstruct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint rc, now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\treturn emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t   vcpu, ops);\n}\n",
        "output": "0",
        "index": 20683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ShelfLayoutManager::CanStartFullscreenAppListDrag(\n    float scroll_y_hint) const {\n  if (!shelf_->IsHorizontalAlignment())\n    return false;\n\n  if (!IsVisible())\n    return false;\n\n  if (shelf_widget_->IsShowingOverflowBubble())\n    return false;\n\n  if (is_app_list_visible_)\n    return false;\n\n  if (scroll_y_hint >= 0)\n    return false;\n\n  if (IsHomeLauncherEnabledInTabletMode())\n    return false;\n\n  return true;\n}\n",
        "output": "0",
        "index": 142426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::DidCommitProvisionalLoad(\n    std::unique_ptr<FrameHostMsg_DidCommitProvisionalLoad_Params>\n        validated_params,\n    mojom::DidCommitProvisionalLoadInterfaceParamsPtr interface_params) {\n  if (MaybeInterceptCommitCallback(nullptr, validated_params.get(),\n                                   &interface_params)) {\n    DidCommitNavigation(std::move(navigation_request_),\n                        std::move(validated_params),\n                        std::move(interface_params));\n  }\n}\n",
        "output": "0",
        "index": 151922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static xmlEntityPtr SVGGetEntity(void *context,const xmlChar *name)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Get an entity by name.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  SAX.SVGGetEntity(%s)\",\n    name);\n  svg_info=(SVGInfo *) context;\n  return(xmlGetDocEntity(svg_info->document,name));\n}\n",
        "output": "0",
        "index": 71727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void v9fs_mkdir(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    size_t offset = 7;\n    int32_t fid;\n    struct stat stbuf;\n    V9fsQID qid;\n    V9fsString name;\n    V9fsFidState *fidp;\n    gid_t gid;\n    int mode;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsdd\", &fid, &name, &mode, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_mkdir(pdu->tag, pdu->id, fid, name.data, mode, gid);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    err = v9fs_co_mkdir(pdu, fidp, &name, mode, fidp->uid, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    stat_to_qid(&stbuf, &qid);\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_mkdir_return(pdu->tag, pdu->id,\n                            qid.type, qid.version, qid.path, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}\n",
        "output": "0",
        "index": 8223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit au1100fb_unload(void)\n{\n\tplatform_driver_unregister(&au1100fb_driver);\n}\n",
        "output": "0",
        "index": 28335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_environment_file(char ***env, u_int *envsize,\n\tconst char *filename)\n{\n\tFILE *f;\n\tchar buf[4096];\n\tchar *cp, *value;\n\tu_int lineno = 0;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn;\n\n\twhile (fgets(buf, sizeof(buf), f)) {\n\t\tif (++lineno > 1000)\n\t\t\tfatal(\"Too many lines in environment file %s\", filename);\n\t\tfor (cp = buf; *cp == ' ' || *cp == '\\t'; cp++)\n\t\t\t;\n\t\tif (!*cp || *cp == '#' || *cp == '\\n')\n\t\t\tcontinue;\n\n\t\tcp[strcspn(cp, \"\\n\")] = '\\0';\n\n\t\tvalue = strchr(cp, '=');\n\t\tif (value == NULL) {\n\t\t\tfprintf(stderr, \"Bad line %u in %.100s\\n\", lineno,\n\t\t\t    filename);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Replace the equals sign by nul, and advance value to\n\t\t * the value string.\n\t\t */\n\t\t*value = '\\0';\n\t\tvalue++;\n\t\tchild_set_env(env, envsize, cp, value);\n\t}\n\tfclose(f);\n}\n",
        "output": "0",
        "index": 14398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LocalDOMWindow::DispatchLoadEvent() {\n  Event* load_event(Event::Create(EventTypeNames::load));\n  DocumentLoader* document_loader =\n      GetFrame() ? GetFrame()->Loader().GetDocumentLoader() : nullptr;\n  if (document_loader &&\n      document_loader->GetTiming().LoadEventStart().is_null()) {\n    DocumentLoadTiming& timing = document_loader->GetTiming();\n    timing.MarkLoadEventStart();\n    DispatchEvent(load_event, document());\n    timing.MarkLoadEventEnd();\n    DCHECK(document_loader->Fetcher());\n    if (GetFrame() &&\n        document_loader == GetFrame()->Loader().GetDocumentLoader() &&\n        document_loader->Fetcher()->CountPreloads()) {\n      unused_preloads_timer_.StartOneShot(kUnusedPreloadTimeoutInSeconds,\n                                          FROM_HERE);\n    }\n  } else {\n    DispatchEvent(load_event, document());\n  }\n\n  if (GetFrame()) {\n    WindowPerformance* performance = DOMWindowPerformance::performance(*this);\n    DCHECK(performance);\n    performance->NotifyNavigationTimingToObservers();\n  }\n\n  FrameOwner* owner = GetFrame() ? GetFrame()->Owner() : nullptr;\n  if (owner)\n    owner->DispatchLoad();\n\n  TRACE_EVENT_INSTANT1(\"devtools.timeline\", \"MarkLoad\",\n                       TRACE_EVENT_SCOPE_THREAD, \"data\",\n                       InspectorMarkLoadEvent::Data(GetFrame()));\n  probe::loadEventFired(GetFrame());\n}\n",
        "output": "0",
        "index": 136741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfunc(I_BDEV(inode), arg);\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}\n",
        "output": "0",
        "index": 46281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64 HttpResponseHeaders::GetContentLength() const {\n  void* iter = NULL;\n  std::string content_length_val;\n  if (!EnumerateHeader(&iter, \"content-length\", &content_length_val))\n    return -1;\n\n  if (content_length_val.empty())\n    return -1;\n\n  if (content_length_val[0] == '+')\n    return -1;\n\n  int64 result;\n  bool ok = base::StringToInt64(content_length_val, &result);\n  if (!ok || result < 0)\n    return -1;\n\n  return result;\n}\n",
        "output": "0",
        "index": 100789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n\n    if (type != EXPR_TYPE_INT)\n        return false;\n\n    str = xkb_atom_text(ctx, field);\n\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n\n    *val_rtrn = (1u << ndx);\n    return true;\n}\n",
        "output": "0",
        "index": 79030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ContentSecurityPolicy::ReportReportOnlyInMeta(const String& header) {\n  LogToConsole(\"The report-only Content Security Policy '\" + header +\n               \"' was delivered via a <meta> element, which is disallowed. The \"\n               \"policy has been ignored.\");\n}\n",
        "output": "0",
        "index": 165549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ChromeMockRenderThread::OnDidGetPreviewPageCount(\n    const PrintHostMsg_DidGetPreviewPageCount_Params& params) {\n  print_preview_pages_remaining_ = params.page_count;\n}\n",
        "output": "0",
        "index": 112811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PictureLayerImpl::CleanUpTilingsOnActiveLayer(\n    std::vector<PictureLayerTiling*> used_tilings) {\n  DCHECK(layer_tree_impl()->IsActiveTree());\n  if (tilings_->num_tilings() == 0)\n    return;\n\n  float min_acceptable_high_res_scale = std::min(\n      raster_contents_scale_, ideal_contents_scale_);\n  float max_acceptable_high_res_scale = std::max(\n      raster_contents_scale_, ideal_contents_scale_);\n\n  PictureLayerImpl* twin = GetPendingOrActiveTwinLayer();\n  if (twin && twin->CanHaveTilings()) {\n    min_acceptable_high_res_scale = std::min(\n        min_acceptable_high_res_scale,\n        std::min(twin->raster_contents_scale_, twin->ideal_contents_scale_));\n    max_acceptable_high_res_scale = std::max(\n        max_acceptable_high_res_scale,\n        std::max(twin->raster_contents_scale_, twin->ideal_contents_scale_));\n  }\n\n  PictureLayerTilingSet* twin_set = twin ? twin->tilings_.get() : nullptr;\n  PictureLayerImpl* recycled_twin = GetRecycledTwinLayer();\n  PictureLayerTilingSet* recycled_twin_set =\n      recycled_twin ? recycled_twin->tilings_.get() : nullptr;\n\n  tilings_->CleanUpTilings(min_acceptable_high_res_scale,\n                           max_acceptable_high_res_scale, used_tilings,\n                           layer_tree_impl()->create_low_res_tiling(), twin_set,\n                           recycled_twin_set);\n\n  if (recycled_twin_set && recycled_twin_set->num_tilings() == 0)\n    recycled_twin->ResetRasterScale();\n\n  DCHECK_GT(tilings_->num_tilings(), 0u);\n  SanityCheckTilingState();\n}\n",
        "output": "0",
        "index": 132820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_label_release_security(struct nfs4_label *label)\n{ return; }\n",
        "output": "0",
        "index": 57144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool NavigationControllerImpl::CanViewSource() const {\n  const std::string& mime_type = web_contents_->GetContentsMimeType();\n  bool is_viewable_mime_type = net::IsSupportedNonImageMimeType(mime_type) &&\n      !net::IsSupportedMediaMimeType(mime_type);\n  NavigationEntry* active_entry = GetActiveEntry();\n  return active_entry && !active_entry->IsViewSourceMode() &&\n      is_viewable_mime_type && !web_contents_->GetInterstitialPage();\n}\n",
        "output": "0",
        "index": 119748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_inode_ag_iterator_flags(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\titer_flags)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\terror = 0;\n\tint\t\t\tlast_error = 0;\n\txfs_agnumber_t\t\tag;\n\n\tag = 0;\n\twhile ((pag = xfs_perag_get(mp, ag))) {\n\t\tag = pag->pag_agno + 1;\n\t\terror = xfs_inode_ag_walk(mp, pag, execute, flags, args, -1,\n\t\t\t\t\t  iter_flags);\n\t\txfs_perag_put(pag);\n\t\tif (error) {\n\t\t\tlast_error = error;\n\t\t\tif (error == -EFSCORRUPTED)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn last_error;\n}\n",
        "output": "0",
        "index": 79955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void locationReplaceableAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::locationReplaceableAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 131447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TEE_Result get_prop_ta_app_id(struct tee_ta_session *sess,\n\t\t\t\t     void *buf, size_t *blen)\n{\n\tif (*blen < sizeof(TEE_UUID)) {\n\t\t*blen = sizeof(TEE_UUID);\n\t\treturn TEE_ERROR_SHORT_BUFFER;\n\t}\n\t*blen = sizeof(TEE_UUID);\n\treturn tee_svc_copy_to_user(buf, &sess->ctx->uuid, sizeof(TEE_UUID));\n}\n",
        "output": "0",
        "index": 86907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JSFloat64Array::getOwnPropertyDescriptor(JSObject* object, ExecState* exec, const Identifier& propertyName, PropertyDescriptor& descriptor)\n{\n    JSFloat64Array* thisObject = jsCast<JSFloat64Array*>(object);\n    ASSERT_GC_OBJECT_INHERITS(thisObject, &s_info);\n    bool ok;\n    unsigned index = propertyName.toUInt32(ok);\n    if (ok && index < static_cast<Float64Array*>(thisObject->impl())->length()) {\n        descriptor.setDescriptor(thisObject->getByIndex(exec, index), DontDelete);\n        return true;\n    }\n    return getStaticValueDescriptor<JSFloat64Array, Base>(exec, getJSFloat64ArrayTable(exec), thisObject, propertyName, descriptor);\n}\n",
        "output": "0",
        "index": 105918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sg_proc_cleanup(void)\n{\n\tint k;\n\tint num_leaves = ARRAY_SIZE(sg_proc_leaf_arr);\n\n\tif (!sg_proc_sgp)\n\t\treturn;\n\tfor (k = 0; k < num_leaves; ++k)\n\t\tremove_proc_entry(sg_proc_leaf_arr[k].name, sg_proc_sgp);\n\tremove_proc_entry(sg_proc_sg_dirname, NULL);\n}\n",
        "output": "0",
        "index": 42279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sysvipc_shm_proc_show(struct seq_file *s, void *it)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct shmid_kernel *shp = it;\n\tunsigned long rss = 0, swp = 0;\n\n\tshm_add_rss_swap(shp, &rss, &swp);\n\n#if BITS_PER_LONG <= 32\n#define SIZE_SPEC \"%10lu\"\n#else\n#define SIZE_SPEC \"%21lu\"\n#endif\n\n\tseq_printf(s,\n\t\t   \"%10d %10d  %4o \" SIZE_SPEC \" %5u %5u  \"\n\t\t   \"%5lu %5u %5u %5u %5u %10lu %10lu %10lu \"\n\t\t   SIZE_SPEC \" \" SIZE_SPEC \"\\n\",\n\t\t   shp->shm_perm.key,\n\t\t   shp->shm_perm.id,\n\t\t   shp->shm_perm.mode,\n\t\t   shp->shm_segsz,\n\t\t   shp->shm_cprid,\n\t\t   shp->shm_lprid,\n\t\t   shp->shm_nattch,\n\t\t   from_kuid_munged(user_ns, shp->shm_perm.uid),\n\t\t   from_kgid_munged(user_ns, shp->shm_perm.gid),\n\t\t   from_kuid_munged(user_ns, shp->shm_perm.cuid),\n\t\t   from_kgid_munged(user_ns, shp->shm_perm.cgid),\n\t\t   shp->shm_atim,\n\t\t   shp->shm_dtim,\n\t\t   shp->shm_ctim,\n\t\t   rss * PAGE_SIZE,\n\t\t   swp * PAGE_SIZE);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 42030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VOID MiniportDisableMSIInterrupt(\n    IN PVOID  MiniportInterruptContext,\n    IN ULONG  MessageId\n    )\n{\n    PARANDIS_ADAPTER *pContext = (PARANDIS_ADAPTER *)MiniportInterruptContext;\n    /* TODO - How we prevent DPC procedure from re-enabling interrupt? */\n\n    CParaNdisAbstractPath *path = GetPathByMessageId(pContext, MessageId);\n    path->DisableInterrupts();\n}\n",
        "output": "0",
        "index": 96348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BrowserFrameGtk::GetMinimizeButtonOffset() const {\n  NOTIMPLEMENTED();\n  return 0;\n}\n",
        "output": "0",
        "index": 103367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_MINIT_FUNCTION(exif)\n{\n\tREGISTER_INI_ENTRIES();\n\tif (zend_hash_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\"))) {\n\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 1, CONST_CS | CONST_PERSISTENT);\n\t} else {\n\t\tREGISTER_LONG_CONSTANT(\"EXIF_USE_MBSTRING\", 0, CONST_CS | CONST_PERSISTENT);\n\t}\n\treturn SUCCESS;\n}\n",
        "output": "0",
        "index": 9573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\n{\n\tstruct sense_iu *sense_iu = urb->transfer_buffer;\n\tstruct scsi_device *sdev = cmnd->device;\n\n\tif (urb->actual_length > 16) {\n\t\tunsigned len = be16_to_cpup(&sense_iu->len);\n\t\tif (len + 16 != urb->actual_length) {\n\t\t\tint newlen = min(len + 16, urb->actual_length) - 16;\n\t\t\tif (newlen < 0)\n\t\t\t\tnewlen = 0;\n\t\t\tsdev_printk(KERN_INFO, sdev, \"%s: urb length %d \"\n\t\t\t\t\"disagrees with IU sense data length %d, \"\n\t\t\t\t\"using %d bytes of sense data\\n\", __func__,\n\t\t\t\t\turb->actual_length, len, newlen);\n\t\t\tlen = newlen;\n\t\t}\n\t\tmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\n\t}\n\n\tcmnd->result = sense_iu->status;\n}\n",
        "output": "0",
        "index": 59910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderWidgetHostView* RenderWidgetHostView::CreateViewForWidget(\n    RenderWidgetHost* widget) {\n  return new RenderWidgetHostViewAura(widget);\n}\n",
        "output": "0",
        "index": 123157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LockScreenMediaControlsView::MediaControllerImageChanged(\n    media_session::mojom::MediaSessionImageType type,\n    const SkBitmap& bitmap) {\n  if (hide_controls_timer_->IsRunning())\n    return;\n\n  SkBitmap converted_bitmap;\n  if (bitmap.colorType() == kN32_SkColorType) {\n    converted_bitmap = bitmap;\n  } else {\n    SkImageInfo info = bitmap.info().makeColorType(kN32_SkColorType);\n    if (converted_bitmap.tryAllocPixels(info)) {\n      bitmap.readPixels(info, converted_bitmap.getPixels(),\n                        converted_bitmap.rowBytes(), 0, 0);\n    }\n  }\n\n  switch (type) {\n    case media_session::mojom::MediaSessionImageType::kArtwork: {\n      base::Optional<gfx::ImageSkia> session_artwork =\n          gfx::ImageSkia::CreateFrom1xBitmap(converted_bitmap);\n      SetArtwork(session_artwork);\n      break;\n    }\n    case media_session::mojom::MediaSessionImageType::kSourceIcon: {\n      gfx::ImageSkia session_icon =\n          gfx::ImageSkia::CreateFrom1xBitmap(converted_bitmap);\n      if (session_icon.isNull()) {\n        session_icon = gfx::CreateVectorIcon(message_center::kProductIcon,\n                                             kIconSize, gfx::kChromeIconGrey);\n      }\n      header_row_->SetAppIcon(session_icon);\n    }\n  }\n}\n",
        "output": "0",
        "index": 149172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int addrconf_sysctl_register(struct inet6_dev *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->nd_parms,\n\t\t\t\t    &ndisc_ifinfo_sysctl_change);\n\tif (err)\n\t\treturn err;\n\terr = __addrconf_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\t idev, &idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->nd_parms);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 41800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void streamFreeConsumer(streamConsumer *sc) {\n    raxFree(sc->pel); /* No value free callback: the PEL entries are shared\n                         between the consumer and the main stream PEL. */\n    sdsfree(sc->name);\n    zfree(sc);\n}\n",
        "output": "0",
        "index": 81793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ip6_tnl_set_cap(struct ip6_tnl *t)\n{\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tint ltype = ipv6_addr_type(&p->laddr);\n\tint rtype = ipv6_addr_type(&p->raddr);\n\n\tp->flags &= ~(IP6_TNL_F_CAP_XMIT|IP6_TNL_F_CAP_RCV);\n\n\tif (ltype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t    rtype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t    !((ltype|rtype) & IPV6_ADDR_LOOPBACK) &&\n\t    (!((ltype|rtype) & IPV6_ADDR_LINKLOCAL) || p->link)) {\n\t\tif (ltype&IPV6_ADDR_UNICAST)\n\t\t\tp->flags |= IP6_TNL_F_CAP_XMIT;\n\t\tif (rtype&IPV6_ADDR_UNICAST)\n\t\t\tp->flags |= IP6_TNL_F_CAP_RCV;\n\t}\n}\n",
        "output": "0",
        "index": 27422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int buf_to_pages_noslab(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tstruct page *newpage, **spages;\n\tint rc = 0;\n\tsize_t len;\n\tspages = pages;\n\n\tdo {\n\t\tlen = min_t(size_t, PAGE_CACHE_SIZE, buflen);\n\t\tnewpage = alloc_page(GFP_KERNEL);\n\n\t\tif (newpage == NULL)\n\t\t\tgoto unwind;\n\t\tmemcpy(page_address(newpage), buf, len);\n                buf += len;\n                buflen -= len;\n\t\t*pages++ = newpage;\n\t\trc++;\n\t} while (buflen != 0);\n\n\treturn rc;\n\nunwind:\n\tfor(; rc > 0; rc--)\n\t\t__free_page(spages[rc-1]);\n\treturn -ENOMEM;\n}\n",
        "output": "0",
        "index": 19841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "epass2003_restore_security_env(struct sc_card *card, int se_num)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
        "output": "0",
        "index": 78398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u64 hash_name(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\treturn hashlen_create(end_name_hash(hash), len);\n}\n",
        "output": "0",
        "index": 67435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct se_wwn *srpt_make_tport(struct target_fabric_configfs *tf,\n\t\t\t\t      struct config_group *group,\n\t\t\t\t      const char *name)\n{\n\tstruct srpt_port *sport;\n\tint ret;\n\n\tsport = srpt_lookup_port(name);\n\tpr_debug(\"make_tport(%s)\\n\", name);\n\tret = -EINVAL;\n\tif (!sport)\n\t\tgoto err;\n\n\treturn &sport->port_wwn;\n\nerr:\n\treturn ERR_PTR(ret);\n}\n",
        "output": "0",
        "index": 50676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::LocationWithExceptionAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_locationWithException_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::LocationWithExceptionAttributeSetter(v8_value, info);\n}\n",
        "output": "0",
        "index": 147504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ExtensionPrefs::ReadExtensionPrefInteger(\n    const std::string& extension_id, const std::string& pref_key,\n    int* out_value) {\n  const DictionaryValue* ext = GetExtensionPref(extension_id);\n  if (!ext) {\n    return false;\n  }\n  return ReadIntegerFromPref(ext, pref_key, out_value);\n}\n",
        "output": "0",
        "index": 102301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ATSParser::Program::parsePSISection(\n unsigned pid, ABitReader *br, status_t *err) {\n *err = OK;\n\n if (pid != mProgramMapPID) {\n return false;\n }\n\n *err = parseProgramMap(br);\n\n return true;\n}\n",
        "output": "0",
        "index": 173672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebString WebGraphicsContext3DDefaultImpl::getProgramInfoLog(WebGLId program)\n{\n    makeContextCurrent();\n    GLint logLength;\n    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logLength);\n    if (!logLength)\n        return WebString();\n    GLchar* log = 0;\n    if (!tryFastMalloc(logLength * sizeof(GLchar)).getValue(log))\n        return WebString();\n    GLsizei returnedLogLength;\n    glGetProgramInfoLog(program, logLength, &returnedLogLength, log);\n    ASSERT(logLength == returnedLogLength + 1);\n    WebString res = WebString::fromUTF8(log, returnedLogLength);\n    fastFree(log);\n    return res;\n}\n",
        "output": "0",
        "index": 99003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nf_tables_getrule(struct sock *nlsk, struct sk_buff *skb,\n\t\t\t     const struct nlmsghdr *nlh,\n\t\t\t     const struct nlattr * const nla[])\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(nlh);\n\tconst struct nft_af_info *afi;\n\tconst struct nft_table *table;\n\tconst struct nft_chain *chain;\n\tconst struct nft_rule *rule;\n\tstruct sk_buff *skb2;\n\tstruct net *net = sock_net(skb->sk);\n\tint family = nfmsg->nfgen_family;\n\tint err;\n\n\tif (nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = nf_tables_dump_rules,\n\t\t};\n\t\treturn netlink_dump_start(nlsk, skb, nlh, &c);\n\t}\n\n\tafi = nf_tables_afinfo_lookup(net, family, false);\n\tif (IS_ERR(afi))\n\t\treturn PTR_ERR(afi);\n\n\ttable = nf_tables_table_lookup(afi, nla[NFTA_RULE_TABLE]);\n\tif (IS_ERR(table))\n\t\treturn PTR_ERR(table);\n\tif (table->flags & NFT_TABLE_INACTIVE)\n\t\treturn -ENOENT;\n\n\tchain = nf_tables_chain_lookup(table, nla[NFTA_RULE_CHAIN]);\n\tif (IS_ERR(chain))\n\t\treturn PTR_ERR(chain);\n\tif (chain->flags & NFT_CHAIN_INACTIVE)\n\t\treturn -ENOENT;\n\n\trule = nf_tables_rule_lookup(chain, nla[NFTA_RULE_HANDLE]);\n\tif (IS_ERR(rule))\n\t\treturn PTR_ERR(rule);\n\n\tskb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb2)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_fill_rule_info(skb2, net, NETLINK_CB(skb).portid,\n\t\t\t\t       nlh->nlmsg_seq, NFT_MSG_NEWRULE, 0,\n\t\t\t\t       family, table, chain, rule);\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);\n\nerr:\n\tkfree_skb(skb2);\n\treturn err;\n}\n",
        "output": "0",
        "index": 57973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asepcos_tlvpath_to_scpath(sc_path_t *out, const u8 *in, size_t in_len)\n{\n\tint    r;\n\tsize_t len = in_len;\n\n\tmemset(out, 0, sizeof(sc_path_t));\n\n\twhile (len != 0) {\n\t\tif (len < 4)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (in[0] != 0x8b || in[1] != 0x02)\n\t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\t\t/* append file id to the path */\n\t\tr = sc_append_path_id(out, &in[2], 2);\n\t\tif (r != SC_SUCCESS)\n\t\t\treturn r;\n\t\tlen -= 4;\n\t\tin  += 4;\n\t}\n\tout->type = SC_PATH_TYPE_PATH;\n\n\treturn SC_SUCCESS;\n}\n",
        "output": "0",
        "index": 78171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ExecuteMoveWordLeftAndModifySelection(LocalFrame& frame,\n                                                  Event*,\n                                                  EditorCommandSource,\n                                                  const String&) {\n  frame.Selection().Modify(SelectionModifyAlteration::kExtend,\n                           SelectionModifyDirection::kLeft,\n                           TextGranularity::kWord, SetSelectionBy::kUser);\n  return true;\n}\n",
        "output": "0",
        "index": 139488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CenterDialog(HWND hDlg)\n{\n\tHWND hParent;\n\tRECT rc, rcDlg, rcParent;\n\n\tif ((hParent = GetParent(hDlg)) == NULL) {\n\t\thParent = GetDesktopWindow();\n\t}\n\n\tGetWindowRect(hParent, &rcParent);\n\tGetWindowRect(hDlg, &rcDlg);\n\tCopyRect(&rc, &rcParent);\n\n\tOffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);\n\tOffsetRect(&rc, -rc.left, -rc.top);\n\tOffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);\n\n\tSetWindowPos(hDlg, HWND_TOP, rcParent.left + (rc.right / 2), rcParent.top + (rc.bottom / 2) - 25, 0, 0, SWP_NOSIZE);\n}\n",
        "output": "0",
        "index": 62174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BluetoothAdapterChromeOS::StopDiscovering(\n    const base::Closure& callback,\n    const ErrorCallback& error_callback) {\n  DBusThreadManager::Get()->GetBluetoothAdapterClient()->\n      StopDiscovery(\n          object_path_,\n          base::Bind(&BluetoothAdapterChromeOS::OnStopDiscovery,\n                     weak_ptr_factory_.GetWeakPtr(),\n                     callback),\n          base::Bind(&BluetoothAdapterChromeOS::OnStopDiscoveryError,\n                     weak_ptr_factory_.GetWeakPtr(),\n                     error_callback));\n}\n",
        "output": "0",
        "index": 120795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evdns_base_free(struct evdns_base *base, int fail_requests)\n{\n\tEVDNS_LOCK(base);\n\tevdns_base_free_and_unlock(base, fail_requests);\n}\n",
        "output": "0",
        "index": 70578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_libxml_clear_object(php_libxml_node_object *object TSRMLS_DC)\n{\n\tif (object->properties) {\n\t\tobject->properties = NULL;\n\t}\n\tphp_libxml_decrement_node_ptr(object TSRMLS_CC);\n\treturn php_libxml_decrement_doc_ref(object TSRMLS_CC);\n}\n",
        "output": "0",
        "index": 4223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fz_new_default_colorspaces(fz_context *ctx)\n{\n\tfz_default_colorspaces *default_cs = fz_malloc_struct(ctx, fz_default_colorspaces);\n\tdefault_cs->refs = 1;\n\tdefault_cs->gray = fz_keep_colorspace(ctx, fz_device_gray(ctx));\n\tdefault_cs->rgb = fz_keep_colorspace(ctx, fz_device_rgb(ctx));\n\tdefault_cs->cmyk = fz_keep_colorspace(ctx, fz_device_cmyk(ctx));\n\tdefault_cs->oi = NULL;\n\treturn default_cs;\n}\n",
        "output": "0",
        "index": 396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CronTab::init() {\n\tinitRegexObject();\n\tthis->lastRunTime = CRONTAB_INVALID;\n\tthis->valid = false;\n\t\n\tint mins[]\t\t\t\t= { CRONTAB_MINUTE_MIN,\n\t\t\t\t\t\t\t\tCRONTAB_HOUR_MIN,\n\t\t\t\t\t\t\t\tCRONTAB_DAY_OF_MONTH_MIN,\n\t\t\t\t\t\t\t\tCRONTAB_MONTH_MIN,\n\t\t\t\t\t\t\t\tCRONTAB_DAY_OF_WEEK_MIN\n\t};\n\tint maxs[]\t\t\t\t= { CRONTAB_MINUTE_MAX,\n\t\t\t\t\t\t\t\tCRONTAB_HOUR_MAX,\n\t\t\t\t\t\t\t\tCRONTAB_DAY_OF_MONTH_MAX,\n\t\t\t\t\t\t\t\tCRONTAB_MONTH_MAX,\n\t\t\t\t\t\t\t\tCRONTAB_DAY_OF_WEEK_MAX\n\t};\n\tbool failed = false;\n\tint ctr;\n\tfor ( ctr = 0; ctr < CRONTAB_FIELDS; ctr++ ) {\n\t\tthis->ranges[ctr] = new ExtArray<int>();\t\t\t\n\t\tif ( !this->expandParameter( ctr, mins[ctr], maxs[ctr] )) {\n\t\t\tfailed = true;\n\t\t}\n\t} // FOR\n\tif ( !failed ) {\n\t\tthis->valid = true;\n\t}\n\t\n\treturn;\n}\n",
        "output": "0",
        "index": 16541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(imagecreatefromxpm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XPM, \"XPM\", gdImageCreateFromXpm, NULL);\n}\n",
        "output": "0",
        "index": 15117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pmd_clear_bad(pmd_t *pmd)\n{\n\tpmd_ERROR(*pmd);\n\tpmd_clear(pmd);\n}\n",
        "output": "0",
        "index": 21252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_syscall_exit(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *ent = iter->ent;\n\tstruct syscall_trace_exit *trace;\n\tint syscall;\n\tstruct syscall_metadata *entry;\n\tint ret;\n\n\ttrace = (typeof(trace))ent;\n\tsyscall = trace->nr;\n\tentry = syscall_nr_to_meta(syscall);\n\n\tif (!entry) {\n\t\ttrace_seq_putc(s, '\\n');\n\t\treturn TRACE_TYPE_HANDLED;\n\t}\n\n\tif (entry->exit_event->event.type != ent->type) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn TRACE_TYPE_UNHANDLED;\n\t}\n\n\tret = trace_seq_printf(s, \"%s -> 0x%lx\\n\", entry->name,\n\t\t\t\ttrace->ret);\n\tif (!ret)\n\t\treturn TRACE_TYPE_PARTIAL_LINE;\n\n\treturn TRACE_TYPE_HANDLED;\n}\n",
        "output": "0",
        "index": 35910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLInputElement::UpdateFocusAppearanceWithOptions(\n    SelectionBehaviorOnFocus selection_behavior,\n    const FocusOptions& options) {\n  if (IsTextField()) {\n    switch (selection_behavior) {\n      case SelectionBehaviorOnFocus::kReset:\n        select();\n        break;\n      case SelectionBehaviorOnFocus::kRestore:\n        RestoreCachedSelection();\n        break;\n      case SelectionBehaviorOnFocus::kNone:\n        return;\n    }\n    GetDocument().EnsurePaintLocationDataValidForNode(this);\n    if (!options.preventScroll()) {\n      if (GetLayoutObject()) {\n        GetLayoutObject()->ScrollRectToVisible(BoundingBoxForScrollIntoView(),\n                                               WebScrollIntoViewParams());\n      }\n      if (GetDocument().GetFrame())\n        GetDocument().GetFrame()->Selection().RevealSelection();\n    }\n  } else {\n    TextControlElement::UpdateFocusAppearanceWithOptions(selection_behavior,\n                                                         options);\n  }\n}\n",
        "output": "0",
        "index": 136996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u32 nfsd4_getdeviceinfo_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tu32 maxcount = 0, rlen = 0;\n\n\tmaxcount = svc_max_payload(rqstp);\n\trlen = min(op->u.getdeviceinfo.gd_maxcount, maxcount);\n\n\treturn (op_encode_hdr_size +\n\t\t1 /* gd_layout_type*/ +\n\t\tXDR_QUADLEN(rlen) +\n\t\t2 /* gd_notify_types */) * sizeof(__be32);\n}\n",
        "output": "0",
        "index": 65332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  SkMatrix GetSkMatrix(\n      const TransformPaintPropertyNode* target_transform) const {\n    return SkMatrix(TransformationMatrix::ToSkMatrix44(\n        GeometryMapper::SourceToDestinationProjection(target_transform,\n                                                      current_transform_)));\n  }\n",
        "output": "0",
        "index": 136449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ModuleExport size_t RegisterRLEImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"RLE\",\"RLE\",\"Utah Run length encoded image\");\n  entry->decoder=(DecodeImageHandler *) ReadRLEImage;\n  entry->magick=(IsImageFormatHandler *) IsRLE;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "output": "0",
        "index": 65136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)\n{\n    if (!virtio_should_notify(vdev, vq)) {\n        return;\n    }\n\n    trace_virtio_notify(vdev, vq);\n    vdev->isr |= 0x01;\n    virtio_notify_vector(vdev, vq->vector);\n}\n",
        "output": "0",
        "index": 9208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Browser* Browser::Create(Profile* profile) {\n  Browser* browser = new Browser(TYPE_NORMAL, profile);\n  browser->InitBrowserWindow();\n  return browser;\n}\n",
        "output": "0",
        "index": 103086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pppol2tp_tunnel_ioctl(struct l2tp_tunnel *tunnel,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err = 0;\n\tstruct sock *sk;\n\tstruct pppol2tp_ioc_stats stats;\n\n\tl2tp_dbg(tunnel, PPPOL2TP_MSG_CONTROL,\n\t\t \"%s: pppol2tp_tunnel_ioctl(cmd=%#x, arg=%#lx)\\n\",\n\t\t tunnel->name, cmd, arg);\n\n\tsk = tunnel->sock;\n\tsock_hold(sk);\n\n\tswitch (cmd) {\n\tcase PPPIOCGL2TPSTATS:\n\t\terr = -ENXIO;\n\t\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\t\tbreak;\n\n\t\tif (copy_from_user(&stats, (void __user *) arg,\n\t\t\t\t   sizeof(stats))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (stats.session_id != 0) {\n\t\t\t/* resend to session ioctl handler */\n\t\t\tstruct l2tp_session *session =\n\t\t\t\tl2tp_session_find(sock_net(sk), tunnel, stats.session_id);\n\t\t\tif (session != NULL)\n\t\t\t\terr = pppol2tp_session_ioctl(session, cmd, arg);\n\t\t\telse\n\t\t\t\terr = -EBADR;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_XFRM\n\t\tstats.using_ipsec = (sk->sk_policy[0] || sk->sk_policy[1]) ? 1 : 0;\n#endif\n\t\tpppol2tp_copy_stats(&stats, &tunnel->stats);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof(stats))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tl2tp_info(tunnel, PPPOL2TP_MSG_CONTROL, \"%s: get L2TP stats\\n\",\n\t\t\t  tunnel->name);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tsock_put(sk);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 36431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HWNDMessageHandler::SetCapture() {\n  DCHECK(!HasCapture());\n  ::SetCapture(hwnd());\n}\n",
        "output": "0",
        "index": 133165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BackendImpl::SyncCreateEntry(const std::string& key,\n                                 scoped_refptr<EntryImpl>* entry) {\n  DCHECK(entry);\n  *entry = CreateEntryImpl(key);\n  return (*entry) ? net::OK : net::ERR_FAILED;\n}\n",
        "output": "0",
        "index": 160096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)\n{\n  while (s < end) {\n    *conv++ = s[3];\n    *conv++ = s[2];\n    *conv++ = s[1];\n    *conv++ = s[0];\n    s += 4;\n  }\n}\n",
        "output": "0",
        "index": 89251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)\n{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL))\n    {\n        return false;\n    }\n\n    child = array->child;\n\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array->child = item;\n    }\n    else\n    {\n        /* append to the end */\n        while (child->next)\n        {\n            child = child->next;\n        }\n        suffix_object(child, item);\n    }\n\n    return true;\n}\n",
        "output": "0",
        "index": 87083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n                                  X509 *signcert, EVP_PKEY *pkey,\n                                  STACK_OF(X509) *certs, unsigned int flags)\n{\n    CMS_SignerInfo *rct_si;\n    CMS_ContentInfo *cms = NULL;\n    ASN1_OCTET_STRING **pos, *os;\n    BIO *rct_cont = NULL;\n    int r = 0;\n\n    flags &= ~(CMS_STREAM | CMS_TEXT);\n    /* Not really detached but avoids content being allocated */\n    flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;\n    if (!pkey || !signcert) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);\n        return NULL;\n    }\n\n    /* Initialize signed data */\n\n    cms = CMS_sign(NULL, NULL, certs, NULL, flags);\n    if (!cms)\n        goto err;\n\n    /* Set inner content type to signed receipt */\n    if (!CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_smime_ct_receipt)))\n        goto err;\n\n    rct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);\n    if (!rct_si) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);\n        goto err;\n    }\n\n    os = cms_encode_Receipt(si);\n\n    if (!os)\n        goto err;\n\n    /* Set content to digest */\n    rct_cont = BIO_new_mem_buf(os->data, os->length);\n    if (!rct_cont)\n        goto err;\n\n    /* Add msgSigDigest attribute */\n\n    if (!cms_msgSigDigest_add1(rct_si, si))\n        goto err;\n\n    /* Finalize structure */\n    if (!CMS_final(cms, rct_cont, NULL, flags))\n        goto err;\n\n    /* Set embedded content */\n    pos = CMS_get0_content(cms);\n    *pos = os;\n\n    r = 1;\n\n err:\n    if (rct_cont)\n        BIO_free(rct_cont);\n    if (r)\n        return cms;\n    CMS_ContentInfo_free(cms);\n    return NULL;\n\n}\n",
        "output": "0",
        "index": 11964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t rtnl_port_size(const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tsize_t port_size = nla_total_size(4)\t\t/* PORT_VF */\n\t\t+ nla_total_size(PORT_PROFILE_MAX)\t/* PORT_PROFILE */\n\t\t+ nla_total_size(sizeof(struct ifla_port_vsi))\n\t\t\t\t\t\t\t/* PORT_VSI_TYPE */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_INSTANCE_UUID */\n\t\t+ nla_total_size(PORT_UUID_MAX)\t\t/* PORT_HOST_UUID */\n\t\t+ nla_total_size(1)\t\t\t/* PROT_VDP_REQUEST */\n\t\t+ nla_total_size(2);\t\t\t/* PORT_VDP_RESPONSE */\n\tsize_t vf_ports_size = nla_total_size(sizeof(struct nlattr));\n\tsize_t vf_port_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\tsize_t port_self_size = nla_total_size(sizeof(struct nlattr))\n\t\t+ port_size;\n\n\tif (!dev->netdev_ops->ndo_get_vf_port || !dev->dev.parent ||\n\t    !(ext_filter_mask & RTEXT_FILTER_VF))\n\t\treturn 0;\n\tif (dev_num_vf(dev->dev.parent))\n\t\treturn port_self_size + vf_ports_size +\n\t\t\tvf_port_size * dev_num_vf(dev->dev.parent);\n\telse\n\t\treturn port_self_size;\n}\n",
        "output": "0",
        "index": 53177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UsageTracker* QuotaManager::GetUsageTracker(StorageType type) const {\n  switch (type) {\n    case kStorageTypeTemporary:\n      return temporary_usage_tracker_.get();\n    case kStorageTypePersistent:\n      return persistent_usage_tracker_.get();\n    default:\n      NOTREACHED();\n  }\n  return NULL;\n}\n",
        "output": "0",
        "index": 101031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n{\n    DeviceState *d = DEVICE(dev);\n    MPTSASState *s = MPT_SAS(dev);\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n                          \"mptsas-mmio\", 0x4000);\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n                          \"mptsas-io\", 256);\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n                          \"mptsas-diag\", 0x10000);\n\n    if (s->msi_available &&\n        msi_init(dev, 0, 1, true, false) >= 0) {\n        s->msi_in_use = true;\n    }\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n    if (!s->sas_addr) {\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n    }\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n    QTAILQ_INIT(&s->pending);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n    if (!d->hotplugged) {\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n    }\n}\n",
        "output": "0",
        "index": 10542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n \t * one divide.\n \t */\n \tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n \tvalue->tv_usec = rem / NSEC_PER_USEC;\n }\n",
        "output": "1",
        "index": 178920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,\n                                 const ASN1_ITEM *it, int tag, int aclass)\n{\n    int len;\n    int utype;\n    int usetag;\n    int ndef = 0;\n\n    utype = it->utype;\n\n    /*\n     * Get length of content octets and maybe find out the underlying type.\n     */\n\n    len = asn1_ex_i2c(pval, NULL, &utype, it);\n\n    /*\n     * If SEQUENCE, SET or OTHER then header is included in pseudo content\n     * octets so don't include tag+length. We need to check here because the\n     * call to asn1_ex_i2c() could change utype.\n     */\n    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||\n        (utype == V_ASN1_OTHER))\n        usetag = 0;\n    else\n        usetag = 1;\n\n    /* -1 means omit type */\n\n    if (len == -1)\n        return 0;\n\n    /* -2 return is special meaning use ndef */\n    if (len == -2) {\n        ndef = 2;\n        len = 0;\n    }\n\n    /* If not implicitly tagged get tag from underlying type */\n    if (tag == -1)\n        tag = utype;\n\n    /* Output tag+length followed by content octets */\n    if (out) {\n        if (usetag)\n            ASN1_put_object(out, ndef, len, tag, aclass);\n        asn1_ex_i2c(pval, *out, &utype, it);\n        if (ndef)\n            ASN1_put_eoc(out);\n        else\n            *out += len;\n    }\n\n    if (usetag)\n        return ASN1_object_size(ndef, len, tag);\n    return len;\n}\n",
        "output": "0",
        "index": 12843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int getch() {\n\treturn getchar();\n}\n",
        "output": "0",
        "index": 92819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sock *__l2tp_ip6_bind_lookup(struct net *net,\n\t\t\t\t\t   struct in6_addr *laddr,\n\t\t\t\t\t   int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\n\t\tconst struct in6_addr *addr = inet6_rcv_saddr(sk);\n\t\tstruct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\n\n\t\tif (l2tp == NULL)\n\t\t\tcontinue;\n\n\t\tif ((l2tp->conn_id == tunnel_id) &&\n\t\t    net_eq(sock_net(sk), net) &&\n\t\t    !(addr && ipv6_addr_equal(addr, laddr)) &&\n\t\t    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\n\t\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n",
        "output": "0",
        "index": 53741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::PepperInstanceCreated(\n    PepperPluginInstanceImpl* instance) {\n  active_pepper_instances_.insert(instance);\n\n  Send(new FrameHostMsg_PepperInstanceCreated(\n      routing_id_, instance->pp_instance()));\n}\n",
        "output": "0",
        "index": 152472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int x25_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *uaddr_len, int peer)\n{\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tint rc = 0;\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trc = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsx25->sx25_addr = x25->dest_addr;\n\t} else\n\t\tsx25->sx25_addr = x25->source_addr;\n\n\tsx25->sx25_family = AF_X25;\n\t*uaddr_len = sizeof(*sx25);\n\nout:\n\treturn rc;\n}\n",
        "output": "0",
        "index": 40780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GpuProcessHostUIShim::OnMessageReceived(const IPC::Message& message) {\n  DCHECK(CalledOnValidThread());\n\n  if (message.routing_id() != MSG_ROUTING_CONTROL)\n    return false;\n\n  return OnControlMessageReceived(message);\n}\n",
        "output": "0",
        "index": 113726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionInstallPrompt::OnInstallSuccess(const Extension* extension,\n                                              SkBitmap* icon) {\n  extension_ = extension;\n  SetIcon(icon);\n\n  install_ui_->OnInstallSuccess(extension, &icon_);\n}\n",
        "output": "0",
        "index": 144386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_decode_ofp10_phy_port(struct ofputil_phy_port *pp,\n                              const struct ofp10_phy_port *opp)\n{\n    pp->port_no = u16_to_ofp(ntohs(opp->port_no));\n    pp->hw_addr = opp->hw_addr;\n    ovs_strlcpy(pp->name, opp->name, OFP_MAX_PORT_NAME_LEN);\n\n    pp->config = ntohl(opp->config) & OFPPC10_ALL;\n    pp->state = ntohl(opp->state) & OFPPS10_ALL;\n\n    pp->curr = netdev_port_features_from_ofp10(opp->curr);\n    pp->advertised = netdev_port_features_from_ofp10(opp->advertised);\n    pp->supported = netdev_port_features_from_ofp10(opp->supported);\n    pp->peer = netdev_port_features_from_ofp10(opp->peer);\n\n    pp->curr_speed = netdev_features_to_bps(pp->curr, 0) / 1000;\n    pp->max_speed = netdev_features_to_bps(pp->supported, 0) / 1000;\n\n    return 0;\n}\n",
        "output": "0",
        "index": 77516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gx_dc_pattern2_color_has_bbox(const gx_device_color * pdevc)\n{\n    gs_pattern2_instance_t *pinst = (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n    const gs_shading_t *psh = pinst->templat.Shading;\n\n    return psh->params.have_BBox;\n}\n",
        "output": "0",
        "index": 1712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ContentSecurityPolicy::reportInvalidSourceExpression(\n    const String& directiveName,\n    const String& source) {\n  String message = \"The source list for Content Security Policy directive '\" +\n                   directiveName + \"' contains an invalid source: '\" + source +\n                   \"'. It will be ignored.\";\n  if (equalIgnoringCase(source, \"'none'\"))\n    message = message +\n              \" Note that 'none' has no effect unless it is the only \"\n              \"expression in the source list.\";\n  logToConsole(message);\n}\n",
        "output": "0",
        "index": 149470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssl_check_server_ecdh_params( const mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    curve_info = mbedtls_ecp_curve_info_from_grp_id( ssl->handshake->ecdh_ctx.grp.id );\n    if( curve_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"ECDH curve: %s\", curve_info->name ) );\n\n#if defined(MBEDTLS_ECP_C)\n    if( mbedtls_ssl_check_curve( ssl, ssl->handshake->ecdh_ctx.grp.id ) != 0 )\n#else\n    if( ssl->handshake->ecdh_ctx.grp.nbits < 163 ||\n        ssl->handshake->ecdh_ctx.grp.nbits > 521 )\n#endif\n        return( -1 );\n\n    MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp\", &ssl->handshake->ecdh_ctx.Qp );\n\n    return( 0 );\n}\n",
        "output": "0",
        "index": 83347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "next_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\n{\n\tif (bss == NULL)\n\t\treturn list->bss_info_le;\n\treturn (struct brcmf_bss_info_le *)((unsigned long)bss +\n\t\t\t\t\t    le32_to_cpu(bss->length));\n}\n",
        "output": "0",
        "index": 49143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::DidInitiatePaint() {\n  pepper_delegate_.ViewInitiatedPaint();\n\n  for (std::set<WebPluginDelegatePepper*>::iterator i =\n           current_oldstyle_pepper_plugins_.begin();\n       i != current_oldstyle_pepper_plugins_.end(); ++i)\n    (*i)->RenderViewInitiatedPaint();\n}\n",
        "output": "0",
        "index": 97892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainGetID(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, (unsigned int)-1);\n\n    return domain->id;\n}\n",
        "output": "0",
        "index": 93805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RecordDiceResponseHeader(DiceResponseHeader header) {\n  UMA_HISTOGRAM_ENUMERATION(kDiceResponseHeaderHistogram, header,\n                            kDiceResponseHeaderCount);\n}\n",
        "output": "0",
        "index": 155794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_write_poll(struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tint len = sshbuf_len(state->output);\n\tint cont, r;\n\n\tif (len > 0) {\n\t\tcont = 0;\n\t\tlen = roaming_write(state->connection_out,\n\t\t    sshbuf_ptr(state->output), len, &cont);\n\t\tif (len == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN ||\n\t\t\t    errno == EWOULDBLOCK)\n\t\t\t\treturn 0;\n\t\t\treturn SSH_ERR_SYSTEM_ERROR;\n\t\t}\n\t\tif (len == 0 && !cont)\n\t\t\treturn SSH_ERR_CONN_CLOSED;\n\t\tif ((r = sshbuf_consume(state->output, len)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 12999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WindowTreeHostManager::CloseChildWindows() {\n  for (WindowTreeHostMap::const_iterator it = window_tree_hosts_.begin();\n       it != window_tree_hosts_.end(); ++it) {\n    aura::Window* root_window = GetWindow(it->second);\n    RootWindowController* controller = GetRootWindowController(root_window);\n    if (controller) {\n      controller->CloseChildWindows();\n    } else {\n      while (!root_window->children().empty()) {\n        aura::Window* child = root_window->children()[0];\n        delete child;\n      }\n    }\n  }\n}\n",
        "output": "0",
        "index": 133349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void DetectFlow(ThreadVars *tv,\n                        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                        Packet *p)\n {\n    /* No need to perform any detection on this packet, if the the given flag is set.*/\n    if ((p->flags & PKT_NOPACKET_INSPECTION) ||\n        (PACKET_TEST_ACTION(p, ACTION_DROP)))\n    {\n         /* hack: if we are in pass the entire flow mode, we need to still\n          * update the inspect_id forward. So test for the condition here,\n          * and call the update code if necessary. */\n        const int pass = ((p->flow->flags & FLOW_NOPACKET_INSPECTION));\n        const AppProto alproto = FlowGetAppProtocol(p->flow);\n        if (pass && AppLayerParserProtocolSupportsTxs(p->proto, alproto)) {\n            uint8_t flags;\n            if (p->flowflags & FLOW_PKT_TOSERVER) {\n                flags = STREAM_TOSERVER;\n            } else {\n                flags = STREAM_TOCLIENT;\n            }\n             flags = FlowGetDisruptionFlags(p->flow, flags);\n             DeStateUpdateInspectTransactionId(p->flow, flags, true);\n         }\n         return;\n     }\n \n    /* see if the packet matches one or more of the sigs */\n    (void)DetectRun(tv, de_ctx, det_ctx, p);\n}\n",
        "output": "1",
        "index": 182504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fragmenter_transmit_finished(BT_HDR *packet, bool all_fragments_sent) {\n if (all_fragments_sent) {\n    buffer_allocator->free(packet);\n } else {\n    data_dispatcher_dispatch(interface.event_dispatcher, packet->event & MSG_EVT_MASK, packet);\n }\n}\n",
        "output": "0",
        "index": 172135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_proc_readlink(struct inode *inode, struct page *page,\n\t\tunsigned int pgbase, unsigned int pglen)\n{\n\tstruct nfs4_readlink args = {\n\t\t.fh       = NFS_FH(inode),\n\t\t.pgbase\t  = pgbase,\n\t\t.pglen    = pglen,\n\t\t.pages    = &page,\n\t};\n\tstruct nfs4_readlink_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READLINK],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\treturn nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n}\n",
        "output": "0",
        "index": 19832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ti_vread_sync(struct usb_device *dev, __u8 request,\n\t\t\t\t__u16 value, __u16 index, u8 *data, int size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),\n\t\t\tvalue, index, data, size, 1000);\n\tif (status < 0)\n\t\treturn status;\n\tif (status != size) {\n\t\tdev_dbg(&dev->dev, \"%s - wanted to write %d, but only wrote %d\\n\",\n\t\t\t__func__, size, status);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 33367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\t/* this is the postfix we want */\n\t\t\t/* the actual postfix string is kept at the end of the structure */\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\t/* we ran off the end of the list and still didn't find the requested string */\n\tEVUTIL_ASSERT(0);\n\treturn NULL; /* unreachable; stops warnings in some compilers. */\n}\n",
        "output": "0",
        "index": 70777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct task_group *parent = css_tg(parent_css);\n\tstruct task_group *tg;\n\n\tif (!parent) {\n\t\t/* This is early initialization for the top cgroup */\n\t\treturn &root_task_group.css;\n\t}\n\n\ttg = sched_create_group(parent);\n\tif (IS_ERR(tg))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsched_online_group(tg, parent);\n\n\treturn &tg->css;\n}\n",
        "output": "0",
        "index": 55506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int issue_flush_thread(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;\n\twait_queue_head_t *q = &fcc->flush_wait_queue;\nrepeat:\n\tif (kthread_should_stop())\n\t\treturn 0;\n\n\tsb_start_intwrite(sbi->sb);\n\n\tif (!llist_empty(&fcc->issue_list)) {\n\t\tstruct flush_cmd *cmd, *next;\n\t\tint ret;\n\n\t\tfcc->dispatch_list = llist_del_all(&fcc->issue_list);\n\t\tfcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);\n\n\t\tret = submit_flush_wait(sbi);\n\t\tatomic_inc(&fcc->issued_flush);\n\n\t\tllist_for_each_entry_safe(cmd, next,\n\t\t\t\t\t  fcc->dispatch_list, llnode) {\n\t\t\tcmd->ret = ret;\n\t\t\tcomplete(&cmd->wait);\n\t\t}\n\t\tfcc->dispatch_list = NULL;\n\t}\n\n\tsb_end_intwrite(sbi->sb);\n\n\twait_event_interruptible(*q,\n\t\tkthread_should_stop() || !llist_empty(&fcc->issue_list));\n\tgoto repeat;\n}\n",
        "output": "0",
        "index": 86027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int GM2TabStyle::GetStrokeThickness(bool should_paint_as_active) const {\n  return (tab_->IsActive() || should_paint_as_active)\n             ? tab_->controller()->GetStrokeThickness()\n              : 0;\n }\n",
        "output": "0",
        "index": 153522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void skb_free_datagram(struct sock *sk, struct sk_buff *skb)\n{\n\tconsume_skb(skb);\n\tsk_mem_reclaim_partial(sk);\n}\n",
        "output": "0",
        "index": 33841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AutofillDialogViews::SectionContainer::~SectionContainer() {}\n",
        "output": "0",
        "index": 118343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_handle_error(struct super_block *sb)\n{\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt(sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\tif (journal)\n\t\t\tjbd2_journal_abort(journal, -EIO);\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tif (test_opt(sb, ERRORS_PANIC)) {\n\t\tif (EXT4_SB(sb)->s_journal &&\n\t\t  !(EXT4_SB(sb)->s_journal->j_flags & JBD2_REC_ERR))\n\t\t\treturn;\n\t\tpanic(\"EXT4-fs (device %s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n\t}\n}\n",
        "output": "0",
        "index": 56671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_server_get_prefix_char_index (struct t_irc_server *server,\n                                  char prefix_char)\n{\n    const char *prefix_chars;\n    char *pos;\n    \n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        pos = strchr (prefix_chars, prefix_char);\n        if (pos)\n            return pos - prefix_chars;\n    }\n    \n    return -1;\n}\n",
        "output": "0",
        "index": 3487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ossl_statem_set_error(SSL *s)\n{\n    s->statem.state = MSG_FLOW_ERROR;\n}\n",
        "output": "0",
        "index": 9359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfc_llcp_send_dm(struct nfc_llcp_local *local, u8 ssap, u8 dsap, u8 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_dev *dev;\n\tu16 size = 1; /* Reason code */\n\n\tpr_debug(\"Sending DM reason 0x%x\\n\", reason);\n\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\n\tdev = local->dev;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n\tskb = llcp_add_header(skb, dsap, ssap, LLCP_PDU_DM);\n\n\tskb_put_data(skb, &reason, 1);\n\n\tskb_queue_head(&local->tx_queue, skb);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 89678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void SetImage(const gfx::Image& image) {\n    image_ = image;\n    image_size_ = image.AsImageSkia().size();\n  }\n",
        "output": "0",
        "index": 134542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void modssl_proxy_info_log(conn_rec *c,\n                                  X509_INFO *info,\n                                  const char *msg)\n{\n    ssl_log_cxerror(SSLLOG_MARK, APLOG_DEBUG, 0, c, info->x509, APLOGNO(02277)\n                    SSLPROXY_CERT_CB_LOG_FMT \"%s, sending\",\n                    (mySrvConfigFromConn(c))->vhost_id, msg);\n}\n",
        "output": "0",
        "index": 52457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void SetWindowBounds(\n      const gfx::Rect& rect,\n      base::Callback<void(std::unique_ptr<browser::SetWindowBoundsResult>)>\n          callback) {\n    std::unique_ptr<browser::Bounds> bounds =\n        browser::Bounds::Builder()\n            .SetLeft(rect.x())\n            .SetTop(rect.y())\n            .SetWidth(rect.width())\n            .SetHeight(rect.height())\n            .SetWindowState(browser::WindowState::NORMAL)\n            .Build();\n    int window_id = HeadlessWebContentsImpl::From(web_contents_)->window_id();\n    std::unique_ptr<browser::SetWindowBoundsParams> params =\n        browser::SetWindowBoundsParams::Builder()\n            .SetWindowId(window_id)\n            .SetBounds(std::move(bounds))\n            .Build();\n    browser_devtools_client_->GetBrowser()->GetExperimental()->SetWindowBounds(\n        std::move(params), callback);\n  }\n",
        "output": "0",
        "index": 157581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usbdev_vm_close(struct vm_area_struct *vma)\n{\n\tstruct usb_memory *usbm = vma->vm_private_data;\n\n\tdec_usb_memory_use_count(usbm, &usbm->vma_use_count);\n}\n",
        "output": "0",
        "index": 53263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                     const gss_buffer_t sasl_mech_name,\n                                     gss_OID *mech_type)\n{\n\tif (sasl_mech_name->length == SPNEGO_SASL_NAME_LEN &&\n\t    memcmp(sasl_mech_name->value, SPNEGO_SASL_NAME,\n\t\t   SPNEGO_SASL_NAME_LEN) == 0) {\n\t\tif (mech_type != NULL)\n\t\t\t*mech_type = (gss_OID)gss_mech_spnego;\n\t\treturn (GSS_S_COMPLETE);\n\t}\n\n\treturn (GSS_S_BAD_MECH);\n}\n",
        "output": "0",
        "index": 36761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 *p = (u64 *)&vcpu->arch.mtrr_state.fixed_ranges;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn 1;\n\n\tif (msr == MSR_MTRRdefType)\n\t\t*pdata = vcpu->arch.mtrr_state.def_type +\n\t\t\t (vcpu->arch.mtrr_state.enabled << 10);\n\telse if (msr == MSR_MTRRfix64K_00000)\n\t\t*pdata = p[0];\n\telse if (msr == MSR_MTRRfix16K_80000 || msr == MSR_MTRRfix16K_A0000)\n\t\t*pdata = p[1 + msr - MSR_MTRRfix16K_80000];\n\telse if (msr >= MSR_MTRRfix4K_C0000 && msr <= MSR_MTRRfix4K_F8000)\n\t\t*pdata = p[3 + msr - MSR_MTRRfix4K_C0000];\n\telse if (msr == MSR_IA32_CR_PAT)\n\t\t*pdata = vcpu->arch.pat;\n\telse {\t/* Variable MTRRs */\n\t\tint idx, is_mtrr_mask;\n\t\tu64 *pt;\n\n\t\tidx = (msr - 0x200) / 2;\n\t\tis_mtrr_mask = msr - 0x200 - 2 * idx;\n\t\tif (!is_mtrr_mask)\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].base_lo;\n\t\telse\n\t\t\tpt =\n\t\t\t  (u64 *)&vcpu->arch.mtrr_state.var_ranges[idx].mask_lo;\n\t\t*pdata = *pt;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 20700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ImeAdapterAndroid* ime_adapter() {\n    return static_cast<RenderWidgetHostViewAndroid*>(\n               web_contents()->GetRenderWidgetHostView())\n        ->ime_adapter_for_testing();\n  }\n",
        "output": "0",
        "index": 156748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tst_QQuickWebView::loadEmptyPageViewVisible()\n{\n    m_window->show();\n    loadEmptyPageViewHidden();\n}\n",
        "output": "0",
        "index": 107101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebSettingsImpl::setDeveloperExtrasEnabled(bool enabled)\n{\n    m_settings->setDeveloperExtrasEnabled(enabled);\n}\n",
        "output": "0",
        "index": 100466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_reset(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    int i;\n\n    virtio_set_status(vdev, 0);\n\n    if (k->reset) {\n        k->reset(vdev);\n    }\n\n    vdev->guest_features = 0;\n    vdev->queue_sel = 0;\n    vdev->status = 0;\n    vdev->isr = 0;\n    vdev->config_vector = VIRTIO_NO_VECTOR;\n    virtio_notify_vector(vdev, vdev->config_vector);\n\n    for(i = 0; i < VIRTIO_PCI_QUEUE_MAX; i++) {\n        vdev->vq[i].vring.desc = 0;\n        vdev->vq[i].vring.avail = 0;\n        vdev->vq[i].vring.used = 0;\n        vdev->vq[i].last_avail_idx = 0;\n        vdev->vq[i].pa = 0;\n        vdev->vq[i].vector = VIRTIO_NO_VECTOR;\n        vdev->vq[i].signalled_used = 0;\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n    }\n}\n",
        "output": "0",
        "index": 14468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void tokenadd(struct jv_parser* p, char c) {\n   assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n     p->tokenlen = p->tokenlen*2 + 256;\n     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n   }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}\n",
        "output": "1",
        "index": 180649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::LoadingStateChanged(WebContents* source,\n    bool to_different_document) {\n  window_->UpdateLoadingAnimations(tab_strip_model_->TabsAreLoading());\n  window_->UpdateTitleBar();\n\n  WebContents* selected_contents = tab_strip_model_->GetActiveWebContents();\n  if (source == selected_contents) {\n    bool is_loading = source->IsLoading() && to_different_document;\n    command_controller_->LoadingStateChanged(is_loading, false);\n    if (GetStatusBubble()) {\n      GetStatusBubble()->SetStatus(CoreTabHelper::FromWebContents(\n          tab_strip_model_->GetActiveWebContents())->GetStatusText());\n    }\n  }\n}\n",
        "output": "0",
        "index": 151697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void OctetAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"octetAttribute\");\n\n  uint8_t cpp_value = NativeValueTraits<IDLOctet>::NativeValue(info.GetIsolate(), v8_value, exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->setOctetAttribute(cpp_value);\n}\n",
        "output": "0",
        "index": 147605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void StringifierAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8StringResource<> cpp_value = v8_value;\n  if (!cpp_value.Prepare())\n    return;\n\n  impl->setStringifierAttribute(cpp_value);\n}\n",
        "output": "0",
        "index": 147889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::dispatchVisibilityStateChangeEvent()\n{\n    dispatchEvent(Event::create(eventNames().webkitvisibilitychangeEvent, false, false));\n}\n",
        "output": "0",
        "index": 112445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean webkit_web_view_draw(GtkWidget* widget, cairo_t* cr)\n{\n    WebKitWebView* webView = WEBKIT_WEB_VIEW(widget);\n    WebKitWebViewPrivate* priv = webView->priv;\n    GdkRectangle clipRect;\n\n    if (!gdk_cairo_get_clip_rectangle(cr, &clipRect))\n        return FALSE;\n\n    Frame* frame = core(webView)->mainFrame();\n    if (frame->contentRenderer() && frame->view()) {\n        GraphicsContext gc(cr);\n        IntRect rect = clipRect;\n        cairo_rectangle_list_t* rectList = cairo_copy_clip_rectangle_list(cr);\n\n        frame->view()->updateLayoutAndStyleIfNeededRecursive();\n\n        Vector<IntRect> rects;\n        if (!rectList->status && rectList->num_rectangles > 0) {\n            for (int i = 0; i < rectList->num_rectangles; i++)\n                rects.append(enclosingIntRect(FloatRect(rectList->rectangles[i])));\n        }\n        paintWebView(frame, priv->transparent, gc, rect, rects);\n\n        cairo_rectangle_list_destroy(rectList);\n    }\n\n    return FALSE;\n}\n",
        "output": "0",
        "index": 105419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType SetImageColor(Image *image,\n  const MagickPixelPacket *color)\n{\n  CacheView\n    *image_view;\n\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickSignature);\n  assert(color != (const MagickPixelPacket *) NULL);\n  image->colorspace=color->colorspace;\n  image->matte=color->matte;\n  image->fuzz=color->fuzz;\n  image->depth=color->depth;\n  status=MagickTrue;\n  exception=(&image->exception);\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register IndexPacket\n      *magick_restrict indexes;\n\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    indexes=GetCacheViewAuthenticIndexQueue(image_view);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelPacket(image,color,q,indexes+x);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n",
        "output": "0",
        "index": 64530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const AtomicString& HTMLSelectElement::formControlType() const\n{\n    DEFINE_STATIC_LOCAL(const AtomicString, selectMultiple, (\"select-multiple\", AtomicString::ConstructFromLiteral));\n    DEFINE_STATIC_LOCAL(const AtomicString, selectOne, (\"select-one\", AtomicString::ConstructFromLiteral));\n    return m_multiple ? selectMultiple : selectOne;\n}\n",
        "output": "0",
        "index": 110014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kiocb *lookup_kiocb(struct kioctx *ctx, struct iocb __user *iocb,\n\t\t\t\t  u32 key)\n{\n\tstruct list_head *pos;\n\n\tassert_spin_locked(&ctx->ctx_lock);\n\n\t/* TODO: use a hash or array, this sucks. */\n\tlist_for_each(pos, &ctx->active_reqs) {\n\t\tstruct kiocb *kiocb = list_kiocb(pos);\n\t\tif (kiocb->ki_obj.user == iocb && kiocb->ki_key == key)\n\t\t\treturn kiocb;\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 21694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int alloc_fresh_gigantic_page(struct hstate *h,\n\t\t\t\t\tnodemask_t *nodes_allowed) { return 0; }\n",
        "output": "0",
        "index": 86327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_lookup(struct ctl_table_root *root)\n{\n\treturn &current_user_ns()->set;\n}\n",
        "output": "0",
        "index": 67898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FFmpegVideoDecodeEngine::FFmpegVideoDecodeEngine()\n    : codec_context_(NULL),\n      event_handler_(NULL),\n      frame_rate_numerator_(0),\n      frame_rate_denominator_(0),\n      pending_input_buffers_(0),\n      pending_output_buffers_(0),\n      output_eos_reached_(false),\n      flush_pending_(false) {\n}\n",
        "output": "0",
        "index": 103232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DeleteRenderbuffersHelper(\n    GLsizei n, const GLuint* client_ids) {\n  bool supports_separate_framebuffer_binds =\n     feature_info_->feature_flags().chromium_framebuffer_multisample;\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    RenderbufferManager::RenderbufferInfo* renderbuffer =\n        GetRenderbufferInfo(client_ids[ii]);\n    if (renderbuffer && !renderbuffer->IsDeleted()) {\n      if (bound_renderbuffer_ == renderbuffer) {\n        bound_renderbuffer_ = NULL;\n      }\n      if (supports_separate_framebuffer_binds) {\n        if (bound_read_framebuffer_) {\n          bound_read_framebuffer_->UnbindRenderbuffer(\n              GL_READ_FRAMEBUFFER_EXT, renderbuffer);\n        }\n        if (bound_draw_framebuffer_) {\n          bound_draw_framebuffer_->UnbindRenderbuffer(\n              GL_DRAW_FRAMEBUFFER_EXT, renderbuffer);\n        }\n      } else {\n        if (bound_draw_framebuffer_) {\n          bound_draw_framebuffer_->UnbindRenderbuffer(\n              GL_FRAMEBUFFER, renderbuffer);\n        }\n      }\n      state_dirty_ = true;\n      RemoveRenderbufferInfo(client_ids[ii]);\n    }\n  }\n}\n",
        "output": "0",
        "index": 110445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ArrayBufferAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueFast(info, WTF::GetPtr(impl->arrayBufferAttribute()), impl);\n}\n",
        "output": "0",
        "index": 147200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void firmware_config_callback(UNUSED_ATTR bool success) {\n  LOG_INFO(\"%s\", __func__);\n  firmware_is_configured = true;\n  non_repeating_timer_cancel(startup_timer);\n\n  future_ready(startup_future, FUTURE_SUCCESS);\n  startup_future = NULL;\n}\n",
        "output": "0",
        "index": 172134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "connection_edge_end_errno(edge_connection_t *conn)\n{\n  uint8_t reason;\n  tor_assert(conn);\n  reason = errno_to_stream_end_reason(tor_socket_errno(conn->base_.s));\n  return connection_edge_end(conn, reason);\n}\n",
        "output": "0",
        "index": 69912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *set_document_root(cmd_parms *cmd, void *dummy,\n                                     const char *arg)\n{\n    void *sconf = cmd->server->module_config;\n    core_server_config *conf = ap_get_core_module_config(sconf);\n\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    if (err != NULL) {\n        return err;\n    }\n\n    /* When ap_document_root_check is false; skip all the stuff below */\n    if (!ap_document_root_check) {\n       conf->ap_document_root = arg;\n       return NULL;\n    }\n\n    /* Make it absolute, relative to ServerRoot */\n    arg = ap_server_root_relative(cmd->pool, arg);\n    if (arg == NULL) {\n        return \"DocumentRoot must be a directory\";\n    }\n\n    if (apr_filepath_merge((char**)&conf->ap_document_root, NULL, arg,\n                           APR_FILEPATH_TRUENAME, cmd->pool) != APR_SUCCESS\n        || !ap_is_directory(cmd->temp_pool, arg)) {\n        if (cmd->server->is_virtual) {\n            ap_log_perror(APLOG_MARK, APLOG_STARTUP, 0,\n                          cmd->pool, APLOGNO(00112)\n                          \"Warning: DocumentRoot [%s] does not exist\",\n                          arg);\n            conf->ap_document_root = arg;\n        }\n        else {\n            return apr_psprintf(cmd->pool, \n                                \"DocumentRoot '%s' is not a directory, or is not readable\",\n                                arg);\n        }\n    }\n    return NULL;\n}\n",
        "output": "0",
        "index": 64277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit PostMessageIpcInterceptor(RenderProcessHost* process)\n      : BrowserMessageFilter(FrameMsgStart) {\n    process->AddFilter(this);\n  }\n",
        "output": "0",
        "index": 164708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::OnDelete() {\n  if (!webview())\n    return;\n\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Delete\"));\n}\n",
        "output": "0",
        "index": 103809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~TestAutofillExternalDelegate() {}\n",
        "output": "0",
        "index": 127155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int codebook_decode_start(vorb *f, Codebook *c)\n{\n   int z = -1;\n\n   if (c->lookup_type == 0)\n      error(f, VORBIS_invalid_stream);\n   else {\n      DECODE_VQ(z,f,c);\n      if (c->sparse) assert(z < c->sorted_entries);\n      if (z < 0) {  // check for EOP\n         if (!f->bytes_in_seg)\n            if (f->last_seg)\n               return z;\n         error(f, VORBIS_invalid_stream);\n      }\n   }\n   return z;\n}\n",
        "output": "0",
        "index": 75239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u64 perf_event_count(struct perf_event *event)\n{\n\tif (event->pmu->count)\n\t\treturn event->pmu->count(event);\n\n\treturn __perf_event_count(event);\n}\n",
        "output": "0",
        "index": 56067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PDFiumEngine::RotateCounterclockwise() {\n  current_rotation_ = (current_rotation_ - 1) % 4;\n  RotateInternal();\n}\n",
        "output": "0",
        "index": 153103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet_csk_route_child_sock(const struct sock *sk,\n\t\t\t\t\t    struct sock *newsk,\n\t\t\t\t\t    const struct request_sock *req)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct net *net = read_pnet(&ireq->ireq_net);\n\tstruct inet_sock *newinet = inet_sk(newsk);\n\tstruct ip_options_rcu *opt;\n\tstruct flowi4 *fl4;\n\tstruct rtable *rt;\n\n\tfl4 = &newinet->cork.fl.u.ip4;\n\n\trcu_read_lock();\n\topt = rcu_dereference(newinet->inet_opt);\n\tflowi4_init_output(fl4, ireq->ir_iif, ireq->ir_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->opt.srr) ? opt->opt.faddr : ireq->ir_rmt_addr,\n\t\t\t   ireq->ir_loc_addr, ireq->ir_rmt_port,\n\t\t\t   htons(ireq->ir_num), sk->sk_uid);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(fl4));\n\trt = ip_route_output_flow(net, fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->opt.is_strictroute && rt->rt_uses_gateway)\n\t\tgoto route_err;\n\trcu_read_unlock();\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\trcu_read_unlock();\n\t__IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 66126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 52737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_8byte */\n",
        "output": "1",
        "index": 183221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PrintWebViewHelper::CopyAndPrint(WebKit::WebFrame* web_frame) {\n  webkit_glue::WebPreferences prefs = render_view()->GetWebkitPreferences();\n  prefs.javascript_enabled = false;\n  prefs.java_enabled = false;\n\n  print_web_view_ = WebKit::WebView::create(this);\n  prefs.Apply(print_web_view_);\n  print_web_view_->initializeMainFrame(this);\n\n  print_pages_params_->pages.clear();  // Print all pages of selection.\n\n  std::string html = web_frame->selectionAsMarkup().utf8();\n  std::string url_str = \"data:text/html;charset=utf-8,\";\n  url_str.append(html);\n  GURL url(url_str);\n\n  print_web_view_->mainFrame()->loadRequest(WebKit::WebURLRequest(url));\n\n  return true;\n}\n",
        "output": "0",
        "index": 109497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " BlockEntry::BlockEntry(Cluster* p, long idx) : m_pCluster(p), m_index(idx) {}\n",
        "output": "0",
        "index": 173875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_vn_setattr_nonsize(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(d_inode(dentry));\n\tint error;\n\n\ttrace_xfs_setattr(ip);\n\n\terror = xfs_vn_change_ok(dentry, iattr);\n\tif (error)\n\t\treturn error;\n\treturn xfs_setattr_nonsize(ip, iattr, 0);\n}\n",
        "output": "0",
        "index": 88349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void release_mc(struct kref *kref)\n{\n\tstruct cma_multicast *mc = container_of(kref, struct cma_multicast, mcref);\n\n\tkfree(mc->multicast.ib);\n\tkfree(mc);\n}\n",
        "output": "0",
        "index": 38562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    OVS_REQUIRES(ofproto_mutex)\n{\n    struct ofgroup *new_group = ogm->new_group;\n    struct ofgroup *old_group;\n\n    /* Restore replaced or deleted groups. */\n    GROUP_COLLECTION_FOR_EACH (old_group, &ogm->old_groups) {\n        ofproto->n_groups[old_group->type]++;\n        if (new_group) {\n            ovs_assert(group_collection_n(&ogm->old_groups) == 1);\n            /* Transfer rules back. */\n            rule_collection_move(&old_group->rules, &new_group->rules);\n        } else {\n            old_group->being_deleted = false;\n            /* Revert rule deletion. */\n            delete_flows_revert__(ofproto, &old_group->rules);\n        }\n        /* Restore visibility. */\n        versions_set_remove_version(&old_group->versions,\n                                    OVS_VERSION_NOT_REMOVED);\n    }\n    if (new_group) {\n        /* Remove the new group immediately.  It was never visible to\n         * lookups. */\n        cmap_remove(&ofproto->groups, &new_group->cmap_node,\n                    hash_int(new_group->group_id, 0));\n        ofproto->n_groups[new_group->type]--;\n        ofproto_group_unref(new_group);\n    }\n}\n",
        "output": "0",
        "index": 77197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void shmem_unlock_mapping(struct address_space *mapping)\n{\n}\n",
        "output": "0",
        "index": 33558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfc_llcp_sock_exit(void)\n{\n\tnfc_proto_unregister(&llcp_nfc_proto);\n}\n",
        "output": "0",
        "index": 30495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DeleteDownloadedFileDone(\n    base::WeakPtr<DownloadItemImpl> item,\n    const base::Callback<void(bool)>& callback,\n    bool success) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  if (success && item.get())\n    item->OnDownloadedFileRemoved();\n  callback.Run(success);\n}\n",
        "output": "0",
        "index": 159100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int prism2_open(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_open\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tprintk(KERN_DEBUG \"%s: could not set interface UP - no PRI \"\n\t\t       \"f/w\\n\", dev->name);\n\t\treturn 1;\n\t}\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    local->hw_downloading)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(local->hw_module))\n\t\treturn -ENODEV;\n\tlocal->num_dev_open++;\n\n\tif (!local->dev_enabled && local->func->hw_enable(dev, 1)) {\n\t\tprintk(KERN_WARNING \"%s: could not enable MAC port\\n\",\n\t\t       dev->name);\n\t\tprism2_close(dev);\n\t\treturn 1;\n\t}\n\tif (!local->dev_enabled)\n\t\tprism2_callback(local, PRISM2_CALLBACK_ENABLE);\n\tlocal->dev_enabled = 1;\n\n\tif (dev != local->dev && !(local->dev->flags & IFF_UP)) {\n\t\t/* Master radio interface is needed for all operation, so open\n\t\t * it automatically when any virtual net_device is opened. */\n\t\tlocal->master_dev_auto_open = 1;\n\t\tdev_open(local->dev);\n\t}\n\n\tnetif_device_attach(dev);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 24122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DownloadManagerImpl::CreateSavePackageDownloadItem(\n    const base::FilePath& main_file_path,\n    const GURL& page_url,\n    const std::string& mime_type,\n    std::unique_ptr<DownloadRequestHandleInterface> request_handle,\n    const DownloadItemImplCreated& item_created) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  GetNextId(base::Bind(\n      &DownloadManagerImpl::CreateSavePackageDownloadItemWithId,\n      weak_factory_.GetWeakPtr(), main_file_path, page_url, mime_type,\n      base::Passed(std::move(request_handle)), item_created));\n}\n",
        "output": "0",
        "index": 159237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cdrom_ioctl_select_speed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_SPEED\\n\");\n\n\tif (!CDROM_CAN(CDC_SELECT_SPEED))\n\t\treturn -ENOSYS;\n\treturn cdi->ops->select_speed(cdi, arg);\n}\n",
        "output": "0",
        "index": 76242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassOwnPtr<CCProxy> CCThreadProxy::create(CCLayerTreeHost* layerTreeHost)\n{\n    return adoptPtr(new CCThreadProxy(layerTreeHost));\n}\n",
        "output": "0",
        "index": 102707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int khugepaged_test_exit(struct mm_struct *mm)\n{\n\treturn atomic_read(&mm->mm_users) == 0;\n}\n",
        "output": "0",
        "index": 35117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__xmlGetWarningsDefaultValue(void) {\n    if (IS_MAIN_THREAD)\n\treturn (&xmlGetWarningsDefaultValue);\n    else\n\treturn (&xmlGetGlobalState()->xmlGetWarningsDefaultValue);\n}\n",
        "output": "0",
        "index": 114796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int co64_required(const MOVTrack *track)\n{\n    if (track->entry > 0 && track->cluster[track->entry - 1].pos + track->data_offset > UINT32_MAX)\n        return 1;\n    return 0;\n}\n",
        "output": "0",
        "index": 79281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2DecoderImpl::ValidateCompressedTexDimensions(\n    const char* function_name,\n    GLint level, GLsizei width, GLsizei height, GLenum format) {\n  switch (format) {\n    case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:\n    case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:\n    case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:\n    case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT: {\n      if (!IsValidDXTSize(level, width) || !IsValidDXTSize(level, height)) {\n        SetGLError(\n            GL_INVALID_OPERATION, function_name,\n            \"width or height invalid for level\");\n        return false;\n      }\n      return true;\n    }\n    default:\n      return false;\n  }\n}\n",
        "output": "0",
        "index": 110646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewGtk::MarkCachedWidgetCenterStale() {\n  widget_center_valid_ = false;\n  mouse_has_been_warped_to_new_center_ = false;\n}\n",
        "output": "0",
        "index": 123312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __nfs4_read_done_cb(struct nfs_read_data *data)\n{\n\tnfs_invalidate_atime(data->inode);\n}\n",
        "output": "0",
        "index": 19801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool StartupBrowserCreator::ProcessLoadApps(\n    const base::CommandLine& command_line,\n    const base::FilePath& cur_dir,\n    Profile* profile) {\n  base::CommandLine::StringType path_list =\n      command_line.GetSwitchValueNative(extensions::switches::kLoadApps);\n\n  base::StringTokenizerT<base::CommandLine::StringType,\n                         base::CommandLine::StringType::const_iterator>\n      tokenizer(path_list, FILE_PATH_LITERAL(\",\"));\n\n  if (!tokenizer.GetNext())\n    return false;\n\n  base::FilePath app_absolute_dir =\n      base::MakeAbsoluteFilePath(base::FilePath(tokenizer.token()));\n  if (!apps::AppLoadService::Get(profile)->LoadAndLaunch(\n          app_absolute_dir, command_line, cur_dir)) {\n    return false;\n  }\n\n  while (tokenizer.GetNext()) {\n    app_absolute_dir =\n        base::MakeAbsoluteFilePath(base::FilePath(tokenizer.token()));\n\n    if (!apps::AppLoadService::Get(profile)->Load(app_absolute_dir)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
        "output": "0",
        "index": 150189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pfkey_dump_sa_done(struct pfkey_sock *pfk)\n{\n\txfrm_state_walk_done(&pfk->dump.u.state);\n}\n",
        "output": "0",
        "index": 31415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SelectionController::HandleTripleClick(\n    const MouseEventWithHitTestResults& event) {\n  TRACE_EVENT0(\"blink\",\n               \"SelectionController::handleMousePressEventTripleClick\");\n\n  if (!Selection().IsAvailable()) {\n    return false;\n  }\n\n  if (!mouse_down_allows_multi_click_)\n    return HandleSingleClick(event);\n\n  if (event.Event().button != WebPointerProperties::Button::kLeft)\n    return false;\n\n  Node* const inner_node = event.InnerNode();\n  if (!(inner_node && inner_node->GetLayoutObject() &&\n        mouse_down_may_start_select_))\n    return false;\n\n  const VisiblePositionInFlatTree& pos =\n      VisiblePositionOfHitTestResult(event.GetHitTestResult());\n  const VisibleSelectionInFlatTree new_selection =\n      pos.IsNotNull() ? CreateVisibleSelectionWithGranularity(\n                            SelectionInFlatTree::Builder()\n                                .Collapse(pos.ToPositionWithAffinity())\n                                .Build(),\n                            TextGranularity::kParagraph)\n                      : VisibleSelectionInFlatTree();\n\n  const bool is_handle_visible =\n      event.Event().FromTouch() && new_selection.IsRange();\n\n  const bool did_select = UpdateSelectionForMouseDownDispatchingSelectStart(\n      inner_node,\n      ExpandSelectionToRespectUserSelectAll(inner_node,\n                                            new_selection.AsSelection()),\n      TextGranularity::kParagraph,\n      is_handle_visible ? HandleVisibility::kVisible\n                        : HandleVisibility::kNotVisible);\n  if (!did_select)\n    return false;\n\n  if (!Selection().IsHandleVisible())\n    return true;\n  frame_->GetEventHandler().ShowNonLocatedContextMenu(nullptr,\n                                                      kMenuSourceTouch);\n  return true;\n}\n",
        "output": "0",
        "index": 135789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}\n",
        "output": "0",
        "index": 46259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void red_channel_client_reset_send_data(RedChannelClient *rcc)\n{\n    spice_marshaller_reset(rcc->send_data.marshaller);\n    rcc->send_data.header.data = spice_marshaller_reserve_space(rcc->send_data.marshaller,\n                                                                rcc->send_data.header.header_size);\n    spice_marshaller_set_base(rcc->send_data.marshaller, rcc->send_data.header.header_size);\n    rcc->send_data.header.set_msg_type(&rcc->send_data.header, 0);\n    rcc->send_data.header.set_msg_size(&rcc->send_data.header, 0);\n\n    /* Keeping the serial consecutive: reseting it if reset_send_data\n     * has been called before, but no message has been sent since then.\n     */\n    if (rcc->send_data.last_sent_serial != rcc->send_data.serial) {\n        spice_assert(rcc->send_data.serial - rcc->send_data.last_sent_serial == 1);\n        /*  When the urgent marshaller is active, the serial was incremented by\n         *  the call to reset_send_data that was made for the main marshaller.\n         *  The urgent msg receives this serial, and the main msg serial is\n         *  the following one. Thus, (rcc->send_data.serial - rcc->send_data.last_sent_serial)\n         *  should be 1 in this case*/\n        if (!red_channel_client_urgent_marshaller_is_active(rcc)) {\n            rcc->send_data.serial = rcc->send_data.last_sent_serial;\n        }\n    }\n    rcc->send_data.serial++;\n\n    if (!rcc->is_mini_header) {\n        spice_assert(rcc->send_data.marshaller != rcc->send_data.urgent.marshaller);\n        rcc->send_data.header.set_msg_sub_list(&rcc->send_data.header, 0);\n        rcc->send_data.header.set_msg_serial(&rcc->send_data.header, rcc->send_data.serial);\n    }\n}\n",
        "output": "0",
        "index": 2130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeRenderProcessObserver::OnSetIsIncognitoProcess(\n    bool is_incognito_process) {\n  is_incognito_process_ = is_incognito_process;\n}\n",
        "output": "0",
        "index": 108460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aspath_as_add (struct aspath *as, as_t asno)\n{\n  struct assegment *seg = as->segments;\n\n  if (!seg)\n    return;\n  \n  /* Last segment search procedure. */\n  while (seg->next)\n    seg = seg->next;\n\n  assegment_append_asns (seg, &asno, 1);\n}\n",
        "output": "0",
        "index": 1567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 55839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hmac_sha1_digest(struct ahash_request *req)\n{\n\tint ret2, ret1;\n\n\tret1 = hmac_sha1_init(req);\n\tif (ret1)\n\t\tgoto out;\n\n\tret1 = ahash_update(req);\n\tret2 = ahash_final(req);\n\nout:\n\treturn ret1 ? ret1 : ret2;\n}\n",
        "output": "0",
        "index": 47552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EventType TouchEventConverterEvdev::GetEventTypeForTouch(\n    const InProgressTouchEvdev& touch) {\n  if (touch.cancelled)\n    return ET_UNKNOWN;\n\n  if (touch_noise_finder_ && touch_noise_finder_->SlotHasNoise(touch.slot)) {\n    if (touch.touching && !touch.was_touching)\n      return ET_UNKNOWN;\n    return ET_TOUCH_CANCELLED;\n  }\n\n  if (touch.touching)\n    return touch.was_touching ? ET_TOUCH_MOVED : ET_TOUCH_PRESSED;\n  return touch.was_touching ? ET_TOUCH_RELEASED : ET_UNKNOWN;\n}\n",
        "output": "0",
        "index": 134803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nf_ct_net_init(struct net *net)\n{\n\tint res;\n\n\tnet->nf_frag.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnet->nf_frag.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\n\tnet->nf_frag.frags.timeout = IPV6_FRAG_TIMEOUT;\n\tres = inet_frags_init_net(&net->nf_frag.frags);\n\tif (res)\n\t\treturn res;\n\tres = nf_ct_frag6_sysctl_register(net);\n\tif (res)\n\t\tinet_frags_uninit_net(&net->nf_frag.frags);\n\treturn res;\n}\n",
        "output": "0",
        "index": 47995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tg3_ape_wait_for_event(struct tg3 *tp, u32 timeout_us)\n{\n\tu32 i, apedata;\n\n\tfor (i = 0; i < timeout_us / 10; i++) {\n\t\tapedata = tg3_ape_read32(tp, TG3_APE_EVENT_STATUS);\n\n\t\tif (!(apedata & APE_EVENT_STATUS_EVENT_PENDING))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\treturn i == timeout_us / 10;\n}\n",
        "output": "0",
        "index": 32505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ieee80211_if_remove(struct ieee80211_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tlist_del_rcu(&sdata->list);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tsynchronize_rcu();\n\tunregister_netdevice(sdata->dev);\n}\n",
        "output": "0",
        "index": 24325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "run_external_js (WebKitWebView * web_view, GArray *argv, GString *result) {\n    (void) result;\n    gchar *path = NULL;\n\n    if (argv_idx(argv, 0) &&\n        ((path = find_existing_file(argv_idx(argv, 0)))) ) {\n        GArray* lines = read_file_by_line (path);\n        gchar*  js = NULL;\n        int i = 0;\n        gchar* line;\n\n        while ((line = g_array_index(lines, gchar*, i))) {\n            if (js == NULL) {\n                js = g_strdup (line);\n            } else {\n                gchar* newjs = g_strconcat (js, line, NULL);\n                js = newjs;\n            }\n            i ++;\n            g_free (line);\n        }\n\n        if (uzbl.state.verbose)\n            printf (\"External JavaScript file %s loaded\\n\", argv_idx(argv, 0));\n\n        gchar* newjs = str_replace(\"%s\", argv_idx (argv, 1)?argv_idx (argv, 1):\"\", js);\n        g_free (js);\n        js = newjs;\n\n        eval_js (web_view, js, result);\n        g_free (js);\n        g_array_free (lines, TRUE);\n        g_free(path);\n    }\n}\n",
        "output": "0",
        "index": 18390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avpriv_bprint_to_extradata(AVCodecContext *avctx, struct AVBPrint *buf)\n{\n    int ret;\n    char *str;\n\n    ret = av_bprint_finalize(buf, &str);\n    if (ret < 0)\n        return ret;\n    if (!av_bprint_is_complete(buf)) {\n        av_free(str);\n        return AVERROR(ENOMEM);\n    }\n\n    avctx->extradata = str;\n    /* Note: the string is NUL terminated (so extradata can be read as a\n     * string), but the ending character is not accounted in the size (in\n     * binary formats you are likely not supposed to mux that character). When\n     * extradata is copied, it is also padded with AV_INPUT_BUFFER_PADDING_SIZE\n     * zeros. */\n    avctx->extradata_size = buf->len;\n    return 0;\n}\n",
        "output": "0",
        "index": 67002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_options(struct exfat* ef, const char* options)\n{\n\tint opt_umask;\n\n\topt_umask = get_int_option(options, \"umask\", 8, 0);\n\tef->dmask = get_int_option(options, \"dmask\", 8, opt_umask);\n\tef->fmask = get_int_option(options, \"fmask\", 8, opt_umask);\n\n\tef->uid = get_int_option(options, \"uid\", 10, geteuid());\n\tef->gid = get_int_option(options, \"gid\", 10, getegid());\n\n\tef->noatime = match_option(options, \"noatime\");\n}\n",
        "output": "0",
        "index": 74080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual URLRequestJob* MaybeIntercept(URLRequest* request,\n                                        NetworkDelegate* network_delegate) {\n    if (restart_main_request_) {\n      restart_main_request_ = false;\n      did_restart_main_ = true;\n      return new RestartTestJob(request, network_delegate);\n    }\n    if (cancel_main_request_) {\n      cancel_main_request_ = false;\n      did_cancel_main_ = true;\n      return new CancelTestJob(request, network_delegate);\n    }\n    if (cancel_then_restart_main_request_) {\n      cancel_then_restart_main_request_ = false;\n      did_cancel_then_restart_main_ = true;\n      return new CancelThenRestartTestJob(request, network_delegate);\n    }\n    if (simulate_main_network_error_) {\n      simulate_main_network_error_ = false;\n      did_simulate_error_main_ = true;\n      return new URLRequestTestJob(request, network_delegate, true);\n    }\n    if (!intercept_main_request_)\n      return NULL;\n    intercept_main_request_ = false;\n    did_intercept_main_ = true;\n    return new URLRequestTestJob(request,\n                                 network_delegate,\n                                 main_headers_,\n                                 main_data_,\n                                 true);\n  }\n",
        "output": "0",
        "index": 108629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init dma_contiguous_remap(void)\n{\n\tint i;\n\tfor (i = 0; i < dma_mmu_remap_num; i++) {\n\t\tphys_addr_t start = dma_mmu_remap[i].base;\n\t\tphys_addr_t end = start + dma_mmu_remap[i].size;\n\t\tstruct map_desc map;\n\t\tunsigned long addr;\n\n\t\tif (end > arm_lowmem_limit)\n\t\t\tend = arm_lowmem_limit;\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\tmap.pfn = __phys_to_pfn(start);\n\t\tmap.virtual = __phys_to_virt(start);\n\t\tmap.length = end - start;\n\t\tmap.type = MT_MEMORY_DMA_READY;\n\n\t\t/*\n\t\t * Clear previous low-memory mapping\n\t\t */\n\t\tfor (addr = __phys_to_virt(start); addr < __phys_to_virt(end);\n\t\t     addr += PMD_SIZE)\n\t\t\tpmd_clear(pmd_off_k(addr));\n\n\t\tiotable_init(&map, 1);\n\t}\n}\n",
        "output": "0",
        "index": 58319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DataReductionProxyIOData::InitializeOnIOThread(\n    const std::string& user_agent) {\n  DCHECK(io_task_runner_->BelongsToCurrentThread());\n  DCHECK(network_properties_manager_);\n\n  DCHECK(url_loader_factory_info_);\n  auto url_loader_factory = network::SharedURLLoaderFactory::Create(\n      std::move(url_loader_factory_info_));\n\n  config_->InitializeOnIOThread(\n      url_loader_factory,\n      base::BindRepeating(&DataReductionProxyIOData::CreateCustomProxyConfig,\n                          base::Unretained(this), true),\n      network_properties_manager_.get(), user_agent);\n  if (config_client_)\n    config_client_->InitializeOnIOThread(url_loader_factory);\n  if (ui_task_runner_->BelongsToCurrentThread()) {\n    service_->SetIOData(weak_factory_.GetWeakPtr());\n    return;\n  }\n  ui_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&DataReductionProxyService::SetIOData, service_,\n                                weak_factory_.GetWeakPtr()));\n}\n",
        "output": "0",
        "index": 150598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tint err;\n\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\n\tif ((err = register_netdev(sitn->fb_tunnel_dev)))\n\t\tgoto err_reg_dev;\n\n\treturn 0;\n\nerr_reg_dev:\n\tdev_put(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}\n",
        "output": "0",
        "index": 27458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void update_rate_histogram(struct rate_hist *hist,\n const vpx_codec_enc_cfg_t *cfg,\n const vpx_codec_cx_pkt_t *pkt) {\n int i;\n int64_t then = 0;\n int64_t avg_bitrate = 0;\n int64_t sum_sz = 0;\n const int64_t now = pkt->data.frame.pts * 1000 *\n (uint64_t)cfg->g_timebase.num /\n (uint64_t)cfg->g_timebase.den;\n\n int idx = hist->frames++ % hist->samples;\n  hist->pts[idx] = now;\n  hist->sz[idx] = (int)pkt->data.frame.sz;\n\n\n   if (now < cfg->rc_buf_initial_sz)\n     return;\n \n   then = now;\n \n   /* Sum the size over the past rc_buf_sz ms */\n for (i = hist->frames; i > 0 && hist->frames - i < hist->samples; i--) {\n const int i_idx = (i - 1) % hist->samples;\n\n    then = hist->pts[i_idx];\n if (now - then > cfg->rc_buf_sz)\n break;\n    sum_sz += hist->sz[i_idx];\n }\n\n if (now == then)\n return;\n\n  avg_bitrate = sum_sz * 8 * 1000 / (now - then);\n  idx = (int)(avg_bitrate * (RATE_BINS / 2) / (cfg->rc_target_bitrate * 1000));\n if (idx < 0)\n    idx = 0;\n if (idx > RATE_BINS - 1)\n    idx = RATE_BINS - 1;\n if (hist->bucket[idx].low > avg_bitrate)\n    hist->bucket[idx].low = (int)avg_bitrate;\n if (hist->bucket[idx].high < avg_bitrate)\n    hist->bucket[idx].high = (int)avg_bitrate;\n  hist->bucket[idx].count++;\n  hist->total++;\n}\n",
        "output": "1",
        "index": 188522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void deprecatedReadonlyAttrAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    UseCounter::countDeprecation(callingExecutionContext(info.GetIsolate()), UseCounter::ReadonlyAttribute);\n    TestObjectV8Internal::deprecatedReadonlyAttrAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "index": 130717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "logger_get_filename (struct t_gui_buffer *buffer)\n{\n    char *res, *mask_expanded, *file_path;\n    const char *mask;\n    const char *dir_separator, *weechat_dir;\n    int length;\n\n    res = NULL;\n    mask_expanded = NULL;\n    file_path = NULL;\n\n    dir_separator = weechat_info_get (\"dir_separator\", \"\");\n    if (!dir_separator)\n        return NULL;\n    weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n    if (!weechat_dir)\n        return NULL;\n\n    /* get filename mask for buffer */\n    mask = logger_get_mask_for_buffer (buffer);\n    if (!mask)\n    {\n        weechat_printf_date_tags (\n            NULL, 0, \"no_log\",\n            _(\"%s%s: unable to find filename mask for buffer \"\n              \"\\\"%s\\\", logging is disabled for this buffer\"),\n            weechat_prefix (\"error\"), LOGGER_PLUGIN_NAME,\n            weechat_buffer_get_string (buffer, \"name\"));\n        return NULL;\n    }\n\n    mask_expanded = logger_get_mask_expanded (buffer, mask);\n    if (!mask_expanded)\n        goto end;\n\n    file_path = logger_get_file_path ();\n    if (!file_path)\n        goto end;\n\n    /* build string with path + mask */\n    length = strlen (file_path) + strlen (dir_separator) +\n        strlen (mask_expanded) + 1;\n    res = malloc (length);\n    if (res)\n    {\n        snprintf (res, length, \"%s%s%s\",\n                  file_path,\n                  (file_path[strlen (file_path) - 1] == dir_separator[0]) ? \"\" : dir_separator,\n                  mask_expanded);\n    }\n\nend:\n    if (mask_expanded)\n        free (mask_expanded);\n    if (file_path)\n        free (file_path);\n\n    return res;\n}\n",
        "output": "0",
        "index": 60834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inet_get_local_port_range(int *low, int *high)\n{\n\tunsigned seq;\n\tdo {\n\t\tseq = read_seqbegin(&sysctl_local_ports.lock);\n\n\t\t*low = sysctl_local_ports.range[0];\n\t\t*high = sysctl_local_ports.range[1];\n\t} while (read_seqretry(&sysctl_local_ports.lock, seq));\n}\n",
        "output": "0",
        "index": 18887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double WebMediaPlayerImpl::Duration() const {\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n\n  if (ready_state_ == WebMediaPlayer::kReadyStateHaveNothing)\n    return std::numeric_limits<double>::quiet_NaN();\n\n  if (chunk_demuxer_)\n    return chunk_demuxer_->GetDuration();\n\n  base::TimeDelta pipeline_duration = GetPipelineMediaDuration();\n  return pipeline_duration == kInfiniteDuration\n             ? std::numeric_limits<double>::infinity()\n             : pipeline_duration.InSecondsF();\n}\n",
        "output": "0",
        "index": 157198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPage::clearHistory()\n{\n    PageGroup::removeAllVisitedLinks();\n}\n",
        "output": "0",
        "index": 111089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nodeFilterAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(RefPtr<NodeFilter>, cppValue, toNodeFilter(jsValue, info.GetIsolate()));\n    imp->setNodeFilterAttribute(WTF::getPtr(cppValue));\n}\n",
        "output": "0",
        "index": 131493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs_idmap_pipe_destroy(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct idmap *idmap = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = idmap->idmap_pipe;\n\n\tif (pipe->dentry) {\n\t\trpc_unlink(pipe->dentry);\n\t\tpipe->dentry = NULL;\n\t}\n}\n",
        "output": "0",
        "index": 69464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "modifier_set_encoding(png_modifier *pm)\n{\n /* Set the encoding to the one specified by the current encoding counter,\n    * first clear out all the settings - this corresponds to an encoding_counter\n    * of 0.\n    */\n   pm->current_gamma = 0;\n   pm->current_encoding = 0;\n   pm->encoding_ignored = 0; /* not ignored yet - happens in _ini functions. */\n\n /* Now, if required, set the gamma and encoding fields. */\n if (pm->encoding_counter > 0)\n {\n /* The gammas[] array is an array of screen gammas, not encoding gammas,\n       * so we need the inverse:\n       */\n if (pm->encoding_counter <= pm->ngammas)\n         pm->current_gamma = 1/pm->gammas[pm->encoding_counter-1];\n\n else\n {\n unsigned int i = pm->encoding_counter - pm->ngammas;\n\n if (i >= pm->nencodings)\n {\n            i %= pm->nencodings;\n            pm->current_gamma = 1; /* Linear, only in the 16 bit case */\n }\n\n else\n            pm->current_gamma = pm->encodings[i].gamma;\n\n         pm->current_encoding = pm->encodings + i;\n }\n }\n}\n",
        "output": "0",
        "index": 173175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *userns_get(struct task_struct *task)\n{\n\tstruct user_namespace *user_ns;\n\n\trcu_read_lock();\n\tuser_ns = get_user_ns(__task_cred(task)->user_ns);\n\trcu_read_unlock();\n\n\treturn user_ns;\n}\n",
        "output": "0",
        "index": 29922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::OnVisualStateRequest(uint64_t id) {\n  GetRenderWidget()->QueueMessage(\n      new FrameHostMsg_VisualStateResponse(routing_id_, id));\n}\n",
        "output": "0",
        "index": 165923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHPAPI php_stream *_php_stream_memory_open(int mode, char *buf, size_t length STREAMS_DC TSRMLS_DC)\n{\n\tphp_stream *stream;\n\tphp_stream_memory_data *ms;\n \n        if ((stream = php_stream_memory_create_rel(mode)) != NULL) {\n                ms = (php_stream_memory_data*)stream->abstract;\n                if (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {\n                        /* use the buffer directly */\n                        ms->data = buf;\n\t\t\tms->fsize = length;\n\t\t} else {\n\t\t\tif (length) {\n\t\t\t\tassert(buf != NULL);\n\t\t\t\tphp_stream_write(stream, buf, length);\n\t\t\t}\n\t\t}\n\t}\n\treturn stream;\n}\n",
        "output": "1",
        "index": 178647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void webViewEnterFullscreen(WebKitWebView* webView, Node* node)\n{\n    if (!node->hasTagName(HTMLNames::videoTag))\n        return;\n\n#if ENABLE(VIDEO)\n    HTMLMediaElement* videoElement = static_cast<HTMLMediaElement*>(node);\n    WebKitWebViewPrivate* priv = webView->priv;\n\n    if (priv->fullscreenVideoController)\n        priv->fullscreenVideoController->exitFullscreen();\n\n    priv->fullscreenVideoController = new FullscreenVideoController;\n    priv->fullscreenVideoController->setMediaElement(videoElement);\n    priv->fullscreenVideoController->enterFullscreen();\n#endif\n}\n",
        "output": "0",
        "index": 105386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGL2RenderingContextBase::endTransformFeedback() {\n  if (isContextLost())\n    return;\n\n  ContextGL()->EndTransformFeedback();\n\n  if (current_program_)\n    current_program_->DecreaseActiveTransformFeedbackCount();\n}\n",
        "output": "0",
        "index": 146092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPB_Flash_MessageLoop_Impl::InternalQuit(int32_t result) {\n  if (!state_->run_called() || state_->quit_called())\n    return;\n  state_->set_quit_called();\n  state_->set_result(result);\n\n  base::MessageLoop::current()->QuitNow();\n\n  if (!state_->run_callback().is_null())\n    state_->run_callback().Run(result);\n}\n",
        "output": "0",
        "index": 143756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Con_ToggleMenu_f( void ) {\n\tCL_KeyEvent( K_ESCAPE, qtrue, Sys_Milliseconds() );\n\tCL_KeyEvent( K_ESCAPE, qfalse, Sys_Milliseconds() );\n}\n",
        "output": "0",
        "index": 95440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void increment(huff_t* huff, node_t *node) {\n\tnode_t *lnode;\n\n\tif (!node) {\n\t\treturn;\n\t}\n\n\tif (node->next != NULL && node->next->weight == node->weight) {\n\t    lnode = *node->head;\n\t\tif (lnode != node->parent) {\n\t\t\tswap(huff, lnode, node);\n\t\t}\n\t\tswaplist(lnode, node);\n\t}\n\tif (node->prev && node->prev->weight == node->weight) {\n\t\t*node->head = node->prev;\n\t} else {\n\t    *node->head = NULL;\n\t\tfree_ppnode(huff, node->head);\n\t}\n\tnode->weight++;\n\tif (node->next && node->next->weight == node->weight) {\n\t\tnode->head = node->next->head;\n\t} else { \n\t\tnode->head = get_ppnode(huff);\n\t\t*node->head = node;\n\t}\n\tif (node->parent) {\n\t\tincrement(huff, node->parent);\n\t\tif (node->prev == node->parent) {\n\t\t\tswaplist(node, node->parent);\n\t\t\tif (*node->head == node) {\n\t\t\t\t*node->head = node->parent;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 63131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __dma_update_pte(pte_t *pte, pgtable_t token, unsigned long addr,\n\t\t\t    void *data)\n{\n\tstruct page *page = virt_to_page(addr);\n\tpgprot_t prot = *(pgprot_t *)data;\n\n\tset_pte_ext(pte, mk_pte(page, prot), 0);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  TestOpenCallback()\n      : callback_(\n            base::Bind(&TestOpenCallback::SetResult, base::Unretained(this))) {}\n",
        "output": "1",
        "index": 185854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  OnigEncoding enc = reg->enc;\n\n  sn = STR_(node);\n  if (sn->end <= sn->s)\n    return 0;\n\n  end = sn->end;\n  ambig = NODE_STRING_IS_AMBIG(node);\n\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r != 0) return r;\n\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n\n    p += len;\n  }\n\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}\n",
        "output": "0",
        "index": 89137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "user_change_real_name_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n\n{\n        gchar *name = data;\n        GError *error;\n        const gchar *argv[6];\n\n        if (g_strcmp0 (user->real_name, name) != 0) {\n                sys_log (context,\n                         \"change real name of user '%s' (%d) to '%s'\",\n                         user->user_name, user->uid, name);\n\n                argv[0] = \"/usr/sbin/usermod\";\n                argv[1] = \"-c\";\n                argv[2] = name;\n                argv[3] = \"--\";\n                argv[4] = user->user_name;\n                argv[5] = NULL;\n\n                error = NULL;\n                if (!spawn_with_login_uid (context, argv, &error)) {\n                        throw_error (context, ERROR_FAILED, \"running '%s' failed: %s\", argv[0], error->message);\n                        g_error_free (error);\n                        return;\n                }\n\n                g_free (user->real_name);\n                user->real_name = g_strdup (name);\n\n                accounts_user_emit_changed (ACCOUNTS_USER (user));\n\n                g_object_notify (G_OBJECT (user), \"real-name\");\n        }\n\n         accounts_user_complete_set_real_name (ACCOUNTS_USER (user), context);\n }\n",
        "output": "0",
        "index": 10370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XNewModifiermap(int keyspermodifier)\n{\n    XModifierKeymap *res = Xmalloc((sizeof (XModifierKeymap)));\n    if (res) {\n\tres->max_keypermod = keyspermodifier;\n\tres->modifiermap = (keyspermodifier > 0 ?\n\t\t\t    Xmalloc(8 * keyspermodifier)\n\t\t\t    : (KeyCode *) NULL);\n\tif (keyspermodifier && (res->modifiermap == NULL)) {\n\t    Xfree(res);\n\t    return (XModifierKeymap *) NULL;\n\t}\n    }\n    return (res);\n}\n",
        "output": "0",
        "index": 8323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool OSExchangeDataProviderAura::GetPickledData(\n    const OSExchangeData::CustomFormat& format,\n    Pickle* data) const {\n  PickleData::const_iterator i = pickle_data_.find(format);\n  if (i == pickle_data_.end())\n    return false;\n\n  *data = i->second;\n  return true;\n}\n",
        "output": "0",
        "index": 134613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  QuicPeerForTest* client_peer() { return client_peer_.get(); }\n",
        "output": "0",
        "index": 145438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int armv8pmu_enable_counter(int idx)\n{\n\tu32 counter;\n\n\tif (!armv8pmu_counter_valid(idx)) {\n\t\tpr_err(\"CPU%u enabling wrong PMNC counter %d\\n\",\n\t\t\tsmp_processor_id(), idx);\n\t\treturn -EINVAL;\n\t}\n\n\tcounter = ARMV8_IDX_TO_COUNTER(idx);\n\tasm volatile(\"msr pmcntenset_el0, %0\" :: \"r\" (BIT(counter)));\n\treturn idx;\n}\n",
        "output": "0",
        "index": 56206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HKEY GetHKEYFromString(const std::wstring &name) {\n  if (L\"HKLM\" == name)\n    return HKEY_LOCAL_MACHINE;\n  else if (L\"HKCR\" == name)\n    return HKEY_CLASSES_ROOT;\n  else if (L\"HKCC\" == name)\n    return HKEY_CURRENT_CONFIG;\n  else if (L\"HKCU\" == name)\n    return HKEY_CURRENT_USER;\n  else if (L\"HKU\" == name)\n    return HKEY_USERS;\n\n  return NULL;\n}\n",
        "output": "0",
        "index": 114151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int phar_copy_entry_fp(phar_entry_info *source, phar_entry_info *dest, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_entry_info *link;\n\n\tif (FAILURE == phar_open_entry_fp(source, error, 1 TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (dest->link) {\n\t\tefree(dest->link);\n\t\tdest->link = NULL;\n\t\tdest->tar_type = (dest->is_tar ? TAR_FILE : '\\0');\n\t}\n\n\tdest->fp_type = PHAR_MOD;\n\tdest->offset = 0;\n\tdest->is_modified = 1;\n\tdest->fp = php_stream_fopen_tmpfile();\n\tif (dest->fp == NULL) {\n\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");\n\t\treturn EOF;\n\t}\n\tphar_seek_efp(source, 0, SEEK_SET, 0, 1 TSRMLS_CC);\n\tlink = phar_get_link_source(source TSRMLS_CC);\n\n\tif (!link) {\n\t\tlink = source;\n\t}\n\n\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), dest->fp, link->uncompressed_filesize, NULL)) {\n\t\tphp_stream_close(dest->fp);\n\t\tdest->fp_type = PHAR_FP;\n\t\tif (error) {\n\t\t\tspprintf(error, 4096, \"phar error: unable to copy contents of file \\\"%s\\\" to \\\"%s\\\" in phar archive \\\"%s\\\"\", source->filename, dest->filename, source->phar->fname);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n",
        "output": "0",
        "index": 187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 33266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned LocalFrameClientImpl::BackForwardLength() {\n  WebViewImpl* webview = web_frame_->ViewImpl();\n  if (!webview || !webview->Client())\n    return 0;\n  return webview->Client()->HistoryBackListCount() + 1 +\n         webview->Client()->HistoryForwardListCount();\n}\n",
        "output": "0",
        "index": 158019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t NuMediaExtractor::readSampleData(const sp<ABuffer> &buffer) {\n Mutex::Autolock autoLock(mLock);\n\n ssize_t minIndex = fetchTrackSamples();\n\n if (minIndex < 0) {\n return ERROR_END_OF_STREAM;\n }\n\n TrackInfo *info = &mSelectedTracks.editItemAt(minIndex);\n\n size_t sampleSize = info->mSample->range_length();\n\n if (info->mTrackFlags & kIsVorbis) {\n        sampleSize += sizeof(int32_t);\n }\n\n if (buffer->capacity() < sampleSize) {\n return -ENOMEM;\n }\n\n const uint8_t *src =\n (const uint8_t *)info->mSample->data()\n + info->mSample->range_offset();\n\n    memcpy((uint8_t *)buffer->data(), src, info->mSample->range_length());\n\n status_t err = OK;\n if (info->mTrackFlags & kIsVorbis) {\n        err = appendVorbisNumPageSamples(info, buffer);\n }\n\n if (err == OK) {\n        buffer->setRange(0, sampleSize);\n }\n\n return err;\n}\n",
        "output": "0",
        "index": 175596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string ProcessRawBytes(const unsigned char* data, size_t data_length) {\n  return ProcessRawBytesWithSeparators(data, data_length, ' ', '\\n');\n}\n",
        "output": "0",
        "index": 115309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\n{\n\tstruct sas_discovery *disc;\n\n\tif (!port)\n\t\treturn 0;\n\tdisc = &port->disc;\n\n\tBUG_ON(ev >= DISC_NUM_EVENTS);\n\n\tsas_chain_event(ev, &disc->pending, &disc->disc_work[ev].work, port->ha);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 85467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DelegatedFrameHost::OnCompositingEnded(\n    ui::Compositor* compositor) {\n}\n",
        "output": "0",
        "index": 119988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n",
        "output": "0",
        "index": 24494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::PushCurrentScript(ScriptElementBase* new_current_script) {\n  current_script_stack_.push_back(new_current_script);\n}\n",
        "output": "0",
        "index": 141190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ProfileSyncService::ShutdownImpl(bool sync_disabled) {\n  base::Time shutdown_start_time = base::Time::Now();\n  if (backend_.get())\n    backend_->StopSyncingForShutdown();\n\n  if (data_type_manager_.get()) {\n    if (data_type_manager_->state() != DataTypeManager::STOPPED) {\n      expect_sync_configuration_aborted_ = true;\n      data_type_manager_->Stop();\n    }\n\n    registrar_.Remove(\n        this,\n        chrome::NOTIFICATION_SYNC_CONFIGURE_START,\n        content::Source<DataTypeManager>(data_type_manager_.get()));\n    registrar_.Remove(\n        this,\n        chrome::NOTIFICATION_SYNC_CONFIGURE_DONE,\n        content::Source<DataTypeManager>(data_type_manager_.get()));\n    registrar_.Remove(\n        this,\n        chrome::NOTIFICATION_SYNC_CONFIGURE_BLOCKED,\n        content::Source<DataTypeManager>(data_type_manager_.get()));\n    data_type_manager_.reset();\n  }\n\n  migrator_.reset();\n  sync_js_controller_.AttachJsBackend(WeakHandle<JsBackend>());\n\n  scoped_ptr<SyncBackendHost> doomed_backend(backend_.release());\n  if (doomed_backend.get()) {\n    doomed_backend->Shutdown(sync_disabled);\n\n    doomed_backend.reset();\n  }\n  base::TimeDelta shutdown_time = base::Time::Now() - shutdown_start_time;\n  UMA_HISTOGRAM_TIMES(\"Sync.Shutdown.BackendDestroyedTime\", shutdown_time);\n\n  weak_factory_.InvalidateWeakPtrs();\n\n  expect_sync_configuration_aborted_ = false;\n  is_auth_in_progress_ = false;\n  backend_initialized_ = false;\n  cached_passphrase_.clear();\n  encryption_pending_ = false;\n  encrypt_everything_ = false;\n  encrypted_types_ = browser_sync::Cryptographer::SensitiveTypes();\n  passphrase_required_reason_ = sync_api::REASON_PASSPHRASE_NOT_REQUIRED;\n  last_auth_error_ = GoogleServiceAuthError::None();\n\n  if (sync_global_error_.get()) {\n    GlobalErrorServiceFactory::GetForProfile(profile_)->RemoveGlobalError(\n        sync_global_error_.get());\n    RemoveObserver(sync_global_error_.get());\n    sync_global_error_.reset(NULL);\n  }\n}\n",
        "output": "0",
        "index": 111939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&, PassRefPtr<FormState> formState, bool shouldContinue)\n{\n    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader->unreachableURL().isEmpty());\n\n    bool isTargetItem = history()->provisionalItem() ? history()->provisionalItem()->isTargetItem() : false;\n\n    bool canContinue = shouldContinue && (!isLoadingMainFrame() || m_frame->shouldClose());\n\n    if (!canContinue) {\n        if (m_quickRedirectComing)\n            clientRedirectCancelledOrFinished(false);\n\n        setPolicyDocumentLoader(0);\n\n        if ((isTargetItem || isLoadingMainFrame()) && isBackForwardLoadType(policyChecker()->loadType()))\n            if (Page* page = m_frame->page()) {\n                Frame* mainFrame = page->mainFrame();\n                if (HistoryItem* resetItem = mainFrame->loader()->history()->currentItem()) {\n                    page->backForwardList()->goToItem(resetItem);\n                    Settings* settings = m_frame->settings();\n                    page->setGlobalHistoryItem((!settings || settings->privateBrowsingEnabled()) ? 0 : resetItem);\n                }\n            }\n        return;\n    }\n\n    FrameLoadType type = policyChecker()->loadType();\n    stopAllLoaders();\n    \n    if (!m_frame->page())\n        return;\n\n#if ENABLE(JAVASCRIPT_DEBUGGER) && ENABLE(INSPECTOR)\n    if (Page* page = m_frame->page()) {\n        if (page->mainFrame() == m_frame)\n            page->inspectorController()->resumeDebugger();\n    }\n#endif\n\n    setProvisionalDocumentLoader(m_policyDocumentLoader.get());\n    m_loadType = type;\n    setState(FrameStateProvisional);\n\n    setPolicyDocumentLoader(0);\n\n    if (isBackForwardLoadType(type) && loadProvisionalItemFromCachedPage())\n        return;\n\n    if (formState)\n        m_client->dispatchWillSubmitForm(&PolicyChecker::continueLoadAfterWillSubmitForm, formState);\n    else\n        continueLoadAfterWillSubmitForm();\n}\n",
        "output": "0",
        "index": 97382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CompositeSettingsChange* BaseSettingChange::MergeWith(\n    BaseSettingChange* other) {\n  CompositeSettingsChange* composite_change = new CompositeSettingsChange();\n  CHECK(composite_change->Init(profile_));\n  composite_change->MergeWith(this);\n  composite_change->MergeWith(other);\n  return composite_change;\n}\n",
        "output": "0",
        "index": 110717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct pfkey_sock *pfk = ptr;\n\tstruct sk_buff *out_skb;\n\tstruct sadb_msg *out_hdr;\n\tint err;\n\n\tif (!pfkey_can_dump(&pfk->sk))\n\t\treturn -ENOBUFS;\n\n\tout_skb = pfkey_xfrm_policy2msg_prep(xp);\n\tif (IS_ERR(out_skb))\n\t\treturn PTR_ERR(out_skb);\n\n\terr = pfkey_xfrm_policy2msg(out_skb, xp, dir);\n\tif (err < 0)\n\t\treturn err;\n\n\tout_hdr = (struct sadb_msg *) out_skb->data;\n\tout_hdr->sadb_msg_version = pfk->dump.msg_version;\n\tout_hdr->sadb_msg_type = SADB_X_SPDDUMP;\n\tout_hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\tout_hdr->sadb_msg_errno = 0;\n\tout_hdr->sadb_msg_seq = count + 1;\n\tout_hdr->sadb_msg_pid = pfk->dump.msg_portid;\n\n\tif (pfk->dump.skb)\n\t\tpfkey_broadcast(pfk->dump.skb, GFP_ATOMIC, BROADCAST_ONE,\n\t\t\t\t&pfk->sk, sock_net(&pfk->sk));\n\tpfk->dump.skb = out_skb;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 31387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::allowInlineEventHandlers(Node* node, EventListener* listener, const String& contextURL, const WTF::OrdinalNumber& contextLine)\n{\n    if (!contentSecurityPolicy()->allowInlineEventHandlers(contextURL, contextLine))\n        return false;\n\n    LocalFrame* frame = executingFrame();\n    if (!frame)\n        return false;\n    if (!frame->script().canExecuteScripts(NotAboutToExecuteScript))\n        return false;\n    if (node && node->document() != this && !node->document().allowInlineEventHandlers(node, listener, contextURL, contextLine))\n        return false;\n\n    return true;\n}\n",
        "output": "0",
        "index": 138402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TabContentsWrapper* GetTabContentsWrapperFromDict(const Browser* browser,\n                                                  const DictionaryValue* args,\n                                                  std::string* error_message) {\n  int tab_index;\n  if (!args->GetInteger(\"tab_index\", &tab_index)) {\n    *error_message = \"Must include tab_index.\";\n    return NULL;\n  }\n\n  TabContentsWrapper* tab_contents =\n      browser->GetTabContentsWrapperAt(tab_index);\n  if (!tab_contents) {\n    *error_message = StringPrintf(\"No tab at index %d.\", tab_index);\n    return NULL;\n  }\n  return tab_contents;\n}\n",
        "output": "0",
        "index": 114951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool lockdep_nfnl_is_held(u8 subsys_id)\n{\n\treturn lockdep_is_held(&table[subsys_id].mutex);\n}\n",
        "output": "0",
        "index": 49364
    }
]