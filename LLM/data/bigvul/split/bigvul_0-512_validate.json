[
    {
        "index": 102672,
        "code": "void CCLayerTreeHost::clearPendingUpdate()\n{\n    for (size_t surfaceIndex = 0; surfaceIndex < m_updateList.size(); ++surfaceIndex) {\n        LayerChromium* layer = m_updateList[surfaceIndex].get();\n        ASSERT(layer->renderSurface());\n        layer->clearRenderSurface();\n    }\n    m_updateList.clear();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2881",
        "length": 76
    },
    {
        "index": 160261,
        "code": "  explicit ServiceWorkerTest(version_info::Channel channel)\n      : current_channel_(channel) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6089",
        "length": 20
    },
    {
        "index": 12080,
        "code": "int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)\n{\n    if (group->meth->invert == 0) {\n        ECerr(EC_F_EC_POINT_INVERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return 0;\n    }\n    if (group->meth != a->meth) {\n        ECerr(EC_F_EC_POINT_INVERT, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n    return group->meth->invert(group, a, ctx);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-311",
        "cve": "CVE-2019-1547",
        "length": 116
    },
    {
        "index": 138634,
        "code": "void RenderFrameHostImpl::ActivateFindInPageResultForAccessibility(\n    int request_id) {\n  AccessibilityMode accessibility_mode = delegate_->GetAccessibilityMode();\n  if (accessibility_mode.has_mode(AccessibilityMode::kNativeAPIs)) {\n    BrowserAccessibilityManager* manager =\n        GetOrCreateBrowserAccessibilityManager();\n    if (manager)\n      manager->ActivateFindInPageResult(request_id);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1278",
        "length": 85
    },
    {
        "index": 62075,
        "code": "static bool rt_cache_route(struct fib_nh *nh, struct rtable *rt)\n{\n\tstruct rtable *orig, *prev, **p;\n\tbool ret = true;\n\n\tif (rt_is_input_route(rt)) {\n\t\tp = (struct rtable **)&nh->nh_rth_input;\n\t} else {\n\t\tp = (struct rtable **)raw_cpu_ptr(nh->nh_pcpu_rth_output);\n\t}\n\torig = *p;\n\n\t/* hold dst before doing cmpxchg() to avoid race condition\n\t * on this dst\n\t */\n\tdst_hold(&rt->dst);\n\tprev = cmpxchg(p, orig, rt);\n\tif (prev == orig) {\n\t\tif (orig) {\n\t\t\tdst_dev_put(&orig->dst);\n\t\t\tdst_release(&orig->dst);\n\t\t}\n\t} else {\n\t\tdst_release(&rt->dst);\n\t\tret = false;\n\t}\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-13686",
        "length": 190
    },
    {
        "index": 183136,
        "code": " cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\n \tBuffer *buf, int *err, gchar **err_info)\n {\n\tint\tpkt_len;\n \tchar\tline[COSINE_LINE_LENGTH];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\n\t\treturn FALSE;\n\n\tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n \t\treturn FALSE;\n \t}\n \n\t/* Parse the header */\n\tpkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\t/* Convert the ASCII hex dump to binary data */\n\treturn parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,\n \t    err_info);\n }\n",
        "line": "\tint\tpkt_len;\n\t/* Parse the header */\n\tpkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\t/* Convert the ASCII hex dump to binary data */\n\treturn parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5356",
        "length": 226
    },
    {
        "index": 155938,
        "code": "void PeopleHandler::HandleStartSyncingWithEmail(const base::ListValue* args) {\n  DCHECK(AccountConsistencyModeManager::IsDiceEnabledForProfile(profile_));\n  const base::Value* email;\n  const base::Value* is_default_promo_account;\n  CHECK(args->Get(0, &email));\n  CHECK(args->Get(1, &is_default_promo_account));\n\n  Browser* browser =\n      chrome::FindBrowserWithWebContents(web_ui()->GetWebContents());\n\n  AccountTrackerService* account_tracker =\n      AccountTrackerServiceFactory::GetForProfile(profile_);\n  AccountInfo account =\n      account_tracker->FindAccountInfoByEmail(email->GetString());\n  signin_ui_util::EnableSyncFromPromo(\n      browser, account, signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS,\n      is_default_promo_account->GetBool());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1665",
        "length": 173
    },
    {
        "index": 127532,
        "code": "void LayerWebKitThread::setContents(Image* contents)\n{\n    if (m_contents == contents) {\n        if (contents)\n            setNeedsDisplay();\n        return;\n    }\n    m_contents = contents;\n    setNeedsTexture(m_isDrawable && (this->contents() || drawsContent() || pluginView()));\n\n    if (m_contents)\n        setNeedsDisplay();\n    else\n        setNeedsCommit();\n\n    m_contentsResolutionIndependent = static_cast<bool>(m_contents);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-0837",
        "length": 97
    },
    {
        "index": 105962,
        "code": "bool JSTestCustomNamedGetterOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, SlotVisitor& visitor)\n{\n    JSTestCustomNamedGetter* jsTestCustomNamedGetter = jsCast<JSTestCustomNamedGetter*>(handle.get().asCell());\n    if (!isObservable(jsTestCustomNamedGetter))\n        return false;\n    UNUSED_PARAM(visitor);\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2350",
        "length": 90
    },
    {
        "index": 9002,
        "code": "static int vmxnet3_get_txq_descr(QEMUFile *f, void *pv, size_t size)\n{\n    Vmxnet3TxqDescr *r = pv;\n\n    vmxnet3_get_ring_from_file(f, &r->tx_ring);\n    vmxnet3_get_ring_from_file(f, &r->comp_ring);\n    r->intr_idx = qemu_get_byte(f);\n    r->tx_stats_pa = qemu_get_be64(f);\n\n    vmxnet3_get_tx_stats_from_file(f, &r->txq_stats);\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-6836",
        "length": 123
    },
    {
        "index": 93575,
        "code": "static netdev_tx_t reg_vif_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mr6_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif\t= dev->ifindex,\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint err;\n\n\terr = ip6mr_fib_lookup(net, &fl6, &mrt);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tread_lock(&mrt_lock);\n\tdev->stats.tx_bytes += skb->len;\n\tdev->stats.tx_packets++;\n\tip6mr_cache_report(mrt, skb, mrt->mroute_reg_vif_num, MRT6MSG_WHOLEPKT);\n\tread_unlock(&mrt_lock);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-18509",
        "length": 204
    },
    {
        "index": 88731,
        "code": "int modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->response_timeout.tv_sec;\n    *to_usec = ctx->response_timeout.tv_usec;\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2019-14463",
        "length": 78
    },
    {
        "index": 9458,
        "code": "int tls1_ec_nid2curve_id(int nid)\n{\n    size_t i;\n    for (i = 0; i < OSSL_NELEM(nid_list); i++) {\n        if (nid_list[i].nid == nid)\n            return i + 1;\n    }\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-6302",
        "length": 66
    },
    {
        "index": 102098,
        "code": "PendingConfigureDataTypesState()\n    : reason(sync_api::CONFIGURE_REASON_UNKNOWN) {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 19
    },
    {
        "index": 102919,
        "code": "void DefaultTabHandler::CreateHistoricalTab(TabContentsWrapper* contents) {\n  delegate_->AsBrowser()->CreateHistoricalTab(contents);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2840",
        "length": 31
    },
    {
        "index": 179884,
        "code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n \t\tfclose(pathfile);\n \t}\n \n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n \tif (ret < 0)\n \t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n \tINFO(\"lxc.init.static bound into container at %s\", path);\n}\n",
        "line": "\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n",
        "label": 1,
        "cwe": "CWE-59",
        "cve": "CVE-2015-1335",
        "length": 324
    },
    {
        "index": 61372,
        "code": "static int64_t add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\n                               int size, int distance, int flags)\n{\n    AVIndexEntry *entries, *ie;\n    int64_t index = -1;\n    const size_t min_size_needed = (st->nb_index_entries + 1) * sizeof(AVIndexEntry);\n\n    const size_t requested_size =\n        min_size_needed > st->index_entries_allocated_size ?\n        FFMAX(min_size_needed, 2 * st->index_entries_allocated_size) :\n        min_size_needed;\n\n    if((unsigned)st->nb_index_entries + 1 >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    entries = av_fast_realloc(st->index_entries,\n                              &st->index_entries_allocated_size,\n                              requested_size);\n    if(!entries)\n        return -1;\n\n    st->index_entries= entries;\n\n    index= st->nb_index_entries++;\n    ie= &entries[index];\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n    return index;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-834",
        "cve": "CVE-2017-14222",
        "length": 249
    },
    {
        "index": 102000,
        "code": "  ~PrintWebViewHelperTestBase() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3897",
        "length": 10
    },
    {
        "index": 32170,
        "code": "static void napi_gro_flush(struct napi_struct *napi)\n{\n\tstruct sk_buff *skb, *next;\n\n\tfor (skb = napi->gro_list; skb; skb = next) {\n\t\tnext = skb->next;\n\t\tskb->next = NULL;\n\t\tnapi_gro_complete(skb);\n\t}\n\n\tnapi->gro_count = 0;\n\tnapi->gro_list = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2017",
        "length": 86
    },
    {
        "index": 48550,
        "code": "static struct ion_handle *ion_handle_create(struct ion_client *client,\n\t\t\t\t     struct ion_buffer *buffer)\n{\n\tstruct ion_handle *handle;\n\n\thandle = kzalloc(sizeof(struct ion_handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\tkref_init(&handle->ref);\n\tRB_CLEAR_NODE(&handle->node);\n\thandle->client = client;\n\tion_buffer_get(buffer);\n\tion_buffer_add_to_handle(buffer);\n\thandle->buffer = buffer;\n\n\treturn handle;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9120",
        "length": 99
    },
    {
        "index": 6894,
        "code": "smp_fetch_body_size(const struct arg *args, struct sample *smp, const char *kw, void *private)\n{\n\tstruct http_msg *msg;\n\n\tCHECK_HTTP_MESSAGE_FIRST();\n\n\tif ((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ)\n\t\tmsg = &smp->strm->txn->req;\n\telse\n\t\tmsg = &smp->strm->txn->rsp;\n\n\tsmp->data.type = SMP_T_SINT;\n\tsmp->data.u.sint = msg->body_len;\n\n\tsmp->flags = SMP_F_VOL_TEST;\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-11469",
        "length": 125
    },
    {
        "index": 57305,
        "code": "static int clean_non_persistent_class(zval *zv) /* {{{ */\n{\n\tzend_class_entry *ce = Z_PTR_P(zv);\n\treturn (ce->type == ZEND_INTERNAL_CLASS) ? ZEND_HASH_APPLY_STOP : ZEND_HASH_APPLY_REMOVE;\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-134",
        "cve": "CVE-2015-8617",
        "length": 57
    },
    {
        "index": 123202,
        "code": "bool RenderWidgetHostViewAura::IsShowing() {\n  return window_->IsVisible();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 20
    },
    {
        "index": 71533,
        "code": "ModuleExport size_t RegisterEXRImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"EXR\");\n#if defined(MAGICKCORE_OPENEXR_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadEXRImage;\n  entry->encoder=(EncodeImageHandler *) WriteEXRImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsEXR;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"High Dynamic-range (HDR)\");\n  entry->blob_support=MagickFalse;\n  entry->module=ConstantString(\"EXR\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10066",
        "length": 154
    },
    {
        "index": 85546,
        "code": "static void hns_gmac_get_strings(u32 stringset, u8 *data)\n{\n\tchar *buff = (char *)data;\n\tu32 i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(g_gmac_stats_string); i++) {\n\t\tsnprintf(buff, ETH_GSTRING_LEN, \"%s\",\n\t\t\t g_gmac_stats_string[i].desc);\n\t\tbuff = buff + ETH_GSTRING_LEN;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18222",
        "length": 100
    },
    {
        "index": 83391,
        "code": "CmpHandle(LPVOID item, LPVOID hnd)\n{\n    return item == hnd;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-9336",
        "length": 22
    },
    {
        "index": 67919,
        "code": " static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n\t/* If this function is being called, the buffer should not have been\n\t  initialized yet. */\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\t/* The full- or line-buffered mode is being employed. */\n\t\tif (!buf) {\n\t\t\t/* The caller has not specified a buffer to employ, so allocate\n\t\t\t  one. */\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\t/* The buffer allocation has failed.  Resort to unbuffered\n\t\t\t\t  operation. */\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t/* The caller has specified a buffer to employ. */\n\t\t\t/* The buffer must be large enough to accommodate maximum\n\t\t\t  putback. */\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(jas_uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\t/* The unbuffered mode is being employed. */\n\t\t/* A buffer should not have been supplied by the caller. */\n\t\tassert(!buf);\n\t\t/* Use a trivial one-character buffer. */\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-6850",
        "length": 421
    },
    {
        "index": 33064,
        "code": "static int sctp_setsockopt_rtoinfo(struct sock *sk, char __user *optval, unsigned int optlen)\n{\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&rtoinfo, optval, optlen))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\t/* Set the values to the specific association */\n\tif (!asoc && rtoinfo.srto_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (rtoinfo.srto_initial != 0)\n\t\t\tasoc->rto_initial =\n\t\t\t\tmsecs_to_jiffies(rtoinfo.srto_initial);\n\t\tif (rtoinfo.srto_max != 0)\n\t\t\tasoc->rto_max = msecs_to_jiffies(rtoinfo.srto_max);\n\t\tif (rtoinfo.srto_min != 0)\n\t\t\tasoc->rto_min = msecs_to_jiffies(rtoinfo.srto_min);\n\t} else {\n\t\t/* If there is no association or the association-id = 0\n\t\t * set the values to the endpoint.\n\t\t */\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (rtoinfo.srto_initial != 0)\n\t\t\tsp->rtoinfo.srto_initial = rtoinfo.srto_initial;\n\t\tif (rtoinfo.srto_max != 0)\n\t\t\tsp->rtoinfo.srto_max = rtoinfo.srto_max;\n\t\tif (rtoinfo.srto_min != 0)\n\t\t\tsp->rtoinfo.srto_min = rtoinfo.srto_min;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1828",
        "length": 404
    },
    {
        "index": 29214,
        "code": "static void nfs4_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)\n{\n\tstruct nfs_server *server = NFS_SERVER(data->header->inode);\n\n\tif (!nfs4_write_need_cache_consistency_data(data)) {\n\t\tdata->args.bitmask = NULL;\n\t\tdata->res.fattr = NULL;\n\t} else\n\t\tdata->args.bitmask = server->cache_consistency_bitmask;\n\n\tif (!data->write_done_cb)\n\t\tdata->write_done_cb = nfs4_write_done_cb;\n\tdata->res.server = server;\n\tdata->timestamp   = jiffies;\n\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4591",
        "length": 166
    },
    {
        "index": 66132,
        "code": "int inet_rtx_syn_ack(const struct sock *parent, struct request_sock *req)\n{\n\tint err = req->rsk_ops->rtx_syn_ack(parent, req);\n\n\tif (!err)\n\t\treq->num_retrans++;\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-8890",
        "length": 52
    },
    {
        "index": 117870,
        "code": "static v8::Handle<v8::Value> strawberryAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.strawberry._get\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    return v8::Integer::New(imp->blueberry());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3055",
        "length": 80
    },
    {
        "index": 179747,
        "code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tswitch (cmd) {\n \tcase FBIOGET_VBLANK: {\n \t\tstruct fb_vblank vblank;\n \n \t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n \t\t\tFB_VBLANK_HAVE_VSYNC;\n \t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2015-7884",
        "length": 181
    },
    {
        "index": 179625,
        "code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n \tq->pi_state = NULL;\n \n \tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n }\n",
        "line": "\tdrop_futex_key_refs(&q->key);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0205",
        "length": 87
    },
    {
        "index": 79077,
        "code": "static inline bool match_option(const char *arg, int arglen, const char *opt)\n{\n\tint len = strlen(opt);\n\n\treturn len == arglen && !strncmp(arg, opt, len);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-15572",
        "length": 42
    },
    {
        "index": 184182,
        "code": "void PrintWebViewHelper::UpdatePrintableSizeInPrintParameters(\n    WebFrame* frame,\n    WebNode* node,\n    ViewMsg_Print_Params* params) {\n  double content_width_in_points;\n  double content_height_in_points;\n  double margin_top_in_points;\n  double margin_right_in_points;\n  double margin_bottom_in_points;\n  double margin_left_in_points;\n  PrepareFrameAndViewForPrint prepare(*params, frame, node, frame->view());\n  PrintWebViewHelper::GetPageSizeAndMarginsInPoints(frame, 0, *params,\n      &content_width_in_points, &content_height_in_points,\n      &margin_top_in_points, &margin_right_in_points,\n      &margin_bottom_in_points, &margin_left_in_points);\n#if defined(OS_MACOSX)\n  int dpi = printing::kPointsPerInch;\n#else\n  int dpi = static_cast<int>(params->dpi);\n#endif  // defined(OS_MACOSX)\n  params->printable_size = gfx::Size(\n      static_cast<int>(ConvertUnitDouble(content_width_in_points,\n          printing::kPointsPerInch, dpi)),\n       static_cast<int>(ConvertUnitDouble(content_height_in_points,\n           printing::kPointsPerInch, dpi)));\n \n   params->page_size = gfx::Size(\n      static_cast<int>(ConvertUnitDouble(content_width_in_points +\n          margin_left_in_points + margin_right_in_points,\n          printing::kPointsPerInch, dpi)),\n      static_cast<int>(ConvertUnitDouble(content_height_in_points +\n          margin_top_in_points + margin_bottom_in_points,\n          printing::kPointsPerInch, dpi)));\n \n   params->margin_top = static_cast<int>(ConvertUnitDouble(\n       margin_top_in_points, printing::kPointsPerInch, dpi));\n  params->margin_left = static_cast<int>(ConvertUnitDouble(\n      margin_left_in_points, printing::kPointsPerInch, dpi));\n}\n",
        "line": "      static_cast<int>(ConvertUnitDouble(content_width_in_points +\n          margin_left_in_points + margin_right_in_points,\n          printing::kPointsPerInch, dpi)),\n      static_cast<int>(ConvertUnitDouble(content_height_in_points +\n          margin_top_in_points + margin_bottom_in_points,\n          printing::kPointsPerInch, dpi)));\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 397
    },
    {
        "index": 144406,
        "code": "void ExpandableContainerView::DetailsView::AnimateToState(double state) {\n  state_ = state;\n  PreferredSizeChanged();\n  SchedulePaint();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2016-1640",
        "length": 33
    },
    {
        "index": 77449,
        "code": "make_echo_reply(const struct ofp_header *rq)\n{\n    struct ofpbuf rq_buf = ofpbuf_const_initializer(rq, ntohs(rq->length));\n    ofpraw_pull_assert(&rq_buf);\n\n    struct ofpbuf *reply = ofpraw_alloc_reply(OFPRAW_OFPT_ECHO_REPLY,\n                                              rq, rq_buf.size);\n    ofpbuf_put(reply, rq_buf.data, rq_buf.size);\n    return reply;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2018-17204",
        "length": 94
    },
    {
        "index": 48384,
        "code": "tsize_t t2p_write_pdf_stream_start(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"stream\\n\", 7);\n\n\treturn(written);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2016-9537",
        "length": 50
    },
    {
        "index": 101938,
        "code": "int MockPrinter::GetWidth(unsigned int page) const {\n  if (printer_status_ != PRINTER_READY || page >= pages_.size())\n    return -1;\n  return pages_[page]->width();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3897",
        "length": 43
    },
    {
        "index": 152626,
        "code": "void HTMLFormControlElement::associateWith(HTMLFormElement* form) {\n  associateByParser(form);\n};\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-1021",
        "cve": "CVE-2017-5016",
        "length": 23
    },
    {
        "index": 140419,
        "code": "PermissionUtil::ScopedRevocationReporter::ScopedRevocationReporter(\n    Profile* profile,\n    const ContentSettingsPattern& primary_pattern,\n    const ContentSettingsPattern& secondary_pattern,\n    ContentSettingsType content_type,\n    PermissionSourceUI source_ui)\n    : ScopedRevocationReporter(\n          profile,\n          GURL(primary_pattern.ToString()),\n          GURL((secondary_pattern == ContentSettingsPattern::Wildcard())\n                   ? primary_pattern.ToString()\n                   : secondary_pattern.ToString()),\n          content_type,\n          source_ui) {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1223",
        "length": 100
    },
    {
        "index": 10193,
        "code": "  Ins_UTP( INS_ARG )\n  {\n    FT_UShort  point;\n    FT_Byte    mask;\n\n\n    point = (FT_UShort)args[0];\n\n    if ( BOUNDS( point, CUR.zp0.n_points ) )\n    {\n      if ( CUR.pedantic_hinting )\n        CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    mask = 0xFF;\n\n    if ( CUR.GS.freeVector.x != 0 )\n      mask &= ~FT_CURVE_TAG_TOUCH_X;\n\n    if ( CUR.GS.freeVector.y != 0 )\n      mask &= ~FT_CURVE_TAG_TOUCH_Y;\n\n    CUR.zp0.tags[point] &= mask;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2010-2520",
        "length": 149
    },
    {
        "index": 171293,
        "code": "struct svcinfo *find_svc(const uint16_t *s16, size_t len)\n{\n struct svcinfo *si;\n\n for (si = svclist; si; si = si->next) {\n if ((len == si->len) &&\n !memcmp(s16, si->name, len * sizeof(uint16_t))) {\n return si;\n }\n }\n return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-3900",
        "length": 77
    },
    {
        "index": 119252,
        "code": "unsigned HTMLFormElement::length() const\n{\n    unsigned len = 0;\n    for (unsigned i = 0; i < m_associatedElements.size(); ++i)\n        if (m_associatedElements[i]->isEnumeratable())\n            ++len;\n    return len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2927",
        "length": 60
    },
    {
        "index": 78581,
        "code": "pgp_delete_file(sc_card_t *card, const sc_path_t *path)\n{\n\tstruct pgp_priv_data *priv = DRVDATA(card);\n\tpgp_blob_t *blob;\n\tsc_file_t *file;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\t/* sc_pkcs15init_delete_by_path() sets the path type to SC_PATH_TYPE_FILE_ID */\n\tr = pgp_select_file(card, path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Cannot select file.\");\n\n\t/* save \"current\" blob */\n\tblob = priv->current;\n\n\t/* don't try to delete MF */\n\tif (blob == priv->mf)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tif (card->type != SC_CARD_TYPE_OPENPGP_GNUK &&\n\t\t(file->id == DO_SIGN_SYM || file->id == DO_ENCR_SYM || file->id == DO_AUTH_SYM)) {\n\t\t/* These tags are just symbolic. We don't really delete them. */\n\t\tr = SC_SUCCESS;\n\t}\n\telse if (card->type == SC_CARD_TYPE_OPENPGP_GNUK && file->id == DO_SIGN_SYM) {\n\t\tr = gnuk_delete_key(card, 1);\n\t}\n\telse if (card->type == SC_CARD_TYPE_OPENPGP_GNUK && file->id == DO_ENCR_SYM) {\n\t\tr = gnuk_delete_key(card, 2);\n\t}\n\telse if (card->type == SC_CARD_TYPE_OPENPGP_GNUK && file->id == DO_AUTH_SYM) {\n\t\tr = gnuk_delete_key(card, 3);\n\t}\n\telse {\n\t\t/* call pgp_put_data() with zero-sized NULL-buffer to zap the DO contents */\n\t\tr = pgp_put_data(card, file->id, NULL, 0);\n\t}\n\n\t/* set \"current\" blob to parent */\n\tpriv->current = blob->parent;\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 410
    },
    {
        "index": 38293,
        "code": "void __init anon_vma_init(void)\n{\n\tanon_vma_cachep = kmem_cache_create(\"anon_vma\", sizeof(struct anon_vma),\n\t\t\t0, SLAB_DESTROY_BY_RCU|SLAB_PANIC, anon_vma_ctor);\n\tanon_vma_chain_cachep = KMEM_CACHE(anon_vma_chain, SLAB_PANIC);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3122",
        "length": 81
    },
    {
        "index": 71842,
        "code": "static void lite_font_init( wmfAPI* API, wmfAPI_Options* options)\n{\n  wmfFontData\n    *font_data;\n\n  (void) options;\n  API->fonts = 0;\n\n  /* Allocate wmfFontData data structure */\n  API->font_data = wmf_malloc(API,sizeof(wmfFontData));\n  if (ERR (API))\n    return;\n\n  font_data = (wmfFontData*)API->font_data;\n\n  /* Assign function to map font (type wmfMap) */\n  font_data->map = lite_font_map;\n\n  /* Assign function to return string width in points (type wmfStringWidth) */\n  font_data->stringwidth = lite_font_stringwidth;\n\n  /* Assign user data, not used by libwmflite (type void*) */\n  font_data->user_data = wmf_malloc(API,sizeof(wmf_magick_font_t));\n  if (ERR(API))\n    return;\n  ((wmf_magick_font_t*)font_data->user_data)->ps_name = 0;\n  ((wmf_magick_font_t*)font_data->user_data)->pointsize = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10066",
        "length": 240
    },
    {
        "index": 130808,
        "code": "static void limitedWithInvalidAndMissingDefaultAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    String resultValue = imp->fastGetAttribute(HTMLNames::limitedwithinvalidandmissingdefaultattributeAttr);\n    if (resultValue.isEmpty()) {\n        resultValue = \"left\";\n    } else if (equalIgnoringCase(resultValue, \"left\")) {\n        resultValue = \"left\";\n    } else if (equalIgnoringCase(resultValue, \"right\")) {\n        resultValue = \"right\";\n    } else {\n        resultValue = \"left\";\n    }\n    v8SetReturnValueString(info, resultValue, info.GetIsolate());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 156
    },
    {
        "index": 151434,
        "code": "String FrameFetchContext::GetUserAgent() const {\n  if (IsDetached())\n    return frozen_state_->user_agent;\n  return GetFrame()->Loader().UserAgent();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 38
    },
    {
        "index": 96830,
        "code": "static int fuse_request_send_notify_reply(struct fuse_conn *fc,\n\t\t\t\t\t  struct fuse_req *req, u64 unique)\n{\n\tint err = -ENODEV;\n\tstruct fuse_iqueue *fiq = &fc->iq;\n\n\t__clear_bit(FR_ISREPLY, &req->flags);\n\treq->in.h.unique = unique;\n\tspin_lock(&fiq->waitq.lock);\n\tif (fiq->connected) {\n\t\tqueue_request(fiq, req);\n\t\terr = 0;\n\t}\n\tspin_unlock(&fiq->waitq.lock);\n\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "length": 118
    },
    {
        "index": 85483,
        "code": "void sas_porte_timer_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-18232",
        "length": 57
    },
    {
        "index": 59661,
        "code": "static int csnmp_config_add_data_blacklist_match_inverted(data_definition_t *dd,\n                                                          oconfig_item_t *ci) {\n  if ((ci->values_num != 1) || (ci->values[0].type != OCONFIG_TYPE_BOOLEAN)) {\n    WARNING(\"snmp plugin: `InvertMatch' needs exactly one boolean argument.\");\n    return (-1);\n  }\n\n  dd->invert_match = ci->values[0].value.boolean ? 1 : 0;\n\n  return (0);\n} /* int csnmp_config_add_data_blacklist_match_inverted */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-16820",
        "length": 122
    },
    {
        "index": 79862,
        "code": "static void update_ovl_inode_times(struct dentry *dentry, struct inode *inode,\n\t\t\t       bool rcu)\n{\n\tstruct dentry *upperdentry;\n\n\t/*\n\t * Nothing to do if in rcu or if non-overlayfs\n\t */\n\tif (rcu || likely(!(dentry->d_flags & DCACHE_OP_REAL)))\n\t\treturn;\n\n\tupperdentry = d_real(dentry, NULL, 0, D_REAL_UPPER);\n\n\t/*\n\t * If file is on lower then we can't update atime, so no worries about\n\t * stale mtime/ctime.\n\t */\n\tif (upperdentry) {\n\t\tstruct inode *realinode = d_inode(upperdentry);\n\n\t\tif ((!timespec64_equal(&inode->i_mtime, &realinode->i_mtime) ||\n\t\t     !timespec64_equal(&inode->i_ctime, &realinode->i_ctime))) {\n\t\t\tinode->i_mtime = realinode->i_mtime;\n\t\t\tinode->i_ctime = realinode->i_ctime;\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2018-13405",
        "length": 223
    },
    {
        "index": 130049,
        "code": "base::Time GetReferenceDateForExpiryChecks(PrefService* local_state) {\n  const int64 date_value = local_state->GetInt64(prefs::kVariationsSeedDate);\n  const base::Time seed_date = base::Time::FromInternalValue(date_value);\n  const base::Time build_time = base::GetBuildTime();\n  base::Time reference_date = seed_date;\n  if (seed_date.is_null() || seed_date < build_time)\n    reference_date = build_time;\n  return reference_date;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 110
    },
    {
        "index": 88806,
        "code": "static void send_message(struct ifsock *ifs, char *type, struct sockaddr *sa)\n{\n\tint s;\n\tsize_t i, len, note = 0;\n\tssize_t num;\n\tchar host[NI_MAXHOST];\n\tchar buf[MAX_PKT_SIZE];\n\tstruct sockaddr dest;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sa;\n\n\tgethostname(hostname, sizeof(hostname));\n\ts = getnameinfo((struct sockaddr *)&ifs->addr, sizeof(struct sockaddr_in), host, sizeof(host), NULL, 0, NI_NUMERICHOST);\n\tif (s) {\n\t\tlogit(LOG_WARNING, \"Failed getnameinfo(): %s\", gai_strerror(s));\n\t\treturn;\n\t}\n\n\tif (ifs->addr.sin_addr.s_addr == htonl(INADDR_ANY))\n\t\treturn;\n\tif (ifs->out == -1)\n\t\treturn;\n\n\tif (!strcmp(type, SSDP_ST_ALL))\n\t\ttype = NULL;\n\n\tmemset(buf, 0, sizeof(buf));\n\tif (sin)\n\t\tcompose_response(type, host, buf, sizeof(buf));\n\telse\n\t\tcompose_notify(type, host, buf, sizeof(buf));\n\n\tif (!sin) {\n\t\tnote = 1;\n\t\tcompose_addr((struct sockaddr_in *)&dest, MC_SSDP_GROUP, MC_SSDP_PORT);\n\t\tsin = (struct sockaddr_in *)&dest;\n\t}\n\n\tlogit(LOG_DEBUG, \"Sending %s from %s ...\", !note ? \"reply\" : \"notify\", host);\n\tnum = sendto(ifs->out, buf, strlen(buf), 0, sin, sizeof(struct sockaddr_in));\n\tif (num < 0)\n\t\tlogit(LOG_WARNING, \"Failed sending SSDP %s, type: %s: %s\", !note ? \"reply\" : \"notify\", type, strerror(errno));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-14323",
        "length": 368
    },
    {
        "index": 92173,
        "code": "static u16 prot_field_size(enum ib_signature_type type)\n{\n\tswitch (type) {\n\tcase IB_SIG_TYPE_T10_DIF:\n\t\treturn MLX5_DIF_SIZE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-20855",
        "length": 47
    },
    {
        "index": 85194,
        "code": "static int get_data_block_dio(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn __get_data_block(inode, iblock, bh_result, create,\n\t\t\t\t\t\tF2FS_GET_BLOCK_DIO, NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-18257",
        "length": 57
    },
    {
        "index": 84173,
        "code": "ptaGetCount(PTA  *pta)\n{\n    PROCNAME(\"ptaGetCount\");\n\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 0);\n\n    return pta->n;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-7186",
        "length": 48
    },
    {
        "index": 145160,
        "code": "  explicit GpuSandboxedProcessLauncherDelegate(\n      const base::CommandLine& cmd_line)\n#if defined(OS_WIN)\n      : cmd_line_(cmd_line),\n        enable_appcontainer_(true)\n#endif\n  {\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1620",
        "length": 47
    },
    {
        "index": 48388,
        "code": "tsize_t t2p_write_pdf_transfer_dict(T2P* t2p, TIFF* output, uint16 i){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\t(void)i; /* XXX */\n\n\twritten += t2pWriteFile(output, (tdata_t) \"/FunctionType 0 \\n\", 17);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Domain [0.0 1.0] \\n\", 19);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Range [0.0 1.0] \\n\", 18);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"/Size [%u] \\n\", (1<<t2p->tiff_bitspersample));\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"/BitsPerSample 16 \\n\", 19);\n\twritten += t2p_write_pdf_stream_dict(((tsize_t)1)<<(t2p->tiff_bitspersample+1), 0, output);\n\n\treturn(written);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2016-9537",
        "length": 271
    },
    {
        "index": 175144,
        "code": "static wifi_error wifi_stop_rssi_monitoring(wifi_request_id id, wifi_interface_handle iface)\n{\n    ALOGD(\"Stopping RSSI monitor\");\n\n if(id == -1) {\n        wifi_rssi_event_handler handler;\n        s8 max_rssi = 0, min_rssi = 0;\n        wifi_handle handle = getWifiHandle(iface);\n        memset(&handler, 0, sizeof(handler));\n SetRSSIMonitorCommand *cmd = new SetRSSIMonitorCommand(id, iface,\n                                                    max_rssi, min_rssi, handler);\n        cmd->cancel();\n        cmd->releaseRef();\n return WIFI_SUCCESS;\n }\n return wifi_cancel_cmd(id, iface);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0809",
        "length": 139
    },
    {
        "index": 161288,
        "code": "Response InputHandler::SetIgnoreInputEvents(bool ignore) {\n  ignore_input_events_ = ignore;\n  if (host_)\n    host_->GetRenderWidgetHost()->SetIgnoreInputEvents(ignore);\n  return Response::OK();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6111",
        "length": 47
    },
    {
        "index": 138892,
        "code": "void WallpaperManager::OnDeviceWallpaperDownloaded(const AccountId& account_id,\n                                                   const std::string& hash,\n                                                   bool success,\n                                                   const GURL& url) {\n  if (!success) {\n    LOG(ERROR) << \"Failed to download the device wallpaper. Fallback to \"\n                  \"default wallpaper.\";\n    SetDefaultWallpaperDelayed(account_id);\n    return;\n  }\n\n  base::PostTaskWithTraitsAndReplyWithResult(\n      FROM_HERE, {base::MayBlock()},\n      base::Bind(&CheckDeviceWallpaperMatchHash, GetDeviceWallpaperFilePath(),\n                 hash),\n      base::Bind(&WallpaperManager::OnCheckDeviceWallpaperMatchHash,\n                 weak_factory_.GetWeakPtr(), account_id, url.spec(), hash));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-1285",
        "length": 156
    },
    {
        "index": 81640,
        "code": "construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat)\n{\n\tif ((filestat != NULL) && (buf != NULL)) {\n\t\tmg_snprintf(NULL,\n\t\t            NULL, /* All calls to construct_etag use 64 byte buffer */\n\t\t            buf,\n\t\t            buf_len,\n\t\t            \"\\\"%lx.%\" INT64_FMT \"\\\"\",\n\t\t            (unsigned long)filestat->last_modified,\n\t\t            filestat->size);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-12684",
        "length": 98
    },
    {
        "index": 14491,
        "code": "static inline void vring_used_flags_set_bit(VirtQueue *vq, int mask)\n{\n    hwaddr pa;\n    pa = vq->vring.used + offsetof(VRingUsed, flags);\n    stw_phys(&address_space_memory,\n             pa, lduw_phys(&address_space_memory, pa) | mask);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0182",
        "length": 70
    },
    {
        "index": 129185,
        "code": "  Renderbuffer* renderbuffer() const {\n    return renderbuffer_.get();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3173",
        "length": 19
    },
    {
        "index": 119216,
        "code": "void XMLHttpRequest::suspend(ReasonForSuspension)\n{\n    m_progressEventThrottle.suspend();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2925",
        "length": 22
    },
    {
        "index": 135351,
        "code": "void Document::resumeScheduledTasks()\n{\n    ExecutionContext::resumeScheduledTasks();\n    m_taskRunner->resume();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6768",
        "length": 24
    },
    {
        "index": 176943,
        "code": "static inline int32_t getMotionEventActionPointerIndex(int32_t action) {\n return (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK)\n >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-2496",
        "length": 40
    },
    {
        "index": 123474,
        "code": "static IntSize sizeFor(HTMLVideoElement* video)\n{\n    if (MediaPlayer* player = video->player())\n        return player->naturalSize();\n    return IntSize();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0890",
        "length": 38
    },
    {
        "index": 18616,
        "code": "SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint len, err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getpeername(sock);\n\t\tif (err) {\n\t\t\tfput_light(sock->file, fput_needed);\n\t\t\treturn err;\n\t\t}\n\n\t\terr =\n\t\t    sock->ops->getname(sock, (struct sockaddr *)&address, &len,\n\t\t\t\t       1);\n\t\tif (!err)\n\t\t\terr = move_addr_to_user(&address, len, usockaddr,\n\t\t\t\t\t\tusockaddr_len);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-4467",
        "length": 179
    },
    {
        "index": 46951,
        "code": "static int chksum_finup(struct shash_desc *desc, const u8 *data,\n\t\t\tunsigned int len, u8 *out)\n{\n\tstruct chksum_desc_ctx *ctx = shash_desc_ctx(desc);\n\n\treturn __chksum_finup(&ctx->crc, data, len, out);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 63
    },
    {
        "index": 102511,
        "code": "bool FileUtilProxy::GetFileInfo(\n    scoped_refptr<MessageLoopProxy> message_loop_proxy,\n    const FilePath& file_path,\n    GetFileInfoCallback* callback) {\n  return Start(FROM_HERE, message_loop_proxy, new RelayGetFileInfo(\n               file_path, callback));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2880",
        "length": 58
    },
    {
        "index": 177291,
        "code": "void ACodec::processDeferredMessages() {\n List<sp<AMessage> > queue = mDeferredQueue;\n    mDeferredQueue.clear();\n\n List<sp<AMessage> >::iterator it = queue.begin();\n while (it != queue.end()) {\n        onMessageReceived(*it++);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 59
    },
    {
        "index": 60825,
        "code": "logger_buffer_closing_signal_cb (const void *pointer, void *data,\n                                 const char *signal,\n                                 const char *type_data, void *signal_data)\n{\n    /* make C compiler happy */\n    (void) pointer;\n    (void) data;\n    (void) signal;\n    (void) type_data;\n\n    logger_stop (logger_buffer_search_buffer (signal_data), 1);\n\n    return WEECHAT_RC_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-14727",
        "length": 92
    },
    {
        "index": 26920,
        "code": "static int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2011-2494",
        "length": 314
    },
    {
        "index": 103126,
        "code": "bool Browser::IsPopup(const TabContents* source) const {\n  return !!(type() & TYPE_POPUP);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2840",
        "length": 26
    },
    {
        "index": 51095,
        "code": "static int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-6187",
        "length": 40
    },
    {
        "index": 83953,
        "code": "static int sas_ex_manuf_info(struct domain_device *dev)\n{\n\tu8 *mi_req;\n\tu8 *mi_resp;\n\tint res;\n\n\tmi_req = alloc_smp_req(MI_REQ_SIZE);\n\tif (!mi_req)\n\t\treturn -ENOMEM;\n\n\tmi_resp = alloc_smp_resp(MI_RESP_SIZE);\n\tif (!mi_resp) {\n\t\tkfree(mi_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tmi_req[1] = SMP_REPORT_MANUF_INFO;\n\n\tres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp,MI_RESP_SIZE);\n\tif (res) {\n\t\tSAS_DPRINTK(\"MI: ex %016llx failed:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out;\n\t} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tSAS_DPRINTK(\"MI ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t    SAS_ADDR(dev->sas_addr), mi_resp[2]);\n\t\tgoto out;\n\t}\n\n\tex_assign_manuf_info(dev, mi_resp);\nout:\n\tkfree(mi_req);\n\tkfree(mi_resp);\n\treturn res;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-772",
        "cve": "CVE-2018-7757",
        "length": 242
    },
    {
        "index": 9302,
        "code": "static int appendenv(const char *opt, const char *new)\n{\n\tchar buf[1024];\n\tchar *old = getenv(opt);\n\n\tbuf[1023] = 0;\n\tif (old)\n\t\tsnprintf(buf, 1023, \"%s %s\", old, new);\n\telse\n\t\tsnprintf(buf, 1023, \"%s\", new);\n\n\treturn setenv(opt, buf, 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3291",
        "length": 85
    },
    {
        "index": 169390,
        "code": "void WebContentsAddedObserver::WebContentsCreated(WebContents* web_contents) {\n  DCHECK(!web_contents_);\n  web_contents_ = web_contents;\n  child_observer_.reset(new RenderViewCreatedObserver(web_contents));\n\n  if (runner_.get())\n    runner_->QuitClosure().Run();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6121",
        "length": 60
    },
    {
        "index": 90739,
        "code": "static void Np_toFixed(js_State *J)\n{\n\tjs_Object *self = js_toobject(J, 0);\n\tint width = js_tointeger(J, 1);\n\tchar buf[32];\n\tdouble x;\n\tif (self->type != JS_CNUMBER) js_typeerror(J, \"not a number\");\n\tif (width < 0) js_rangeerror(J, \"precision %d out of range\", width);\n\tif (width > 20) js_rangeerror(J, \"precision %d out of range\", width);\n\tx = self->u.number;\n\tif (isnan(x) || isinf(x) || x <= -1e21 || x >= 1e21)\n\t\tjs_pushstring(J, jsV_numbertostring(J, buf, x));\n\telse\n\t\tnumtostr(J, \"%.*f\", width, x);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-11411",
        "length": 177
    },
    {
        "index": 178613,
        "code": " SProcXFixesSelectCursorInput(ClientPtr client)\n {\n     REQUEST(xXFixesSelectCursorInputReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->window);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-12183",
        "length": 62
    },
    {
        "index": 60110,
        "code": "R_API RBinFile *r_bin_cur(RBin *bin) {\n\treturn bin? bin->cur: NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-16358",
        "length": 26
    },
    {
        "index": 44596,
        "code": "int lxc_create_tty(const char *name, struct lxc_conf *conf)\n{\n\tstruct lxc_tty_info *tty_info = &conf->tty_info;\n\tint i, ret;\n\n\t/* no tty in the configuration */\n\tif (!conf->tty)\n\t\treturn 0;\n\n\ttty_info->pty_info =\n\t\tmalloc(sizeof(*tty_info->pty_info)*conf->tty);\n\tif (!tty_info->pty_info) {\n\t\tSYSERROR(\"failed to allocate pty_info\");\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < conf->tty; i++) {\n\n\t\tstruct lxc_pty_info *pty_info = &tty_info->pty_info[i];\n\n\t\tprocess_lock();\n\t\tret = openpty(&pty_info->master, &pty_info->slave,\n\t\t\t    pty_info->name, NULL, NULL);\n\t\tprocess_unlock();\n\t\tif (ret) {\n\t\t\tSYSERROR(\"failed to create pty #%d\", i);\n\t\t\ttty_info->nbtty = i;\n\t\t\tlxc_delete_tty(tty_info);\n\t\t\treturn -1;\n\t\t}\n\n\t\tDEBUG(\"allocated pty '%s' (%d/%d)\",\n\t\t      pty_info->name, pty_info->master, pty_info->slave);\n\n\t\t/* Prevent leaking the file descriptors to the container */\n\t\tfcntl(pty_info->master, F_SETFD, FD_CLOEXEC);\n\t\tfcntl(pty_info->slave, F_SETFD, FD_CLOEXEC);\n\n\t\tpty_info->busy = 0;\n\t}\n\n\ttty_info->nbtty = conf->tty;\n\n\tINFO(\"tty's configured\");\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2015-1335",
        "length": 348
    },
    {
        "index": 161359,
        "code": "std::unique_ptr<Network::ResourceTiming> getTiming(\n    const net::LoadTimingInfo& load_timing) {\n  const base::TimeTicks kNullTicks;\n  return Network::ResourceTiming::Create()\n      .SetRequestTime((load_timing.request_start - kNullTicks).InSecondsF())\n      .SetProxyStart(\n          timeDelta(load_timing.proxy_resolve_start, load_timing.request_start))\n      .SetProxyEnd(\n          timeDelta(load_timing.proxy_resolve_end, load_timing.request_start))\n      .SetDnsStart(timeDelta(load_timing.connect_timing.dns_start,\n                             load_timing.request_start))\n      .SetDnsEnd(timeDelta(load_timing.connect_timing.dns_end,\n                           load_timing.request_start))\n      .SetConnectStart(timeDelta(load_timing.connect_timing.connect_start,\n                                 load_timing.request_start))\n      .SetConnectEnd(timeDelta(load_timing.connect_timing.connect_end,\n                               load_timing.request_start))\n      .SetSslStart(timeDelta(load_timing.connect_timing.ssl_start,\n                             load_timing.request_start))\n      .SetSslEnd(timeDelta(load_timing.connect_timing.ssl_end,\n                           load_timing.request_start))\n      .SetWorkerStart(-1)\n      .SetWorkerReady(-1)\n      .SetSendStart(\n          timeDelta(load_timing.send_start, load_timing.request_start))\n      .SetSendEnd(timeDelta(load_timing.send_end, load_timing.request_start))\n      .SetPushStart(\n          timeDelta(load_timing.push_start, load_timing.request_start, 0))\n      .SetPushEnd(timeDelta(load_timing.push_end, load_timing.request_start, 0))\n      .SetReceiveHeadersEnd(\n          timeDelta(load_timing.receive_headers_end, load_timing.request_start))\n      .Build();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6111",
        "length": 349
    },
    {
        "index": 178616,
        "code": " SProcXFixesQueryVersion(ClientPtr client)\n {\n     REQUEST(xXFixesQueryVersionReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->majorVersion);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-12183",
        "length": 61
    },
    {
        "index": 147455,
        "code": "void V8TestObject::InstallFeatureName(\n    ScriptState* script_state, v8::Local<v8::Object> instance) {\n  V8PerContextData* per_context_data = script_state->PerContextData();\n  v8::Local<v8::Object> prototype = per_context_data->PrototypeForType(\n      V8TestObject::GetWrapperTypeInfo());\n  v8::Local<v8::Function> interface = per_context_data->ConstructorForType(\n      V8TestObject::GetWrapperTypeInfo());\n  ALLOW_UNUSED_LOCAL(interface);\n  InstallFeatureName(script_state->GetIsolate(), script_state->World(), instance, prototype, interface);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 137
    },
    {
        "index": 88940,
        "code": "static void GetMinimumPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  register SkipList\n    *list;\n\n  register ssize_t\n    channel;\n\n  size_t\n    color,\n    minimum;\n\n  ssize_t\n    count;\n\n  unsigned short\n    channels[ListChannels];\n\n  /*\n    Find the minimum value for each of the color.\n  */\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    count=0;\n    color=65536UL;\n    minimum=list->nodes[color].next[0];\n    do\n    {\n      color=list->nodes[color].next[0];\n      if (color < minimum)\n        minimum=color;\n      count+=list->nodes[color].count;\n    } while (count < (ssize_t) pixel_list->length);\n    channels[channel]=(unsigned short) minimum;\n  }\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-13307",
        "length": 293
    },
    {
        "index": 158222,
        "code": "void AppCacheGroup::HostDestructionImminent(AppCacheHost* host) {\n  queued_updates_.erase(host);\n  if (queued_updates_.empty() && !restart_update_task_.IsCancelled())\n    restart_update_task_.Cancel();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17462",
        "length": 50
    },
    {
        "index": 18312,
        "code": "test_print (void) {\n    GString *result = g_string_new(\"\");\n\n    /* a simple message can be returned as a result */\n    parse_cmd_line(\"print A simple test\", result);\n    g_assert_cmpstr(\"A simple test\", ==, result->str);\n\n    /* arguments to print should be expanded */\n    parse_cmd_line(\"print A simple @(echo expansion)@ test\", result);\n    g_assert_cmpstr(\"A simple expansion test\", ==, result->str);\n\n    g_string_free(result, TRUE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2010-0011",
        "length": 109
    },
    {
        "index": 184044,
        "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert5(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     e* (toe(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->convert5();\n    return JSValue::encode(jsUndefined());\n}\n",
        "line": "        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2350",
        "length": 197
    },
    {
        "index": 63472,
        "code": "int64_t yr_object_get_integer(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* integer_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    integer_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    integer_obj = object;\n\n  va_end(args);\n\n  if (integer_obj == NULL)\n    return UNDEFINED;\n\n  assertf(integer_obj->type == OBJECT_TYPE_INTEGER,\n          \"type of \\\"%s\\\" is not integer\\n\", field);\n\n  return integer_obj->value.i;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-11328",
        "length": 131
    },
    {
        "index": 168352,
        "code": "void BrowserView::SetIntentPickerViewVisibility(bool visible) {\n  LocationBarView* location_bar = GetLocationBarView();\n\n  if (!location_bar->intent_picker_view())\n    return;\n\n  if (location_bar->intent_picker_view()->visible() != visible) {\n    location_bar->intent_picker_view()->SetVisible(visible);\n    location_bar->Layout();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-16080",
        "length": 77
    },
    {
        "index": 100355,
        "code": "  ~NetworkLibraryImpl() {\n    network_manager_observers_.Clear();\n    if (network_manager_monitor_)\n      DisconnectPropertyChangeMonitor(network_manager_monitor_);\n    data_plan_observers_.Clear();\n    if (data_plan_monitor_)\n      DisconnectDataPlanUpdateMonitor(data_plan_monitor_);\n    STLDeleteValues(&network_observers_);\n    ClearNetworks();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 73
    },
    {
        "index": 140312,
        "code": "void Editor::copy() {\n  if (tryDHTMLCopy())\n    return;  // DHTML did the whole operation\n  if (!canCopy())\n    return;\n\n  frame().document()->updateStyleAndLayoutIgnorePendingStylesheets();\n\n  if (enclosingTextControl(frame()\n                               .selection()\n                               .computeVisibleSelectionInDOMTreeDeprecated()\n                               .start())) {\n    Pasteboard::generalPasteboard()->writePlainText(\n        frame().selectedTextForClipboard(),\n        canSmartCopyOrDelete() ? Pasteboard::CanSmartReplace\n                               : Pasteboard::CannotSmartReplace);\n  } else {\n    Document* document = frame().document();\n    if (HTMLImageElement* imageElement =\n            imageElementFromImageDocument(document))\n      writeImageNodeToPasteboard(Pasteboard::generalPasteboard(), imageElement,\n                                 document->title());\n    else\n      writeSelectionToPasteboard();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1221",
        "length": 188
    },
    {
        "index": 126484,
        "code": "bool TabStripGtk::CompleteDrop(const guchar* data, bool is_plain_text) {\n  if (!drop_info_.get())\n    return false;\n\n  const int drop_index = drop_info_->drop_index;\n  const bool drop_before = drop_info_->drop_before;\n\n  drop_info_.reset();\n\n  hover_tab_selector_.CancelTabTransition();\n\n  GURL url;\n  if (is_plain_text) {\n    AutocompleteMatch match;\n    AutocompleteClassifierFactory::GetForProfile(model_->profile())->Classify(\n        UTF8ToUTF16(reinterpret_cast<const char*>(data)), string16(),\n        false, false, &match, NULL);\n    url = match.destination_url;\n  } else {\n    std::string url_string(reinterpret_cast<const char*>(data));\n    url = GURL(url_string.substr(0, url_string.find_first_of('\\n')));\n  }\n  if (!url.is_valid())\n    return false;\n\n  chrome::NavigateParams params(window()->browser(), url,\n                                content::PAGE_TRANSITION_LINK);\n  params.tabstrip_index = drop_index;\n\n  if (drop_before) {\n    params.disposition = NEW_FOREGROUND_TAB;\n  } else {\n    params.disposition = CURRENT_TAB;\n    params.source_contents = model_->GetTabContentsAt(drop_index);\n  }\n\n  chrome::Navigate(&params);\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 272
    },
    {
        "index": 96242,
        "code": "fm_mgr_fe_cfg_query\n(\n\tIN      p_fm_config_conx_hdlt       hdl,\n\tIN      fm_mgr_action_t             action,\n\t\tOUT fe_config_t                 *info,\n\t\tOUT fm_msg_ret_code_t           *ret_code\n)\n{\n\tp_hsm_com_client_hdl_t client_hdl;\n\t\n    if ( (client_hdl = get_mgr_hdl(hdl,FM_MGR_FE)) != NULL )\n    {\n        return fm_mgr_general_query(client_hdl,action,FM_DT_FE_CFG,sizeof(fe_config_t),info,ret_code);\n    }\n\n\treturn FM_CONF_ERROR;\n\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-5232",
        "length": 122
    },
    {
        "index": 153540,
        "code": "  static TabIcon* GetTabIcon(const Tab& tab) { return tab.icon_; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-5218",
        "length": 20
    },
    {
        "index": 164935,
        "code": "ResourceDispatcherHostImpl::HandleDownloadStarted(\n    net::URLRequest* request,\n    std::unique_ptr<ResourceHandler> handler,\n    bool is_content_initiated,\n    bool must_download,\n    bool is_new_request) {\n  if (delegate()) {\n    const ResourceRequestInfoImpl* request_info(\n        ResourceRequestInfoImpl::ForRequest(request));\n    std::vector<std::unique_ptr<ResourceThrottle>> throttles;\n    delegate()->DownloadStarting(request, request_info->GetContext(),\n                                 is_content_initiated, true, is_new_request,\n                                 &throttles);\n    if (!throttles.empty()) {\n      handler.reset(new ThrottlingResourceHandler(std::move(handler), request,\n                                                  std::move(throttles)));\n    }\n  }\n  return handler;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2019-5822",
        "length": 160
    },
    {
        "index": 14281,
        "code": "MYSQLND_METHOD_PRIVATE(mysqlnd_conn_data, dtor)(MYSQLND_CONN_DATA * conn TSRMLS_DC)\n{\n\tDBG_ENTER(\"mysqlnd_conn_data::dtor\");\n\tDBG_INF_FMT(\"conn=%llu\", conn->thread_id);\n\n\tconn->m->free_contents(conn TSRMLS_CC);\n\tconn->m->free_options(conn TSRMLS_CC);\n\n\tif (conn->net) {\n\t\tmysqlnd_net_free(conn->net, conn->stats, conn->error_info TSRMLS_CC);\n\t\tconn->net = NULL;\n\t}\n\n\tif (conn->protocol) {\n\t\tmysqlnd_protocol_free(conn->protocol TSRMLS_CC);\n\t\tconn->protocol = NULL;\n\t}\n\n\tif (conn->stats) {\n\t\tmysqlnd_stats_end(conn->stats);\n\t}\n\n\tmnd_pefree(conn, conn->persistent);\n\n\tDBG_VOID_RETURN;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2015-8838",
        "length": 163
    },
    {
        "index": 116765,
        "code": "void RenderViewTest::LoadHTML(const char* html) {\n  std::string url_str = \"data:text/html;charset=utf-8,\";\n  url_str.append(html);\n  GURL url(url_str);\n\n  GetMainFrame()->loadRequest(WebURLRequest(url));\n\n  ProcessPendingMessages();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-3084",
        "length": 59
    },
    {
        "index": 76480,
        "code": "static int canon_copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t    unsigned char __user **b,\n\t\t\t\t    size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail;\n\tint ret, found = 0;\n\n\t/* N.B. avoid overrun if nr == 0 */\n\tif (!*nr)\n\t\treturn 0;\n\n\tn = min(*nr + 1, smp_load_acquire(&ldata->canon_head) - ldata->read_tail);\n\n\ttail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t/* scan wrapped without finding set bit */\n\t\teol = find_next_bit(ldata->read_flags, more, 0);\n\t\tfound = eol != more;\n\t} else\n\t\tfound = eol != size;\n\n\tn = eol - tail;\n\tif (n > N_TTY_BUF_SIZE)\n\t\tn += N_TTY_BUF_SIZE;\n\tc = n + found;\n\n\tif (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {\n\t\tc = min(*nr, c);\n\t\tn = c;\n\t}\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu tail:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, tail, more);\n\n\tret = tty_copy_to_user(tty, *b, tail, n);\n\tif (ret)\n\t\treturn -EFAULT;\n\t*b += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_store_release(&ldata->read_tail, ldata->read_tail + c);\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push();\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-18386",
        "length": 509
    },
    {
        "index": 12372,
        "code": "static int spl_array_next_no_verify(spl_array_object *intern, HashTable *aht TSRMLS_DC) /* {{{ */\n{\n\tzend_hash_move_forward_ex(aht, &intern->pos);\n\tspl_array_update_pos(intern);\n\tif (Z_TYPE_P(intern->array) == IS_OBJECT) {\n\t\treturn spl_array_skip_protected(intern, aht TSRMLS_CC);\n\t} else {\n\t\treturn zend_hash_has_more_elements_ex(aht, &intern->pos);\n\t}\n} /* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3515",
        "length": 105
    },
    {
        "index": 60125,
        "code": "static RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 binfile_id) {\n\tRBinFile *binfile = NULL;\n\tRListIter *iter = NULL;\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tif (binfile->id == binfile_id) {\n\t\t\tbreak;\n\t\t}\n\t\tbinfile = NULL;\n\t}\n\treturn binfile;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-16358",
        "length": 89
    },
    {
        "index": 143857,
        "code": "  void WriteMetricsFileAtTime(const base::FilePath& path,\n                              base::PersistentHistogramAllocator* metrics,\n                              base::Time write_time) {\n    WriteMetricsFile(path, metrics);\n    base::TouchFile(path, write_time, write_time);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-1632",
        "length": 55
    },
    {
        "index": 174996,
        "code": "CameraDeviceClient::~CameraDeviceClient() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0826",
        "length": 11
    },
    {
        "index": 175224,
        "code": "void kernel_restart(char *cmd)\n{\n\tkernel_restart_prepare(cmd);\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n if (!cmd)\n\t\tprintk(KERN_EMERG \"Restarting system.\\n\");\n else\n\t\tprintk(KERN_EMERG \"Restarting system with command '%s'.\\n\", cmd);\n\tkmsg_dump(KMSG_DUMP_RESTART);\n\tmachine_restart(cmd);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6640",
        "length": 78
    },
    {
        "index": 114223,
        "code": "gpu::CommandBuffer::State CommandBufferProxyImpl::GetState() {\n  if (last_state_.error == gpu::error::kNoError) {\n    gpu::CommandBuffer::State state;\n    if (Send(new GpuCommandBufferMsg_GetState(route_id_, &state)))\n      OnUpdateState(state);\n  }\n\n  TryUpdateState();\n  return last_state_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 79
    },
    {
        "index": 96563,
        "code": "int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )\n{\n    int ret;\n    mbedtls_ecp_point Q;\n    mbedtls_ecp_group grp;\n\n    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||\n        pub->grp.id != prv->grp.id ||\n        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||\n        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||\n        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )\n    {\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n    }\n\n    mbedtls_ecp_point_init( &Q );\n    mbedtls_ecp_group_init( &grp );\n\n    /* mbedtls_ecp_mul() needs a non-const group... */\n    mbedtls_ecp_group_copy( &grp, &prv->grp );\n\n    /* Also checks d is valid */\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &Q, &prv->d, &prv->grp.G, NULL, NULL ) );\n\n    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||\n        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||\n        mbedtls_mpi_cmp_mpi( &Q.Z, &prv->Q.Z ) )\n    {\n        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\ncleanup:\n    mbedtls_ecp_point_free( &Q );\n    mbedtls_ecp_group_free( &grp );\n\n    return( ret );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-16910",
        "length": 351
    },
    {
        "index": 136056,
        "code": "void ExtensionWebContentsObserver::InitializeRenderFrame(\n    content::RenderFrameHost* render_frame_host) {\n  DCHECK(render_frame_host);\n  DCHECK(render_frame_host->IsRenderFrameLive());\n\n  render_frame_host->Send(new ExtensionMsg_NotifyRenderViewType(\n      render_frame_host->GetRoutingID(), GetViewType(web_contents())));\n\n  const Extension* frame_extension = GetExtensionFromFrame(render_frame_host);\n  if (frame_extension) {\n    ExtensionsBrowserClient::Get()->RegisterMojoServices(render_frame_host,\n                                                         frame_extension);\n    ProcessManager::Get(browser_context_)\n        ->RegisterRenderFrameHost(web_contents(), render_frame_host,\n                                  frame_extension);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6779",
        "length": 140
    },
    {
        "index": 23573,
        "code": "static void __switch_pg(struct multipath *m, struct pgpath *pgpath)\n{\n\tm->current_pg = pgpath->pg;\n\n\t/* Must we initialise the PG first, and queue I/O till it's ready? */\n\tif (m->hw_handler_name) {\n\t\tm->pg_init_required = 1;\n\t\tm->queue_io = 1;\n\t} else {\n\t\tm->pg_init_required = 0;\n\t\tm->queue_io = 0;\n\t}\n\n\tm->pg_init_count = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4127",
        "length": 112
    },
    {
        "index": 112623,
        "code": "void Document::webkitWillEnterFullScreenForElement(Element* element)\n{\n    if (!attached() || inPageCache())\n        return;\n\n    ASSERT(element);\n\n    if (!page())\n        return;\n\n    ASSERT(page()->settings()->fullScreenEnabled());\n\n    if (m_fullScreenRenderer)\n        m_fullScreenRenderer->unwrapRenderer();\n\n    m_fullScreenElement = element;\n\n#if USE(NATIVE_FULLSCREEN_VIDEO)\n    if (element && element->isMediaElement())\n        return;\n#endif\n\n    RenderObject* renderer = m_fullScreenElement->renderer();\n    bool shouldCreatePlaceholder = renderer && renderer->isBox();\n    if (shouldCreatePlaceholder) {\n        m_savedPlaceholderFrameRect = toRenderBox(renderer)->frameRect();\n        m_savedPlaceholderRenderStyle = RenderStyle::clone(renderer->style());\n    }\n\n    if (m_fullScreenElement != documentElement())\n        RenderFullScreen::wrapRenderer(renderer, renderer ? renderer->parent() : 0, this);\n\n    m_fullScreenElement->setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);\n    \n    recalcStyle(Force);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 225
    },
    {
        "index": 109721,
        "code": "static bool isValidNameNonASCII(const UChar* characters, unsigned length)\n{\n    unsigned i = 0;\n\n    UChar32 c;\n    U16_NEXT(characters, i, length, c)\n    if (!isValidNameStart(c))\n        return false;\n\n    while (i < length) {\n        U16_NEXT(characters, i, length, c)\n        if (!isValidNamePart(c))\n            return false;\n    }\n\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5136",
        "length": 95
    },
    {
        "index": 5450,
        "code": "  static void  Ins_SHC( INS_ARG )\n  {\n    TGlyph_Zone zp;\n    Int         refp;\n    TT_F26Dot6  dx,\n                dy;\n\n    Long        contour, i;\n    Int         first_point, last_point;\n\n    contour = args[0];\n\n    if ( BOUNDS( args[0], CUR.pts.n_contours ) )\n    {\n#if 0\n      /* A workaround for the Ghostscript bug 688501.\n       *  Ported from FreeType 2\n       */\n      CUR.error = TT_Err_Invalid_Reference;\n#endif\n      return;\n    }\n\n    if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )\n      return;\n\n    if ( contour == 0 )\n      first_point = 0;\n    else\n      first_point = CUR.pts.contours[contour-1] + 1;\n\n    last_point = CUR.pts.contours[contour];\n\n    /* undocumented: SHC doesn't touch the points */\n    for ( i = first_point; i <= last_point; i++ )\n    {\n      if ( zp.cur_x != CUR.zp2.cur_x || refp != i )\n        MOVE_Zp2_Point( i, dx, dy, FALSE );\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-9739",
        "length": 273
    },
    {
        "index": 186429,
        "code": "GURL DevToolsUI::SanitizeFrontendURL(const GURL& url) {\n  return ::SanitizeFrontendURL(url, content::kChromeDevToolsScheme,\n      chrome::kChromeUIDevToolsHost, SanitizeFrontendPath(url.path()), true);\n}\n",
        "line": "  return ::SanitizeFrontendURL(url, content::kChromeDevToolsScheme,\n      chrome::kChromeUIDevToolsHost, SanitizeFrontendPath(url.path()), true);\n}\n",
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2017-5011",
        "length": 57
    },
    {
        "index": 5982,
        "code": "e1000e_intrmgr_delay_tx_causes(E1000ECore *core, uint32_t *causes)\n{\n    static const uint32_t delayable_causes = E1000_ICR_TXQ0 |\n                                             E1000_ICR_TXQ1 |\n                                             E1000_ICR_TXQE |\n                                             E1000_ICR_TXDW;\n\n    if (msix_enabled(core->owner)) {\n        return false;\n    }\n\n    /* Clean up all causes that may be delayed */\n    core->delayed_causes |= *causes & delayable_causes;\n    *causes &= ~delayable_causes;\n\n    /* If there are causes that cannot be delayed */\n    if (*causes != 0) {\n        return false;\n    }\n\n    /* All causes delayed */\n    e1000e_intrmgr_rearm_timer(&core->tidv);\n\n    if (!core->tadv.running && (core->mac[TADV] != 0)) {\n        e1000e_intrmgr_rearm_timer(&core->tadv);\n    }\n\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-9310",
        "length": 224
    },
    {
        "index": 107611,
        "code": "Eina_Bool ewk_view_setting_auto_load_images_set(Evas_Object* ewkView, Eina_Bool automatic)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    automatic = !!automatic;\n    if (priv->settings.autoLoadImages != automatic) {\n        priv->pageSettings->setLoadsImagesAutomatically(automatic);\n        priv->settings.autoLoadImages = automatic;\n    }\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 110
    },
    {
        "index": 165686,
        "code": "bool ReportingIsEnforcedByPolicy(bool* crash_reporting_enabled) {\n  std::wstring policies_path = L\"SOFTWARE\\\\Policies\\\\\";\n  AppendChromeInstallSubDirectory(InstallDetails::Get().mode(),\n                                  false /* !include_suffix */, &policies_path);\n  DWORD value = 0;\n\n  if (nt::QueryRegValueDWORD(nt::HKLM, nt::NONE, policies_path.c_str(),\n                             kMetricsReportingEnabled, &value)) {\n    *crash_reporting_enabled = (value != 0);\n    return true;\n  }\n\n  if (nt::QueryRegValueDWORD(nt::HKCU, nt::NONE, policies_path.c_str(),\n                             kMetricsReportingEnabled, &value)) {\n    *crash_reporting_enabled = (value != 0);\n    return true;\n  }\n\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2019-5804",
        "length": 172
    },
    {
        "index": 170564,
        "code": "int32_t EqualizerGetBandFreqRange(EffectContext *pContext __unused, int32_t band, uint32_t *pLow,\n uint32_t *pHi){\n *pLow = bandFreqRange[band][0];\n *pHi  = bandFreqRange[band][1];\n return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3842",
        "length": 68
    },
    {
        "index": 95600,
        "code": "void Com_InitHunkMemory( void ) {\n\tcvar_t  *cv;\n\tint nMinAlloc;\n\tchar *pMsg = NULL;\n\n\tif ( FS_LoadStack() != 0 ) {\n\t\tCom_Error( ERR_FATAL, \"Hunk initialization failed. File system load stack not zero\" );\n\t}\n\n\tcv = Cvar_Get( \"com_hunkMegs\", DEF_COMHUNKMEGS_S, CVAR_LATCH | CVAR_ARCHIVE );\n\n\tif ( com_dedicated && com_dedicated->integer ) {\n\t\tnMinAlloc = MIN_DEDICATED_COMHUNKMEGS;\n\t\tpMsg = \"Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\\n\";\n\t} else {\n\t\tnMinAlloc = MIN_COMHUNKMEGS;\n\t\tpMsg = \"Minimum com_hunkMegs is %i, allocating %i megs.\\n\";\n\t}\n\n\tif ( cv->integer < nMinAlloc ) {\n\t\ts_hunkTotal = 1024 * 1024 * nMinAlloc;\n\t\tCom_Printf( pMsg, nMinAlloc, s_hunkTotal / ( 1024 * 1024 ) );\n\t} else {\n\t\ts_hunkTotal = cv->integer * 1024 * 1024;\n\t}\n\n\n\ts_hunkData = malloc( s_hunkTotal + 31 );\n\tif ( !s_hunkData ) {\n\t\tCom_Error( ERR_FATAL, \"Hunk data failed to allocate %i megs\", s_hunkTotal / ( 1024 * 1024 ) );\n\t}\n\ts_hunkData = (byte *) ( ( (intptr_t)s_hunkData + 31 ) & ~31 );\n\tHunk_Clear();\n\n\tCmd_AddCommand( \"meminfo\", Com_Meminfo_f );\n#ifdef ZONE_DEBUG\n\tCmd_AddCommand( \"zonelog\", Z_LogHeap );\n#endif\n#ifdef HUNK_DEBUG\n\tCmd_AddCommand( \"hunklog\", Hunk_Log );\n\tCmd_AddCommand( \"hunksmalllog\", Hunk_SmallLog );\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 437
    },
    {
        "index": 28762,
        "code": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!kvm_vcpu_has_lapic(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tapic_set_reg(apic, APIC_LVR, v);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6376",
        "length": 138
    },
    {
        "index": 62433,
        "code": "wep_print(netdissect_options *ndo,\n          const u_char *p)\n{\n\tuint32_t iv;\n\n\tif (!ND_TTEST2(*p, IEEE802_11_IV_LEN + IEEE802_11_KID_LEN))\n\t\treturn 0;\n\tiv = EXTRACT_LE_32BITS(p);\n\n\tND_PRINT((ndo, \" IV:%3x Pad %x KeyID %x\", IV_IV(iv), IV_PAD(iv),\n\t    IV_KEYID(iv)));\n\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13008",
        "length": 102
    },
    {
        "index": 70518,
        "code": "void __ext4_abort(struct super_block *sb, const char *function,\n\t\tunsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tsave_error_info(sb, function, line);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: %pV\\n\",\n\t       sb->s_id, function, line, &vaf);\n\tva_end(args);\n\n\tif ((sb->s_flags & MS_RDONLY) == 0) {\n\t\text4_msg(sb, KERN_CRIT, \"Remounting filesystem read-only\");\n\t\tEXT4_SB(sb)->s_mount_flags |= EXT4_MF_FS_ABORTED;\n\t\t/*\n\t\t * Make sure updated value of ->s_mount_flags will be visible\n\t\t * before ->s_flags update\n\t\t */\n\t\tsmp_wmb();\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tif (EXT4_SB(sb)->s_journal)\n\t\t\tjbd2_journal_abort(EXT4_SB(sb)->s_journal, -EIO);\n\t\tsave_error_info(sb, function, line);\n\t}\n\tif (test_opt(sb, ERRORS_PANIC)) {\n\t\tif (EXT4_SB(sb)->s_journal &&\n\t\t  !(EXT4_SB(sb)->s_journal->j_flags & JBD2_REC_ERR))\n\t\t\treturn;\n\t\tpanic(\"EXT4-fs panic from previous error\\n\");\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10208",
        "length": 311
    },
    {
        "index": 173006,
        "code": " buffer_extend(struct buffer_list *current)\n {\n struct buffer_list *add;\n\n   assert(current->next == NULL);\n\n   add = NEW(struct buffer_list);\n if (add == NULL)\n return NULL;\n\n   add->next = NULL;\n   current->next = add;\n\n return add;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 59
    },
    {
        "index": 128569,
        "code": "pp::Var Instance::GetLinkAtPosition(const pp::Point& point) {\n  pp::Point offset_point(point);\n  ScalePoint(device_scale_, &offset_point);\n  offset_point.set_x(offset_point.x() - available_area_.x());\n  return engine_->GetLinkAtPosition(offset_point);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3198",
        "length": 63
    },
    {
        "index": 127111,
        "code": "void AudioRendererAlgorithm::ResetWindow() {\n  DCHECK_LE(index_into_window_, window_size_);\n  index_into_window_ = 0;\n   crossfade_frame_number_ = 0;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-5152",
        "length": 40
    },
    {
        "index": 131114,
        "code": "static void variadicNodeMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectV8Internal::variadicNodeMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 70
    },
    {
        "index": 83431,
        "code": "size_t filter_result_len(const char *filter, const char *user, char *output) {\n  const char *part = NULL;\n  size_t result = 0;\n  do\n    {\n      size_t len;\n      part = strstr(filter, \"%u\");\n      if(part)\n        len = part - filter;\n      else\n        len = strlen(filter);\n      if (output)\n        {\n          strncpy(output, filter, len);\n          output += len;\n        }\n      result += len;\n      filter += len + 2;\n      if(part)\n        {\n          if(output)\n            {\n              strncpy(output, user, strlen(user));\n              output += strlen(user);\n            }\n          result += strlen(user);\n        }\n    }\n  while(part);\n\n  if(output)\n    *output = '\\0';\n  return(result + 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-9275",
        "length": 173
    },
    {
        "index": 185909,
        "code": "void OffscreenCanvasSurfaceImpl::RequestSurfaceCreation(\n    const cc::SurfaceId& surface_id) {\n  cc::SurfaceManager* manager = GetSurfaceManager();\n  if (!surface_factory_) {\n    surface_factory_ = base::MakeUnique<cc::SurfaceFactory>(manager, this);\n  }\n  surface_factory_->Create(surface_id);\n}\n",
        "line": "    const cc::SurfaceId& surface_id) {\n  cc::SurfaceManager* manager = GetSurfaceManager();\n  if (!surface_factory_) {\n    surface_factory_ = base::MakeUnique<cc::SurfaceFactory>(manager, this);\n  }\n  surface_factory_->Create(surface_id);\n}\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 72
    },
    {
        "index": 43229,
        "code": "CLASS DCRaw()\n{\norder=0; /* Suppress valgrind error. */\nshot_select=0, multi_out=0, aber[0] = aber[1] = aber[2] = aber[3] = 1;\ngamm[0] = 0.45, gamm[1] = 4.5, gamm[2] = gamm[3] = gamm[4] = gamm[5] = 0;\nbright=1, user_mul[0] = user_mul[1] = user_mul[2] = user_mul[3] = 0;\nthreshold=0, half_size=0, four_color_rgb=0, document_mode=0, highlight=0;\nverbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=-1;\noutput_color=1, output_bps=8, output_tiff=0, med_passes=0, no_auto_bright=0;\ngreybox[0] = greybox[1] = 0, greybox[2] = greybox[3] = UINT_MAX;\ntone_curve_size = 0, tone_curve_offset = 0; /* Nikon Tone Curves UF*/\ntone_mode_offset = 0, tone_mode_size = 0; /* Nikon ToneComp UF*/\nmessageBuffer = NULL;\nlastStatus = DCRAW_SUCCESS;\nifname = NULL;\nifname_display = NULL;\nifpReadCount = 0;\nifpSize = 0;\nifpStepProgress = 0;\neofCount = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2015-3885",
        "length": 329
    },
    {
        "index": 107631,
        "code": "int ewk_view_setting_font_default_size_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    return priv->settings.fontDefaultSize;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 66
    },
    {
        "index": 47711,
        "code": "gsf_infile_tar_read (GsfInput *input, size_t num_bytes, guint8 *buffer)\n{\n\t(void)input;\n\t(void)num_bytes;\n\t(void)buffer;\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-9888",
        "length": 45
    },
    {
        "index": 116145,
        "code": "void ResourceDispatcherHostImpl::OnAuthRequired(\n    net::URLRequest* request,\n    net::AuthChallengeInfo* auth_info) {\n  if (request->load_flags() & net::LOAD_DO_NOT_PROMPT_FOR_LOGIN) {\n    request->CancelAuth();\n    return;\n  }\n\n  if (delegate_ && !delegate_->AcceptAuthRequest(request, auth_info)) {\n    request->CancelAuth();\n    return;\n  }\n\n  if (!auth_info->is_proxy) {\n    HttpAuthResourceType resource_type = HttpAuthResourceTypeOf(request);\n    UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\",\n                              resource_type,\n                              HTTP_AUTH_RESOURCE_LAST);\n\n    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS) {\n      request->CancelAuth();\n      return;\n    }\n  }\n\n\n  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);\n  DCHECK(!info->login_delegate()) <<\n      \"OnAuthRequired called with login_delegate pending\";\n  if (delegate_) {\n    info->set_login_delegate(delegate_->CreateLoginDelegate(\n        auth_info, request));\n  }\n  if (!info->login_delegate())\n    request->CancelAuth();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3106",
        "length": 246
    },
    {
        "index": 46835,
        "code": "static int cbc_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt(desc, &walk);\n\n\twhile ((nbytes = walk.nbytes)) {\n\t\tnbytes = __cbc_encrypt(desc, &walk);\n\t\terr = blkcipher_walk_done(desc, &walk, nbytes);\n\t}\n\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 112
    },
    {
        "index": 165259,
        "code": "net::Error NavigationRequest::CheckContentSecurityPolicy(\n    bool has_followed_redirect,\n    bool url_upgraded_after_redirect,\n    bool is_response_check) {\n  if (common_params_.url.SchemeIs(url::kAboutScheme))\n    return net::OK;\n\n  if (common_params_.initiator_csp_info.should_check_main_world_csp ==\n      CSPDisposition::DO_NOT_CHECK) {\n    return net::OK;\n  }\n\n  FrameTreeNode* parent_ftn = frame_tree_node()->parent();\n  RenderFrameHostImpl* parent =\n      parent_ftn ? parent_ftn->current_frame_host() : nullptr;\n\n  initiator_csp_context_->SetReportingRenderFrameHost(\n      frame_tree_node()->current_frame_host());\n\n\n  net::Error report_only_csp_status = CheckCSPDirectives(\n      parent, has_followed_redirect, url_upgraded_after_redirect,\n      is_response_check, CSPContext::CHECK_REPORT_ONLY_CSP);\n\n  if (!has_followed_redirect && !frame_tree_node()->IsMainFrame()) {\n    if (parent &&\n        parent->ShouldModifyRequestUrlForCsp(true /* is subresource */)) {\n      upgrade_if_insecure_ = true;\n      parent->ModifyRequestUrlForCsp(&common_params_.url);\n      commit_params_.original_url = common_params_.url;\n    }\n  }\n\n  net::Error enforced_csp_status = CheckCSPDirectives(\n      parent, has_followed_redirect, url_upgraded_after_redirect,\n      is_response_check, CSPContext::CHECK_ENFORCED_CSP);\n  if (enforced_csp_status != net::OK)\n    return enforced_csp_status;\n  return report_only_csp_status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2019-5794",
        "length": 346
    },
    {
        "index": 158461,
        "code": "  void SimulateGestureScrollUpdateEvent(float dX, float dY, int modifiers) {\n    SimulateGestureEventCore(SyntheticWebGestureEventBuilder::BuildScrollUpdate(\n        dX, dY, modifiers, blink::kWebGestureDeviceTouchscreen));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17467",
        "length": 59
    },
    {
        "index": 187556,
        "code": "status_t OMXNodeInstance::useGraphicBuffer(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id *buffer) {\n Mutex::Autolock autoLock(mLock);\n\n    OMX_INDEXTYPE index;\n if (OMX_GetExtensionIndex(\n            mHandle,\n const_cast<OMX_STRING>(\"OMX.google.android.index.useAndroidNativeBuffer2\"),\n &index) == OMX_ErrorNone) {\n return useGraphicBuffer2_l(portIndex, graphicBuffer, buffer);\n }\n\n    OMX_STRING name = const_cast<OMX_STRING>(\n \"OMX.google.android.index.useAndroidNativeBuffer\");\n    OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(getExtensionIndex, err, \"%s\", name);\n\n         return StatusFromOMXError(err);\n     }\n \n    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_VERSIONTYPE ver;\n    ver.s.nVersionMajor = 1;\n    ver.s.nVersionMinor = 0;\n    ver.s.nRevision = 0;\n    ver.s.nStep = 0;\n UseAndroidNativeBufferParams params = {\n sizeof(UseAndroidNativeBufferParams), ver, portIndex, bufferMeta,\n &header, graphicBuffer,\n };\n\n    err = OMX_SetParameter(mHandle, index, &params);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u meta=%p GB=%p\", name, index,\n                portString(portIndex), portIndex, bufferMeta, graphicBuffer->handle);\n\n delete bufferMeta;\n        bufferMeta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, bufferMeta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n    CLOG_BUFFER(useGraphicBuffer, NEW_BUFFER_FMT(\n *buffer, portIndex, \"GB=%p\", graphicBuffer->handle));\n return OK;\n}\n",
        "line": "    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3824",
        "length": 443
    },
    {
        "index": 137406,
        "code": "void RenderViewTest::SendWebGestureEvent(\n    const blink::WebGestureEvent& gesture_event) {\n  SendInputEvent(gesture_event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-7181, CVE-2015-7182, CVE-2015-7183",
        "length": 32
    },
    {
        "index": 108007,
        "code": "int InlineTextBox::caretMaxOffset() const\n{\n    return m_start + m_len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 21
    },
    {
        "index": 168065,
        "code": "void AutofillManager::OnFocusNoLongerOnForm() {\n  ProcessPendingFormForUpload();\n  if (external_delegate_->HasActiveScreenReader())\n    external_delegate_->OnAutofillAvailabilityEvent(false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-16078",
        "length": 46
    },
    {
        "index": 151142,
        "code": "void InspectorNetworkAgent::ApplyUserAgentOverride(String* user_agent) {\n  String user_agent_override;\n  state_->getString(NetworkAgentState::kUserAgentOverride,\n                    &user_agent_override);\n  if (!user_agent_override.IsEmpty())\n    *user_agent = user_agent_override;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 59
    },
    {
        "index": 72839,
        "code": "static void jpc_com_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tif (com->data) {\n\t\tjas_free(com->data);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-9557",
        "length": 49
    },
    {
        "index": 103262,
        "code": "void WebSocketJob::RestartWithAuth(\n    const string16& username,\n    const string16& password) {\n  state_ = CONNECTING;\n  socket_->RestartWithAuth(username, password);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-2849",
        "length": 42
    },
    {
        "index": 51355,
        "code": "static zend_object_value spl_filesystem_object_new_check(zend_class_entry *class_type TSRMLS_DC)\n{\n\tzend_object_value ret = spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);\n\tret.handlers = &spl_filesystem_object_check_handlers;\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5770",
        "length": 56
    },
    {
        "index": 125519,
        "code": "void GDataDirectory::RemoveChild(GDataEntry* entry) {\n  DCHECK(entry);\n\n  const std::string& base_name(entry->base_name());\n  DCHECK_EQ(entry, FindChild(base_name));\n  if (directory_service_)\n    directory_service_->RemoveEntryFromResourceMap(entry);\n\n  child_files_.erase(base_name);\n  child_directories_.erase(base_name);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-0839",
        "length": 77
    },
    {
        "index": 129054,
        "code": "    void writeVersion()\n    {\n        append(VersionTag);\n        doWriteUint32(SerializedScriptValue::wireFormatVersion);\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3171",
        "length": 30
    },
    {
        "index": 54828,
        "code": "static void add_preferred_base_object(const char *name)\n{\n\tstruct pbase_tree *it;\n\tint cmplen;\n\tunsigned hash = pack_name_hash(name);\n\n\tif (!num_preferred_base || check_pbase_path(hash))\n\t\treturn;\n\n\tcmplen = name_cmp_len(name);\n\tfor (it = pbase_tree; it; it = it->next) {\n\t\tif (cmplen == 0) {\n\t\t\tadd_object_entry(it->pcache.sha1, OBJ_TREE, NULL, 1);\n\t\t}\n\t\telse {\n\t\t\tstruct tree_desc tree;\n\t\t\tinit_tree_desc(&tree, it->pcache.tree_data, it->pcache.tree_size);\n\t\t\tadd_pbase_object(&tree, name, cmplen, name);\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2324",
        "length": 158
    },
    {
        "index": 90096,
        "code": "int ZSTD_maxCLevel(void) { return ZSTD_MAX_CLEVEL; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2019-11922",
        "length": 18
    },
    {
        "index": 112528,
        "code": "void Document::registerForPageCacheSuspensionCallbacks(Element* e)\n{\n    m_documentSuspensionCallbackElements.add(e);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 27
    },
    {
        "index": 41360,
        "code": "int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tregs->rax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tregs->rbx = kvm_register_read(vcpu, VCPU_REGS_RBX);\n\tregs->rcx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tregs->rdx = kvm_register_read(vcpu, VCPU_REGS_RDX);\n\tregs->rsi = kvm_register_read(vcpu, VCPU_REGS_RSI);\n\tregs->rdi = kvm_register_read(vcpu, VCPU_REGS_RDI);\n\tregs->rsp = kvm_register_read(vcpu, VCPU_REGS_RSP);\n\tregs->rbp = kvm_register_read(vcpu, VCPU_REGS_RBP);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_register_read(vcpu, VCPU_REGS_R8);\n\tregs->r9 = kvm_register_read(vcpu, VCPU_REGS_R9);\n\tregs->r10 = kvm_register_read(vcpu, VCPU_REGS_R10);\n\tregs->r11 = kvm_register_read(vcpu, VCPU_REGS_R11);\n\tregs->r12 = kvm_register_read(vcpu, VCPU_REGS_R12);\n\tregs->r13 = kvm_register_read(vcpu, VCPU_REGS_R13);\n\tregs->r14 = kvm_register_read(vcpu, VCPU_REGS_R14);\n\tregs->r15 = kvm_register_read(vcpu, VCPU_REGS_R15);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2010-5313",
        "length": 348
    },
    {
        "index": 104824,
        "code": "void ExtensionService::UpdateActiveExtensionsInCrashReporter() {\n  std::set<std::string> extension_ids;\n  for (size_t i = 0; i < extensions_.size(); ++i) {\n    if (!extensions_[i]->is_theme() &&\n        extensions_[i]->location() != Extension::COMPONENT)\n      extension_ids.insert(extensions_[i]->id());\n  }\n\n   child_process_logging::SetActiveExtensions(extension_ids);\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2783",
        "length": 93
    },
    {
        "index": 79649,
        "code": "char *M_fs_path_join_vparts(M_fs_system_t sys_type, size_t num, ...)\n{\n\tM_list_str_t *parts;\n\tchar         *out;\n\tva_list       ap;\n\tsize_t        i;\n\n\tparts = M_list_str_create(M_LIST_STR_NONE);\n\tva_start(ap, num);\n\tfor (i=0; i<num; i++) {\n\t\tM_list_str_insert(parts, va_arg(ap, const char *));\n\t}\n\tva_end(ap);\n\n\tout = M_fs_path_join_parts(parts, sys_type);\n\tM_list_str_destroy(parts);\n\treturn out;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-14043",
        "length": 116
    },
    {
        "index": 80238,
        "code": "GF_Err mfra_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentRandomAccessBox *ptr = (GF_MovieFragmentRandomAccessBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFRA:\n\t\treturn gf_list_add(ptr->tfra_list, a);\n\tcase GF_ISOM_BOX_TYPE_MFRO:\n\t\tif (ptr->mfro) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)a;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 142
    },
    {
        "index": 2778,
        "code": "gs_copydevice(gx_device ** pnew_dev, const gx_device * dev, gs_memory_t * mem)\n{\n    return gs_copydevice2(pnew_dev, dev, false, mem);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-78",
        "cve": "CVE-2018-16863",
        "length": 42
    },
    {
        "index": 110943,
        "code": "  ImageCursors() {\n    LoadImageCursor(ui::kCursorNoDrop, IDR_AURA_CURSOR_NO_DROP);\n    LoadImageCursor(ui::kCursorCopy, IDR_AURA_CURSOR_COPY);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 41
    },
    {
        "index": 87061,
        "code": "int oidc_content_handler(request_rec *r) {\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tint rc = DECLINED;\n\tif (oidc_util_request_matches_url(r, oidc_get_redirect_uri(r, c))) {\n\n\t\tif (oidc_util_request_has_parameter(r,\n\t\t\t\tOIDC_REDIRECT_URI_REQUEST_INFO)) {\n\n\t\t\toidc_session_t *session = NULL;\n\t\t\toidc_session_load(r, &session);\n\n\t\t\t/* handle request for session info */\n\t\t\trc = oidc_handle_info_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t}\n\n\t}\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2019-1010247",
        "length": 160
    },
    {
        "index": 45548,
        "code": "static int crypto_authenc_esn_givencrypt(struct aead_givcrypt_request *req)\n{\n\tstruct crypto_aead *authenc_esn = aead_givcrypt_reqtfm(req);\n\tstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\n\tstruct aead_request *areq = &req->areq;\n\tstruct skcipher_givcrypt_request *greq = aead_request_ctx(areq);\n\tu8 *iv = req->giv;\n\tint err;\n\n\tskcipher_givcrypt_set_tfm(greq, ctx->enc);\n\tskcipher_givcrypt_set_callback(greq, aead_request_flags(areq),\n\t\t\t\t       crypto_authenc_esn_givencrypt_done, areq);\n\tskcipher_givcrypt_set_crypt(greq, areq->src, areq->dst, areq->cryptlen,\n\t\t\t\t    areq->iv);\n\tskcipher_givcrypt_set_giv(greq, iv, req->seq);\n\n\terr = crypto_skcipher_givencrypt(greq);\n\tif (err)\n\t\treturn err;\n\n\treturn crypto_authenc_esn_genicv(areq, iv, CRYPTO_TFM_REQ_MAY_SLEEP);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 252
    },
    {
        "index": 181527,
        "code": " alloc_limit_failure (char *fn_name, size_t size)\n {\n    fprintf (stderr, \n              \"%s: Maximum allocation size exceeded \"\n              \"(maxsize = %lu; size = %lu).\\n\",\n              fn_name,\n             (unsigned long)alloc_limit, \n              (unsigned long)size);\n }\n",
        "line": "    fprintf (stderr, \n             (unsigned long)alloc_limit, \n",
        "label": 1,
        "cwe": "CWE-190",
        "cve": "CVE-2017-6308",
        "length": 65
    },
    {
        "index": 154620,
        "code": "error::Error GLES2DecoderPassthroughImpl::DoDeleteQueriesEXT(\n    GLsizei n,\n    const volatile GLuint* queries) {\n  if (n < 0) {\n    InsertError(GL_INVALID_VALUE, \"count cannot be negative.\");\n    return error::kNoError;\n  }\n\n  std::vector<GLuint> queries_copy(queries, queries + n);\n  for (GLuint query_client_id : queries_copy) {\n    GLuint query_service_id = 0;\n    if (!query_id_map_.GetServiceID(query_client_id, &query_service_id) ||\n        query_service_id == 0) {\n      continue;\n    }\n\n    QueryInfo query_info = query_info_map_[query_service_id];\n    query_info_map_.erase(query_service_id);\n\n    if (query_info.type == GL_NONE) {\n      continue;\n    }\n\n    auto active_queries_iter = active_queries_.find(query_info.type);\n    if (active_queries_iter != active_queries_.end()) {\n      active_queries_.erase(active_queries_iter);\n    }\n\n    RemovePendingQuery(query_service_id);\n  }\n  return DeleteHelper(queries_copy.size(), queries_copy.data(), &query_id_map_,\n                      [this](GLsizei n, GLuint* queries) {\n                        api()->glDeleteQueriesFn(n, queries);\n                      });\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 264
    },
    {
        "index": 18313,
        "code": "test_run_handler_arg_order (void) {\n    run_handler(\"sync_spawn echo uvw xyz\", \"abc def\");\n\n    assert(uzbl.comm.sync_stdout);\n\n    /* the result should begin with the standard handler arguments */\n    gchar *rest = assert_sync_beginswith_stdarg();\n\n    /* the rest of the result should be the arguments passed to run_handler. */\n    /* the arguments in the second argument to run_handler should be placed before any\n     * included in the first argument to run handler. */\n    g_assert_cmpstr(\"abc def uvw xyz\\n\", ==, rest);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2010-0011",
        "length": 123
    },
    {
        "index": 9665,
        "code": "PHP_FUNCTION(urldecode)\n{\n\tchar *in_str, *out_str;\n\tint in_str_len, out_str_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &in_str,\n\t\t\t\t\t\t\t  &in_str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tout_str = estrndup(in_str, in_str_len);\n\tout_str_len = php_url_decode(out_str, in_str_len);\n\n    RETURN_STRINGL(out_str, out_str_len, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-6288",
        "length": 102
    },
    {
        "index": 174590,
        "code": "static void btm_sec_auth_collision (UINT16 handle)\n{\n    tBTM_SEC_DEV_REC *p_dev_rec;\n\n if (!btm_cb.collision_start_time)\n        btm_cb.collision_start_time = GKI_get_tick_count ();\n\n if ((GKI_get_tick_count () - btm_cb.collision_start_time) < btm_cb.max_collision_delay)\n {\n if (handle == BTM_SEC_INVALID_HANDLE)\n {\n if ((p_dev_rec = btm_sec_find_dev_by_sec_state (BTM_SEC_STATE_AUTHENTICATING)) == NULL)\n                p_dev_rec = btm_sec_find_dev_by_sec_state (BTM_SEC_STATE_ENCRYPTING);\n }\n else\n            p_dev_rec = btm_find_dev_by_handle (handle);\n\n if (p_dev_rec != NULL)\n {\n            BTM_TRACE_DEBUG (\"btm_sec_auth_collision: state %d (retrying in a moment...)\", p_dev_rec->sec_state);\n /* We will restart authentication after timeout */\n if (p_dev_rec->sec_state == BTM_SEC_STATE_AUTHENTICATING || p_dev_rec->sec_state == BTM_SEC_STATE_ENCRYPTING)\n                p_dev_rec->sec_state = 0;\n\n            btm_cb.p_collided_dev_rec = p_dev_rec;\n            btm_cb.sec_collision_tle.param = (UINT32) btm_sec_collision_timeout;\n            btu_start_timer (&btm_cb.sec_collision_tle, BTU_TTYPE_USER_FUNC, BT_1SEC_TIMEOUT);\n }\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0850",
        "length": 307
    },
    {
        "index": 81802,
        "code": "streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int create) {\n    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,\n                               sdslen(name));\n    if (consumer == raxNotFound) {\n        if (!create) return NULL;\n        consumer = zmalloc(sizeof(*consumer));\n        consumer->name = sdsdup(name);\n        consumer->pel = raxNew();\n        raxInsert(cg->consumers,(unsigned char*)name,sdslen(name),\n                  consumer,NULL);\n    }\n    consumer->seen_time = mstime();\n    return consumer;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-12453",
        "length": 131
    },
    {
        "index": 69719,
        "code": "get_nonprimary_guard_connect_timeout(void)\n{\n  return networkstatus_get_param(NULL,\n                                 \"guard-nonprimary-guard-connect-timeout\",\n                                 DFLT_NONPRIMARY_GUARD_CONNECT_TIMEOUT,\n                                 1, INT32_MAX);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-0377",
        "length": 47
    },
    {
        "index": 9538,
        "code": "PHP_METHOD(snmp, walk)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_WALK, (-1));\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-6295",
        "length": 32
    },
    {
        "index": 151329,
        "code": "std::unique_ptr<TracedValue> InspectorTimeStampEvent::Data(\n    ExecutionContext* context,\n    const String& message) {\n  std::unique_ptr<TracedValue> value = TracedValue::Create();\n  value->SetString(\"message\", message);\n  if (LocalFrame* frame = FrameForExecutionContext(context))\n    value->SetString(\"frame\", ToHexString(frame));\n  return value;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 86
    },
    {
        "index": 71516,
        "code": "static MagickBooleanType IsDPX(const unsigned char *magick,const size_t extent)\n{\n  if (extent < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"SDPX\",4) == 0)\n    return(MagickTrue);\n  if (memcmp(magick,\"XPDS\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10066",
        "length": 91
    },
    {
        "index": 118087,
        "code": "void ConfirmEmailDialogDelegate::OnClosed() {\n  base::ResetAndReturn(&callback_).Run(CLOSE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-6634",
        "length": 26
    },
    {
        "index": 109772,
        "code": "String Document::queryCommandValue(const String& commandName)\n{\n    return command(this, commandName).value();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5136",
        "length": 25
    },
    {
        "index": 20095,
        "code": "static u32 rio_get_link(struct net_device *dev)\n{\n\tstruct netdev_private *np = netdev_priv(dev);\n\treturn np->link_status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-2313",
        "length": 33
    },
    {
        "index": 124886,
        "code": "static bool isCandidateForOpaquenessTest(RenderBox* childBox)\n{\n    RenderStyle* childStyle = childBox->style();\n    if (childStyle->position() != StaticPosition && childBox->containingBlock() != childBox->parent())\n        return false;\n    if (childStyle->visibility() != VISIBLE || childStyle->shapeOutside())\n        return false;\n    if (!childBox->width() || !childBox->height())\n        return false;\n    if (RenderLayer* childLayer = childBox->layer()) {\n        if (childLayer->compositingState() != NotComposited)\n            return false;\n        if (!childStyle->hasAutoZIndex())\n            return false;\n        if (childLayer->hasTransform() || childLayer->isTransparent() || childLayer->hasFilter())\n            return false;\n        if (childBox->hasOverflowClip() && childStyle->hasBorderRadius())\n            return false;\n    }\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 207
    },
    {
        "index": 1254,
        "code": "SplashPattern *Splash::getFillPattern() {\n  return state->fillPattern;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 19
    },
    {
        "index": 103721,
        "code": "  virtual WebDevToolsAgent* agent() {\n    DevToolsAgent* agent = DevToolsAgent::FromHostId(host_id);\n    if (!agent)\n      return 0;\n    return agent->GetWebAgent();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 48
    },
    {
        "index": 134566,
        "code": "WebContentsViewAura::WebContentsViewAura(\n    WebContentsImpl* web_contents,\n    WebContentsViewDelegate* delegate)\n    : web_contents_(web_contents),\n      delegate_(delegate),\n      current_drag_op_(blink::WebDragOperationNone),\n      drag_dest_delegate_(NULL),\n      current_rvh_for_drag_(NULL),\n      overscroll_change_brightness_(false),\n      current_overscroll_gesture_(OVERSCROLL_NONE),\n      completed_overscroll_gesture_(OVERSCROLL_NONE),\n      touch_editable_(TouchEditableImplAura::Create()) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 116
    },
    {
        "index": 173587,
        "code": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) {\n if (err != OK) {\n {\n            sp<DataSource> dataSource = mDataSource;\n            sp<NuCachedSource2> cachedSource = mCachedSource;\n            sp<DataSource> httpSource = mHttpSource;\n {\n Mutex::Autolock _l(mDisconnectLock);\n                mDataSource.clear();\n                mDecryptHandle = NULL;\n                mDrmManagerClient = NULL;\n                mCachedSource.clear();\n                mHttpSource.clear();\n }\n }\n        mBitrate = -1;\n\n        cancelPollBuffering();\n }\n    notifyPrepared(err);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2508",
        "length": 132
    },
    {
        "index": 17351,
        "code": "n_shell_variables ()\n{\n  VAR_CONTEXT *vc;\n  int n;\n\n  for (n = 0, vc = shell_variables; vc; vc = vc->down)\n    n += HASH_ENTRIES (vc->table);\n  return n;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-6711",
        "length": 52
    },
    {
        "index": 118388,
        "code": "  void ServiceURLRequest(const std::string& response) {\n    net::TestURLFetcher* url_fetcher =\n        test_url_fetcher_factory_.GetFetcherByID(0);\n    ASSERT_NE(nullptr, url_fetcher);\n\n    url_fetcher->set_response_code(200);\n    url_fetcher->SetResponseString(response);\n    url_fetcher->delegate()->OnURLFetchComplete(url_fetcher);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6640",
        "length": 84
    },
    {
        "index": 162413,
        "code": "MojoResult Core::MapBuffer(MojoHandle buffer_handle,\n                           uint64_t offset,\n                           uint64_t num_bytes,\n                           void** buffer,\n                           MojoMapBufferFlags flags) {\n  RequestContext request_context;\n  scoped_refptr<Dispatcher> dispatcher(GetDispatcher(buffer_handle));\n  if (!dispatcher)\n    return MOJO_RESULT_INVALID_ARGUMENT;\n\n  std::unique_ptr<PlatformSharedBufferMapping> mapping;\n  MojoResult result = dispatcher->MapBuffer(offset, num_bytes, flags, &mapping);\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n  DCHECK(mapping);\n  void* address = mapping->GetBase();\n  {\n    base::AutoLock locker(mapping_table_lock_);\n    result = mapping_table_.AddMapping(std::move(mapping));\n  }\n  if (result != MOJO_RESULT_OK)\n    return result;\n\n  *buffer = address;\n  return MOJO_RESULT_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 186
    },
    {
        "index": 130602,
        "code": "static void activityLoggedInIsolatedWorldMethodMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectV8Internal::activityLoggedInIsolatedWorldMethodMethodForMainWorld(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 80
    },
    {
        "index": 125025,
        "code": "static LayoutUnit initialJustifyContentOffset(LayoutUnit availableFreeSpace, EJustifyContent justifyContent, unsigned numberOfChildren)\n{\n    if (justifyContent == JustifyFlexEnd)\n        return availableFreeSpace;\n    if (justifyContent == JustifyCenter)\n        return availableFreeSpace / 2;\n    if (justifyContent == JustifySpaceAround) {\n        if (availableFreeSpace > 0 && numberOfChildren)\n            return availableFreeSpace / (2 * numberOfChildren);\n        else\n            return availableFreeSpace / 2;\n    }\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 119
    },
    {
        "index": 137249,
        "code": "void Textfield::OnCompositionTextConfirmedOrCleared() {\n  if (!skip_input_method_cancel_composition_)\n    GetInputMethod()->CancelComposition(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 34
    },
    {
        "index": 106965,
        "code": "bool QQuickWebView::canGoBack() const\n{\n    Q_D(const QQuickWebView);\n    return d->webPageProxy->canGoBack();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-1800",
        "length": 34
    },
    {
        "index": 93769,
        "code": "virDomainBlockRebase(virDomainPtr dom, const char *disk,\n                     const char *base, unsigned long bandwidth,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"disk=%s, base=%s, bandwidth=%lu, flags=%x\",\n                     disk, NULLSTR(base), bandwidth, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(disk, error);\n\n    if (flags & VIR_DOMAIN_BLOCK_REBASE_COPY) {\n        virCheckNonNullArgGoto(base, error);\n    } else if (flags & (VIR_DOMAIN_BLOCK_REBASE_SHALLOW |\n                        VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |\n                        VIR_DOMAIN_BLOCK_REBASE_COPY_RAW |\n                        VIR_DOMAIN_BLOCK_REBASE_COPY_DEV)) {\n        virReportInvalidArg(flags, \"%s\",\n                            _(\"use of flags requires a copy job\"));\n        goto error;\n    }\n\n    if (conn->driver->domainBlockRebase) {\n        int ret;\n        ret = conn->driver->domainBlockRebase(dom, disk, base, bandwidth,\n                                              flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10746",
        "length": 293
    },
    {
        "index": 170065,
        "code": "xsltFreeDecimalFormatList(xsltStylesheetPtr self)\n{\n    xsltDecimalFormatPtr iter;\n    xsltDecimalFormatPtr tmp;\n\n    if (self == NULL)\n\treturn;\n\n    iter = self->decimalFormat;\n    while (iter != NULL) {\n\ttmp = iter->next;\n\txsltFreeDecimalFormat(iter);\n\titer = tmp;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 76
    },
    {
        "index": 115925,
        "code": "void ewk_frame_load_firstlayout_nonempty_finished(Evas_Object* ewkFrame)\n{\n    evas_object_smart_callback_call(ewkFrame, \"load,nonemptylayout,finished\", 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3103",
        "length": 45
    },
    {
        "index": 150904,
        "code": "void FakeCentral::GetLastWrittenDescriptorValue(\n    const std::string& descriptor_id,\n    const std::string& characteristic_id,\n    const std::string& service_id,\n    const std::string& peripheral_address,\n    GetLastWrittenDescriptorValueCallback callback) {\n  FakeRemoteGattDescriptor* fake_remote_gatt_descriptor =\n      GetFakeRemoteGattDescriptor(peripheral_address, service_id,\n                                  characteristic_id, descriptor_id);\n  if (!fake_remote_gatt_descriptor) {\n    std::move(callback).Run(false, base::nullopt);\n  }\n\n  std::move(callback).Run(true,\n                          fake_remote_gatt_descriptor->last_written_value());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5044",
        "length": 137
    },
    {
        "index": 20493,
        "code": "void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_itable_unused_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_itable_unused_hi = cpu_to_le16(count >> 16);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2100",
        "length": 84
    },
    {
        "index": 58631,
        "code": "BOOL rdp_read_share_data_header(STREAM* s, UINT16* length, BYTE* type, UINT32* share_id,\n\t\t\t\t\tBYTE *compressed_type, UINT16 *compressed_len)\n{\n\tif (stream_get_left(s) < 12)\n\t\treturn FALSE;\n\n\t/* Share Data Header */\n\tstream_read_UINT32(s, *share_id); /* shareId (4 bytes) */\n\tstream_seek_BYTE(s); /* pad1 (1 byte) */\n\tstream_seek_BYTE(s); /* streamId (1 byte) */\n\tstream_read_UINT16(s, *length); /* uncompressedLength (2 bytes) */\n\tstream_read_BYTE(s, *type); /* pduType2, Data PDU Type (1 byte) */\n\tstream_read_BYTE(s, *compressed_type); /* compressedType (1 byte) */\n\tstream_read_UINT16(s, *compressed_len); /* compressedLength (2 bytes) */\n\treturn TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2013-4118",
        "length": 184
    },
    {
        "index": 151531,
        "code": "void FetchContext::DispatchDidFail(unsigned long,\n                                   const ResourceError&,\n                                   int64_t,\n                                   bool) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 26
    },
    {
        "index": 104606,
        "code": "GURL Extension::GetFullLaunchURL() const {\n  if (!launch_local_path().empty())\n    return url().Resolve(launch_local_path());\n  else\n    return GURL(launch_web_url());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2839",
        "length": 43
    },
    {
        "index": 45667,
        "code": "static int cryptd_hash_finup_enqueue(struct ahash_request *req)\n{\n\treturn cryptd_hash_enqueue(req, cryptd_hash_finup);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 31
    },
    {
        "index": 122553,
        "code": "void WebDevToolsAgentImpl::disableViewportEmulation()\n{\n    if (!m_emulateViewportEnabled)\n        return;\n    RuntimeEnabledFeatures::setOverlayScrollbarsEnabled(m_isOverlayScrollbarsEnabled);\n    RuntimeEnabledFeatures::setCSSViewportEnabled(m_originalViewportEnabled);\n    m_webViewImpl->settings()->setViewportEnabled(false);\n    m_webViewImpl->settings()->setViewportMetaEnabled(false);\n    m_webViewImpl->settings()->setShrinksViewportContentToFit(false);\n    m_webViewImpl->setIgnoreViewportTagScaleLimits(false);\n    m_webViewImpl->setPageScaleFactorLimits(1, 1);\n    m_webViewImpl->setZoomFactorOverride(0);\n    m_emulateViewportEnabled = false;\n    if (m_touchEventEmulationEnabled)\n        m_client->setTouchEventEmulationEnabled(m_touchEventEmulationEnabled, m_emulateViewportEnabled);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0884",
        "length": 188
    },
    {
        "index": 158602,
        "code": "FrameFetchContext::CreateResourceLoadingTaskRunnerHandle() {\n  if (IsDetached()) {\n    return scheduler::WebResourceLoadingTaskRunnerHandle::CreateUnprioritized(\n        FetchContext::GetLoadingTaskRunner());\n  }\n  return GetFrame()\n      ->GetFrameScheduler()\n      ->CreateResourceLoadingTaskRunnerHandle();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-17468",
        "length": 69
    },
    {
        "index": 172488,
        "code": "unsigned venc_dev::venc_start_done(void)\n{\n struct venc_msg venc_msg;\n    venc_msg.msgcode = VEN_MSG_START;\n    venc_msg.statuscode = VEN_S_SUCCESS;\n    venc_handle->async_message_process(venc_handle,&venc_msg);\n return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3835",
        "length": 66
    },
    {
        "index": 53804,
        "code": "static void __init reserve_initrd(void)\n{\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-3699",
        "length": 12
    },
    {
        "index": 116031,
        "code": "gfx::Rect ExtensionInstalledBubble::GetAnchorRect() {\n  if (type_ == OMNIBOX_KEYWORD) {\n    LocationBarView* location_bar_view =\n        BrowserView::GetBrowserViewForBrowser(browser_)->GetLocationBarView();\n    return gfx::Rect(location_bar_view->GetLocationEntryOrigin(),\n        gfx::Size(0, location_bar_view->location_entry_view()->height()));\n  }\n  return views::BubbleDelegateView::GetAnchorRect();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3104",
        "length": 98
    },
    {
        "index": 85165,
        "code": "static struct bio *f2fs_grab_bio(struct inode *inode, block_t blkaddr,\n\t\t\t\t unsigned nr_pages)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct fscrypt_ctx *ctx = NULL;\n\tstruct bio *bio;\n\n\tif (f2fs_encrypted_inode(inode) && S_ISREG(inode->i_mode)) {\n\t\tctx = fscrypt_get_ctx(inode, GFP_NOFS);\n\t\tif (IS_ERR(ctx))\n\t\t\treturn ERR_CAST(ctx);\n\n\t\t/* wait the page to be moved by cleaning */\n\t\tf2fs_wait_on_encrypted_page_writeback(sbi, blkaddr);\n\t}\n\n\tbio = bio_alloc(GFP_KERNEL, min_t(int, nr_pages, BIO_MAX_PAGES));\n\tif (!bio) {\n\t\tif (ctx)\n\t\t\tfscrypt_release_ctx(ctx);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tf2fs_target_device(sbi, blkaddr, bio);\n\tbio->bi_end_io = f2fs_read_end_io;\n\tbio->bi_private = ctx;\n\n\treturn bio;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-18257",
        "length": 223
    },
    {
        "index": 107796,
        "code": "bool Browser::IsReservedCommand(int command_id) {\n  return command_id == IDC_CLOSE_TAB ||\n         command_id == IDC_CLOSE_WINDOW ||\n         command_id == IDC_NEW_INCOGNITO_WINDOW ||\n         command_id == IDC_NEW_TAB ||\n         command_id == IDC_NEW_WINDOW ||\n         command_id == IDC_RESTORE_TAB ||\n         command_id == IDC_SELECT_NEXT_TAB ||\n         command_id == IDC_SELECT_PREVIOUS_TAB ||\n         command_id == IDC_TABPOSE ||\n         command_id == IDC_EXIT ||\n         command_id == IDC_SEARCH;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 108
    },
    {
        "index": 124360,
        "code": "void BrowserEventRouter::DispatchEventToExtension(\n    Profile* profile,\n    const std::string& extension_id,\n    const char* event_name,\n    scoped_ptr<ListValue> event_args,\n    EventRouter::UserGestureState user_gesture) {\n  if (!profile_->IsSameProfile(profile) ||\n      !extensions::ExtensionSystem::Get(profile)->event_router())\n    return;\n\n  scoped_ptr<Event> event(new Event(event_name, event_args.Pass()));\n  event->restrict_to_profile = profile;\n  event->user_gesture = user_gesture;\n  ExtensionSystem::Get(profile)->event_router()->\n      DispatchEventToExtension(extension_id, event.Pass());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0925",
        "length": 138
    },
    {
        "index": 117616,
        "code": "AutolaunchInfoBarDelegate::AutolaunchInfoBarDelegate(\n    InfoBarTabHelper* infobar_helper,\n    PrefService* prefs)\n    : ConfirmInfoBarDelegate(infobar_helper),\n      prefs_(prefs),\n      action_taken_(false),\n      should_expire_(false),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)) {\n  auto_launch_trial::UpdateInfobarShownMetric();\n\n  int count = prefs_->GetInteger(prefs::kShownAutoLaunchInfobar);\n  prefs_->SetInteger(prefs::kShownAutoLaunchInfobar, count + 1);\n\n  MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&AutolaunchInfoBarDelegate::AllowExpiry,\n                 weak_factory_.GetWeakPtr()),\n      8000);  // 8 seconds.\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3053",
        "length": 171
    },
    {
        "index": 94264,
        "code": "static enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response_header;\n        protocol_binary_response_incr response;\n        char bytes[1024];\n    } send, receive;\n    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,\n                                    key, strlen(key), 1, 0, 0);\n\n    int ii;\n    for (ii = 0; ii < 10; ++ii) {\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response_header, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n            assert(ntohll(receive.response.message.body.value) == ii);\n        }\n    }\n\n    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {\n        test_binary_noop();\n    }\n    return TEST_PASS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-1152",
        "length": 215
    },
    {
        "index": 54858,
        "code": "static int mark_tagged(const char *path, const struct object_id *oid, int flag,\n\t\t       void *cb_data)\n{\n\tunsigned char peeled[20];\n\tstruct object_entry *entry = packlist_find(&to_pack, oid->hash, NULL);\n\n\tif (entry)\n\t\tentry->tagged = 1;\n\tif (!peel_ref(path, peeled)) {\n\t\tentry = packlist_find(&to_pack, peeled, NULL);\n\t\tif (entry)\n\t\t\tentry->tagged = 1;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2324",
        "length": 111
    },
    {
        "index": 12583,
        "code": "void ne2000_reset(NE2000State *s)\n{\n    int i;\n\n    s->isr = ENISR_RESET;\n    memcpy(s->mem, &s->c.macaddr, 6);\n    s->mem[14] = 0x57;\n    s->mem[15] = 0x57;\n\n    /* duplicate prom data */\n    for(i = 15;i >= 0; i--) {\n        s->mem[2 * i] = s->mem[i];\n        s->mem[2 * i + 1] = s->mem[i];\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-2841",
        "length": 127
    },
    {
        "index": 22177,
        "code": "static void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n\t/* Thread group counters. */\n\tthread_group_cputime_init(sig);\n\n\t/* Expiration times and increments. */\n\tsig->it_virt_expires = cputime_zero;\n\tsig->it_virt_incr = cputime_zero;\n\tsig->it_prof_expires = cputime_zero;\n\tsig->it_prof_incr = cputime_zero;\n\n\t/* Cached expiration times. */\n\tsig->cputime_expires.prof_exp = cputime_zero;\n\tsig->cputime_expires.virt_exp = cputime_zero;\n\tsig->cputime_expires.sched_exp = 0;\n\n\t/* The timer lists. */\n\tINIT_LIST_HEAD(&sig->cpu_timers[0]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[1]);\n\tINIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-0028",
        "length": 189
    },
    {
        "index": 107952,
        "code": "void LinkInfoBar::LinkActivated(views::Link* source, int event_flags) {\n  DCHECK(source == link_);\n  if (GetDelegate()->LinkClicked(\n          event_utils::DispositionFromEventFlags(event_flags))) {\n    RemoveInfoBar();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 55
    },
    {
        "index": 138549,
        "code": "void setLayoutTestMode(bool value)\n{\n    LayoutTestSupport::setIsRunningLayoutTest(value);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1281",
        "length": 23
    },
    {
        "index": 177758,
        "code": " bool asn1_write_BOOLEAN_context(struct asn1_data *data, bool v, int context)\n {\n       asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context));\n       asn1_write_uint8(data, v ? 0xFF : 0);\n       asn1_pop_tag(data);\n       return !data->has_error;\n }\n",
        "line": "       asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context));\n       asn1_write_uint8(data, v ? 0xFF : 0);\n       asn1_pop_tag(data);\n       return !data->has_error;\n",
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2015-7540",
        "length": 67
    },
    {
        "index": 64960,
        "code": "IW_IMPL(void) iw_destroy_context(struct iw_context *ctx)\n{\n\tint i;\n\tif(!ctx) return;\n\tif(ctx->req.options) {\n\t\tfor(i=0; i<=ctx->req.options_count; i++) {\n\t\t\tiw_free(ctx, ctx->req.options[i].name);\n\t\t\tiw_free(ctx, ctx->req.options[i].val);\n\t\t}\n\t\tiw_free(ctx, ctx->req.options);\n\t}\n\tif(ctx->img1.pixels) iw_free(ctx,ctx->img1.pixels);\n\tif(ctx->img2.pixels) iw_free(ctx,ctx->img2.pixels);\n\tif(ctx->error_msg) iw_free(ctx,ctx->error_msg);\n\tif(ctx->optctx.tmp_pixels) iw_free(ctx,ctx->optctx.tmp_pixels);\n\tif(ctx->optctx.palette) iw_free(ctx,ctx->optctx.palette);\n\tif(ctx->input_color_corr_table) iw_free(ctx,ctx->input_color_corr_table);\n\tif(ctx->output_rev_color_corr_table) iw_free(ctx,ctx->output_rev_color_corr_table);\n\tif(ctx->nearest_color_table) iw_free(ctx,ctx->nearest_color_table);\n\tif(ctx->prng) iwpvt_prng_destroy(ctx,ctx->prng);\n\tiw_free(ctx,ctx);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2017-9202",
        "length": 265
    },
    {
        "index": 19960,
        "code": "nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nfs_open_context *ctx)\n{\n\tstruct dentry *de = dentry;\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred = NULL;\n\tfmode_t fmode = 0;\n\tint status = 0;\n\n\tif (ctx != NULL) {\n\t\tcred = ctx->cred;\n\t\tde = ctx->dentry;\n\t\tfmode = ctx->mode;\n\t}\n\tsattr->ia_mode &= ~current_umask();\n\tstate = nfs4_do_open(dir, de, fmode, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (ctx != NULL)\n\t\tctx->state = state;\n\telse\n\t\tnfs4_close_sync(state, fmode);\nout:\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 223
    },
    {
        "index": 81706,
        "code": "static void ff_jref_idct2_put(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n{\n    ff_j_rev_dct2 (block);\n    put_pixels_clamped2_c(block, dest, line_size);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-12460",
        "length": 54
    },
    {
        "index": 10291,
        "code": "  open_face_PS_from_sfnt_stream( FT_Library     library,\n                                 FT_Stream      stream,\n                                 FT_Long        face_index,\n                                 FT_Int         num_params,\n                                 FT_Parameter  *params,\n                                 FT_Face       *aface )\n  {\n    FT_Error   error;\n    FT_Memory  memory = library->memory;\n    FT_ULong   offset, length;\n    FT_Long    pos;\n    FT_Bool    is_sfnt_cid;\n    FT_Byte*   sfnt_ps;\n\n    FT_UNUSED( num_params );\n    FT_UNUSED( params );\n\n\n    pos = FT_Stream_Pos( stream );\n\n    error = ft_lookup_PS_in_sfnt_stream( stream,\n                                         face_index,\n                                         &offset,\n                                         &length,\n                                         &is_sfnt_cid );\n    if ( error )\n      goto Exit;\n\n    if ( FT_Stream_Seek( stream, pos + offset ) )\n      goto Exit;\n\n    if ( FT_ALLOC( sfnt_ps, (FT_Long)length ) )\n      goto Exit;\n\n    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_ps, length );\n    if ( error )\n      goto Exit;\n\n    error = open_face_from_buffer( library,\n                                   sfnt_ps,\n                                   length,\n                                   face_index < 0 ? face_index : 0,\n                                   is_sfnt_cid ? \"cid\" : \"type1\",\n                                   aface );\n  Exit:\n    {\n      FT_Error  error1;\n\n\n      if ( error == FT_Err_Unknown_File_Format )\n      {\n        error1 = FT_Stream_Seek( stream, pos );\n        if ( error1 )\n          return error1;\n      }\n\n      return error;\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2010-2519",
        "length": 346
    },
    {
        "index": 121433,
        "code": "DevToolsWindow::InspectedWebContentsObserver::InspectedWebContentsObserver(\n    content::WebContents* web_contents)\n    : WebContentsObserver(web_contents) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-2874",
        "length": 36
    },
    {
        "index": 156560,
        "code": "  bool has_web_ui_bindings() const {\n    return enabled_bindings_ & kWebUIBindingsPolicyMask;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-18345",
        "length": 25
    },
    {
        "index": 69844,
        "code": "circuit_consider_sending_sendme(circuit_t *circ, crypt_path_t *layer_hint)\n{\n  while ((layer_hint ? layer_hint->deliver_window : circ->deliver_window) <=\n          CIRCWINDOW_START - CIRCWINDOW_INCREMENT) {\n    log_debug(LD_CIRC,\"Queuing circuit sendme.\");\n    if (layer_hint)\n      layer_hint->deliver_window += CIRCWINDOW_INCREMENT;\n    else\n      circ->deliver_window += CIRCWINDOW_INCREMENT;\n    if (relay_send_command_from_edge(0, circ, RELAY_COMMAND_SENDME,\n                                     NULL, 0, layer_hint) < 0) {\n      log_warn(LD_CIRC,\n               \"relay_send_command_from_edge failed. Circuit's closed.\");\n      return; /* the circuit's closed, don't continue */\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2017-0376",
        "length": 172
    },
    {
        "index": 45654,
        "code": "static void cryptd_free(struct crypto_instance *inst)\n{\n\tstruct cryptd_instance_ctx *ctx = crypto_instance_ctx(inst);\n\tstruct hashd_instance_ctx *hctx = crypto_instance_ctx(inst);\n\tstruct aead_instance_ctx *aead_ctx = crypto_instance_ctx(inst);\n\n\tswitch (inst->alg.cra_flags & CRYPTO_ALG_TYPE_MASK) {\n\tcase CRYPTO_ALG_TYPE_AHASH:\n\t\tcrypto_drop_shash(&hctx->spawn);\n\t\tkfree(ahash_instance(inst));\n\t\treturn;\n\tcase CRYPTO_ALG_TYPE_AEAD:\n\t\tcrypto_drop_spawn(&aead_ctx->aead_spawn.base);\n\t\tkfree(inst);\n\t\treturn;\n\tdefault:\n\t\tcrypto_drop_spawn(&ctx->spawn);\n\t\tkfree(inst);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 155
    },
    {
        "index": 185399,
        "code": " NativeStackSamplerWin::NativeStackSamplerWin(win::ScopedHandle thread_handle)\n    : thread_handle_(thread_handle.Take()) {\n }\n",
        "line": "    : thread_handle_(thread_handle.Take()) {\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 28
    },
    {
        "index": 164524,
        "code": "static void checkPtrmap(\n  IntegrityCk *pCheck,   /* Integrity check context */\n  Pgno iChild,           /* Child page number */\n  u8 eType,              /* Expected pointer map type */\n  Pgno iParent           /* Expected pointer map parent page number */\n){\n  int rc;\n  u8 ePtrmapType;\n  Pgno iPtrmapParent;\n\n  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;\n    checkAppendMsg(pCheck, \"Failed to read ptrmap key=%d\", iChild);\n    return;\n  }\n\n  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){\n    checkAppendMsg(pCheck,\n      \"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)\",\n      iChild, eType, iParent, ePtrmapType, iPtrmapParent);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-5827",
        "length": 243
    },
    {
        "index": 102744,
        "code": "    MockLayerTreeHost(TestHooks* testHooks, CCLayerTreeHostClient* client, PassRefPtr<LayerChromium> rootLayer, const CCSettings& settings)\n        : CCLayerTreeHost(client, rootLayer, settings)\n        , m_testHooks(testHooks)\n    {\n        bool success = initialize();\n        ASSERT(success);\n        UNUSED_PARAM(success);\n    }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2881",
        "length": 78
    },
    {
        "index": 33128,
        "code": "static int verify_userspi_info(struct xfrm_userspi_info *p)\n{\n\tswitch (p->info.id.proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\t/* IPCOMP spi is 16-bits. */\n\t\tif (p->max >= 0x10000)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (p->min > p->max)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-1826",
        "length": 106
    },
    {
        "index": 62374,
        "code": " atmarp_addr_print(netdissect_options *ndo,\n \t\t  const u_char *ha, u_int ha_len, const u_char *srca,\n    u_int srca_len)\n{\n\tif (ha_len == 0)\n\t\tND_PRINT((ndo, \"<No address>\"));\n\telse {\n\t\tND_PRINT((ndo, \"%s\", linkaddr_string(ndo, ha, LINKADDR_ATM, ha_len)));\n\t\tif (srca_len != 0)\n\t\t\tND_PRINT((ndo, \",%s\",\n\t\t\t\t  linkaddr_string(ndo, srca, LINKADDR_ATM, srca_len)));\n \t}\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13013",
        "length": 133
    },
    {
        "index": 108178,
        "code": "void GLES2DecoderTestBase::DoBindBuffer(\n    GLenum target, GLuint client_id, GLuint service_id) {\n  EXPECT_CALL(*gl_, BindBuffer(target, service_id))\n      .Times(1)\n      .RetiresOnSaturation();\n  BindBuffer cmd;\n  cmd.Init(target, client_id);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 79
    },
    {
        "index": 6919,
        "code": "smp_fetch_proto_http(const struct arg *args, struct sample *smp, const char *kw, void *private)\n{\n\t/* Note: hdr_idx.v cannot be NULL in this ACL because the ACL is tagged\n\t * as a layer7 ACL, which involves automatic allocation of hdr_idx.\n\t */\n\n\tCHECK_HTTP_MESSAGE_FIRST_PERM();\n\n\tsmp->data.type = SMP_T_BOOL;\n\tsmp->data.u.sint = 1;\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-11469",
        "length": 98
    },
    {
        "index": 86830,
        "code": "static TEE_Result copy_in_attrs(struct user_ta_ctx *utc,\n\t\t\tconst struct utee_attribute *usr_attrs,\n\t\t\tuint32_t attr_count, TEE_Attribute *attrs)\n{\n\tTEE_Result res;\n\tuint32_t n;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t(uaddr_t)usr_attrs,\n\t\t\tattr_count * sizeof(struct utee_attribute));\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tfor (n = 0; n < attr_count; n++) {\n\t\tattrs[n].attributeID = usr_attrs[n].attribute_id;\n\t\tif (attrs[n].attributeID & TEE_ATTR_BIT_VALUE) {\n\t\t\tattrs[n].content.value.a = usr_attrs[n].a;\n\t\t\tattrs[n].content.value.b = usr_attrs[n].b;\n\t\t} else {\n\t\t\tuintptr_t buf = usr_attrs[n].a;\n\t\t\tsize_t len = usr_attrs[n].b;\n\n\t\t\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\tTEE_MEMORY_ACCESS_READ |\n\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER, buf, len);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tattrs[n].content.ref.buffer = (void *)buf;\n\t\t\tattrs[n].content.ref.length = len;\n\t\t}\n\t}\n\n\treturn TEE_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-1010298",
        "length": 292
    },
    {
        "index": 4987,
        "code": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n{\n    if (ctx->cleanup)\n        ctx->cleanup(ctx);\n    if (ctx->param != NULL) {\n        if (ctx->parent == NULL)\n            X509_VERIFY_PARAM_free(ctx->param);\n        ctx->param = NULL;\n    }\n    if (ctx->tree != NULL) {\n        X509_policy_tree_free(ctx->tree);\n        ctx->tree = NULL;\n    }\n    if (ctx->chain != NULL) {\n        sk_X509_pop_free(ctx->chain, X509_free);\n        ctx->chain = NULL;\n    }\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n    memset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1793",
        "length": 169
    },
    {
        "index": 131635,
        "code": "static void readOnlyVoidMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::readOnlyVoidMethodMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 69
    },
    {
        "index": 160045,
        "code": "void BackendImpl::GetStats(StatsItems* stats) {\n  if (disabled_)\n    return;\n\n  std::pair<std::string, std::string> item;\n\n  item.first = \"Entries\";\n  item.second = base::IntToString(data_->header.num_entries);\n  stats->push_back(item);\n\n  item.first = \"Pending IO\";\n  item.second = base::IntToString(num_pending_io_);\n  stats->push_back(item);\n\n  item.first = \"Max size\";\n  item.second = base::IntToString(max_size_);\n  stats->push_back(item);\n\n  item.first = \"Current size\";\n  item.second = base::IntToString(data_->header.num_bytes);\n  stats->push_back(item);\n\n  item.first = \"Cache type\";\n  item.second = \"Blockfile Cache\";\n  stats->push_back(item);\n\n  stats_.GetItems(stats);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6085",
        "length": 178
    },
    {
        "index": 73696,
        "code": "static zend_object *spl_object_storage_clone(zval *zobject)\n{\n\tzend_object *old_object;\n\tzend_object *new_object;\n\n\told_object = Z_OBJ_P(zobject);\n\tnew_object = spl_object_storage_new_ex(old_object->ce, zobject);\n\n\tzend_objects_clone_members(new_object, old_object);\n\n\treturn new_object;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-7480",
        "length": 71
    },
    {
        "index": 22907,
        "code": "static void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\targs->bitmask = server->attr_bitmask;\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4324",
        "length": 95
    },
    {
        "index": 99500,
        "code": "static bool NPN_InvokeDefault(NPP, NPObject *npObject, const NPVariant* arguments, uint32_t argumentCount, NPVariant* result)\n{\n    if (npObject->_class->invokeDefault)\n        return npObject->_class->invokeDefault(npObject, arguments, argumentCount, result);\n\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 69
    },
    {
        "index": 45968,
        "code": "usage(void)\n{\n\t(void)fprintf(stderr, USAGE, progname, progname, progname);\n\texit(1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-9620",
        "length": 27
    },
    {
        "index": 45207,
        "code": "psf_fclose (SF_PRIVATE *psf)\n{\tint retval ;\n\n\tif (psf->virtual_io)\n\t\treturn 0 ;\n\n\tif (psf->file.do_not_close_descriptor)\n\t{\tpsf->file.filedes = -1 ;\n\t\treturn 0 ;\n\t\t} ;\n\n\tif ((retval = psf_close_fd (psf->file.filedes)) == -1)\n\t\tpsf_log_syserr (psf, errno) ;\n\n\tpsf->file.filedes = -1 ;\n\n\treturn retval ;\n} /* psf_fclose */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-9756",
        "length": 117
    },
    {
        "index": 11981,
        "code": "static void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap)\n{\n    int cmp;\n    unsigned int shift;\n    const unsigned char *seq = s->s3->read_sequence;\n\n    cmp = satsub64be(seq, bitmap->max_seq_num);\n    if (cmp > 0) {\n        shift = cmp;\n        if (shift < sizeof(bitmap->map) * 8)\n            bitmap->map <<= shift, bitmap->map |= 1UL;\n        else\n            bitmap->map = 1UL;\n        memcpy(bitmap->max_seq_num, seq, 8);\n    } else {\n        shift = -cmp;\n        if (shift < sizeof(bitmap->map) * 8)\n            bitmap->map |= 1UL << shift;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-1559",
        "length": 168
    },
    {
        "index": 72893,
        "code": "static int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-9557",
        "length": 94
    },
    {
        "index": 53030,
        "code": "static bool bpf_dname_reserved(const struct dentry *dentry)\n{\n\treturn strchr(dentry->d_name.name, '.');\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-4558",
        "length": 29
    },
    {
        "index": 177582,
        "code": "   virtual ~Trans16x16TestBase() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 12
    },
    {
        "index": 153360,
        "code": "Tab::~Tab() {\n  close_button_->RemoveObserver(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-5218",
        "length": 15
    },
    {
        "index": 157183,
        "code": "void WebMediaPlayerImpl::CreateWatchTimeReporter() {\n  if (!HasVideo() && !HasAudio())\n    return;\n\n  watch_time_reporter_.reset(new WatchTimeReporter(\n      mojom::PlaybackProperties::New(pipeline_metadata_.has_audio,\n                                     pipeline_metadata_.has_video, false, false,\n                                     !!chunk_demuxer_, is_encrypted_,\n                                     embedded_media_experience_enabled_),\n      pipeline_metadata_.natural_size,\n      base::BindRepeating(&WebMediaPlayerImpl::GetCurrentTimeInternal,\n                          base::Unretained(this)),\n      media_metrics_provider_.get(),\n      frame_->GetTaskRunner(blink::TaskType::kInternalMedia)));\n  watch_time_reporter_->OnVolumeChange(volume_);\n  watch_time_reporter_->OnDurationChanged(GetPipelineMediaDuration());\n\n  if (delegate_->IsFrameHidden())\n    watch_time_reporter_->OnHidden();\n  else\n    watch_time_reporter_->OnShown();\n\n  if (client_->HasNativeControls())\n    watch_time_reporter_->OnNativeControlsEnabled();\n  else\n    watch_time_reporter_->OnNativeControlsDisabled();\n\n  switch (client_->DisplayType()) {\n    case WebMediaPlayer::DisplayType::kInline:\n      watch_time_reporter_->OnDisplayTypeInline();\n      break;\n    case WebMediaPlayer::DisplayType::kFullscreen:\n      watch_time_reporter_->OnDisplayTypeFullscreen();\n      break;\n    case WebMediaPlayer::DisplayType::kPictureInPicture:\n      watch_time_reporter_->OnDisplayTypePictureInPicture();\n      break;\n  }\n\n  UpdateSecondaryProperties();\n\n  if (!paused_ && !seeking_)\n    watch_time_reporter_->OnPlaying();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 339
    },
    {
        "index": 166963,
        "code": "CSSStyleSheet* CSSStyleSheet::Create(Document& document,\n                                     const String& text,\n                                     ExceptionState& exception_state) {\n  return CSSStyleSheet::Create(document, text, CSSStyleSheetInit(),\n                               exception_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-6164",
        "length": 45
    },
    {
        "index": 125904,
        "code": "bool FramerVisitorCapturingAcks::OnPacketHeader(\n    const QuicPacketHeader& header) {\n  header_ = header;\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-5147",
        "length": 35
    },
    {
        "index": 169298,
        "code": "void PwnMessageHelper::RegisterBlobURL(RenderProcessHost* process,\n                                       GURL url,\n                                       std::string uuid) {\n  IPC::IpcSecurityTestUtil::PwnMessageReceived(\n      process->GetChannel(), BlobHostMsg_RegisterPublicURL(url, uuid));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6121",
        "length": 58
    },
    {
        "index": 19113,
        "code": "static void __tcp_v6_send_check(struct sk_buff *skb,\n\t\t\t\tconst struct in6_addr *saddr, const struct in6_addr *daddr)\n{\n\tstruct tcphdr *th = tcp_hdr(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tth->check = ~tcp_v6_check(skb->len, saddr, daddr, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct tcphdr, check);\n\t} else {\n\t\tth->check = tcp_v6_check(skb->len, saddr, daddr,\n\t\t\t\t\t csum_partial(th, th->doff << 2,\n\t\t\t\t\t\t      skb->csum));\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 164
    },
    {
        "index": 66207,
        "code": "static int mailimf_minute_parse(const char * message, size_t length,\n\t\t\t\tsize_t * indx, int * result)\n{\n  uint32_t minute;\n  int r;\n\n  r = mailimf_number_parse(message, length, indx, &minute);\n  if (r != MAILIMF_NO_ERROR)\n    return r;\n\n  * result = minute;\n\n  return MAILIMF_NO_ERROR;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-8825",
        "length": 85
    },
    {
        "index": 29210,
        "code": "static int nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)\n{\n\tstruct nfs4_exception exception = {\n\t\t.state = state,\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\n\tdo {\n\t\terr = _nfs4_proc_setlk(state, cmd, request);\n\t\tif (err == -NFS4ERR_DENIED)\n\t\t\terr = -EAGAIN;\n\t\terr = nfs4_handle_exception(NFS_SERVER(state->inode),\n\t\t\t\terr, &exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4591",
        "length": 120
    },
    {
        "index": 150296,
        "code": "void PasswordAutofillAgent::FireSubmissionIfFormDisappear(\n    SubmissionIndicatorEvent event) {\n  if (!browser_has_form_to_process_)\n    return;\n  DCHECK(FrameCanAccessPasswordManager());\n\n  WebLocalFrame* frame = render_frame()->GetWebFrame();\n  if (event != SubmissionIndicatorEvent::DOM_MUTATION_AFTER_XHR) {\n    bool is_last_updated_field_in_form =\n        last_updated_form_renderer_id_ != FormData::kNotSetFormRendererId;\n    if (is_last_updated_field_in_form) {\n      if (IsFormVisible(frame, last_updated_form_renderer_id_))\n        return;\n    } else {\n      if (IsFormControlVisible(frame, last_updated_field_renderer_id_))\n        return;\n    }\n  }\n  GetPasswordManagerDriver()->SameDocumentNavigation(event);\n  browser_has_form_to_process_ = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5053",
        "length": 175
    },
    {
        "index": 70705,
        "code": "strtok_r(char *s, const char *delim, char **state) {\n\tchar *cp, *start;\n\tstart = cp = s ? s : *state;\n\tif (!cp)\n\t\treturn NULL;\n\twhile (*cp && !strchr(delim, *cp))\n\t\t++cp;\n\tif (!*cp) {\n\t\tif (cp == start)\n\t\t\treturn NULL;\n\t\t*state = NULL;\n\t\treturn start;\n\t} else {\n\t\t*cp++ = '\\0';\n\t\t*state = cp;\n\t\treturn start;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10197",
        "length": 118
    },
    {
        "index": 116971,
        "code": "void IndexedDBDispatcher::RequestIDBObjectStoreGet(\n    const IndexedDBKey& key,\n    WebIDBCallbacks* callbacks_ptr,\n    int32 idb_object_store_id,\n    const WebIDBTransaction& transaction,\n    WebExceptionCode* ec) {\n  ResetCursorPrefetchCaches();\n  scoped_ptr<WebIDBCallbacks> callbacks(callbacks_ptr);\n\n  int32 response_id = pending_callbacks_.Add(callbacks.release());\n  Send(new IndexedDBHostMsg_ObjectStoreGet(\n           idb_object_store_id, CurrentWorkerId(), response_id,\n           key, TransactionId(transaction), ec));\n  if (*ec)\n    pending_callbacks_.Remove(response_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3091",
        "length": 142
    },
    {
        "index": 50803,
        "code": "idr_init(struct iso9660 *iso9660, struct vdd *vdd, struct idr *idr)\n{\n\n\tidr->idrent_pool = NULL;\n\tidr->pool_size = 0;\n\tif (vdd->vdd_type != VDD_JOLIET) {\n\t\tif (iso9660->opt.iso_level <= 3) {\n\t\t\tmemcpy(idr->char_map, d_characters_map,\n\t\t\t    sizeof(idr->char_map));\n\t\t} else {\n\t\t\tmemcpy(idr->char_map, d1_characters_map,\n\t\t\t    sizeof(idr->char_map));\n\t\t\tidr_relaxed_filenames(idr->char_map);\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-6250",
        "length": 142
    },
    {
        "index": 54542,
        "code": "static int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_dlog(c->fc, \"keyframe_count = %d\\n\", entries);\n\n    if (!entries)\n    {\n        sc->keyframe_absent = 1;\n        return 0;\n    }\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    sc->keyframes = av_malloc(entries * sizeof(int));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n    sc->keyframe_count = entries;\n\n    for (i=0; i<entries; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n    }\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3062",
        "length": 251
    },
    {
        "index": 16923,
        "code": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n    unsigned int nb_clusters, enum qcow2_discard_type type)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t *l2_table;\n    int l2_index;\n    int ret;\n    int i;\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n    if (ret < 0) {\n        return ret;\n    }\n\n    /* Limit nb_clusters to one L2 table */\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n    for (i = 0; i < nb_clusters; i++) {\n        uint64_t old_offset;\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n        /*\n         * Make sure that a discarded area reads back as zeroes for v3 images\n         * (we cannot do it for v2 without actually writing a zero-filled\n         * buffer). We can skip the operation if the cluster is already marked\n         * as zero, or if it's unallocated and we don't have a backing file.\n         *\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n         * holding s->lock, so that doesn't work today.\n         */\n        if (old_offset & QCOW_OFLAG_ZERO) {\n            continue;\n        }\n\n        if ((old_offset & L2E_OFFSET_MASK) == 0 && !bs->backing_hd) {\n            continue;\n        }\n\n        /* First remove L2 entries */\n        qcow2_cache_entry_mark_dirty(s->l2_table_cache, l2_table);\n        if (s->qcow_version >= 3) {\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n        } else {\n            l2_table[l2_index + i] = cpu_to_be64(0);\n        }\n\n        /* Then decrease the refcount */\n        qcow2_free_any_clusters(bs, old_offset, 1, type);\n    }\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return nb_clusters;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2014-0143",
        "length": 491
    },
    {
        "index": 28833,
        "code": "void kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tstruct kvm_userspace_memory_region mem;\n\t\tmemset(&mem, 0, sizeof(mem));\n\t\tmem.slot = APIC_ACCESS_PAGE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = IDENTITY_PAGETABLE_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\n\t\tmem.slot = TSS_PRIVATE_MEMSLOT;\n\t\tkvm_set_memory_region(kvm, &mem);\n\t}\n\tkvm_iommu_unmap_guest(kvm);\n\tkfree(kvm->arch.vpic);\n\tkfree(kvm->arch.vioapic);\n\tkvm_free_vcpus(kvm);\n\tif (kvm->arch.apic_access_page)\n\t\tput_page(kvm->arch.apic_access_page);\n\tif (kvm->arch.ept_identity_pagetable)\n\t\tput_page(kvm->arch.ept_identity_pagetable);\n\tkfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-6368",
        "length": 263
    },
    {
        "index": 54641,
        "code": "static struct snd_seq_queue *queue_new(int owner, int locked)\n{\n\tstruct snd_seq_queue *q;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tspin_lock_init(&q->owner_lock);\n\tspin_lock_init(&q->check_lock);\n\tmutex_init(&q->timer_mutex);\n\tsnd_use_lock_init(&q->use_lock);\n\tq->queue = -1;\n\n\tq->tickq = snd_seq_prioq_new();\n\tq->timeq = snd_seq_prioq_new();\n\tq->timer = snd_seq_timer_new();\n\tif (q->tickq == NULL || q->timeq == NULL || q->timer == NULL) {\n\t\tsnd_seq_prioq_delete(&q->tickq);\n\t\tsnd_seq_prioq_delete(&q->timeq);\n\t\tsnd_seq_timer_delete(&q->timer);\n\t\tkfree(q);\n\t\treturn NULL;\n\t}\n\n\tq->owner = owner;\n\tq->locked = locked;\n\tq->klocked = 0;\n\n\treturn q;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2544",
        "length": 215
    },
    {
        "index": 54630,
        "code": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2016-2546",
        "length": 92
    },
    {
        "index": 31492,
        "code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t/* first fragment, reserve header_len */\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * this fragment is not first, the headers\n\t\t\t * space is regarded as data space.\n\t\t\t */\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2232",
        "length": 173
    },
    {
        "index": 113900,
        "code": "void HTMLDocumentParser::resumeParsingAfterYield()\n{\n    RefPtr<HTMLDocumentParser> protect(this);\n\n    pumpTokenizer(AllowYield);\n    endIfDelayed();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 37
    },
    {
        "index": 169633,
        "code": "std::string TestURLLoader::TestTrustedCrossOriginRequest() {\n  pp::URLRequestInfo request(instance_);\n  std::string cross_origin_url = GetReachableCrossOriginURL(\"test_case.html\");\n  request.SetURL(cross_origin_url);\n  request.SetAllowCrossOriginRequests(true);\n\n  int32_t rv = OpenTrusted(request, NULL);\n  if (rv != PP_OK)\n    return ReportError(\"Trusted cross-origin request failed\", rv);\n\n  PASS();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-1675",
        "length": 100
    },
    {
        "index": 10576,
        "code": "  Ins_ABS( FT_Long*  args )\n  {\n    if ( args[0] < 0 )\n      args[0] = NEG_LONG( args[0] );\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-6942",
        "length": 40
    },
    {
        "index": 67316,
        "code": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-7533",
        "length": 27
    },
    {
        "index": 87108,
        "code": "CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)\n{\n    cJSON *item = cJSON_New_Item(&global_hooks);\n    if(item)\n    {\n        item->type = cJSON_Number;\n        item->valuedouble = num;\n\n        /* use saturation in case of overflow */\n        if (num >= INT_MAX)\n        {\n            item->valueint = INT_MAX;\n        }\n        else if (num <= (double)INT_MIN)\n        {\n            item->valueint = INT_MIN;\n        }\n        else\n        {\n            item->valueint = (int)num;\n        }\n    }\n\n    return item;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-754",
        "cve": "CVE-2019-1010239",
        "length": 129
    },
    {
        "index": 133931,
        "code": "bool AppListControllerDelegate::UserMayModifySettings(\n    Profile* profile,\n    const std::string& app_id) {\n  const extensions::Extension* extension = GetExtension(profile, app_id);\n  const extensions::ManagementPolicy* policy =\n      extensions::ExtensionSystem::Get(profile)->management_policy();\n  return extension &&\n         policy->UserMayModifySettings(extension, NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6644",
        "length": 79
    },
    {
        "index": 52150,
        "code": "PHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tint dir_len, prefix_len;\n\tsize_t p_len;\n\tchar *opened_path;\n\tchar *p;\n\tint fd;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp\", &dir, &dir_len, &prefix, &prefix_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_basename(prefix, prefix_len, NULL, 0, &p, &p_len TSRMLS_CC);\n\tif (p_len > 64) {\n\t\tp[63] = '\\0';\n\t}\n\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd_ex(dir, p, &opened_path, 1 TSRMLS_CC)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STRING(opened_path, 0);\n\t}\n\tefree(p);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5096",
        "length": 194
    },
    {
        "index": 71666,
        "code": "static void WritePackbitsLength(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  unsigned char *compact_pixels,const QuantumType quantum_type)\n{\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  size_t\n    length,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  packet_size=next_image->depth > 8UL ? 2UL : 1UL;\n  (void) packet_size;\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  pixels=GetQuantumPixels(quantum_info);\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,&image->exception);\n    length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels);\n    (void) SetPSDOffset(psd_info,image,length);\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10066",
        "length": 298
    },
    {
        "index": 172703,
        "code": "status_t MediaRecorder::prepare()\n{\n    ALOGV(\"prepare\");\n if (mMediaRecorder == NULL) {\n        ALOGE(\"media recorder is not initialized yet\");\n return INVALID_OPERATION;\n }\n if (!(mCurrentState & MEDIA_RECORDER_DATASOURCE_CONFIGURED)) {\n        ALOGE(\"prepare called in an invalid state: %d\", mCurrentState);\n return INVALID_OPERATION;\n }\n if (mIsAudioSourceSet != mIsAudioEncoderSet) {\n if (mIsAudioSourceSet) {\n            ALOGE(\"audio source is set, but audio encoder is not set\");\n } else { // must not happen, since setAudioEncoder checks this already\n            ALOGE(\"audio encoder is set, but audio source is not set\");\n }\n return INVALID_OPERATION;\n }\n\n if (mIsVideoSourceSet != mIsVideoEncoderSet) {\n if (mIsVideoSourceSet) {\n            ALOGE(\"video source is set, but video encoder is not set\");\n } else { // must not happen, since setVideoEncoder checks this already\n            ALOGE(\"video encoder is set, but video source is not set\");\n }\n return INVALID_OPERATION;\n }\n\n status_t ret = mMediaRecorder->prepare();\n if (OK != ret) {\n        ALOGE(\"prepare failed: %d\", ret);\n        mCurrentState = MEDIA_RECORDER_ERROR;\n return ret;\n }\n    mCurrentState = MEDIA_RECORDER_PREPARED;\n return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-3821",
        "length": 291
    },
    {
        "index": 46891,
        "code": "static void __exit cast5_exit(void)\n{\n\tcrypto_unregister_algs(cast5_algs, ARRAY_SIZE(cast5_algs));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 31
    },
    {
        "index": 80365,
        "code": "GF_Err rtpo_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_RTPOBox *ptr = (GF_RTPOBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->timeOffset);\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 90
    },
    {
        "index": 120653,
        "code": "void Element::setStyleAffectedByEmpty()\n{\n    ensureElementRareData()->setStyleAffectedByEmpty(true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2884",
        "length": 25
    },
    {
        "index": 158211,
        "code": "void InstallablePaymentAppCrawler::OnPaymentWebAppInstallationInfo(\n    const GURL& method_manifest_url,\n    const GURL& web_app_manifest_url,\n    std::unique_ptr<WebAppInstallationInfo> app_info,\n    std::unique_ptr<std::vector<PaymentManifestParser::WebAppIcon>> icons) {\n  number_of_web_app_manifest_to_parse_--;\n\n  if (CompleteAndStorePaymentWebAppInfoIfValid(\n          method_manifest_url, web_app_manifest_url, std::move(app_info))) {\n    DownloadAndDecodeWebAppIcon(method_manifest_url, web_app_manifest_url,\n                                std::move(icons));\n  }\n\n  FinishCrawlingPaymentAppsIfReady();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-20071",
        "length": 143
    },
    {
        "index": 138624,
        "code": "void RenderFrameHostImpl::AXContentTreeDataToAXTreeData(\n    ui::AXTreeData* dst) {\n  const AXContentTreeData& src = ax_content_tree_data_;\n\n  *dst = src;\n\n  if (src.routing_id != -1)\n    dst->tree_id = RoutingIDToAXTreeID(src.routing_id);\n\n  if (src.parent_routing_id != -1)\n    dst->parent_tree_id = RoutingIDToAXTreeID(src.parent_routing_id);\n\n  if (browser_plugin_embedder_ax_tree_id_ != ui::AXTreeIDRegistry::kNoAXTreeID)\n    dst->parent_tree_id = browser_plugin_embedder_ax_tree_id_;\n\n  if (frame_tree_node()->parent())\n    return;\n\n  FrameTreeNode* focused_frame_tree_node = frame_tree_->GetFocusedFrame();\n  if (!focused_frame_tree_node)\n    return;\n  RenderFrameHostImpl* focused_frame =\n      focused_frame_tree_node->current_frame_host();\n  DCHECK(focused_frame);\n  dst->focused_tree_id = focused_frame->GetAXTreeID();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1278",
        "length": 221
    },
    {
        "index": 55148,
        "code": "static void truncate_pack(struct sha1file_checkpoint *checkpoint)\n{\n\tif (sha1file_truncate(pack_file, checkpoint))\n\t\tdie_errno(\"cannot truncate pack to skip duplicate\");\n\tpack_size = checkpoint->offset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2315",
        "length": 46
    },
    {
        "index": 69985,
        "code": "size_t sdsZmallocSize(sds s) {\n    void *sh = sdsAllocPtr(s);\n    return zmalloc_size(sh);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10517",
        "length": 32
    },
    {
        "index": 172509,
        "code": "void CameraSource::ProxyListener::dataCallbackTimestamp(\n nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr) {\n    mSource->dataCallbackTimestamp(timestamp / 1000, msgType, dataPtr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3834",
        "length": 52
    },
    {
        "index": 14150,
        "code": "int __glXDisp_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n{\n    xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;\n    __GLXconfig *config;\n    __GLXscreen *pGlxScreen;\n    int err;\n\n    if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n\treturn err;\n    if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n\treturn err;\n\n    return DoCreateContext(cl, req->context, req->shareList,\n\t\t\t   config, pGlxScreen, req->isDirect);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-4818",
        "length": 155
    },
    {
        "index": 32436,
        "code": "static struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-1957",
        "length": 145
    },
    {
        "index": 54965,
        "code": "static int add_parents_only(struct rev_info *revs, const char *arg_, int flags)\n{\n\tunsigned char sha1[20];\n\tstruct object *it;\n\tstruct commit *commit;\n\tstruct commit_list *parents;\n\tconst char *arg = arg_;\n\n\tif (*arg == '^') {\n\t\tflags ^= UNINTERESTING | BOTTOM;\n\t\targ++;\n\t}\n\tif (get_sha1_committish(arg, sha1))\n\t\treturn 0;\n\twhile (1) {\n\t\tit = get_reference(revs, arg, sha1, 0);\n\t\tif (!it && revs->ignore_missing)\n\t\t\treturn 0;\n\t\tif (it->type != OBJ_TAG)\n\t\t\tbreak;\n\t\tif (!((struct tag*)it)->tagged)\n\t\t\treturn 0;\n\t\thashcpy(sha1, ((struct tag*)it)->tagged->oid.hash);\n\t}\n\tif (it->type != OBJ_COMMIT)\n\t\treturn 0;\n\tcommit = (struct commit *)it;\n\tfor (parents = commit->parents; parents; parents = parents->next) {\n\t\tit = &parents->item->object;\n\t\tit->flags |= flags;\n\t\tadd_rev_cmdline(revs, it, arg_, REV_CMD_PARENTS_ONLY, flags);\n\t\tadd_pending_object(revs, it, arg);\n\t}\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2324",
        "length": 274
    },
    {
        "index": 42366,
        "code": "static void autorun_array(struct mddev *mddev)\n{\n\tstruct md_rdev *rdev;\n\tint err;\n\n\tif (list_empty(&mddev->disks))\n\t\treturn;\n\n\tprintk(KERN_INFO \"md: running: \");\n\n\trdev_for_each(rdev, mddev) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tprintk(\"<%s>\", bdevname(rdev->bdev,b));\n\t}\n\tprintk(\"\\n\");\n\n\terr = do_md_run(mddev);\n\tif (err) {\n\t\tprintk(KERN_WARNING \"md: do_md_run() returned %d\\n\", err);\n\t\tdo_md_stop(mddev, 0, NULL);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5697",
        "length": 135
    },
    {
        "index": 65879,
        "code": "__be32 nfsd4_vfs_fallocate(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t   struct file *file, loff_t offset, loff_t len,\n\t\t\t   int flags)\n{\n\tint error;\n\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn nfserr_inval;\n\n\terror = vfs_fallocate(file, flags, offset, len);\n\tif (!error)\n\t\terror = commit_metadata(fhp);\n\n\treturn nfserrno(error);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 100
    },
    {
        "index": 102136,
        "code": "JsArgList SyncManager::SyncInternal::GetNotificationInfo(\n    const JsArgList& args) {\n  ListValue return_args;\n  return_args.Append(NotificationInfoToValue(notification_info_map_));\n  return JsArgList(&return_args);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 51
    },
    {
        "index": 99937,
        "code": "void PluginInstance::AddStream(PluginStream* stream) {\n  open_streams_.push_back(stream);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 23
    },
    {
        "index": 64979,
        "code": "IW_IMPL(void) iw_make_srgb_csdescr_2(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_SRGB;\n\tcs->gamma = 0.0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2017-9202",
        "length": 42
    },
    {
        "index": 81224,
        "code": "void tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer,\n\t\t\t  enum hrtimer_restart (*function)(struct hrtimer *),\n\t\t\t  clockid_t which_clock, enum hrtimer_mode mode)\n{\n\thrtimer_init(&ttimer->timer, which_clock, mode);\n\tttimer->timer.function = __hrtimer_tasklet_trampoline;\n\ttasklet_init(&ttimer->tasklet, __tasklet_hrtimer_trampoline,\n\t\t     (unsigned long)ttimer);\n\tttimer->function = function;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 111
    },
    {
        "index": 106791,
        "code": "bool WebPage::platformHasLocalDataForURL(const WebCore::KURL& url)\n{\n#if USE(CFNETWORK)\n    RetainPtr<CFURLRef> cfURL(AdoptCF, url.createCFURL());\n    RetainPtr<CFMutableURLRequestRef> request(AdoptCF, CFURLRequestCreateMutable(0, cfURL.get(), kCFURLRequestCachePolicyReloadIgnoringCache, 60, 0));\n    \n    RetainPtr<CFStringRef> userAgent(AdoptCF, userAgent().createCFString());\n    CFURLRequestSetHTTPHeaderFieldValue(request.get(), CFSTR(\"User-Agent\"), userAgent.get());\n\n    RetainPtr<CFURLCacheRef> cache;\n#if USE(CFURLSTORAGESESSIONS)\n    if (CFURLStorageSessionRef storageSession = ResourceHandle::privateBrowsingStorageSession())\n        cache.adoptCF(wkCopyURLCache(storageSession));\n    else\n#endif\n        cache.adoptCF(CFURLCacheCopySharedURLCache());\n\n    RetainPtr<CFCachedURLResponseRef> response(AdoptCF, CFURLCacheCopyResponseForRequest(cache.get(), request.get()));    \n    return response;\n#else\n    return false;\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 247
    },
    {
        "index": 73780,
        "code": "int bzrtp_packetUpdateSequenceNumber(bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber) {\n\tuint32_t CRC;\n\tuint8_t *CRCbuffer;\n\n\tif (zrtpPacket == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\n\tif (zrtpPacket->packetString == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\t/* update the sequence number field (even if it is probably useless as this function is called just before sending the DHPart2 packet only)*/\n\tzrtpPacket->sequenceNumber = sequenceNumber;\n\n\t/* update hte sequence number in the packetString */\n\t*(zrtpPacket->packetString+2)= (uint8_t)((sequenceNumber>>8)&0x00FF);\n\t*(zrtpPacket->packetString+3)= (uint8_t)(sequenceNumber&0x00FF);\n\n\n\t/* update the CRC */\n\tCRC = bzrtp_CRC32(zrtpPacket->packetString, zrtpPacket->messageLength+ZRTP_PACKET_HEADER_LENGTH);\n\tCRCbuffer = (zrtpPacket->packetString)+(zrtpPacket->messageLength)+ZRTP_PACKET_HEADER_LENGTH;\n\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-6271",
        "length": 341
    },
    {
        "index": 84318,
        "code": "static void close_and_free_request(struct wsgi_request *wsgi_req) {\n\n        if (!wsgi_req->fd_closed) {\n                wsgi_req->socket->proto_close(wsgi_req);\n        }\n\n        if (wsgi_req->post_file) {\n                fclose(wsgi_req->post_file);\n        }\n\n        if (wsgi_req->post_read_buf) {\n                free(wsgi_req->post_read_buf);\n        }\n\n        if (wsgi_req->post_readline_buf) {\n                free(wsgi_req->post_readline_buf);\n        }\n\n        if (wsgi_req->proto_parser_buf) {\n                free(wsgi_req->proto_parser_buf);\n        }\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-6758",
        "length": 140
    },
    {
        "index": 52287,
        "code": "static void compat_standard_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v > 0)\n\t\tv += xt_compat_calc_jump(AF_INET, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "length": 56
    },
    {
        "index": 49095,
        "code": "brcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,\n\t\t\t       struct net_device *ndev,\n\t\t\t       const struct brcmf_event_msg *e, void *data)\n{\n\tstatic int generation;\n\tu32 event = e->event_code;\n\tu32 reason = e->reason;\n\tstruct station_info sinfo;\n\n\tbrcmf_dbg(CONN, \"event %d, reason %d\\n\", event, reason);\n\tif (event == BRCMF_E_LINK && reason == BRCMF_E_REASON_LINK_BSSCFG_DIS &&\n\t    ndev != cfg_to_ndev(cfg)) {\n\t\tbrcmf_dbg(CONN, \"AP mode link down\\n\");\n\t\tcomplete(&cfg->vif_disabled);\n\t\treturn 0;\n\t}\n\n\tif (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&\n\t    (reason == BRCMF_E_STATUS_SUCCESS)) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tif (!data) {\n\t\t\tbrcmf_err(\"No IEs present in ASSOC/REASSOC_IND\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsinfo.assoc_req_ies = data;\n\t\tsinfo.assoc_req_ies_len = e->datalen;\n\t\tgeneration++;\n\t\tsinfo.generation = generation;\n\t\tcfg80211_new_sta(ndev, e->addr, &sinfo, GFP_KERNEL);\n\t} else if ((event == BRCMF_E_DISASSOC_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH_IND) ||\n\t\t   (event == BRCMF_E_DEAUTH)) {\n\t\tcfg80211_del_sta(ndev, e->addr, GFP_KERNEL);\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8658",
        "length": 363
    },
    {
        "index": 113565,
        "code": "JSRetainPtr<JSStringRef> AccessibilityUIElement::documentEncoding()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return JSStringCreateWithCharacters(0, 0);\n\n    AtkRole role = atk_object_get_role(ATK_OBJECT(m_element));\n    if (role != ATK_ROLE_DOCUMENT_FRAME)\n        return JSStringCreateWithCharacters(0, 0);\n\n    return JSStringCreateWithUTF8CString(atk_document_get_attribute_value(ATK_DOCUMENT(m_element), \"Encoding\"));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2867",
        "length": 109
    },
    {
        "index": 54375,
        "code": "krb5_encode_krbsecretkey(krb5_key_data *key_data, int n_key_data,\n                         krb5_kvno mkvno)\n{\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 0;\n    int i, j, last;\n    krb5_error_code err = 0;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Find the number of key versions */\n    if (n_key_data > 0) {\n        for (i = 0, num_versions = 1; i < n_key_data - 1; i++) {\n            if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n                num_versions++;\n        }\n    }\n\n    ret = calloc(num_versions + 1, sizeof(struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    ret[num_versions] = NULL;\n\n    /* n_key_data may be 0 if a principal is created without a key. */\n    if (n_key_data == 0)\n        goto cleanup;\n\n    currkvno = key_data[0].key_data_kvno;\n    for (i = 0, last = 0, j = 0; i < n_key_data; i++) {\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            err = encode_keys(key_data + last, (krb5_int16)i - last + 1, mkvno,\n                              &ret[j]);\n            if (err)\n                goto cleanup;\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3119",
        "length": 427
    },
    {
        "index": 171031,
        "code": "void AudioFlinger::EffectChain::setThread(const sp<ThreadBase>& thread)\n{\n Mutex::Autolock _l(mLock);\n    mThread = thread;\n for (size_t i = 0; i < mEffects.size(); i++) {\n        mEffects[i]->setThread(thread);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3924",
        "length": 65
    },
    {
        "index": 163548,
        "code": "ScriptProcessorHandler::ScriptProcessorHandler(\n    AudioNode& node,\n    float sample_rate,\n    size_t buffer_size,\n    unsigned number_of_input_channels,\n    unsigned number_of_output_channels)\n    : AudioHandler(kNodeTypeScriptProcessor, node, sample_rate),\n      double_buffer_index_(0),\n      buffer_size_(buffer_size),\n      buffer_read_write_index_(0),\n      number_of_input_channels_(number_of_input_channels),\n      number_of_output_channels_(number_of_output_channels),\n      internal_input_bus_(AudioBus::Create(number_of_input_channels,\n                                           AudioUtilities::kRenderQuantumFrames,\n                                           false)) {\n  if (buffer_size_ < AudioUtilities::kRenderQuantumFrames)\n    buffer_size_ = AudioUtilities::kRenderQuantumFrames;\n\n  DCHECK_LE(number_of_input_channels, BaseAudioContext::MaxNumberOfChannels());\n\n  AddInput();\n  AddOutput(number_of_output_channels);\n\n  channel_count_ = number_of_input_channels;\n  SetInternalChannelCountMode(kExplicit);\n\n  Initialize();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5129",
        "length": 207
    },
    {
        "index": 94563,
        "code": "static void scsi_cancel_io(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    DPRINTF(\"Cancel tag=0x%x\\n\", req->tag);\n    if (r->req.aiocb) {\n        bdrv_aio_cancel(r->req.aiocb);\n    }\n     r->req.aiocb = NULL;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3346",
        "length": 88
    },
    {
        "index": 42719,
        "code": "static inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2015-5307",
        "length": 35
    },
    {
        "index": 113272,
        "code": "  LocationBar* GetLocationBar() const {\n    return browser()->window()->GetLocationBar();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 23
    },
    {
        "index": 126832,
        "code": "void BrowserView::OnSysColorChange() {\n  chrome::MaybeShowInvertBubbleView(browser_.get(), contents_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 27
    },
    {
        "index": 184548,
        "code": " GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)\n     : host_id_(host_id),\n      gpu_process_(base::kNullProcessHandle),\n       in_process_(false),\n       software_rendering_(false),\n       kind_(kind),\n      process_launched_(false) {\n  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) ||\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU))\n    in_process_ = true;\n\n  DCHECK(!in_process_ || g_gpu_process_hosts[kind] == NULL);\n\n  g_gpu_process_hosts[kind] = this;\n\n  BrowserThread::PostTask(\n      BrowserThread::UI,\n      FROM_HERE,\n      base::Bind(base::IgnoreResult(&GpuProcessHostUIShim::Create), host_id));\n\n  process_.reset(\n      new BrowserChildProcessHostImpl(content::PROCESS_TYPE_GPU, this));\n}\n",
        "line": "      gpu_process_(base::kNullProcessHandle),\n",
        "label": 1,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 197
    },
    {
        "index": 122438,
        "code": "bool HTMLTextAreaElement::matchesReadWritePseudoClass() const\n{\n    return !isReadOnly();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0882",
        "length": 22
    },
    {
        "index": 15369,
        "code": "static int server_set_kex(ssh_session session) {\n  struct ssh_kex_struct *server = &session->next_crypto->server_kex;\n  int i, j, rc;\n  const char *wanted;\n  char hostkeys[64] = {0};\n  enum ssh_keytypes_e keytype;\n  size_t len;\n\n  ZERO_STRUCTP(server);\n  ssh_get_random(server->cookie, 16, 0);\n\n#ifdef HAVE_ECC\n  if (session->srv.ecdsa_key != NULL) {\n      snprintf(hostkeys, sizeof(hostkeys),\n               \"%s\", session->srv.ecdsa_key->type_c);\n  }\n#endif\n  if (session->srv.dsa_key != NULL) {\n      len = strlen(hostkeys);\n      keytype = ssh_key_type(session->srv.dsa_key);\n\n      snprintf(hostkeys + len, sizeof(hostkeys) - len,\n               \",%s\", ssh_key_type_to_char(keytype));\n  }\n  if (session->srv.rsa_key != NULL) {\n      len = strlen(hostkeys);\n      keytype = ssh_key_type(session->srv.rsa_key);\n\n      snprintf(hostkeys + len, sizeof(hostkeys) - len,\n               \",%s\", ssh_key_type_to_char(keytype));\n  }\n\n  if (strlen(hostkeys) == 0) {\n      return -1;\n  }\n\n  rc = ssh_options_set_algo(session,\n                            SSH_HOSTKEYS,\n                            hostkeys[0] == ',' ? hostkeys + 1 : hostkeys);\n  if (rc < 0) {\n      return -1;\n  }\n\n  for (i = 0; i < 10; i++) {\n    if ((wanted = session->opts.wanted_methods[i]) == NULL) {\n      wanted = ssh_kex_get_supported_method(i);\n    }\n    server->methods[i] = strdup(wanted);\n    if (server->methods[i] == NULL) {\n      for (j = 0; j < i; j++) {\n        SAFE_FREE(server->methods[j]);\n      }\n      return -1;\n    }\n  }\n\n  return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-3146",
        "length": 439
    },
    {
        "index": 180964,
        "code": "ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len _U_,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_KE)));\n\n\tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n \tND_PRINT((ndo,\" key len=%d\", ntohs(e.len) - 4));\n \tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n \t\tND_PRINT((ndo,\" \"));\n \t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n \t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_KE)));\n\treturn NULL;\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13690",
        "length": 243
    },
    {
        "index": 131158,
        "code": "static void activityLoggingAccessForAllWorldsMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    imp->activityLoggingAccessForAllWorldsMethod();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 59
    },
    {
        "index": 169995,
        "code": "xsltDebuggerStartSequenceConstructor(xsltTransformContextPtr ctxt,\n\t\t\t\t     xmlNodePtr contextNode,\n\t\t\t\t     xmlNodePtr list,\n\t\t\t\t     xsltTemplatePtr templ,\n\t\t\t\t     int *addCallResult)\n{\n    xmlNodePtr debugedNode = NULL;\n\n    if (ctxt->debugStatus != XSLT_DEBUG_NONE) {\n        if (templ) {\n            *addCallResult = xslAddCall(templ, templ->elem);\n        } else {\n            *addCallResult = xslAddCall(NULL, list);\n        }\n        switch (ctxt->debugStatus) {\n            case XSLT_DEBUG_RUN_RESTART:\n            case XSLT_DEBUG_QUIT:\n                if (*addCallResult)\n                    xslDropCall();\n                return(NULL);\n        }\n        if (templ) {\n            xslHandleDebugger(templ->elem, contextNode, templ, ctxt);\n            debugedNode = templ->elem;\n        } else if (list) {\n            xslHandleDebugger(list, contextNode, templ, ctxt);\n            debugedNode = list;\n        } else if (ctxt->inst) {\n            xslHandleDebugger(ctxt->inst, contextNode, templ, ctxt);\n            debugedNode = ctxt->inst;\n        }\n    }\n    return(debugedNode);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 265
    },
    {
        "index": 6101,
        "code": "e1000e_write_ps_rx_descr(E1000ECore *core, uint8_t *desc,\n                         struct NetRxPkt *pkt,\n                         const E1000E_RSSInfo *rss_info,\n                         size_t ps_hdr_len,\n                         uint16_t(*written)[MAX_PS_BUFFERS])\n{\n    int i;\n    union e1000_rx_desc_packet_split *d =\n        (union e1000_rx_desc_packet_split *) desc;\n\n    memset(&d->wb, 0, sizeof(d->wb));\n\n    d->wb.middle.length0 = cpu_to_le16((*written)[0]);\n\n    for (i = 0; i < PS_PAGE_BUFFERS; i++) {\n        d->wb.upper.length[i] = cpu_to_le16((*written)[i + 1]);\n    }\n\n    e1000e_build_rx_metadata(core, pkt, pkt != NULL,\n                             rss_info,\n                             &d->wb.lower.hi_dword.rss,\n                             &d->wb.lower.mrq,\n                             &d->wb.middle.status_error,\n                             &d->wb.lower.hi_dword.csum_ip.ip_id,\n                             &d->wb.middle.vlan);\n\n    d->wb.upper.header_status =\n        cpu_to_le16(ps_hdr_len | (ps_hdr_len ? E1000_RXDPS_HDRSTAT_HDRSP : 0));\n\n    trace_e1000e_rx_desc_ps_write((*written)[0], (*written)[1],\n                                  (*written)[2], (*written)[3]);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-9310",
        "length": 311
    },
    {
        "index": 145850,
        "code": "std::string ToString(std::unique_ptr<base::DictionaryValue> value) {\n  std::string json;\n  base::JSONWriter::Write(*value, &json);\n  return json;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-1625",
        "length": 42
    },
    {
        "index": 114974,
        "code": "void TestingAutomationProvider::IsFullscreen(int handle, bool* visible) {\n  *visible = false;\n\n  if (browser_tracker_->ContainsHandle(handle)) {\n    Browser* browser = browser_tracker_->GetResource(handle);\n    if (browser)\n      *visible = browser->window()->IsFullscreen();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 64
    },
    {
        "index": 69490,
        "code": "int ceph_encrypt2(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n\t\t  const void *src1, size_t src1_len,\n\t\t  const void *src2, size_t src2_len)\n{\n\tswitch (secret->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\tif (*dst_len < src1_len + src2_len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(dst, src1, src1_len);\n\t\tmemcpy(dst + src1_len, src2, src2_len);\n\t\t*dst_len = src1_len + src2_len;\n\t\treturn 0;\n\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_encrypt2(secret->key, secret->len, dst, dst_len,\n\t\t\t\t\t src1, src1_len, src2, src2_len);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "length": 182
    },
    {
        "index": 106561,
        "code": "void WebPageProxy::initializeContextMenuClient(const WKPageContextMenuClient* client)\n{\n    m_contextMenuClient.initialize(client);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 27
    },
    {
        "index": 163018,
        "code": "ProfilingProcessHost* ProfilingProcessHost::GetInstance() {\n  return base::Singleton<\n      ProfilingProcessHost,\n      base::LeakySingletonTraits<ProfilingProcessHost>>::get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-15411",
        "length": 42
    },
    {
        "index": 129372,
        "code": "Logger* GLES2DecoderImpl::GetLogger() {\n  return &logger_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3173",
        "length": 18
    },
    {
        "index": 78844,
        "code": "const sc_path_t *sc_get_mf_path(void)\n{\n\tstatic const sc_path_t mf_path = {\n\t\t{0x3f, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 2,\n\t\t0,\n\t\t0,\n\t\tSC_PATH_TYPE_PATH,\n\t\t{{0},0}\n\t};\n\treturn &mf_path;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-16425",
        "length": 110
    },
    {
        "index": 73591,
        "code": "static MagickBooleanType load_hierarchy(Image *image,XCFDocInfo *inDocInfo,\n   XCFLayerInfo *inLayer, ExceptionInfo *exception)\n{\n  MagickOffsetType\n    saved_pos,\n    offset,\n    junk;\n\n  size_t\n    width,\n    height,\n    bytes_per_pixel;\n\n  width=ReadBlobMSBLong(image);\n  (void) width;\n  height=ReadBlobMSBLong(image);\n  (void) height;\n  bytes_per_pixel=inDocInfo->bytes_per_pixel=ReadBlobMSBLong(image);\n  (void) bytes_per_pixel;\n\n  /* load in the levels...we make sure that the number of levels\n   *  calculated when the TileManager was created is the same\n   *  as the number of levels found in the file.\n   */\n  offset=(MagickOffsetType) ReadBlobMSBLong(image);  /* top level */\n\n  /* discard offsets for layers below first, if any.\n   */\n  do\n  {\n    junk=(MagickOffsetType) ReadBlobMSBLong(image);\n  }\n  while (junk != 0);\n\n  /* save the current position as it is where the\n   *  next level offset is stored.\n   */\n  saved_pos=TellBlob(image);\n\n  /* seek to the level offset */\n  offset=SeekBlob(image, offset, SEEK_SET);\n\n  /* read in the level */\n  if (load_level (image, inDocInfo, inLayer, exception) == 0)\n    return(MagickFalse);\n  /* restore the saved position so we'll be ready to\n   *  read the next offset.\n   */\n  offset=SeekBlob(image, saved_pos, SEEK_SET);\n  return(MagickTrue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-7529",
        "length": 363
    },
    {
        "index": 69575,
        "code": "static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    u16 selector, struct desc_struct *desc)\n{\n\tint rc;\n\tulong addr;\n\n\trc = get_descriptor_ptr(ctxt, selector, &addr);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\treturn ctxt->ops->write_std(ctxt, addr, desc, sizeof *desc,\n \t\t\t\t    &ctxt->exception);\n }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-2583",
        "length": 87
    },
    {
        "index": 159323,
        "code": "bool WebGLRenderingContextBase::ValidateReadPixelsFuncParameters(\n    GLsizei width,\n    GLsizei height,\n    GLenum format,\n    GLenum type,\n    DOMArrayBufferView* buffer,\n    long long buffer_size) {\n  if (!ValidateReadPixelsFormatAndType(format, type, buffer))\n    return false;\n\n  unsigned total_bytes_required = 0, total_skip_bytes = 0;\n  GLenum error = WebGLImageConversion::ComputeImageSizeInBytes(\n      format, type, width, height, 1, GetPackPixelStoreParams(),\n      &total_bytes_required, nullptr, &total_skip_bytes);\n  if (error != GL_NO_ERROR) {\n    SynthesizeGLError(error, \"readPixels\", \"invalid dimensions\");\n    return false;\n  }\n  if (buffer_size <\n      static_cast<long long>(total_bytes_required + total_skip_bytes)) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"readPixels\",\n                      \"buffer is not large enough for dimensions\");\n    return false;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-6034",
        "length": 209
    },
    {
        "index": 103728,
        "code": "void DevToolsClient::SendToAgent(const IPC::Message& tools_agent_message) {\n  Send(new DevToolsHostMsg_ForwardToAgent(routing_id(), tools_agent_message));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 39
    },
    {
        "index": 133016,
        "code": "void RenderWidgetHostViewAura::SelectionBoundsChanged(\n    const ViewHostMsg_SelectionBounds_Params& params) {\n  if (selection_anchor_rect_ == params.anchor_rect &&\n      selection_focus_rect_ == params.focus_rect)\n    return;\n\n  selection_anchor_rect_ = params.anchor_rect;\n  selection_focus_rect_ = params.focus_rect;\n\n  if (GetInputMethod())\n    GetInputMethod()->OnCaretBoundsChanged(this);\n\n  if (touch_editing_client_) {\n    touch_editing_client_->OnSelectionOrCursorChanged(selection_anchor_rect_,\n        selection_focus_rect_);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 120
    },
    {
        "index": 63390,
        "code": "static void ape_apply_filters(APEContext *ctx, int32_t *decoded0,\n                              int32_t *decoded1, int count)\n{\n    int i;\n\n    for (i = 0; i < APE_FILTER_LEVELS; i++) {\n        if (!ape_filter_orders[ctx->fset][i])\n            break;\n        apply_filter(ctx, ctx->filters[i], decoded0, decoded1, count,\n                     ape_filter_orders[ctx->fset][i],\n                     ape_filter_fracbits[ctx->fset][i]);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-11399",
        "length": 117
    },
    {
        "index": 24173,
        "code": "ar6000_dbglog_init_done(struct ar6_softc *ar)\n{\n    ar->dbglog_init_done = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 27
    },
    {
        "index": 160602,
        "code": "void RenderFrameImpl::FocusedNodeChanged(const WebNode& node) {\n  has_scrolled_focused_editable_node_into_rect_ = false;\n  bool is_editable = false;\n  gfx::Rect node_bounds;\n  if (!node.IsNull() && node.IsElementNode()) {\n    WebElement element = const_cast<WebNode&>(node).To<WebElement>();\n    blink::WebRect rect = element.BoundsInViewport();\n    GetRenderWidget()->ConvertViewportToWindow(&rect);\n    is_editable = element.IsEditable();\n    node_bounds = gfx::Rect(rect);\n  }\n  Send(new FrameHostMsg_FocusedNodeChanged(routing_id_, is_editable,\n                                           node_bounds));\n  GetRenderWidget()->ClearTextInputState();\n\n  {\n    SCOPED_UMA_HISTOGRAM_TIMER(\"RenderFrameObservers.FocusedNodeChanged\");\n    for (auto& observer : observers_)\n      observer.FocusedNodeChanged(node);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 191
    },
    {
        "index": 133905,
        "code": "HTMLElement* toHTMLElement(FormAssociatedElement* associatedElement)\n{\n    return const_cast<HTMLElement*>(toHTMLElement(static_cast<const FormAssociatedElement*>(associatedElement)));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-6643",
        "length": 33
    },
    {
        "index": 98779,
        "code": "  void InitializeForSeekableStream(unsigned long resource_id,\n                                   int range_request_id) {\n    resource_id_ = resource_id;\n    multibyte_response_expected_ = true;\n    channel_->Send(new PluginMsg_HTTPRangeRequestReply(\n        instance_id_, resource_id, range_request_id));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 63
    },
    {
        "index": 161847,
        "code": "void ClientDiscardableSharedMemoryManager::ReleaseFreeMemory() {\n  base::AutoLock lock(lock_);\n\n  size_t heap_size_prior_to_releasing_memory = heap_->GetSize();\n\n  heap_->ReleasePurgedMemory();\n  heap_->ReleaseFreeMemory();\n\n  if (heap_->GetSize() != heap_size_prior_to_releasing_memory)\n    MemoryUsageChanged(heap_->GetSize(), heap_->GetSizeOfFreeLists());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 86
    },
    {
        "index": 105086,
        "code": "static inline void boundaryNodeChildrenChanged(RangeBoundaryPoint& boundary, ContainerNode* container)\n{\n    if (!boundary.childBefore())\n        return;\n    if (boundary.container() != container)\n        return;\n    boundary.invalidateOffset();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2795",
        "length": 49
    },
    {
        "index": 23254,
        "code": "static int decode_attr_aclsupport(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\n\t*res = ACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_ACLSUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_ACLSUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_ACLSUPPORT;\n\t}\n\tdprintk(\"%s: ACLs supported=%u\\n\", __func__, (unsigned int)*res);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-4131",
        "length": 199
    },
    {
        "index": 122696,
        "code": "bool Extension::LoadRequiredFeatures(string16* error) {\n  if (!LoadName(error) ||\n      !LoadVersion(error))\n    return false;\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0885",
        "length": 36
    },
    {
        "index": 29735,
        "code": "static av_cold int fieldmatch_init(AVFilterContext *ctx)\n{\n    const FieldMatchContext *fm = ctx->priv;\n    AVFilterPad pad = {\n        .name         = av_strdup(\"main\"),\n        .type         = AVMEDIA_TYPE_VIDEO,\n        .filter_frame = filter_frame,\n        .config_props = config_input,\n    };\n\n    if (!pad.name)\n        return AVERROR(ENOMEM);\n    ff_insert_inpad(ctx, INPUT_MAIN, &pad);\n\n    if (fm->ppsrc) {\n        pad.name = av_strdup(\"clean_src\");\n        pad.config_props = NULL;\n        if (!pad.name)\n            return AVERROR(ENOMEM);\n        ff_insert_inpad(ctx, INPUT_CLEANSRC, &pad);\n    }\n\n    if ((fm->blockx & (fm->blockx - 1)) ||\n        (fm->blocky & (fm->blocky - 1))) {\n        av_log(ctx, AV_LOG_ERROR, \"blockx and blocky settings must be power of two\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    if (fm->combpel > fm->blockx * fm->blocky) {\n        av_log(ctx, AV_LOG_ERROR, \"Combed pixel should not be larger than blockx x blocky\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4263",
        "length": 285
    },
    {
        "index": 61434,
        "code": "static int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-834",
        "cve": "CVE-2017-14222",
        "length": 38
    },
    {
        "index": 107904,
        "code": "void BeforeTranslateInfoBar::OriginalLanguageChanged() {\n  UpdateOriginalButtonText();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 18
    },
    {
        "index": 124741,
        "code": "void RenderBlockFlow::markSiblingsWithFloatsForLayout(RenderBox* floatToRemove)\n{\n    if (!m_floatingObjects)\n        return;\n\n    const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n    FloatingObjectSetIterator end = floatingObjectSet.end();\n\n    for (RenderObject* next = nextSibling(); next; next = next->nextSibling()) {\n        if (!next->isRenderBlockFlow() || next->isFloatingOrOutOfFlowPositioned() || toRenderBlock(next)->avoidsFloats())\n            continue;\n\n        RenderBlockFlow* nextBlock = toRenderBlockFlow(next);\n        for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {\n            RenderBox* floatingBox = (*it)->renderer();\n            if (floatToRemove && floatingBox != floatToRemove)\n                continue;\n            if (nextBlock->containsFloat(floatingBox))\n                nextBlock->markAllDescendantsWithFloatsForLayout(floatingBox);\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 214
    },
    {
        "index": 39719,
        "code": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)\n{\n\tint error = may_create(dir, dentry);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tvfs_dq_init(dir);\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-0203",
        "length": 129
    },
    {
        "index": 8115,
        "code": "void Gfx::opCurveTo(Object args[], int numArgs) {\n  double x1, y1, x2, y2, x3, y3;\n\n  if (!state->isCurPt()) {\n    error(getPos(), \"No current point in curveto\");\n    return;\n  }\n  x1 = args[0].getNum();\n  y1 = args[1].getNum();\n  x2 = args[2].getNum();\n  y2 = args[3].getNum();\n  x3 = args[4].getNum();\n  y3 = args[5].getNum();\n  state->curveTo(x1, y1, x2, y2, x3, y3);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-3702",
        "length": 149
    },
    {
        "index": 72616,
        "code": "int ring_buffer_print_page_header(struct trace_seq *s)\n{\n\tstruct buffer_data_page field;\n\n\ttrace_seq_printf(s, \"\\tfield: u64 timestamp;\\t\"\n\t\t\t \"offset:0;\\tsize:%u;\\tsigned:%u;\\n\",\n\t\t\t (unsigned int)sizeof(field.time_stamp),\n\t\t\t (unsigned int)is_signed_type(u64));\n\n\ttrace_seq_printf(s, \"\\tfield: local_t commit;\\t\"\n\t\t\t \"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\",\n\t\t\t (unsigned int)offsetof(typeof(field), commit),\n\t\t\t (unsigned int)sizeof(field.commit),\n\t\t\t (unsigned int)is_signed_type(long));\n\n\ttrace_seq_printf(s, \"\\tfield: int overwrite;\\t\"\n\t\t\t \"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\",\n\t\t\t (unsigned int)offsetof(typeof(field), commit),\n\t\t\t 1,\n\t\t\t (unsigned int)is_signed_type(long));\n\n\ttrace_seq_printf(s, \"\\tfield: char data;\\t\"\n\t\t\t \"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\",\n\t\t\t (unsigned int)offsetof(typeof(field), data),\n\t\t\t (unsigned int)BUF_PAGE_SIZE,\n\t\t\t (unsigned int)is_signed_type(char));\n\n\treturn !trace_seq_has_overflowed(s);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-9754",
        "length": 266
    },
    {
        "index": 141281,
        "code": "void Document::UpdateHoverActiveState(const HitTestRequest& request,\n                                      Element* inner_element) {\n  DCHECK(!request.ReadOnly());\n\n  if (request.Active() && frame_)\n    frame_->GetEventHandler().NotifyElementActivated();\n\n  Element* inner_element_in_document = inner_element;\n\n  while (inner_element_in_document &&\n         inner_element_in_document->GetDocument() != this) {\n    inner_element_in_document->GetDocument().UpdateHoverActiveState(\n        request, inner_element_in_document);\n    inner_element_in_document =\n        inner_element_in_document->GetDocument().LocalOwner();\n  }\n\n  UpdateDistributionForFlatTreeTraversal();\n\n  UpdateActiveState(request, inner_element_in_document);\n  UpdateHoverState(request, inner_element_in_document);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 152
    },
    {
        "index": 174533,
        "code": "get_option_uint8(uint8_t *i, const struct dhcp_message *dhcp, uint8_t option)\n{\n const uint8_t *p = get_option_raw(dhcp, option);\n\n if (!p)\n return -1;\n if (i)\n *i = *(p);\n return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1503",
        "length": 62
    },
    {
        "index": 83695,
        "code": "int git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-8099",
        "length": 200
    },
    {
        "index": 19839,
        "code": "static int _nfs4_recover_proc_open(struct nfs4_opendata *data)\n{\n\tstruct inode *dir = data->dir->d_inode;\n\tstruct nfs_openres *o_res = &data->o_res;\n        int status;\n\n\tstatus = nfs4_run_open_task(data, 1);\n\tif (status != 0 || !data->rpc_done)\n\t\treturn status;\n\n\tnfs_fattr_map_and_free_names(NFS_SERVER(dir), &data->f_attr);\n\n\tnfs_refresh_inode(dir, o_res->dir_attr);\n\n\tif (o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n\t\tstatus = _nfs4_proc_open_confirm(data);\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 156
    },
    {
        "index": 7537,
        "code": "change_env (timezone_t tz)\n{\n  if (setenv_TZ (tz->tz_is_set ? tz->abbrs : NULL) != 0)\n    return false;\n  tzset ();\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7476",
        "length": 47
    },
    {
        "index": 81963,
        "code": "static long getLongInfoField(char *info, char *field) {\n    char *value = getInfoField(info,field);\n    long l;\n\n    if (!value) return LONG_MIN;\n    l = strtol(value,NULL,10);\n    zfree(value);\n    return l;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-12326",
        "length": 59
    },
    {
        "index": 48788,
        "code": "struct net_device *dev_get_by_index_rcu(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tstruct hlist_head *head = dev_index_hash(net, ifindex);\n\n\thlist_for_each_entry_rcu(dev, head, index_hlist)\n\t\tif (dev->ifindex == ifindex)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2016-8666",
        "length": 76
    },
    {
        "index": 28382,
        "code": "static int ping_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct ping_seq_afinfo *afinfo = PDE_DATA(inode);\n\treturn seq_open_net(inode, file, &afinfo->seq_ops,\n\t\t\t   sizeof(struct ping_iter_state));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6432",
        "length": 54
    },
    {
        "index": 18107,
        "code": "valgrind_append(char **dst, int valgrind_gdbserver, int valgrind_mode, int valgrind_tool, char *valgrind_path, const char *valgrind_log)\n{\n   int i = 0;\n\n   if (valgrind_tool)\n     {\n        dst[i++] = valgrind_path;\n        switch (valgrind_tool)\n          {\n           case 1: dst[i++] = \"--tool=massif\"; break;\n\n           case 2: dst[i++] = \"--tool=callgrind\"; break;\n          }\n        return i;\n     }\n   if (valgrind_gdbserver) dst[i++] = \"--db-attach=yes\";\n   if (!valgrind_mode) return 0;\n   dst[i++] = valgrind_path;\n   dst[i++] = \"--num-callers=40\";\n   dst[i++] = \"--track-origins=yes\";\n   dst[i++] = \"--malloc-fill=13\"; /* invalid pointer, make it crash */\n   if (valgrind_log)\n     {\n        static char logparam[PATH_MAX + sizeof(\"--log-file=\")];\n\n        snprintf(logparam, sizeof(logparam), \"--log-file=%s\", valgrind_log);\n        dst[i++] = logparam;\n     }\n   if (valgrind_mode & 2) dst[i++] = \"--trace-children=yes\";\n   if (valgrind_mode & 4)\n     {\n        dst[i++] = \"--leak-check=full\";\n        dst[i++] = \"--leak-resolution=high\";\n        dst[i++] = \"--track-fds=yes\";\n     }\n   if (valgrind_mode & 8) dst[i++] = \"--show-reachable=yes\";\n   return i;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-1846",
        "length": 362
    },
    {
        "index": 130981,
        "code": "static void reflectedBooleanAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_VOID(bool, cppValue, jsValue->BooleanValue());\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    imp->setBooleanAttribute(HTMLNames::reflectedbooleanattrAttr, cppValue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 99
    },
    {
        "index": 135402,
        "code": "void Document::styleResolverMayHaveChanged()\n{\n    styleResolverChanged(hasNodesWithPlaceholderStyle() ? FullStyleUpdate : AnalyzedStyleUpdate);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6768",
        "length": 32
    },
    {
        "index": 40726,
        "code": "int tipc_sock_create_local(int type, struct socket **res)\n{\n\tint rc;\n\tstruct sock *sk;\n\n\trc = sock_create_lite(AF_TIPC, type, 0, res);\n\tif (rc < 0) {\n\t\tpr_err(\"Failed to create kernel socket\\n\");\n\t\treturn rc;\n\t}\n\ttipc_sk_create(&init_net, *res, 0, 1);\n\n\tsk = (*res)->sk;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-7271",
        "length": 95
    },
    {
        "index": 143569,
        "code": "    OnDetectionWindowElapsedWithoutHighMemoryUsage() {\n  ResetInterventionState();\n  ResetInterfaces();\n  StartMonitoringIfNeeded();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1646",
        "length": 28
    },
    {
        "index": 177124,
        "code": "static status_t ConvertAvcSpecLevelToOmxAvcLevel(\n        WORD32 avcLevel, OMX_VIDEO_AVCLEVELTYPE *omxLevel) {\n for (size_t i = 0; i < NELEM(ConversionTable); ++i) {\n if (avcLevel == ConversionTable[i].avcLevel) {\n *omxLevel = ConversionTable[i].omxLevel;\n return OK;\n }\n }\n\n    ALOGE(\"ConvertAvcSpecLevelToOmxAvcLevel: %d level not supported\",\n (int32_t)avcLevel);\n\n return BAD_VALUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 123
    },
    {
        "index": 137660,
        "code": "void PrintPreviewDialogController::EraseInitiatorInfo(\n    WebContents* preview_dialog) {\n  PrintPreviewDialogMap::iterator it = preview_dialog_map_.find(preview_dialog);\n  if (it == preview_dialog_map_.end())\n    return;\n\n  RemoveObservers(it->second);\n  preview_dialog_map_[preview_dialog] = nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1300",
        "length": 72
    },
    {
        "index": 184403,
        "code": " void PrintPreviewUI::ClearAllPreviewData() {\n  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);\n }\n",
        "line": "  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);\n",
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2012-2891",
        "length": 27
    },
    {
        "index": 41991,
        "code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->type_data.reject_error;\n\t}\n\treturn key_validate(key);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-7872",
        "length": 98
    },
    {
        "index": 146086,
        "code": "void WebGL2RenderingContextBase::deleteVertexArray(\n    WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost() || !vertex_array)\n    return;\n\n  if (!vertex_array->IsDefaultObject() &&\n      vertex_array == bound_vertex_array_object_)\n    SetBoundVertexArrayObject(nullptr);\n\n  vertex_array->DeleteObject(ContextGL());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 71
    },
    {
        "index": 133406,
        "code": "void ShellDelegateImpl::OpenUrlFromArc(const GURL& url) {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 16
    },
    {
        "index": 181182,
        "code": " void acpi_ns_terminate(void)\n {\n \tacpi_status status;\n \n \tACPI_FUNCTION_TRACE(ns_terminate);\n \n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n \n\t\t/* Delete any module-level code blocks */\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n \t}\n#endif\n \n \t/*\n \t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t */\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\t/* Delete any objects attached to the root node */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}\n",
        "line": "#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\t\t/* Delete any module-level code blocks */\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n#endif\n",
        "label": 1,
        "cwe": "CWE-755",
        "cve": "CVE-2017-11472",
        "length": 254
    },
    {
        "index": 151104,
        "code": "bool DevToolsWindow::ReloadInspectedWebContents(bool bypass_cache) {\n  WebContents* wc = GetInspectedWebContents();\n  if (!wc || wc->GetCrashedStatus() != base::TERMINATION_STATUS_STILL_RUNNING)\n    return false;\n  base::FundamentalValue bypass_cache_value(bypass_cache);\n  bindings_->CallClientFunction(\"DevToolsAPI.reloadInspectedPage\",\n                                &bypass_cache_value, nullptr, nullptr);\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-5011",
        "length": 99
    },
    {
        "index": 77909,
        "code": "test_bson_copy_to_excluding_noinit (void)\n{\n   bson_iter_t iter;\n   bool r;\n   bson_t b;\n   bson_t c;\n   int i;\n\n   bson_init (&b);\n   bson_append_int32 (&b, \"a\", 1, 1);\n   bson_append_int32 (&b, \"b\", 1, 2);\n\n   bson_init (&c);\n   bson_copy_to_excluding_noinit (&b, &c, \"b\", NULL);\n   r = bson_iter_init_find (&iter, &c, \"a\");\n   BSON_ASSERT (r);\n   r = bson_iter_init_find (&iter, &c, \"b\");\n   BSON_ASSERT (!r);\n\n   i = bson_count_keys (&b);\n   ASSERT_CMPINT (i, ==, 2);\n\n   i = bson_count_keys (&c);\n   ASSERT_CMPINT (i, ==, 1);\n\n   bson_destroy (&b);\n   bson_destroy (&c);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16790",
        "length": 204
    },
    {
        "index": 138891,
        "code": "void WallpaperManager::OnDeviceWallpaperDecoded(\n    const AccountId& account_id,\n    std::unique_ptr<user_manager::UserImage> user_image) {\n  if (!user_manager::UserManager::Get()->IsUserLoggedIn()) {\n    WallpaperInfo wallpaper_info = {GetDeviceWallpaperFilePath().value(),\n                                    wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED,\n                                    wallpaper::DEVICE,\n                                    base::Time::Now().LocalMidnight()};\n    GetPendingWallpaper(user_manager::SignInAccountId(), false)\n        ->ResetSetWallpaperImage(user_image->image(), wallpaper_info);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-1285",
        "length": 128
    },
    {
        "index": 119738,
        "code": "void ColorChooserWin::OnColorChooserDialogClosed() {\n  if (color_chooser_dialog_.get()) {\n    color_chooser_dialog_->ListenerDestroyed();\n    color_chooser_dialog_ = NULL;\n  }\n  DCHECK(current_color_chooser_ == this);\n  current_color_chooser_ = NULL;\n  if (web_contents_)\n    web_contents_->DidEndColorChooser();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2914",
        "length": 79
    },
    {
        "index": 74394,
        "code": "static void ReadLinkState(PARANDIS_ADAPTER *pContext)\n{\n    if (pContext->bLinkDetectSupported)\n    {\n        USHORT linkStatus = 0;\n        VirtIODeviceGet(pContext->IODevice, ETH_LENGTH_OF_ADDRESS, &linkStatus, sizeof(linkStatus));\n        pContext->bConnected = !!(linkStatus & VIRTIO_NET_S_LINK_UP);\n    }\n    else\n    {\n        pContext->bConnected = TRUE;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-3215",
        "length": 98
    },
    {
        "index": 133933,
        "code": "AppListControllerDelegate::~AppListControllerDelegate() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6644",
        "length": 12
    },
    {
        "index": 67745,
        "code": "void r_pkcs7_free_cms (RCMS* container) {\n\tif (container) {\n\t\tr_asn1_free_string (container->contentType);\n\t\tr_pkcs7_free_signeddata (&container->signedData);\n\t\tfree (container);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7274",
        "length": 55
    },
    {
        "index": 50570,
        "code": "static inline double gamma_pow(const double value,const double gamma)\n{\n  return(value < 0.0 ? value : pow(value,gamma));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-6520",
        "length": 31
    },
    {
        "index": 124638,
        "code": "void RenderBlock::setBreakAtLineToAvoidWidow(int lineToBreak)\n{\n    ASSERT(lineToBreak >= 0);\n    if (!m_rareData)\n        m_rareData = adoptPtr(new RenderBlockRareData());\n\n    ASSERT(!m_rareData->m_didBreakAtLineToAvoidWidow);\n    m_rareData->m_lineBreakToAvoidWidow = lineToBreak;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 91
    },
    {
        "index": 156566,
        "code": "network::ResourceRequest CreateXHRRequest(const char* url) {\n  network::ResourceRequest request;\n  request.method = \"GET\";\n  request.url = GURL(url);\n  request.referrer_policy = Referrer::GetDefaultReferrerPolicy();\n  request.request_initiator = url::Origin();\n  request.load_flags = 0;\n  request.plugin_child_id = -1;\n  request.resource_type = RESOURCE_TYPE_XHR;\n  request.appcache_host_id = kAppCacheNoHostId;\n  request.should_reset_appcache = false;\n  request.is_main_frame = true;\n  request.transition_type = ui::PAGE_TRANSITION_LINK;\n  request.allow_download = true;\n  return request;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-18345",
        "length": 142
    },
    {
        "index": 2432,
        "code": "uint8_t smb2cli_conn_get_io_priority(struct smbXcli_conn *conn)\n{\n\tif (conn->protocol < PROTOCOL_SMB3_11) {\n\t\treturn 0;\n\t}\n\n\treturn conn->smb2.io_priority;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-5296",
        "length": 52
    },
    {
        "index": 150781,
        "code": "device::BluetoothAdapter* WebBluetoothServiceImpl::GetAdapter() {\n  return BluetoothAdapterFactoryWrapper::Get().GetAdapter(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5044",
        "length": 27
    },
    {
        "index": 30892,
        "code": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-2929",
        "length": 91
    },
    {
        "index": 146106,
        "code": "ScriptValue WebGL2RenderingContextBase::getSyncParameter(\n    ScriptState* script_state,\n    WebGLSync* sync,\n    GLenum pname) {\n  if (isContextLost() || !ValidateWebGLObject(\"getSyncParameter\", sync))\n    return ScriptValue::CreateNull(script_state);\n\n  switch (pname) {\n    case GL_OBJECT_TYPE:\n    case GL_SYNC_STATUS:\n    case GL_SYNC_CONDITION:\n    case GL_SYNC_FLAGS: {\n      GLint value = 0;\n      GLsizei length = -1;\n      ContextGL()->GetSynciv(SyncObjectOrZero(sync), pname, 1, &length, &value);\n      return WebGLAny(script_state, static_cast<unsigned>(value));\n    }\n    default:\n      SynthesizeGLError(GL_INVALID_ENUM, \"getSyncParameter\",\n                        \"invalid parameter name\");\n      return ScriptValue::CreateNull(script_state);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 181
    },
    {
        "index": 79768,
        "code": "static int param_set_scroll(const char *val, const struct kernel_param *kp)\n{\n\typan = 0;\n\n\tif (!strcmp(val, \"redraw\"))\n\t\typan = 0;\n\telse if (!strcmp(val, \"ypan\"))\n\t\typan = 1;\n\telse if (!strcmp(val, \"ywrap\"))\n\t\typan = 2;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-13406",
        "length": 87
    },
    {
        "index": 93502,
        "code": "static int setup_channel(lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    LIBSSH2_CHANNEL **channel = (LIBSSH2_CHANNEL **) lua_touserdata(L, 2);\n\n    while ((rc = libssh2_channel_request_pty(*channel, \"vanilla\")) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 1, \"filter\");\n        lua_pushvalue(L, 1);\n        lua_callk(L, 1, 0, 0, setup_channel);\n    }\n    if (rc != 0)\n        return luaL_error(L, \"Requesting pty\");\n\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-18594",
        "length": 142
    },
    {
        "index": 113804,
        "code": "ContentSettingsStore::FindEntry(const std::string& ext_id) const {\n  ExtensionEntryMap::const_iterator i;\n  for (i = entries_.begin(); i != entries_.end(); ++i) {\n    if (i->second->id == ext_id)\n      return i;\n  }\n  return entries_.end();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 70
    },
    {
        "index": 49624,
        "code": "static int ffs_func_set_alt(struct usb_function *f,\n\t\t\t    unsigned interface, unsigned alt)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tint ret = 0, intf;\n\n\tif (alt != (unsigned)-1) {\n\t\tintf = ffs_func_revmap_intf(func, interface);\n\t\tif (unlikely(intf < 0))\n\t\t\treturn intf;\n\t}\n\n\tif (ffs->func)\n\t\tffs_func_eps_disable(ffs->func);\n\n\tif (ffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tINIT_WORK(&ffs->reset_work, ffs_reset_work);\n\t\tschedule_work(&ffs->reset_work);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tif (alt == (unsigned)-1) {\n\t\tffs->func = NULL;\n\t\tffs_event_add(ffs, FUNCTIONFS_DISABLE);\n\t\treturn 0;\n\t}\n\n\tffs->func = func;\n\tret = ffs_func_eps_enable(func);\n\tif (likely(ret >= 0))\n\t\tffs_event_add(ffs, FUNCTIONFS_ENABLE);\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7912",
        "length": 271
    },
    {
        "index": 45655,
        "code": "void cryptd_free_ablkcipher(struct cryptd_ablkcipher *tfm)\n{\n\tcrypto_free_ablkcipher(&tfm->base);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 35
    },
    {
        "index": 73504,
        "code": "MagickExport Cache ReferencePixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count++;\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  return(cache_info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-7539",
        "length": 86
    },
    {
        "index": 28744,
        "code": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_apic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6376",
        "length": 241
    },
    {
        "index": 111011,
        "code": "void FileSystemOperation::DidTouchFile(const StatusCallback& callback,\n                                       base::PlatformFileError rv) {\n  callback.Run(rv);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 29
    },
    {
        "index": 75998,
        "code": "vrrp_garp_rep_handler(vector_t *strvec)\n{\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\tunsigned repeats;\n\n\t/* The min value should be 1, but allow 0 to maintain backward compatibility\n\t * with pre v2.0.7 */\n\tif (!read_unsigned_strvec(strvec, 1, &repeats, 0, UINT_MAX, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_repeat '%s' invalid - ignoring\", vrrp->iname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (repeats == 0) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s): garp_master_repeat must be greater than 0, setting to 1\", vrrp->iname);\n\t\trepeats = 1;\n\t}\n\n\tvrrp->garp_rep = repeats;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2018-19044",
        "length": 204
    },
    {
        "index": 165009,
        "code": "bool HTMLCanvasElement::HasImageBitmapContext() const {\n  if (!context_)\n    return false;\n  CanvasRenderingContext::ContextType type = context_->GetContextType();\n  return (type == CanvasRenderingContext::kContextImageBitmap ||\n          type == CanvasRenderingContext::kContextXRPresent);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-5787",
        "length": 61
    },
    {
        "index": 13080,
        "code": "  cf2_free_instance( void*  ptr )\n  {\n    CF2_Font  font = (CF2_Font)ptr;\n\n\n    if ( font )\n    {\n      FT_Memory  memory = font->memory;\n\n\n      (void)memory;\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2241",
        "length": 56
    },
    {
        "index": 29841,
        "code": "cifs_umount(struct cifs_sb_info *cifs_sb)\n{\n\tstruct rb_root *root = &cifs_sb->tlink_tree;\n\tstruct rb_node *node;\n\tstruct tcon_link *tlink;\n\n\tcancel_delayed_work_sync(&cifs_sb->prune_tlinks);\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\twhile ((node = rb_first(root))) {\n\t\ttlink = rb_entry(node, struct tcon_link, tl_rbnode);\n\t\tcifs_get_tlink(tlink);\n\t\tclear_bit(TCON_LINK_IN_TREE, &tlink->tl_flags);\n\t\trb_erase(node, root);\n\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\tcifs_put_tlink(tlink);\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t}\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tbdi_destroy(&cifs_sb->bdi);\n\tkfree(cifs_sb->mountdata);\n\tunload_nls(cifs_sb->local_nls);\n\tkfree(cifs_sb);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-4247",
        "length": 216
    },
    {
        "index": 45405,
        "code": "static int ecryptfs_copy_filename(char **copied_name, size_t *copied_name_size,\n\t\t\t\t  const char *name, size_t name_size)\n{\n\tint rc = 0;\n\n\t(*copied_name) = kmalloc((name_size + 1), GFP_KERNEL);\n\tif (!(*copied_name)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy((void *)(*copied_name), (void *)name, name_size);\n\t(*copied_name)[(name_size)] = '\\0';\t/* Only for convenience\n\t\t\t\t\t\t * in printing out the\n\t\t\t\t\t\t * string in debug\n\t\t\t\t\t\t * messages */\n\t(*copied_name_size) = name_size;\nout:\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-9683",
        "length": 150
    },
    {
        "index": 78291,
        "code": "coolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\t/* If it matched, it must be one of the booleans */\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\t/* attribute isn't in the list */\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 292
    },
    {
        "index": 84769,
        "code": "read_colormap(bmp_source_ptr sinfo, int cmaplen, int mapentrysize)\n/* Read the colormap from a BMP file */\n{\n  int i, gray = 1;\n\n  switch (mapentrysize) {\n  case 3:\n    /* BGR format (occurs in OS/2 files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  case 4:\n    /* BGR0 format (occurs in MS Windows files) */\n    for (i = 0; i < cmaplen; i++) {\n      sinfo->colormap[2][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[1][i] = (JSAMPLE)read_byte(sinfo);\n      sinfo->colormap[0][i] = (JSAMPLE)read_byte(sinfo);\n      (void)read_byte(sinfo);\n      if (sinfo->colormap[2][i] != sinfo->colormap[1][i] ||\n          sinfo->colormap[1][i] != sinfo->colormap[0][i])\n        gray = 0;\n    }\n    break;\n  default:\n    ERREXIT(sinfo->cinfo, JERR_BMP_BADCMAP);\n    break;\n  }\n\n  if (sinfo->cinfo->in_color_space == JCS_UNKNOWN && gray)\n    sinfo->cinfo->in_color_space = JCS_GRAYSCALE;\n\n  if (sinfo->cinfo->in_color_space == JCS_GRAYSCALE && !gray)\n    ERREXIT(sinfo->cinfo, JERR_BAD_IN_COLORSPACE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2018-1152",
        "length": 472
    },
    {
        "index": 126670,
        "code": "void TabStripModelObserver::TabMoved(TabContents* contents,\n                                     int from_index,\n                                     int to_index) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 27
    },
    {
        "index": 115163,
        "code": "BluetoothOptionsHandler::BluetoothOptionsHandler()\n    : chromeos::CrosOptionsPageUIHandler(\n        new chromeos::SystemSettingsProvider()) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3963",
        "length": 32
    },
    {
        "index": 184598,
        "code": " void BluetoothOptionsHandler::DisplayPasskey(\n     chromeos::BluetoothDevice* device,\n     int passkey,\n     int entered) {\n }\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3963",
        "length": 30
    },
    {
        "index": 137006,
        "code": "bool HTMLInputElement::checked() const {\n  input_type_->ReadingChecked();\n  return is_checked_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 22
    },
    {
        "index": 35505,
        "code": "static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\treturn assign_eip_far(ctxt, dst, ctxt->mode == X86EMUL_MODE_PROT64);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-8481",
        "length": 45
    },
    {
        "index": 39990,
        "code": "cifs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\n\tlock_page(page);\n\treturn VM_FAULT_LOCKED;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-0069",
        "length": 43
    },
    {
        "index": 174555,
        "code": "tBTM_STATUS BTM_SecBond (BD_ADDR bd_addr, UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[])\n{\n    tBT_TRANSPORT   transport = BT_TRANSPORT_BR_EDR;\n#if BLE_INCLUDED == TRUE\n if (BTM_UseLeLink(bd_addr))\n        transport = BT_TRANSPORT_LE;\n#endif\n return btm_sec_bond_by_transport(bd_addr, transport, pin_len, p_pin, trusted_mask);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0850",
        "length": 100
    },
    {
        "index": 107093,
        "code": "QQuickWebViewPrivate::~QQuickWebViewPrivate()\n{\n    webPageProxy->close();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-1800",
        "length": 20
    },
    {
        "index": 116215,
        "code": "QQuickWebView::QQuickWebView(WKContextRef contextRef, WKPageGroupRef pageGroupRef, QQuickItem* parent)\n    : QQuickFlickable(parent)\n    , d_ptr(createPrivateObject(this))\n    , m_experimental(new QQuickWebViewExperimental(this))\n{\n    Q_D(QQuickWebView);\n    d->initialize(contextRef, pageGroupRef);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3107",
        "length": 79
    },
    {
        "index": 184485,
        "code": " void WebPagePrivate::didComposite()\n {\n     if (!m_page->settings()->developerExtrasEnabled())\n         return;\n    InspectorInstrumentation::didComposite(m_page);\n }\n",
        "line": "    InspectorInstrumentation::didComposite(m_page);\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 36
    },
    {
        "index": 3754,
        "code": "_dbus_parse_uid (const DBusString      *uid_str,\n                 dbus_uid_t            *uid)\n{\n  int end;\n  long val;\n\n  if (_dbus_string_get_length (uid_str) == 0)\n    {\n      _dbus_verbose (\"UID string was zero length\\n\");\n      return FALSE;\n    }\n\n  val = -1;\n  end = 0;\n  if (!_dbus_string_parse_int (uid_str, 0, &val,\n                               &end))\n    {\n      _dbus_verbose (\"could not parse string as a UID\\n\");\n      return FALSE;\n    }\n\n  if (end != _dbus_string_get_length (uid_str))\n    {\n      _dbus_verbose (\"string contained trailing stuff after UID\\n\");\n      return FALSE;\n    }\n\n  *uid = val;\n\n  return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2168",
        "length": 168
    },
    {
        "index": 159761,
        "code": "void PermissionPromptImpl::Accept() {\n  if (delegate_)\n    delegate_->Accept();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6049",
        "length": 20
    },
    {
        "index": 29299,
        "code": "proc_do_sync_threshold(ctl_table *table, int write,\n\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = table->data;\n\tint val[2];\n\tint rc;\n\n\t/* backup the value first */\n\tmemcpy(val, valp, sizeof(val));\n\n\trc = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (write && (valp[0] < 0 || valp[1] < 0 || valp[0] >= valp[1])) {\n\t\t/* Restore the correct value */\n\t\tmemcpy(valp, val, sizeof(val));\n\t}\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4588",
        "length": 145
    },
    {
        "index": 10839,
        "code": "static int tls_curve_allowed(SSL *s, const unsigned char *curve, int op)\n\t{\n\ttls_curve_info *cinfo;\n\tif (curve[0])\n\t\treturn 1;\n\tif ((curve[1] < 1) || ((size_t)curve[1] >\n\t\t\t\tsizeof(nid_list)/sizeof(nid_list[0])))\n\t\treturn 0;\n\tcinfo = &nid_list[curve[1]-1];\n\treturn ssl_security(s, op, cinfo->secbits, cinfo->nid, (void *)curve);\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-5139",
        "length": 117
    },
    {
        "index": 123726,
        "code": "FILE* CreateAndOpenTemporaryFileInDir(const FilePath& dir, FilePath* path) {\n  int fd = CreateAndOpenFdForTemporaryFile(dir, path);\n  if (fd < 0)\n    return NULL;\n\n  FILE* file = fdopen(fd, \"a+\");\n  if (!file)\n    ignore_result(HANDLE_EINTR(close(fd)));\n  return file;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2013-0895",
        "length": 79
    },
    {
        "index": 36383,
        "code": "struct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *tmp = getname(pathname);\n\tstruct dentry *res;\n\tif (IS_ERR(tmp))\n\t\treturn ERR_CAST(tmp);\n\tres = kern_path_create(dfd, tmp->name, path, lookup_flags);\n\tputname(tmp);\n\treturn res;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2014-5045",
        "length": 84
    },
    {
        "index": 150708,
        "code": "base::string16 PageInfoUI::PermissionTypeToUIString(ContentSettingsType type) {\n  for (const PermissionsUIInfo& info : GetContentSettingsUIInfo()) {\n    if (info.type == type)\n      return l10n_util::GetStringUTF16(info.string_id);\n  }\n  NOTREACHED();\n  return base::string16();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-311",
        "cve": "CVE-2017-5042",
        "length": 73
    },
    {
        "index": 136783,
        "code": "static void UntrackAllBeforeUnloadEventListeners(LocalDOMWindow* dom_window) {\n  DOMWindowSet& set = WindowsWithBeforeUnloadEventListeners();\n  DOMWindowSet::iterator it = set.find(dom_window);\n  if (it == set.end())\n    return;\n  set.RemoveAll(it);\n  UpdateSuddenTerminationStatus(dom_window, false, kBeforeUnloadHandler);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 79
    },
    {
        "index": 31376,
        "code": "\t__acquires(rcu)\n{\n\tstruct net *net = seq_file_net(f);\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\n\trcu_read_lock();\n\treturn seq_hlist_start_head_rcu(&net_pfkey->table, *ppos);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-2237",
        "length": 63
    },
    {
        "index": 110586,
        "code": "error::Error GLES2DecoderImpl::HandleGenSharedIdsCHROMIUM(\n    uint32 immediate_data_size, const gles2::GenSharedIdsCHROMIUM& c) {\n  GLuint namespace_id = static_cast<GLuint>(c.namespace_id);\n  GLuint id_offset = static_cast<GLuint>(c.id_offset);\n  GLsizei n = static_cast<GLsizei>(c.n);\n  uint32 data_size;\n  if (!SafeMultiplyUint32(n, sizeof(GLuint), &data_size)) {\n    return error::kOutOfBounds;\n  }\n  GLuint* ids = GetSharedMemoryAs<GLuint*>(\n      c.ids_shm_id, c.ids_shm_offset, data_size);\n  if (n < 0) {\n    SetGLError(GL_INVALID_VALUE, \"GenSharedIdsCHROMIUM\", \"n < 0\");\n    return error::kNoError;\n  }\n  if (ids == NULL) {\n    return error::kOutOfBounds;\n  }\n  DoGenSharedIdsCHROMIUM(namespace_id, id_offset, n, ids);\n  return error::kNoError;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2896",
        "length": 231
    },
    {
        "index": 126801,
        "code": "bool BrowserView::IsActive() const {\n  return frame_->IsActive();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 16
    },
    {
        "index": 25273,
        "code": "static void armv7pmu_enable_event(struct hw_perf_event *hwc, int idx)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Enable counter and interrupt, and set the counter to count\n\t * the event that we're interested in.\n\t */\n\traw_spin_lock_irqsave(&pmu_lock, flags);\n\n\t/*\n\t * Disable counter\n\t */\n\tarmv7_pmnc_disable_counter(idx);\n\n\t/*\n\t * Set event (if destined for PMNx counters)\n\t * We don't need to set the event if it's a cycle count\n\t */\n\tif (idx != ARMV7_CYCLE_COUNTER)\n\t\tarmv7_pmnc_write_evtsel(idx, hwc->config_base);\n\n\t/*\n\t * Enable interrupt for this counter\n\t */\n\tarmv7_pmnc_enable_intens(idx);\n\n\t/*\n\t * Enable counter\n\t */\n\tarmv7_pmnc_enable_counter(idx);\n\n\traw_spin_unlock_irqrestore(&pmu_lock, flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 202
    },
    {
        "index": 155493,
        "code": "   base::Version ruleset_format_version() {\n     return policy_->ruleset_format_version_;\n   }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5199",
        "length": 22
    },
    {
        "index": 84995,
        "code": "do_ipt_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase IPT_SO_SET_REPLACE:\n\t\tret = do_replace(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase IPT_SO_SET_ADD_COUNTERS:\n\t\tret = do_add_counters(sock_net(sk), user, len, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1065",
        "length": 119
    },
    {
        "index": 88222,
        "code": "XML_SetExternalEntityRefHandler(XML_Parser parser,\n                                XML_ExternalEntityRefHandler handler) {\n  if (parser != NULL)\n    parser->m_externalEntityRefHandler = handler;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-611",
        "cve": "CVE-2019-15903",
        "length": 41
    },
    {
        "index": 62645,
        "code": "_zip_cdir_new(zip_uint64_t nentry, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n\n    if ((cd=(zip_cdir_t *)malloc(sizeof(*cd))) == NULL) {\n\tzip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n\n    cd->entry = NULL;\n    cd->nentry = cd->nentry_alloc = 0;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->is_zip64 = false;\n\n    if (!_zip_cdir_grow(cd, nentry, error)) {\n\t_zip_cdir_free(cd);\n\treturn NULL;\n    }\n\n    return cd;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-12858",
        "length": 147
    },
    {
        "index": 3108,
        "code": "static int labbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)\n{\n    os_ptr op;\n    int i, components=1;\n\n    components = 3;\n    pop(components);\n    op = osp;\n    components = 3;\n    push(components);\n    op -= components-1;\n    for (i=0;i<components;i++) {\n        make_real(op, (float)0);\n        op++;\n    }\n    *stage = 0;\n    *cont = 0;\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-16513",
        "length": 127
    },
    {
        "index": 153194,
        "code": "gfx::Size DesktopWindowTreeHostX11::AdjustSize(\n    const gfx::Size& requested_size_in_pixels) {\n  std::vector<display::Display> displays =\n      display::Screen::GetScreen()->GetAllDisplays();\n  for (size_t i = 0; i < displays.size(); ++i) {\n    if (requested_size_in_pixels == displays[i].GetSizeInPixel()) {\n      return gfx::Size(requested_size_in_pixels.width() - 1,\n                       requested_size_in_pixels.height() - 1);\n    }\n  }\n\n  gfx::Size size_in_pixels = requested_size_in_pixels;\n  size_in_pixels.SetToMax(gfx::Size(1, 1));\n  return size_in_pixels;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5217",
        "length": 152
    },
    {
        "index": 165664,
        "code": "ProcessType GetProcessType(const std::wstring& process_type) {\n  if (process_type.empty())\n    return ProcessType::BROWSER_PROCESS;\n  if (process_type == kCloudPrintServiceProcess)\n    return ProcessType::CLOUD_PRINT_SERVICE_PROCESS;\n#if BUILDFLAG(ENABLE_NACL)\n  if (process_type == kNaClBrokerProcess)\n    return ProcessType::NACL_BROKER_PROCESS;\n  if (process_type == kNaClLoaderProcess)\n    return ProcessType::NACL_LOADER_PROCESS;\n#endif\n  return ProcessType::OTHER_PROCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2019-5804",
        "length": 122
    },
    {
        "index": 43707,
        "code": "void ndisc_late_cleanup(void)\n{\n\tunregister_netdevice_notifier(&ndisc_netdev_notifier);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2015-2922",
        "length": 23
    },
    {
        "index": 63524,
        "code": "static void init_once(void *foo)\n{\n\tstruct mqueue_inode_info *p = (struct mqueue_inode_info *) foo;\n\n\tinode_init_once(&p->vfs_inode);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-11176",
        "length": 38
    },
    {
        "index": 1473,
        "code": "static int coroutine_fn put_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    BUG_ON(!fidp->ref);\n    fidp->ref--;\n    /*\n     * Don't free the fid if it is in reclaim list\n     */\n    if (!fidp->ref && fidp->clunked) {\n        if (fidp->fid == pdu->s->root_fid) {\n            /*\n             * if the clunked fid is root fid then we\n             * have unmounted the fs on the client side.\n             * delete the migration blocker. Ideally, this\n             * should be hooked to transport close notification\n             */\n            if (pdu->s->migration_blocker) {\n                migrate_del_blocker(pdu->s->migration_blocker);\n                error_free(pdu->s->migration_blocker);\n                pdu->s->migration_blocker = NULL;\n            }\n        }\n        return free_fid(pdu, fidp);\n    }\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-19489",
        "length": 215
    },
    {
        "index": 78706,
        "code": "static int setcos_set_security_env(sc_card_t *card,\n\t\t\t\t   const sc_security_env_t *env, int se_num)\n{\n\tif (env->flags & SC_SEC_ENV_ALG_PRESENT) {\n\t\tsc_security_env_t tmp;\n\n\t\ttmp = *env;\n\t\ttmp.flags &= ~SC_SEC_ENV_ALG_PRESENT;\n\t\ttmp.flags |= SC_SEC_ENV_ALG_REF_PRESENT;\n\t\tif (tmp.algorithm != SC_ALGORITHM_RSA) {\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Only RSA algorithm supported.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t}\n\t\tswitch (card->type) {\n\t\tcase SC_CARD_TYPE_SETCOS_PKI:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID:\n\t\tcase SC_CARD_TYPE_SETCOS_FINEID_V2_2048:\n\t\tcase SC_CARD_TYPE_SETCOS_NIDEL:\n\t\tcase SC_CARD_TYPE_SETCOS_44:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_0:\n\t\tcase SC_CARD_TYPE_SETCOS_EID_V2_1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL, \"Card does not support RSA.\\n\");\n\t\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\t\ttmp.algorithm_ref = 0x00;\n\t\t/* potential FIXME: return an error, if an unsupported\n\t\t * pad or hash was requested, although this shouldn't happen.\n\t\t */\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1)\n\t\t\ttmp.algorithm_ref = 0x02;\n\t\tif (tmp.algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)\n\t\t\ttmp.algorithm_ref |= 0x10;\n\t\treturn setcos_set_security_env2(card, &tmp, se_num);\n\t}\n\treturn setcos_set_security_env2(card, env, se_num);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 385
    },
    {
        "index": 28321,
        "code": "void uio_unregister_device(struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\n\tif (!info || !info->uio_dev)\n\t\treturn;\n\n\tidev = info->uio_dev;\n\n\tuio_free_minor(idev);\n\n\tif (info->irq && (info->irq != UIO_IRQ_CUSTOM))\n\t\tfree_irq(info->irq, idev);\n\n\tuio_dev_del_attributes(idev);\n\n\tdevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\n\tkfree(idev);\n\n\treturn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6763",
        "length": 115
    },
    {
        "index": 158821,
        "code": "gfx::Size Browser::EnterPictureInPicture(const viz::SurfaceId& surface_id,\n                                         const gfx::Size& natural_size) {\n  return PictureInPictureWindowManager::GetInstance()->EnterPictureInPicture(\n      tab_strip_model_->GetActiveWebContents(), surface_id, natural_size);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17476",
        "length": 61
    },
    {
        "index": 138552,
        "code": "static double systemTraceTimeFunction()\n{\n    return Platform::current()->systemTraceTime();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1281",
        "length": 20
    },
    {
        "index": 177198,
        "code": "void ACodec::PortDescription::addBuffer(\n        IOMX::buffer_id id, const sp<ABuffer> &buffer) {\n    mBufferIDs.push_back(id);\n    mBuffers.push_back(buffer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 46
    },
    {
        "index": 33736,
        "code": "static void hidp_idle_timeout(unsigned long arg)\n{\n\tstruct hidp_session *session = (struct hidp_session *) arg;\n\n\tatomic_inc(&session->terminate);\n\twake_up_process(session->task);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-0349",
        "length": 43
    },
    {
        "index": 93633,
        "code": "nvmet_fc_target_assoc_free(struct kref *ref)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc =\n\t\tcontainer_of(ref, struct nvmet_fc_tgt_assoc, ref);\n\tstruct nvmet_fc_tgtport *tgtport = assoc->tgtport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_del(&assoc->a_list);\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\tida_simple_remove(&tgtport->assoc_cnt, assoc->a_id);\n\tkfree(assoc);\n\tnvmet_fc_tgtport_put(tgtport);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18379",
        "length": 120
    },
    {
        "index": 26416,
        "code": "static int pmcraid_build_ioadl(\n\tstruct pmcraid_instance *pinstance,\n\tstruct pmcraid_cmd *cmd\n)\n{\n\tint i, nseg;\n\tstruct scatterlist *sglist;\n\n\tstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\n\tstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\n\tstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\n\n\tu32 length = scsi_bufflen(scsi_cmd);\n\n\tif (!length)\n\t\treturn 0;\n\n\tnseg = scsi_dma_map(scsi_cmd);\n\n\tif (nseg < 0) {\n\t\tscmd_printk(KERN_ERR, scsi_cmd, \"scsi_map_dma failed!\\n\");\n\t\treturn -1;\n\t} else if (nseg > PMCRAID_MAX_IOADLS) {\n\t\tscsi_dma_unmap(scsi_cmd);\n\t\tscmd_printk(KERN_ERR, scsi_cmd,\n\t\t\t\"sg count is (%d) more than allowed!\\n\", nseg);\n\t\treturn -1;\n\t}\n\n\t/* Initialize IOARCB data transfer length fields */\n\tif (scsi_cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\n\n\tioarcb->request_flags0 |= NO_LINK_DESCS;\n\tioarcb->data_transfer_length = cpu_to_le32(length);\n\tioadl = pmcraid_init_ioadls(cmd, nseg);\n\n\t/* Initialize IOADL descriptor addresses */\n\tscsi_for_each_sg(scsi_cmd, sglist, nseg, i) {\n\t\tioadl[i].data_len = cpu_to_le32(sg_dma_len(sglist));\n\t\tioadl[i].address = cpu_to_le64(sg_dma_address(sglist));\n\t\tioadl[i].flags = 0;\n\t}\n\t/* setup last descriptor */\n\tioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-2906",
        "length": 428
    },
    {
        "index": 78700,
        "code": "static int setcos_list_files(sc_card_t *card, u8 * buf, size_t buflen)\n{\n\tsc_apdu_t apdu;\n\tint r;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, 0, 0);\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 || \n\t    card->type == SC_CARD_TYPE_SETCOS_NIDEL ||\n\t    SETCOS_IS_EID_APPLET(card))\n\t\tapdu.cla = 0x80;\n\tapdu.resp = buf;\n\tapdu.resplen = buflen;\n\tapdu.le = buflen > 256 ? 256 : buflen;\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tif (card->type == SC_CARD_TYPE_SETCOS_44 && apdu.sw1 == 0x6A && apdu.sw2 == 0x82)\n\t\treturn 0; /* no files found */\n\tif (apdu.resplen == 0)\n\t\treturn sc_check_sw(card, apdu.sw1, apdu.sw2);\n\treturn apdu.resplen;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 254
    },
    {
        "index": 34881,
        "code": "call_connect(struct rpc_task *task)\n{\n\tstruct rpc_xprt *xprt = task->tk_xprt;\n\n\tdprintk(\"RPC: %5u call_connect xprt %p %s connected\\n\",\n\t\t\ttask->tk_pid, xprt,\n\t\t\t(xprt_connected(xprt) ? \"is\" : \"is not\"));\n\n\ttask->tk_action = call_transmit;\n\tif (!xprt_connected(xprt)) {\n\t\ttask->tk_action = call_connect_status;\n\t\tif (task->tk_status < 0)\n\t\t\treturn;\n\t\txprt_connect(task);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2491",
        "length": 121
    },
    {
        "index": 143276,
        "code": "void Document::setWindowAttributeEventListener(const AtomicString& eventType, EventListener* listener)\n{\n    LocalDOMWindow* domWindow = this->domWindow();\n    if (!domWindow)\n        return;\n    domWindow->setAttributeEventListener(eventType, listener);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 54
    },
    {
        "index": 151818,
        "code": "  MockOfflinePageModel() : mock_saving_(false), mock_deleting_(false) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5014",
        "length": 21
    },
    {
        "index": 146662,
        "code": "views::BubbleDialogDelegateView* PageInfoBubbleView::CreatePageInfoBubble(\n    Browser* browser,\n    content::WebContents* web_contents,\n    const GURL& url,\n    const security_state::SecurityInfo& security_info) {\n  views::View* anchor_view = GetPageInfoAnchorView(browser);\n  gfx::Rect anchor_rect =\n      anchor_view ? gfx::Rect() : GetPageInfoAnchorRect(browser);\n  gfx::NativeView parent_window =\n      platform_util::GetViewForWindow(browser->window()->GetNativeWindow());\n\n  if (url.SchemeIs(content::kChromeUIScheme) ||\n      url.SchemeIs(content::kChromeDevToolsScheme) ||\n      url.SchemeIs(extensions::kExtensionScheme) ||\n      url.SchemeIs(content::kViewSourceScheme)) {\n    return new InternalPageInfoBubbleView(anchor_view, anchor_rect,\n                                          parent_window, url);\n  }\n\n  return new PageInfoBubbleView(anchor_view, anchor_rect, parent_window,\n                                browser->profile(), web_contents, url,\n                                security_info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2017-5116",
        "length": 214
    },
    {
        "index": 130167,
        "code": "RenderFrameHost* RenderFrameHostImpl::GetParent() {\n  FrameTreeNode* parent_node = frame_tree_node_->parent();\n  if (!parent_node)\n    return NULL;\n  return parent_node->current_frame_host();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 47
    },
    {
        "index": 169663,
        "code": "  explicit RequestBlockingNavigationThrottle(NavigationHandle* handle)\n      : NavigationThrottle(handle) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1678",
        "length": 22
    },
    {
        "index": 25170,
        "code": "static inline int rt_fast_clean(struct rtable *rth)\n{\n\t/* Kill broadcast/multicast entries very aggresively, if they\n\t   collide in hash table with more useful entries */\n\treturn (rth->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)) &&\n\t\trt_is_input_route(rth) && rth->dst.rt_next;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3188",
        "length": 78
    },
    {
        "index": 174488,
        "code": " virtual status_t emptyBuffer(\n            node_id node,\n            buffer_id buffer,\n            OMX_U32 range_offset, OMX_U32 range_length,\n            OMX_U32 flags, OMX_TICKS timestamp) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32((int32_t)buffer);\n        data.writeInt32(range_offset);\n        data.writeInt32(range_length);\n        data.writeInt32(flags);\n        data.writeInt64(timestamp);\n        remote()->transact(EMPTY_BUFFER, data, &reply);\n\n return reply.readInt32();\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-2417",
        "length": 128
    },
    {
        "index": 186665,
        "code": "   void DoTest(ExternalProtocolHandler::BlockState block_state,\n               shell_integration::DefaultWebClientState os_state,\n               Action expected_action) {\n    GURL url(\"mailto:test@test.com\");\n     EXPECT_FALSE(delegate_.has_prompted());\n     EXPECT_FALSE(delegate_.has_launched());\n     EXPECT_FALSE(delegate_.has_blocked());\n\n    delegate_.set_block_state(block_state);\n    delegate_.set_os_state(os_state);\n    ExternalProtocolHandler::LaunchUrlWithDelegate(\n        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);\n    content::RunAllTasksUntilIdle();\n\n    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());\n    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());\n    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());\n  }\n",
        "line": "    GURL url(\"mailto:test@test.com\");\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6043",
        "length": 177
    },
    {
        "index": 56009,
        "code": "static int tty_ldiscs_seq_show(struct seq_file *m, void *v)\n{\n\tint i = *(loff_t *)v;\n\tstruct tty_ldisc_ops *ldops;\n\n\tldops = get_ldops(i);\n\tif (IS_ERR(ldops))\n\t\treturn 0;\n\tseq_printf(m, \"%-10s %2d\\n\", ldops->name ? ldops->name : \"???\", i);\n\tput_ldops(ldops);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-8964",
        "length": 98
    },
    {
        "index": 131185,
        "code": "static void activityLoggingGetterForAllWorldsLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    V8PerContextData* contextData = V8PerContextData::from(info.GetIsolate()->GetCurrentContext());\n    if (contextData && contextData->activityLogger())\n        contextData->activityLogger()->log(\"TestObjectPython.activityLoggingGetterForAllWorldsLongAttribute\", 0, 0, \"Getter\");\n    TestObjectPythonV8Internal::activityLoggingGetterForAllWorldsLongAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 160
    },
    {
        "index": 16823,
        "code": "static int qcow2_probe(const uint8_t *buf, int buf_size, const char *filename)\n{\n    const QCowHeader *cow_header = (const void *)buf;\n\n    if (buf_size >= sizeof(QCowHeader) &&\n        be32_to_cpu(cow_header->magic) == QCOW_MAGIC &&\n        be32_to_cpu(cow_header->version) >= 2)\n        return 100;\n    else\n        return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2014-0143",
        "length": 96
    },
    {
        "index": 25209,
        "code": "static inline int compute_score(struct sock *sk, struct net *net,\n\t\t\t\tconst unsigned short hnum,\n\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\tconst int dif)\n{\n\tint score = -1;\n\n\tif (net_eq(sock_net(sk), net) && inet_sk(sk)->inet_num == hnum &&\n\t    sk->sk_family == PF_INET6) {\n\t\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\tscore = 1;\n\t\tif (!ipv6_addr_any(&np->rcv_saddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->rcv_saddr, daddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t}\n\treturn score;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3188",
        "length": 183
    },
    {
        "index": 107266,
        "code": "  virtual void Run() {\n    MessageLoop::current()->PostTask(FROM_HERE, task_);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1296",
        "length": 23
    },
    {
        "index": 139586,
        "code": "RenderMediaClient::~RenderMediaClient() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 11
    },
    {
        "index": 19371,
        "code": "static void efx_fini_napi_channel(struct efx_channel *channel)\n{\n\tif (channel->napi_dev)\n\t\tnetif_napi_del(&channel->napi_str);\n\tchannel->napi_dev = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-3412",
        "length": 48
    },
    {
        "index": 114459,
        "code": "ClientStateNotification::ClientStateNotification() : cv_(&lock_) {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 16
    },
    {
        "index": 54532,
        "code": "static int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    c->fragment.moof_offset = avio_tell(pb) - 8;\n    av_dlog(c->fc, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3062",
        "length": 80
    },
    {
        "index": 8011,
        "code": "static void vnc_desktop_resize(VncState *vs)\n{\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == pixman_image_get_width(vs->vd->server) &&\n        vs->client_height == pixman_image_get_height(vs->vd->server)) {\n        return;\n    }\n    vs->client_width = pixman_image_get_width(vs->vd->server);\n    vs->client_height = pixman_image_get_height(vs->vd->server);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-7815",
        "length": 218
    },
    {
        "index": 41197,
        "code": "static inline void tcp_reset_reno_sack(struct tcp_sock *tp)\n{\n\ttp->sacked_out = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-6638",
        "length": 27
    },
    {
        "index": 70277,
        "code": "OJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFWarningExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\",\"%s\",buffer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2016-10267",
        "length": 72
    },
    {
        "index": 57984,
        "code": "static int nf_tables_newsetelem(struct sock *nlsk, struct sk_buff *skb,\n\t\t\t\tconst struct nlmsghdr *nlh,\n\t\t\t\tconst struct nlattr * const nla[])\n{\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nlattr *attr;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tint rem, err = 0;\n\n\tif (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)\n\t\treturn -EINVAL;\n\n\terr = nft_ctx_init_from_elemattr(&ctx, skb, nlh, nla, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tset = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_ELEM_LIST_SET]);\n\tif (IS_ERR(set)) {\n\t\tif (nla[NFTA_SET_ELEM_LIST_SET_ID]) {\n\t\t\tset = nf_tables_set_lookup_byid(net,\n\t\t\t\t\tnla[NFTA_SET_ELEM_LIST_SET_ID]);\n\t\t}\n\t\tif (IS_ERR(set))\n\t\t\treturn PTR_ERR(set);\n\t}\n\n\tif (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)\n\t\treturn -EBUSY;\n\n\tnla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {\n\t\terr = nft_add_set_elem(&ctx, set, attr);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tset->nelems++;\n\t}\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1573",
        "length": 296
    },
    {
        "index": 77097,
        "code": "put_be32(struct ofpbuf *b, ovs_be32 x)\n{\n    ofpbuf_put(b, &x, sizeof x);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-17206",
        "length": 32
    },
    {
        "index": 155839,
        "code": "bool SupervisedUserService::MustRemainInstalled(const Extension* extension,\n                                                base::string16* error) const {\n  DCHECK(ProfileIsSupervised());\n  ExtensionState result = GetExtensionState(*extension);\n  bool may_not_uninstall = result == ExtensionState::FORCED;\n  if (may_not_uninstall && error)\n    *error = GetExtensionsLockedMessage();\n  return may_not_uninstall;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1665",
        "length": 85
    },
    {
        "index": 21684,
        "code": "static void ctx_rcu_free(struct rcu_head *head)\n{\n\tstruct kioctx *ctx = container_of(head, struct kioctx, rcu_head);\n\tunsigned nr_events = ctx->max_reqs;\n\n\tkmem_cache_free(kioctx_cachep, ctx);\n\n\tif (nr_events) {\n\t\tspin_lock(&aio_nr_lock);\n\t\tBUG_ON(aio_nr - nr_events > aio_nr);\n\t\taio_nr -= nr_events;\n\t\tspin_unlock(&aio_nr_lock);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-0058",
        "length": 107
    },
    {
        "index": 157697,
        "code": "  bool has_navigation_ui_data() { return has_navigation_ui_data_; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-20067",
        "length": 16
    },
    {
        "index": 70326,
        "code": "jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_read_header(cinfo,require_image);\n\t\treturn 1;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2016-10267",
        "length": 65
    },
    {
        "index": 102281,
        "code": "bool ExtensionPrefs::IsExtensionOrphaned(const std::string& extension_id) {\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 24
    },
    {
        "index": 133701,
        "code": "bool XSSAuditor::filterCharacterToken(const FilterTokenRequest& request)\n{\n    ASSERT(m_scriptTagNestingLevel);\n    ASSERT(m_state != Uninitialized);\n    if (m_state == PermittingAdjacentCharacterTokens)\n        return false;\n\n    if ((m_state == SuppressingAdjacentCharacterTokens)\n        || (m_scriptTagFoundInRequest && isContainedInRequest(decodedSnippetForJavaScript(request)))) {\n        request.token.eraseCharacters();\n        request.token.appendToCharacter(' '); // Technically, character tokens can't be empty.\n        m_state = SuppressingAdjacentCharacterTokens;\n        return true;\n    }\n\n    m_state = PermittingAdjacentCharacterTokens;\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 138
    },
    {
        "index": 38012,
        "code": "u16 skb_tx_hash(const struct net_device *dev, const struct sk_buff *skb)\n{\n\tu32 hash;\n\n\tif (skb_rx_queue_recorded(skb)) {\n\t\thash = skb_get_rx_queue(skb);\n\t\twhile (unlikely(hash >= dev->real_num_tx_queues))\n\t\t\thash -= dev->real_num_tx_queues;\n\t\treturn hash;\n\t}\n\n\tif (skb->sk && skb->sk->sk_hash)\n\t\thash = skb->sk->sk_hash;\n\telse\n\t\thash = (__force u16) skb->protocol;\n\n\thash = jhash_1word(hash, hashrnd);\n\n\treturn (u16) (((u64) hash * dev->real_num_tx_queues) >> 32);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3535",
        "length": 146
    },
    {
        "index": 122080,
        "code": "bool APIPermission::ManifestEntryForbidden() const {\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0879",
        "length": 16
    },
    {
        "index": 145301,
        "code": "void ObjectBackedNativeHandler::SetPrivate(v8::Local<v8::Context> context,\n                                           v8::Local<v8::Object> obj,\n                                           const char* key,\n                                           v8::Local<v8::Value> value) {\n  obj->SetPrivate(context, v8::Private::ForApi(context->GetIsolate(),\n                                               v8::String::NewFromUtf8(\n                                                   context->GetIsolate(), key)),\n                  value)\n      .FromJust();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-1696",
        "length": 101
    },
    {
        "index": 125437,
        "code": "GDataFileError GDataFileSystem::RemoveEntryFromFileSystem(\n    const FilePath& file_path) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  std::string resource_id;\n  GDataFileError error = RemoveEntryFromGData(file_path, &resource_id);\n  if (error != GDATA_FILE_OK)\n    return error;\n\n  if (!resource_id.empty())\n    cache_->RemoveOnUIThread(resource_id, CacheOperationCallback());\n\n  return GDATA_FILE_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-0839",
        "length": 105
    },
    {
        "index": 105839,
        "code": "STDMETHODIMP UrlmonUrlRequest::OnStopBinding(HRESULT result, LPCWSTR error) {\n  DCHECK_EQ(thread_, base::PlatformThread::CurrentId());\n  DVLOG(1) << __FUNCTION__ << me()\n           << \"- Request stopped, Result: \" << std::hex << result;\n  DCHECK(status_.get_state() == Status::WORKING ||\n         status_.get_state() == Status::ABORTING);\n\n  Status::State state = status_.get_state();\n\n  status_.Done();\n\n  if (result == INET_E_TERMINATED_BIND) {\n    if (terminate_requested()) {\n      terminate_bind_callback_->Run(moniker_, bind_context_, upload_data_,\n                                    request_headers_.c_str());\n    } else {\n      cleanup_transaction_ = true;\n    }\n    result = S_OK;\n  }\n\n  if (state == Status::WORKING) {\n    status_.set_result(result);\n\n    if (result == E_ACCESSDENIED) {\n      int http_code = GetHttpResponseStatusFromBinding(binding_);\n      if (300 <= http_code && http_code < 400) {\n        status_.set_result(net::URLRequestStatus::FAILED,\n                           net::ERR_UNSAFE_REDIRECT);\n      }\n    }\n\n\n    if (pending_data_) {\n      DCHECK_EQ(pending_read_size_, 0UL);\n      ReleaseBindings();\n      return S_OK;\n    }\n\n    if (headers_received_ && pending_read_size_ == 0) {\n      ReleaseBindings();\n      return S_OK;\n    }\n\n    NotifyDelegateAndDie();\n    return S_OK;\n  }\n\n  if (status_.was_redirected()) {\n    if (!pending_) {\n      std::string headers = GetHttpHeadersFromBinding(binding_);\n      OnResponse(0, UTF8ToWide(headers).c_str(), NULL, NULL);\n    }\n    ReleaseBindings();\n    return S_OK;\n  }\n\n  NotifyDelegateAndDie();\n  return S_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2347",
        "length": 390
    },
    {
        "index": 94818,
        "code": "MagickExport MagickBooleanType SyncAuthenticPixels(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.sync_authentic_pixels_handler !=\n       (SyncAuthenticPixelsHandler) NULL)\n    {\n      status=cache_info->methods.sync_authentic_pixels_handler(image,\n        exception);\n      return(status);\n    }\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5688",
        "length": 195
    },
    {
        "index": 120584,
        "code": "PseudoElement* Element::pseudoElement(PseudoId pseudoId) const\n{\n    return hasRareData() ? elementRareData()->pseudoElement(pseudoId) : 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2884",
        "length": 40
    },
    {
        "index": 85689,
        "code": "static int hns_nic_init_affinity_mask(int q_num, int ring_idx,\n\t\t\t\t      struct hnae_ring *ring, cpumask_t *mask)\n{\n\tint cpu;\n\n\t/* Diffrent irq banlance between 16core and 32core.\n\t * The cpu mask set by ring index according to the ring flag\n\t * which indicate the ring is tx or rx.\n\t */\n\tif (q_num == num_possible_cpus()) {\n\t\tif (is_tx_ring(ring))\n\t\t\tcpu = ring_idx;\n\t\telse\n\t\t\tcpu = ring_idx - q_num;\n\t} else {\n\t\tif (is_tx_ring(ring))\n\t\t\tcpu = ring_idx * 2;\n\t\telse\n\t\t\tcpu = (ring_idx - q_num) * 2 + 1;\n\t}\n\n\tcpumask_clear(mask);\n\tcpumask_set_cpu(cpu, mask);\n\n\treturn cpu;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18218",
        "length": 184
    },
    {
        "index": 28858,
        "code": "int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.mtrr_state.have_fixed = 1;\n\tr = vcpu_load(vcpu);\n\tif (r)\n\t\treturn r;\n\tkvm_vcpu_reset(vcpu);\n\tkvm_mmu_setup(vcpu);\n\tvcpu_put(vcpu);\n\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-6368",
        "length": 75
    },
    {
        "index": 170485,
        "code": "String8 Parcel::readString8() const\n{\n int32_t size = readInt32();\n if (size > 0 && size < INT32_MAX) {\n const char* str = (const char*)readInplace(size+1);\n if (str) return String8(str, size);\n }\n return String8();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-3845",
        "length": 68
    },
    {
        "index": 155176,
        "code": "bool OmniboxViewViews::UnapplySteadyStateElisions(UnelisionGesture gesture) {\n  if (IsSelectAll() && gesture != UnelisionGesture::HOME_KEY_PRESSED)\n    return false;\n\n  size_t start, end;\n  GetSelectionBounds(&start, &end);\n\n  base::string16 original_text = GetText();\n  base::string16 original_selected_text = GetSelectedText();\n  if (!model()->Unelide(false /* exit_query_in_omnibox */))\n    return false;\n\n  size_t offset = GetText().find(original_text);\n  if (offset != base::string16::npos) {\n    if (start != end && gesture == UnelisionGesture::MOUSE_RELEASE &&\n        !model()->ClassifiesAsSearch(original_selected_text)) {\n      if (start != 0)\n        start += offset;\n      if (end != 0)\n        end += offset;\n    } else {\n      start += offset;\n      end += offset;\n    }\n\n    OffsetDoubleClickWord(offset);\n  }\n\n  SelectRange(gfx::Range(start, end));\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-5220",
        "length": 232
    },
    {
        "index": 69847,
        "code": "circuit_queue_streams_are_blocked(circuit_t *circ)\n{\n  if (CIRCUIT_IS_ORIGIN(circ)) {\n    return circ->streams_blocked_on_n_chan;\n  } else {\n    return circ->streams_blocked_on_p_chan;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2017-0376",
        "length": 54
    },
    {
        "index": 32755,
        "code": "static int tg3_set_rxfh_indir(struct net_device *dev, const u32 *indir)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tsize_t i;\n\n\tfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\n\t\ttp->rss_ind_tbl[i] = indir[i];\n\n\tif (!netif_running(dev) || !tg3_flag(tp, ENABLE_RSS))\n\t\treturn 0;\n\n\t/* It is legal to write the indirection\n\t * table while the device is running.\n\t */\n\ttg3_full_lock(tp, 0);\n\ttg3_rss_write_indir_tbl(tp);\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "length": 149
    },
    {
        "index": 135537,
        "code": "static SelectionInDOMTree CorrectedSelectionAfterCommand(\n    const VisibleSelection& passed_selection,\n    Document* document) {\n  if (!passed_selection.Base().IsConnected() ||\n      !passed_selection.Extent().IsConnected() ||\n      passed_selection.Base().GetDocument() != document ||\n      passed_selection.Base().GetDocument() !=\n          passed_selection.Extent().GetDocument())\n    return SelectionInDOMTree();\n  return passed_selection.AsSelection();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-6773",
        "length": 92
    },
    {
        "index": 8346,
        "code": "static void xhci_stall_ep(XHCITransfer *xfer)\n{\n    XHCIState *xhci = xfer->xhci;\n    XHCISlot *slot = &xhci->slots[xfer->slotid-1];\n    XHCIEPContext *epctx = slot->eps[xfer->epid-1];\n    uint32_t err;\n    XHCIStreamContext *sctx;\n\n    if (epctx->nr_pstreams) {\n        sctx = xhci_find_stream(epctx, xfer->streamid, &err);\n        if (sctx == NULL) {\n            return;\n        }\n        sctx->ring.dequeue = xfer->trbs[0].addr;\n        sctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, sctx, EP_HALTED);\n    } else {\n        epctx->ring.dequeue = xfer->trbs[0].addr;\n        epctx->ring.ccs = xfer->trbs[0].ccs;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_HALTED);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-7466",
        "length": 250
    },
    {
        "index": 24121,
        "code": "static int prism2_close(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_close\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (dev == local->ddev) {\n\t\tprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\n\t}\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (!local->hostapd && dev == local->dev &&\n\t    (!local->func->card_present || local->func->card_present(local)) &&\n\t    local->hw_ready && local->ap && local->iw_mode == IW_MODE_MASTER)\n\t\thostap_deauth_all_stas(dev, local->ap, 1);\n#endif /* PRISM2_NO_KERNEL_IEEE80211_MGMT */\n\n\tif (dev == local->dev) {\n\t\tlocal->func->hw_shutdown(dev, HOSTAP_HW_ENABLE_CMDCOMPL);\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\n\tcancel_work_sync(&local->reset_queue);\n\tcancel_work_sync(&local->set_multicast_list_queue);\n\tcancel_work_sync(&local->set_tim_queue);\n#ifndef PRISM2_NO_STATION_MODES\n\tcancel_work_sync(&local->info_queue);\n#endif\n\tcancel_work_sync(&local->comms_qual_update);\n\n\tmodule_put(local->hw_module);\n\n\tlocal->num_dev_open--;\n\n\tif (dev != local->dev && local->dev->flags & IFF_UP &&\n\t    local->master_dev_auto_open && local->num_dev_open == 1) {\n\t\t/* Close master radio interface automatically if it was also\n\t\t * opened automatically and we are now closing the last\n\t\t * remaining non-master device. */\n\t\tdev_close(local->dev);\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 392
    },
    {
        "index": 107654,
        "code": "const char* ewk_view_setting_user_agent_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    return priv->settings.userAgent;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 65
    },
    {
        "index": 141830,
        "code": "void MetricsLog::WriteMetricsEnableDefault(EnableMetricsDefault metrics_default,\n                                           SystemProfileProto* system_profile) {\n  if (client_->IsReportingPolicyManaged()) {\n    system_profile->set_uma_default_state(\n        SystemProfileProto_UmaDefaultState_POLICY_FORCED_ENABLED);\n    return;\n  }\n\n  switch (metrics_default) {\n    case EnableMetricsDefault::DEFAULT_UNKNOWN:\n      break;\n    case EnableMetricsDefault::OPT_IN:\n      system_profile->set_uma_default_state(\n          SystemProfileProto_UmaDefaultState_OPT_IN);\n      break;\n    case EnableMetricsDefault::OPT_OUT:\n      system_profile->set_uma_default_state(\n          SystemProfileProto_UmaDefaultState_OPT_OUT);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2016-5165",
        "length": 149
    },
    {
        "index": 119967,
        "code": "void DelegatedFrameHost::AddOnCommitCallbackAndDisableLocks(\n    const base::Closure& callback) {\n  ui::Compositor* compositor = client_->GetCompositor();\n  DCHECK(compositor);\n\n  if (!compositor->HasObserver(this))\n    compositor->AddObserver(this);\n\n  can_lock_compositor_ = NO_PENDING_COMMIT;\n  on_compositing_did_commit_callbacks_.push_back(callback);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2921",
        "length": 90
    },
    {
        "index": 161758,
        "code": "void PlatformSensorAndroid::UpdatePlatformSensorReading(\n    JNIEnv*,\n    const base::android::JavaRef<jobject>& caller,\n    jdouble timestamp,\n    jdouble value1,\n    jdouble value2,\n    jdouble value3,\n    jdouble value4) {\n  SensorReading reading;\n  reading.raw.timestamp = timestamp;\n  reading.raw.values[0] = value1;\n  reading.raw.values[1] = value2;\n  reading.raw.values[2] = value3;\n  reading.raw.values[3] = value4;\n\n  UpdateSharedBufferAndNotifyClients(reading);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-6057",
        "length": 125
    },
    {
        "index": 54440,
        "code": "static char * php_zipobj_get_zip_comment(struct zip *za, int *len) /* {{{ */\n{\n\tif (za) {\n\t\treturn (char *)zip_get_archive_comment(za, len, 0);\n\t}\n\treturn NULL;\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-3078",
        "length": 54
    },
    {
        "index": 119897,
        "code": "void FrameLoader::dispatchDidClearWindowObjectInWorld(DOMWrapperWorld* world)\n{\n    if (!m_frame->script()->canExecuteScripts(NotAboutToExecuteScript) || !m_frame->script()->existingWindowShell(world))\n        return;\n\n    m_client->dispatchDidClearWindowObjectInWorld(world);\n\n    if (Page* page = m_frame->page())\n        page->inspectorController().didClearWindowObjectInWorld(m_frame, world);\n\n    InspectorInstrumentation::didClearWindowObjectInWorld(m_frame, world);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2916",
        "length": 113
    },
    {
        "index": 100280,
        "code": "static NetworkRoamingState ParseRoamingState(\n    const std::string& roaming_state) {\n    if (roaming_state == kRoamingStateHome)\n    return ROAMING_STATE_HOME;\n  if (roaming_state == kRoamingStateRoaming)\n    return ROAMING_STATE_ROAMING;\n  if (roaming_state == kRoamingStateUnknown)\n    return ROAMING_STATE_UNKNOWN;\n  return ROAMING_STATE_UNKNOWN;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 96
    },
    {
        "index": 8107,
        "code": "void Gfx::opBeginImage(Object args[], int numArgs) {\n  Stream *str;\n  int c1, c2;\n\n  str = buildImageStream();\n\n  if (str) {\n    doImage(NULL, str, gTrue);\n  \n    c1 = str->getUndecodedStream()->getChar();\n    c2 = str->getUndecodedStream()->getChar();\n    while (!(c1 == 'E' && c2 == 'I') && c2 != EOF) {\n      c1 = c2;\n      c2 = str->getUndecodedStream()->getChar();\n    }\n    delete str;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-3702",
        "length": 137
    },
    {
        "index": 160813,
        "code": "void RenderViewImpl::OnSetLocalSurfaceIdForAutoResize(\n    uint64_t sequence_number,\n    const gfx::Size& min_size,\n    const gfx::Size& max_size,\n    const content::ScreenInfo& screen_info,\n    uint32_t content_source_id,\n    const viz::LocalSurfaceId& local_surface_id) {\n  if (!auto_resize_mode_ || resize_or_repaint_ack_num_ != sequence_number)\n    return;\n\n  SetLocalSurfaceIdForAutoResize(sequence_number, screen_info,\n                                 content_source_id, local_surface_id);\n\n  if (IsUseZoomForDSFEnabled()) {\n    webview()->EnableAutoResizeMode(\n        gfx::ScaleToCeiledSize(min_size, device_scale_factor_),\n        gfx::ScaleToCeiledSize(max_size, device_scale_factor_));\n  } else {\n    webview()->EnableAutoResizeMode(min_size, max_size);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 189
    },
    {
        "index": 64836,
        "code": "static void my_term_source_fn(j_decompress_ptr cinfo)\n{\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-9207",
        "length": 16
    },
    {
        "index": 64491,
        "code": "R_API bool r_config_save_num(RConfigHold *h, ...) {\n\tva_list ap;\n\tchar *key;\n\tif (!h->list_num) {\n\t\th->list_num = r_list_newf ((RListFree) free);\n\t\tif (!h->list_num) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tva_start (ap, h);\n\twhile ((key = va_arg (ap, char *))) {\n\t\tRConfigHoldNum *hc = R_NEW0 (RConfigHoldNum);\n\t\tif (!hc) {\n\t\t\tcontinue;\n\t\t}\n\t\thc->key = key;\n\t\thc->value = r_config_get_i (h->cfg, key);\n\t\tr_list_append (h->list_num, hc);\n\t}\n\tva_end (ap);\n\treturn true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-9520",
        "length": 164
    },
    {
        "index": 172667,
        "code": "status_t MediaPlayer::invoke(const Parcel& request, Parcel *reply)\n{\n Mutex::Autolock _l(mLock);\n const bool hasBeenInitialized =\n (mCurrentState != MEDIA_PLAYER_STATE_ERROR) &&\n ((mCurrentState & MEDIA_PLAYER_IDLE) != MEDIA_PLAYER_IDLE);\n if ((mPlayer != NULL) && hasBeenInitialized) {\n        ALOGV(\"invoke %zu\", request.dataSize());\n return  mPlayer->invoke(request, reply);\n }\n    ALOGE(\"invoke failed: wrong state %X\", mCurrentState);\n return INVALID_OPERATION;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-3821",
        "length": 113
    },
    {
        "index": 133238,
        "code": "void TaskQueue::QueueAsValueInto(const base::DelayedTaskQueue& queue,\n                                 base::trace_event::TracedValue* state) {\n  base::DelayedTaskQueue queue_copy(queue);\n  while (!queue_copy.empty()) {\n    TaskAsValueInto(queue_copy.top(), state);\n    queue_copy.pop();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 68
    },
    {
        "index": 10334,
        "code": "  psh_glyph_load_points( PSH_Glyph  glyph,\n                         FT_Int     dimension )\n  {\n    FT_Vector*  vec   = glyph->outline->points;\n    PSH_Point   point = glyph->points;\n    FT_UInt     count = glyph->num_points;\n\n\n    for ( ; count > 0; count--, point++, vec++ )\n    {\n      point->flags2 = 0;\n      point->hint   = NULL;\n      if ( dimension == 0 )\n      {\n        point->org_u = vec->x;\n        point->org_v = vec->y;\n      }\n      else\n      {\n        point->org_u = vec->y;\n        point->org_v = vec->x;\n      }\n\n#ifdef DEBUG_HINTER\n      point->org_x = vec->x;\n      point->org_y = vec->y;\n#endif\n\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2010-2498",
        "length": 185
    },
    {
        "index": 93192,
        "code": "parse_interface_number(const char *device)\n{\n\tlong devnum;\n\tchar *end;\n\n\tdevnum = strtol(device, &end, 10);\n\tif (device != end && *end == '\\0') {\n\t\t/*\n\t\t * It's all-numeric, but is it a valid number?\n\t\t */\n\t\tif (devnum <= 0) {\n\t\t\t/*\n\t\t\t * No, it's not an ordinal.\n\t\t\t */\n\t\t\terror(\"Invalid adapter index\");\n\t\t}\n\t\treturn (devnum);\n\t} else {\n\t\t/*\n\t\t * It's not all-numeric; return -1, so our caller\n\t\t * knows that.\n\t\t */\n\t\treturn (-1);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-120",
        "cve": "CVE-2018-14879",
        "length": 143
    },
    {
        "index": 122777,
        "code": "void BrowserPluginGuest::UpdateRect(\n    RenderViewHost* render_view_host,\n    const ViewHostMsg_UpdateRect_Params& params) {\n  if (!params.needs_ack)\n    return;\n\n  if (((auto_size_enabled_ && InAutoSizeBounds(params.view_size)) ||\n      (params.view_size.width() == damage_view_size().width() &&\n       params.view_size.height() == damage_view_size().height())) &&\n       params.scale_factor == damage_buffer_scale_factor()) {\n    TransportDIB* dib = render_view_host->GetProcess()->\n        GetTransportDIB(params.bitmap);\n    if (dib) {\n#if defined(OS_WIN)\n      size_t guest_damage_buffer_size = params.bitmap_rect.width() *\n                                        params.bitmap_rect.height() * 4;\n      size_t embedder_damage_buffer_size = damage_buffer_size_;\n#else\n      size_t guest_damage_buffer_size = dib->size();\n      size_t embedder_damage_buffer_size = damage_buffer_->size();\n#endif\n      void* guest_memory = dib->memory();\n      void* embedder_memory = damage_buffer_->memory();\n      size_t size = std::min(guest_damage_buffer_size,\n                             embedder_damage_buffer_size);\n      memcpy(embedder_memory, guest_memory, size);\n    }\n  }\n  BrowserPluginMsg_UpdateRect_Params relay_params;\n#if defined(OS_MACOSX)\n  relay_params.damage_buffer_identifier = damage_buffer_->id();\n#elif defined(OS_WIN)\n  relay_params.damage_buffer_identifier = remote_damage_buffer_handle_;\n#else\n  relay_params.damage_buffer_identifier = damage_buffer_->handle();\n#endif\n  relay_params.bitmap_rect = params.bitmap_rect;\n  relay_params.scroll_delta = params.scroll_delta;\n  relay_params.scroll_rect = params.scroll_rect;\n  relay_params.copy_rects = params.copy_rects;\n  relay_params.view_size = params.view_size;\n  relay_params.scale_factor = params.scale_factor;\n  relay_params.is_resize_ack = ViewHostMsg_UpdateRect_Flags::is_resize_ack(\n      params.flags);\n\n  int message_id = pending_update_counter_++;\n  pending_updates_.AddWithID(render_view_host, message_id);\n\n  SendMessageToEmbedder(new BrowserPluginMsg_UpdateRect(embedder_routing_id(),\n                                                        instance_id(),\n                                                        message_id,\n                                                        relay_params));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 457
    },
    {
        "index": 130232,
        "code": "bool HasData(IDataObject* data_object, const Clipboard::FormatType& format) {\n  FORMATETC format_etc = format.ToFormatEtc();\n  return SUCCEEDED(data_object->QueryGetData(&format_etc));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 49
    },
    {
        "index": 18480,
        "code": "static int kvp_write_file(FILE *f, char *s1, char *s2, char *s3)\n{\n\tint ret;\n\n\tret = fprintf(f, \"%s%s%s%s\\n\", s1, s2, \"=\", s3);\n\n\tif (ret < 0)\n\t\treturn HV_E_FAIL;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5532",
        "length": 69
    },
    {
        "index": 46222,
        "code": "static bool generic_pkt_to_tuple(const struct sk_buff *skb,\n\t\t\t\t unsigned int dataoff,\n\t\t\t\t struct nf_conntrack_tuple *tuple)\n{\n\ttuple->src.u.all = 0;\n\ttuple->dst.u.all = 0;\n\n\treturn true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2014-8160",
        "length": 54
    },
    {
        "index": 38923,
        "code": "lseg_interpt(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *l1 = PG_GETARG_LSEG_P(0);\n\tLSEG\t   *l2 = PG_GETARG_LSEG_P(1);\n\tPoint\t   *result;\n\n\tresult = lseg_interpt_internal(l1, l2);\n\tif (!PointerIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_POINT_P(result);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 81
    },
    {
        "index": 187600,
        "code": "find_insert(png_const_charp what, png_charp param)\n{\n   png_uint_32 chunk = 0;\n   png_charp parameter_list[1024];\n int i, nparams;\n\n /* Assemble the chunk name */\n for (i=0; i<4; ++i)\n {\n char ch = what[i];\n\n if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))\n         chunk = (chunk << 8) + what[i];\n\n else\n break;\n }\n\n if (i < 4 || what[4] != 0)\n {\n      fprintf(stderr, \"makepng --insert \\\"%s\\\": invalid chunk name\\n\", what);\n      exit(1);\n }\n\n /* Assemble the parameter list. */\n   nparams = find_parameters(what, param, parameter_list, 1024);\n\n#  define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))\n\n switch (chunk)\n {\n case CHUNK(105,67,67,80): /* iCCP */\n if (nparams == 2)\n return make_insert(what, insert_iCCP, nparams, parameter_list);\n break;\n\n case CHUNK(116,69,88,116): /* tEXt */\n if (nparams == 2)\n return make_insert(what, insert_tEXt, nparams, parameter_list);\n break;\n\n case CHUNK(122,84,88,116): /* zTXt */\n if (nparams == 2)\n return make_insert(what, insert_zTXt, nparams, parameter_list);\n break;\n\n case CHUNK(105,84,88,116): /* iTXt */\n if (nparams == 4)\n return make_insert(what, insert_iTXt, nparams, parameter_list);\n break;\n\n case CHUNK(104,73,83,84): /* hIST */\n if (nparams <= 256)\n\n             return make_insert(what, insert_hIST, nparams, parameter_list);\n          break;\n \n #if 0\n       case CHUNK(115,80,76,84):  /* sPLT */\n          return make_insert(what, insert_sPLT, nparams, parameter_list);\n#endif\n\n default:\n         fprintf(stderr, \"makepng --insert \\\"%s\\\": unrecognized chunk name\\n\",\n            what);\n         exit(1);\n }\n\n   bad_parameter_count(what, nparams);\n\n    return NULL;\n }\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 510
    },
    {
        "index": 152720,
        "code": "const std::string LinearHistogram::GetAsciiBucketRange(uint32_t i) const {\n  int range = ranges(i);\n  BucketDescriptionMap::const_iterator it = bucket_description_.find(range);\n  if (it == bucket_description_.end())\n    return Histogram::GetAsciiBucketRange(i);\n  return it->second;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-5023",
        "length": 68
    },
    {
        "index": 28409,
        "code": "static struct rt6_info *fib6_find_prefix(struct net *net, struct fib6_node *fn)\n{\n\tif (fn->fn_flags & RTN_ROOT)\n\t\treturn net->ipv6.ip6_null_entry;\n\n\twhile (fn) {\n\t\tif (fn->left)\n\t\t\treturn fn->left->leaf;\n\t\tif (fn->right)\n\t\t\treturn fn->right->leaf;\n\n\t\tfn = FIB6_SUBTREE(fn);\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-6431",
        "length": 97
    },
    {
        "index": 43978,
        "code": "__subtract_xml_object(xmlNode * target, xmlNode * patch)\n{\n    xmlNode *patch_child = NULL;\n    xmlNode *cIter = NULL;\n    xmlAttrPtr xIter = NULL;\n\n    char *id = NULL;\n    const char *name = NULL;\n    const char *value = NULL;\n\n    if (target == NULL || patch == NULL) {\n        return;\n    }\n\n    if (target->type == XML_COMMENT_NODE) {\n        gboolean dummy;\n\n        subtract_xml_comment(target->parent, target, patch, &dummy);\n    }\n\n    name = crm_element_name(target);\n    CRM_CHECK(name != NULL, return);\n    CRM_CHECK(safe_str_eq(crm_element_name(target), crm_element_name(patch)), return);\n    CRM_CHECK(safe_str_eq(ID(target), ID(patch)), return);\n\n    /* check for XML_DIFF_MARKER in a child */\n    id = crm_element_value_copy(target, XML_ATTR_ID);\n    value = crm_element_value(patch, XML_DIFF_MARKER);\n    if (value != NULL && strcmp(value, \"removed:top\") == 0) {\n        crm_trace(\"We are the root of the deletion: %s.id=%s\", name, id);\n        free_xml(target);\n        free(id);\n        return;\n    }\n\n    for (xIter = crm_first_attr(patch); xIter != NULL; xIter = xIter->next) {\n        const char *p_name = (const char *)xIter->name;\n\n        /* Removing and then restoring the id field would change the ordering of properties */\n        if (safe_str_neq(p_name, XML_ATTR_ID)) {\n            xml_remove_prop(target, p_name);\n        }\n    }\n\n    /* changes to child objects */\n    cIter = __xml_first_child(target);\n    while (cIter) {\n        xmlNode *target_child = cIter;\n\n        cIter = __xml_next(cIter);\n\n        if (target_child->type == XML_COMMENT_NODE) {\n            patch_child = find_xml_comment(patch, target_child);\n\n        } else {\n            patch_child = find_entity(patch, crm_element_name(target_child), ID(target_child));\n        }\n\n        __subtract_xml_object(target_child, patch_child);\n    }\n    free(id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-1867",
        "length": 463
    },
    {
        "index": 133748,
        "code": "int SSLClientSocketOpenSSL::DoPayloadWrite() {\n  crypto::OpenSSLErrStackTracer err_tracer(FROM_HERE);\n  int rv = SSL_write(ssl_, user_write_buf_->data(), user_write_buf_len_);\n\n  if (rv >= 0) {\n    net_log_.AddByteTransferEvent(NetLog::TYPE_SSL_SOCKET_BYTES_SENT, rv,\n                                  user_write_buf_->data());\n    return rv;\n  }\n\n  int err = SSL_get_error(ssl_, rv);\n  return MapOpenSSLError(err, err_tracer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 117
    },
    {
        "index": 187714,
        "code": " sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,\n    png_uint_32 x, unsigned int sample_index)\n {\n    png_uint_32 bit_index, result;\n \n /* Find a sample index for the desired sample: */\n   x *= bit_depth;\n   bit_index = x;\n\n if ((colour_type & 1) == 0) /* !palette */\n {\n if (colour_type & 2)\n         bit_index *= 3;\n\n if (colour_type & 4)\n         bit_index += x; /* Alpha channel */\n\n /* Multiple channels; select one: */\n if (colour_type & (2+4))\n         bit_index += sample_index * bit_depth;\n }\n\n /* Return the sample from the row as an integer. */\n   row += bit_index >> 3;\n   result = *row;\n\n if (bit_depth == 8)\n\n       return result;\n \n    else if (bit_depth > 8)\n      return (result << 8) + *++row;\n \n   /* Less than 8 bits per sample. */\n    bit_index &= 7;\n   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);\n }\n",
        "line": "    png_uint_32 x, unsigned int sample_index)\n      return (result << 8) + *++row;\n   /* Less than 8 bits per sample. */\n   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);\n",
        "label": 1,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 249
    },
    {
        "index": 10429,
        "code": "static int megasas_dcmd_pd_get_info(MegasasState *s, MegasasCmd *cmd)\n{\n    size_t dcmd_size = sizeof(struct mfi_pd_info);\n    uint16_t pd_id;\n    uint8_t target_id, lun_id;\n    SCSIDevice *sdev = NULL;\n    int retval = MFI_STAT_DEVICE_NOT_FOUND;\n\n    if (cmd->iov_size < dcmd_size) {\n        return MFI_STAT_INVALID_PARAMETER;\n    }\n\n    /* mbox0 has the ID */\n    pd_id = le16_to_cpu(cmd->frame->dcmd.mbox[0]);\n    target_id = (pd_id >> 8) & 0xFF;\n    lun_id = pd_id & 0xFF;\n    sdev = scsi_device_find(&s->bus, 0, target_id, lun_id);\n    trace_megasas_dcmd_pd_get_info(cmd->index, pd_id);\n\n    if (sdev) {\n        /* Submit inquiry */\n        retval = megasas_pd_get_info_submit(sdev, pd_id, cmd);\n    }\n\n    return retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-5337",
        "length": 232
    },
    {
        "index": 23233,
        "code": "nfs4_proc_setattr(struct dentry *dentry, struct nfs_fattr *fattr,\n\t\t  struct iattr *sattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct rpc_cred *cred = NULL;\n\tstruct nfs4_state *state = NULL;\n\tint status;\n\n\tif (pnfs_ld_layoutret_on_setattr(inode))\n\t\tpnfs_return_layout(inode);\n\n\tnfs_fattr_init(fattr);\n\t\n\t/* Search for an existing open(O_WRITE) file */\n\tif (sattr->ia_valid & ATTR_FILE) {\n\t\tstruct nfs_open_context *ctx;\n\n\t\tctx = nfs_file_open_context(sattr->ia_file);\n\t\tif (ctx) {\n\t\t\tcred = ctx->cred;\n\t\t\tstate = ctx->state;\n\t\t}\n\t}\n\n\tstatus = nfs4_do_setattr(inode, cred, fattr, sattr, state);\n\tif (status == 0)\n\t\tnfs_setattr_update_inode(inode, sattr);\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-4131",
        "length": 204
    },
    {
        "index": 21008,
        "code": "static void __mem_cgroup_free(struct mem_cgroup *memcg)\n{\n\tint node;\n\n\tmem_cgroup_remove_from_trees(memcg);\n\tfree_css_id(&mem_cgroup_subsys, &memcg->css);\n\n\tfor_each_node(node)\n\t\tfree_mem_cgroup_per_zone_info(memcg, node);\n\n\tfree_percpu(memcg->stat);\n\tif (sizeof(struct mem_cgroup) < PAGE_SIZE)\n\t\tkfree_rcu(memcg, rcu_freeing);\n\telse\n\t\tcall_rcu(&memcg->rcu_freeing, vfree_rcu);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-1179",
        "length": 116
    },
    {
        "index": 156418,
        "code": "void PageHandler::ScreenshotCaptured(\n    std::unique_ptr<CaptureScreenshotCallback> callback,\n    const std::string& format,\n    int quality,\n    const gfx::Size& original_view_size,\n    const gfx::Size& requested_image_size,\n    const blink::WebDeviceEmulationParams& original_emulation_params,\n    const gfx::Image& image) {\n  if (original_view_size.width()) {\n    RenderWidgetHostImpl* widget_host = host_->GetRenderWidgetHost();\n    widget_host->GetView()->SetSize(original_view_size);\n    emulation_handler_->SetDeviceEmulationParams(original_emulation_params);\n  }\n\n  if (image.IsEmpty()) {\n    callback->sendFailure(Response::Error(\"Unable to capture screenshot\"));\n    return;\n  }\n\n  if (!requested_image_size.IsEmpty() &&\n      (image.Width() != requested_image_size.width() ||\n       image.Height() != requested_image_size.height())) {\n    const SkBitmap* bitmap = image.ToSkBitmap();\n    SkBitmap cropped = SkBitmapOperations::CreateTiledBitmap(\n        *bitmap, 0, 0, requested_image_size.width(),\n        requested_image_size.height());\n    gfx::Image croppedImage = gfx::Image::CreateFrom1xBitmap(cropped);\n    callback->sendSuccess(EncodeImage(croppedImage, format, quality));\n  } else {\n    callback->sendSuccess(EncodeImage(image, format, quality));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-18344",
        "length": 292
    },
    {
        "index": 163314,
        "code": "void CreateSingleSampleMetricsProvider(\n    scoped_refptr<base::SingleThreadTaskRunner> task_runner,\n    service_manager::Connector* connector,\n    metrics::mojom::SingleSampleMetricsProviderRequest request) {\n  if (task_runner->BelongsToCurrentThread()) {\n    connector->BindInterface(mojom::kBrowserServiceName, std::move(request));\n    return;\n  }\n\n  task_runner->PostTask(\n      FROM_HERE,\n      base::BindOnce(&CreateSingleSampleMetricsProvider, std::move(task_runner),\n                     connector, base::Passed(&request)));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2017-15423",
        "length": 118
    },
    {
        "index": 181260,
        "code": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n\n      if (ext_block->depth == 0)\n        return ext_block;\n\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n\n      if (--i < 0)\n        return 0;\n\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n       block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n       if (grub_disk_read (data->disk,\n                           block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n         return 0;\n \n       ext_block = (struct grub_ext4_extent_header *) buf;\n     }\n}\n",
        "line": "                          0, EXT2_BLOCK_SIZE(data), buf))\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2017-9763",
        "length": 281
    },
    {
        "index": 182694,
        "code": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n \tint unit;\n \tunregister_blkdev(major, name);\n \tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n \t\tif (pf->present)\n \t\t\tdel_gendisk(pf->disk);\n \n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15922",
        "length": 119
    },
    {
        "index": 21020,
        "code": "static void drain_all_stock_async(struct mem_cgroup *root_memcg)\n{\n\t/*\n\t * If someone calls draining, avoid adding more kworker runs.\n\t */\n\tif (!mutex_trylock(&percpu_charge_mutex))\n\t\treturn;\n\tdrain_all_stock(root_memcg, false);\n\tmutex_unlock(&percpu_charge_mutex);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-1179",
        "length": 68
    },
    {
        "index": 185428,
        "code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n \n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n\n  return handled;\n}\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 396
    },
    {
        "index": 101085,
        "code": "  void DeleteClientOriginData(QuotaClient* client,\n                        const GURL& origin,\n                        StorageType type) {\n    DCHECK(client);\n    quota_status_ = kQuotaStatusUnknown;\n    client->DeleteOriginData(origin, type,\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::StatusCallback));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 70
    },
    {
        "index": 47945,
        "code": "static int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)\n{\n\tu64 old = ctxt->dst.orig_val64;\n\n\tif (ctxt->dst.bytes == 16)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\tif (((u32) (old >> 0) != (u32) reg_read(ctxt, VCPU_REGS_RAX)) ||\n\t    ((u32) (old >> 32) != (u32) reg_read(ctxt, VCPU_REGS_RDX))) {\n\t\t*reg_write(ctxt, VCPU_REGS_RAX) = (u32) (old >> 0);\n\t\t*reg_write(ctxt, VCPU_REGS_RDX) = (u32) (old >> 32);\n\t\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\t} else {\n\t\tctxt->dst.val64 = ((u64)reg_read(ctxt, VCPU_REGS_RCX) << 32) |\n\t\t\t(u32) reg_read(ctxt, VCPU_REGS_RBX);\n\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-9756",
        "length": 243
    },
    {
        "index": 91318,
        "code": "send_channel_info_cmd(struct ipmi_smi *intf, int chan)\n{\n\tstruct kernel_ipmi_msg            msg;\n\tunsigned char                     data[1];\n\tstruct ipmi_system_interface_addr si;\n\n\tsi.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsi.channel = IPMI_BMC_CHANNEL;\n\tsi.lun = 0;\n\n\tmsg.netfn = IPMI_NETFN_APP_REQUEST;\n\tmsg.cmd = IPMI_GET_CHANNEL_INFO_CMD;\n\tmsg.data = data;\n\tmsg.data_len = 1;\n\tdata[0] = chan;\n\treturn i_ipmi_request(NULL,\n\t\t\t      intf,\n\t\t\t      (struct ipmi_addr *) &si,\n\t\t\t      0,\n\t\t\t      &msg,\n\t\t\t      intf,\n\t\t\t      NULL,\n\t\t\t      NULL,\n\t\t\t      0,\n\t\t\t      intf->addrinfo[0].address,\n\t\t\t      intf->addrinfo[0].lun,\n\t\t\t      -1, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-9003",
        "length": 180
    },
    {
        "index": 39096,
        "code": "bitsubstr_no_len(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_VARBIT_P(bitsubstring(PG_GETARG_VARBIT_P(0),\n\t\t\t\t\t\t\t\t\tPG_GETARG_INT32(1),\n\t\t\t\t\t\t\t\t\t-1, true));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 49
    },
    {
        "index": 162021,
        "code": "void BrowserChildProcessHostImpl::Launch(\n    std::unique_ptr<SandboxedProcessLauncherDelegate> delegate,\n    std::unique_ptr<base::CommandLine> cmd_line,\n    bool terminate_on_shutdown) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  GetContentClient()->browser()->AppendExtraCommandLineSwitches(cmd_line.get(),\n                                                                data_.id);\n\n  const base::CommandLine& browser_command_line =\n      *base::CommandLine::ForCurrentProcess();\n  static const char* const kForwardSwitches[] = {\n      service_manager::switches::kDisableInProcessStackTraces,\n      switches::kDisableLogging,\n      switches::kEnableLogging,\n      switches::kIPCConnectionTimeout,\n      switches::kLoggingLevel,\n      switches::kTraceToConsole,\n      switches::kV,\n      switches::kVModule,\n  };\n  cmd_line->CopySwitchesFrom(browser_command_line, kForwardSwitches,\n                             arraysize(kForwardSwitches));\n\n  if (child_connection_) {\n    cmd_line->AppendSwitchASCII(switches::kServiceRequestChannelToken,\n                                child_connection_->service_token());\n  }\n\n  DCHECK(broker_client_invitation_);\n  notify_child_disconnected_ = true;\n  child_process_.reset(new ChildProcessLauncher(\n      std::move(delegate), std::move(cmd_line), data_.id, this,\n      std::move(broker_client_invitation_),\n      base::Bind(&BrowserChildProcessHostImpl::OnMojoError,\n                 weak_factory_.GetWeakPtr(),\n                 base::ThreadTaskRunnerHandle::Get()),\n      terminate_on_shutdown));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 330
    },
    {
        "index": 11362,
        "code": "fbCombineDisjointAtopU (CARD32 *dest, const CARD32 *src, int width)\n{\n    fbCombineDisjointGeneralU (dest, src, width, CombineAAtop);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2010-1166",
        "length": 44
    },
    {
        "index": 8201,
        "code": "static int free_fid(V9fsPDU *pdu, V9fsFidState *fidp)\n{\n    int retval = 0;\n\n    if (fidp->fid_type == P9_FID_FILE) {\n        /* If we reclaimed the fd no need to close */\n        if (fidp->fs.fd != -1) {\n            retval = v9fs_co_close(pdu, &fidp->fs);\n        }\n    } else if (fidp->fid_type == P9_FID_DIR) {\n        if (fidp->fs.dir.stream != NULL) {\n            retval = v9fs_co_closedir(pdu, &fidp->fs);\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        retval = v9fs_xattr_fid_clunk(pdu, fidp);\n    }\n    v9fs_path_free(&fidp->path);\n    g_free(fidp);\n    return retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-8577",
        "length": 204
    },
    {
        "index": 145436,
        "code": "  rtc::scoped_refptr<rtc::RTCCertificate> certificate() { return certificate_; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-1667",
        "length": 20
    },
    {
        "index": 36542,
        "code": "void RenameThread(const char* name)\n{\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"cg@%s\", name);\n#if defined(PR_SET_NAME)\n\tprctl(PR_SET_NAME, buf, 0, 0, 0);\n#elif (defined(__FreeBSD__) || defined(__OpenBSD__))\n\tpthread_set_name_np(pthread_self(), buf);\n#elif defined(MAC_OSX)\n\tpthread_setname_np(buf);\n#else\n\t(void)buf;\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-4503",
        "length": 97
    },
    {
        "index": 159820,
        "code": "static bool IsNonCanonicalCharacter(UChar c) {\n  return (c == '\\\\' || c == '0' || c == '\\0' || c == '/' || c == '?' ||\n          c == '%' || c >= 127);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2018-6051",
        "length": 50
    },
    {
        "index": 61405,
        "code": "static int mov_read_aclr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = 0;\n    int length = 0;\n    uint64_t original_size;\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_id == AV_CODEC_ID_H264)\n            return 0;\n        if (atom.size == 16) {\n            original_size = par->extradata_size;\n            ret = mov_realloc_extradata(par, atom);\n            if (!ret) {\n                length =  mov_read_atom_into_extradata(c, pb, atom, par, par->extradata + original_size);\n                if (length == atom.size) {\n                    const uint8_t range_value = par->extradata[original_size + 19];\n                    switch (range_value) {\n                    case 1:\n                        par->color_range = AVCOL_RANGE_MPEG;\n                        break;\n                    case 2:\n                        par->color_range = AVCOL_RANGE_JPEG;\n                        break;\n                    default:\n                        av_log(c, AV_LOG_WARNING, \"ignored unknown aclr value (%d)\\n\", range_value);\n                        break;\n                    }\n                    ff_dlog(c, \"color_range: %d\\n\", par->color_range);\n                } else {\n                  /* For some reason the whole atom was not added to the extradata */\n                  av_log(c, AV_LOG_ERROR, \"aclr not decoded - incomplete atom\\n\");\n                }\n            } else {\n                av_log(c, AV_LOG_ERROR, \"aclr not decoded - unable to add atom to extradata\\n\");\n            }\n        } else {\n            av_log(c, AV_LOG_WARNING, \"aclr not decoded - unexpected size %\"PRId64\"\\n\", atom.size);\n        }\n    }\n\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-834",
        "cve": "CVE-2017-14222",
        "length": 404
    },
    {
        "index": 128667,
        "code": "int ContextualSearchFieldTrial::GetIcingSurroundingSize() {\n  return GetIntParamValueOrDefault(\n      kContextualSearchIcingSurroundingSizeParamName,\n      kContextualSearchDefaultIcingSurroundingSize,\n      &is_icing_surrounding_size_cached_, &icing_surrounding_size_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3200",
        "length": 71
    },
    {
        "index": 183807,
        "code": "void RTCPeerConnectionHandlerDummy::setRemoteDescription(PassRefPtr<RTCVoidRequest>, PassRefPtr<RTCSessionDescriptionDescriptor>)\n{\n}\n",
        "line": "{\n}\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2875",
        "length": 31
    },
    {
        "index": 46233,
        "code": "static int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-7822",
        "length": 34
    },
    {
        "index": 160380,
        "code": "bool HeapDoesNotContainCache::lookup(Address address) {\n  ASSERT(ThreadState::current()->isInGC());\n\n  size_t index = hash(address);\n  ASSERT(!(index & 1));\n  Address cachePage = roundToBlinkPageStart(address);\n  if (m_entries[index] == cachePage)\n    return m_entries[index];\n  if (m_entries[index + 1] == cachePage)\n    return m_entries[index + 1];\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-6094",
        "length": 98
    },
    {
        "index": 54084,
        "code": "struct in_ifaddr *inet_ifa_byprefix(struct in_device *in_dev, __be32 prefix,\n\t\t\t\t    __be32 mask)\n{\n\tASSERT_RTNL();\n\n\tfor_primary_ifa(in_dev) {\n\t\tif (ifa->ifa_mask == mask && inet_ifa_match(prefix, ifa))\n\t\t\treturn ifa;\n\t} endfor_ifa(in_dev);\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-3156",
        "length": 81
    },
    {
        "index": 133756,
        "code": "int SSLClientSocketOpenSSL::ExportKeyingMaterial(\n    const base::StringPiece& label,\n    bool has_context, const base::StringPiece& context,\n    unsigned char* out, unsigned int outlen) {\n  crypto::OpenSSLErrStackTracer err_tracer(FROM_HERE);\n\n  int rv = SSL_export_keying_material(\n      ssl_, out, outlen, const_cast<char*>(label.data()),\n      label.size(),\n      reinterpret_cast<unsigned char*>(const_cast<char*>(context.data())),\n      context.length(),\n      context.length() > 0);\n\n  if (rv != 1) {\n    int ssl_error = SSL_get_error(ssl_, rv);\n    LOG(ERROR) << \"Failed to export keying material;\"\n               << \" returned \" << rv\n               << \", SSL error code \" << ssl_error;\n    return MapOpenSSLError(ssl_error, err_tracer);\n  }\n  return OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 193
    },
    {
        "index": 73087,
        "code": "BGD_DECLARE(void) gdImageSetStyle (gdImagePtr im, int *style, int noOfPixels)\n{\n\tif (im->style) {\n\t\tgdFree (im->style);\n\t}\n\tif (overflow2(sizeof (int), noOfPixels)) {\n\t\treturn;\n\t}\n\tim->style = (int *) gdMalloc (sizeof (int) * noOfPixels);\n\tif (!im->style) {\n\t\treturn;\n\t}\n\tmemcpy (im->style, style, sizeof (int) * noOfPixels);\n\tim->styleLength = noOfPixels;\n\tim->stylePos = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-9317",
        "length": 128
    },
    {
        "index": 144708,
        "code": "bool WebContentsImpl::WasRecentlyAudible() {\n  return audio_stream_monitor_.WasRecentlyAudible();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1641",
        "length": 24
    },
    {
        "index": 8060,
        "code": "char **FoFiType1::getEncoding() {\n  if (!parsed) {\n    parse();\n  }\n  return encoding;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-3704",
        "length": 28
    },
    {
        "index": 186360,
        "code": "bool IsIDNComponentSafe(base::StringPiece16 label) {\n  return g_idn_spoof_checker.Get().Check(label);\n }\n",
        "line": "  return g_idn_spoof_checker.Get().Check(label);\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5060",
        "length": 30
    },
    {
        "index": 59979,
        "code": "static int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = cval->channels;\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 1;\n\t} else {\n\t\tif (!cval->initialized) {\n\t\t\tget_min_max_with_quirks(cval, 0, kcontrol);\n\t\t\tif (cval->initialized && cval->dBmin >= cval->dBmax) {\n\t\t\t\tkcontrol->vd[0].access &= \n\t\t\t\t\t~(SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK);\n\t\t\t\tsnd_ctl_notify(cval->head.mixer->chip->card,\n\t\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t\t\t       &kcontrol->id);\n\t\t\t}\n\t\t}\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max =\n\t\t\t(cval->max - cval->min + cval->res - 1) / cval->res;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-16527",
        "length": 328
    },
    {
        "index": 89438,
        "code": "int nfc_genl_device_removed(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12984",
        "length": 171
    },
    {
        "index": 64989,
        "code": "IW_IMPL(void) iw_set_dither_type(struct iw_context *ctx, int channeltype, int f, int s)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->ditherfamily_by_channeltype[channeltype] = f;\n\t\tctx->dithersubtype_by_channeltype[channeltype] = s;\n\t}\n\n\tswitch(channeltype) {\n\tcase IW_CHANNELTYPE_ALL:\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_ALPHA] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_ALPHA] = s;\n\tcase IW_CHANNELTYPE_NONALPHA:\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_RED] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_RED] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_GREEN] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_GREEN] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_BLUE] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_BLUE] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_GRAY] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_GRAY] = s;\n\t\tbreak;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2017-9202",
        "length": 291
    },
    {
        "index": 28623,
        "code": "static int qeth_register_dbf_views(void)\n{\n\tint ret;\n\tint x;\n\n\tfor (x = 0; x < QETH_DBF_INFOS; x++) {\n\t\t/* register the areas */\n\t\tqeth_dbf[x].id = debug_register(qeth_dbf[x].name,\n\t\t\t\t\t\tqeth_dbf[x].pages,\n\t\t\t\t\t\tqeth_dbf[x].areas,\n\t\t\t\t\t\tqeth_dbf[x].len);\n\t\tif (qeth_dbf[x].id == NULL) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* register a view */\n\t\tret = debug_register_view(qeth_dbf[x].id, qeth_dbf[x].view);\n\t\tif (ret) {\n\t\t\tqeth_unregister_dbf_views();\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* set a passing level */\n\t\tdebug_set_level(qeth_dbf[x].id, qeth_dbf[x].level);\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6381",
        "length": 205
    },
    {
        "index": 83483,
        "code": "static inline void cond_local_irq_disable(struct pt_regs *regs)\n{\n\tif (regs->flags & X86_EFLAGS_IF)\n\t\tlocal_irq_disable();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-8897",
        "length": 33
    },
    {
        "index": 69733,
        "code": "guard_selection_new(const char *name,\n                    guard_selection_type_t type)\n{\n  guard_selection_t *gs;\n\n  type = guard_selection_infer_type(type, name);\n\n  gs = tor_malloc_zero(sizeof(*gs));\n  gs->name = tor_strdup(name);\n  gs->type = type;\n  gs->sampled_entry_guards = smartlist_new();\n  gs->confirmed_entry_guards = smartlist_new();\n  gs->primary_entry_guards = smartlist_new();\n\n  return gs;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-0377",
        "length": 104
    },
    {
        "index": 182324,
        "code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n \t\t    info->cmap.len || cmap->start < info->cmap.start)\n \t\t\treturn -EINVAL;\n \n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n \t\tif (!entries)\n \t\t\treturn -ENOMEM;\n \n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\t/*\n\t\t * For modes with bpp > 8, we only set the pseudo palette in\n\t\t * the fb_info struct. We rely on uvesafb_setcolreg to do all\n\t\t * sanity checking.\n\t\t */\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}\n",
        "line": "\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n",
        "label": 1,
        "cwe": "CWE-190",
        "cve": "CVE-2018-13406",
        "length": 355
    },
    {
        "index": 147006,
        "code": "bool WebLocalFrameImpl::HasSelection() const {\n  DCHECK(GetFrame());\n  WebPluginContainerImpl* plugin_container =\n      GetFrame()->GetWebPluginContainer();\n  if (plugin_container)\n    return plugin_container->Plugin()->HasSelection();\n\n  return GetFrame()\n             ->Selection()\n             .ComputeVisibleSelectionInDOMTreeDeprecated()\n             .Start() != GetFrame()\n                             ->Selection()\n                             .ComputeVisibleSelectionInDOMTreeDeprecated()\n                             .End();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 97
    },
    {
        "index": 124576,
        "code": "int RenderBlock::lastLineBoxBaseline(LineDirectionMode lineDirection) const\n{\n    if (isWritingModeRoot() && !isRubyRun())\n        return -1;\n\n    if (childrenInline()) {\n        if (!firstLineBox() && hasLineIfEmpty()) {\n            const FontMetrics& fontMetrics = firstLineStyle()->fontMetrics();\n            return fontMetrics.ascent()\n                 + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2\n                 + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight());\n        }\n        if (lastLineBox())\n            return lastLineBox()->logicalTop() + style(lastLineBox() == firstLineBox())->fontMetrics().ascent(lastRootBox()->baselineType());\n        return -1;\n    } else {\n        bool haveNormalFlowChild = false;\n        for (RenderBox* curr = lastChildBox(); curr; curr = curr->previousSiblingBox()) {\n            if (!curr->isFloatingOrOutOfFlowPositioned()) {\n                haveNormalFlowChild = true;\n                int result = curr->inlineBlockBaseline(lineDirection);\n                if (result != -1)\n                    return curr->logicalTop() + result; // Translate to our coordinate space.\n            }\n        }\n        if (!haveNormalFlowChild && hasLineIfEmpty()) {\n            const FontMetrics& fontMetrics = firstLineStyle()->fontMetrics();\n            return fontMetrics.ascent()\n                 + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2\n                 + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight());\n        }\n    }\n\n    return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 361
    },
    {
        "index": 123484,
        "code": "void SafeBrowsingBlockingPage::NotifySafeBrowsingUIManager(\n    SafeBrowsingUIManager* ui_manager,\n    const UnsafeResourceList& unsafe_resources,\n    bool proceed) {\n  BrowserThread::PostTask(\n      BrowserThread::IO, FROM_HERE,\n      base::Bind(&SafeBrowsingUIManager::OnBlockingPageDone,\n                 ui_manager, unsafe_resources, proceed));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0890",
        "length": 81
    },
    {
        "index": 90583,
        "code": "static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)\n{\n\tunsigned long nr_accounted = 0;\n\n\t/* Update high watermark before we lower total_vm */\n\tupdate_hiwater_vm(mm);\n\tdo {\n\t\tlong nrpages = vma_pages(vma);\n\n\t\tif (vma->vm_flags & VM_ACCOUNT)\n\t\t\tnr_accounted += nrpages;\n\t\tvm_stat_account(mm, vma->vm_flags, -nrpages);\n\t\tvma = remove_vma(vma);\n\t} while (vma);\n\tvm_unacct_memory(nr_accounted);\n\tvalidate_mm(mm);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2019-11599",
        "length": 129
    },
    {
        "index": 163430,
        "code": "void OmniboxViewViews::EnterKeywordModeForDefaultSearchProvider() {\n  model()->EnterKeywordModeForDefaultSearchProvider(\n      KeywordModeEntryMethod::KEYBOARD_SHORTCUT);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2017-15427",
        "length": 40
    },
    {
        "index": 60212,
        "code": "static int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-15951",
        "length": 344
    },
    {
        "index": 10827,
        "code": "int tls1_new(SSL *s)\n\t{\n\tif (!ssl3_new(s)) return(0);\n\ts->method->ssl_clear(s);\n\treturn(1);\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-5139",
        "length": 37
    },
    {
        "index": 95090,
        "code": "client_fqdn_flags(u_int flags)\n{\n\tstatic char buf[8+1];\n\tint i = 0;\n\n\tif (flags & CLIENT_FQDN_FLAGS_S)\n\t\tbuf[i++] = 'S';\n\tif (flags & CLIENT_FQDN_FLAGS_O)\n\t\tbuf[i++] = 'O';\n\tif (flags & CLIENT_FQDN_FLAGS_E)\n\t\tbuf[i++] = 'E';\n\tif (flags & CLIENT_FQDN_FLAGS_N)\n\t\tbuf[i++] = 'N';\n\tbuf[i] = '\\0';\n\n\treturn buf;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13028",
        "length": 112
    },
    {
        "index": 119501,
        "code": "    explicit SpellCheckClient(uint32_t hash = 0) : m_numberOfTimesChecked(0), m_hash(hash) { }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2908",
        "length": 29
    },
    {
        "index": 55995,
        "code": "tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\n{\n\tint ret;\n\n\tret = __tty_ldisc_lock(tty, timeout);\n\tif (!ret)\n\t\treturn -EBUSY;\n\tset_bit(TTY_LDISC_HALTED, &tty->flags);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-8964",
        "length": 62
    },
    {
        "index": 137119,
        "code": "bool InputType::SupportsRequired() const {\n  return SupportsValidation();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 17
    },
    {
        "index": 178239,
        "code": "PHP_METHOD(Phar, offsetSet)\n{\n\tchar *fname, *cont_str = NULL;\n\tsize_t fname_len, cont_len;\n\tzval *zresource;\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Write operations disabled by the php.ini setting phar.readonly\");\n                return;\n        }\n \n       if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"sr\", &fname, &fname_len, &zresource) == FAILURE\n       && zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &fname, &fname_len, &cont_str, &cont_len) == FAILURE) {\n                return;\n        }\n \n\tif (fname_len == sizeof(\".phar/stub.php\")-1 && !memcmp(fname, \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Cannot set stub \\\".phar/stub.php\\\" directly in phar \\\"%s\\\", use setStub\", phar_obj->archive->fname);\n\t\treturn;\n\t}\n\n\tif (fname_len == sizeof(\".phar/alias.txt\")-1 && !memcmp(fname, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Cannot set alias \\\".phar/alias.txt\\\" directly in phar \\\"%s\\\", use setAlias\", phar_obj->archive->fname);\n\t\treturn;\n\t}\n\n\tif (fname_len >= sizeof(\".phar\")-1 && !memcmp(fname, \".phar\", sizeof(\".phar\")-1)) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0, \"Cannot set any files or directories in magic \\\".phar\\\" directory\", phar_obj->archive->fname);\n\t\treturn;\n\t}\n\n\tphar_add_file(&(phar_obj->archive), fname, fname_len, cont_str, cont_len, zresource);\n}\n",
        "line": "       if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"sr\", &fname, &fname_len, &zresource) == FAILURE\n       && zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &fname, &fname_len, &cont_str, &cont_len) == FAILURE) {\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2016-4072",
        "length": 463
    },
    {
        "index": 114226,
        "code": "void CommandBufferProxyImpl::OnChannelError() {\n  for (Decoders::iterator it = video_decoder_hosts_.begin();\n       it != video_decoder_hosts_.end(); ++it) {\n    it->second->OnChannelError();\n  }\n  OnDestroyed(gpu::error::kUnknown);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 63
    },
    {
        "index": 18863,
        "code": "static int __net_init icmp_sk_init(struct net *net)\n{\n\tint i, err;\n\n\tnet->ipv4.icmp_sk =\n\t\tkzalloc(nr_cpu_ids * sizeof(struct sock *), GFP_KERNEL);\n\tif (net->ipv4.icmp_sk == NULL)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct sock *sk;\n\n\t\terr = inet_ctl_sock_create(&sk, PF_INET,\n\t\t\t\t\t   SOCK_RAW, IPPROTO_ICMP, net);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\tnet->ipv4.icmp_sk[i] = sk;\n\n\t\t/* Enough space for 2 64K ICMP packets, including\n\t\t * sk_buff struct overhead.\n\t\t */\n\t\tsk->sk_sndbuf =\n\t\t\t(2 * ((64 * 1024) + sizeof(struct sk_buff)));\n\n\t\t/*\n\t\t * Speedup sock_wfree()\n\t\t */\n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\t\tinet_sk(sk)->pmtudisc = IP_PMTUDISC_DONT;\n\t}\n\n\t/* Control parameters for ECHO replies. */\n\tnet->ipv4.sysctl_icmp_echo_ignore_all = 0;\n\tnet->ipv4.sysctl_icmp_echo_ignore_broadcasts = 1;\n\n\t/* Control parameter - ignore bogus broadcast responses? */\n\tnet->ipv4.sysctl_icmp_ignore_bogus_error_responses = 1;\n\n\t/*\n\t * \tConfigurable global rate limit.\n\t *\n\t *\tratelimit defines tokens/packet consumed for dst->rate_token\n\t *\tbucket ratemask defines which icmp types are ratelimited by\n\t *\tsetting\tit's bit position.\n\t *\n\t *\tdefault:\n\t *\tdest unreachable (3), source quench (4),\n\t *\ttime exceeded (11), parameter problem (12)\n\t */\n\n\tnet->ipv4.sysctl_icmp_ratelimit = 1 * HZ;\n\tnet->ipv4.sysctl_icmp_ratemask = 0x1818;\n\tnet->ipv4.sysctl_icmp_errors_use_inbound_ifaddr = 0;\n\n\treturn 0;\n\nfail:\n\tfor_each_possible_cpu(i)\n\t\tinet_ctl_sock_destroy(net->ipv4.icmp_sk[i]);\n\tkfree(net->ipv4.icmp_sk);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 470
    },
    {
        "index": 158099,
        "code": "WebLocalFrameImpl* LocalFrameClientImpl::GetWebFrame() const {\n  return web_frame_.Get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-20067",
        "length": 25
    },
    {
        "index": 28737,
        "code": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tif ((kvm_apic_get_reg(apic, APIC_SPIV) ^ val) & APIC_SPIV_APIC_ENABLED) {\n\t\tif (val & APIC_SPIV_APIC_ENABLED)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n\tapic_set_reg(apic, APIC_SPIV, val);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6376",
        "length": 111
    },
    {
        "index": 107268,
        "code": "void AutomationProvider::SaveAsAsync(int tab_handle) {\n  NavigationController* tab = NULL;\n  TabContents* tab_contents = GetTabContentsForHandle(tab_handle, &tab);\n  if (tab_contents)\n    tab_contents->OnSavePage();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1296",
        "length": 54
    },
    {
        "index": 155941,
        "code": "void PeopleHandler::MarkFirstSetupComplete() {\n  signin::SetUserSkippedPromo(profile_);\n\n  ProfileSyncService* service = GetSyncService();\n  if (!service || service->IsFirstSetupComplete())\n    return;\n\n  base::FilePath profile_file_path = profile_->GetPath();\n  ProfileMetrics::LogProfileSyncSignIn(profile_file_path);\n\n  sync_blocker_.reset();\n  service->SetFirstSetupComplete();\n  FireWebUIListener(\"sync-settings-saved\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1665",
        "length": 100
    },
    {
        "index": 1969,
        "code": "SPICE_GNUC_VISIBLE int spice_server_migrate_switch(SpiceServer *s)\n{\n    spice_assert(reds == s);\n    spice_info(NULL);\n    if (!reds->num_clients) {\n       return 0;\n    }\n    reds->expect_migrate = FALSE;\n    reds_mig_switch();\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4282",
        "length": 73
    },
    {
        "index": 94090,
        "code": "static int iwl_send_remove_station(struct iwl_priv *priv,\n\t\t\t\t   const u8 *addr, int sta_id,\n\t\t\t\t   bool temporary)\n{\n\tstruct iwl_rx_packet *pkt;\n\tint ret;\n\n\tunsigned long flags_spin;\n\tstruct iwl_rem_sta_cmd rm_sta_cmd;\n\n\tstruct iwl_host_cmd cmd = {\n\t\t.id = REPLY_REMOVE_STA,\n\t\t.len = { sizeof(struct iwl_rem_sta_cmd), },\n\t\t.flags = CMD_SYNC,\n\t\t.data = { &rm_sta_cmd, },\n\t};\n\n\tmemset(&rm_sta_cmd, 0, sizeof(rm_sta_cmd));\n\trm_sta_cmd.num_sta = 1;\n\tmemcpy(&rm_sta_cmd.addr, addr, ETH_ALEN);\n\n\tcmd.flags |= CMD_WANT_SKB;\n\n\tret = iwl_trans_send_cmd(trans(priv), &cmd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpkt = (struct iwl_rx_packet *)cmd.reply_page;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_REMOVE_STA (0x%08X)\\n\",\n\t\t\t  pkt->hdr.flags);\n\t\tret = -EIO;\n\t}\n\n\tif (!ret) {\n\t\tswitch (pkt->u.rem_sta.status) {\n\t\tcase REM_STA_SUCCESS_MSK:\n\t\t\tif (!temporary) {\n\t\t\t\tspin_lock_irqsave(&priv->shrd->sta_lock,\n\t\t\t\t\tflags_spin);\n\t\t\t\tiwl_sta_ucode_deactivate(priv, sta_id);\n\t\t\t\tspin_unlock_irqrestore(&priv->shrd->sta_lock,\n\t\t\t\t\tflags_spin);\n\t\t\t}\n\t\t\tIWL_DEBUG_ASSOC(priv, \"REPLY_REMOVE_STA PASSED\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t\tIWL_ERR(priv, \"REPLY_REMOVE_STA failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tiwl_free_pages(priv->shrd, cmd.reply_page);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-6712",
        "length": 390
    },
    {
        "index": 17807,
        "code": "int nbd_client(int fd)\n{\n    return -ENOTSUP;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-7539",
        "length": 17
    },
    {
        "index": 38797,
        "code": "box_below_eq(PG_FUNCTION_ARGS)\n{\n\tBOX\t\t   *box1 = PG_GETARG_BOX_P(0);\n\tBOX\t\t   *box2 = PG_GETARG_BOX_P(1);\n\n\tPG_RETURN_BOOL(FPle(box1->high.y, box2->low.y));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 60
    },
    {
        "index": 120186,
        "code": "void Layer::SetScrollOffsetFromImplSide(const gfx::Vector2d& scroll_offset) {\n  DCHECK(IsPropertyChangeAllowed());\n  DCHECK(layer_tree_host_ && layer_tree_host_->CommitRequested());\n  if (scroll_offset_ == scroll_offset)\n    return;\n  scroll_offset_ = scroll_offset;\n  SetNeedsPushProperties();\n  if (!did_scroll_callback_.is_null())\n    did_scroll_callback_.Run();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2902",
        "length": 87
    },
    {
        "index": 59525,
        "code": "xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {\n    xmlChar *version = NULL;\n\n    if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {\n\tSKIP(7);\n\tSKIP_BLANKS;\n\tif (RAW != '=') {\n\t    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n\t    return(NULL);\n        }\n\tNEXT;\n\tSKIP_BLANKS;\n\tif (RAW == '\"') {\n\t    NEXT;\n\t    version = xmlParseVersionNum(ctxt);\n\t    if (RAW != '\"') {\n\t\txmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n\t    } else\n\t        NEXT;\n\t} else if (RAW == '\\''){\n\t    NEXT;\n\t    version = xmlParseVersionNum(ctxt);\n\t    if (RAW != '\\'') {\n\t\txmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n\t    } else\n\t        NEXT;\n\t} else {\n\t    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n\t}\n    }\n    return(version);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-16932",
        "length": 232
    },
    {
        "index": 139638,
        "code": "MediaElementAudioSourceNode* AudioContext::createMediaElementSource(HTMLMediaElement* mediaElement, ExceptionState& exceptionState)\n{\n    ASSERT(isMainThread());\n    if (!mediaElement) {\n        exceptionState.throwDOMException(\n            InvalidStateError,\n            \"invalid HTMLMedialElement.\");\n        return 0;\n    }\n\n    if (mediaElement->audioSourceNode()) {\n        exceptionState.throwDOMException(\n            InvalidStateError,\n            \"HTMLMediaElement already connected previously to a different MediaElementSourceNode.\");\n        return 0;\n    }\n\n    MediaElementAudioSourceNode* node = MediaElementAudioSourceNode::create(this, mediaElement);\n\n    mediaElement->setAudioSourceNode(node);\n\n    refNode(node); // context keeps reference until node is disconnected\n    return node;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 164
    },
    {
        "index": 113384,
        "code": "void WebProcessProxy::didNavigateWithNavigationData(uint64_t pageID, const WebNavigationDataStore& store, uint64_t frameID) \n{\n    WebPageProxy* page = webPage(pageID);\n    if (!page)\n        return;\n    \n    WebFrameProxy* frame = webFrame(frameID);\n    MESSAGE_CHECK(frame);\n    MESSAGE_CHECK(frame->page() == page);\n    \n    m_context->historyClient().didNavigateWithNavigationData(m_context.get(), page, store, frame);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 105
    },
    {
        "index": 159957,
        "code": "void DiskCacheBackendTest::BackendDisable2() {\n  EXPECT_EQ(8, cache_->GetEntryCount());\n\n  disk_cache::Entry* entry;\n  std::unique_ptr<TestIterator> iter = CreateIterator();\n  int count = 0;\n  while (iter->OpenNextEntry(&entry) == net::OK) {\n    ASSERT_TRUE(NULL != entry);\n    entry->Close();\n    count++;\n    ASSERT_LT(count, 9);\n  };\n\n  FlushQueueForTest();\n  EXPECT_EQ(0, cache_->GetEntryCount());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6085",
        "length": 113
    },
    {
        "index": 183608,
        "code": "void BrowserActionsContainer::BrowserActionAdded(Extension* extension,\n                                                 int index) {\n#if defined(DEBUG)\n  for (size_t i = 0; i < browser_action_views_.size(); ++i) {\n    DCHECK(browser_action_views_[i]->button()->extension() != extension) <<\n           \"Asked to add a browser action view for an extension that already \"\n           \"exists.\";\n  }\n#endif\n  size_t visible_actions = 0;\n  for (size_t i = 0; i < browser_action_views_.size(); ++i) {\n    if (browser_action_views_[i]->IsVisible())\n      ++visible_actions;\n  }\n  BrowserActionView* view = new BrowserActionView(extension, this);\n  browser_action_views_.push_back(view);\n  AddChildView(index, view);\n  if (visible_actions < browser_action_views_.size() - 1) {\n    OnBrowserActionVisibilityChanged();\n  } else {\n    animation_target_size_ = IconCountToWidth(visible_actions + 1);\n    suppress_chevron_ = !chevron_->IsVisible();\n    resize_animation_->Reset();\n    resize_animation_->SetTweenType(SlideAnimation::NONE);\n    resize_animation_->Show();\n  }\n}\n",
        "line": "                                                 int index) {\n#if defined(DEBUG)\n  for (size_t i = 0; i < browser_action_views_.size(); ++i) {\n    DCHECK(browser_action_views_[i]->button()->extension() != extension) <<\n           \"Asked to add a browser action view for an extension that already \"\n           \"exists.\";\n  }\n#endif\n  size_t visible_actions = 0;\n  for (size_t i = 0; i < browser_action_views_.size(); ++i) {\n    if (browser_action_views_[i]->IsVisible())\n      ++visible_actions;\n  }\n  BrowserActionView* view = new BrowserActionView(extension, this);\n  browser_action_views_.push_back(view);\n  AddChildView(index, view);\n  if (visible_actions < browser_action_views_.size() - 1) {\n    OnBrowserActionVisibilityChanged();\n  } else {\n    animation_target_size_ = IconCountToWidth(visible_actions + 1);\n    suppress_chevron_ = !chevron_->IsVisible();\n    resize_animation_->Reset();\n    resize_animation_->SetTweenType(SlideAnimation::NONE);\n    resize_animation_->Show();\n  }\n}\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 251
    },
    {
        "index": 84334,
        "code": "UNCURL_EXPORT int32_t uncurl_new_tls_ctx(struct uncurl_tls_ctx **uc_tls_in)\n{\n\tint32_t e;\n\n\tstruct uncurl_tls_ctx *uc_tls = *uc_tls_in = calloc(1, sizeof(struct uncurl_tls_ctx));\n\n\te = tlss_alloc(&uc_tls->tlss);\n\tif (e == UNCURL_OK) return e;\n\n\tuncurl_free_tls_ctx(uc_tls);\n\t*uc_tls_in = NULL;\n\n\treturn e;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-352",
        "cve": "CVE-2018-6651",
        "length": 98
    },
    {
        "index": 1730,
        "code": "IRCView::IRCView(QWidget* parent) : KTextBrowser(parent), m_rememberLine(0), m_lastMarkerLine(0), m_rememberLineDirtyBit(false), markerFormatObject(this)\n{\n    m_mousePressedOnUrl = false;\n    m_isOnNick = false;\n    m_isOnChannel = false;\n    m_chatWin = 0;\n    m_server = 0;\n\n    setAcceptDrops(false);\n\n    connect(document(), SIGNAL(contentsChange(int,int,int)), SLOT(cullMarkedLine(int,int,int)));\n\n    QTextObjectInterface *iface = qobject_cast<QTextObjectInterface *>(&markerFormatObject);\n    if (!iface)\n    {\n        Q_ASSERT(iface);\n    }\n\n    document()->documentLayout()->registerHandler(IRCView::MarkerLine, &markerFormatObject);\n    document()->documentLayout()->registerHandler(IRCView::RememberLine, &markerFormatObject);\n\n\n    connect(this, SIGNAL(anchorClicked(QUrl)), this, SLOT(anchorClicked(QUrl)));\n    connect( this, SIGNAL(highlighted(QString)), this, SLOT(highlightedSlot(QString)) );\n    setOpenLinks(false);\n    setUndoRedoEnabled(0);\n    document()->setDefaultStyleSheet(\"a.nick:link {text-decoration: none}\");\n    setWordWrapMode(QTextOption::WrapAtWordBoundaryOrAnywhere);\n    setFocusPolicy(Qt::ClickFocus);\n    setReadOnly(true);\n    viewport()->setCursor(Qt::ArrowCursor);\n    setTextInteractionFlags(Qt::TextBrowserInteraction);\n    viewport()->setMouseTracking(true);\n\n    if (Preferences::self()->useParagraphSpacing()) enableParagraphSpacing();\n\n    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n\n    setContextMenuOptions(IrcContextMenus::ShowTitle | IrcContextMenus::ShowFindAction, true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-15923",
        "length": 364
    },
    {
        "index": 168398,
        "code": "LocationBar* TestBrowserWindow::GetLocationBar() const {\n  return const_cast<TestLocationBar*>(&location_bar_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-16080",
        "length": 26
    },
    {
        "index": 122233,
        "code": "RenderLayerCompositor::~RenderLayerCompositor()\n{\n    ASSERT(m_rootLayerAttachment == RootLayerUnattached);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-0881",
        "length": 25
    },
    {
        "index": 88742,
        "code": "int modbus_receive(modbus_t *ctx, uint8_t *req)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->receive(ctx, req);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2019-14463",
        "length": 50
    },
    {
        "index": 95048,
        "code": "void exit_aio(struct mm_struct *mm)\n{\n\tstruct kioctx_table *table = rcu_dereference_raw(mm->ioctx_table);\n\tint i;\n\n\tif (!table)\n\t\treturn;\n\n\tfor (i = 0; i < table->nr; ++i) {\n\t\tstruct kioctx *ctx = table->table[i];\n\t\tstruct completion requests_done =\n\t\t\tCOMPLETION_INITIALIZER_ONSTACK(requests_done);\n\n\t\tif (!ctx)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't need to bother with munmap() here - exit_mmap(mm)\n\t\t * is coming and it'll unmap everything. And we simply can't,\n\t\t * this is not necessarily our ->mm.\n\t\t * Since kill_ioctx() uses non-zero ->mmap_size as indicator\n\t\t * that it needs to unmap the area, just set it to 0.\n\t\t */\n\t\tctx->mmap_size = 0;\n\t\tkill_ioctx(mm, ctx, &requests_done);\n\n\t\t/* Wait until all IO for the context are done. */\n\t\twait_for_completion(&requests_done);\n\t}\n\n\tRCU_INIT_POINTER(mm->ioctx_table, NULL);\n\tkfree(table);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8830",
        "length": 248
    },
    {
        "index": 51784,
        "code": "dissect_u3v_event_cmd(proto_tree *u3v_telegram_tree, tvbuff_t *tvb, packet_info *pinfo, gint startoffset, gint length)\n{\n    gint32 eventid;\n    gint offset = startoffset;\n    proto_item *item = NULL;\n\n    /* Get event ID */\n    eventid = tvb_get_letohs(tvb, offset + 2);\n\n    /* fill in Info column in Wireshark GUI */\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"[ID: 0x%04X]\", eventid);\n\n\n    item = proto_tree_add_item(u3v_telegram_tree, hf_u3v_scd_event_cmd, tvb, offset, length, ENC_NA);\n    u3v_telegram_tree = proto_item_add_subtree(item, ett_u3v_payload_cmd);\n\n    offset += 2;\n\n    /* Use range to determine type of event */\n    if ((eventid >= 0x0000) && (eventid <= 0x8000)) {\n        /* Standard ID */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    } else if ((eventid >= 0x8001) && (eventid <= 0x8FFF)) {\n        /* Error */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_error_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    } else if ((eventid >= 0x9000) && (eventid <= 0xFFFF)) {\n        /* Device specific */\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_device_specific_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    }\n    offset += 2;\n\n    /* Timestamp (64 bit) associated with event */\n    proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n    offset += 8;\n\n    /* Data */\n    if (length > offset ) {\n        proto_tree_add_item(u3v_telegram_tree, hf_u3v_eventcmd_data, tvb, offset, length - 12, ENC_NA);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-5354",
        "length": 485
    },
    {
        "index": 115035,
        "code": "void TestingAutomationProvider::SetOmniboxText(Browser* browser,\n                                               DictionaryValue* args,\n                                               IPC::Message* reply_message) {\n  string16 text;\n  AutomationJSONReply reply(this, reply_message);\n  if (!args->GetString(\"text\", &text)) {\n    reply.SendError(\"text missing\");\n    return;\n  }\n  browser->FocusLocationBar();\n  LocationBar* loc_bar = browser->window()->GetLocationBar();\n  OmniboxView* omnibox_view = loc_bar->location_entry();\n  omnibox_view->model()->OnSetFocus(false);\n  omnibox_view->SetUserText(text);\n  reply.SendSuccess(NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 138
    },
    {
        "index": 3410,
        "code": "hook_fd (struct t_weechat_plugin *plugin, int fd, int flag_read,\n         int flag_write, int flag_exception,\n         t_hook_callback_fd *callback, void *callback_data)\n{\n    struct t_hook *new_hook;\n    struct t_hook_fd *new_hook_fd;\n    \n    if ((fd < 0) || hook_search_fd (fd) || !callback)\n        return NULL;\n    \n    new_hook = malloc (sizeof (*new_hook));\n    if (!new_hook)\n        return NULL;\n    new_hook_fd = malloc (sizeof (*new_hook_fd));\n    if (!new_hook_fd)\n    {\n        free (new_hook);\n        return NULL;\n    }\n    \n    hook_init_data (new_hook, plugin, HOOK_TYPE_FD, HOOK_PRIORITY_DEFAULT,\n                    callback_data);\n    \n    new_hook->hook_data = new_hook_fd;\n    new_hook_fd->callback = callback;\n    new_hook_fd->fd = fd;\n    new_hook_fd->flags = 0;\n    if (flag_read)\n        new_hook_fd->flags |= HOOK_FD_FLAG_READ;\n    if (flag_write)\n        new_hook_fd->flags |= HOOK_FD_FLAG_WRITE;\n    if (flag_exception)\n        new_hook_fd->flags |= HOOK_FD_FLAG_EXCEPTION;\n    \n    hook_add_to_list (new_hook);\n    \n    return new_hook;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1428",
        "length": 280
    },
    {
        "index": 119157,
        "code": " bool XMLHttpRequest::canSuspend() const\n{\n    return !m_loader;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2925",
        "length": 18
    },
    {
        "index": 9613,
        "code": "PHPAPI ps_module *_php_find_ps_module(char *name TSRMLS_DC) /* {{{ */\n{\n\tps_module *ret = NULL;\n\tps_module **mod;\n\tint i;\n\n\tfor (i = 0, mod = ps_modules; i < MAX_MODULES; i++, mod++) {\n\t\tif (*mod && !strcasecmp(name, (*mod)->s_name)) {\n\t\t\tret = *mod;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-6290",
        "length": 94
    },
    {
        "index": 94308,
        "code": "cdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4x: \", abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-1571",
        "length": 161
    },
    {
        "index": 5647,
        "code": "file_id_hasher (void const *entry, size_t table_size)\n{\n  file_id const *e = entry;\n  size_t i = e->ino + e->dev;\n  return i % table_size;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2010-4651",
        "length": 47
    },
    {
        "index": 115002,
        "code": "void TestingAutomationProvider::PerformActionOnSearchEngine(\n    Browser* browser,\n    DictionaryValue* args,\n    IPC::Message* reply_message) {\n  TemplateURLService* url_model =\n      TemplateURLServiceFactory::GetForProfile(browser->profile());\n  std::string keyword;\n  std::string action;\n  if (!args->GetString(\"keyword\", &keyword) ||\n      !args->GetString(\"action\", &action)) {\n    AutomationJSONReply(this, reply_message).SendError(\n        \"One or more inputs invalid\");\n    return;\n  }\n  const TemplateURL* template_url(\n      url_model->GetTemplateURLForKeyword(UTF8ToUTF16(keyword)));\n  if (template_url == NULL) {\n    AutomationJSONReply(this, reply_message)\n        .SendError(StringPrintf(\"No match for keyword: %s\", keyword.c_str()));\n    return;\n  }\n  if (action == \"delete\") {\n    url_model->AddObserver(new AutomationProviderSearchEngineObserver(\n      this, reply_message));\n    url_model->Remove(template_url);\n  } else if (action == \"default\") {\n    url_model->AddObserver(new AutomationProviderSearchEngineObserver(\n      this, reply_message));\n    url_model->SetDefaultSearchProvider(template_url);\n  } else {\n    AutomationJSONReply(this, reply_message)\n        .SendError(StringPrintf(\"Invalid action: %s\", action.c_str()));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 292
    },
    {
        "index": 96581,
        "code": "int mbedtls_ecp_point_cmp( const mbedtls_ecp_point *P,\n                           const mbedtls_ecp_point *Q )\n{\n    if( mbedtls_mpi_cmp_mpi( &P->X, &Q->X ) == 0 &&\n        mbedtls_mpi_cmp_mpi( &P->Y, &Q->Y ) == 0 &&\n        mbedtls_mpi_cmp_mpi( &P->Z, &Q->Z ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-16910",
        "length": 112
    },
    {
        "index": 156187,
        "code": "void RendererSchedulerImpl::DidHandleInputEventOnCompositorThread(\n    const blink::WebInputEvent& web_input_event,\n    InputEventState event_state) {\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"renderer.scheduler\"),\n               \"RendererSchedulerImpl::DidHandleInputEventOnCompositorThread\");\n  if (!ShouldPrioritizeInputEvent(web_input_event))\n    return;\n\n  UpdateForInputEventOnCompositorThread(web_input_event.GetType(), event_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-18339",
        "length": 96
    },
    {
        "index": 82822,
        "code": "static char *swiftField(const char *dn, const char *cn) {\n\tchar *p = strstr (dn, \".getter_\");\n\tif (!p) {\n\t\tp = strstr (dn, \".setter_\");\n\t\tif (!p) {\n\t\t\tp = strstr (dn, \".method_\");\n\t\t}\n\t}\n\tif (p) {\n\t\tchar *q = strstr (dn, cn);\n\t\tif (q && q[strlen (cn)] == '.') {\n\t\t\tq = strdup (q + strlen (cn) + 1);\n\t\t\tchar *r = strchr (q, '.');\n\t\t\tif (r) {\n\t\t\t\t*r = 0;\n\t\t\t}\n\t\t\treturn q;\n\t\t}\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-11381",
        "length": 151
    },
    {
        "index": 351,
        "code": "int fz_colorspace_n(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs ? cs->n : 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-1000040",
        "length": 31
    },
    {
        "index": 154498,
        "code": "void RequestExtensions(gl::GLApi* api,\n                       const gfx::ExtensionSet& requestable_extensions,\n                       const char* const* extensions_to_request,\n                       size_t count) {\n  for (size_t i = 0; i < count; i++) {\n    if (gfx::HasExtension(requestable_extensions, extensions_to_request[i])) {\n      api->glRequestExtensionANGLEFn(extensions_to_request[i]);\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 91
    },
    {
        "index": 169444,
        "code": "int FileStream::Open(const base::FilePath& path, int open_flags,\n                     const CompletionCallback& callback) {\n  if (IsOpen()) {\n    DLOG(FATAL) << \"File is already open!\";\n    return ERR_UNEXPECTED;\n  }\n\n  DCHECK(open_flags & base::File::FLAG_ASYNC);\n  context_->Open(path, open_flags, callback);\n  return ERR_IO_PENDING;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-311",
        "cve": "CVE-2017-15397",
        "length": 82
    },
    {
        "index": 142149,
        "code": "  virtual void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) {\n    CreateEntryImpl(entry, root_path().AppendASCII(entry.target_path));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-5194",
        "length": 35
    },
    {
        "index": 732,
        "code": "struct dns_srvrq *new_dns_srvrq(struct server *srv, char *fqdn)\n{\n\tstruct proxy     *px    = srv->proxy;\n\tstruct dns_srvrq *srvrq = NULL;\n\tint fqdn_len, hostname_dn_len;\n\n\tfqdn_len = strlen(fqdn);\n\thostname_dn_len = dns_str_to_dn_label(fqdn, fqdn_len + 1, trash.area,\n\t\t\t\t\t      trash.size);\n\tif (hostname_dn_len == -1) {\n\t\tha_alert(\"config : %s '%s', server '%s': failed to parse FQDN '%s'\\n\",\n\t\t\t proxy_type_str(px), px->id, srv->id, fqdn);\n\t\tgoto err;\n\t}\n\n\tif ((srvrq = calloc(1, sizeof(*srvrq))) == NULL) {\n\t\tha_alert(\"config : %s '%s', server '%s': out of memory\\n\",\n\t\t\t proxy_type_str(px), px->id, srv->id);\n\t\tgoto err;\n\t}\n\tsrvrq->obj_type        = OBJ_TYPE_SRVRQ;\n\tsrvrq->proxy           = px;\n\tsrvrq->name            = strdup(fqdn);\n\tsrvrq->hostname_dn     = strdup(trash.area);\n\tsrvrq->hostname_dn_len = hostname_dn_len;\n\tif (!srvrq->name || !srvrq->hostname_dn) {\n\t\tha_alert(\"config : %s '%s', server '%s': out of memory\\n\",\n\t\t\t proxy_type_str(px), px->id, srv->id);\n\t\tgoto err;\n\t}\n\tLIST_ADDQ(&dns_srvrq_list, &srvrq->list);\n\treturn srvrq;\n\n  err:\n\tif (srvrq) {\n\t\tfree(srvrq->name);\n\t\tfree(srvrq->hostname_dn);\n\t\tfree(srvrq);\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-20102",
        "length": 382
    },
    {
        "index": 9226,
        "code": "static void virtio_queue_host_notifier_aio_read(EventNotifier *n)\n{\n    VirtQueue *vq = container_of(n, VirtQueue, host_notifier);\n    if (event_notifier_test_and_clear(n)) {\n        virtio_queue_notify_aio_vq(vq);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-6490",
        "length": 60
    },
    {
        "index": 48458,
        "code": "static struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-9191",
        "length": 72
    },
    {
        "index": 85975,
        "code": "static void dump_header(struct oom_control *oc, struct task_struct *p)\n{\n\tpr_warn(\"%s invoked oom-killer: gfp_mask=%#x(%pGg), nodemask=%*pbl, order=%d, oom_score_adj=%hd\\n\",\n\t\tcurrent->comm, oc->gfp_mask, &oc->gfp_mask,\n\t\tnodemask_pr_args(oc->nodemask), oc->order,\n\t\t\tcurrent->signal->oom_score_adj);\n\tif (!IS_ENABLED(CONFIG_COMPACTION) && oc->order)\n\t\tpr_warn(\"COMPACTION is disabled!!!\\n\");\n\n\tcpuset_print_current_mems_allowed();\n\tdump_stack();\n\tif (is_memcg_oom(oc))\n\t\tmem_cgroup_print_oom_info(oc->memcg, p);\n\telse {\n\t\tshow_mem(SHOW_MEM_FILTER_NODES, oc->nodemask);\n\t\tif (is_dump_unreclaim_slabs())\n\t\t\tdump_unreclaimable_slab();\n\t}\n\tif (sysctl_oom_dump_tasks)\n\t\tdump_tasks(oc->memcg, oc->nodemask);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18202",
        "length": 236
    },
    {
        "index": 78435,
        "code": "gpk_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tswitch (cmd) {\n\tcase SC_CARDCTL_ERASE_CARD:\n\t\treturn gpk_erase_card(card);\n\tcase SC_CARDCTL_GET_DEFAULT_KEY:\n\t\treturn gpk_get_default_key(card,\n\t\t\t\t(struct sc_cardctl_default_key *) ptr);\n\tcase SC_CARDCTL_GPK_VARIANT:\n\t\t*(int *) ptr = card->type;\n\t\treturn 0;\n\tcase SC_CARDCTL_GPK_LOCK:\n\t\treturn gpk_lock(card, (struct sc_cardctl_gpk_lock *) ptr);\n\tcase SC_CARDCTL_GPK_PKINIT:\n\t\treturn gpk_pkfile_init(card,\n\t\t\t       (struct sc_cardctl_gpk_pkinit *) ptr);\n\tcase SC_CARDCTL_GPK_PKLOAD:\n\t\treturn gpk_pkfile_load(card,\n\t\t\t       (struct sc_cardctl_gpk_pkload *) ptr);\n\tcase SC_CARDCTL_GPK_IS_LOCKED:\n\t\t*(int *) ptr = DRVDATA(card)->locked;\n\t\treturn 0;\n\tcase SC_CARDCTL_GPK_GENERATE_KEY:\n\t\treturn gpk_generate_key(card,\n\t\t\t\t(struct sc_cardctl_gpk_genkey *) ptr);\n\tcase SC_CARDCTL_GET_SERIALNR:\n\t\treturn gpk_get_serialnr(card, (sc_serial_number_t *) ptr);\n\t}\n\n\n\treturn SC_ERROR_NOT_SUPPORTED;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 276
    },
    {
        "index": 175757,
        "code": "IV_API_CALL_STATUS_T impeg2d_api_function (iv_obj_t *ps_dechdl, void *pv_api_ip,void *pv_api_op)\n{\n    WORD32 i4_cmd;\n    IV_API_CALL_STATUS_T u4_error_code;\n    UWORD32 *pu4_api_ip;\n\n    u4_error_code = impeg2d_api_check_struct_sanity(ps_dechdl,pv_api_ip,pv_api_op);\n if(IV_SUCCESS != u4_error_code)\n {\n return u4_error_code;\n }\n\n\n    pu4_api_ip  = (UWORD32 *)pv_api_ip;\n    i4_cmd = *(pu4_api_ip + 1);\n\n switch(i4_cmd)\n {\n\n case IV_CMD_GET_NUM_MEM_REC:\n        u4_error_code = impeg2d_api_num_mem_rec((void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IV_CMD_FILL_NUM_MEM_REC:\n        u4_error_code = impeg2d_api_fill_mem_rec((void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IV_CMD_INIT:\n        u4_error_code = impeg2d_api_init(ps_dechdl,(void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IVD_CMD_SET_DISPLAY_FRAME:\n        u4_error_code = impeg2d_api_set_display_frame(ps_dechdl,(void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IVD_CMD_REL_DISPLAY_FRAME:\n        u4_error_code = impeg2d_api_rel_display_frame(ps_dechdl,(void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IVD_CMD_VIDEO_DECODE:\n        u4_error_code = impeg2d_api_entity(ps_dechdl, (void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IV_CMD_RETRIEVE_MEMREC:\n        u4_error_code = impeg2d_api_retrieve_mem_rec(ps_dechdl,(void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n case IVD_CMD_VIDEO_CTL:\n        u4_error_code = impeg2d_api_ctl(ps_dechdl,(void *)pv_api_ip,(void *)pv_api_op);\n break;\n\n default:\n break;\n }\n\n return(u4_error_code);\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-0587",
        "length": 470
    },
    {
        "index": 163922,
        "code": "InlineBoxPosition AdjustInlineBoxPositionForPrimaryDirection(\n    InlineBox* inline_box,\n    int caret_offset) {\n  if (caret_offset == inline_box->CaretRightmostOffset()) {\n    InlineBox* const next_box = inline_box->NextLeafChild();\n    if (!next_box || next_box->BidiLevel() >= inline_box->BidiLevel())\n      return InlineBoxPosition(inline_box, caret_offset);\n\n    const unsigned level = next_box->BidiLevel();\n    InlineBox* const prev_box =\n        InlineBoxTraversal::FindLeftBidiRun(*inline_box, level);\n\n    if (prev_box && prev_box->BidiLevel() == level)\n      return InlineBoxPosition(inline_box, caret_offset);\n\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindRightBoundaryOfEntireBidiRun(*inline_box,\n                                                             level);\n    return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n  }\n\n  if (IsStartOfDifferentDirection(inline_box))\n    return InlineBoxPosition(inline_box, caret_offset);\n\n  const unsigned level = inline_box->PrevLeafChild()->BidiLevel();\n  InlineBox* const next_box =\n      InlineBoxTraversal::FindRightBidiRun(*inline_box, level);\n\n  if (next_box && next_box->BidiLevel() == level)\n    return InlineBoxPosition(inline_box, caret_offset);\n\n  InlineBox* const result_box =\n      InlineBoxTraversal::FindLeftBoundaryOfEntireBidiRun(*inline_box, level);\n  return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 339
    },
    {
        "index": 120021,
        "code": "void FileBrowserPrivateRequestAccessTokenFunction::OnAccessTokenFetched(\n    google_apis::GDataErrorCode code,\n    const std::string& access_token) {\n  SetResult(new base::StringValue(access_token));\n  SendResponse(true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2922",
        "length": 50
    },
    {
        "index": 161711,
        "code": "VaapiVideoDecodeAccelerator::VaapiDecodeSurface::~VaapiDecodeSurface() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-6061",
        "length": 19
    },
    {
        "index": 88346,
        "code": "xfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2019-15538",
        "length": 54
    },
    {
        "index": 20503,
        "code": "static int ext4_mark_dquot_dirty(struct dquot *dquot)\n{\n\t/* Are we journaling quotas? */\n\tif (EXT4_SB(dquot->dq_sb)->s_qf_names[USRQUOTA] ||\n\t    EXT4_SB(dquot->dq_sb)->s_qf_names[GRPQUOTA]) {\n\t\tdquot_mark_dquot_dirty(dquot);\n\t\treturn ext4_write_dquot(dquot);\n\t} else {\n\t\treturn dquot_mark_dquot_dirty(dquot);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2100",
        "length": 105
    },
    {
        "index": 27388,
        "code": "static struct ip_tunnel * ipip_tunnel_lookup(struct net *net,\n\t\t__be32 remote, __be32 local)\n{\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct ipip_net *ipn = net_generic(net, ipip_net_id);\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_r_l[h0 ^ h1])\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_r[h0])\n\t\tif (remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tfor_each_ip_tunnel_rcu(ipn->tunnels_l[h1])\n\t\tif (local == t->parms.iph.saddr && (t->dev->flags&IFF_UP))\n\t\t\treturn t;\n\n\tt = rcu_dereference(ipn->tunnels_wc[0]);\n\tif (t && (t->dev->flags&IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2011-1768",
        "length": 248
    },
    {
        "index": 146438,
        "code": "PassRefPtr<Image> WebGLRenderingContextBase::VideoFrameToImage(\n    HTMLVideoElement* video) {\n  IntSize size(video->videoWidth(), video->videoHeight());\n  ImageBuffer* buf = generated_image_cache_.GetImageBuffer(size);\n  if (!buf) {\n    SynthesizeGLError(GL_OUT_OF_MEMORY, \"texImage2D\", \"out of memory\");\n    return nullptr;\n  }\n  IntRect dest_rect(0, 0, size.Width(), size.Height());\n  video->PaintCurrentFrame(buf->Canvas(), dest_rect, nullptr);\n  return buf->NewImageSnapshot();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 125
    },
    {
        "index": 148638,
        "code": "void SkiaOutputSurfaceImpl::EnsureBackbuffer() {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  auto callback = base::BindOnce(&SkiaOutputSurfaceImplOnGpu::EnsureBackbuffer,\n                                 base::Unretained(impl_on_gpu_.get()));\n  task_sequence_->ScheduleOrRetainTask(std::move(callback),\n                                       std::vector<gpu::SyncToken>());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2017-5094",
        "length": 83
    },
    {
        "index": 33829,
        "code": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options_rcu *opt;\n\tstruct inet_sock *sk_inet;\n\n\tsk_inet = inet_sk(sk);\n\topt = rcu_dereference_protected(sk_inet->inet_opt, 1);\n\tif (opt == NULL || opt->opt.cipso == 0)\n\t\treturn;\n\n\thdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0310",
        "length": 173
    },
    {
        "index": 135747,
        "code": "WebTextInputMode InputMethodController::InputModeOfFocusedElement() const {\n  if (!RuntimeEnabledFeatures::InputModeAttributeEnabled())\n    return kWebTextInputModeDefault;\n\n  AtomicString mode = GetInputModeAttribute(GetDocument().FocusedElement());\n\n  if (mode.IsEmpty())\n    return kWebTextInputModeDefault;\n  if (mode == InputModeNames::verbatim)\n    return kWebTextInputModeVerbatim;\n  if (mode == InputModeNames::latin)\n    return kWebTextInputModeLatin;\n  if (mode == InputModeNames::latin_name)\n    return kWebTextInputModeLatinName;\n  if (mode == InputModeNames::latin_prose)\n    return kWebTextInputModeLatinProse;\n  if (mode == InputModeNames::full_width_latin)\n    return kWebTextInputModeFullWidthLatin;\n  if (mode == InputModeNames::kana)\n    return kWebTextInputModeKana;\n  if (mode == InputModeNames::kana_name)\n    return kWebTextInputModeKanaName;\n  if (mode == InputModeNames::katakana)\n    return kWebTextInputModeKataKana;\n  if (mode == InputModeNames::numeric)\n    return kWebTextInputModeNumeric;\n  if (mode == InputModeNames::tel)\n    return kWebTextInputModeTel;\n  if (mode == InputModeNames::email)\n    return kWebTextInputModeEmail;\n  if (mode == InputModeNames::url)\n    return kWebTextInputModeUrl;\n  return kWebTextInputModeDefault;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-6773",
        "length": 325
    },
    {
        "index": 12103,
        "code": "calc_enc_length (gnutls_session_t session, int data_size,\n\t\t int hash_size, uint8_t * pad, int random_pad,\n\t\t cipher_type_t block_algo, uint16_t blocksize)\n{\n  uint8_t rnd;\n  int length, ret;\n\n  *pad = 0;\n\n  switch (block_algo)\n    {\n    case CIPHER_STREAM:\n      length = data_size + hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      ret =_gnutls_rnd (RND_NONCE, &rnd, 1);\n      if ( ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* make rnd a multiple of blocksize */\n      if (session->security_parameters.version == GNUTLS_SSL3 ||\n\t  random_pad == 0)\n\t{\n\t  rnd = 0;\n\t}\n      else\n\t{\n\t  rnd = (rnd / blocksize) * blocksize;\n\t  /* added to avoid the case of pad calculated 0\n\t   * seen below for pad calculation.\n\t   */\n\t  if (rnd > blocksize)\n\t    rnd -= blocksize;\n\t}\n\n      length = data_size + hash_size;\n\n      *pad = (uint8_t) (blocksize - (length % blocksize)) + rnd;\n\n      length += *pad;\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\tlength += blocksize;\t/* for the IV */\n\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  return length;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2008-1950",
        "length": 331
    },
    {
        "index": 56669,
        "code": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(sb, block_group, gdp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "length": 67
    },
    {
        "index": 133789,
        "code": "X509Certificate* SSLClientSocketOpenSSL::UpdateServerCert() {\n  if (server_cert_.get())\n    return server_cert_.get();\n\n  crypto::ScopedOpenSSL<X509, X509_free> cert(SSL_get_peer_certificate(ssl_));\n  if (!cert.get()) {\n    LOG(WARNING) << \"SSL_get_peer_certificate returned NULL\";\n    return NULL;\n  }\n\n  STACK_OF(X509)* chain = SSL_get_peer_cert_chain(ssl_);\n  X509Certificate::OSCertHandles intermediates;\n  if (chain) {\n    for (int i = 0; i < sk_X509_num(chain); ++i)\n      intermediates.push_back(sk_X509_value(chain, i));\n  }\n  server_cert_ = X509Certificate::CreateFromHandle(cert.get(), intermediates);\n  DCHECK(server_cert_.get());\n\n  return server_cert_.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 181
    },
    {
        "index": 53914,
        "code": "static bool ndp_msg_check_opts(struct ndp_msg *msg)\n{\n\tunsigned char *ptr = ndp_msg_payload_opts(msg);\n\tsize_t len = ndp_msg_payload_opts_len(msg);\n\tstruct ndp_msg_opt_type_info *info;\n\n\twhile (len > 0) {\n\t\tuint8_t cur_opt_raw_type = ptr[0];\n\t\tunsigned int cur_opt_len = ptr[1] << 3; /* convert to bytes */\n\n\t\tif (!cur_opt_len)\n\t\t\treturn false;\n\t\tif (len < cur_opt_len)\n\t\t\tbreak;\n\t\tinfo = ndp_msg_opt_type_info_by_raw_type(cur_opt_raw_type);\n\t\tif (info) {\n\t\t\tif (cur_opt_len < info->raw_struct_size ||\n\t\t\t    (info->check_valid && !info->check_valid(ptr)))\n\t\t\t\tptr[0] = __INVALID_OPT_TYPE_MAGIC;\n\t\t}\n\t\tptr += cur_opt_len;\n\t\tlen -= cur_opt_len;\n\t}\n\n\treturn true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3698",
        "length": 199
    },
    {
        "index": 100602,
        "code": "  void AnimateToTransforms(\n      const PaintedShapeTransforms transforms,\n      base::TimeDelta duration,\n      ui::LayerAnimator::PreemptionStrategy preemption_strategy,\n      gfx::Tween::Type tween,\n      ui::LayerAnimationObserver* animation_observer) {\n    for (int i = 0; i < PAINTED_SHAPE_COUNT; ++i) {\n      ui::LayerAnimator* animator = painted_layers_[i]->GetAnimator();\n      ui::ScopedLayerAnimationSettings animation(animator);\n      animation.SetPreemptionStrategy(preemption_strategy);\n      animation.SetTweenType(tween);\n      std::unique_ptr<ui::LayerAnimationElement> element =\n          ui::LayerAnimationElement::CreateTransformElement(transforms[i],\n                                                            duration);\n      ui::LayerAnimationSequence* sequence =\n          new ui::LayerAnimationSequence(std::move(element));\n\n      if (animation_observer)\n        sequence->AddObserver(animation_observer);\n\n      animator->StartAnimation(sequence);\n    }\n\n    {\n      ui::ScopedLayerAnimationSettings animation(\n          large_shadow_layer_->GetAnimator());\n      animation.SetTweenType(tween);\n      animation.SetTransitionDuration(duration);\n\n      large_shadow_layer_->SetVisible(true);\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 245
    },
    {
        "index": 52688,
        "code": "static int snd_timer_dev_free(struct snd_device *device)\n{\n\tstruct snd_timer *timer = device->device_data;\n\treturn snd_timer_free(timer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-4578",
        "length": 32
    },
    {
        "index": 113520,
        "code": "void WebPage::touchPointAsMouseEvent(const Platform::TouchPoint& point, unsigned modifiers)\n{\n    if (d->m_page->defersLoading())\n        return;\n\n    if (d->m_fullScreenPluginView.get())\n        return;\n\n    d->m_lastUserEventTimestamp = currentTime();\n\n    d->m_touchEventHandler->handleTouchPoint(point, modifiers);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 77
    },
    {
        "index": 140965,
        "code": "const AtomicString& Document::BodyAttributeValue(\n    const QualifiedName& name) const {\n  if (auto* bodyElement = body())\n    return bodyElement->FastGetAttribute(name);\n  return g_null_atom;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 46
    },
    {
        "index": 89628,
        "code": "ghash_setup_armv8_ce_pmull (gcry_cipher_hd_t c)\n{\n  _gcry_ghash_setup_armv8_ce_pmull(c->u_mode.gcm.u_ghash_key.key,\n                                   c->u_mode.gcm.gcm_table);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2019-12904",
        "length": 58
    },
    {
        "index": 130454,
        "code": "void ReportFoundUwS() {\n  base::win::RegKey reporter_key(HKEY_CURRENT_USER,\n                                 kSoftwareRemovalToolRegistryKey,\n                                 KEY_QUERY_VALUE | KEY_SET_VALUE);\n  std::vector<base::string16> found_uws_strings;\n  if (reporter_key.Valid() &&\n      reporter_key.ReadValues(kFoundUwsValueName, &found_uws_strings) ==\n          ERROR_SUCCESS) {\n    rappor::RapporService* rappor_service = g_browser_process->rappor_service();\n\n    bool parse_error = false;\n    for (const base::string16& uws_string : found_uws_strings) {\n      uint32_t uws_id = 0;\n      if (base::StringToUint(uws_string, &uws_id)) {\n        UMA_HISTOGRAM_SPARSE_SLOWLY(kFoundUwsMetricName, uws_id);\n        if (rappor_service) {\n          rappor_service->RecordSample(kFoundUwsMetricName,\n                                       rappor::COARSE_RAPPOR_TYPE,\n                                       base::UTF16ToUTF8(uws_string));\n        }\n      } else {\n        parse_error = true;\n      }\n    }\n\n    reporter_key.DeleteValue(kFoundUwsValueName);\n\n    UMA_HISTOGRAM_BOOLEAN(kFoundUwsReadErrorMetricName, parse_error);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 286
    },
    {
        "index": 169483,
        "code": "void NetworkThrottleManagerImpl::OnThrottlePriorityChanged(\n    NetworkThrottleManagerImpl::ThrottleImpl* throttle,\n    RequestPriority old_priority,\n    RequestPriority new_priority) {\n  if (throttle->IsBlocked() && new_priority != THROTTLED) {\n    UnblockThrottle(throttle);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-311",
        "cve": "CVE-2017-15397",
        "length": 69
    },
    {
        "index": 32677,
        "code": "static int tg3_poll(struct napi_struct *napi, int budget)\n{\n\tstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\n\tstruct tg3 *tp = tnapi->tp;\n\tint work_done = 0;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\twhile (1) {\n\t\tif (sblk->status & SD_STATUS_ERROR)\n\t\t\ttg3_process_error(tp);\n\n\t\ttg3_poll_link(tp);\n\n\t\twork_done = tg3_poll_work(tnapi, work_done, budget);\n\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\tgoto tx_recovery;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\tif (tg3_flag(tp, TAGGED_STATUS)) {\n\t\t\t/* tp->last_tag is used in tg3_int_reenable() below\n\t\t\t * to tell the hw how much work has been processed,\n\t\t\t * so we must read it before checking for more work.\n\t\t\t */\n\t\t\ttnapi->last_tag = sblk->status_tag;\n\t\t\ttnapi->last_irq_tag = tnapi->last_tag;\n\t\t\trmb();\n\t\t} else\n\t\t\tsblk->status &= ~SD_STATUS_UPDATED;\n\n\t\tif (likely(!tg3_has_work(tnapi))) {\n\t\t\tnapi_complete(napi);\n\t\t\ttg3_int_reenable(tnapi);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn work_done;\n\ntx_recovery:\n\t/* work_done is guaranteed to be less than budget. */\n\tnapi_complete(napi);\n\ttg3_reset_task_schedule(tp);\n\treturn work_done;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "length": 343
    },
    {
        "index": 175563,
        "code": "size_t HevcParameterSets::getNumNalUnitsOfType(uint8_t type) {\n size_t num = 0;\n for (size_t i = 0; i < mNalUnits.size(); ++i) {\n if (getType(i) == type) {\n ++num;\n }\n }\n return num;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-0635",
        "length": 65
    },
    {
        "index": 50450,
        "code": "static void perf_cgroup_attach(struct cgroup_subsys_state *css,\n\t\t\t       struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\n\tcgroup_taskset_for_each(task, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-6787",
        "length": 59
    },
    {
        "index": 103666,
        "code": "bool BrowserRenderProcessHost::FastShutdownIfPossible() {\n  if (run_renderer_in_process())\n    return false;  // Single process mode can't do fast shutdown.\n\n  if (!content::GetContentClient()->browser()->IsFastShutdownPossible())\n    return false;\n\n  if (!child_process_launcher_.get() ||\n      child_process_launcher_->IsStarting() ||\n      !GetHandle())\n    return false;  // Render process hasn't started or is probably crashed.\n\n  if (!sudden_termination_allowed())\n    return false;\n\n  child_process_launcher_.reset();\n  fast_shutdown_started_ = true;\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 129
    },
    {
        "index": 157191,
        "code": "bool WebMediaPlayerImpl::DidLoadingProgress() {\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n\n  const bool pipeline_progress = pipeline_controller_.DidLoadingProgress();\n  const bool data_progress = buffered_data_source_host_.DidLoadingProgress();\n  return pipeline_progress || data_progress;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 59
    },
    {
        "index": 122601,
        "code": "void LogSuccess(const Extension* extension,\n                const std::string& api_name,\n                scoped_ptr<ListValue> args,\n                Profile* profile) {\n  if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {\n    BrowserThread::PostTask(BrowserThread::UI,\n                            FROM_HERE,\n                            base::Bind(&LogSuccess,\n                                       extension,\n                                       api_name,\n                                       base::Passed(&args),\n                                       profile));\n  } else {\n    extensions::ActivityLog* activity_log =\n        extensions::ActivityLog::GetInstance(profile);\n    activity_log->LogAPIAction(extension, api_name, args.get(), \"\");\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0885",
        "length": 129
    },
    {
        "index": 142154,
        "code": "  bool CreateRootDirectory(const Profile* profile) {\n    if (root_initialized_)\n      return true;\n    root_ = profile->GetPath().Append(name_);\n    base::ScopedAllowBlockingForTesting allow_blocking;\n    root_initialized_ = base::CreateDirectory(root_);\n    return root_initialized_;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-5194",
        "length": 63
    },
    {
        "index": 106179,
        "code": "JSValue jsTestObjUnsignedLongSequenceAttr(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = jsArray(exec, castedThis->globalObject(), impl->unsignedLongSequenceAttr());\n    return result;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2350",
        "length": 97
    },
    {
        "index": 50390,
        "code": "posix_acl_xattr_get(const struct xattr_handler *handler,\n\t\t    struct dentry *unused, struct inode *inode,\n\t\t    const char *name, void *value, size_t size)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn -EOPNOTSUPP;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, handler->flags);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-285",
        "cve": "CVE-2016-7097",
        "length": 154
    },
    {
        "index": 94406,
        "code": "static void sd_read_protection_type(struct scsi_disk *sdkp, unsigned char *buffer)\n{\n\tstruct scsi_device *sdp = sdkp->device;\n\tu8 type;\n\n\tif (scsi_device_protection(sdp) == 0 || (buffer[12] & 1) == 0)\n\t\treturn;\n\n\ttype = ((buffer[12] >> 1) & 7) + 1; /* P_TYPE 0 = Type 1 */\n\n\tif (type == sdkp->protection_type || !sdkp->first_scan)\n\t\treturn;\n\n\tsdkp->protection_type = type;\n\n\tif (type > SD_DIF_TYPE3_PROTECTION) {\n\t\tsd_printk(KERN_ERR, sdkp, \"formatted with unsupported \"\t\\\n\t\t\t  \"protection type %u. Disabling disk!\\n\", type);\n\t\tsdkp->capacity = 0;\n\t\treturn;\n\t}\n\n\tif (scsi_host_dif_capable(sdp->host, type))\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"Enabling DIF Type %u protection\\n\", type);\n\telse\n\t\tsd_printk(KERN_NOTICE, sdkp,\n\t\t\t  \"Disabling DIF Type %u protection\\n\", type);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4127",
        "length": 257
    },
    {
        "index": 5161,
        "code": "PHP_FUNCTION(pg_lo_read)\n{\n\tzval *pgsql_id;\n\tzend_long len;\n\tsize_t buf_len = PGSQL_LO_READ_BUF_SIZE;\n\tint nbytes, argc = ZEND_NUM_ARGS();\n\tzend_string *buf;\n\tpgLofp *pgsql;\n\n\tif (zend_parse_parameters(argc, \"r|l\", &pgsql_id, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, \"PostgreSQL large object\", le_lofp);\n\n\tif (argc > 1) {\n\t\tbuf_len = len < 0 ? 0 : len;\n\t}\n\t\n\tbuf = zend_string_alloc(buf_len, 0);\n\tif ((nbytes = lo_read((PGconn *)pgsql->conn, pgsql->lofd, buf->val, buf->len))<0) {\n\t\tzend_string_free(buf);\n\t\tRETURN_FALSE;\n\t}\n\n\tbuf->len = nbytes;\n\tbuf->val[buf->len] = '\\0';\n\tRETURN_STR(buf);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1352",
        "length": 214
    },
    {
        "index": 27652,
        "code": "ssize_t tpm_show_temp_deactivated(struct device * dev,\n\t\t\t\tstruct device_attribute * attr, char *buf)\n{\n\tcap_t cap;\n\tssize_t rc;\n\n\trc = tpm_getcap(dev, TPM_CAP_FLAG_VOL, &cap,\n\t\t\t \"attempting to determine the temporary state\");\n\tif (rc)\n\t\treturn 0;\n\n\trc = sprintf(buf, \"%d\\n\", cap.stclear_flags.deactivated);\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2011-1160",
        "length": 91
    },
    {
        "index": 82507,
        "code": "JsVar *jsvMathsOpSkipNames(JsVar *a, JsVar *b, int op) {\n  JsVar *pa = jsvSkipName(a);\n  JsVar *pb = jsvSkipName(b);\n  JsVar *oa = jsvGetValueOf(pa);\n  JsVar *ob = jsvGetValueOf(pb);\n  jsvUnLock2(pa, pb);\n  JsVar *res = jsvMathsOp(oa,ob,op);\n  jsvUnLock2(oa, ob);\n  return res;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-11596",
        "length": 118
    },
    {
        "index": 86638,
        "code": "static unsigned int __blk_mq_get_reserved_tag(struct blk_mq_alloc_data *data)\n{\n\tint tag, zero = 0;\n\n\tif (unlikely(!data->hctx->tags->nr_reserved_tags)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn BLK_MQ_TAG_FAIL;\n\t}\n\n\ttag = bt_get(data, &data->hctx->tags->breserved_tags, NULL, &zero,\n\t\tdata->hctx->tags);\n\tif (tag < 0)\n\t\treturn BLK_MQ_TAG_FAIL;\n\n\treturn tag;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "length": 115
    },
    {
        "index": 31336,
        "code": "int crypto_register_shashes(struct shash_alg *algs, int count)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = crypto_register_shash(&algs[i]);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (--i; i >= 0; --i)\n\t\tcrypto_unregister_shash(&algs[i]);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2013-2548",
        "length": 93
    },
    {
        "index": 38359,
        "code": "static int cm_drep_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_drep_msg *drep_msg;\n\tint ret;\n\n\tdrep_msg = (struct cm_drep_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(drep_msg->remote_comm_id,\n\t\t\t\t   drep_msg->local_comm_id);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\twork->cm_event.private_data = &drep_msg->private_data;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_DREQ_SENT &&\n\t    cm_id_priv->id.state != IB_CM_DREQ_RCVD) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_enter_timewait(cm_id_priv);\n\n\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\tret = atomic_inc_and_test(&cm_id_priv->work_count);\n\tif (!ret)\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tif (ret)\n\t\tcm_process_work(cm_id_priv, work);\n\telse\n\t\tcm_deref_id(cm_id_priv);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2739",
        "length": 285
    },
    {
        "index": 115170,
        "code": "void BluetoothOptionsHandler::Initialize() {\n  DCHECK(web_ui_);\n  if (!CommandLine::ForCurrentProcess()\n      ->HasSwitch(switches::kEnableBluetooth)) {\n    return;\n  }\n\n  web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.showBluetoothSettings\");\n\n  bool bluetooth_on = true;\n  base::FundamentalValue checked(bluetooth_on);\n  web_ui_->CallJavascriptFunction(\n      \"options.SystemOptions.setBluetoothCheckboxState\", checked);\n\n  chromeos::BluetoothManager* bluetooth_manager =\n      chromeos::BluetoothManager::GetInstance();\n  DCHECK(bluetooth_manager);\n  bluetooth_manager->AddObserver(this);\n\n  chromeos::BluetoothAdapter* default_adapter =\n      bluetooth_manager->DefaultAdapter();\n  DefaultAdapterChanged(default_adapter);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3963",
        "length": 154
    },
    {
        "index": 56117,
        "code": "static void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_THROTTLE,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_event_clock(event),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2015-8963",
        "length": 229
    },
    {
        "index": 66125,
        "code": "void inet_csk_reqsk_queue_hash_add(struct sock *sk, struct request_sock *req,\n\t\t\t\t   unsigned long timeout)\n{\n\treqsk_queue_hash_req(req, timeout);\n\tinet_csk_reqsk_queue_added(sk);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-8890",
        "length": 47
    },
    {
        "index": 15561,
        "code": "client_cleanup_stdio_fwd(int id, void *arg)\n{\n\tdebug(\"stdio forwarding: done\");\n\tcleanup_exit(0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-1908",
        "length": 27
    },
    {
        "index": 99906,
        "code": "void* NPN_GetJavaPeer(NPP) {\n  DLOG(INFO) << \"NPN_GetJavaPeer is not implemented.\";\n  return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 33
    },
    {
        "index": 103510,
        "code": "void ExtensionService::RecordPermissionMessagesHistogram(\n    const Extension* e, const char* histogram) {\n  base::Histogram* counter = base::LinearHistogram::FactoryGet(\n      histogram,\n      1,\n      ExtensionPermissionMessage::kEnumBoundary,\n      ExtensionPermissionMessage::kEnumBoundary + 1,\n      base::Histogram::kUmaTargetedHistogramFlag);\n\n  ExtensionPermissionMessages permissions = e->GetPermissionMessages();\n  if (permissions.empty()) {\n    counter->Add(ExtensionPermissionMessage::kNone);\n  } else {\n    for (ExtensionPermissionMessages::iterator it = permissions.begin();\n         it != permissions.end(); ++it)\n      counter->Add(it->id());\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2859",
        "length": 146
    },
    {
        "index": 9563,
        "code": "PHP_FUNCTION(locale_get_display_region)\n{\n    get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-6294",
        "length": 32
    },
    {
        "index": 166872,
        "code": "CrossThreadPersistentRegion& ProcessHeap::GetCrossThreadWeakPersistentRegion() {\n  DEFINE_THREAD_SAFE_STATIC_LOCAL(CrossThreadPersistentRegion,\n                                  persistent_region, ());\n  return persistent_region;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-6158",
        "length": 40
    },
    {
        "index": 13004,
        "code": "sshpkt_disconnect(struct ssh *ssh, const char *fmt,...)\n{\n\tchar buf[1024];\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (compat20) {\n\t\tif ((r = sshpkt_start(ssh, SSH2_MSG_DISCONNECT)) != 0 ||\n\t\t    (r = sshpkt_put_u32(ssh, SSH2_DISCONNECT_PROTOCOL_ERROR)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, \"\")) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\treturn r;\n\t} else {\n\t\tif ((r = sshpkt_start(ssh, SSH_MSG_DISCONNECT)) != 0 ||\n\t\t    (r = sshpkt_put_cstring(ssh, buf)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1907",
        "length": 220
    },
    {
        "index": 50691,
        "code": "static void srpt_refresh_port_work(struct work_struct *work)\n{\n\tstruct srpt_port *sport = container_of(work, struct srpt_port, work);\n\n\tsrpt_refresh_port(sport);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-6327",
        "length": 42
    },
    {
        "index": 138395,
        "code": "UtilityServiceFactory::UtilityServiceFactory()\n    : network_registry_(base::MakeUnique<service_manager::BinderRegistry>()) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-1280",
        "length": 26
    },
    {
        "index": 66863,
        "code": "static unsigned long __init init_range_memory_mapping(\n\t\t\t\t\t   unsigned long r_start,\n\t\t\t\t\t   unsigned long r_end)\n{\n\tunsigned long start_pfn, end_pfn;\n\tunsigned long mapped_ram_size = 0;\n\tint i;\n\n\tfor_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL) {\n\t\tu64 start = clamp_val(PFN_PHYS(start_pfn), r_start, r_end);\n\t\tu64 end = clamp_val(PFN_PHYS(end_pfn), r_start, r_end);\n\t\tif (start >= end)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if it is overlapping with brk pgt, we need to\n\t\t * alloc pgt buf from memblock instead.\n\t\t */\n\t\tcan_use_brk_pgt = max(start, (u64)pgt_buf_end<<PAGE_SHIFT) >=\n\t\t\t\t    min(end, (u64)pgt_buf_top<<PAGE_SHIFT);\n\t\tinit_memory_mapping(start, end);\n\t\tmapped_ram_size += end - start;\n\t\tcan_use_brk_pgt = true;\n\t}\n\n\treturn mapped_ram_size;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-7889",
        "length": 231
    },
    {
        "index": 66847,
        "code": "nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf   = p; p += 2;\n\targs->dircount = ~0;\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7895",
        "length": 144
    },
    {
        "index": 58967,
        "code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\n\tif (peer) {\n\t\tla->l2_psm = l2cap_pi(sk)->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t} else {\n\t\tla->l2_psm = l2cap_pi(sk)->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-1000251",
        "length": 219
    },
    {
        "index": 88433,
        "code": "uint32_t GPMF_ElementsInStruct(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t ssize = GPMF_StructSize(ms);\n\t\tGPMF_SampleType type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\tif (type != GPMF_TYPE_NEST && type != GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tint32_t tsize = GPMF_SizeofType(type);\n\t\t\tif (tsize > 0)\n\t\t\t\treturn ssize / tsize;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tchar tmp[64] = \"\";\n\t\t\t\tuint32_t tmpsize = sizeof(tmp);\n\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\t\t\t\t\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data, size, tmp, &tmpsize))\n\t\t\t\t\treturn tmpsize;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2019-15148",
        "length": 302
    },
    {
        "index": 98312,
        "code": "bool FrameLoaderClient::dispatchDidLoadResourceFromMemoryCache(WebCore::DocumentLoader*, const ResourceRequest&, const ResourceResponse&, int length)\n{\n    notImplemented();\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 39
    },
    {
        "index": 112903,
        "code": " void SetFreeDiskSpaceGetterForTesting(FreeDiskSpaceGetterInterface* getter) {\n   delete global_free_disk_getter_for_testing;  // Safe to delete NULL;\n   global_free_disk_getter_for_testing = getter;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2895",
        "length": 48
    },
    {
        "index": 129085,
        "code": "bool DebuggerSendCommandFunction::RunAsync() {\n  scoped_ptr<SendCommand::Params> params(SendCommand::Params::Create(*args_));\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n\n  CopyDebuggee(&debuggee_, params->target);\n  if (!InitClientHost())\n    return false;\n\n  client_host_->SendMessageToBackend(this, params->method,\n      params->command_params.get());\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3172",
        "length": 87
    },
    {
        "index": 162328,
        "code": "void KeepVideoFrameAlive(const scoped_refptr<VideoFrame>& frame) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 16
    },
    {
        "index": 69410,
        "code": "void unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)\n{\n\tdown_write(&asymmetric_key_parsers_sem);\n\tlist_del(&parser->link);\n\tup_write(&asymmetric_key_parsers_sem);\n\n\tpr_notice(\"Asymmetric key parser '%s' unregistered\\n\", parser->name);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "length": 62
    },
    {
        "index": 112681,
        "code": "const ResourceRequest& DocumentLoader::originalRequestCopy() const\n{\n    return m_originalRequestCopy;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 23
    },
    {
        "index": 105790,
        "code": "Label::Label(const std::wstring& text) {\n  Init(text, GetDefaultFont());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2346",
        "length": 21
    },
    {
        "index": 167464,
        "code": "void OfflineAudioDestinationHandler::StopRendering() {\n  NOTREACHED();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 17
    },
    {
        "index": 129147,
        "code": "void Framebuffer::ClearFramebufferCompleteComboMap() {\n  if (framebuffer_combo_complete_map_) {\n    framebuffer_combo_complete_map_->clear();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3173",
        "length": 33
    },
    {
        "index": 112590,
        "code": "void Document::takeDOMWindowFrom(Document* document)\n{\n    ASSERT(m_frame);\n    ASSERT(!m_domWindow);\n    ASSERT(document->domWindow());\n    ASSERT(!document->inPageCache());\n\n    m_domWindow = document->m_domWindow.release();\n    m_domWindow->didSecureTransitionTo(this);\n\n    ASSERT(m_domWindow->document() == this);\n    ASSERT(m_domWindow->frame() == m_frame);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 88
    },
    {
        "index": 106308,
        "code": "void SyncBackendHost::Core::DoSetPassphrase(const std::string& passphrase,\n                                            bool is_explicit) {\n  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());\n  syncapi_->SetPassphrase(passphrase, is_explicit);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2351",
        "length": 57
    },
    {
        "index": 574,
        "code": "pdf_drop_processor(fz_context *ctx, pdf_processor *proc)\n{\n\tif (proc)\n\t{\n\t\tif (proc->close_processor)\n\t\t\tfz_warn(ctx, \"dropping unclosed PDF processor\");\n\t\tif (proc->drop_processor)\n\t\t\tproc->drop_processor(ctx, proc);\n\t}\n\tfz_free(ctx, proc);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-1000037",
        "length": 72
    },
    {
        "index": 6495,
        "code": "static int dtls1_handshake_write(SSL *s)\n{\n    return dtls1_do_write(s, SSL3_RT_HANDSHAKE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-0207",
        "length": 32
    },
    {
        "index": 129959,
        "code": "void TestUnwindFunctions::SetNoUnwindInfoForNextFrame() {\n  next_lookup_returns_null_ = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 27
    },
    {
        "index": 1149,
        "code": "GfxShadingPattern::~GfxShadingPattern() {\n  delete shading;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 19
    },
    {
        "index": 35277,
        "code": "int netdev_bonding_change(struct net_device *dev, unsigned long event)\n{\n\treturn call_netdevice_notifiers(event, dev);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-1019",
        "length": 30
    },
    {
        "index": 125141,
        "code": "void PluginServiceImpl::OpenChannelToPpapiBroker(\n    int render_process_id,\n    const FilePath& path,\n    PpapiPluginProcessHost::BrokerClient* client) {\n  PpapiPluginProcessHost* plugin_host = FindOrStartPpapiBrokerProcess(\n      render_process_id, path);\n  if (plugin_host) {\n    plugin_host->OpenChannelToPlugin(client);\n  } else {\n    client->OnPpapiChannelOpened(IPC::ChannelHandle(), base::kNullProcessId, 0);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-0910",
        "length": 115
    },
    {
        "index": 161669,
        "code": "VaapiVideoDecodeAccelerator::CreateSurface() {\n  DCHECK(decoder_thread_task_runner_->BelongsToCurrentThread());\n  base::AutoLock auto_lock(lock_);\n\n  if (available_va_surfaces_.empty())\n    return nullptr;\n\n  DCHECK(!awaiting_va_surfaces_recycle_);\n  scoped_refptr<VASurface> va_surface(new VASurface(\n      available_va_surfaces_.front(), requested_pic_size_,\n      vaapi_wrapper_->va_surface_format(), va_surface_release_cb_));\n  available_va_surfaces_.pop_front();\n\n  return new VaapiDecodeSurface(curr_input_buffer_->id(), va_surface);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-6061",
        "length": 125
    },
    {
        "index": 51440,
        "code": "void gdImageGetClip (gdImagePtr im, int *x1P, int *y1P, int *x2P, int *y2P)\n{\n\t*x1P = im->cx1;\n\t*y1P = im->cy1;\n\t*x2P = im->cx2;\n\t*y2P = im->cy2;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5767",
        "length": 78
    },
    {
        "index": 113859,
        "code": "std::wstring GetExtensionWithoutLeadingDot(const std::wstring& extension) {\n  DCHECK(extension.empty() || extension[0] == L'.');\n   return extension.empty() ? extension : extension.substr(1);\n }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 45
    },
    {
        "index": 153611,
        "code": "void GLES2Implementation::DeletePathsCHROMIUMStub(GLuint first_client_id,\n                                                  GLsizei range) {\n  helper_->DeletePathsCHROMIUM(first_client_id, range);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 40
    },
    {
        "index": 107429,
        "code": "void JSArray::getOwnPropertyNames(ExecState* exec, PropertyNameArray& propertyNames, EnumerationMode mode)\n{\n\n    ArrayStorage* storage = m_storage;\n    \n    unsigned usedVectorLength = min(storage->m_length, m_vectorLength);\n    for (unsigned i = 0; i < usedVectorLength; ++i) {\n        if (storage->m_vector[i])\n            propertyNames.add(Identifier::from(exec, i));\n    }\n\n    if (SparseArrayValueMap* map = storage->m_sparseValueMap) {\n        SparseArrayValueMap::iterator end = map->end();\n        for (SparseArrayValueMap::iterator it = map->begin(); it != end; ++it)\n            propertyNames.add(Identifier::from(exec, it->first));\n    }\n\n    if (mode == IncludeDontEnumProperties)\n        propertyNames.add(exec->propertyNames().length);\n\n    JSObject::getOwnPropertyNames(exec, propertyNames, mode);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 200
    },
    {
        "index": 185820,
        "code": "void UtilityServiceFactory::RegisterServices(ServiceMap* services) {\n  GetContentClient()->utility()->RegisterServices(services);\n\n  service_manager::EmbeddedServiceInfo video_capture_info;\n  video_capture_info.factory = base::Bind(&CreateVideoCaptureService);\n  services->insert(\n      std::make_pair(video_capture::mojom::kServiceName, video_capture_info));\n \n #if BUILDFLAG(ENABLE_PEPPER_CDMS)\n   service_manager::EmbeddedServiceInfo info;\n  info.factory = base::Bind(&CreateMediaService);\n  services->insert(std::make_pair(media::mojom::kMediaServiceName, info));\n #endif\n \n   service_manager::EmbeddedServiceInfo shape_detection_info;\n  shape_detection_info.factory =\n      base::Bind(&shape_detection::ShapeDetectionService::Create);\n  services->insert(std::make_pair(shape_detection::mojom::kServiceName,\n                                  shape_detection_info));\n\n  service_manager::EmbeddedServiceInfo data_decoder_info;\n  data_decoder_info.factory = base::Bind(&CreateDataDecoderService);\n  services->insert(\n      std::make_pair(data_decoder::mojom::kServiceName, data_decoder_info));\n\n  if (base::FeatureList::IsEnabled(features::kNetworkService)) {\n    GetContentClient()->utility()->RegisterNetworkBinders(\n        network_registry_.get());\n    service_manager::EmbeddedServiceInfo network_info;\n    network_info.factory = base::Bind(\n        &UtilityServiceFactory::CreateNetworkService, base::Unretained(this));\n    network_info.task_runner = ChildProcess::current()->io_task_runner();\n    services->insert(\n        std::make_pair(content::mojom::kNetworkServiceName, network_info));\n  }\n}\n",
        "line": "  info.factory = base::Bind(&CreateMediaService);\n  services->insert(std::make_pair(media::mojom::kMediaServiceName, info));\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2015-1280",
        "length": 345
    },
    {
        "index": 180960,
        "code": "AcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n     UINT32                  i;\n \n \n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n\n\n    /* Get all arguments in the list */\n\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n\n        /* Move on to next argument, if any */\n\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n \n     /* Create the interpreter arguments, in reverse order */\n \n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n\n    return_ACPI_STATUS (Status);\n\n\nCleanup:\n    /*\n     * We must undo everything done above; meaning that we must\n      * pop everything off of the operand stack and delete those\n      * objects\n      */\n    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n \n     ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n     return_ACPI_STATUS (Status);\n}\n",
        "line": "    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n",
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2017-13693",
        "length": 453
    },
    {
        "index": 173500,
        "code": "void omx_vdec::set_frame_rate(OMX_S64 act_timestamp)\n{\n    OMX_U32 new_frame_interval = 0;\n if (VALID_TS(act_timestamp) && VALID_TS(prev_ts) && act_timestamp != prev_ts\n && llabs(act_timestamp - prev_ts) > 2000) {\n        new_frame_interval = client_set_fps ? frm_int :\n            llabs(act_timestamp - prev_ts);\n if (new_frame_interval != frm_int || frm_int == 0) {\n            frm_int = new_frame_interval;\n if (frm_int) {\n                drv_ctx.frame_rate.fps_numerator = 1e6;\n                drv_ctx.frame_rate.fps_denominator = frm_int;\n                DEBUG_PRINT_LOW(\"set_frame_rate: frm_int(%u) fps(%f)\",\n (unsigned int)frm_int, drv_ctx.frame_rate.fps_numerator /\n (float)drv_ctx.frame_rate.fps_denominator);\n /* We need to report the difference between this FBD and the previous FBD\n                 * back to the driver for clock scaling purposes. */\n struct v4l2_outputparm oparm;\n /*XXX: we're providing timing info as seconds per frame rather than frames\n                 * per second.*/\n                oparm.timeperframe.numerator = drv_ctx.frame_rate.fps_denominator;\n                oparm.timeperframe.denominator = drv_ctx.frame_rate.fps_numerator;\n\n struct v4l2_streamparm sparm;\n                sparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n                sparm.parm.output = oparm;\n if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_PARM, &sparm)) {\n                    DEBUG_PRINT_ERROR(\"Unable to convey fps info to driver, \\\n                            performance might be affected\");\n }\n\n }\n }\n }\n    prev_ts = act_timestamp;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3746",
        "length": 378
    },
    {
        "index": 79202,
        "code": "static int StreamTcpPacketIsWindowUpdate(TcpSession *ssn, Packet *p)\n{\n    TcpStream *stream = NULL, *ostream = NULL;\n    uint32_t seq;\n    uint32_t ack;\n    uint32_t pkt_win;\n\n    if (p->flags & PKT_PSEUDO_STREAM_END)\n        return 0;\n\n    if (ssn->state < TCP_ESTABLISHED)\n        return 0;\n\n    if (p->payload_len > 0)\n        return 0;\n\n    if ((p->tcph->th_flags & (TH_SYN|TH_FIN|TH_RST)) != 0)\n        return 0;\n\n    if (TCP_GET_WINDOW(p) == 0)\n        return 0;\n\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n\n    seq = TCP_GET_SEQ(p);\n    ack = TCP_GET_ACK(p);\n\n    pkt_win = TCP_GET_WINDOW(p) << ostream->wscale;\n    if (pkt_win == ostream->window)\n        return 0;\n\n    if (ack == ostream->last_ack && seq == stream->next_seq) {\n        SCLogDebug(\"packet is TCP window update: %\"PRIu64, p->pcap_cnt);\n        return 1;\n    }\n    SCLogDebug(\"seq %u (%u), ack %u (%u)\", seq, stream->next_seq, ack, ostream->last_ack);\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-14568",
        "length": 338
    },
    {
        "index": 63484,
        "code": "static void test_anonymous_strings()\n{\n  assert_true_rule(\n      \"rule test { strings: $ = \\\"a\\\" $ = \\\"b\\\" condition: all of them }\",\n      \"ab\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-11328",
        "length": 43
    },
    {
        "index": 65143,
        "code": "static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, &fl6, sk->sk_mark, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\tdst_release(dst);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-9077",
        "length": 474
    },
    {
        "index": 14301,
        "code": "static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch *d,\n                                                        hwaddr addr,\n                                                        bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    subpage_t *subpage;\n\n    section = phys_page_find(d->phys_map, addr, d->map.nodes, d->map.sections);\n    if (resolve_subpage && section->mr->subpage) {\n        subpage = container_of(section->mr, subpage_t, iomem);\n        section = &d->map.sections[subpage->sub_section[SUBPAGE_IDX(addr)]];\n    }\n    return section;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-8818",
        "length": 126
    },
    {
        "index": 74213,
        "code": "save_and_apply_config_tree(void)\n{\n\tconfig_tree *ptree;\n#ifndef SAVECONFIG\n\tconfig_tree *punlinked;\n#endif\n\n\t/*\n\t * Keep all the configuration trees applied since startup in\n\t * a list that can be used to dump the configuration back to\n\t * a text file.\n\t */\n\tptree = emalloc(sizeof(*ptree));\n\tmemcpy(ptree, &cfgt, sizeof(*ptree));\n\tmemset(&cfgt, 0, sizeof(cfgt));\n\t\n\tLINK_TAIL_SLIST(cfg_tree_history, ptree, link, config_tree);\n\n#ifdef SAVECONFIG\n\tif (HAVE_OPT( SAVECONFIGQUIT )) {\n\t\tFILE *dumpfile;\n\t\tint err;\n\t\tint dumpfailed;\n\n\t\tdumpfile = fopen(OPT_ARG( SAVECONFIGQUIT ), \"w\");\n\t\tif (NULL == dumpfile) {\n\t\t\terr = errno;\n\t\t\tfprintf(stderr,\n\t\t\t\t\"can not create save file %s, error %d %s\\n\",\n\t\t\t\tOPT_ARG( SAVECONFIGQUIT ), err,\n\t\t\t\tstrerror(err));\n\t\t\texit(err);\n\t\t}\n\t\t\n\t\tdumpfailed = dump_all_config_trees(dumpfile, 0);\n\t\tif (dumpfailed)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"--saveconfigquit %s error %d\\n\",\n\t\t\t\tOPT_ARG( SAVECONFIGQUIT ),\n\t\t\t\tdumpfailed);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t\t\"configuration saved to %s\\n\",\n\t\t\t\tOPT_ARG( SAVECONFIGQUIT ));\n\n\t\texit(dumpfailed);\n\t}\n#endif\t/* SAVECONFIG */\n\n\t/* The actual configuration done depends on whether we are configuring the\n\t * simulator or the daemon. Perform a check and call the appropriate\n\t * function as needed.\n\t */\n\n#ifndef SIM\n\tconfig_ntpd(ptree);\n#else\n\tconfig_ntpdsim(ptree);\n#endif\n\n\t/*\n\t * With configure --disable-saveconfig, there's no use keeping\n\t * the config tree around after application, so free it.\n\t */\n#ifndef SAVECONFIG\n\tUNLINK_SLIST(punlinked, cfg_tree_history, ptree, link,\n\t\t     config_tree);\n\tNTP_INSIST(punlinked == ptree);\n\tfree_config_tree(ptree);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-5195",
        "length": 452
    },
    {
        "index": 30001,
        "code": "static int br_mdb_copy(struct net_bridge_mdb_htable *new,\n\t\t       struct net_bridge_mdb_htable *old,\n\t\t       int elasticity)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tint maxlen;\n\tint len;\n\tint i;\n\n\tfor (i = 0; i < old->max; i++)\n\t\thlist_for_each_entry(mp, &old->mhash[i], hlist[old->ver])\n\t\t\thlist_add_head(&mp->hlist[new->ver],\n\t\t\t\t       &new->mhash[br_ip_hash(new, &mp->addr)]);\n\n\tif (!elasticity)\n\t\treturn 0;\n\n\tmaxlen = 0;\n\tfor (i = 0; i < new->max; i++) {\n\t\tlen = 0;\n\t\thlist_for_each_entry(mp, &new->mhash[i], hlist[new->ver])\n\t\t\tlen++;\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t}\n\n\treturn maxlen > elasticity ? -EINVAL : 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-4129",
        "length": 209
    },
    {
        "index": 107571,
        "code": "Eina_Bool ewk_view_page_zoom_set(Evas_Object* ewkView, float pageZoomFactor)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_page_zoom_set(smartData->main_frame, pageZoomFactor);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 62
    },
    {
        "index": 141775,
        "code": "std::unique_ptr<ChromeMetricsServiceClient> ChromeMetricsServiceClient::Create(\n    metrics::MetricsStateManager* state_manager) {\n  std::unique_ptr<ChromeMetricsServiceClient> client(\n      new ChromeMetricsServiceClient(state_manager));\n  client->Initialize();\n\n  return client;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2016-5165",
        "length": 60
    },
    {
        "index": 23939,
        "code": "static void add_airo_dev(struct airo_info *ai)\n{\n\t/* Upper layers already keep track of PCI devices,\n\t * so we only need to remember our non-PCI cards. */\n\tif (!ai->pci)\n\t\tlist_add_tail(&ai->dev_list, &airo_devices);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 62
    },
    {
        "index": 14567,
        "code": "static int gf2m_Mdouble(const EC_GROUP *group, BIGNUM *x, BIGNUM *z, BN_CTX *ctx)\n\t{\n\tBIGNUM *t1;\n\tint ret = 0;\n\t\n\t/* Since Mdouble is static we can guarantee that ctx != NULL. */\n\tBN_CTX_start(ctx);\n\tt1 = BN_CTX_get(ctx);\n\tif (t1 == NULL) goto err;\n\n\tif (!group->meth->field_sqr(group, x, x, ctx)) goto err;\n\tif (!group->meth->field_sqr(group, t1, z, ctx)) goto err;\n\tif (!group->meth->field_mul(group, z, x, t1, ctx)) goto err;\n\tif (!group->meth->field_sqr(group, x, x, ctx)) goto err;\n\tif (!group->meth->field_sqr(group, t1, t1, ctx)) goto err;\n\tif (!group->meth->field_mul(group, t1, &group->b, t1, ctx)) goto err;\n\tif (!BN_GF2m_add(x, x, t1)) goto err;\n\n\tret = 1;\n\n err:\n\tBN_CTX_end(ctx);\n\treturn ret;\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2014-0076",
        "length": 253
    },
    {
        "index": 25842,
        "code": "static void release_bts_buffer(int cpu)\n{\n\tstruct debug_store *ds = per_cpu(cpu_hw_events, cpu).ds;\n\n\tif (!ds || !x86_pmu.bts)\n\t\treturn;\n\n\tkfree((void *)(unsigned long)ds->bts_buffer_base);\n\tds->bts_buffer_base = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 67
    },
    {
        "index": 147057,
        "code": "WebURLRequest WebLocalFrameImpl::RequestForReload(\n    WebFrameLoadType load_type,\n    const WebURL& override_url) const {\n  DCHECK(GetFrame());\n  ResourceRequest request = GetFrame()->Loader().ResourceRequestForReload(\n      static_cast<FrameLoadType>(load_type), override_url);\n  return WrappedResourceRequest(request);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 72
    },
    {
        "index": 150163,
        "code": "bool ImageProcessorClient::WaitForFrameProcessors() {\n  bool success = true;\n  for (auto& processor : frame_processors_)\n    success &= processor->WaitUntilDone();\n\n  return success;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5067",
        "length": 43
    },
    {
        "index": 63932,
        "code": "static int decode(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n{\n    rc->code -= cumFreq * rc->range;\n    rc->range *= freq;\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n        unsigned byte = bytestream2_get_byte(gb);\n        rc->code = (rc->code << 8) | byte;\n        rc->range <<= 8;\n    }\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-9995",
        "length": 115
    },
    {
        "index": 66011,
        "code": "void svc_rdma_wc_inv(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tsvc_rdma_send_wc_common_put(cq, wc, \"localInv\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 39
    },
    {
        "index": 2403,
        "code": "bool smb1cli_conn_server_writebraw(struct smbXcli_conn *conn)\n{\n\treturn conn->smb1.server.writebraw;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-5296",
        "length": 31
    },
    {
        "index": 46074,
        "code": "xdr_krb5_kvno(XDR *xdrs, krb5_kvno *objp)\n{\n\tunsigned char tmp;\n\n\ttmp = '\\0'; /* for purify, else xdr_u_char performs a umr */\n\n\tif (xdrs->x_op == XDR_ENCODE)\n\t\ttmp = (unsigned char) *objp;\n\n\tif (!xdr_u_char(xdrs, &tmp))\n\t\treturn (FALSE);\n\n\tif (xdrs->x_op == XDR_DECODE)\n\t\t*objp = (krb5_kvno) tmp;\n\n\treturn (TRUE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-9421",
        "length": 120
    },
    {
        "index": 53921,
        "code": "int ndp_msg_next_opt_offset(struct ndp_msg *msg, int offset,\n\t\t\t    enum ndp_msg_opt_type opt_type)\n{\n\tunsigned char *opts_start = ndp_msg_payload_opts(msg);\n\tunsigned char *ptr = opts_start;\n\tsize_t len = ndp_msg_payload_opts_len(msg);\n\tuint8_t opt_raw_type = ndp_msg_opt_type_info(opt_type)->raw_type;\n\tbool ignore = true;\n\n\tif (offset == -1) {\n\t\toffset = 0;\n\t\tignore = false;\n\t}\n\n\tptr += offset;\n\tlen -= offset;\n\twhile (len > 0) {\n\t\tuint8_t cur_opt_raw_type = ptr[0];\n\t\tunsigned int cur_opt_len = ptr[1] << 3; /* convert to bytes */\n\n\t\tif (!cur_opt_len || len < cur_opt_len)\n\t\t\tbreak;\n\t\tif (cur_opt_raw_type == opt_raw_type && !ignore)\n\t\t\treturn ptr - opts_start;\n\t\tptr += cur_opt_len;\n\t\tlen -= cur_opt_len;\n\t\tignore = false;\n\t}\n\treturn -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3698",
        "length": 222
    },
    {
        "index": 179458,
        "code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n \tstruct pppol2tp_session *ps;\n \n \tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n \n \tif (get_user(len, optlen))\n \t\treturn -EFAULT;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\n\t/* Get the session context */\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\n\t/* Special case: if session_id == 0x0000, treat as operation on tunnel */\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n",
        "line": "\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n",
        "label": 1,
        "cwe": "CWE-264",
        "cve": "CVE-2014-4943",
        "length": 419
    },
    {
        "index": 122767,
        "code": "void BrowserPluginGuest::SetDamageBuffer(\n    TransportDIB* damage_buffer,\n#if defined(OS_WIN)\n    int damage_buffer_size,\n    TransportDIB::Handle remote_handle,\n#endif\n    const gfx::Size& damage_view_size,\n    float scale_factor) {\n  DCHECK(*static_cast<unsigned int*>(damage_buffer->memory()) == 0xdeadbeef);\n  damage_buffer_.reset(damage_buffer);\n#if defined(OS_WIN)\n  damage_buffer_size_ = damage_buffer_size;\n  remote_damage_buffer_handle_ = remote_handle;\n#endif\n  damage_view_size_ = damage_view_size;\n  damage_buffer_scale_factor_ = scale_factor;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 134
    },
    {
        "index": 121797,
        "code": "void UDPSocketWin::LogRead(int result, const char* bytes) const {\n  if (result < 0) {\n    net_log_.AddEventWithNetErrorCode(NetLog::TYPE_UDP_RECEIVE_ERROR, result);\n    return;\n  }\n\n  if (net_log_.IsLoggingAllEvents()) {\n    IPEndPoint address;\n    bool is_address_valid = ReceiveAddressToIPEndpoint(&address);\n    net_log_.AddEvent(\n        NetLog::TYPE_UDP_BYTES_RECEIVED,\n        CreateNetLogUDPDataTranferCallback(\n            result, bytes,\n            is_address_valid ? &address : NULL));\n  }\n\n  base::StatsCounter read_bytes(\"udp.read_bytes\");\n  read_bytes.Add(result);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2013-2856",
        "length": 149
    },
    {
        "index": 111894,
        "code": "void ProfileSyncService::InitializeBackend(bool delete_stale_data) {\n  if (!backend_.get()) {\n    NOTREACHED();\n    return;\n  }\n\n  syncable::ModelTypeSet initial_types;\n  if (HasSyncSetupCompleted()) {\n    initial_types = GetPreferredDataTypes();\n  }\n\n  SyncCredentials credentials = GetCredentials();\n\n  scoped_refptr<net::URLRequestContextGetter> request_context_getter(\n      profile_->GetRequestContext());\n\n  if (delete_stale_data)\n    ClearStaleErrors();\n\n  backend_unrecoverable_error_handler_.reset(\n    new browser_sync::BackendUnrecoverableErrorHandler(\n        MakeWeakHandle(AsWeakPtr())));\n\n  backend_->Initialize(\n      this,\n      MakeWeakHandle(sync_js_controller_.AsWeakPtr()),\n      sync_service_url_,\n      initial_types,\n      credentials,\n      delete_stale_data,\n      backend_unrecoverable_error_handler_.get(),\n      &browser_sync::ChromeReportUnrecoverableError);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 199
    },
    {
        "index": 64226,
        "code": "static apr_status_t core_insert_network_bucket(conn_rec *c,\n                                               apr_bucket_brigade *bb,\n                                               apr_socket_t *socket)\n{\n    apr_bucket *e = apr_bucket_socket_create(socket, c->bucket_alloc);\n    APR_BRIGADE_INSERT_TAIL(bb, e);\n    return APR_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-9798",
        "length": 66
    },
    {
        "index": 26420,
        "code": "static void pmcraid_cancel_ldn(struct pmcraid_cmd *cmd)\n{\n\tpmcraid_cancel_hcam(cmd,\n\t\t\t    PMCRAID_HCAM_CODE_LOG_DATA,\n\t\t\t    pmcraid_cancel_ccn);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-2906",
        "length": 45
    },
    {
        "index": 90537,
        "code": "static __always_inline void __vma_unlink_common(struct mm_struct *mm,\n\t\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\t\tstruct vm_area_struct *prev,\n\t\t\t\t\t\tbool has_prev,\n\t\t\t\t\t\tstruct vm_area_struct *ignore)\n{\n\tstruct vm_area_struct *next;\n\n\tvma_rb_erase_ignore(vma, &mm->mm_rb, ignore);\n\tnext = vma->vm_next;\n\tif (has_prev)\n\t\tprev->vm_next = next;\n\telse {\n\t\tprev = vma->vm_prev;\n\t\tif (prev)\n\t\t\tprev->vm_next = next;\n\t\telse\n\t\t\tmm->mmap = next;\n\t}\n\tif (next)\n\t\tnext->vm_prev = prev;\n\n\t/* Kill the cache */\n\tvmacache_invalidate(mm);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2019-11599",
        "length": 157
    },
    {
        "index": 45927,
        "code": "static int crypt(struct blkcipher_desc *d,\n\t\t struct blkcipher_walk *w, struct priv *ctx,\n\t\t void (*tw)(struct crypto_tfm *, u8 *, const u8 *),\n\t\t void (*fn)(struct crypto_tfm *, u8 *, const u8 *))\n{\n\tint err;\n\tunsigned int avail;\n\tconst int bs = XTS_BLOCK_SIZE;\n\tstruct sinfo s = {\n\t\t.tfm = crypto_cipher_tfm(ctx->child),\n\t\t.fn = fn\n\t};\n\tu8 *wsrc;\n\tu8 *wdst;\n\n\terr = blkcipher_walk_virt(d, w);\n\tif (!w->nbytes)\n\t\treturn err;\n\n\ts.t = (be128 *)w->iv;\n\tavail = w->nbytes;\n\n\twsrc = w->src.virt.addr;\n\twdst = w->dst.virt.addr;\n\n\t/* calculate first value of T */\n\ttw(crypto_cipher_tfm(ctx->tweak), w->iv, w->iv);\n\n\tgoto first;\n\n\tfor (;;) {\n\t\tdo {\n\t\t\tgf128mul_x_ble(s.t, s.t);\n\nfirst:\n\t\t\txts_round(&s, wdst, wsrc);\n\n\t\t\twsrc += bs;\n\t\t\twdst += bs;\n\t\t} while ((avail -= bs) >= bs);\n\n\t\terr = blkcipher_walk_done(d, w, avail);\n\t\tif (!w->nbytes)\n\t\t\tbreak;\n\n\t\tavail = w->nbytes;\n\n\t\twsrc = w->src.virt.addr;\n\t\twdst = w->dst.virt.addr;\n\t}\n\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 335
    },
    {
        "index": 45188,
        "code": "static const SSL_METHOD *dtls1_get_server_method(int ver)\n\t{\n\tif (ver == DTLS1_VERSION)\n\t\treturn(DTLSv1_server_method());\n\telse if (ver == DTLS1_2_VERSION)\n\t\treturn(DTLSv1_2_server_method());\n\telse\n\t\treturn(NULL);\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2015-0204",
        "length": 66
    },
    {
        "index": 123853,
        "code": "void RenderViewImpl::EvaluateScript(const string16& frame_xpath,\n                                    const string16& jscript,\n                                    int id,\n                                    bool notify_result) {\n  v8::HandleScope handle_scope;\n  v8::Handle<v8::Value> result;\n  WebFrame* web_frame = GetChildFrame(frame_xpath);\n  if (web_frame)\n    result = web_frame->executeScriptAndReturnValue(WebScriptSource(jscript));\n  if (notify_result) {\n    base::ListValue list;\n    if (!result.IsEmpty() && web_frame) {\n      v8::Local<v8::Context> context = web_frame->mainWorldScriptContext();\n      v8::Context::Scope context_scope(context);\n      V8ValueConverterImpl converter;\n      converter.SetDateAllowed(true);\n      converter.SetRegExpAllowed(true);\n      base::Value* result_value = converter.FromV8Value(result, context);\n      list.Set(0, result_value ? result_value : base::Value::CreateNullValue());\n    } else {\n      list.Set(0, base::Value::CreateNullValue());\n    }\n    Send(new ViewHostMsg_ScriptEvalResponse(routing_id_, id, list));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0918",
        "length": 245
    },
    {
        "index": 137634,
        "code": "void MockDownloadController::StartContextMenuDownload(\n    const content::ContextMenuParams& params,\n    content::WebContents* web_contents,\n    bool is_link, const std::string& extra_headers) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1296",
        "length": 43
    },
    {
        "index": 152938,
        "code": "    Read(media::mojom::VideoCaptureDeviceDescriptorCameraCalibrationDataView\n             data,\n         media::VideoCaptureDeviceDescriptor::CameraCalibration* output) {\n  output->focal_length_x = data.focal_length_x();\n  output->focal_length_y = data.focal_length_y();\n  output->depth_near = data.depth_near();\n  output->depth_far = data.depth_far();\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2016-5214",
        "length": 88
    },
    {
        "index": 184887,
        "code": "GURL GetFileManagerBaseUrl() {\n  return GetFileManagerUrl(\"/\");\n}\n",
        "line": "  return GetFileManagerUrl(\"/\");\n}\n",
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2922",
        "length": 15
    },
    {
        "index": 60039,
        "code": "static ut64 getmainsymbol(ELFOBJ *bin) {\n\tstruct r_bin_elf_symbol_t *symbol;\n\tint i;\n\tif (!(symbol = Elf_(r_bin_elf_get_symbols) (bin))) {\n\t\treturn UT64_MAX;\n\t}\n\tfor (i = 0; !symbol[i].last; i++) {\n\t\tif (!strcmp (symbol[i].name, \"main\")) {\n\t\t\tut64 paddr = symbol[i].offset;\n\t\t\treturn Elf_(r_bin_elf_p2v) (bin, paddr);\n\t\t}\n\t}\n\treturn UT64_MAX;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-16359",
        "length": 125
    },
    {
        "index": 38353,
        "code": "static int cm_create_port_fs(struct cm_port *port)\n{\n\tint i, ret;\n\n\tret = kobject_init_and_add(&port->port_obj, &cm_port_obj_type,\n\t\t\t\t   &port->cm_dev->device->kobj,\n\t\t\t\t   \"%d\", port->port_num);\n\tif (ret) {\n\t\tkfree(port);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < CM_COUNTER_GROUPS; i++) {\n\t\tret = kobject_init_and_add(&port->counter_group[i].obj,\n\t\t\t\t\t   &cm_counter_obj_type,\n\t\t\t\t\t   &port->port_obj,\n\t\t\t\t\t   \"%s\", counter_group_names[i]);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\twhile (i--)\n\t\tkobject_put(&port->counter_group[i].obj);\n\tkobject_put(&port->port_obj);\n\treturn ret;\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2739",
        "length": 177
    },
    {
        "index": 136374,
        "code": "  CompositedLayerRasterInvalidatorTest& Chunk(int type) {\n    DEFINE_STATIC_LOCAL(FakeDisplayItemClient, fake_client, ());\n    fake_client.ClearIsJustCreated();\n    PaintChunk::Id id(fake_client, static_cast<DisplayItem::Type>(\n                                       DisplayItem::kDrawingFirst + type));\n    data_.chunks.emplace_back(0, 0, id, DefaultPropertyTreeState());\n    data_.chunks.back().bounds =\n        FloatRect(type * 110, type * 220, type * 220 + 200, type * 110 + 200);\n    return *this;\n   }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 128
    },
    {
        "index": 150944,
        "code": "const WTF::AtomicString& Bluetooth::InterfaceName() const {\n  return event_type_names::kAdvertisementreceived;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5044",
        "length": 25
    },
    {
        "index": 43998,
        "code": "__xml_private_clean(xml_private_t *p)\n{\n    if(p) {\n        CRM_ASSERT(p->check == XML_PRIVATE_MAGIC);\n\n        free(p->user);\n        p->user = NULL;\n\n        if(p->acls) {\n            g_list_free_full(p->acls, __xml_acl_free);\n            p->acls = NULL;\n        }\n\n        if(p->deleted_paths) {\n            g_list_free_full(p->deleted_paths, free);\n            p->deleted_paths = NULL;\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-1867",
        "length": 107
    },
    {
        "index": 91700,
        "code": "am_file_data_t *am_file_data_copy(apr_pool_t *pool,\n                                  am_file_data_t *src_file_data)\n{\n    am_file_data_t *dst_file_data = NULL;\n\n    if ((dst_file_data = am_file_data_new(pool, src_file_data->path)) == NULL) {\n        return NULL;\n    }\n\n    dst_file_data->path = apr_pstrdup(pool, src_file_data->path);\n    dst_file_data->stat_time = src_file_data->stat_time;\n    dst_file_data->finfo = src_file_data->finfo;\n    dst_file_data->contents = apr_pstrdup(pool, src_file_data->contents);\n    dst_file_data->read_time = src_file_data->read_time;\n    dst_file_data->rv = src_file_data->rv;\n    dst_file_data->strerror = apr_pstrdup(pool, src_file_data->strerror);\n    dst_file_data->generated = src_file_data->generated;\n\n    return dst_file_data;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-601",
        "cve": "CVE-2019-3877",
        "length": 206
    },
    {
        "index": 43931,
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\t(void)a; /* UNUSED */\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)set; /* UNUSED */\n\t(void)clear; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2015-2304",
        "length": 87
    },
    {
        "index": 34553,
        "code": "static int get_slot(struct macvlan_dev *vlan, struct macvtap_queue *q)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_MACVTAP_QUEUES; i++) {\n\t\tif (rcu_dereference(vlan->taps[i]) == q)\n\t\t\treturn i;\n\t}\n\n\t/* Should never happen */\n\tBUG_ON(1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2119",
        "length": 81
    },
    {
        "index": 153180,
        "code": "void Compositor::SetDisplayVSyncParameters(base::TimeTicks timebase,\n                                           base::TimeDelta interval) {\n  static bool is_frame_rate_limit_disabled =\n      base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableFrameRateLimit);\n  if (is_frame_rate_limit_disabled)\n    return;\n\n  if (interval.is_zero()) {\n    interval = viz::BeginFrameArgs::DefaultInterval();\n  }\n  DCHECK_GT(interval.InMillisecondsF(), 0);\n\n  if (vsync_timebase_ == timebase && vsync_interval_ == interval)\n    return;\n\n  vsync_timebase_ = timebase;\n  vsync_interval_ = interval;\n  if (context_factory_private_) {\n    context_factory_private_->SetDisplayVSyncParameters(this, timebase,\n                                                        interval);\n  }\n  vsync_manager_->UpdateVSyncParameters(timebase, interval);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5217",
        "length": 183
    },
    {
        "index": 96214,
        "code": "int sm_looptest_stop(p_fm_config_conx_hdlt hdl, fm_mgr_type_t mgr, int argc, char *argv[]) {\n\tfm_mgr_config_errno_t\tres;\n\tfm_msg_ret_code_t\t\tret_code;\n\tuint8_t data[BUF_SZ];\n\n\tif((res = fm_mgr_simple_query(hdl, FM_ACT_GET, FM_DT_SM_LOOP_TEST_STOP, mgr, BUF_SZ, data, &ret_code)) != FM_CONF_OK)\n\t{\n\t\tfprintf(stderr, \"sm_looptest_stop: Failed to retrieve data: \\n\"\n\t\t       \"\\tError:(%d) %s \\n\\tRet code:(%d) %s\\n\",\n\t\t       res, fm_mgr_get_error_str(res),ret_code,\n\t\t       fm_mgr_get_resp_error_str(ret_code));\n\t} else {\n\t\tprintf(\"Successfully sent Loop Test STOP control to local SM instance\\n\");\n\t\tdata[BUF_SZ-1]=0;\n\t\tprintf(\"%s\", (char*) data);\n    }\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-5232",
        "length": 208
    },
    {
        "index": 37492,
        "code": "int kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tint r;\n\n\tpgprintk(\"%s: looking for gfn %llx\\n\", __func__, gfn);\n\tr = 0;\n\tspin_lock(&kvm->mmu_lock);\n\tfor_each_gfn_indirect_valid_sp(kvm, sp, gfn) {\n\t\tpgprintk(\"%s: gfn %llx role %x\\n\", __func__, gfn,\n\t\t\t sp->role.word);\n\t\tr = 1;\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t}\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 176
    },
    {
        "index": 146523,
        "code": "GLboolean WebGLRenderingContextBase::isEnabled(GLenum cap) {\n  if (isContextLost() || !ValidateCapability(\"isEnabled\", cap))\n    return 0;\n  if (cap == GL_STENCIL_TEST)\n    return stencil_enabled_;\n  return ContextGL()->IsEnabled(cap);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 58
    },
    {
        "index": 135982,
        "code": "void ChromeExtensionWebContentsObserver::ReloadIfTerminated(\n    content::RenderViewHost* render_view_host) {\n  std::string extension_id = GetExtensionId(render_view_host);\n  if (extension_id.empty())\n    return;\n\n  ExtensionRegistry* registry = ExtensionRegistry::Get(browser_context());\n\n  if (registry->GetExtensionById(extension_id, ExtensionRegistry::TERMINATED)) {\n    ExtensionSystem::Get(browser_context())->\n        extension_service()->ReloadExtension(extension_id);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6779",
        "length": 102
    },
    {
        "index": 140953,
        "code": "static bool AllDescendantsAreComplete(Frame* frame) {\n  if (!frame)\n    return true;\n  for (Frame* child = frame->Tree().FirstChild(); child;\n       child = child->Tree().TraverseNext(frame)) {\n    if (child->IsLoading())\n      return false;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 69
    },
    {
        "index": 137378,
        "code": "  bool key_received() const { return key_received_; }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 13
    },
    {
        "index": 37755,
        "code": "static int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3610",
        "length": 35
    },
    {
        "index": 172869,
        "code": "bt_status_t btif_storage_remove_ble_local_keys(void)\n{\n int ret = 1;\n if(btif_config_exist(\"Adapter\", \"LE_LOCAL_KEY_IR\"))\n        ret &= btif_config_remove(\"Adapter\", \"LE_LOCAL_KEY_IR\");\n if(btif_config_exist(\"Adapter\", \"LE_LOCAL_KEY_IRK\"))\n        ret &= btif_config_remove(\"Adapter\", \"LE_LOCAL_KEY_IRK\");\n if(btif_config_exist(\"Adapter\", \"LE_LOCAL_KEY_DHK\"))\n        ret &= btif_config_remove(\"Adapter\", \"LE_LOCAL_KEY_DHK\");\n if(btif_config_exist(\"Adapter\", \"LE_LOCAL_KEY_ER\"))\n        ret &= btif_config_remove(\"Adapter\", \"LE_LOCAL_KEY_ER\");\n    btif_config_save();\n return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-3760",
        "length": 162
    },
    {
        "index": 146649,
        "code": " bool DrawingBuffer::ShouldUseChromiumImage() {\n  return RuntimeEnabledFeatures::WebGLImageChromiumEnabled() &&\n         chromium_image_usage_ == kAllowChromiumImage;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 39
    },
    {
        "index": 98485,
        "code": "HICON AeroPeekWindow::OnGetIcon(UINT index) {\n  if (favicon_bitmap_.isNull()) {\n    if (!frame_icon_) {\n      frame_icon_ = GetAppIcon();\n    }\n    return frame_icon_;\n  }\n\n  favicon_.Set(IconUtil::CreateHICONFromSkBitmap(favicon_bitmap_));\n  return favicon_.Get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 74
    },
    {
        "index": 84300,
        "code": "void DetectSignatureApplyActions(Packet *p,\n        const Signature *s, const uint8_t alert_flags)\n{\n    PACKET_UPDATE_ACTION(p, s->action);\n\n    if (s->action & ACTION_DROP) {\n        if (p->alerts.drop.action == 0) {\n            p->alerts.drop.num = s->num;\n            p->alerts.drop.action = s->action;\n            p->alerts.drop.s = (Signature *)s;\n        }\n    } else if (s->action & ACTION_PASS) {\n        /* if an stream/app-layer match we enforce the pass for the flow */\n        if ((p->flow != NULL) &&\n                (alert_flags & (PACKET_ALERT_FLAG_STATE_MATCH|PACKET_ALERT_FLAG_STREAM_MATCH)))\n        {\n            FlowSetNoPacketInspectionFlag(p->flow);\n        }\n\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-693",
        "cve": "CVE-2018-6794",
        "length": 172
    },
    {
        "index": 128662,
        "code": "  void recordSurroundingText(const std::string& after_text) {\n    after_text_ = after_text;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3200",
        "length": 27
    },
    {
        "index": 126901,
        "code": "void BrowserTabStripController::ExecuteCommandForTab(\n    TabStripModel::ContextMenuCommand command_id,\n    BaseTab* tab) {\n  int model_index = tabstrip_->GetModelIndexOfBaseTab(tab);\n  if (model_->ContainsIndex(model_index))\n    model_->ExecuteContextMenuCommand(model_index, command_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 67
    },
    {
        "index": 113765,
        "code": "void PrintPreviewUI::ClearAllPreviewData() {\n  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 27
    },
    {
        "index": 112404,
        "code": "void Document::clearFullscreenElementStack()\n{\n    m_fullScreenElementStack.clear();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 19
    },
    {
        "index": 170925,
        "code": "status_t OMXNodeInstance::useGraphicBuffer2_l(\n        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,\n        OMX::buffer_id *buffer) {\n if (graphicBuffer == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n    OMX_ERRORTYPE err = OMX_GetParameter(mHandle, OMX_IndexParamPortDefinition, &def);\n if (err != OMX_ErrorNone) {\n        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;\n        CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u\",\n                asString(index), index, portString(portIndex), portIndex);\n return UNKNOWN_ERROR;\n }\n\n BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);\n\n    OMX_BUFFERHEADERTYPE *header = NULL;\n    OMX_U8* bufferHandle = const_cast<OMX_U8*>(\n reinterpret_cast<const OMX_U8*>(graphicBuffer->handle));\n\n    err = OMX_UseBuffer(\n            mHandle,\n &header,\n            portIndex,\n            bufferMeta,\n            def.nBufferSize,\n            bufferHandle);\n\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(useBuffer, err, BUFFER_FMT(portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n delete bufferMeta;\n        bufferMeta = NULL;\n *buffer = 0;\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pBuffer, bufferHandle);\n    CHECK_EQ(header->pAppPrivate, bufferMeta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n    CLOG_BUFFER(useGraphicBuffer2, NEW_BUFFER_FMT(\n *buffer, portIndex, \"%u@%p\", def.nBufferSize, bufferHandle));\n return OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-6720",
        "length": 402
    },
    {
        "index": 4752,
        "code": "user_set_location (AccountsUser          *auser,\n                   GDBusMethodInvocation *context,\n                   const gchar           *location)\n{\n        User *user = (User*)auser;\n        int uid;\n        const gchar *action_id;\n\n        if (!get_caller_uid (context, &uid)) {\n                throw_error (context, ERROR_FAILED, \"identifying caller failed\");\n                return FALSE;\n        }\n\n        if (accounts_user_get_uid (ACCOUNTS_USER (user)) == (uid_t) uid)\n                action_id = \"org.freedesktop.accounts.change-own-user-data\";\n        else\n                action_id = \"org.freedesktop.accounts.user-administration\";\n\n        daemon_local_check_auth (user->daemon,\n                                 user,\n                                 action_id,\n                                 TRUE,\n                                 user_change_location_authorized_cb,\n                                 context,\n                                 g_strdup (location),\n                                 (GDestroyNotify)g_free);\n\n        return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2018-14036",
        "length": 190
    },
    {
        "index": 170823,
        "code": "static ToColorProc ChooseToColorProc(const SkBitmap& src) {\n switch (src.colorType()) {\n case kN32_SkColorType:\n switch (src.alphaType()) {\n case kOpaque_SkAlphaType:\n return ToColor_S32_Opaque;\n case kPremul_SkAlphaType:\n return ToColor_S32_Alpha;\n case kUnpremul_SkAlphaType:\n return ToColor_S32_Raw;\n default:\n return NULL;\n }\n case kARGB_4444_SkColorType:\n switch (src.alphaType()) {\n case kOpaque_SkAlphaType:\n return ToColor_S4444_Opaque;\n case kPremul_SkAlphaType:\n return ToColor_S4444_Alpha;\n case kUnpremul_SkAlphaType:\n return ToColor_S4444_Raw;\n default:\n return NULL;\n }\n case kRGB_565_SkColorType:\n return ToColor_S565;\n case kIndex_8_SkColorType:\n if (src.getColorTable() == NULL) {\n return NULL;\n }\n switch (src.alphaType()) {\n case kOpaque_SkAlphaType:\n return ToColor_SI8_Opaque;\n case kPremul_SkAlphaType:\n return ToColor_SI8_Alpha;\n case kUnpremul_SkAlphaType:\n return ToColor_SI8_Raw;\n default:\n return NULL;\n }\n default:\n break;\n }\n return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2015-1536",
        "length": 288
    },
    {
        "index": 110130,
        "code": "bool ShellWindowViews::IsFullscreen() const {\n  return window_->IsFullscreen();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2012-2889",
        "length": 19
    },
    {
        "index": 71234,
        "code": "static int kvm_reboot(struct notifier_block *notifier, unsigned long val,\n\t\t      void *v)\n{\n\t/*\n\t * Some (well, at least mine) BIOSes hang on reboot if\n\t * in vmx root mode.\n\t *\n\t * And Intel TXT required VMX off for all cpu when system shutdown.\n\t */\n\tpr_info(\"kvm: exiting hardware virtualization\\n\");\n\tkvm_rebooting = true;\n\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n\treturn NOTIFY_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10150",
        "length": 110
    },
    {
        "index": 136604,
        "code": "void DocumentLoader::DidInstallNewDocument(Document* document) {\n  document->SetReadyState(Document::kLoading);\n  if (content_security_policy_) {\n    document->InitContentSecurityPolicy(content_security_policy_.Release());\n  }\n\n  if (history_item_ && IsBackForwardLoadType(load_type_))\n    document->SetStateForNewFormElements(history_item_->GetDocumentState());\n\n  String suborigin_header = response_.HttpHeaderField(HTTPNames::Suborigin);\n  if (!suborigin_header.IsNull()) {\n    Vector<String> messages;\n    Suborigin suborigin;\n    if (ParseSuboriginHeader(suborigin_header, &suborigin, messages))\n      document->EnforceSuborigin(suborigin);\n\n    for (auto& message : messages) {\n      document->AddConsoleMessage(\n          ConsoleMessage::Create(kSecurityMessageSource, kErrorMessageLevel,\n                                 \"Error with Suborigin header: \" + message));\n    }\n  }\n\n  document->GetClientHintsPreferences().UpdateFrom(client_hints_preferences_);\n\n  Settings* settings = document->GetSettings();\n  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());\n  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());\n\n  const AtomicString& dns_prefetch_control =\n      response_.HttpHeaderField(HTTPNames::X_DNS_Prefetch_Control);\n  if (!dns_prefetch_control.IsEmpty())\n    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);\n\n  String header_content_language =\n      response_.HttpHeaderField(HTTPNames::Content_Language);\n  if (!header_content_language.IsEmpty()) {\n    size_t comma_index = header_content_language.find(',');\n    header_content_language.Truncate(comma_index);\n    header_content_language =\n        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);\n    if (!header_content_language.IsEmpty())\n      document->SetContentLanguage(AtomicString(header_content_language));\n  }\n\n  String referrer_policy_header =\n      response_.HttpHeaderField(HTTPNames::Referrer_Policy);\n  if (!referrer_policy_header.IsNull()) {\n    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);\n    document->ParseAndSetReferrerPolicy(referrer_policy_header);\n  }\n\n  GetLocalFrameClient().DidCreateNewDocument();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-6761",
        "length": 462
    },
    {
        "index": 117938,
        "code": "bool ScriptController::canAccessFromCurrentOrigin(Frame *frame)\n{\n    return !v8::Context::InContext() || V8BindingSecurity::canAccessFrame(V8BindingState::Only(), frame, true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3055",
        "length": 47
    },
    {
        "index": 37903,
        "code": "static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3610",
        "length": 24
    },
    {
        "index": 110928,
        "code": "CompositorLock::~CompositorLock() {\n  CancelLock();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 15
    },
    {
        "index": 24297,
        "code": "static int bnep_net_set_mac_addr(struct net_device *dev, void *arg)\n{\n\tBT_DBG(\"%s\", dev->name);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 35
    },
    {
        "index": 83757,
        "code": "static int reuc_cmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcmp(info_a->path, info_b->path);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-8099",
        "length": 54
    },
    {
        "index": 75408,
        "code": "static int opfmul(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xd8;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_QWORD ) {\n\t\t\t\tdata[l++] = 0xdc;\n\t\t\t\tdata[l++] = 0x08 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tdata[l++] = 0xd8;\n\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t} else if ( op->operands[0].type & OT_FPUREG & ~OT_REGALL &&\n\t\t\t    op->operands[1].type & OT_FPUREG & ~OT_REGALL && op->operands[1].reg == 0 ) {\n\t\t\tdata[l++] = 0xdc;\n\t\t\tdata[l++] = 0xc8 | op->operands[0].reg;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-20456",
        "length": 374
    },
    {
        "index": 40466,
        "code": "static void irda_connect_response(struct irda_sock *self)\n{\n\tstruct sk_buff *skb;\n\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\n\tskb = alloc_skb(TTP_MAX_HEADER + TTP_SAR_HEADER, GFP_KERNEL);\n\tif (skb == NULL) {\n\t\tIRDA_DEBUG(0, \"%s() Unable to allocate sk_buff!\\n\",\n\t\t\t   __func__);\n\t\treturn;\n\t}\n\n\t/* Reserve space for MUX_CONTROL and LAP header */\n\tskb_reserve(skb, IRDA_MAX_HEADER);\n\n\tirttp_connect_response(self->tsap, self->max_sdu_size_rx, skb);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-7271",
        "length": 135
    },
    {
        "index": 177375,
        "code": "bool Tags::Tag::ExpandSimpleTagsArray() {\n if (m_simple_tags_size > m_simple_tags_count)\n return true; // nothing else to do\n\n const int size = (m_simple_tags_size == 0) ? 1 : 2 * m_simple_tags_size;\n\n SimpleTag* const displays = new (std::nothrow) SimpleTag[size];\n\n if (displays == NULL)\n return false;\n\n for (int idx = 0; idx < m_simple_tags_count; ++idx) {\n    m_simple_tags[idx].ShallowCopy(displays[idx]);\n }\n\n delete[] m_simple_tags;\n  m_simple_tags = displays;\n\n  m_simple_tags_size = size;\n return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-2464",
        "length": 142
    },
    {
        "index": 103550,
        "code": "ExtensionService::ExtensionRuntimeData::~ExtensionRuntimeData() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2859",
        "length": 14
    },
    {
        "index": 100306,
        "code": "  virtual void UpdateSystemInfo() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 9
    },
    {
        "index": 167229,
        "code": "int ConfirmInfoBar::ContentMinimumWidth() const {\n  return label_->GetMinimumSize().width() + link_->GetMinimumSize().width() +\n      NonLabelWidth();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-6178",
        "length": 38
    },
    {
        "index": 46158,
        "code": "struct file *dentry_open(const struct path *path, int flags,\n\t\t\t const struct cred *cred)\n{\n\tint error;\n\tstruct file *f;\n\n\tvalidate_creds(cred);\n\n\t/* We must always pass in a valid mount pointer. */\n\tBUG_ON(!path->mnt);\n\n\tf = get_empty_filp();\n\tif (!IS_ERR(f)) {\n\t\tf->f_flags = flags;\n\t\tf->f_path = *path;\n\t\terror = do_dentry_open(f, NULL, cred);\n\t\tif (!error) {\n\t\t\t/* from now on we need fput() to dispose of f */\n\t\t\terror = open_check_o_direct(f);\n\t\t\tif (error) {\n\t\t\t\tfput(f);\n\t\t\t\tf = ERR_PTR(error);\n\t\t\t}\n\t\t} else { \n\t\t\tput_filp(f);\n\t\t\tf = ERR_PTR(error);\n\t\t}\n\t}\n\treturn f;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2014-8172",
        "length": 184
    },
    {
        "index": 11392,
        "code": "fbCombineOverReverseC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    int i;\n\n    for (i = 0; i < width; ++i) {\n        CARD32 d = READ(dest + i);\n        CARD32 a = ~d >> 24;\n\n        if (a)\n        {\n            CARD32 s = READ(src + i);\n\t    CARD32 m = READ(mask + i);\n\n\t    fbCombineMaskValueC (&s, &m);\n\n            if (a != 0xff)\n            {\n                FbByteMulAdd(s, a, d);\n            }\n            WRITE(dest + i, s);\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2010-1166",
        "length": 144
    },
    {
        "index": 116675,
        "code": "WebView* RenderViewImpl::createView(\n    WebFrame* creator,\n    const WebURLRequest& request,\n    const WebWindowFeatures& features,\n    const WebString& frame_name,\n    WebNavigationPolicy policy) {\n  if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)\n    return NULL;\n\n  ViewHostMsg_CreateWindow_Params params;\n  params.opener_id = routing_id_;\n  params.user_gesture = creator->isProcessingUserGesture();\n  params.window_container_type = WindowFeaturesToContainerType(features);\n  params.session_storage_namespace_id = session_storage_namespace_id_;\n  params.frame_name = frame_name;\n  params.opener_frame_id = creator->identifier();\n  params.opener_url = creator->document().url();\n  params.opener_security_origin =\n      creator->document().securityOrigin().toString().utf8();\n  params.opener_suppressed = creator->willSuppressOpenerInNewFrame();\n  params.disposition = NavigationPolicyToDisposition(policy);\n  if (!request.isNull())\n    params.target_url = request.url();\n\n  int32 routing_id = MSG_ROUTING_NONE;\n  int32 surface_id = 0;\n  int64 cloned_session_storage_namespace_id;\n\n  RenderThread::Get()->Send(\n      new ViewHostMsg_CreateWindow(params,\n                                   &routing_id,\n                                   &surface_id,\n                                   &cloned_session_storage_namespace_id));\n  if (routing_id == MSG_ROUTING_NONE)\n    return NULL;\n\n  RenderViewImpl* view = RenderViewImpl::Create(\n      0,\n      routing_id_,\n      renderer_preferences_,\n      webkit_preferences_,\n      shared_popup_counter_,\n      routing_id,\n      surface_id,\n      cloned_session_storage_namespace_id,\n      frame_name,\n      1,\n      screen_info_);\n  view->opened_by_user_gesture_ = params.user_gesture;\n\n  view->opener_suppressed_ = params.opener_suppressed;\n\n  GURL creator_url(creator->document().securityOrigin().toString().utf8());\n  if (!creator_url.is_valid() || !creator_url.IsStandard())\n    creator_url = GURL();\n  view->creator_url_ = creator_url;\n\n  view->alternate_error_page_url_ = alternate_error_page_url_;\n\n  return view->webview();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-3084",
        "length": 459
    },
    {
        "index": 136861,
        "code": "HTMLInputElement* HTMLInputElement::CheckedRadioButtonForGroup() {\n  if (checked())\n    return this;\n  if (RadioButtonGroupScope* scope = GetRadioButtonGroupScope())\n    return scope->CheckedButtonForGroup(GetName());\n  return nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 52
    },
    {
        "index": 158415,
        "code": "  bool HasPrimarySurface() const {\n    return GetDelegatedFrameHost()->HasPrimarySurface();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17467",
        "length": 24
    },
    {
        "index": 78905,
        "code": "static int yurex_fasync(int fd, struct file *file, int on)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\treturn fasync_helper(fd, file, on, &dev->async_queue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-16276",
        "length": 52
    },
    {
        "index": 78318,
        "code": "coolkey_v0_get_attribute_count(const u8 *obj, size_t buf_len)\n{\n\tcoolkey_v0_object_header_t *object_head = (coolkey_v0_object_header_t *)obj;\n\tconst u8 *attr;\n\tint count = 0;\n\tsize_t attribute_data_len;\n\n\t/* make sure we have enough of the object to read the record_type */\n\tif (buf_len <= sizeof(coolkey_v0_object_header_t)) {\n\t\treturn 0;\n\t}\n\t/*\n\t * now loop through all the attributes in the list. first find the start of the list\n\t */\n\tattr = coolkey_attribute_start(obj, COOLKEY_V0_OBJECT, buf_len);\n\tif (attr == NULL) {\n\t\treturn 0;\n\t}\n\n\tbuf_len -= (attr-obj);\n\tattribute_data_len = bebytes2ushort(object_head->attribute_data_len);\n\tif (buf_len < attribute_data_len) {\n\t\treturn 0;\n\t}\n\n\twhile (attribute_data_len) {\n\t\tsize_t len = coolkey_v0_get_attribute_record_len(attr, buf_len);\n\n\t\tif (len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/*  This is an error in the token data, don't parse the last attribute */\n\t\tif (len > attribute_data_len) {\n\t\t\tbreak;\n\t\t}\n\t\t/* we know that coolkey_v0_get_attribute_record_len never\n\t\t * \treturns more than buf_len, so we can safely assert that.\n\t\t * \tIf the assert is true, you can easily see that the loop\n\t\t * \twill eventually break with len == 0, even if attribute_data_len\n\t\t * \twas invalid */\n\t\tassert(len <= buf_len);\n\t\tcount++;\n\t\tattr += len;\n\t\tbuf_len -= len;\n\t\tattribute_data_len -= len;\n\t}\n\treturn count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 384
    },
    {
        "index": 33481,
        "code": "static struct inode *shmem_alloc_inode(struct super_block *sb)\n{\n\tstruct shmem_inode_info *info;\n\tinfo = kmem_cache_alloc(shmem_inode_cachep, GFP_KERNEL);\n\tif (!info)\n\t\treturn NULL;\n\treturn &info->vfs_inode;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-1767",
        "length": 56
    },
    {
        "index": 117376,
        "code": "void BookmarkManagerView::SetTableModel(BookmarkTableModel* new_table_model,\n                                        BookmarkNode* parent_node,\n                                        bool is_search) {\n  table_view_->SetModel(NULL);\n  table_view_->SetShowPathColumn(!parent_node);\n  table_view_->SetModel(new_table_model);\n  table_view_->set_parent_node(parent_node);\n  table_model_.reset(new_table_model);\n  if (!is_search || (new_table_model && new_table_model->RowCount() > 0)) {\n    table_view_->SetAltText(std::wstring());\n  } else if (search_tf_->GetText().empty()) {\n    table_view_->SetAltText(\n        l10n_util::GetString(IDS_BOOKMARK_MANAGER_NO_SEARCH_TEXT));\n  } else {\n    table_view_->SetAltText(\n        l10n_util::GetStringF(IDS_BOOKMARK_MANAGER_NO_RESULTS,\n                              search_tf_->GetText()));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3050",
        "length": 187
    },
    {
        "index": 100443,
        "code": "void RenderThread::SendHistograms(int sequence_number) {\n  return histogram_snapshots_->SendHistograms(sequence_number);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 26
    },
    {
        "index": 128499,
        "code": "void ShellSurface::OnSurfaceDestroying(Surface* surface) {\n  if (resizer_)\n    EndDrag(false /* revert */);\n  if (widget_)\n    SetMainSurface(widget_->GetNativeWindow(), nullptr);\n  surface->RemoveSurfaceObserver(this);\n  surface_ = nullptr;\n\n  if (widget_)\n    widget_->Hide();\n\n  if (!surface_destroyed_callback_.is_null())\n    surface_destroyed_callback_.Run();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-3194",
        "length": 90
    },
    {
        "index": 151031,
        "code": "void DevToolsUIBindings::SendPortForwardingStatus(const base::Value& status) {\n  CallClientFunction(\"DevToolsAPI.devicesPortForwardingStatusChanged\", &status,\n                     nullptr, nullptr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-5011",
        "length": 44
    },
    {
        "index": 142487,
        "code": "void ShelfLayoutManager::StopAnimating() {\n  GetLayer(shelf_widget_)->GetAnimator()->StopAnimating();\n  GetLayer(shelf_widget_->status_area_widget())->GetAnimator()->StopAnimating();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 41
    },
    {
        "index": 160572,
        "code": "void RenderFrameImpl::DidAccessInitialDocument() {\n  DCHECK(!frame_->Parent());\n\n  if (!has_accessed_initial_document_) {\n    DocumentState* document_state =\n        DocumentState::FromDocumentLoader(frame_->GetDocumentLoader());\n    NavigationStateImpl* navigation_state =\n        static_cast<NavigationStateImpl*>(document_state->navigation_state());\n\n    if (!navigation_state->request_committed()) {\n      Send(new FrameHostMsg_DidAccessInitialDocument(routing_id_));\n    }\n  }\n\n  has_accessed_initial_document_ = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 112
    },
    {
        "index": 165660,
        "code": "void GetExecutableVersionDetails(const std::wstring& exe_path,\n                                 std::wstring* product_name,\n                                 std::wstring* version,\n                                 std::wstring* special_build,\n                                 std::wstring* channel_name) {\n  assert(product_name);\n  assert(version);\n  assert(special_build);\n  assert(channel_name);\n\n  *product_name = L\"Chrome\";\n  *version = L\"0.0.0.0-devel\";\n  special_build->clear();\n\n  DWORD dummy = 0;\n  DWORD length = ::GetFileVersionInfoSize(exe_path.c_str(), &dummy);\n  if (length) {\n    std::unique_ptr<char[]> data(new char[length]);\n    if (::GetFileVersionInfo(exe_path.c_str(), dummy, length, data.get())) {\n      GetValueFromVersionResource(data.get(), L\"ProductVersion\", version);\n\n      std::wstring official_build;\n      GetValueFromVersionResource(data.get(), L\"Official Build\",\n                                  &official_build);\n      if (official_build != L\"1\")\n        version->append(L\"-devel\");\n      GetValueFromVersionResource(data.get(), L\"ProductShortName\",\n                                  product_name);\n      GetValueFromVersionResource(data.get(), L\"SpecialBuild\", special_build);\n    }\n  }\n  *channel_name = GetChromeChannelName();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2019-5804",
        "length": 267
    },
    {
        "index": 176787,
        "code": "status_t Parcel::writeDoubleVector(const std::unique_ptr<std::vector<double>>& val)\n{\n return writeNullableTypedVector(val, &Parcel::writeDouble);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3861",
        "length": 35
    },
    {
        "index": 146519,
        "code": "long long WebGLRenderingContextBase::getVertexAttribOffset(GLuint index,\n                                                           GLenum pname) {\n  if (isContextLost())\n    return 0;\n  GLvoid* result = nullptr;\n  ContextGL()->GetVertexAttribPointerv(index, pname, &result);\n  return static_cast<long long>(reinterpret_cast<intptr_t>(result));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 70
    },
    {
        "index": 38554,
        "code": "int rdma_notify(struct rdma_cm_id *id, enum ib_event_type event)\n{\n\tstruct rdma_id_private *id_priv;\n\tint ret;\n\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tif (!id_priv->cm_id.ib)\n\t\treturn -EINVAL;\n\n\tswitch (id->device->node_type) {\n\tcase RDMA_NODE_IB_CA:\n\t\tret = ib_cm_notify(id_priv->cm_id.ib, event);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2739",
        "length": 113
    },
    {
        "index": 58755,
        "code": "static int tty_fasync(int fd, struct file *filp, int on)\n{\n\tint retval;\n\ttty_lock();\n\tretval = __tty_fasync(fd, filp, on);\n\ttty_unlock();\n\treturn retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-5321",
        "length": 47
    },
    {
        "index": 27535,
        "code": "static void do_inotify_remove_from_idr(struct fsnotify_group *group,\n\t\t\t\t       struct inotify_inode_mark *i_mark)\n{\n\tstruct idr *idr = &group->inotify_data.idr;\n\tspinlock_t *idr_lock = &group->inotify_data.idr_lock;\n\tint wd = i_mark->wd;\n\n\tassert_spin_locked(idr_lock);\n\n\tidr_remove(idr, wd);\n\n\t/* removed from the idr, drop that ref */\n\tfsnotify_put_mark(&i_mark->fsn_mark);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-1479",
        "length": 110
    },
    {
        "index": 132397,
        "code": "void ReportCustomFlags(const std::string& uma_histogram_hame,\n                       const std::set<std::string>& command_line_difference) {\n  for (const std::string& flag : command_line_difference) {\n    int uma_id = about_flags::testing::kBadSwitchFormatHistogramId;\n    if (StartsWithASCII(flag, \"--\", true /* case_sensitive */)) {\n      std::string switch_name(flag.substr(2));\n\n      const size_t value_pos = switch_name.find('=');\n      if (value_pos != std::string::npos)\n        switch_name.resize(value_pos);\n\n      uma_id = GetSwitchUMAId(switch_name);\n    } else {\n      NOTREACHED() << \"ReportCustomFlags(): flag '\" << flag\n                   << \"' has incorrect format.\";\n    }\n    DVLOG(1) << \"ReportCustomFlags(): histogram='\" << uma_histogram_hame\n             << \"' '\" << flag << \"', uma_id=\" << uma_id;\n\n    UMA_HISTOGRAM_SPARSE_SLOWLY(uma_histogram_hame, uma_id);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 221
    },
    {
        "index": 104451,
        "code": "GLvoid StubGLGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length,\n                               char* infolog) {\n  glGetProgramInfoLog(program, bufsize, length, infolog);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-2829",
        "length": 42
    },
    {
        "index": 143308,
        "code": " Frame::Frame(FrameClient* client, FrameHost* host, FrameOwner* owner)\n     : m_treeNode(this)\n     , m_host(host)\n    , m_owner(owner)\n    , m_client(client)\n    , m_isLoading(false)\n{\n    InstanceCounters::incrementCounter(InstanceCounters::FrameCounter);\n\n    ASSERT(page());\n\n    if (m_owner)\n        m_owner->setContentFrame(*this);\n    else\n        page()->setMainFrame(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 97
    },
    {
        "index": 141255,
        "code": "static Element* SkipDisplayNoneAncestors(Element* element) {\n  for (; element; element = FlatTreeTraversal::ParentElement(*element)) {\n    if (element->GetLayoutObject() || element->HasDisplayContentsStyle())\n      return element;\n  }\n  return nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 60
    },
    {
        "index": 21075,
        "code": "struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,\n\t\t\t\t   struct mem_cgroup *prev,\n\t\t\t\t   struct mem_cgroup_reclaim_cookie *reclaim)\n{\n\tstruct mem_cgroup *memcg = NULL;\n\tint id = 0;\n\n\tif (mem_cgroup_disabled())\n\t\treturn NULL;\n\n\tif (!root)\n\t\troot = root_mem_cgroup;\n\n\tif (prev && !reclaim)\n\t\tid = css_id(&prev->css);\n\n\tif (prev && prev != root)\n\t\tcss_put(&prev->css);\n\n\tif (!root->use_hierarchy && root != root_mem_cgroup) {\n\t\tif (prev)\n\t\t\treturn NULL;\n\t\treturn root;\n\t}\n\n\twhile (!memcg) {\n\t\tstruct mem_cgroup_reclaim_iter *uninitialized_var(iter);\n\t\tstruct cgroup_subsys_state *css;\n\n\t\tif (reclaim) {\n\t\t\tint nid = zone_to_nid(reclaim->zone);\n\t\t\tint zid = zone_idx(reclaim->zone);\n\t\t\tstruct mem_cgroup_per_zone *mz;\n\n\t\t\tmz = mem_cgroup_zoneinfo(root, nid, zid);\n\t\t\titer = &mz->reclaim_iter[reclaim->priority];\n\t\t\tif (prev && reclaim->generation != iter->generation)\n\t\t\t\treturn NULL;\n\t\t\tid = iter->position;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tcss = css_get_next(&mem_cgroup_subsys, id + 1, &root->css, &id);\n\t\tif (css) {\n\t\t\tif (css == &root->css || css_tryget(css))\n\t\t\t\tmemcg = container_of(css,\n\t\t\t\t\t\t     struct mem_cgroup, css);\n\t\t} else\n\t\t\tid = 0;\n\t\trcu_read_unlock();\n\n\t\tif (reclaim) {\n\t\t\titer->position = id;\n\t\t\tif (!css)\n\t\t\t\titer->generation++;\n\t\t\telse if (!prev && memcg)\n\t\t\t\treclaim->generation = iter->generation;\n\t\t}\n\n\t\tif (prev && !css)\n\t\t\treturn NULL;\n\t}\n\treturn memcg;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-1179",
        "length": 426
    },
    {
        "index": 141376,
        "code": "void Document::write(v8::Isolate* isolate,\n                     const Vector<String>& text,\n                     ExceptionState& exception_state) {\n  if (IsTrustedTypesEnabledForDoc()) {\n    DCHECK(origin_trials::TrustedDOMTypesEnabled(this));\n    exception_state.ThrowTypeError(\n        \"This document can only write `TrustedHTML` objects.\");\n    return;\n  }\n\n  if (!AllowedToUseDynamicMarkUpInsertion(\"write\", exception_state))\n    return;\n\n  StringBuilder builder;\n  for (const String& string : text)\n    builder.Append(string);\n  write(builder.ToString(), EnteredDOMWindow(isolate)->document(),\n        exception_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 133
    },
    {
        "index": 19200,
        "code": "void send_dialbacks(conn_t out)\n{\n  char *rkey;\n  int rkeylen;\n\n  if (out->s2s->dns_bad_timeout > 0) {\n      dnsres_t bad = xhash_get(out->s2s->dns_bad, out->key);\n\n      if (bad != NULL) {\n          log_debug(ZONE, \"removing bad host entry for '%s'\", out->key);\n          xhash_zap(out->s2s->dns_bad, out->key);\n          free(bad->key);\n          free(bad);\n      }\n  }\n\n  if (xhash_iter_first(out->routes)) {\n       log_debug(ZONE, \"sending dialback packets for %s\", out->key);\n       do {\n            xhash_iter_get(out->routes, (const char **) &rkey, &rkeylen, NULL);\n            _out_dialback(out, rkey, rkeylen);\n          } while(xhash_iter_next(out->routes));\n  }\n\n  return;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-3525",
        "length": 214
    },
    {
        "index": 183110,
        "code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n \ttmsize_t wc = cc / bps;\n \ttmsize_t count = cc;\n \tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n \n     if(cc%(bps*stride)!=0)\n     {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n         return 0;\n     }\n \n \tif (!tmp)\n \t\treturn 0;\n \n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}\n",
        "line": "\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9535",
        "length": 344
    },
    {
        "index": 142348,
        "code": "void PasswordAccessoryControllerImpl::OnImageFetched(\n    url::Origin origin,\n    const favicon_base::FaviconRawBitmapResult& bitmap_result) {\n  FaviconRequestData* icon_request = &icons_request_data_[origin];\n\n  favicon_base::FaviconImageResult image_result;\n  if (bitmap_result.is_valid()) {\n    image_result.image = gfx::Image::CreateFrom1xPNGBytes(\n        bitmap_result.bitmap_data->front(), bitmap_result.bitmap_data->size());\n  }\n  icon_request->cached_icon = image_result.image;\n  if (origin == current_origin_) {\n    for (auto& callback : icon_request->pending_requests) {\n      std::move(callback).Run(icon_request->cached_icon);\n    }\n  }\n  icon_request->pending_requests.clear();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 162
    },
    {
        "index": 73757,
        "code": "smb_ofile_getcred(smb_ofile_t *of)\n{\n\treturn (of->f_cr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-6561",
        "length": 24
    },
    {
        "index": 143973,
        "code": "png_get_rgb_to_gray_status (png_structp png_ptr)\n{\n   return (png_byte)(png_ptr? png_ptr->rgb_to_gray_status : 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8126",
        "length": 36
    },
    {
        "index": 12465,
        "code": "int OBJ_add_object(const ASN1_OBJECT *obj)\n\t{\n\tASN1_OBJECT *o;\n\tADDED_OBJ *ao[4]={NULL,NULL,NULL,NULL},*aop;\n\tint i;\n\n\tif (added == NULL)\n\t\tif (!init_added()) return(0);\n\tif ((o=OBJ_dup(obj)) == NULL) goto err;\n\tif (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\n\tif ((o->length != 0) && (obj->data != NULL))\n\t\tif (!(ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\n\tif (o->sn != NULL)\n\t\tif (!(ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\n\tif (o->ln != NULL)\n\t\tif (!(ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\n\n\tfor (i=ADDED_DATA; i<=ADDED_NID; i++)\n\t\t{\n\t\tif (ao[i] != NULL)\n\t\t\t{\n\t\t\tao[i]->type=i;\n\t\t\tao[i]->obj=o;\n\t\t\taop=lh_ADDED_OBJ_insert(added,ao[i]);\n\t\t\t/* memory leak, buit should not normally matter */\n\t\t\tif (aop != NULL)\n\t\t\t\tOPENSSL_free(aop);\n\t\t\t}\n\t\t}\n\to->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\n\t\t\tASN1_OBJECT_FLAG_DYNAMIC_DATA);\n\n\treturn(o->nid);\nerr2:\n\tOBJerr(OBJ_F_OBJ_ADD_OBJECT,ERR_R_MALLOC_FAILURE);\nerr:\n\tfor (i=ADDED_DATA; i<=ADDED_NID; i++)\n\t\tif (ao[i] != NULL) OPENSSL_free(ao[i]);\n\tif (o != NULL) OPENSSL_free(o);\n\treturn(NID_undef);\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2014-3508",
        "length": 415
    },
    {
        "index": 28852,
        "code": "int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_rip_read(vcpu) +\n\t\t\tget_segment_base(vcpu, VCPU_SREG_CS);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tkvm_x86_ops->update_db_bp_intercept(vcpu);\n\n\tr = 0;\n\nout:\n\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-6368",
        "length": 427
    },
    {
        "index": 112504,
        "code": "PassRefPtr<NodeList> Document::nodesFromRect(int centerX, int centerY, unsigned topPadding, unsigned rightPadding, unsigned bottomPadding, unsigned leftPadding, HitTestRequest::HitTestRequestType hitType) const\n{\n    if (!renderer())\n        return 0;\n    Frame* frame = this->frame();\n    if (!frame)\n        return 0;\n    FrameView* frameView = frame->view();\n    if (!frameView)\n        return 0;\n\n    float zoomFactor = frame->pageZoomFactor();\n    LayoutPoint point = roundedLayoutPoint(FloatPoint(centerX * zoomFactor + view()->scrollX(), centerY * zoomFactor + view()->scrollY()));\n\n    HitTestRequest request(hitType);\n\n    if (!request.ignoreClipping() && !frameView->visibleContentRect().intersects(HitTestLocation::rectForPoint(point, topPadding, rightPadding, bottomPadding, leftPadding)))\n        return 0;\n\n    if (!topPadding && !rightPadding && !bottomPadding && !leftPadding) {\n        HitTestResult result(point);\n        return handleZeroPadding(request, result);\n    }\n\n    HitTestResult result(point, topPadding, rightPadding, bottomPadding, leftPadding);\n    renderView()->hitTest(request, result);\n\n    return StaticHashSetNodeList::adopt(result.rectBasedTestResult());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 275
    },
    {
        "index": 87398,
        "code": "static void xen_online_page(struct page *page, unsigned int order)\n{\n\tunsigned long i, size = (1 << order);\n\tunsigned long start_pfn = page_to_pfn(page);\n\tstruct page *p;\n\n\tpr_debug(\"Online %lu pages starting at pfn 0x%lx\\n\", size, start_pfn);\n\tmutex_lock(&balloon_mutex);\n\tfor (i = 0; i < size; i++) {\n\t\tp = pfn_to_page(start_pfn + i);\n\t\t__online_page_set_limits(p);\n\t\t__SetPageOffline(p);\n\t\t__balloon_append(p);\n\t}\n\tmutex_unlock(&balloon_mutex);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2019-17351",
        "length": 137
    },
    {
        "index": 31023,
        "code": "int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, unsigned int group, int echo)\n{\n\tstruct sock *rtnl = net->rtnl;\n\tint err = 0;\n\n\tNETLINK_CB(skb).dst_group = group;\n\tif (echo)\n\t\tatomic_inc(&skb->users);\n\tnetlink_broadcast(rtnl, skb, pid, group, GFP_KERNEL);\n\tif (echo)\n\t\terr = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2635",
        "length": 116
    },
    {
        "index": 107173,
        "code": "int AutoFillManager::GUIDToID(const std::string& guid) {\n  static int last_id = 1;\n\n  if (!guid::IsValidGUID(guid))\n    return 0;\n\n  std::map<std::string, int>::const_iterator iter = guid_id_map_.find(guid);\n  if (iter == guid_id_map_.end()) {\n    guid_id_map_[guid] = last_id;\n    id_guid_map_[last_id] = guid;\n    return last_id++;\n  } else {\n    return iter->second;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-1292",
        "length": 113
    },
    {
        "index": 142494,
        "code": "void ShelfLayoutManager::UpdateGestureDrag(\n    const ui::GestureEvent& gesture_in_screen) {\n  if (ShouldHomeGestureHandleEvent(gesture_in_screen.details().scroll_y())) {\n    HomeLauncherGestureHandler* home_launcher_handler =\n        Shell::Get()->app_list_controller()->home_launcher_gesture_handler();\n    if (home_launcher_handler->OnScrollEvent(\n            gesture_in_screen.location(),\n            gesture_in_screen.details().scroll_y())) {\n      return;\n    }\n  }\n\n  if (gesture_drag_status_ == GESTURE_DRAG_APPLIST_IN_PROGRESS) {\n    if (!shelf_->IsHorizontalAlignment()) {\n      Shell::Get()->app_list_controller()->DismissAppList();\n      launcher_above_shelf_bottom_amount_ = 0.f;\n      gesture_drag_status_ = GESTURE_DRAG_NONE;\n      return;\n    }\n    const gfx::Rect shelf_bounds = GetIdealBounds();\n    Shell::Get()->app_list_controller()->UpdateYPositionAndOpacity(\n        std::min(gesture_in_screen.location().y(), shelf_bounds.y()),\n        GetAppListBackgroundOpacityOnShelfOpacity());\n    launcher_above_shelf_bottom_amount_ =\n        shelf_bounds.bottom() - gesture_in_screen.location().y();\n  } else {\n    gesture_drag_amount_ +=\n        PrimaryAxisValue(gesture_in_screen.details().scroll_y(),\n                         gesture_in_screen.details().scroll_x());\n    LayoutShelf();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 287
    },
    {
        "index": 70593,
        "code": "evdns_base_resume(struct evdns_base *base)\n{\n\tEVDNS_LOCK(base);\n\tevdns_requests_pump_waiting_queue(base);\n\tEVDNS_UNLOCK(base);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10197",
        "length": 39
    },
    {
        "index": 3536,
        "code": "gs_heap_alloc_byte_array(gs_memory_t * mem, uint num_elements, uint elt_size,\n                         client_name_t cname)\n{\n    ulong lsize = (ulong) num_elements * elt_size;\n\n    if (lsize != (uint) lsize)\n        return 0;\n    return gs_heap_alloc_bytes(mem, (uint) lsize, cname);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2015-3228",
        "length": 75
    },
    {
        "index": 54751,
        "code": "static int roland_load_info(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_info *info)\n{\n\tstatic const char *const names[] = { \"High Load\", \"Light Load\" };\n\n\treturn snd_ctl_enum_info(info, 1, 2, names);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-2384",
        "length": 59
    },
    {
        "index": 133538,
        "code": "void WebContentsImpl::CancelModalDialogsForRenderManager() {\n  if (dialog_manager_)\n    dialog_manager_->CancelActiveAndPendingDialogs(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 34
    },
    {
        "index": 164758,
        "code": "ChildProcessLauncherHelper::CreateNamedPlatformChannelOnClientThread() {\n  return base::nullopt;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-664",
        "cve": "CVE-2019-5816",
        "length": 24
    },
    {
        "index": 163231,
        "code": "  void ResumeNavigation() { Resume(); }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-15420",
        "length": 10
    },
    {
        "index": 183560,
        "code": " void WebPluginDelegateStub::OnHandleURLRequestReply(\n    const PluginMsg_URLRequestReply_Params& params) {\n   WebPluginResourceClient* resource_client =\n      delegate_->CreateResourceClient(params.resource_id, params.url,\n                                      params.notify_needed,\n                                      params.notify_data,\n                                      params.stream);\n  webplugin_->OnResourceCreated(params.resource_id, resource_client);\n }\n",
        "line": "    const PluginMsg_URLRequestReply_Params& params) {\n      delegate_->CreateResourceClient(params.resource_id, params.url,\n                                      params.notify_needed,\n                                      params.notify_data,\n                                      params.stream);\n  webplugin_->OnResourceCreated(params.resource_id, resource_client);\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 75
    },
    {
        "index": 12244,
        "code": "int ssl_prepare_serverhello_tlsext(SSL *s)\n\t{\n#ifndef OPENSSL_NO_EC\n\t/* If we are server and using an ECC cipher suite, send the point formats we support \n\t * if the client sent us an ECPointsFormat extension.  Note that the server is not\n\t * supposed to send an EllipticCurves extension.\n\t */\n\n\tunsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\tunsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\tint using_ecc = (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA);\n\tusing_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n\t\n\tif (using_ecc)\n\t\t{\n\t\tif (s->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->tlsext_ecpointformatlist);\n\t\tif ((s->tlsext_ecpointformatlist = OPENSSL_malloc(3)) == NULL)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_PREPARE_SERVERHELLO_TLSEXT,ERR_R_MALLOC_FAILURE);\n\t\t\treturn -1;\n\t\t\t}\n\t\ts->tlsext_ecpointformatlist_length = 3;\n\t\ts->tlsext_ecpointformatlist[0] = TLSEXT_ECPOINTFORMAT_uncompressed;\n\t\ts->tlsext_ecpointformatlist[1] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;\n\t\ts->tlsext_ecpointformatlist[2] = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;\n\t\t}\n#endif /* OPENSSL_NO_EC */\n\n\treturn 1;\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3567",
        "length": 381
    },
    {
        "index": 3000,
        "code": "void vga_dirty_log_stop(VGACommonState *s)\n{\n    memory_region_set_log(&s->vram, false, DIRTY_MEMORY_VGA);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2017-13673",
        "length": 35
    },
    {
        "index": 30862,
        "code": "int perf_ftrace_event_register(struct ftrace_event_call *call,\n\t\t\t       enum trace_reg type, void *data)\n{\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\tcase TRACE_REG_UNREGISTER:\n\t\tbreak;\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn perf_ftrace_function_register(data);\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn perf_ftrace_function_unregister(data);\n\tcase TRACE_REG_PERF_ADD:\n\t\tperf_ftrace_function_enable(data);\n\t\treturn 0;\n\tcase TRACE_REG_PERF_DEL:\n\t\tperf_ftrace_function_disable(data);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-2930",
        "length": 146
    },
    {
        "index": 110490,
        "code": "bool GLES2DecoderImpl::DoIsFramebuffer(GLuint client_id) {\n  const FramebufferManager::FramebufferInfo* framebuffer =\n      GetFramebufferInfo(client_id);\n  return framebuffer && framebuffer->IsValid() && !framebuffer->IsDeleted();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2896",
        "length": 51
    },
    {
        "index": 57611,
        "code": "long keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7550",
        "length": 357
    },
    {
        "index": 70695,
        "code": "server_port_read(struct evdns_server_port *s) {\n\tu8 packet[1500];\n\tstruct sockaddr_storage addr;\n\tev_socklen_t addrlen;\n\tint r;\n\tASSERT_LOCKED(s);\n\n\tfor (;;) {\n\t\taddrlen = sizeof(struct sockaddr_storage);\n\t\tr = recvfrom(s->socket, (void*)packet, sizeof(packet), 0,\n\t\t\t\t\t (struct sockaddr*) &addr, &addrlen);\n\t\tif (r < 0) {\n\t\t\tint err = evutil_socket_geterror(s->socket);\n\t\t\tif (EVUTIL_ERR_RW_RETRIABLE(err))\n\t\t\t\treturn;\n\t\t\tlog(EVDNS_LOG_WARN,\n\t\t\t    \"Error %s (%d) while reading request.\",\n\t\t\t    evutil_socket_error_to_string(err), err);\n\t\t\treturn;\n\t\t}\n\t\trequest_parse(packet, r, s, (struct sockaddr*) &addr, addrlen);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10197",
        "length": 181
    },
    {
        "index": 27220,
        "code": "SYSCALL_DEFINE2(osf_settimeofday, struct timeval32 __user *, tv,\n\t\tstruct timezone __user *, tz)\n{\n\tstruct timespec kts;\n\tstruct timezone ktz;\n\n \tif (tv) {\n\t\tif (get_tv32((struct timeval *)&kts, tv))\n\t\t\treturn -EFAULT;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&ktz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tkts.tv_nsec *= 1000;\n\n\treturn do_sys_settimeofday(tv ? &kts : NULL, tz ? &ktz : NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2211",
        "length": 124
    },
    {
        "index": 3968,
        "code": "int FileOutStream::getPos ()\n{\n  return ftell(f);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1790",
        "length": 17
    },
    {
        "index": 18767,
        "code": "static int __net_init dccp_v6_init_net(struct net *net)\n{\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&net->dccp.v6_ctl_sk, PF_INET6,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 71
    },
    {
        "index": 116471,
        "code": "void ProfileImplIOData::Handle::LazyInitialize() const {\n  if (!initialized_) {\n    io_data_->InitializeOnUIThread(profile_);\n    PrefService* pref_service = profile_->GetPrefs();\n    io_data_->http_server_properties_manager_.reset(\n        new chrome_browser_net::HttpServerPropertiesManager(pref_service));\n    ChromeNetworkDelegate::InitializeReferrersEnabled(\n        io_data_->enable_referrers(), pref_service);\n    io_data_->clear_local_state_on_exit()->Init(\n        prefs::kClearSiteDataOnExit, pref_service, NULL);\n    io_data_->clear_local_state_on_exit()->MoveToThread(BrowserThread::IO);\n#if defined(ENABLE_SAFE_BROWSING)\n    io_data_->safe_browsing_enabled()->Init(prefs::kSafeBrowsingEnabled,\n        pref_service, NULL);\n    io_data_->safe_browsing_enabled()->MoveToThread(BrowserThread::IO);\n#endif\n    initialized_ = true;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3083",
        "length": 198
    },
    {
        "index": 11971,
        "code": "int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\n                               void *value)\n{\n    return (add_attribute(&(p7si->auth_attr), nid, atrtype, value));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-311",
        "cve": "CVE-2019-1563",
        "length": 54
    },
    {
        "index": 114393,
        "code": "void GpuCommandBufferStub::OnEnsureBackbuffer() {\n  if (!surface_)\n    return;\n  surface_->SetBufferAllocation(\n      gfx::GLSurface::BUFFER_ALLOCATION_FRONT_AND_BACK);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 43
    },
    {
        "index": 131244,
        "code": "static void cachedAttributeAnyAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::cachedAttributeAnyAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 82
    },
    {
        "index": 124998,
        "code": "static inline LayoutUnit constrainedChildIntrinsicContentLogicalHeight(RenderBox* child)\n{\n    LayoutUnit childIntrinsicContentLogicalHeight = child->intrinsicContentLogicalHeight();\n    return child->constrainLogicalHeightByMinMax(childIntrinsicContentLogicalHeight + child->borderAndPaddingLogicalHeight(), childIntrinsicContentLogicalHeight);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 69
    },
    {
        "index": 11875,
        "code": "static void set_output_verbosity(int level, uchar priority)\n{\n\tint j;\n\n\tif (level > MAX_VERBOSITY)\n\t\tlevel = MAX_VERBOSITY;\n\n\tfor (j = 1; j <= level; j++) {\n\t\tparse_output_words(info_words, info_levels, info_verbosity[j], priority);\n\t\tparse_output_words(debug_words, debug_levels, debug_verbosity[j], priority);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-5764",
        "length": 87
    },
    {
        "index": 125628,
        "code": "void RenderViewHostImpl::JavaScriptDialogClosed(IPC::Message* reply_msg,\n                                                bool success,\n                                                const string16& user_input) {\n  GetProcess()->SetIgnoreInputEvents(false);\n  bool is_waiting =\n      is_waiting_for_beforeunload_ack_ || is_waiting_for_unload_ack_;\n\n  if (is_waiting) {\n    StartHangMonitorTimeout(TimeDelta::FromMilliseconds(\n        success ? kUnloadTimeoutMS : hung_renderer_delay_ms_));\n  }\n\n  ViewHostMsg_RunJavaScriptMessage::WriteReplyParams(reply_msg,\n                                                     success, user_input);\n  Send(reply_msg);\n\n  if (is_waiting && are_javascript_messages_suppressed_)\n    delegate_->RendererUnresponsive(this, is_waiting);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0840",
        "length": 145
    },
    {
        "index": 4569,
        "code": "zend_bool php_openssl_pkey_init_dsa(DSA *dsa, zval *data)\n{\n\tBIGNUM *p, *q, *g, *priv_key, *pub_key;\n\tconst BIGNUM *priv_key_const, *pub_key_const;\n\n\tOPENSSL_PKEY_SET_BN(data, p);\n\tOPENSSL_PKEY_SET_BN(data, q);\n\tOPENSSL_PKEY_SET_BN(data, g);\n\tif (!p || !q || !g || !DSA_set0_pqg(dsa, p, q, g)) {\n\t\treturn 0;\n\t}\n\n\tOPENSSL_PKEY_SET_BN(data, pub_key);\n\tOPENSSL_PKEY_SET_BN(data, priv_key);\n\tif (pub_key) {\n\t\treturn DSA_set0_key(dsa, pub_key, priv_key);\n\t}\n\n\t/* generate key */\n\tPHP_OPENSSL_RAND_ADD_TIME();\n\tif (!DSA_generate_key(dsa)) {\n\t\treturn 0;\n\t}\n\n\t/* if BN_mod_exp return -1, then DSA_generate_key succeed for failed key\n\t * so we need to double check that public key is created */\n\tDSA_get0_key(dsa, &pub_key_const, &priv_key_const);\n\tif (!pub_key_const || BN_is_zero(pub_key_const)) {\n\t\treturn 0;\n\t}\n\t/* all good */\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-754",
        "cve": "CVE-2017-11144",
        "length": 290
    },
    {
        "index": 130526,
        "code": " void DisplayItemList::beginScope()\n{\n    ASSERT_WITH_SECURITY_IMPLICATION(m_nextScope < UINT_MAX);\n    m_scopeStack.append(m_nextScope++);\n    beginSkippingCache();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 37
    },
    {
        "index": 181930,
        "code": "chunk_new_with_alloc_size(size_t alloc)\n{\n  chunk_t *ch;\n  ch = tor_malloc(alloc);\n  ch->next = NULL;\n  ch->datalen = 0;\n#ifdef DEBUG_CHUNK_ALLOC\n  ch->DBG_alloc = alloc;\n#endif\n   ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);\n   total_bytes_allocated_in_chunks += alloc;\n   ch->data = &ch->mem[0];\n   return ch;\n }\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8860",
        "length": 95
    },
    {
        "index": 80835,
        "code": "GF_Err sbgp_dump(GF_Box *a, FILE * trace)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"SampleGroupBox\", trace);\n\n\tif (ptr->grouping_type)\n\t\tfprintf(trace, \"grouping_type=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type) );\n\n\tif (ptr->version==1) {\n\t\tif (isalnum(ptr->grouping_type_parameter&0xFF)) {\n\t\t\tfprintf(trace, \" grouping_type_parameter=\\\"%s\\\"\", gf_4cc_to_str(ptr->grouping_type_parameter) );\n\t\t} else {\n\t\t\tfprintf(trace, \" grouping_type_parameter=\\\"%d\\\"\", ptr->grouping_type_parameter);\n\t\t}\n\t}\n\tfprintf(trace, \">\\n\");\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tfprintf(trace, \"<SampleGroupBoxEntry sample_count=\\\"%d\\\" group_description_index=\\\"%d\\\"/>\\n\", ptr->sample_entries[i].sample_count, ptr->sample_entries[i].group_description_index );\n\t}\n\tif (!ptr->size) {\n\t\tfprintf(trace, \"<SampleGroupBoxEntry sample_count=\\\"\\\" group_description_index=\\\"\\\"/>\\n\");\n\t}\n\tgf_isom_box_dump_done(\"SampleGroupBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 286
    },
    {
        "index": 32395,
        "code": "void mnt_set_mountpoint(struct mount *mnt, struct dentry *dentry,\n\t\t\tstruct mount *child_mnt)\n{\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_MOUNTED;\n\tspin_unlock(&dentry->d_lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-1957",
        "length": 101
    },
    {
        "index": 97374,
        "code": "bool FrameLoader::closeURL()\n{\n    history()->saveDocumentState();\n    \n    Document* currentDocument = m_frame->document();\n    stopLoading(currentDocument && !currentDocument->inPageCache() ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly);\n    \n    m_frame->editor()->clearUndoRedoOperations();\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 77
    },
    {
        "index": 179844,
        "code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n \t\t     gss_buffer_t output_message_buffer)\n {\n \tOM_uint32 ret;\n \tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n \t\t\t    conf_req_flag,\n \t\t\t    qop_req,\n \t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\n\treturn (ret);\n}\n",
        "line": "\t\t\t    context_handle,\n",
        "label": 1,
        "cwe": "CWE-18",
        "cve": "CVE-2015-2695",
        "length": 136
    },
    {
        "index": 63268,
        "code": "int _WM_midi_setup_endoftrack(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_endoftrack;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-11664",
        "length": 123
    },
    {
        "index": 171629,
        "code": "static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,\n const struct audio_config *config)\n{\n    UNUSED(dev);\n    UNUSED(config);\n\n    FNLOG();\n\n return 320;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3839",
        "length": 43
    },
    {
        "index": 143145,
        "code": "    static std::unique_ptr<AutofocusTask> create()\n    {\n        return wrapUnique(new AutofocusTask());\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 28
    },
    {
        "index": 124347,
        "code": "void MessageService::Observe(int type,\n                             const content::NotificationSource& source,\n                             const content::NotificationDetails& details) {\n  switch (type) {\n    case content::NOTIFICATION_RENDERER_PROCESS_TERMINATED:\n    case content::NOTIFICATION_RENDERER_PROCESS_CLOSED: {\n      content::RenderProcessHost* renderer =\n          content::Source<content::RenderProcessHost>(source).ptr();\n      OnProcessClosed(renderer);\n      break;\n    }\n    default:\n      NOTREACHED();\n      return;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0925",
        "length": 106
    },
    {
        "index": 32907,
        "code": "static inline struct inode *dquot_to_inode(struct dquot *dquot)\n{\n\treturn sb_dqopt(dquot->dq_sb)->files[dquot->dq_id.type];\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1848",
        "length": 38
    },
    {
        "index": 3737,
        "code": "_dbus_full_duplex_pipe (int        *fd1,\n                        int        *fd2,\n                        dbus_bool_t blocking,\n                        DBusError  *error)\n{\n#ifdef HAVE_SOCKETPAIR\n  int fds[2];\n  int retval;\n\n#ifdef SOCK_CLOEXEC\n  dbus_bool_t cloexec_done;\n\n  retval = socketpair(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0, fds);\n  cloexec_done = retval >= 0;\n\n  if (retval < 0 && errno == EINVAL)\n#endif\n    {\n      retval = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);\n    }\n\n  if (retval < 0)\n    {\n      dbus_set_error (error, _dbus_error_from_errno (errno),\n                      \"Could not create full-duplex pipe\");\n      return FALSE;\n    }\n\n  _DBUS_ASSERT_ERROR_IS_CLEAR (error);\n\n#ifdef SOCK_CLOEXEC\n  if (!cloexec_done)\n#endif\n    {\n      _dbus_fd_set_close_on_exec (fds[0]);\n      _dbus_fd_set_close_on_exec (fds[1]);\n    }\n\n  if (!blocking &&\n      (!_dbus_set_fd_nonblocking (fds[0], NULL) ||\n       !_dbus_set_fd_nonblocking (fds[1], NULL)))\n    {\n      dbus_set_error (error, _dbus_error_from_errno (errno),\n                      \"Could not set full-duplex pipe nonblocking\");\n\n      _dbus_close (fds[0], NULL);\n      _dbus_close (fds[1], NULL);\n\n      return FALSE;\n    }\n\n  *fd1 = fds[0];\n  *fd2 = fds[1];\n\n  _dbus_verbose (\"full-duplex pipe %d <-> %d\\n\",\n                 *fd1, *fd2);\n\n  return TRUE;\n#else\n  _dbus_warn (\"_dbus_full_duplex_pipe() not implemented on this OS\\n\");\n  dbus_set_error (error, DBUS_ERROR_FAILED,\n                  \"_dbus_full_duplex_pipe() not implemented on this OS\");\n  return FALSE;\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2168",
        "length": 423
    },
    {
        "index": 18880,
        "code": "int inet_csk_listen_start(struct sock *sk, const int nr_table_entries)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint rc = reqsk_queue_alloc(&icsk->icsk_accept_queue, nr_table_entries);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\tsk->sk_max_ack_backlog = 0;\n\tsk->sk_ack_backlog = 0;\n\tinet_csk_delack_init(sk);\n\n\t/* There is race window here: we announce ourselves listening,\n\t * but this transition is still not validated by get_port().\n\t * It is OK, because this socket enters to hash table only\n\t * after validation is complete.\n\t */\n\tsk->sk_state = TCP_LISTEN;\n\tif (!sk->sk_prot->get_port(sk, inet->inet_num)) {\n\t\tinet->inet_sport = htons(inet->inet_num);\n\n\t\tsk_dst_reset(sk);\n\t\tsk->sk_prot->hash(sk);\n\n\t\treturn 0;\n\t}\n\n\tsk->sk_state = TCP_CLOSE;\n\t__reqsk_queue_destroy(&icsk->icsk_accept_queue);\n\treturn -EADDRINUSE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 253
    },
    {
        "index": 99129,
        "code": "void ResourceDispatcherHost::UpdateLoadStates() {\n  LoadInfoMap info_map;\n\n  PendingRequestList::const_iterator i;\n\n  std::map<std::pair<int, int>, uint64> largest_upload_size;\n  for (i = pending_requests_.begin(); i != pending_requests_.end(); ++i) {\n    URLRequest* request = i->second;\n    ResourceDispatcherHostRequestInfo* info = InfoForRequest(request);\n    uint64 upload_size = info->upload_size();\n    if (request->GetLoadState() != net::LOAD_STATE_SENDING_REQUEST)\n      upload_size = 0;\n    std::pair<int, int> key(info->child_id(), info->route_id());\n    if (upload_size && largest_upload_size[key] < upload_size)\n      largest_upload_size[key] = upload_size;\n  }\n\n  for (i = pending_requests_.begin(); i != pending_requests_.end(); ++i) {\n    URLRequest* request = i->second;\n    net::LoadState load_state = request->GetLoadState();\n    ResourceDispatcherHostRequestInfo* info = InfoForRequest(request);\n\n    bool update_upload_progress = MaybeUpdateUploadProgress(info, request);\n\n    if (info->last_load_state() != load_state || update_upload_progress) {\n      std::pair<int, int> key(info->child_id(), info->route_id());\n\n      if (largest_upload_size.find(key) != largest_upload_size.end() &&\n          info->upload_size() < largest_upload_size[key])\n        continue;\n\n      info->set_last_load_state(load_state);\n\n      net::LoadState to_insert;\n      LoadInfoMap::iterator existing = info_map.find(key);\n      if (existing == info_map.end()) {\n        to_insert = load_state;\n      } else {\n        to_insert =\n            MoreInterestingLoadState(existing->second.load_state, load_state);\n        if (to_insert == existing->second.load_state)\n          continue;\n      }\n      LoadInfo& load_info = info_map[key];\n      load_info.url = request->url();\n      load_info.load_state = to_insert;\n      load_info.upload_size = info->upload_size();\n      load_info.upload_position = request->GetUploadProgress();\n    }\n  }\n\n  if (info_map.empty())\n    return;\n\n  LoadInfoUpdateTask* task = new LoadInfoUpdateTask;\n  task->info_map.swap(info_map);\n  ChromeThread::PostTask(ChromeThread::UI, FROM_HERE, task);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 506
    },
    {
        "index": 165640,
        "code": "const wchar_t* GetAppGuid() {\n  return InstallDetails::Get().app_guid();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2019-5804",
        "length": 21
    },
    {
        "index": 9650,
        "code": "static void cwd_globals_dtor(virtual_cwd_globals *cwd_g TSRMLS_DC) /* {{{ */\n{\n\tCWD_STATE_FREE(&cwd_g->cwd);\n\trealpath_cache_clean(TSRMLS_C);\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-6289",
        "length": 45
    },
    {
        "index": 76043,
        "code": "vrrp_track_file_handler(vector_t *strvec)\n{\n\talloc_value_block(alloc_vrrp_track_file, vector_slot(strvec, 0));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2018-19044",
        "length": 35
    },
    {
        "index": 32708,
        "code": "static u32 tg3_read_indirect_reg32(struct tg3 *tp, u32 off)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);\n\tpci_read_config_dword(tp->pdev, TG3PCI_REG_DATA, &val);\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n\treturn val;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "length": 98
    },
    {
        "index": 144029,
        "code": "png_start_read_image(png_structp png_ptr)\n{\n   png_debug(1, \"in png_start_read_image\");\n \n   if (png_ptr == NULL)\n      return;\n   if (!(png_ptr->flags & PNG_FLAG_ROW_INIT))\n      png_read_start_row(png_ptr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8126",
        "length": 59
    },
    {
        "index": 66428,
        "code": "void restore_state_to_opc(CPUX86State *env, TranslationBlock *tb,\n                          target_ulong *data)\n{\n    int cc_op = data[1];\n    env->eip = data[0] - tb->cs_base;\n    if (cc_op != CC_OP_DYNAMIC) {\n        env->cc_op = cc_op;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-94",
        "cve": "CVE-2017-8284",
        "length": 75
    },
    {
        "index": 31041,
        "code": "static int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_BRIDGE_PORT) {\n\t\t\tstruct net_device *br_dev;\n\t\t\tconst struct net_device_ops *ops;\n\n\t\t\tbr_dev = netdev_master_upper_dev_get(dev);\n\t\t\tops = br_dev->netdev_ops;\n\t\t\tif (ops->ndo_fdb_dump)\n\t\t\t\tidx = ops->ndo_fdb_dump(skb, cb, dev, idx);\n\t\t}\n\n\t\tif (dev->netdev_ops->ndo_fdb_dump)\n\t\t\tidx = dev->netdev_ops->ndo_fdb_dump(skb, cb, dev, idx);\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2635",
        "length": 203
    },
    {
        "index": 184782,
        "code": "static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithNonOptionalArgAndOptionalArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1) {\n        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);\n        return v8::Handle<v8::Value>();\n    }\n    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));\n    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\n    return v8::Handle<v8::Value>();\n}\n",
        "line": "        return V8Proxy::throwNotEnoughArgumentsError();\n",
        "label": 1,
        "cwe": null,
        "cve": "CVE-2011-3055",
        "length": 199
    },
    {
        "index": 54884,
        "code": "static enum write_one_status write_one(struct sha1file *f,\n\t\t\t\t       struct object_entry *e,\n\t\t\t\t       off_t *offset)\n{\n\tunsigned long size;\n\tint recursing;\n\n\t/*\n\t * we set offset to 1 (which is an impossible value) to mark\n\t * the fact that this object is involved in \"write its base\n\t * first before writing a deltified object\" recursion.\n\t */\n\trecursing = (e->idx.offset == 1);\n\tif (recursing) {\n\t\twarning(\"recursive delta detected for object %s\",\n\t\t\tsha1_to_hex(e->idx.sha1));\n\t\treturn WRITE_ONE_RECURSIVE;\n\t} else if (e->idx.offset || e->preferred_base) {\n\t\t/* offset is non zero if object is written already. */\n\t\treturn WRITE_ONE_SKIP;\n\t}\n\n\t/* if we are deltified, write out base object first. */\n\tif (e->delta) {\n\t\te->idx.offset = 1; /* now recurse */\n\t\tswitch (write_one(f, e->delta, offset)) {\n\t\tcase WRITE_ONE_RECURSIVE:\n\t\t\t/* we cannot depend on this one */\n\t\t\te->delta = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase WRITE_ONE_BREAK:\n\t\t\te->idx.offset = recursing;\n\t\t\treturn WRITE_ONE_BREAK;\n\t\t}\n\t}\n\n\te->idx.offset = *offset;\n\tsize = write_object(f, e, *offset);\n\tif (!size) {\n\t\te->idx.offset = recursing;\n\t\treturn WRITE_ONE_BREAK;\n\t}\n\twritten_list[nr_written++] = &e->idx;\n\n\t/* make sure off_t is sufficiently large not to wrap */\n\tif (signed_add_overflows(*offset, size))\n\t\tdie(\"pack too large for current definition of off_t\");\n\t*offset += size;\n\treturn WRITE_ONE_WRITTEN;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2324",
        "length": 392
    },
    {
        "index": 169886,
        "code": "xsltShutdownExt(xsltExtDataPtr data, xsltStylesheetPtr style,\n                const xmlChar * URI)\n{\n    xsltExtModulePtr module;\n\n    if ((data == NULL) || (style == NULL) || (URI == NULL))\n        return;\n    module = data->extModule;\n    if ((module == NULL) || (module->styleShutdownFunc == NULL))\n        return;\n\n#ifdef WITH_XSLT_DEBUG_EXTENSIONS\n    xsltGenericDebug(xsltGenericDebugContext,\n                     \"Shutting down module : %s\\n\", URI);\n#endif\n    module->styleShutdownFunc(style, URI, data->extData);\n    /*\n    * Don't remove the entry from the hash table here, since\n    * this will produce segfaults - this fixes bug #340624.\n    *\n    * xmlHashRemoveEntry(style->extInfos, URI,\n    *   (xmlHashDeallocator) xsltFreeExtData);\n    */\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 200
    },
    {
        "index": 117807,
        "code": "static void enabledAtRuntimeAttr1AttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.enabledAtRuntimeAttr1._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    int v = toInt32(value);\n    imp->setEnabledAtRuntimeAttr1(v);\n    return;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3055",
        "length": 97
    },
    {
        "index": 56131,
        "code": "static unsigned int perf_poll(struct file *file, poll_table *wait)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct ring_buffer *rb;\n\tunsigned int events = POLLHUP;\n\n\tpoll_wait(file, &event->waitq, wait);\n\n\tif (is_event_hup(event))\n\t\treturn events;\n\n\t/*\n\t * Pin the event->rb by taking event->mmap_mutex; otherwise\n\t * perf_event_set_output() can swizzle our rb and make us miss wakeups.\n\t */\n\tmutex_lock(&event->mmap_mutex);\n\trb = event->rb;\n\tif (rb)\n\t\tevents = atomic_xchg(&rb->poll, 0);\n\tmutex_unlock(&event->mmap_mutex);\n\treturn events;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2015-8963",
        "length": 153
    },
    {
        "index": 58016,
        "code": "static int nft_delrule(struct nft_ctx *ctx, struct nft_rule *rule)\n{\n\tstruct nft_trans *trans;\n\tint err;\n\n\ttrans = nft_trans_rule_add(ctx, NFT_MSG_DELRULE, rule);\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\n\terr = nf_tables_delrule_deactivate(ctx, rule);\n\tif (err < 0) {\n\t\tnft_trans_destroy(trans);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1573",
        "length": 99
    },
    {
        "index": 149044,
        "code": "static void cdateFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  dateFunc(context, 0, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-6991",
        "length": 53
    },
    {
        "index": 53257,
        "code": "static int usbdev_notify(struct notifier_block *self,\n\t\t\t       unsigned long action, void *dev)\n{\n\tswitch (action) {\n\tcase USB_DEVICE_ADD:\n\t\tbreak;\n\tcase USB_DEVICE_REMOVE:\n\t\tusbdev_remove(dev);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-4482",
        "length": 57
    },
    {
        "index": 22054,
        "code": "raptor_free_turtle_writer(raptor_turtle_writer* turtle_writer)\n{\n  if(!turtle_writer)\n    return;\n\n  if(turtle_writer->nstack && turtle_writer->my_nstack)\n    raptor_free_namespaces(turtle_writer->nstack);\n\n  if(turtle_writer->xsd_boolean_uri)\n    raptor_free_uri(turtle_writer->xsd_boolean_uri);\n  if(turtle_writer->xsd_decimal_uri)\n    raptor_free_uri(turtle_writer->xsd_decimal_uri);\n  if(turtle_writer->xsd_double_uri)\n    raptor_free_uri(turtle_writer->xsd_double_uri);\n  if(turtle_writer->xsd_integer_uri)\n    raptor_free_uri(turtle_writer->xsd_integer_uri);\n\n  RAPTOR_FREE(raptor_turtle_writer, turtle_writer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2012-0037",
        "length": 162
    },
    {
        "index": 64655,
        "code": "history_tree_add_child(OnigCaptureTreeNode* parent, OnigCaptureTreeNode* child)\n{\n#define HISTORY_TREE_INIT_ALLOC_SIZE  8\n\n  if (parent->num_childs >= parent->allocated) {\n    int n, i;\n\n    if (IS_NULL(parent->childs)) {\n      n = HISTORY_TREE_INIT_ALLOC_SIZE;\n      parent->childs =\n        (OnigCaptureTreeNode** )xmalloc(sizeof(OnigCaptureTreeNode*) * n);\n    }\n    else {\n      n = parent->allocated * 2;\n      parent->childs =\n        (OnigCaptureTreeNode** )xrealloc(parent->childs,\n                                         sizeof(OnigCaptureTreeNode*) * n);\n    }\n    CHECK_NULL_RETURN_MEMERR(parent->childs);\n    for (i = parent->allocated; i < n; i++) {\n      parent->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    parent->allocated = n;\n  }\n\n  parent->childs[parent->num_childs] = child;\n  parent->num_childs++;\n  return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-9229",
        "length": 221
    },
    {
        "index": 91916,
        "code": "f_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct usb_composite_dev *cdev = midi->func.config->cdev;\n\tint status = req->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t /* normal completion */\n\t\tif (ep == midi->out_ep) {\n\t\t\t/* We received stuff. req is queued again, below */\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t} else if (ep == midi->in_ep) {\n\t\t\t/* Our transmit completed. See if there's more to go.\n\t\t\t * f_midi_transmit eats req, don't queue it again. */\n\t\t\treq->length = 0;\n\t\t\tf_midi_transmit(midi);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\t/* this endpoint is normally active while we're configured */\n\tcase -ECONNABORTED:\t/* hardware forced ep reset */\n\tcase -ECONNRESET:\t/* request dequeued */\n\tcase -ESHUTDOWN:\t/* disconnect from host */\n\t\tVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\n\t\t\t\treq->actual, req->length);\n\t\tif (ep == midi->out_ep) {\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t\t/* We don't need to free IN requests because it's handled\n\t\t\t * by the midi->in_req_fifo. */\n\t\t\tfree_ep_req(ep, req);\n\t\t}\n\t\treturn;\n\n\tcase -EOVERFLOW:\t/* buffer overrun on read means that\n\t\t\t\t * we didn't provide a big enough buffer.\n\t\t\t\t */\n\tdefault:\n\t\tDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\n\t\t\t\tstatus, req->actual, req->length);\n\t\tbreak;\n\tcase -EREMOTEIO:\t/* short read */\n\t\tbreak;\n\t}\n\n\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (status) {\n\t\tERROR(cdev, \"kill %s:  resubmit %d bytes --> %d\\n\",\n\t\t\t\tep->name, req->length, status);\n\t\tusb_ep_set_halt(ep);\n\t\t/* FIXME recover later ... somehow */\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-20961",
        "length": 476
    },
    {
        "index": 148022,
        "code": "void V8TestObject::VoidMethodArrayBufferArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodArrayBufferArg\");\n\n  test_object_v8_internal::VoidMethodArrayBufferArgMethod(info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 70
    },
    {
        "index": 178111,
        "code": " static void v9fs_walk(void *opaque)\n {\n     int name_idx;\n    V9fsFidState *newfidp = NULL;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return ;\n    }\n     V9fsFidState *newfidp = NULL;\n     V9fsPDU *pdu = opaque;\n     V9fsState *s = pdu->s;\n \n     err = pdu_unmarshal(pdu, offset, \"ddw\", &fid, &newfid, &nwnames);\n     if (err < 0) {\n        for (i = 0; i < nwnames; i++) {\n            err = pdu_unmarshal(pdu, offset, \"s\", &wnames[i]);\n            if (err < 0) {\n                goto out_nofid;\n            }\n            if (name_is_illegal(wnames[i].data)) {\n                err = -ENOENT;\n                goto out_nofid;\n            }\n            offset += err;\n        }\n    } else if (nwnames > P9_MAXWELEM) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    v9fs_path_init(&dpath);\n    v9fs_path_init(&path);\n    /*\n     * Both dpath and path initially poin to fidp.\n     * Needed to handle request with nwnames == 0\n     */\n    v9fs_path_copy(&dpath, &fidp->path);\n         err = -ENOENT;\n         goto out_nofid;\n     }\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-22",
        "cve": "CVE-2016-7116",
        "length": 421
    },
    {
        "index": 38842,
        "code": "circle_contain_pt(PG_FUNCTION_ARGS)\n{\n\tCIRCLE\t   *circle = PG_GETARG_CIRCLE_P(0);\n\tPoint\t   *point = PG_GETARG_POINT_P(1);\n\tdouble\t\td;\n\n\td = point_dt(&circle->center, point);\n\tPG_RETURN_BOOL(d <= circle->radius);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 65
    },
    {
        "index": 8965,
        "code": "void net_tx_pkt_reset(struct NetTxPkt *pkt)\n{\n    int i;\n\n    /* no assert, as reset can be called before tx_pkt_init */\n    if (!pkt) {\n        return;\n    }\n\n    memset(&pkt->virt_hdr, 0, sizeof(pkt->virt_hdr));\n\n    assert(pkt->vec);\n\n    pkt->payload_len = 0;\n    pkt->payload_frags = 0;\n\n    assert(pkt->raw);\n    for (i = 0; i < pkt->raw_frags; i++) {\n        assert(pkt->raw[i].iov_base);\n        pci_dma_unmap(pkt->pci_dev, pkt->raw[i].iov_base, pkt->raw[i].iov_len,\n                      DMA_DIRECTION_TO_DEVICE, 0);\n    }\n    pkt->raw_frags = 0;\n\n    pkt->hdr_len = 0;\n    pkt->l4proto = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-6888",
        "length": 189
    },
    {
        "index": 135163,
        "code": "void Document::cloneDataFromDocument(const Document& other)\n{\n    setCompatibilityMode(other.compatibilityMode());\n    setEncodingData(other.m_encodingData);\n    setContextFeatures(other.contextFeatures());\n    setSecurityOrigin(other.securityOrigin()->isolatedCopy());\n    setMimeType(other.contentType());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6768",
        "length": 59
    },
    {
        "index": 103120,
        "code": "void Browser::GoBack(WindowOpenDisposition disposition) {\n  UserMetrics::RecordAction(UserMetricsAction(\"Back\"), profile_);\n\n  TabContentsWrapper* current_tab = GetSelectedTabContentsWrapper();\n  if (current_tab->controller().CanGoBack()) {\n    TabContents* new_tab = GetOrCloneTabForDisposition(disposition);\n    if (current_tab->tab_contents()->showing_interstitial_page() &&\n        (new_tab != current_tab->tab_contents()))\n      return;\n    new_tab->controller().GoBack();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2840",
        "length": 111
    },
    {
        "index": 70079,
        "code": "void version(void) {\n    printf(\"Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\\n\",\n        REDIS_VERSION,\n        redisGitSHA1(),\n        atoi(redisGitDirty()) > 0,\n        ZMALLOC_LIB,\n        sizeof(long) == 4 ? 32 : 64,\n        (unsigned long long) redisBuildId());\n    exit(0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10517",
        "length": 87
    },
    {
        "index": 1014,
        "code": "void GfxCalRGBColorSpace::getCMYK(GfxColor *color, GfxCMYK *cmyk) {\n  GfxRGB rgb;\n  GfxColorComp c, m, y, k;\n\n#ifdef USE_CMS\n  if (XYZ2DisplayTransform != NULL && displayPixelType == PT_CMYK) {\n    double in[gfxColorMaxComps];\n    Guchar out[gfxColorMaxComps];\n    double X, Y, Z;\n    \n    getXYZ(color,&X,&Y,&Z);\n    in[0] = clip01(X);\n    in[1] = clip01(Y);\n    in[2] = clip01(Z);\n    XYZ2DisplayTransform->doTransform(in,out,1);\n    cmyk->c = byteToCol(out[0]);\n    cmyk->m = byteToCol(out[1]);\n    cmyk->y = byteToCol(out[2]);\n    cmyk->k = byteToCol(out[3]);\n    return;\n  }\n#endif\n  getRGB(color, &rgb);\n  c = clip01(gfxColorComp1 - rgb.r);\n  m = clip01(gfxColorComp1 - rgb.g);\n  y = clip01(gfxColorComp1 - rgb.b);\n  k = c;\n  if (m < k) {\n    k = m;\n  }\n  if (y < k) {\n    k = y;\n  }\n  cmyk->c = c - k;\n  cmyk->m = m - k;\n  cmyk->y = y - k;\n  cmyk->k = k;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 347
    },
    {
        "index": 17020,
        "code": "WebContext::BrowserContextDelegate::~BrowserContextDelegate() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1586",
        "length": 13
    },
    {
        "index": 165655,
        "code": "std::wstring GetElevationServiceName() {\n  std::wstring name = GetElevationServiceDisplayName();\n  name.erase(std::remove_if(name.begin(), name.end(), isspace), name.end());\n  return name;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2019-5804",
        "length": 47
    },
    {
        "index": 159492,
        "code": "void Pack<WebGLImageConversion::kDataFormatRGB565,\n          WebGLImageConversion::kAlphaDoPremultiply,\n          uint8_t,\n          uint16_t>(const uint8_t* source,\n                    uint16_t* destination,\n                    unsigned pixels_per_row) {\n  for (unsigned i = 0; i < pixels_per_row; ++i) {\n    float scale_factor = source[3] / 255.0f;\n    uint8_t source_r =\n        static_cast<uint8_t>(static_cast<float>(source[0]) * scale_factor);\n    uint8_t source_g =\n        static_cast<uint8_t>(static_cast<float>(source[1]) * scale_factor);\n    uint8_t source_b =\n        static_cast<uint8_t>(static_cast<float>(source[2]) * scale_factor);\n    *destination = (((source_r & 0xF8) << 8) | ((source_g & 0xFC) << 3) |\n                    ((source_b & 0xF8) >> 3));\n    source += 4;\n    destination += 1;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-6038",
        "length": 230
    },
    {
        "index": 72041,
        "code": "lookup_kiocb(struct kioctx *ctx, struct iocb __user *iocb, u32 key)\n{\n\tstruct aio_kiocb *kiocb;\n\n\tassert_spin_locked(&ctx->ctx_lock);\n\n\tif (key != KIOCB_KEY)\n\t\treturn NULL;\n\n\t/* TODO: use a hash or array, this sucks. */\n\tlist_for_each_entry(kiocb, &ctx->active_reqs, ki_list) {\n\t\tif (kiocb->ki_user_iocb == iocb)\n\t\t\treturn kiocb;\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-10044",
        "length": 121
    },
    {
        "index": 184426,
        "code": " void ChromeMockRenderThread::OnMsgOpenChannelToExtension(\n    int routing_id, const std::string& source_extension_id,\n     const std::string& target_extension_id,\n    const std::string& channel_name, int* port_id) {\n   *port_id = 0;\n }\n",
        "line": "    int routing_id, const std::string& source_extension_id,\n    const std::string& channel_name, int* port_id) {\n",
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2012-2891",
        "length": 62
    },
    {
        "index": 14728,
        "code": "PHP_FUNCTION(pg_free_result)\n{\n\tzval *result;\n\tpgsql_result_handle *pg_result;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &result) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, &result, -1, \"PostgreSQL result\", le_result);\n\tif (Z_LVAL_P(result) == 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzend_list_delete(Z_RESVAL_P(result));\n\tRETURN_TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-4644",
        "length": 109
    },
    {
        "index": 70143,
        "code": "TIFFReadDirEntryCheckRangeLong8Slong8(int64 value)\n{\n\tif (value < 0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10270",
        "length": 48
    },
    {
        "index": 67154,
        "code": "static void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-7645",
        "length": 98
    },
    {
        "index": 136815,
        "code": "void LocalDOMWindow::moveTo(int x, int y) const {\n  if (!GetFrame() || !GetFrame()->IsMainFrame())\n    return;\n\n  Page* page = GetFrame()->GetPage();\n  if (!page)\n    return;\n\n  IntRect window_rect = page->GetChromeClient().RootWindowRect();\n  window_rect.SetLocation(IntPoint(x, y));\n  page->GetChromeClient().SetWindowRectWithAdjustment(window_rect, *GetFrame());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 100
    },
    {
        "index": 180203,
        "code": "SPL_METHOD(SplFileInfo, getPath)\n{\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tchar *path;\n \tint path_len;\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n  \tpath = spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\tRETURN_STRINGL(path, path_len, 1);\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5770",
        "length": 95
    },
    {
        "index": 12734,
        "code": "WORK_STATE ossl_statem_server_post_process_message(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_SR_CLNT_HELLO:\n        return tls_post_process_client_hello(s, wst);\n\n    case TLS_ST_SR_KEY_EXCH:\n        return tls_post_process_client_key_exchange(s, wst);\n\n    case TLS_ST_SR_CERT_VRFY:\n#ifndef OPENSSL_NO_SCTP\n        if (                    /* Is this SCTP? */\n               BIO_dgram_is_sctp(SSL_get_wbio(s))\n               /* Are we renegotiating? */\n               && s->renegotiate && BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {\n            s->s3->in_read_app_data = 2;\n            s->rwstate = SSL_READING;\n            BIO_clear_retry_flags(SSL_get_rbio(s));\n            BIO_set_retry_read(SSL_get_rbio(s));\n            ossl_statem_set_sctp_read_sock(s, 1);\n            return WORK_MORE_A;\n        } else {\n            ossl_statem_set_sctp_read_sock(s, 0);\n        }\n#endif\n        return WORK_FINISHED_CONTINUE;\n\n    default:\n        break;\n    }\n\n    /* Shouldn't happen */\n    return WORK_ERROR;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-2179",
        "length": 283
    },
    {
        "index": 185157,
        "code": "void SimplifyMarkupCommand::doApply()\n{\n    Node* rootNode = m_firstNode->parentNode();\n    Vector<RefPtr<Node> > nodesToRemove;\n\n    for (Node* node = m_firstNode.get(); node && node != m_nodeAfterLast; node = NodeTraversal::next(*node)) {\n        if (node->firstChild() || (node->isTextNode() && node->nextSibling()))\n            continue;\n\n        Node* startingNode = node->parentNode();\n        if (!startingNode)\n            continue;\n        RenderStyle* startingStyle = startingNode->renderStyle();\n        if (!startingStyle)\n            continue;\n        Node* currentNode = startingNode;\n        Node* topNodeWithStartingStyle = 0;\n        while (currentNode != rootNode) {\n            if (currentNode->parentNode() != rootNode && isRemovableBlock(currentNode))\n                nodesToRemove.append(currentNode);\n\n            currentNode = currentNode->parentNode();\n            if (!currentNode)\n                break;\n\n            if (!currentNode->renderer() || !currentNode->renderer()->isRenderInline() || toRenderInline(currentNode->renderer())->alwaysCreateLineBoxes())\n                continue;\n\n            if (currentNode->firstChild() != currentNode->lastChild()) {\n                topNodeWithStartingStyle = 0;\n                break;\n             }\n \n             unsigned context;\n            if (currentNode->renderStyle()->visualInvalidationDiff(*startingStyle, context) == StyleDifferenceEqual && !context)\n                 topNodeWithStartingStyle = currentNode;\n \n         }\n        if (topNodeWithStartingStyle) {\n            for (Node* node = startingNode; node != topNodeWithStartingStyle; node = node->parentNode())\n                nodesToRemove.append(node);\n        }\n    }\n\n    for (size_t i = 0; i < nodesToRemove.size(); ++i) {\n        int numPrunedAncestors = pruneSubsequentAncestorsToRemove(nodesToRemove, i);\n        if (numPrunedAncestors < 0)\n            continue;\n        removeNodePreservingChildren(nodesToRemove[i], AssumeContentIsAlwaysEditable);\n        i += numPrunedAncestors;\n    }\n}\n",
        "line": "            if (currentNode->renderStyle()->visualInvalidationDiff(*startingStyle, context) == StyleDifferenceEqual && !context)\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 439
    },
    {
        "index": 186607,
        "code": "bool WebMediaPlayerImpl::DidGetOpaqueResponseFromServiceWorker() const {\n  if (data_source_)\n    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n  return false;\n}\n",
        "line": "  if (data_source_)\n    return data_source_->DidGetOpaqueResponseViaServiceWorker();\n  return false;\n}\n",
        "label": 1,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 40
    },
    {
        "index": 132164,
        "code": "void RenderViewTest::SetFocused(const blink::WebNode& node) {\n  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);\n  impl->focusedNodeChanged(blink::WebNode(), node);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 48
    },
    {
        "index": 93543,
        "code": "static int ip6mr_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t      struct nlattr **tb)\n{\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-18509",
        "length": 35
    },
    {
        "index": 115631,
        "code": "void GraphicsContext::setPlatformFillColor(const Color& color, ColorSpace colorSpace)\n{\n    if (paintingDisabled())\n        return;\n\n    platformContext()->setFillColor(color.rgb());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2011-3927",
        "length": 39
    },
    {
        "index": 16413,
        "code": "CStarter::classadCommand( int, Stream* s )\n{\n\tClassAd ad;\n\tReliSock* rsock = (ReliSock*)s;\n\tint cmd = 0;\n\n\tcmd = getCmdFromReliSock( rsock, &ad, false );\n\n\tswitch( cmd ) {\n\tcase FALSE:\n\t\treturn FALSE;\n\t\tbreak;\n\n\tcase CA_RECONNECT_JOB:\n\t\treturn jic->reconnect( rsock, &ad );\n\t\tbreak;\n\n\tdefault:\n\t\tconst char* tmp = getCommandString(cmd);\n\t\tMyString err_msg = \"Starter does not support command (\";\n\t\terr_msg += tmp;\n\t\terr_msg += ')';\n\t\tsendErrorReply( s, tmp, CA_INVALID_REQUEST, err_msg.Value() );\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-134",
        "cve": "CVE-2011-4930",
        "length": 163
    },
    {
        "index": 97483,
        "code": "void FrameLoader::scheduleCheckLoadComplete()\n{\n    m_shouldCallCheckLoadComplete = true;\n    startCheckCompleteTimer();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 27
    },
    {
        "index": 53479,
        "code": "lzss_offset_for_position(struct lzss *lzss, int64_t pos)\n{\n  return (int)(pos & lzss->mask);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4302",
        "length": 32
    },
    {
        "index": 153624,
        "code": "void GLES2Implementation::DeleteTransformFeedbacksHelper(\n    GLsizei n,\n    const GLuint* transformfeedbacks) {\n  helper_->DeleteTransformFeedbacksImmediate(n, transformfeedbacks);\n  IdAllocator* id_allocator = GetIdAllocator(IdNamespaces::kTransformFeedbacks);\n  for (GLsizei ii = 0; ii < n; ++ii)\n    id_allocator->FreeID(transformfeedbacks[ii]);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 87
    },
    {
        "index": 96571,
        "code": "int mbedtls_ecp_group_copy( mbedtls_ecp_group *dst, const mbedtls_ecp_group *src )\n{\n    return mbedtls_ecp_group_load( dst, src->id );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-16910",
        "length": 39
    },
    {
        "index": 103185,
        "code": "void Browser::SelectNumberedTab(int index) {\n  if (index < tab_count()) {\n    UserMetrics::RecordAction(UserMetricsAction(\"SelectNumberedTab\"),\n                              profile_);\n    tab_handler_->GetTabStripModel()->ActivateTabAt(index, true);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2840",
        "length": 58
    },
    {
        "index": 89491,
        "code": "decompileDEFINELOCAL2(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var;\n\n\tINDENT\n\tvar = pop();\n\tputs(\"var \");\n\tputs(getName(var));\n\tprintln(\";\");\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-12982",
        "length": 56
    },
    {
        "index": 84736,
        "code": "static int loop_lookup(struct loop_device **l, int i)\n{\n\tstruct loop_device *lo;\n\tint ret = -ENODEV;\n\n\tif (i < 0) {\n\t\tint err;\n\n\t\terr = idr_for_each(&loop_index_idr, &find_free_cb, &lo);\n\t\tif (err == 1) {\n\t\t\t*l = lo;\n\t\t\tret = lo->lo_number;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* lookup and return a specific i */\n\tlo = idr_find(&loop_index_idr, i);\n\tif (lo) {\n\t\t*l = lo;\n\t\tret = lo->lo_number;\n\t}\nout:\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-5344",
        "length": 143
    },
    {
        "index": 133870,
        "code": "bool HFSIterator::ReadCatalogFile() {\n  catalog_file_.reset(new HFSForkReadStream(this, volume_header_.catalogFile));\n  catalog_.reset(new HFSBTreeIterator());\n  return catalog_->Init(catalog_file_.get());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6661",
        "length": 53
    },
    {
        "index": 82906,
        "code": "static void free_rsdr_hdr(SCV_RSDS_HEADER* rsds_hdr) {\n\tR_FREE (rsds_hdr->file_name);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-11379",
        "length": 30
    },
    {
        "index": 46415,
        "code": "static int ubifs_bulk_read(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = page->index, last_page_read = ui->last_page_read;\n\tstruct bu_info *bu;\n\tint err = 0, allocated = 0;\n\n\tui->last_page_read = index;\n\tif (!c->bulk_read)\n\t\treturn 0;\n\n\t/*\n\t * Bulk-read is protected by @ui->ui_mutex, but it is an optimization,\n\t * so don't bother if we cannot lock the mutex.\n\t */\n\tif (!mutex_trylock(&ui->ui_mutex))\n\t\treturn 0;\n\n\tif (index != last_page_read + 1) {\n\t\t/* Turn off bulk-read if we stop reading sequentially */\n\t\tui->read_in_a_row = 1;\n\t\tif (ui->bulk_read)\n\t\t\tui->bulk_read = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!ui->bulk_read) {\n\t\tui->read_in_a_row += 1;\n\t\tif (ui->read_in_a_row < 3)\n\t\t\tgoto out_unlock;\n\t\t/* Three reads in a row, so switch on bulk-read */\n\t\tui->bulk_read = 1;\n\t}\n\n\t/*\n\t * If possible, try to use pre-allocated bulk-read information, which\n\t * is protected by @c->bu_mutex.\n\t */\n\tif (mutex_trylock(&c->bu_mutex))\n\t\tbu = &c->bu;\n\telse {\n\t\tbu = kmalloc(sizeof(struct bu_info), GFP_NOFS | __GFP_NOWARN);\n\t\tif (!bu)\n\t\t\tgoto out_unlock;\n\n\t\tbu->buf = NULL;\n\t\tallocated = 1;\n\t}\n\n\tbu->buf_len = c->max_bu_buf_len;\n\tdata_key_init(c, &bu->key, inode->i_ino,\n\t\t      page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT);\n\terr = ubifs_do_bulk_read(c, bu, page);\n\n\tif (!allocated)\n\t\tmutex_unlock(&c->bu_mutex);\n\telse\n\t\tkfree(bu);\n\nout_unlock:\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-7822",
        "length": 476
    },
    {
        "index": 174613,
        "code": "tBTM_SEC_DEV_REC *btm_sec_find_dev_by_sec_state (UINT8 state)\n{\n    tBTM_SEC_DEV_REC *p_dev_rec = &btm_cb.sec_dev_rec[0];\n int i;\n\n for (i = 0; i < BTM_SEC_MAX_DEVICE_RECORDS; i++, p_dev_rec++)\n {\n if ((p_dev_rec->sec_flags & BTM_SEC_IN_USE)\n && (p_dev_rec->sec_state == state))\n return(p_dev_rec);\n }\n return(NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0850",
        "length": 107
    },
    {
        "index": 137828,
        "code": "MediaControlVolumeSliderElement::MediaControlVolumeSliderElement(\n    MediaControls& mediaControls)\n    : MediaControlInputElement(mediaControls, MediaVolumeSlider) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-1271",
        "length": 33
    },
    {
        "index": 40090,
        "code": "static void aio_free_ring(struct kioctx *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ctx->nr_pages; i++) {\n\t\tpr_debug(\"pid(%d) [%d] page->count=%d\\n\", current->pid, i,\n\t\t\t\tpage_count(ctx->ring_pages[i]));\n\t\tput_page(ctx->ring_pages[i]);\n\t}\n\n\tput_aio_ring_file(ctx);\n\n\tif (ctx->ring_pages && ctx->ring_pages != ctx->internal_pages)\n\t\tkfree(ctx->ring_pages);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-7348",
        "length": 110
    },
    {
        "index": 31224,
        "code": "struct crypto_alg *crypto_lookup_aead(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\n\talg = crypto_alg_mod_lookup(name, type, mask);\n\tif (IS_ERR(alg))\n\t\treturn alg;\n\n\tif (alg->cra_type == &crypto_aead_type)\n\t\treturn alg;\n\n\tif (!alg->cra_aead.ivsize)\n\t\treturn alg;\n\n\tcrypto_mod_put(alg);\n\talg = crypto_alg_mod_lookup(name, type | CRYPTO_ALG_TESTED,\n\t\t\t\t    mask & ~CRYPTO_ALG_TESTED);\n\tif (IS_ERR(alg))\n\t\treturn alg;\n\n\tif (alg->cra_type == &crypto_aead_type) {\n\t\tif ((alg->cra_flags ^ type ^ ~mask) & CRYPTO_ALG_TESTED) {\n\t\t\tcrypto_mod_put(alg);\n\t\t\talg = ERR_PTR(-ENOENT);\n\t\t}\n\t\treturn alg;\n\t}\n\n\tBUG_ON(!alg->cra_aead.ivsize);\n\n\treturn ERR_PTR(crypto_nivaead_default(alg, type, mask));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2013-2548",
        "length": 228
    },
    {
        "index": 166773,
        "code": "void LargeObjectPage::RemoveFromHeap() {\n  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-6158",
        "length": 28
    },
    {
        "index": 11503,
        "code": "char *cescape(const char *s) {\n        char *r, *t;\n        const char *f;\n\n        assert(s);\n\n        /* Does C style string escaping. */\n\n        if (!(r = new(char, strlen(s)*4 + 1)))\n                return NULL;\n\n        for (f = s, t = r; *f; f++)\n\n                switch (*f) {\n\n                case '\\a':\n                        *(t++) = '\\\\';\n                        *(t++) = 'a';\n                        break;\n                case '\\b':\n                        *(t++) = '\\\\';\n                        *(t++) = 'b';\n                        break;\n                case '\\f':\n                        *(t++) = '\\\\';\n                        *(t++) = 'f';\n                        break;\n                case '\\n':\n                        *(t++) = '\\\\';\n                        *(t++) = 'n';\n                        break;\n                case '\\r':\n                        *(t++) = '\\\\';\n                        *(t++) = 'r';\n                        break;\n                case '\\t':\n                        *(t++) = '\\\\';\n                        *(t++) = 't';\n                        break;\n                case '\\v':\n                        *(t++) = '\\\\';\n                        *(t++) = 'v';\n                        break;\n                case '\\\\':\n                        *(t++) = '\\\\';\n                        *(t++) = '\\\\';\n                        break;\n                case '\"':\n                        *(t++) = '\\\\';\n                        *(t++) = '\"';\n                        break;\n                case '\\'':\n                        *(t++) = '\\\\';\n                        *(t++) = '\\'';\n                        break;\n\n                default:\n                        /* For special chars we prefer octal over\n                         * hexadecimal encoding, simply because glib's\n                         * g_strescape() does the same */\n                        if ((*f < ' ') || (*f >= 127)) {\n                                *(t++) = '\\\\';\n                                *(t++) = octchar((unsigned char) *f >> 6);\n                                *(t++) = octchar((unsigned char) *f >> 3);\n                                *(t++) = octchar((unsigned char) *f);\n                        } else\n                                *(t++) = *f;\n                        break;\n                }\n\n        *t = 0;\n\n        return r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-1174",
        "length": 439
    },
    {
        "index": 132892,
        "code": "  static void VerifyAllTilesExistAndHavePile(\n      const PictureLayerTiling* tiling,\n      PicturePileImpl* pile) {\n    for (PictureLayerTiling::CoverageIterator iter(\n             tiling,\n             tiling->contents_scale(),\n             gfx::Rect(tiling->tiling_size()));\n         iter;\n         ++iter) {\n      EXPECT_TRUE(*iter);\n      EXPECT_EQ(pile, iter->raster_source());\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 96
    },
    {
        "index": 21460,
        "code": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-1097",
        "length": 22
    },
    {
        "index": 66892,
        "code": "static ssize_t read_iter_zero(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tsize_t written = 0;\n\n\twhile (iov_iter_count(iter)) {\n\t\tsize_t chunk = iov_iter_count(iter), n;\n\n\t\tif (chunk > PAGE_SIZE)\n\t\t\tchunk = PAGE_SIZE;\t/* Just for latency reasons */\n\t\tn = iov_iter_zero(chunk, iter);\n\t\tif (!n && iov_iter_count(iter))\n\t\t\treturn written ? written : -EFAULT;\n\t\twritten += n;\n\t\tif (signal_pending(current))\n\t\t\treturn written ? written : -ERESTARTSYS;\n\t\tcond_resched();\n\t}\n\treturn written;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-7889",
        "length": 137
    },
    {
        "index": 138227,
        "code": "void AXObjectCacheImpl::didHideMenuListPopup(LayoutMenuList* menuList) {\n  AXObject* obj = get(menuList);\n  if (!obj || !obj->isMenuList())\n    return;\n\n  toAXMenuList(obj)->didHidePopup();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 57
    },
    {
        "index": 100013,
        "code": "void WebPluginImpl::didFailLoading(const WebURLError& error) {\n  if (!ignore_response_error_)\n    delegate_->DidManualLoadFail();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 33
    },
    {
        "index": 153515,
        "code": "double GM2TabStyle::GetHoverAnimationValue() const {\n  if (!hover_controller_)\n    return 0.0;\n  return hover_controller_->GetAnimationValue();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-5218",
        "length": 37
    },
    {
        "index": 102609,
        "code": "    BrowserPolicyConnector::GetUserCloudPolicyDataStore() const {\n  return user_data_store_.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2880",
        "length": 24
    },
    {
        "index": 148268,
        "code": "void PrintJobWorker::OnDocumentChanged(PrintedDocument* new_document) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  DCHECK_EQ(page_number_, PageNumber::npos());\n\n  if (page_number_ != PageNumber::npos())\n    return;\n\n  document_ = new_document;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5093",
        "length": 62
    },
    {
        "index": 9201,
        "code": "static bool virtio_extra_state_needed(void *opaque)\n{\n    VirtIODevice *vdev = opaque;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    return k->has_extra_state &&\n        k->has_extra_state(qbus->parent);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-6490",
        "length": 76
    },
    {
        "index": 46744,
        "code": "static int cbc_decrypt(struct blkcipher_desc *desc,\n\t\t       struct scatterlist *dst, struct scatterlist *src,\n\t\t       unsigned int nbytes)\n{\n\tstruct camellia_sparc64_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n\tstruct blkcipher_walk walk;\n\tcbc_crypt_op *op;\n\tconst u64 *key;\n\tint err;\n\n\top = camellia_sparc64_cbc_decrypt_3_grand_rounds;\n\tif (ctx->key_len != 16)\n\t\top = camellia_sparc64_cbc_decrypt_4_grand_rounds;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt(desc, &walk);\n\tdesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\tkey = &ctx->decrypt_key[0];\n\tcamellia_sparc64_load_keys(key, ctx->key_len);\n\twhile ((nbytes = walk.nbytes)) {\n\t\tunsigned int block_len = nbytes & CAMELLIA_BLOCK_MASK;\n\n\t\tif (likely(block_len)) {\n\t\t\tconst u64 *src64;\n\t\t\tu64 *dst64;\n\n\t\t\tsrc64 = (const u64 *)walk.src.virt.addr;\n\t\t\tdst64 = (u64 *) walk.dst.virt.addr;\n\t\t\top(src64, dst64, block_len, key,\n\t\t\t   (u64 *) walk.iv);\n\t\t}\n\t\tnbytes &= CAMELLIA_BLOCK_SIZE - 1;\n\t\terr = blkcipher_walk_done(desc, &walk, nbytes);\n\t}\n\tfprs_write(0);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 337
    },
    {
        "index": 168222,
        "code": "bool IsURLAllowedInIncognito(const GURL& url,\n                             content::BrowserContext* browser_context) {\n  if (url.scheme() == content::kViewSourceScheme) {\n    std::string stripped_spec = url.spec();\n    DCHECK_GT(stripped_spec.size(), strlen(content::kViewSourceScheme));\n    stripped_spec.erase(0, strlen(content::kViewSourceScheme) + 1);\n    GURL stripped_url(stripped_spec);\n    return stripped_url.is_valid() &&\n        IsURLAllowedInIncognito(stripped_url, browser_context);\n  }\n  if (url.scheme() == content::kChromeUIScheme &&\n      (url.host_piece() == chrome::kChromeUIAppLauncherPageHost ||\n       url.host_piece() == chrome::kChromeUISettingsHost ||\n       url.host_piece() == chrome::kChromeUIHelpHost ||\n       url.host_piece() == chrome::kChromeUIHistoryHost ||\n       url.host_piece() == chrome::kChromeUIExtensionsHost ||\n       url.host_piece() == chrome::kChromeUIBookmarksHost ||\n       url.host_piece() == chrome::kChromeUIChromeSigninHost ||\n       url.host_piece() == chrome::kChromeUIUberHost ||\n       url.host_piece() == chrome::kChromeUIThumbnailHost ||\n       url.host_piece() == chrome::kChromeUIThumbnailHost2 ||\n       url.host_piece() == chrome::kChromeUIThumbnailListHost ||\n       url.host_piece() == chrome::kChromeUISuggestionsHost ||\n       url.host_piece() == chrome::kChromeUIDevicesHost)) {\n    return false;\n  }\n\n  if (url.scheme() == chrome::kChromeSearchScheme &&\n      (url.host_piece() == chrome::kChromeUIThumbnailHost ||\n       url.host_piece() == chrome::kChromeUIThumbnailHost2 ||\n       url.host_piece() == chrome::kChromeUIThumbnailListHost ||\n       url.host_piece() == chrome::kChromeUISuggestionsHost)) {\n    return false;\n  }\n\n  GURL rewritten_url = url;\n  bool reverse_on_redirect = false;\n  content::BrowserURLHandler::GetInstance()->RewriteURLIfNecessary(\n      &rewritten_url, browser_context, &reverse_on_redirect);\n\n  return !(rewritten_url.scheme_piece() == content::kChromeUIScheme &&\n           rewritten_url.host_piece() == chrome::kChromeUIUberHost);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-16080",
        "length": 494
    },
    {
        "index": 53635,
        "code": "cdc_ncm_speed_change(struct usbnet *dev,\n\t\t     struct usb_cdc_speed_change *data)\n{\n\tuint32_t rx_speed = le32_to_cpu(data->DLBitRRate);\n\tuint32_t tx_speed = le32_to_cpu(data->ULBitRate);\n\n\t/*\n\t * Currently the USB-NET API does not support reporting the actual\n\t * device speed. Do print it instead.\n\t */\n\tif ((tx_speed > 1000000) && (rx_speed > 1000000)) {\n\t\tnetif_info(dev, link, dev->net,\n\t\t\t   \"%u mbit/s downlink %u mbit/s uplink\\n\",\n\t\t\t   (unsigned int)(rx_speed / 1000000U),\n\t\t\t   (unsigned int)(tx_speed / 1000000U));\n\t} else {\n\t\tnetif_info(dev, link, dev->net,\n\t\t\t   \"%u kbit/s downlink %u kbit/s uplink\\n\",\n\t\t\t   (unsigned int)(rx_speed / 1000U),\n\t\t\t   (unsigned int)(tx_speed / 1000U));\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3951",
        "length": 225
    },
    {
        "index": 14809,
        "code": "ftp_rmdir(ftpbuf_t *ftp, const char *dir)\n{\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tif (!ftp_putcmd(ftp, \"RMD\", dir)) {\n\t\treturn 0;\n\t}\n\tif (!ftp_getresp(ftp) || ftp->resp != 250) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4643",
        "length": 82
    },
    {
        "index": 160600,
        "code": "void RenderFrameImpl::ExitFullscreen() {\n  Send(new FrameHostMsg_ToggleFullscreen(routing_id_, false));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 26
    },
    {
        "index": 83140,
        "code": "mrb_io_close_on_exec_p(mrb_state *mrb, mrb_value self)\n{\n#if defined(F_GETFD) && defined(F_SETFD) && defined(FD_CLOEXEC)\n  struct mrb_io *fptr;\n  int ret;\n\n  fptr = io_get_open_fptr(mrb, self);\n\n  if (fptr->fd2 >= 0) {\n    if ((ret = fcntl(fptr->fd2, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n    if (!(ret & FD_CLOEXEC)) return mrb_false_value();\n  }\n\n  if ((ret = fcntl(fptr->fd, F_GETFD)) == -1) mrb_sys_fail(mrb, \"F_GETFD failed\");\n  if (!(ret & FD_CLOEXEC)) return mrb_false_value();\n  return mrb_true_value();\n\n#else\n  mrb_raise(mrb, E_NOTIMP_ERROR, \"IO#close_on_exec? is not supported on the platform\");\n  return mrb_false_value();\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-10199",
        "length": 218
    },
    {
        "index": 79082,
        "code": "static inline const char *spectre_v2_module_string(void) { return \"\"; }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-15572",
        "length": 18
    },
    {
        "index": 132715,
        "code": "protocol::CursorShapeStub* ChromotingInstance::GetCursorShapeStub() {\n  return &empty_cursor_filter_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 25
    },
    {
        "index": 105027,
        "code": "  FakeURLFetcher(const GURL& url, RequestType request_type, Delegate* d,\n                 const std::string& response_data, bool success)\n    : URLFetcher(url, request_type, d),\n      url_(url),\n      response_data_(response_data),\n      success_(success),\n      ALLOW_THIS_IN_INITIALIZER_LIST(method_factory_(this)) {\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2793",
        "length": 73
    },
    {
        "index": 45289,
        "code": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2014-9710",
        "length": 42
    },
    {
        "index": 23287,
        "code": "static int decode_attr_time_delta(struct xdr_stream *xdr, uint32_t *bitmap,\n\t\t\t\t  struct timespec *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_DELTA - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_DELTA)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_DELTA;\n\t}\n\tdprintk(\"%s: time_delta=%ld %ld\\n\", __func__, (long)time->tv_sec,\n\t\t(long)time->tv_nsec);\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-4131",
        "length": 161
    },
    {
        "index": 69402,
        "code": "static void asymmetric_key_describe(const struct key *key, struct seq_file *m)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *kid = asymmetric_key_id(key);\n\tsize_t n;\n\n\tseq_puts(m, key->description);\n\n\tif (subtype) {\n\t\tseq_puts(m, \": \");\n\t\tsubtype->describe(key, m);\n\n\t\tif (kid) {\n\t\t\tseq_putc(m, ' ');\n\t\t\tn = strlen(kid);\n\t\t\tif (n <= 8)\n\t\t\t\tseq_puts(m, kid);\n\t\t\telse\n\t\t\t\tseq_puts(m, kid + n - 8);\n\t\t}\n\n\t\tseq_puts(m, \" [\");\n\t\t/* put something here to indicate the key's capabilities */\n\t\tseq_putc(m, ']');\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "length": 162
    },
    {
        "index": 132682,
        "code": "void BlinkTestRunner::SetPermission(const std::string& name,\n                                    const std::string& value,\n                                    const GURL& origin,\n                                    const GURL& embedding_origin) {\n  content::PermissionStatus status;\n  if (value == \"granted\")\n    status = PERMISSION_STATUS_GRANTED;\n  else if (value == \"prompt\")\n    status = PERMISSION_STATUS_ASK;\n  else if (value == \"denied\")\n    status = PERMISSION_STATUS_DENIED;\n  else {\n    NOTREACHED();\n    status = PERMISSION_STATUS_DENIED;\n  }\n\n  Send(new LayoutTestHostMsg_SetPermission(\n      routing_id(), name, status, origin, embedding_origin));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 135
    },
    {
        "index": 21417,
        "code": "static int swaps_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq;\n\tint ret;\n\n\tret = seq_open(file, &swaps_op);\n\tif (ret)\n\t\treturn ret;\n\n\tseq = file->private_data;\n\tseq->poll_event = atomic_read(&proc_poll_event);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-1179",
        "length": 68
    },
    {
        "index": 63672,
        "code": "char *strstr_full(const char *data, const char *key)\n{\n        return strstr_full_case(data, key, FALSE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-10966",
        "length": 28
    },
    {
        "index": 17239,
        "code": "  static void Set(ContentMainDelegate* delegate, bool single_process) {\n    ContentClient* content_client = oxide::ContentClient::GetInstance();\n    content_client->browser_ = delegate->CreateContentBrowserClient();\n\n    if (single_process) {\n      content_client->renderer_ = delegate->CreateContentRendererClient();\n      content_client->utility_ = delegate->CreateContentUtilityClient();\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1586",
        "length": 83
    },
    {
        "index": 174247,
        "code": "status_t Camera3Device::prepare(int maxCount, int streamId) {\n    ATRACE_CALL();\n    ALOGV(\"%s: Camera %d: Preparing stream %d\", __FUNCTION__, mId, streamId);\n Mutex::Autolock il(mInterfaceLock);\n Mutex::Autolock l(mLock);\n\n    sp<Camera3StreamInterface> stream;\n ssize_t outputStreamIdx = mOutputStreams.indexOfKey(streamId);\n if (outputStreamIdx == NAME_NOT_FOUND) {\n        CLOGE(\"Stream %d does not exist\", streamId);\n return BAD_VALUE;\n }\n\n    stream = mOutputStreams.editValueAt(outputStreamIdx);\n\n if (stream->isUnpreparable() || stream->hasOutstandingBuffers() ) {\n        CLOGE(\"Stream %d has already been a request target\", streamId);\n return BAD_VALUE;\n }\n\n if (mRequestThread->isStreamPending(stream)) {\n        CLOGE(\"Stream %d is already a target in a pending request\", streamId);\n return BAD_VALUE;\n }\n\n return mPreparerThread->prepare(maxCount, stream);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-2449",
        "length": 225
    },
    {
        "index": 136394,
        "code": "std::unique_ptr<JSONObject> PaintArtifactCompositor::LayersAsJSON(\n    LayerTreeFlags flags) const {\n  ContentLayerClientImpl::LayerAsJSONContext context(flags);\n  std::unique_ptr<JSONArray> layers_json = JSONArray::Create();\n  for (const auto& client : content_layer_clients_) {\n    layers_json->PushObject(client->LayerAsJSON(context));\n  }\n  std::unique_ptr<JSONObject> json = JSONObject::Create();\n  json->SetArray(\"layers\", std::move(layers_json));\n  if (context.transforms_json)\n    json->SetArray(\"transforms\", std::move(context.transforms_json));\n  return json;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 136
    },
    {
        "index": 171141,
        "code": "static bool checkPermission(const char* permissionString) {\n if (getpid() == IPCThreadState::self()->getCallingPid()) return true;\n bool ok = checkCallingPermission(String16(permissionString));\n if (!ok) ALOGE(\"Request requires %s\", permissionString);\n return ok;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-3913",
        "length": 61
    },
    {
        "index": 145925,
        "code": "  void PanelInScreen(aura::Window* panel) {\n    gfx::Rect panel_bounds = panel->GetBoundsInRootWindow();\n    gfx::Point root_point = gfx::Point(panel_bounds.x(), panel_bounds.y());\n    display::Display display =\n        display::Screen::GetScreen()->GetDisplayNearestPoint(root_point);\n\n    gfx::Rect panel_bounds_in_screen = panel->GetBoundsInScreen();\n    gfx::Point screen_bottom_right = gfx::Point(\n        panel_bounds_in_screen.right(), panel_bounds_in_screen.bottom());\n    gfx::Rect display_bounds = display.bounds();\n    EXPECT_TRUE(screen_bottom_right.x() < display_bounds.width() &&\n                screen_bottom_right.y() < display_bounds.height());\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5122",
        "length": 147
    },
    {
        "index": 51087,
        "code": "static int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn common_perm_path(OP_CHOWN, path, AA_MAY_CHOWN);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-6187",
        "length": 41
    },
    {
        "index": 59063,
        "code": "static void gluster_free_server(gluster_server **hosts)\n{\n\tif (!*hosts)\n\t\treturn;\n\tfree((*hosts)->volname);\n\tfree((*hosts)->path);\n\n\tgluster_free_host((*hosts)->server);\n\tfree((*hosts)->server);\n\t(*hosts)->server = NULL;\n\tfree(*hosts);\n\t*hosts = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-1000198",
        "length": 69
    },
    {
        "index": 108411,
        "code": "void ChromeRenderMessageFilter::OnAllowDOMStorage(int render_view_id,\n                                                  const GURL& origin_url,\n                                                  const GURL& top_origin_url,\n                                                  bool local,\n                                                  bool* allowed) {\n  *allowed = cookie_settings_->IsSettingCookieAllowed(origin_url,\n                                                      top_origin_url);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(\n          &TabSpecificContentSettings::DOMStorageAccessed,\n          render_process_id_, render_view_id, origin_url, local, !*allowed));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-5112",
        "length": 112
    },
    {
        "index": 79428,
        "code": "static int mov_write_trkn_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s, int disc)\n{\n    AVDictionaryEntry *t = av_dict_get(s->metadata,\n                                       disc ? \"disc\" : \"track\",\n                                       NULL, 0);\n    int size = 0, track = t ? atoi(t->value) : 0;\n    if (track) {\n        int tracks = 0;\n        char *slash = strchr(t->value, '/');\n        if (slash)\n            tracks = atoi(slash + 1);\n        avio_wb32(pb, 32); /* size */\n        ffio_wfourcc(pb, disc ? \"disk\" : \"trkn\");\n        avio_wb32(pb, 24); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 0);        // 8 bytes empty\n        avio_wb32(pb, 0);\n        avio_wb16(pb, 0);        // empty\n        avio_wb16(pb, track);    // track / disc number\n        avio_wb16(pb, tracks);   // total track / disc number\n        avio_wb16(pb, 0);        // empty\n        size = 32;\n    }\n    return size;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2018-14395",
        "length": 286
    },
    {
        "index": 134410,
        "code": "void TabStrip::RemoveTabFromViewModel(int index) {\n  tabs_closing_map_[index].push_back(tab_at(index));\n  UpdateTabsClosingMap(index + 1, -1);\n  tabs_.Remove(index);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 47
    },
    {
        "index": 57191,
        "code": "int nfs4_proc_get_locations(struct inode *inode,\n\t\t\t    struct nfs4_fs_locations *locations,\n\t\t\t    struct page *page, struct rpc_cred *cred)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tconst struct nfs4_mig_recovery_ops *ops =\n\t\t\t\t\tclp->cl_mvops->mig_recovery_ops;\n\tstruct nfs4_exception exception = { };\n\tint status;\n\n\tdprintk(\"%s: FSID %llx:%llx on \\\"%s\\\"\\n\", __func__,\n\t\t(unsigned long long)server->fsid.major,\n\t\t(unsigned long long)server->fsid.minor,\n\t\tclp->cl_hostname);\n\tnfs_display_fhandle(NFS_FH(inode), __func__);\n\n\tdo {\n\t\tstatus = ops->get_locations(inode, locations, page, cred);\n\t\tif (status != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, status, &exception);\n\t} while (exception.retry);\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8746",
        "length": 215
    },
    {
        "index": 62384,
        "code": "fn_printztn(netdissect_options *ndo,\n         register const u_char *s, register u_int n, register const u_char *ep)\n{\n\tregister u_int bytes;\n\tregister u_char c;\n\n\tbytes = 0;\n\tfor (;;) {\n\t\tif (n == 0 || (ep != NULL && s >= ep)) {\n\t\t\t/*\n\t\t\t * Truncated.  This includes \"no null before we\n\t\t\t * got to the end of the fixed-length buffer\".\n\t\t\t *\n\t\t\t * XXX - BOOTP says \"null-terminated\", which\n\t\t\t * means the maximum length of the string, in\n\t\t\t * bytes, is 1 less than the size of the buffer,\n\t\t\t * as there must always be a terminating null.\n\t\t\t */\n\t\t\tbytes = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tc = *s++;\n\t\tbytes++;\n\t\tn--;\n\t\tif (c == '\\0') {\n\t\t\t/* End of string */\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ISASCII(c)) {\n\t\t\tc = ND_TOASCII(c);\n\t\t\tND_PRINT((ndo, \"M-\"));\n\t\t}\n\t\tif (!ND_ISPRINT(c)) {\n\t\t\tc ^= 0x40;\t/* DEL to ?, others to alpha */\n\t\t\tND_PRINT((ndo, \"^\"));\n\t\t}\n\t\tND_PRINT((ndo, \"%c\", c));\n\t}\n\treturn(bytes);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-13011",
        "length": 287
    },
    {
        "index": 14158,
        "code": "int __glXDisp_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)\n{\n    xGLXDestroyPixmapReq *req = (xGLXDestroyPixmapReq *) pc;\n\n    return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-4818",
        "length": 63
    },
    {
        "index": 62123,
        "code": "static void MagickPNGErrorHandler(png_struct *ping,png_const_charp message)\n{\n  Image\n    *image;\n\n  image=(Image *) png_get_error_ptr(ping);\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  libpng-%s error: %s\", PNG_LIBPNG_VER_STRING,message);\n\n  (void) ThrowMagickException(&image->exception,GetMagickModule(),CoderError,\n    message,\"`%s'\",image->filename);\n\n#if (PNG_LIBPNG_VER < 10500)\n  /* A warning about deprecated use of jmpbuf here is unavoidable if you\n   * are building with libpng-1.4.x and can be ignored.\n   */\n  longjmp(ping->jmpbuf,1);\n#else\n  png_longjmp(ping,1);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-754",
        "cve": "CVE-2017-13142",
        "length": 186
    },
    {
        "index": 157105,
        "code": "  int64_t preload_low() {\n    CHECK(loader());\n    return loader()->preload_low();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 22
    },
    {
        "index": 104307,
        "code": "static std::string FixupHomedir(const std::string& text) {\n  DCHECK(text.length() > 0 && text[0] == '~');\n\n  if (text.length() == 1 || text[1] == '/') {\n    const char* home = getenv(base::env_vars::kHome);\n    if (URLFixerUpper::home_directory_override)\n      home = URLFixerUpper::home_directory_override;\n    if (!home)\n      return text;\n    return home + text.substr(1);\n  }\n\n\n#if defined(OS_MACOSX)\n  static const char kHome[] = \"/Users/\";\n#else\n  static const char kHome[] = \"/home/\";\n#endif\n  return kHome + text.substr(1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2822",
        "length": 154
    },
    {
        "index": 38870,
        "code": "close_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 85
    },
    {
        "index": 59728,
        "code": "static av_always_inline int smk_get_code(BitstreamContext *bc, int *recode,\n                                         int *last)\n{\n    register int *table = recode;\n    int v;\n\n    while(*table & SMK_NODE) {\n        if (bitstream_read_bit(bc))\n            table += (*table) & (~SMK_NODE);\n        table++;\n    }\n    v = *table;\n\n    if(v != recode[last[0]]) {\n        recode[last[2]] = recode[last[1]];\n        recode[last[1]] = recode[last[0]];\n        recode[last[0]] = v;\n    }\n    return v;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-16803",
        "length": 139
    },
    {
        "index": 160407,
        "code": "void LargeObjectPage::takeSnapshot(\n    base::trace_event::MemoryAllocatorDump* pageDump,\n    ThreadState::GCSnapshotInfo& info,\n    HeapSnapshotInfo&) {\n  size_t liveSize = 0;\n  size_t deadSize = 0;\n  size_t liveCount = 0;\n  size_t deadCount = 0;\n  HeapObjectHeader* header = heapObjectHeader();\n  size_t gcInfoIndex = header->gcInfoIndex();\n  size_t payloadSize = header->payloadSize();\n  if (header->isMarked()) {\n    liveCount = 1;\n    liveSize += payloadSize;\n    info.liveCount[gcInfoIndex]++;\n    info.liveSize[gcInfoIndex] += payloadSize;\n  } else {\n    deadCount = 1;\n    deadSize += payloadSize;\n    info.deadCount[gcInfoIndex]++;\n    info.deadSize[gcInfoIndex] += payloadSize;\n  }\n\n  pageDump->AddScalar(\"live_count\", \"objects\", liveCount);\n  pageDump->AddScalar(\"dead_count\", \"objects\", deadCount);\n  pageDump->AddScalar(\"live_size\", \"bytes\", liveSize);\n  pageDump->AddScalar(\"dead_size\", \"bytes\", deadSize);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-6094",
        "length": 263
    },
    {
        "index": 82450,
        "code": "void jsvInit() {\n#ifdef RESIZABLE_JSVARS\n  jsVarsSize = JSVAR_BLOCK_SIZE;\n  jsVarBlocks = malloc(sizeof(JsVar*)); // just 1\n  jsVarBlocks[0] = malloc(sizeof(JsVar) * JSVAR_BLOCK_SIZE);\n#endif\n\n  jsVarFirstEmpty = jsvInitJsVars(1/*first*/, jsVarsSize);\n  jsvSoftInit();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-11596",
        "length": 91
    },
    {
        "index": 121878,
        "code": "ChromeNetLog* IOThread::net_log() {\n  return net_log_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2013-2858",
        "length": 18
    },
    {
        "index": 23957,
        "code": "static int airo_get_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\t__le16 mode;\n\n\treadConfigRid(local, 1);\n\tmode = local->config.powerSaveMode;\n\tif ((vwrq->disabled = (mode == POWERSAVE_CAM)))\n\t\treturn 0;\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenDelay) * 1024;\n\t\tvwrq->flags = IW_POWER_TIMEOUT;\n\t} else {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenInterval) * 1024;\n\t\tvwrq->flags = IW_POWER_PERIOD;\n\t}\n\tif ((local->config.rmode & RXMODE_MASK) == RXMODE_ADDR)\n\t\tvwrq->flags |= IW_POWER_UNICAST_R;\n\telse\n\t\tvwrq->flags |= IW_POWER_ALL_R;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 234
    },
    {
        "index": 175436,
        "code": "static int do_out_standby_l(struct stream_out *out)\n{\n struct audio_device *adev = out->dev;\n int status = 0;\n\n    out->standby = true;\n    out_close_pcm_devices(out);\n    status = stop_output_stream(out);\n\n return status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-0812",
        "length": 59
    },
    {
        "index": 27856,
        "code": "static ssize_t fuse_direct_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file->f_path.dentry->d_inode;\n\tssize_t res;\n\n\tif (is_bad_inode(inode))\n\t\treturn -EIO;\n\n\t/* Don't allow parallel writes to the same file */\n\tmutex_lock(&inode->i_mutex);\n\tres = generic_write_checks(file, ppos, &count, 0);\n\tif (!res) {\n\t\tres = fuse_direct_io(file, buf, count, ppos, 1);\n\t\tif (res > 0)\n\t\t\tfuse_write_update_size(inode, *ppos);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n\n\tfuse_invalidate_attr(inode);\n\n\treturn res;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2010-4650",
        "length": 165
    },
    {
        "index": 160056,
        "code": "scoped_refptr<base::SingleThreadTaskRunner> InternalCacheThread() {\n  return g_internal_cache_thread.Get().task_runner();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6085",
        "length": 28
    },
    {
        "index": 159318,
        "code": "void WebGLRenderingContextBase::TextureUnitState::Trace(\n    blink::Visitor* visitor) {\n  visitor->Trace(texture2d_binding_);\n  visitor->Trace(texture_cube_map_binding_);\n  visitor->Trace(texture3d_binding_);\n  visitor->Trace(texture2d_array_binding_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-6034",
        "length": 58
    },
    {
        "index": 151772,
        "code": "  void DontProceed() { interstitial_page_->DontProceed(); }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5013",
        "length": 16
    },
    {
        "index": 40229,
        "code": "static void l2tp_ip_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tsk_common_release(sk);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-7281",
        "length": 62
    },
    {
        "index": 158759,
        "code": "  void DoTexStorageFormatAndType(const InitState& init,\n                                 GLenum format,\n                                 GLenum adjusted_internal_format) {\n    GLsizei kWidth = 512;\n    GLsizei kHeight = 512;\n    GLsizei kLevels = 5;\n    InitDecoder(init);\n    DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);\n    EXPECT_CALL(\n        *gl_, TexStorage2DEXT(GL_TEXTURE_2D, kLevels, format, kWidth, kHeight))\n        .Times(1)\n        .RetiresOnSaturation();\n    TexStorage2DEXT cmd;\n    cmd.Init(GL_TEXTURE_2D, kLevels, format, kWidth, kHeight);\n    EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n    EXPECT_EQ(GL_NO_ERROR, GetGLError());\n    TextureRef* texture_ref =\n        group().texture_manager()->GetTexture(client_texture_id_);\n    Texture* texture = texture_ref->texture();\n    for (GLsizei ii = 0; ii < kLevels; ++ii) {\n      GLenum type = 0, internal_format = 0;\n      GLsizei level_width = 0, level_height = 0;\n      EXPECT_TRUE(texture->GetLevelType(GL_TEXTURE_2D, static_cast<GLint>(ii),\n                                        &type, &internal_format));\n      EXPECT_EQ(static_cast<GLenum>(adjusted_internal_format), internal_format);\n      EXPECT_EQ(static_cast<GLenum>(GL_UNSIGNED_BYTE), type);\n      EXPECT_TRUE(texture->GetLevelSize(GL_TEXTURE_2D, static_cast<GLint>(ii),\n                                        &level_width, &level_height, nullptr));\n      EXPECT_EQ(kWidth >> ii, level_width);\n      EXPECT_EQ(kHeight >> ii, level_height);\n    }\n    EXPECT_TRUE(texture->texture_complete());\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-17470",
        "length": 371
    },
    {
        "index": 164527,
        "code": "static void clearAllSharedCacheTableLocks(Btree *p){\n  BtShared *pBt = p->pBt;\n  BtLock **ppIter = &pBt->pLock;\n\n  assert( sqlite3BtreeHoldsMutex(p) );\n  assert( p->sharable || 0==*ppIter );\n  assert( p->inTrans>0 );\n\n  while( *ppIter ){\n    BtLock *pLock = *ppIter;\n    assert( (pBt->btsFlags & BTS_EXCLUSIVE)==0 || pBt->pWriter==pLock->pBtree );\n    assert( pLock->pBtree->inTrans>=pLock->eLock );\n    if( pLock->pBtree==p ){\n      *ppIter = pLock->pNext;\n      assert( pLock->iTable!=1 || pLock==&p->lock );\n      if( pLock->iTable!=1 ){\n        sqlite3_free(pLock);\n      }\n    }else{\n      ppIter = &pLock->pNext;\n    }\n  }\n\n  assert( (pBt->btsFlags & BTS_PENDING)==0 || pBt->pWriter );\n  if( pBt->pWriter==p ){\n    pBt->pWriter = 0;\n    pBt->btsFlags &= ~(BTS_EXCLUSIVE|BTS_PENDING);\n  }else if( pBt->nTransaction==2 ){\n    /* This function is called when Btree p is concluding its\n    ** transaction. If there currently exists a writer, and p is not\n    ** that writer, then the number of locks held by connections other\n    ** than the writer must be about to drop to zero. In this case\n    ** set the BTS_PENDING flag to 0.\n    **\n    ** If there is not currently a writer, then BTS_PENDING must\n    ** be zero already. So this next line is harmless in that case.\n    */\n    pBt->btsFlags &= ~BTS_PENDING;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-5827",
        "length": 439
    },
    {
        "index": 179593,
        "code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n \tconst char *msg;\n \tu_int8_t state;\n \n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tBUG_ON(dh == NULL);\n \n \tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\n\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}\n",
        "line": "\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2523",
        "length": 373
    },
    {
        "index": 67615,
        "code": "MODRET set_maxclientsclass(cmd_rec *cmd) {\n  int max;\n  config_rec *c;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[2], \"none\") == 0)\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[2], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"max must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 4) {\n    c = add_config_param(cmd->argv[0], 3, NULL, NULL, NULL);\n    c->argv[0] = pstrdup(c->pool, cmd->argv[1]);\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = max;\n    c->argv[2] = pstrdup(c->pool, cmd->argv[3]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pstrdup(c->pool, cmd->argv[1]);\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = max;\n  }\n\n  return PR_HANDLED(cmd);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2017-7418",
        "length": 321
    },
    {
        "index": 11891,
        "code": "static js_Ast *jsP_newnode(js_State *J, enum js_AstType type, js_Ast *a, js_Ast *b, js_Ast *c, js_Ast *d)\n{\n\tjs_Ast *node = js_malloc(J, sizeof *node);\n\n\tnode->type = type;\n\tnode->line = J->astline;\n\tnode->a = a;\n\tnode->b = b;\n\tnode->c = c;\n\tnode->d = d;\n\tnode->number = 0;\n\tnode->string = NULL;\n\tnode->jumps = NULL;\n\tnode->casejump = 0;\n\n\tnode->parent = NULL;\n\tif (a) a->parent = node;\n\tif (b) b->parent = node;\n\tif (c) c->parent = node;\n\tif (d) d->parent = node;\n\n\tnode->gcnext = J->gcast;\n\tJ->gcast = node;\n\n\treturn node;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-674",
        "cve": "CVE-2018-5759",
        "length": 195
    },
    {
        "index": 111055,
        "code": "void WebPage::addOverlay(WebOverlay* overlay)\n{\n#if USE(ACCELERATED_COMPOSITING)\n    if (overlay->d->graphicsLayer()) {\n        overlay->d->setPage(d);\n        d->overlayLayer()->addChild(overlay->d->graphicsLayer());\n    }\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 63
    },
    {
        "index": 99293,
        "code": "void ResourceMessageFilter::OnFilterAdded(IPC::Channel* channel) {\n  channel_ = channel;\n\n  registrar_.Add(this, NotificationType::BLACKLIST_NONVISUAL_RESOURCE_BLOCKED,\n                 NotificationService::AllSources());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 49
    },
    {
        "index": 123472,
        "code": "void ImageBitmapFactories::ImageBitmapLoader::rejectPromise()\n{\n    v8::Isolate* isolate = m_scriptState->isolate();\n    ScriptScope scope(m_scriptState);\n    m_resolver->reject(ScriptValue(v8::Null(isolate), isolate));\n    m_factory->didFinishLoading(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0890",
        "length": 65
    },
    {
        "index": 51963,
        "code": "SpoolssGetPrinterData_r(tvbuff_t *tvb, int offset,\n\t\t\t\t   packet_info *pinfo, proto_tree *tree,\n\t\t\t\t   dcerpc_info *di, guint8 *drep _U_)\n{\n\tdcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data;\n\tguint32 type;\n\tproto_item *hidden_item;\n\tconst char *data;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_printerdata_type, &type);\n\n\tdata = (const char *)(dcv->se_data ? dcv->se_data : \"????\");\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", data);\n\n\toffset = dissect_printerdata_data(\n\t\ttvb, offset, pinfo, tree, di, drep, type);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_needed, NULL);\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-5350",
        "length": 281
    },
    {
        "index": 159017,
        "code": "void PDFiumEngine::SearchUsingICU(const base::string16& term,\n                                  bool case_sensitive,\n                                  bool first_search,\n                                  int character_to_start_searching_from,\n                                  int current_page) {\n  DCHECK(!term.empty());\n\n  const int original_text_length = pages_[current_page]->GetCharCount();\n  int text_length = original_text_length;\n  if (character_to_start_searching_from) {\n    text_length -= character_to_start_searching_from;\n  } else if (!first_search && last_character_index_to_search_ != -1 &&\n             current_page == last_page_to_search_) {\n    text_length = last_character_index_to_search_;\n  }\n  if (text_length <= 0)\n    return;\n\n  base::string16 page_text;\n  PDFiumAPIStringBufferAdapter<base::string16> api_string_adapter(\n      &page_text, text_length + 1, false);\n  unsigned short* data =\n      reinterpret_cast<unsigned short*>(api_string_adapter.GetData());\n  int written = FPDFText_GetText(pages_[current_page]->GetTextPage(),\n                                 character_to_start_searching_from,\n                                 text_length + 1, data);\n  api_string_adapter.Close(written);\n\n  std::vector<PDFEngine::Client::SearchStringResult> results =\n      client_->SearchString(page_text.c_str(), term.c_str(), case_sensitive);\n  for (const auto& result : results) {\n    int temp_start = result.start_index + character_to_start_searching_from;\n    int start = FPDFText_GetCharIndexFromTextIndex(\n        pages_[current_page]->GetTextPage(), temp_start);\n    int end = FPDFText_GetCharIndexFromTextIndex(\n        pages_[current_page]->GetTextPage(), temp_start + result.length);\n\n    if (temp_start + result.length == original_text_length) {\n      DCHECK_EQ(-1, end);\n      end = original_text_length;\n    }\n    DCHECK_LT(start, end);\n    DCHECK_EQ(term.size(), static_cast<size_t>(end - start));\n    AddFindResult(PDFiumRange(pages_[current_page].get(), start, end - start));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-6031",
        "length": 440
    },
    {
        "index": 166039,
        "code": "void RTCPeerConnectionHandler::StopEventLog() {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  native_peer_connection_->StopRtcEventLog();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-5760",
        "length": 36
    },
    {
        "index": 76560,
        "code": "void nw_buf_pool_release(nw_buf_pool *pool)\n{\n    for (uint32_t i = 0; i < pool->free; ++i) {\n        free(pool->free_arr[i]);\n    }\n    free(pool->free_arr);\n    free(pool);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-17570",
        "length": 57
    },
    {
        "index": 113050,
        "code": "DownloadPersistentStoreInfo DownloadItemImpl::GetPersistentStoreInfo() const {\n  return DownloadPersistentStoreInfo(GetFullPath(),\n                                     GetURL(),\n                                     GetReferrerUrl(),\n                                     GetStartTime(),\n                                     GetEndTime(),\n                                     GetReceivedBytes(),\n                                     GetTotalBytes(),\n                                     GetState(),\n                                     GetDbHandle(),\n                                     GetOpened());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2895",
        "length": 67
    },
    {
        "index": 56465,
        "code": "unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_TRANS_FPR(i);\n\tbuf[i] = task->thread.transact_fp.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-8844",
        "length": 122
    },
    {
        "index": 124181,
        "code": "bool ContentBrowserClient::AllowWorkerIndexedDB(\n    const GURL& url,\n    const string16& name,\n    ResourceContext* context,\n    const std::vector<std::pair<int, int> >& render_views) {\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0921",
        "length": 52
    },
    {
        "index": 116710,
        "code": "void ShellContentClient::AddNPAPIPlugins(\n     webkit::npapi::PluginList* plugin_list) {\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-3084",
        "length": 26
    },
    {
        "index": 16220,
        "code": "GahpClient::now_pending(const char *command,const char *buf,\n\t\t\t\t\t\tGahpProxyInfo *cmd_proxy, PrioLevel prio_level )\n{\n\n\tif ( command ) {\n\t\tclear_pending();\n\t\tpending_command = strdup( command );\n\t\tpending_reqid = server->new_reqid();\n\t\tif (buf) {\n\t\t\tpending_args = strdup(buf);\n\t\t}\n\t\tif (m_timeout) {\n\t\t\tpending_timeout = m_timeout;\n\t\t}\n\t\tpending_proxy = cmd_proxy;\n\t\tserver->requestTable->insert(pending_reqid,this);\n\t}\n\tASSERT( pending_command != NULL );\n\n\tif ( server->num_pending_requests >= server->max_pending_requests ) {\n\t\tswitch ( prio_level ) {\n\t\tcase high_prio:\n\t\t\tserver->waitingHighPrio.push( pending_reqid );\n\t\t\tbreak;\n\t\tcase medium_prio:\n\t\t\tserver->waitingMediumPrio.push( pending_reqid );\n\t\t\tbreak;\n\t\tcase low_prio:\n\t\t\tserver->waitingLowPrio.push( pending_reqid );\n\t\t\tbreak;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( server->is_initialized == true && server->can_cache_proxies == true ) {\n\t\tif ( server->useCachedProxy( pending_proxy ) != true ) {\n\t\t\tEXCEPT( \"useCachedProxy() failed!\" );\n\t\t}\n\t}\n\n\tserver->write_line(pending_command,pending_reqid,pending_args);\n\tGahp_Args return_line;\n\tserver->read_argv(return_line);\n\tif ( return_line.argc == 0 || return_line.argv[0][0] != 'S' ) {\n\t\tEXCEPT(\"Bad %s Request: %s\",pending_command, return_line.argc?return_line.argv[0]:\"Empty response\");\n\t}\n\n\tpending_submitted_to_gahp = true;\n\tserver->num_pending_requests++;\n\n\tif (pending_timeout) {\n\t\tpending_timeout_tid = daemonCore->Register_Timer(pending_timeout + 1,\n\t\t\t(TimerHandlercpp)&GahpClient::reset_user_timer_alarm,\n\t\t\t\"GahpClient::reset_user_timer_alarm\",this);\n\t\tpending_timeout += time(NULL);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-134",
        "cve": "CVE-2011-4930",
        "length": 448
    },
    {
        "index": 66145,
        "code": "static int guess_month(const char * message, size_t length, size_t indx)\n{\n  int state;\n\n  state = MONTH_START;\n\n  while (1) {\n\n    if (indx >= length)\n      return -1;\n\n    switch(state) {\n    case MONTH_START:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'J': /* Jan Jun Jul */\n\tstate = MONTH_J;\n\tbreak;\n      case 'F': /* Feb */\n\treturn 2;\n      case 'M': /* Mar May */\n\tstate = MONTH_M;\n\tbreak;\n      case 'A': /* Apr Aug */\n\tstate = MONTH_A;\n\tbreak;\n      case 'S': /* Sep */\n\treturn 9;\n      case 'O': /* Oct */\n\treturn 10;\n      case 'N': /* Nov */\n\treturn 11;\n      case 'D': /* Dec */\n\treturn 12;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_J:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\treturn 1;\n      case 'U':\n\tstate = MONTH_JU;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_JU:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'N':\n\treturn 6;\n      case 'L':\n\treturn 7;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_M:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'A':\n\tstate = MONTH_MA;\n\tbreak;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_MA:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'Y':\n\treturn 5;\n      case 'R':\n\treturn 3;\n      default:\n\treturn -1;\n      }\n      break;\n    case MONTH_A:\n      switch((char) toupper((unsigned char) message[indx])) {\n      case 'P':\n\treturn 4;\n      case 'U':\n\treturn 8;\n      default:\n\treturn -1;\n      }\n      break;\n    }\n\n    indx ++;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-8825",
        "length": 456
    },
    {
        "index": 137436,
        "code": "void MessageLoop::DecrementHighResTaskCountIfNeeded(\n    const PendingTask& pending_task) {\n  if (!pending_task.is_high_res)\n    return;\n  --pending_high_res_tasks_;\n  DCHECK_GE(pending_high_res_tasks_, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1294",
        "length": 54
    },
    {
        "index": 104756,
        "code": "void NavigationController::LoadIfNecessary() {\n  if (!needs_reload_)\n    return;\n\n  pending_entry_index_ = last_committed_entry_index_;\n  NavigateToPendingEntry(NO_RELOAD);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2782",
        "length": 42
    },
    {
        "index": 1150,
        "code": "GfxState::~GfxState() {\n  int i;\n\n  if (fillColorSpace) {\n    delete fillColorSpace;\n  }\n  if (strokeColorSpace) {\n    delete strokeColorSpace;\n  }\n  if (fillPattern) {\n    delete fillPattern;\n  }\n  if (strokePattern) {\n    delete strokePattern;\n  }\n  for (i = 0; i < 4; ++i) {\n    if (transfer[i]) {\n      delete transfer[i];\n    }\n  }\n  gfree(lineDash);\n  if (path) {\n    delete path;\n  }\n  if (saved) {\n    delete saved;\n  }\n  if (font) {\n    font->decRefCnt();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 152
    },
    {
        "index": 107501,
        "code": "static WebCore::ViewportAttributes _ewk_view_viewport_attributes_compute(const Ewk_View_Private_Data* priv)\n{\n    int desktopWidth = 980;\n    int deviceDPI = ewk_util_dpi_get();\n\n    WebCore::IntRect availableRect = enclosingIntRect(priv->page->chrome()->client()->pageRect());\n    WebCore::IntRect deviceRect = enclosingIntRect(priv->page->chrome()->client()->windowRect());\n\n    WebCore::ViewportAttributes attributes = WebCore::computeViewportAttributes(priv->viewportArguments, desktopWidth, deviceRect.width(), deviceRect.height(), deviceDPI, availableRect.size());\n    WebCore::restrictMinimumScaleFactorToViewportSize(attributes, availableRect.size());\n    WebCore::restrictScaleFactorToInitialScaleIfNotUserScalable(attributes);\n\n    return attributes;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 170
    },
    {
        "index": 156776,
        "code": "void RemoteFrame::SetView(RemoteFrameView* view) {\n  view_ = view;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18349",
        "length": 23
    },
    {
        "index": 170637,
        "code": "void AgcEnable(preproc_effect_t *effect)\n{\n    webrtc::GainControl *agc = static_cast<webrtc::GainControl *>(effect->engine);\n    ALOGV(\"AgcEnable agc %p\", agc);\n    agc->Enable(true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3842",
        "length": 59
    },
    {
        "index": 170029,
        "code": "xsltFreeRVTs(xsltTransformContextPtr ctxt)\n{\n    xmlDocPtr cur, next;\n\n    if (ctxt == NULL)\n\treturn;\n    /*\n    * Local fragments.\n    */\n    cur = ctxt->localRVT;\n    while (cur != NULL) {\n        next = (xmlDocPtr) cur->next;\n\tif (cur->_private != NULL) {\n\t    xsltFreeDocumentKeys(cur->_private);\n\t    xmlFree(cur->_private);\n\t}\n\txmlFreeDoc(cur);\n\tcur = next;\n    }\n    ctxt->localRVT = NULL;\n    /*\n    * User-created per-template fragments.\n    */\n    cur = ctxt->tmpRVT;\n    while (cur != NULL) {\n        next = (xmlDocPtr) cur->next;\n\tif (cur->_private != NULL) {\n\t    xsltFreeDocumentKeys(cur->_private);\n\t    xmlFree(cur->_private);\n\t}\n\txmlFreeDoc(cur);\n\tcur = next;\n    }\n    ctxt->tmpRVT = NULL;\n    /*\n    * Global fragments.\n    */\n    cur = ctxt->persistRVT;\n    while (cur != NULL) {\n        next = (xmlDocPtr) cur->next;\n\tif (cur->_private != NULL) {\n\t    xsltFreeDocumentKeys(cur->_private);\n\t    xmlFree(cur->_private);\n\t}\n\txmlFreeDoc(cur);\n\tcur = next;\n    }\n    ctxt->persistRVT = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 293
    },
    {
        "index": 10668,
        "code": "  Ins_SHC( TT_ExecContext  exc,\n           FT_Long*        args )\n  {\n    TT_GlyphZoneRec  zp;\n    FT_UShort        refp;\n    FT_F26Dot6       dx, dy;\n\n    FT_Short         contour, bounds;\n    FT_UShort        start, limit, i;\n\n\n    contour = (FT_Short)args[0];\n    bounds  = ( exc->GS.gep2 == 0 ) ? 1 : exc->zp2.n_contours;\n\n    if ( BOUNDS( contour, bounds ) )\n    {\n      if ( exc->pedantic_hinting )\n        exc->error = FT_THROW( Invalid_Reference );\n      return;\n    }\n\n    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )\n      return;\n\n    if ( contour == 0 )\n      start = 0;\n    else\n      start = (FT_UShort)( exc->zp2.contours[contour - 1] + 1 -\n                           exc->zp2.first_point );\n\n    /* we use the number of points if in the twilight zone */\n    if ( exc->GS.gep2 == 0 )\n      limit = exc->zp2.n_points;\n    else\n      limit = (FT_UShort)( exc->zp2.contours[contour] -\n                           exc->zp2.first_point + 1 );\n\n    for ( i = start; i < limit; i++ )\n    {\n      if ( zp.cur != exc->zp2.cur || refp != i )\n        Move_Zp2_Point( exc, i, dx, dy, TRUE );\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-6942",
        "length": 349
    },
    {
        "index": 179919,
        "code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n             dtls1_get_unprocessed_record(s);\n             if ( ! dtls1_process_record(s))\n                 return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n             }\n         }\n \n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }\n",
        "line": "            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2015-0206",
        "length": 247
    },
    {
        "index": 73783,
        "code": "int32_t messageTypeStringtoInt(uint8_t messageTypeString[8]) {\n\tif (memcmp(messageTypeString, \"Hello   \", 8) == 0) {\n\t\treturn MSGTYPE_HELLO;\n\t} else if (memcmp(messageTypeString, \"HelloACK\", 8) == 0) {\n\t\treturn MSGTYPE_HELLOACK;\n\t} else if (memcmp(messageTypeString, \"Commit  \", 8) == 0) {\n\t\treturn MSGTYPE_COMMIT;\n\t} else if (memcmp(messageTypeString, \"DHPart1 \", 8) == 0) {\n\t\treturn MSGTYPE_DHPART1;\n\t} else if (memcmp(messageTypeString, \"DHPart2 \", 8) == 0) {\n\t\treturn MSGTYPE_DHPART2;\n\t} else if (memcmp(messageTypeString, \"Confirm1\", 8) == 0) {\n\t\treturn MSGTYPE_CONFIRM1;\n\t} else if (memcmp(messageTypeString, \"Confirm2\", 8) == 0) {\n\t\treturn MSGTYPE_CONFIRM2;\n\t} else if (memcmp(messageTypeString, \"Conf2ACK\", 8) == 0) {\n\t\treturn MSGTYPE_CONF2ACK;\n\t} else if (memcmp(messageTypeString, \"Error   \", 8) == 0) {\n\t\treturn MSGTYPE_ERROR;\n\t} else if (memcmp(messageTypeString, \"ErrorACK\", 8) == 0) {\n\t\treturn MSGTYPE_ERRORACK;\n\t} else if (memcmp(messageTypeString, \"GoClear \", 8) == 0) {\n\t\treturn MSGTYPE_GOCLEAR;\n\t} else if (memcmp(messageTypeString, \"ClearACK\", 8) == 0) {\n\t\treturn MSGTYPE_CLEARACK;\n\t} else if (memcmp(messageTypeString, \"SASrelay\", 8) == 0) {\n\t\treturn MSGTYPE_SASRELAY;\n\t} else if (memcmp(messageTypeString, \"RelayACK\", 8) == 0) {\n\t\treturn MSGTYPE_RELAYACK;\n\t} else if (memcmp(messageTypeString, \"Ping    \", 8) == 0) {\n\t\treturn MSGTYPE_PING;\n\t} else if (memcmp(messageTypeString, \"PingACK \", 8) == 0) {\n\t\treturn MSGTYPE_PINGACK;\n\t} else {\n\t\treturn MSGTYPE_INVALID;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-6271",
        "length": 504
    },
    {
        "index": 169094,
        "code": "void ReportSavePageResultHistogramAfterSave(const ClientId& client_id,\n                                            SavePageResult result) {\n  base::HistogramBase* histogram = base::LinearHistogram::FactoryGet(\n      AddHistogramSuffix(client_id, \"OfflinePages.SavePageResult\"), 1,\n      static_cast<int>(SavePageResult::RESULT_COUNT),\n      static_cast<int>(SavePageResult::RESULT_COUNT) + 1,\n      base::HistogramBase::kUmaTargetedHistogramFlag);\n  histogram->Add(static_cast<int>(result));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6144",
        "length": 109
    },
    {
        "index": 31756,
        "code": "void flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\t__flush_signals(t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2141",
        "length": 54
    },
    {
        "index": 145643,
        "code": "void UpdateLoadFlagsWithCacheFlags(\n    int* load_flags,\n    FrameMsg_Navigate_Type::Value navigation_type,\n    bool is_post) {\n  switch (navigation_type) {\n    case FrameMsg_Navigate_Type::RELOAD:\n    case FrameMsg_Navigate_Type::RELOAD_ORIGINAL_REQUEST_URL:\n      *load_flags |= net::LOAD_VALIDATE_CACHE;\n      break;\n    case FrameMsg_Navigate_Type::RELOAD_BYPASSING_CACHE:\n      *load_flags |= net::LOAD_BYPASS_CACHE;\n      break;\n    case FrameMsg_Navigate_Type::RESTORE:\n      *load_flags |= net::LOAD_SKIP_CACHE_VALIDATION;\n      break;\n    case FrameMsg_Navigate_Type::RESTORE_WITH_POST:\n      *load_flags |=\n          net::LOAD_ONLY_FROM_CACHE | net::LOAD_SKIP_CACHE_VALIDATION;\n      break;\n    case FrameMsg_Navigate_Type::SAME_DOCUMENT:\n    case FrameMsg_Navigate_Type::DIFFERENT_DOCUMENT:\n      if (is_post)\n        *load_flags |= net::LOAD_VALIDATE_CACHE;\n      break;\n    case FrameMsg_Navigate_Type::HISTORY_SAME_DOCUMENT:\n    case FrameMsg_Navigate_Type::HISTORY_DIFFERENT_DOCUMENT:\n      if (is_post) {\n        *load_flags |=\n            net::LOAD_ONLY_FROM_CACHE | net::LOAD_SKIP_CACHE_VALIDATION;\n      } else {\n        *load_flags |= net::LOAD_SKIP_CACHE_VALIDATION;\n      }\n      break;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1654",
        "length": 303
    },
    {
        "index": 112467,
        "code": "HTMLCanvasElement* Document::getCSSCanvasElement(const String& name)\n{\n    RefPtr<HTMLCanvasElement>& element = m_cssCanvasElements.add(name, 0).iterator->value;\n    if (!element)\n        element = HTMLCanvasElement::create(this);\n    return element.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 61
    },
    {
        "index": 134319,
        "code": "views::View* ConvertPointToViewAndGetEventHandler(\n    views::View* source,\n    views::View* dest,\n    const gfx::Point& point_in_source) {\n  gfx::Point dest_point(point_in_source);\n  views::View::ConvertPointToTarget(source, dest, &dest_point);\n  return dest->HitTestPoint(dest_point) ?\n      dest->GetEventHandlerForPoint(dest_point) : NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 89
    },
    {
        "index": 99296,
        "code": "void ResourceMessageFilter::OnGetCPBrowsingContext(uint32* context) {\n  *context = CPBrowsingContextManager::Instance()->Allocate(\n      request_context_->GetURLRequestContext());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 41
    },
    {
        "index": 148674,
        "code": " void SkiaOutputSurfaceImpl::SetUpdateVSyncParametersCallback(\n    UpdateVSyncParametersCallback callback) {\n  update_vsync_parameters_callback_ = std::move(callback);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2017-5094",
        "length": 38
    },
    {
        "index": 46787,
        "code": "static int sha1_sparc64_export(struct shash_desc *desc, void *out)\n{\n\tstruct sha1_state *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(out, sctx, sizeof(*sctx));\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 52
    },
    {
        "index": 49530,
        "code": "read_report_descriptor(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct hid_device *hdev = to_hid_device(dev);\n\n\tif (off >= hdev->rsize)\n\t\treturn 0;\n\n\tif (off + count > hdev->rsize)\n\t\tcount = hdev->rsize - off;\n\n\tmemcpy(buf, hdev->rdesc + off, count);\n\n\treturn count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-7915",
        "length": 118
    },
    {
        "index": 41171,
        "code": "static inline int tcp_may_undo(const struct tcp_sock *tp)\n{\n\treturn tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-6638",
        "length": 36
    },
    {
        "index": 23644,
        "code": "isdn_net_get_stats(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\treturn &lp->stats;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 32
    },
    {
        "index": 51425,
        "code": "void gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor) {\n\t\treturn;\n\t}\n\t/* Mark it open. */\n\tim->open[color] = 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5767",
        "length": 47
    },
    {
        "index": 127854,
        "code": "static bool CheckAac(const uint8* buffer, int buffer_size) {\n  RCHECK(buffer_size > 6);\n\n  int offset = 0;\n  while (offset + 6 < buffer_size) {\n    BitReader reader(buffer + offset, 6);\n\n    RCHECK(ReadBits(&reader, 12) == 0xfff);\n\n    reader.SkipBits(1);\n\n    RCHECK(ReadBits(&reader, 2) == 0);\n\n    reader.SkipBits(1 + 2);\n\n    RCHECK(ReadBits(&reader, 4) != 15);  // Forbidden.\n\n    reader.SkipBits(1 + 3 + 1 + 1 + 1 + 1);\n\n    int size = ReadBits(&reader, 13);\n    RCHECK(size > 0);\n    offset += size;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-7908",
        "length": 180
    },
    {
        "index": 134671,
        "code": "BrowserViewRenderer::BrowserViewRenderer(\n    BrowserViewRendererClient* client,\n    const scoped_refptr<base::SingleThreadTaskRunner>& ui_task_runner)\n    : client_(client),\n      shared_renderer_state_(ui_task_runner, this),\n      ui_task_runner_(ui_task_runner),\n      compositor_(NULL),\n      is_paused_(false),\n      view_visible_(false),\n      window_visible_(false),\n      attached_to_window_(false),\n      hardware_enabled_(false),\n      dip_scale_(0.0),\n      page_scale_factor_(1.0),\n      on_new_picture_enable_(false),\n      clear_view_(false),\n      offscreen_pre_raster_(false),\n      fallback_tick_pending_(false) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 146
    },
    {
        "index": 139767,
        "code": "void OffscreenCanvasSurfaceImpl::GetSurfaceId(\n    const GetSurfaceIdCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  surface_id_ = id_allocator_->GenerateId();\n\n   callback.Run(surface_id_);\n }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 51
    },
    {
        "index": 114990,
        "code": "void TestingAutomationProvider::OmniboxMovePopupSelection(\n    Browser* browser,\n    DictionaryValue* args,\n    IPC::Message* reply_message) {\n  int count;\n  AutomationJSONReply reply(this, reply_message);\n  if (!args->GetInteger(\"count\", &count)) {\n    reply.SendError(\"count missing\");\n    return;\n  }\n  LocationBar* loc_bar = browser->window()->GetLocationBar();\n  AutocompleteEditModel* model = loc_bar->location_entry()->model();\n  model->OnUpOrDownKeyPressed(count);\n  reply.SendSuccess(NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 122
    },
    {
        "index": 13700,
        "code": "static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\n{\n    int ret;\n\n    clear_sys_error();\n    if (s->s3->renegotiate)\n        ssl3_renegotiate_check(s);\n    s->s3->in_read_app_data = 1;\n    ret =\n        s->method->ssl_read_bytes(s, SSL3_RT_APPLICATION_DATA, buf, len,\n                                  peek);\n    if ((ret == -1) && (s->s3->in_read_app_data == 2)) {\n        /*\n         * ssl3_read_bytes decided to call s->handshake_func, which called\n         * ssl3_read_bytes to read handshake data. However, ssl3_read_bytes\n         * actually found application data and thinks that application data\n         * makes sense here; so disable handshake processing and try to read\n         * application data again.\n         */\n        s->in_handshake++;\n        ret =\n            s->method->ssl_read_bytes(s, SSL3_RT_APPLICATION_DATA, buf, len,\n                                      peek);\n        s->in_handshake--;\n    } else\n        s->s3->in_read_app_data = 0;\n\n    return (ret);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-0701",
        "length": 255
    },
    {
        "index": 185265,
        "code": "LinkChangeSerializerMarkupAccumulator::LinkChangeSerializerMarkupAccumulator(PageSerializer* serializer, Document* document, Vector<Node*>* nodes, LinkLocalPathMap* links, String directoryName)\n    : SerializerMarkupAccumulator(serializer, document, nodes)\n    , m_replaceLinks(links)\n    , m_directoryName(directoryName)\n{\n}\n",
        "line": "    : SerializerMarkupAccumulator(serializer, document, nodes)\n    , m_replaceLinks(links)\n    , m_directoryName(directoryName)\n{\n}\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2012-5157",
        "length": 71
    },
    {
        "index": 24305,
        "code": "static void l2tp_eth_dev_uninit(struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_eth_net *pn = l2tp_eth_pernet(dev_net(dev));\n\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_del_init(&priv->list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\tdev_put(dev);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 84
    },
    {
        "index": 30467,
        "code": "static void tipc_data_ready(struct sock *sk, int len)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (wq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, POLLIN |\n\t\t\t\t\t\tPOLLRDNORM | POLLRDBAND);\n\trcu_read_unlock();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-3235",
        "length": 89
    },
    {
        "index": 28562,
        "code": "static inline __u8 qeth_get_ipa_adp_type(enum qeth_link_types link_type)\n{\n\tswitch (link_type) {\n\tcase QETH_LINK_TYPE_HSTR:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6381",
        "length": 52
    },
    {
        "index": 166452,
        "code": "void RecordParallelizableDownloadCount(DownloadCountTypes type,\n                                       bool is_parallel_download_enabled) {\n  std::string histogram_name = is_parallel_download_enabled\n                                   ? \"Download.Counts.ParallelDownload\"\n                                   : \"Download.Counts.ParallelizableDownload\";\n  base::UmaHistogramEnumeration(histogram_name, type,\n                                DOWNLOAD_COUNT_TYPES_LAST_ENTRY);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2019-5774",
        "length": 75
    },
    {
        "index": 5732,
        "code": "static void xhci_msix_update(XHCIState *xhci, int v)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(xhci);\n    bool enabled;\n\n    if (!msix_enabled(pci_dev)) {\n        return;\n    }\n\n    enabled = xhci->intr[v].iman & IMAN_IE;\n    if (enabled == xhci->intr[v].msix_used) {\n        return;\n    }\n\n    if (enabled) {\n        trace_usb_xhci_irq_msix_use(v);\n        msix_vector_use(pci_dev, v);\n        xhci->intr[v].msix_used = true;\n    } else {\n        trace_usb_xhci_irq_msix_unuse(v);\n        msix_vector_unuse(pci_dev, v);\n        xhci->intr[v].msix_used = false;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-9375",
        "length": 173
    },
    {
        "index": 176310,
        "code": " static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n Handle<JSObject> receiver,\n Handle<Object> value,\n uint32_t start_from, uint32_t length) {\n return IncludesValueSlowPath(isolate, receiver, value, start_from, length);\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-9490",
        "length": 54
    },
    {
        "index": 94872,
        "code": "static void __handle_link_change(struct usbnet *dev)\n{\n\tif (!test_bit(EVENT_DEV_OPEN, &dev->flags))\n\t\treturn;\n\n\tif (!netif_carrier_ok(dev->net)) {\n\t\t/* kill URBs for reading packets to save bus bandwidth */\n\t\tunlink_urbs(dev, &dev->rxq);\n\n\t\t/*\n\t\t * tx_timeout will unlink URBs for sending packets and\n\t\t * tx queue is stopped by netcore after link becomes off\n\t\t */\n\t} else {\n\t\t/* submitting URBs for reading packets */\n\t\ttasklet_schedule(&dev->bh);\n\t}\n\n\t/* hard_mtu or rx_urb_size may change during link change */\n\tusbnet_update_max_qlen(dev);\n\n\tclear_bit(EVENT_LINK_CHANGE, &dev->flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3951",
        "length": 167
    },
    {
        "index": 108699,
        "code": "void ChromotingInstance::DidChangeView(const pp::View& view) {\n  DCHECK(plugin_task_runner_->BelongsToCurrentThread());\n\n  view_->SetView(view);\n\n  mouse_input_filter_.set_input_size(view_->get_view_size_dips());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5141",
        "length": 51
    },
    {
        "index": 116563,
        "code": "  TestInterstitialPageDelegate(TestInterstitialPage* interstitial_page)\n      : interstitial_page_(interstitial_page) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-3084",
        "length": 25
    },
    {
        "index": 26294,
        "code": "long __sched io_schedule_timeout(long timeout)\n{\n\tstruct rq *rq = raw_rq();\n\tlong ret;\n\n\tdelayacct_blkio_start();\n\tatomic_inc(&rq->nr_iowait);\n\tblk_flush_plug(current);\n\tcurrent->in_iowait = 1;\n\tret = schedule_timeout(timeout);\n\tcurrent->in_iowait = 0;\n\tatomic_dec(&rq->nr_iowait);\n\tdelayacct_blkio_end();\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 91
    },
    {
        "index": 25810,
        "code": "static void intel_pmu_disable_all(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\n\twrmsrl(MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n\tif (test_bit(X86_PMC_IDX_FIXED_BTS, cpuc->active_mask))\n\t\tintel_pmu_disable_bts();\n\n\tintel_pmu_pebs_disable_all();\n\tintel_pmu_lbr_disable_all();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 89
    },
    {
        "index": 74680,
        "code": "rs_filter_get_size(RSFilter *filter, const RSFilterRequest *request)\n{\n\tRSFilterResponse *response = NULL;\n\n\tg_return_val_if_fail(RS_IS_FILTER(filter), NULL);\n\tg_return_val_if_fail(RS_IS_FILTER_REQUEST(request), NULL);\n\n\tif (RS_FILTER_GET_CLASS(filter)->get_size && filter->enabled)\n\t\tresponse = RS_FILTER_GET_CLASS(filter)->get_size(filter, request);\n\telse if (filter->previous)\n\t\tresponse = rs_filter_get_size(filter->previous, request);\n\n\treturn response;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2014-4978",
        "length": 109
    },
    {
        "index": 38100,
        "code": "static int whiteheat_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct serial_struct serstruct;\n\tvoid __user *user_arg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCGSERIAL:\n\t\tmemset(&serstruct, 0, sizeof(serstruct));\n\t\tserstruct.type = PORT_16654;\n\t\tserstruct.line = port->minor;\n\t\tserstruct.port = port->port_number;\n\t\tserstruct.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\n\t\tserstruct.xmit_fifo_size = kfifo_size(&port->write_fifo);\n\t\tserstruct.custom_divisor = 0;\n\t\tserstruct.baud_base = 460800;\n\t\tserstruct.close_delay = CLOSING_DELAY;\n\t\tserstruct.closing_wait = CLOSING_DELAY;\n\n\t\tif (copy_to_user(user_arg, &serstruct, sizeof(serstruct)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3185",
        "length": 236
    },
    {
        "index": 147055,
        "code": "void WebLocalFrameImpl::RequestExecuteV8Function(\n    v8::Local<v8::Context> context,\n    v8::Local<v8::Function> function,\n    v8::Local<v8::Value> receiver,\n    int argc,\n    v8::Local<v8::Value> argv[],\n    WebScriptExecutionCallback* callback) {\n  DCHECK(GetFrame());\n  SuspendableScriptExecutor::CreateAndRun(GetFrame(), ToIsolate(GetFrame()),\n                                          context, function, receiver, argc,\n                                          argv, callback);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 113
    },
    {
        "index": 100876,
        "code": "bool BrowsingDataExtensionFunction::RunImpl() {\n  if (BrowsingDataRemover::is_removing()) {\n    error_ = extension_clear_api_constants::kOneAtATimeError;\n    return false;\n  }\n\n  double ms_since_epoch;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetDouble(0, &ms_since_epoch));\n  remove_since_ = (ms_since_epoch == 0) ?\n      base::Time::UnixEpoch() :\n      base::Time::FromDoubleT(ms_since_epoch / 1000.0);\n\n  removal_mask_ = GetRemovalMask();\n\n  if (removal_mask_ & BrowsingDataRemover::REMOVE_PLUGIN_DATA) {\n    Profile* profile = GetCurrentBrowser()->profile();\n    BrowserThread::PostTask(\n        BrowserThread::FILE, FROM_HERE,\n        base::Bind(\n            &BrowsingDataExtensionFunction::CheckRemovingPluginDataSupported,\n            this,\n            make_scoped_refptr(PluginPrefs::GetForProfile(profile))));\n  } else {\n    StartRemoving();\n  }\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 218
    },
    {
        "index": 105108,
        "code": "short Range::compareBoundaryPoints(const RangeBoundaryPoint& boundaryA, const RangeBoundaryPoint& boundaryB, ExceptionCode& ec)\n{\n    return compareBoundaryPoints(boundaryA.container(), boundaryA.offset(), boundaryB.container(), boundaryB.offset(), ec);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2795",
        "length": 54
    },
    {
        "index": 20331,
        "code": "int kvm_clear_guest(struct kvm *kvm, gpa_t gpa, unsigned long len)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tint seg;\n\tint offset = offset_in_page(gpa);\n\tint ret;\n\n        while ((seg = next_segment(len, offset)) != 0) {\n\t\tret = kvm_clear_guest_page(kvm, gfn, offset, seg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\toffset = 0;\n\t\tlen -= seg;\n\t\t++gfn;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-2121",
        "length": 118
    },
    {
        "index": 47044,
        "code": "static int sha256_ssse3_import(struct shash_desc *desc, const void *in)\n{\n\tstruct sha256_state *sctx = shash_desc_ctx(desc);\n\n\tmemcpy(sctx, in, sizeof(*sctx));\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 52
    },
    {
        "index": 103705,
        "code": "int DevToolsAgent::hostIdentifier() {\n  return routing_id();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 16
    },
    {
        "index": 27401,
        "code": "ip6_tnl_change(struct ip6_tnl *t, struct ip6_tnl_parm *p)\n{\n\tipv6_addr_copy(&t->parms.laddr, &p->laddr);\n\tipv6_addr_copy(&t->parms.raddr, &p->raddr);\n\tt->parms.flags = p->flags;\n\tt->parms.hop_limit = p->hop_limit;\n\tt->parms.encap_limit = p->encap_limit;\n\tt->parms.flowinfo = p->flowinfo;\n\tt->parms.link = p->link;\n\tt->parms.proto = p->proto;\n\tip6_tnl_dst_reset(t);\n\tip6_tnl_link_config(t);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2011-1768",
        "length": 144
    },
    {
        "index": 14902,
        "code": "static int spl_heap_object_count_elements(zval *object, long *count TSRMLS_DC) /* {{{ */\n{\n\tspl_heap_object *intern = (spl_heap_object*)zend_object_store_get_object(object TSRMLS_CC);\n\n\tif (intern->fptr_count) {\n\t\tzval *rv;\n\t\tzend_call_method_with_0_params(&object, intern->std.ce, &intern->fptr_count, \"count\", &rv);\n\t\tif (rv) {\n\t\t\tzval_ptr_dtor(&intern->retval);\n\t\t\tMAKE_STD_ZVAL(intern->retval);\n\t\t\tZVAL_ZVAL(intern->retval, rv, 1, 1);\n\t\t\tconvert_to_long(intern->retval);\n\t\t\t*count = (long) Z_LVAL_P(intern->retval);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\t*count = 0;\n\t\treturn FAILURE;\n\t}\n\t\n\t*count = spl_ptr_heap_count(intern->heap);\n\n\treturn SUCCESS;\n} \n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-4116",
        "length": 205
    },
    {
        "index": 78838,
        "code": "int sc_file_set_content(sc_file_t *file, const u8 *content,\n\t\t\t size_t content_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (content == NULL) {\n\t\tif (file->encoded_content != NULL)\n\t\t\tfree(file->encoded_content);\n\t\tfile->encoded_content = NULL;\n\t\tfile->encoded_content_len = 0;\n\t\treturn SC_SUCCESS;\n\t}\n\n\ttmp = (u8 *) realloc(file->encoded_content, content_len);\n\tif (!tmp) {\n\t\tif (file->encoded_content)\n\t\t\tfree(file->encoded_content);\n\t\tfile->encoded_content = NULL;\n\t\tfile->encoded_content_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\n\tfile->encoded_content = tmp;\n\tmemcpy(file->encoded_content, content, content_len);\n\tfile->encoded_content_len = content_len;\n\n\treturn SC_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-16425",
        "length": 192
    },
    {
        "index": 20193,
        "code": "int sock_prot_inuse_get(struct net *net, struct proto *prot)\n{\n\tint cpu, idx = prot->inuse_idx;\n\tint res = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\tres += per_cpu_ptr(net->core.inuse, cpu)->val[idx];\n\n\treturn res >= 0 ? res : 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-2136",
        "length": 70
    },
    {
        "index": 139382,
        "code": "static bool Enabled(LocalFrame&, Event*, EditorCommandSource) {\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1265",
        "length": 19
    },
    {
        "index": 151695,
        "code": "bool Browser::IsMouseLocked() const {\n  return exclusive_access_manager_->mouse_lock_controller()->IsMouseLocked();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5013",
        "length": 25
    },
    {
        "index": 105244,
        "code": "static inline bool elementAffectsDirectionality(const Node* node)\n{\n    return node->isHTMLElement() && (node->hasTagName(bdiTag) || toHTMLElement(node)->hasAttribute(dirAttr));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2795",
        "length": 43
    },
    {
        "index": 129224,
        "code": "void BackTexture::Create() {\n  ScopedGLErrorSuppressor suppressor(\"BackTexture::Create\",\n                                     state_->GetErrorState());\n  Destroy();\n  glGenTextures(1, &id_);\n  ScopedTextureBinder binder(state_, id_, GL_TEXTURE_2D);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n  glTexImage2D(\n      GL_TEXTURE_2D, 0, GL_RGBA, 16, 16, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);\n\n  bytes_allocated_ = 16u * 16u * 4u;\n  memory_tracker_.TrackMemAlloc(bytes_allocated_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3173",
        "length": 193
    },
    {
        "index": 27560,
        "code": "static void opl3_bender(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tbend_pitch(dev, voice, value - 8192);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-1477",
        "length": 50
    },
    {
        "index": 134989,
        "code": "void AppCacheUpdateJob::CancelAllMasterEntryFetches(\n    const AppCacheErrorDetails& error_details) {\n\n  for (PendingUrlFetches::iterator it = master_entry_fetches_.begin();\n       it != master_entry_fetches_.end(); ++it) {\n    delete it->second;\n    master_entries_to_fetch_.insert(it->first);  // back in unfetched list\n  }\n  master_entry_fetches_.clear();\n\n  master_entries_completed_ += master_entries_to_fetch_.size();\n\n  HostNotifier host_notifier;\n  while (!master_entries_to_fetch_.empty()) {\n    const GURL& url = *master_entries_to_fetch_.begin();\n    PendingMasters::iterator found = pending_master_entries_.find(url);\n    DCHECK(found != pending_master_entries_.end());\n    PendingHosts& hosts = found->second;\n    for (PendingHosts::iterator host_it = hosts.begin();\n         host_it != hosts.end(); ++host_it) {\n      AppCacheHost* host = *host_it;\n      host->AssociateNoCache(GURL());\n      host_notifier.AddHost(host);\n      host->RemoveObserver(this);\n    }\n    hosts.clear();\n\n    master_entries_to_fetch_.erase(master_entries_to_fetch_.begin());\n  }\n  host_notifier.SendErrorNotifications(error_details);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6765",
        "length": 264
    },
    {
        "index": 152533,
        "code": "bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(\n    int error_code,\n    const GURL& unreachable_url) {\n  if (error_code == net::ERR_ABORTED)\n    return false;\n\n  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&\n      render_view_->renderer_preferences_.disable_client_blocked_error_page) {\n    return false;\n  }\n\n  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(\n          this, unreachable_url)) {\n    return false;\n  }\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5019",
        "length": 109
    },
    {
        "index": 105311,
        "code": "void AutofillDownloadManager::SetNegativeUploadRate(double rate) {\n  if (rate == negative_upload_rate_)\n    return;\n  negative_upload_rate_ = rate;\n  DCHECK_GE(rate, 0.0);\n  DCHECK_LE(rate, 1.0);\n  DCHECK(profile_);\n  PrefService* preferences = profile_->GetPrefs();\n  preferences->SetDouble(prefs::kAutofillNegativeUploadRate, rate);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2797",
        "length": 89
    },
    {
        "index": 70176,
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)\n{\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\t*value = direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8(value);\n\treturn(TIFFReadDirEntryErrOk);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10270",
        "length": 180
    },
    {
        "index": 117733,
        "code": "static v8::Handle<v8::Value> attr2AttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestEventConstructor.attr2._get\");\n    TestEventConstructor* imp = V8TestEventConstructor::toNative(info.Holder());\n    return v8String(imp->attr2(), info.GetIsolate());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3055",
        "length": 85
    },
    {
        "index": 109649,
        "code": "void Document::dispatchVisibilityStateChangeEvent()\n{\n    dispatchEvent(Event::create(EventTypeNames::webkitvisibilitychange));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5136",
        "length": 25
    },
    {
        "index": 123935,
        "code": "void RenderViewImpl::SendUpdateState(const WebHistoryItem& item) {\n  if (item.isNull())\n    return;\n\n  if (item.urlString() == WebString::fromUTF8(kSwappedOutURL))\n    return;\n\n  Send(new ViewHostMsg_UpdateState(\n      routing_id_, page_id_, webkit_glue::HistoryItemToString(item)));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0918",
        "length": 76
    },
    {
        "index": 18529,
        "code": "static void tcp_illinois_acked(struct sock *sk, u32 pkts_acked, s32 rtt)\n{\n\tstruct illinois *ca = inet_csk_ca(sk);\n\n\tca->acked = pkts_acked;\n\n\t/* dup ack, no rtt sample */\n\tif (rtt < 0)\n\t\treturn;\n\n\t/* ignore bogus values, this prevents wraparound in alpha math */\n\tif (rtt > RTT_MAX)\n\t\trtt = RTT_MAX;\n\n\t/* keep track of minimum RTT seen so far */\n\tif (ca->base_rtt > rtt)\n\t\tca->base_rtt = rtt;\n\n\t/* and max */\n\tif (ca->max_rtt < rtt)\n\t\tca->max_rtt = rtt;\n\n\t++ca->cnt_rtt;\n\tca->sum_rtt += rtt;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-4565",
        "length": 181
    },
    {
        "index": 119200,
        "code": "SecurityOrigin* XMLHttpRequest::securityOrigin() const\n{\n    return m_securityOrigin ? m_securityOrigin.get() : scriptExecutionContext()->securityOrigin();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2925",
        "length": 31
    },
    {
        "index": 101594,
        "code": "void Browser::CloseContents(TabContents* source) {\n  if (is_attempting_to_close_browser_) {\n    ClearUnloadState(source, true);\n    return;\n  }\n\n  TabContentsWrapper* source_wrapper =\n      TabContentsWrapper::GetCurrentWrapperForContents(source);\n  if (g_browser_process->background_printing_manager()->\n          OwnInitiatorTab(source_wrapper)) {\n    return;\n  }\n\n  int index = tab_handler_->GetTabStripModel()->GetWrapperIndex(source);\n  if (index == TabStripModel::kNoTab) {\n    NOTREACHED() << \"CloseContents called for tab not in our strip\";\n    return;\n  }\n  tab_handler_->GetTabStripModel()->CloseTabContentsAt(\n      index,\n      TabStripModel::CLOSE_CREATE_HISTORICAL_TAB);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3896",
        "length": 167
    },
    {
        "index": 126828,
        "code": "void BrowserView::Minimize() {\n  frame_->Minimize();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 16
    },
    {
        "index": 93627,
        "code": "nvmet_fc_queue_to_cpu(struct nvmet_fc_tgtport *tgtport, int qid)\n{\n\tint cpu, idx, cnt;\n\n\tif (tgtport->ops->max_hw_queues == 1)\n\t\treturn WORK_CPU_UNBOUND;\n\n\t/* Simple cpu selection based on qid modulo active cpu count */\n\tidx = !qid ? 0 : (qid - 1) % num_active_cpus();\n\n\t/* find the n'th active cpu */\n\tfor (cpu = 0, cnt = 0; ; ) {\n\t\tif (cpu_active(cpu)) {\n\t\t\tif (cnt == idx)\n\t\t\t\tbreak;\n\t\t\tcnt++;\n\t\t}\n\t\tcpu = (cpu + 1) % num_possible_cpus();\n\t}\n\n\treturn cpu;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18379",
        "length": 152
    },
    {
        "index": 172746,
        "code": "static u32 Mmcop4(dpbStorage_t *dpb, u32 maxLongTermFrameIdx)\n{\n\n/* Variables */\n\n    u32 i;\n\n/* Code */\n\n    dpb->maxLongTermFrameIdx = maxLongTermFrameIdx;\n\n for (i = 0; i < dpb->maxRefFrames; i++)\n if (IS_LONG_TERM(dpb->buffer[i]) &&\n ( ((u32)dpb->buffer[i].picNum > maxLongTermFrameIdx) ||\n (dpb->maxLongTermFrameIdx == NO_LONG_TERM_FRAME_INDICES) ) )\n {\n            SET_UNUSED(dpb->buffer[i]);\n            dpb->numRefFrames--;\n if (!dpb->buffer[i].toBeDisplayed)\n                dpb->fullness--;\n }\n\n return(HANTRO_OK);\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3819",
        "length": 166
    },
    {
        "index": 55491,
        "code": "build_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL;\n\tstruct sd_data *sdd = sd->private;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered;\n\tint i;\n\n\tget_group(cpu, sdd, &sd->groups);\n\tatomic_inc(&sd->groups->ref);\n\n\tif (cpu != cpumask_first(span))\n\t\treturn 0;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\tcovered = sched_domains_tmpmask;\n\n\tcpumask_clear(covered);\n\n\tfor_each_cpu(i, span) {\n\t\tstruct sched_group *sg;\n\t\tint group, j;\n\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\n\t\tgroup = get_group(i, sdd, &sg);\n\t\tcpumask_setall(sched_group_mask(sg));\n\n\t\tfor_each_cpu(j, span) {\n\t\t\tif (get_group(j, sdd, NULL) != group)\n\t\t\t\tcontinue;\n\n\t\t\tcpumask_set_cpu(j, covered);\n\t\t\tcpumask_set_cpu(j, sched_group_cpus(sg));\n\t\t}\n\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t}\n\tlast->next = first;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1583",
        "length": 278
    },
    {
        "index": 47371,
        "code": "int crypto_sha512_update(struct shash_desc *desc, const u8 *data,\n\t\t\tunsigned int len)\n{\n\tstruct sha512_state *sctx = shash_desc_ctx(desc);\n\n\tunsigned int i, index, part_len;\n\n\t/* Compute number of bytes mod 128 */\n\tindex = sctx->count[0] & 0x7f;\n\n\t/* Update number of bytes */\n\tif ((sctx->count[0] += len) < len)\n\t\tsctx->count[1]++;\n\n        part_len = 128 - index;\n\n\t/* Transform as many times as possible. */\n\tif (len >= part_len) {\n\t\tmemcpy(&sctx->buf[index], data, part_len);\n\t\tsha512_transform(sctx->state, sctx->buf);\n\n\t\tfor (i = part_len; i + 127 < len; i+=128)\n\t\t\tsha512_transform(sctx->state, &data[i]);\n\n\t\tindex = 0;\n\t} else {\n\t\ti = 0;\n\t}\n\n\t/* Buffer remaining input */\n\tmemcpy(&sctx->buf[index], &data[i], len - i);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 239
    },
    {
        "index": 31065,
        "code": "void rtnl_set_sk_err(struct net *net, u32 group, int error)\n{\n\tstruct sock *rtnl = net->rtnl;\n\n\tnetlink_set_err(rtnl, 0, group, error);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2635",
        "length": 49
    },
    {
        "index": 137443,
        "code": "bool MessageLoop::InitMessagePumpForUIFactory(MessagePumpFactory* factory) {\n  if (message_pump_for_ui_factory_)\n    return false;\n\n  message_pump_for_ui_factory_ = factory;\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1294",
        "length": 50
    },
    {
        "index": 174943,
        "code": "void CameraClient::disableMsgType(int32_t msgType) {\n    android_atomic_and(~msgType, &mMsgEnabled);\n    mHardware->disableMsgType(msgType);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0826",
        "length": 39
    },
    {
        "index": 53919,
        "code": "static void ndp_msg_init(struct ndp_msg *msg, enum ndp_msg_type msg_type)\n{\n\tsize_t raw_struct_size = ndp_msg_type_info(msg_type)->raw_struct_size;\n\n\tndp_msg_type_set(msg, msg_type);\n\tmsg->len = raw_struct_size;\n\tmsg->opts_start = msg->buf + raw_struct_size;\n\n\t/* Set-up \"first pointers\" in all ndp_msgrs, ndp_msgra, ndp_msgns,\n\t * ndp_msgna, ndp_msgr structures.\n\t */\n\tmsg->nd_msg.generic.dataptr = ndp_msg_payload(msg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3698",
        "length": 130
    },
    {
        "index": 20719,
        "code": "void kvm_arch_flush_shadow(struct kvm *kvm)\n{\n\tkvm_mmu_zap_all(kvm);\n\tkvm_reload_remote_mmus(kvm);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-1601",
        "length": 33
    },
    {
        "index": 25708,
        "code": "static inline unsigned long __user *__fetch_reg_addr_user(unsigned int reg,\n\t\t\t\t\t\t\t  struct pt_regs *regs)\n{\n\tBUG_ON(reg < 16);\n\tBUG_ON(regs->tstate & TSTATE_PRIV);\n\n\tif (test_thread_flag(TIF_32BIT)) {\n\t\tstruct reg_window32 __user *win32;\n\t\twin32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP]));\n\t\treturn (unsigned long __user *)&win32->locals[reg - 16];\n\t} else {\n\t\tstruct reg_window __user *win;\n\t\twin = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS);\n\t\treturn &win->locals[reg - 16];\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 165
    },
    {
        "index": 152644,
        "code": "HTMLFormElement* HTMLFormControlElement::formOwner() const {\n  return ListedElement::form();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-1021",
        "cve": "CVE-2017-5016",
        "length": 22
    },
    {
        "index": 122342,
        "code": "int HTMLInputElement::selectionEndForBinding(ExceptionState& exceptionState) const\n{\n    if (!m_inputType->supportsSelectionAPI()) {\n        exceptionState.throwDOMException(InvalidStateError, \"The input element's type ('\" + m_inputType->formControlType() + \"') does not support selection.\");\n        return 0;\n    }\n    return HTMLTextFormControlElement::selectionEnd();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0882",
        "length": 83
    },
    {
        "index": 64272,
        "code": "static const char *set_cgi_var(cmd_parms *cmd, void *d_,\n                               const char *var, const char *rule_)\n{\n    core_dir_config *d = d_;\n    char *rule = apr_pstrdup(cmd->pool, rule_);\n\n    ap_str_tolower(rule);\n\n    if (!strcmp(var, \"REQUEST_URI\")) {\n        if (strcmp(rule, \"current-uri\") && strcmp(rule, \"original-uri\")) {\n            return \"Valid rules for REQUEST_URI are 'current-uri' and 'original-uri'\";\n        }\n    }\n    else {\n        return apr_pstrcat(cmd->pool, \"Unrecognized CGI variable: \\\"\",\n                           var, \"\\\"\", NULL);\n    }\n\n    if (!d->cgi_var_rules) {\n        d->cgi_var_rules = apr_hash_make(cmd->pool);\n    }\n    apr_hash_set(d->cgi_var_rules, var, APR_HASH_KEY_STRING, rule);\n    return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-9798",
        "length": 193
    },
    {
        "index": 157099,
        "code": "  bool loading() { return multibuffer()->loading(); }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 14
    },
    {
        "index": 86465,
        "code": "bool userfaultfd_remove(struct vm_area_struct *vma,\n\t\t\tunsigned long start, unsigned long end)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct userfaultfd_ctx *ctx;\n\tstruct userfaultfd_wait_queue ewq;\n\n\tctx = vma->vm_userfaultfd_ctx.ctx;\n\tif (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_REMOVE))\n\t\treturn true;\n\n\tuserfaultfd_ctx_get(ctx);\n\tup_read(&mm->mmap_sem);\n\n\tmsg_init(&ewq.msg);\n\n\tewq.msg.event = UFFD_EVENT_REMOVE;\n\tewq.msg.arg.remove.start = start;\n\tewq.msg.arg.remove.end = end;\n\n\tuserfaultfd_event_wait_completion(ctx, &ewq);\n\n\treturn false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-15126",
        "length": 156
    },
    {
        "index": 29994,
        "code": "static int br_ip6_multicast_add_group(struct net_bridge *br,\n\t\t\t\t      struct net_bridge_port *port,\n\t\t\t\t      const struct in6_addr *group,\n\t\t\t\t      __u16 vid)\n{\n\tstruct br_ip br_group;\n\n\tif (!ipv6_is_transient_multicast(group))\n\t\treturn 0;\n\n\tbr_group.u.ip6 = *group;\n\tbr_group.proto = htons(ETH_P_IPV6);\n\tbr_group.vid = vid;\n\n\treturn br_multicast_add_group(br, port, &br_group);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-4129",
        "length": 103
    },
    {
        "index": 5655,
        "code": "ok_to_reverse (char const *format, ...)\n{\n  bool r = false;\n\n  if (noreverse || ! (force && verbosity == SILENT))\n    {\n      va_list args;\n      va_start (args, format);\n      vsay (format, args);\n      va_end (args);\n    }\n\n  if (noreverse)\n    {\n      say (\"  Skipping patch.\\n\");\n      skip_rest_of_patch = true;\n    }\n  else if (force)\n    {\n      if (verbosity != SILENT)\n\tsay (\"  Applying it anyway.\\n\");\n    }\n  else if (batch)\n    {\n      say (reverse ? \"  Ignoring -R.\\n\" : \"  Assuming -R.\\n\");\n      r = true;\n    }\n  else\n    {\n      ask (reverse ? \"  Ignore -R? [n] \" : \"  Assume -R? [n] \");\n      r = *buf == 'y';\n      if (! r)\n\t{\n\t  ask (\"Apply anyway? [n] \");\n\t  if (*buf != 'y')\n\t    {\n\t      if (verbosity != SILENT)\n\t\tsay (\"Skipping patch.\\n\");\n\t      skip_rest_of_patch = true;\n\t    }\n\t}\n    }\n\n  return r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2010-4651",
        "length": 263
    },
    {
        "index": 29635,
        "code": "static int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2)\n{\n\tif (addr1->sa.sa_family != addr2->sa.sa_family) {\n\t\tif (addr1->sa.sa_family == AF_INET &&\n\t\t    addr2->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr2->v6.sin6_addr)) {\n\t\t\tif (addr2->v6.sin6_port == addr1->v4.sin_port &&\n\t\t\t    addr2->v6.sin6_addr.s6_addr32[3] ==\n\t\t\t    addr1->v4.sin_addr.s_addr)\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (addr2->sa.sa_family == AF_INET &&\n\t\t    addr1->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr1->v6.sin6_addr)) {\n\t\t\tif (addr1->v6.sin6_port == addr2->v4.sin_port &&\n\t\t\t    addr1->v6.sin6_addr.s6_addr32[3] ==\n\t\t\t    addr2->v4.sin_addr.s_addr)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!ipv6_addr_equal(&addr1->v6.sin6_addr, &addr2->v6.sin6_addr))\n\t\treturn 0;\n\t/* If this is a linklocal address, compare the scope_id. */\n\tif (ipv6_addr_type(&addr1->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr1->v6.sin6_scope_id && addr2->v6.sin6_scope_id &&\n\t\t    (addr1->v6.sin6_scope_id != addr2->v6.sin6_scope_id)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2013-4350",
        "length": 383
    },
    {
        "index": 53489,
        "code": "rar_br_preparation(struct archive_read *a, struct rar_br *br)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n\n  if (rar->bytes_remaining > 0) {\n    br->next_in = rar_read_ahead(a, 1, &(br->avail_in));\n    if (br->next_in == NULL) {\n      archive_set_error(&a->archive,\n          ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Truncated RAR file data\");\n      return (ARCHIVE_FATAL);\n    }\n    if (br->cache_avail == 0)\n      (void)rar_br_fillup(a, br);\n  }\n  return (ARCHIVE_OK);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4302",
        "length": 146
    },
    {
        "index": 11923,
        "code": "int cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd)\n{\n    EVP_PKEY *pkey;\n    int i;\n    if (ri->type == CMS_RECIPINFO_TRANS)\n        pkey = ri->d.ktri->pkey;\n    else if (ri->type == CMS_RECIPINFO_AGREE) {\n        EVP_PKEY_CTX *pctx = ri->d.kari->pctx;\n        if (!pctx)\n            return 0;\n        pkey = EVP_PKEY_CTX_get0_pkey(pctx);\n        if (!pkey)\n            return 0;\n    } else\n        return 0;\n    if (!pkey->ameth || !pkey->ameth->pkey_ctrl)\n        return 1;\n    i = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_ENVELOPE, cmd, ri);\n    if (i == -2) {\n        CMSerr(CMS_F_CMS_ENV_ASN1_CTRL,\n               CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\n        return 0;\n    }\n    if (i <= 0) {\n        CMSerr(CMS_F_CMS_ENV_ASN1_CTRL, CMS_R_CTRL_FAILURE);\n        return 0;\n    }\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-311",
        "cve": "CVE-2019-1563",
        "length": 274
    },
    {
        "index": 49605,
        "code": "static ssize_t ffs_epfile_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = true;\n\tp->kiocb = kiocb;\n\tif (p->aio) {\n\t\tp->to_free = dup_iter(&p->data, to, GFP_KERNEL);\n\t\tif (!p->to_free) {\n\t\t\tkfree(p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tp->data = *to;\n\t\tp->to_free = NULL;\n\t}\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\n\tif (p->aio) {\n\t\tkfree(p->to_free);\n\t\tkfree(p);\n\t} else {\n\t\t*to = p->data;\n\t}\n\treturn res;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7912",
        "length": 304
    },
    {
        "index": 30487,
        "code": "static int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t     int *len, int peer)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr);\n\n\tif (llcp_sock == NULL || llcp_sock->dev == NULL)\n\t\treturn -EBADFD;\n\n\tpr_debug(\"%p %d %d %d\\n\", sk, llcp_sock->target_idx,\n\t\t llcp_sock->dsap, llcp_sock->ssap);\n\n\tuaddr->sa_family = AF_NFC;\n\n\t*len = sizeof(struct sockaddr_nfc_llcp);\n\n\tllcp_addr->dev_idx = llcp_sock->dev->idx;\n\tllcp_addr->target_idx = llcp_sock->target_idx;\n\tllcp_addr->dsap = llcp_sock->dsap;\n\tllcp_addr->ssap = llcp_sock->ssap;\n\tllcp_addr->service_name_len = llcp_sock->service_name_len;\n\tmemcpy(llcp_addr->service_name, llcp_sock->service_name,\n\t       llcp_addr->service_name_len);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-3233",
        "length": 256
    },
    {
        "index": 158954,
        "code": "pp::Rect PDFiumEngine::GetPageScreenRect(int page_index) const {\n  return GetScreenRect(\n      pp::Rect(0, pages_[page_index]->rect().y() - kPageShadowTop,\n               document_size_.width(),\n               pages_[page_index]->rect().height() + kPageShadowTop +\n                   kPageShadowBottom + kPageSeparatorThickness));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-6031",
        "length": 80
    },
    {
        "index": 171892,
        "code": "static void btif_hl_proc_abort_ind(tBTA_HL_MCL_HANDLE mcl_handle){\n\n    BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__ );\n btif_hl_app_cb_t *p_acb;\n    UINT8 i,j;\n\n for (i=0; i<BTA_HL_NUM_APPS; i++)\n {\n        p_acb =BTIF_HL_GET_APP_CB_PTR(i);\n for (j=0; j < BTA_HL_NUM_MCLS ; j++)\n {\n if (p_acb->mcb[j].in_use)\n                BTIF_TRACE_DEBUG(\"btif_hl_find_mcl_idx_using_handle: app_idx=%d,mcl_idx =%d mcl_handle=%d\",i,j,p_acb->mcb[j].mcl_handle);\n if (p_acb->mcb[j].in_use &&\n (p_acb->mcb[j].mcl_handle == mcl_handle))\n {\n                btif_hl_stop_cch_timer(i, j);\n                btif_hl_send_setup_disconnected_cb(i, j);\n                btif_hl_clean_mcl_cb(i, j);\n }\n }\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3839",
        "length": 238
    },
    {
        "index": 20798,
        "code": "static void kvm_put_guest_xcr0(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->guest_xcr0_loaded) {\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\t\tvcpu->guest_xcr0_loaded = 0;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-1601",
        "length": 78
    },
    {
        "index": 56664,
        "code": "static int ext4_freeze(struct super_block *sb)\n{\n\tint error = 0;\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tjournal = EXT4_SB(sb)->s_journal;\n\n\tif (journal) {\n\t\t/* Now we set up the journal barrier. */\n\t\tjbd2_journal_lock_updates(journal);\n\n\t\t/*\n\t\t * Don't clear the needs_recovery flag if we failed to\n\t\t * flush the journal.\n\t\t */\n\t\terror = jbd2_journal_flush(journal);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\n\t\t/* Journal blocked and flushed, clear needs_recovery flag. */\n\t\text4_clear_feature_journal_needs_recovery(sb);\n\t}\n\n\terror = ext4_commit_super(sb, 1);\nout:\n\tif (journal)\n\t\t/* we rely on upper layer to stop further updates */\n\t\tjbd2_journal_unlock_updates(journal);\n\treturn error;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "length": 198
    },
    {
        "index": 1466,
        "code": "static int omode_to_uflags(int8_t mode)\n{\n    int ret = 0;\n\n    switch (mode & 3) {\n    case Oread:\n        ret = O_RDONLY;\n        break;\n    case Ordwr:\n        ret = O_RDWR;\n        break;\n    case Owrite:\n        ret = O_WRONLY;\n        break;\n    case Oexec:\n        ret = O_RDONLY;\n        break;\n    }\n\n    if (mode & Otrunc) {\n        ret |= O_TRUNC;\n    }\n\n    if (mode & Oappend) {\n        ret |= O_APPEND;\n    }\n\n    if (mode & Oexcl) {\n        ret |= O_EXCL;\n    }\n\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2018-19489",
        "length": 147
    },
    {
        "index": 62446,
        "code": "parse_post_op_attr(netdissect_options *ndo,\n                   const uint32_t *dp, int verbose)\n{\n\tND_TCHECK(dp[0]);\n\tif (!EXTRACT_32BITS(&dp[0]))\n\t\treturn (dp + 1);\n\tdp++;\n\tif (verbose) {\n\t\treturn parsefattr(ndo, dp, verbose, 1);\n\t} else\n\t\treturn (dp + (NFSX_V3FATTR / sizeof (uint32_t)));\ntrunc:\n\treturn (NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13005",
        "length": 106
    },
    {
        "index": 15162,
        "code": "PHP_FUNCTION(imagecopyresized)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tif (dstW <= 0 || dstH <= 0 || srcW <= 0 || srcH <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\tRETURN_TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-3412",
        "length": 305
    },
    {
        "index": 37456,
        "code": "static bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 37
    },
    {
        "index": 107018,
        "code": "void QQuickWebView::keyReleaseEvent(QKeyEvent* event)\n{\n    Q_D(QQuickWebView);\n    d->pageView->eventHandler()->handleKeyReleaseEvent(event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-1800",
        "length": 38
    },
    {
        "index": 25618,
        "code": "static int id_fxfd(struct sh_fpu_soft_struct *fregs, int x)\n{\n\tconst int flag[] = { FPSCR_SZ, FPSCR_PR, FPSCR_FR, 0 };\n\tswitch (x & 3) {\n\tcase 3:\n\t\tfxchg(fregs, flag[x >> 2]);\n\t\tbreak;\n\tcase 1:\n\t\tftrv(fregs, x - 1);\n\t\tbreak;\n\tdefault:\n\t\tfsca(fregs, x);\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 105
    },
    {
        "index": 153060,
        "code": "FPDF_BOOL PDFiumEngine::IsDataAvail(FX_FILEAVAIL* param,\n                                    size_t offset, size_t size) {\n  PDFiumEngine::FileAvail* file_avail =\n      static_cast<PDFiumEngine::FileAvail*>(param);\n  return file_avail->loader->IsDataAvailable(offset, size);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5216",
        "length": 71
    },
    {
        "index": 26929,
        "code": "void __init taskstats_init_early(void)\n{\n\tunsigned int i;\n\n\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\n\tfor_each_possible_cpu(i) {\n\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\n\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2011-2494",
        "length": 71
    },
    {
        "index": 159145,
        "code": "DownloadItem::TargetDisposition DownloadItemImpl::GetTargetDisposition() const {\n  return destination_info_.target_disposition;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6033",
        "length": 26
    },
    {
        "index": 14968,
        "code": "ProcCreateWindow(ClientPtr client)\n{\n    WindowPtr pParent, pWin;\n\n    REQUEST(xCreateWindowReq);\n    int len, rc;\n\n    REQUEST_AT_LEAST_SIZE(xCreateWindowReq);\n\n    LEGAL_NEW_RESOURCE(stuff->wid, client);\n    rc = dixLookupWindow(&pParent, stuff->parent, client, DixAddAccess);\n    if (rc != Success)\n        return rc;\n    len = client->req_len - bytes_to_int32(sizeof(xCreateWindowReq));\n    if (Ones(stuff->mask) != len)\n        return BadLength;\n    if (!stuff->width || !stuff->height) {\n        client->errorValue = 0;\n        return BadValue;\n    }\n    pWin = CreateWindow(stuff->wid, pParent, stuff->x,\n                        stuff->y, stuff->width, stuff->height,\n                        stuff->borderWidth, stuff->class,\n                        stuff->mask, (XID *) &stuff[1],\n                        (int) stuff->depth, client, stuff->visual, &rc);\n    if (pWin) {\n        Mask mask = pWin->eventMask;\n\n        pWin->eventMask = 0;    /* subterfuge in case AddResource fails */\n        if (!AddResource(stuff->wid, RT_WINDOW, (void *) pWin))\n            return BadAlloc;\n        pWin->eventMask = mask;\n    }\n    return rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2015-3418",
        "length": 300
    },
    {
        "index": 76928,
        "code": "format_LEARN(const struct ofpact_learn *a, struct ds *s)\n{\n    learn_format(a, s);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-17206",
        "length": 27
    },
    {
        "index": 114719,
        "code": "  virtual void SetUpOnMainThread() {\n    const int kInitialQuotaKilobytes = 5000;\n    const int kTemporaryStorageQuotaMaxSize = kInitialQuotaKilobytes\n        * 1024 * QuotaManager::kPerHostTemporaryPortion;\n    SetTempQuota(\n        kTemporaryStorageQuotaMaxSize,\n        content::BrowserContext::GetQuotaManager(browser()->profile()));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2821",
        "length": 93
    },
    {
        "index": 8978,
        "code": "static void vmxnet3_class_init(ObjectClass *class, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(class);\n    PCIDeviceClass *c = PCI_DEVICE_CLASS(class);\n    VMXNET3Class *vc = VMXNET3_DEVICE_CLASS(class);\n\n    c->realize = vmxnet3_pci_realize;\n    c->exit = vmxnet3_pci_uninit;\n    c->vendor_id = PCI_VENDOR_ID_VMWARE;\n    c->device_id = PCI_DEVICE_ID_VMWARE_VMXNET3;\n    c->revision = PCI_DEVICE_ID_VMWARE_VMXNET3_REVISION;\n    c->romfile = \"efi-vmxnet3.rom\";\n    c->class_id = PCI_CLASS_NETWORK_ETHERNET;\n    c->subsystem_vendor_id = PCI_VENDOR_ID_VMWARE;\n    c->subsystem_id = PCI_DEVICE_ID_VMWARE_VMXNET3;\n    vc->parent_dc_realize = dc->realize;\n    dc->realize = vmxnet3_realize;\n    dc->desc = \"VMWare Paravirtualized Ethernet v3\";\n    dc->reset = vmxnet3_qdev_reset;\n    dc->vmsd = &vmstate_vmxnet3;\n    dc->props = vmxnet3_properties;\n    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-6836",
        "length": 286
    },
    {
        "index": 89800,
        "code": "static void CreatePCPMap(pcp_info_t *pcp_msg_info)\n{\n\tint r;\n\n\tif (pcp_msg_info->is_fw)\n\t\tr = CreatePCPMap_FW(pcp_msg_info);\n\telse\n\t\tr = CreatePCPMap_NAT(pcp_msg_info);\n\tpcp_msg_info->result_code = r;\n\tsyslog(r == PCP_SUCCESS ? LOG_INFO : LOG_ERR,\n\t      \"PCP MAP: %s mapping %s %hu->%s:%hu '%s'\",\n\t       r == PCP_SUCCESS ? \"added\" : \"failed to add\",\n\t       (pcp_msg_info->protocol==IPPROTO_TCP)?\"TCP\":\"UDP\",\n\t       pcp_msg_info->ext_port,\n\t       pcp_msg_info->mapped_str,\n\t       pcp_msg_info->int_port,\n\t       pcp_msg_info->desc);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12111",
        "length": 171
    },
    {
        "index": 140842,
        "code": "void GLES2DecoderImpl::LoseContext(uint32 reset_status) {\n  if (reset_status_ != GL_NO_ERROR) {\n    return;\n  }\n\n  if (workarounds().use_virtualized_gl_contexts) {\n    if (reset_status == GL_GUILTY_CONTEXT_RESET_ARB) {\n      reset_status = GL_UNKNOWN_CONTEXT_RESET_ARB;\n    }\n  } else if (reset_status == GL_UNKNOWN_CONTEXT_RESET_ARB &&\n             IsRobustnessSupported()) {\n    GLenum driver_status = glGetGraphicsResetStatusARB();\n    if (driver_status == GL_GUILTY_CONTEXT_RESET_ARB ||\n        driver_status == GL_INNOCENT_CONTEXT_RESET_ARB) {\n      reset_status = driver_status;\n    }\n  }\n\n  reset_status_ = reset_status;\n  current_decoder_error_ = error::kLostContext;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 168
    },
    {
        "index": 12522,
        "code": "SPR_NameToID(struct rx_call *call, namelist *aname, idlist *aid)\n{\n    afs_int32 code;\n\n    code = nameToID(call, aname, aid);\n    osi_auditU(call, PTS_NmToIdEvent, code, AUD_END);\n    ViceLog(125, (\"PTS_NameToID: code %d\\n\", code));\n    return code;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-2860",
        "length": 85
    },
    {
        "index": 180225,
        "code": " SPL_METHOD(SplFileObject, valid)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgets()\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5770",
        "length": 129
    },
    {
        "index": 72689,
        "code": "static jas_iccattrvalinfo_t *jas_iccattrvalinfo_lookup(jas_iccsig_t type)\n{\n\tjas_iccattrvalinfo_t *info;\n\tinfo = jas_iccattrvalinfos;\n\tfor (info = jas_iccattrvalinfos; info->type; ++info) {\n\t\tif (info->type == type) {\n\t\t\treturn info;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-9557",
        "length": 89
    },
    {
        "index": 84773,
        "code": "static int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing(NULL))\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what audit expects.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1091",
        "length": 295
    },
    {
        "index": 114115,
        "code": "on_error(void *user_data, Evas_Object *webview, void *event_info)\n{\n    Eina_Strbuf* buffer;\n    const Ewk_Error *error = (const Ewk_Error *)event_info;\n\n    /* This is a cancellation, do not display the error page */\n    if (ewk_error_cancellation_get(error))\n        return;\n\n    buffer = eina_strbuf_new();\n    eina_strbuf_append_printf(buffer, \"<html><body><div style=\\\"color:#ff0000\\\">ERROR!</div><br><div>Code: %d<br>Description: %s<br>URL: %s</div></body</html>\",\n        ewk_error_code_get(error), ewk_error_description_get(error), ewk_error_url_get(error));\n\n    ewk_view_html_string_load(webview, eina_strbuf_string_get(buffer), 0, ewk_error_url_get(error));\n    eina_strbuf_free(buffer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2844",
        "length": 195
    },
    {
        "index": 140559,
        "code": "void SpdyProxyClientSocket::OnClose(int status)  {\n  was_ever_used_ = spdy_stream_->WasEverUsed();\n  spdy_stream_.reset();\n\n  bool connecting = next_state_ != STATE_DISCONNECTED &&\n      next_state_ < STATE_OPEN;\n  if (next_state_ == STATE_OPEN)\n    next_state_ = STATE_CLOSED;\n  else\n    next_state_ = STATE_DISCONNECTED;\n\n  base::WeakPtr<SpdyProxyClientSocket> weak_ptr = weak_factory_.GetWeakPtr();\n  CompletionCallback write_callback = write_callback_;\n  write_callback_.Reset();\n  write_buffer_len_ = 0;\n\n  if (connecting) {\n    DCHECK(!read_callback_.is_null());\n    CompletionCallback read_callback = read_callback_;\n    read_callback_.Reset();\n    read_callback.Run(status);\n  } else if (!read_callback_.is_null()) {\n    OnDataReceived(scoped_ptr<SpdyBuffer>());\n  }\n  if (weak_ptr.get() && !write_callback.is_null())\n    write_callback.Run(ERR_CONNECTION_CLOSED);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1229",
        "length": 218
    },
    {
        "index": 42227,
        "code": "int vhost_log_access_ok(struct vhost_dev *dev)\n{\n\treturn memory_access_ok(dev, dev->memory, 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2015-6252",
        "length": 29
    },
    {
        "index": 71403,
        "code": "MagickExport ExceptionInfo *AcquireExceptionInfo(void)\n{\n  ExceptionInfo\n    *exception;\n\n  exception=(ExceptionInfo *) AcquireMagickMemory(sizeof(*exception));\n  if (exception == (ExceptionInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  InitializeExceptionInfo(exception);\n  exception->relinquish=MagickTrue;\n  return(exception);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10067",
        "length": 84
    },
    {
        "index": 116046,
        "code": "string16 GetUrlWithLang(const GURL& url) {\n  return ASCIIToUTF16(google_util::AppendGoogleLocaleParam(url).spec());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3104",
        "length": 34
    },
    {
        "index": 78469,
        "code": "_iasecc_sm_update_binary(struct sc_card *card, unsigned int offs,\n\t\tconst unsigned char *buff, size_t count)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tconst struct sc_acl_entry *entry = NULL;\n\tint rv;\n\n\tif (count == 0)\n\t\treturn SC_SUCCESS;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx,\n\t       \"iasecc_sm_read_binary() card:%p offs:%i count:%\"SC_FORMAT_LEN_SIZE_T\"u \",\n\t       card, offs, count);\n\tsc_print_cache(card);\n\n\tif (card->cache.valid && card->cache.current_ef)   {\n\t\tentry = sc_file_get_acl_entry(card->cache.current_ef, SC_AC_OP_UPDATE);\n\t\tif (!entry)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_OBJECT_NOT_FOUND, \"iasecc_sm_update() 'UPDATE' ACL not present\");\n\n\t\tsc_log(ctx, \"UPDATE method/reference %X/%X\", entry->method, entry->key_ref);\n\t\tif (entry->method == SC_AC_SCB && (entry->key_ref & IASECC_SCB_METHOD_SM))   {\n\t\t\tunsigned char se_num = entry->method == SC_AC_SCB ? entry->key_ref & IASECC_SCB_METHOD_MASK_REF : 0;\n\n\t\t\trv = iasecc_sm_update_binary(card, se_num, offs, buff, count);\n\t\t\tLOG_FUNC_RETURN(ctx, rv);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 302
    },
    {
        "index": 95821,
        "code": "void FS_Rename( const char *from, const char *to ) {\n\tchar            *from_ospath, *to_ospath;\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\" );\n\t}\n\n\n\tfrom_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, from );\n\tto_ospath = FS_BuildOSPath( fs_homepath->string, fs_gamedir, to );\n\n\tif ( fs_debug->integer ) {\n\t\tCom_Printf( \"FS_Rename: %s --> %s\\n\", from_ospath, to_ospath );\n\t}\n\n\tFS_CheckFilenameIsMutable( to_ospath, __func__ );\n\n\trename(from_ospath, to_ospath);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 161
    },
    {
        "index": 71421,
        "code": "MagickExport MagickBooleanType ThrowException(ExceptionInfo *exception,\n  const ExceptionType severity,const char *reason,const char *description)\n{\n  register ExceptionInfo\n    *p;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  LockSemaphoreInfo(exception->semaphore);\n  p=(ExceptionInfo *) GetLastValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  if ((p != (ExceptionInfo *) NULL) && (p->severity == severity) &&\n      (LocaleCompare(exception->reason,reason) == 0) &&\n      (LocaleCompare(exception->description,description) == 0))\n    {\n      UnlockSemaphoreInfo(exception->semaphore);\n      return(MagickTrue);\n    }\n  p=(ExceptionInfo *) AcquireMagickMemory(sizeof(*p));\n  if (p == (ExceptionInfo *) NULL)\n    {\n      UnlockSemaphoreInfo(exception->semaphore);\n      ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(p,0,sizeof(*p));\n  p->severity=severity;\n  if (reason != (const char *) NULL)\n    p->reason=ConstantString(reason);\n  if (description != (const char *) NULL)\n    p->description=ConstantString(description);\n  p->signature=MagickSignature;\n  (void) AppendValueToLinkedList((LinkedListInfo *) exception->exceptions,p);\n  if (p->severity >= exception->severity)\n    {\n      exception->severity=p->severity;\n      exception->reason=p->reason;\n      exception->description=p->description;\n    }\n  UnlockSemaphoreInfo(exception->semaphore);\n  return(MagickTrue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10067",
        "length": 351
    },
    {
        "index": 42793,
        "code": "static char *ask_helper(const char *msg, void *args, bool password)\n{\n    GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(g_wnd_assistant),\n            GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,\n            GTK_MESSAGE_QUESTION,\n            GTK_BUTTONS_OK_CANCEL,\n            \"%s\", msg);\n    char *tagged_msg = tag_url(msg, \"\\n\");\n    gtk_dialog_set_default_response(GTK_DIALOG(dialog), GTK_RESPONSE_OK);\n    gtk_message_dialog_set_markup(GTK_MESSAGE_DIALOG(dialog), tagged_msg);\n    free(tagged_msg);\n\n    GtkWidget *vbox = gtk_dialog_get_content_area(GTK_DIALOG(dialog));\n    GtkWidget *textbox = gtk_entry_new();\n    /* gtk_entry_set_editable(GTK_ENTRY(textbox), TRUE);\n     * is not available in gtk3, so please use the highlevel\n     * g_object_set\n     */\n    g_object_set(G_OBJECT(textbox), \"editable\", TRUE, NULL);\n    g_signal_connect(textbox, \"activate\", G_CALLBACK(gtk_entry_emit_dialog_response_ok), dialog);\n\n    if (password)\n        gtk_entry_set_visibility(GTK_ENTRY(textbox), FALSE);\n\n    gtk_box_pack_start(GTK_BOX(vbox), textbox, TRUE, TRUE, 0);\n    gtk_widget_show(textbox);\n\n    char *response = NULL;\n    if (gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_OK)\n    {\n        const char *text = gtk_entry_get_text(GTK_ENTRY(textbox));\n        response = xstrdup(text);\n    }\n\n    gtk_widget_destroy(textbox);\n    gtk_widget_destroy(dialog);\n\n    const char *log_response = \"\";\n    if (response)\n        log_response = password ? \"********\" : response;\n\n    log_request_response_communication(msg, log_response, (struct analyze_event_data *)args);\n    return response ? response : xstrdup(\"\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5302",
        "length": 373
    },
    {
        "index": 1441,
        "code": "ct_build_natseqadj(const struct nf_conntrack *ct, struct nethdr *n)\n{\n\tstruct nta_attr_natseqadj data = {\n\t\t.orig_seq_correction_pos =\n\t\thtonl(nfct_get_attr_u32(ct, ATTR_ORIG_NAT_SEQ_CORRECTION_POS)),\n\t\t.orig_seq_offset_before = \n\t\thtonl(nfct_get_attr_u32(ct, ATTR_ORIG_NAT_SEQ_OFFSET_BEFORE)),\n\t\t.orig_seq_offset_after =\n\t\thtonl(nfct_get_attr_u32(ct, ATTR_ORIG_NAT_SEQ_OFFSET_AFTER)),\n\t\t.repl_seq_correction_pos = \n\t\thtonl(nfct_get_attr_u32(ct, ATTR_REPL_NAT_SEQ_CORRECTION_POS)),\n\t\t.repl_seq_offset_before =\n\t\thtonl(nfct_get_attr_u32(ct, ATTR_REPL_NAT_SEQ_OFFSET_BEFORE)),\n\t\t.repl_seq_offset_after = \n\t\thtonl(nfct_get_attr_u32(ct, ATTR_REPL_NAT_SEQ_OFFSET_AFTER))\n\t};\n\taddattr(n, NTA_NAT_SEQ_ADJ, &data, sizeof(struct nta_attr_natseqadj));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2015-6496",
        "length": 243
    },
    {
        "index": 62448,
        "code": "parse_sattr3(netdissect_options *ndo,\n             const uint32_t *dp, struct nfsv3_sattr *sa3)\n{\n\tND_TCHECK(dp[0]);\n\tsa3->sa_modeset = EXTRACT_32BITS(dp);\n\tdp++;\n\tif (sa3->sa_modeset) {\n\t\tND_TCHECK(dp[0]);\n\t\tsa3->sa_mode = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t}\n\n\tND_TCHECK(dp[0]);\n\tsa3->sa_uidset = EXTRACT_32BITS(dp);\n\tdp++;\n\tif (sa3->sa_uidset) {\n\t\tND_TCHECK(dp[0]);\n\t\tsa3->sa_uid = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t}\n\n\tND_TCHECK(dp[0]);\n\tsa3->sa_gidset = EXTRACT_32BITS(dp);\n\tdp++;\n\tif (sa3->sa_gidset) {\n\t\tND_TCHECK(dp[0]);\n\t\tsa3->sa_gid = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t}\n\n\tND_TCHECK(dp[0]);\n\tsa3->sa_sizeset = EXTRACT_32BITS(dp);\n\tdp++;\n\tif (sa3->sa_sizeset) {\n\t\tND_TCHECK(dp[0]);\n\t\tsa3->sa_size = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t}\n\n\tND_TCHECK(dp[0]);\n\tsa3->sa_atimetype = EXTRACT_32BITS(dp);\n\tdp++;\n\tif (sa3->sa_atimetype == NFSV3SATTRTIME_TOCLIENT) {\n\t\tND_TCHECK(dp[1]);\n\t\tsa3->sa_atime.nfsv3_sec = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t\tsa3->sa_atime.nfsv3_nsec = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t}\n\n\tND_TCHECK(dp[0]);\n\tsa3->sa_mtimetype = EXTRACT_32BITS(dp);\n\tdp++;\n\tif (sa3->sa_mtimetype == NFSV3SATTRTIME_TOCLIENT) {\n\t\tND_TCHECK(dp[1]);\n\t\tsa3->sa_mtime.nfsv3_sec = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t\tsa3->sa_mtime.nfsv3_nsec = EXTRACT_32BITS(dp);\n\t\tdp++;\n\t}\n\n\treturn dp;\ntrunc:\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13005",
        "length": 503
    },
    {
        "index": 76539,
        "code": "is_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-17942",
        "length": 26
    },
    {
        "index": 120337,
        "code": "  void ReceivedAckPreventDefaulted() {\n    ReceivedAckImpl(true);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2887",
        "length": 19
    },
    {
        "index": 36378,
        "code": "static void terminate_walk(struct nameidata *nd)\n{\n\tif (!(nd->flags & LOOKUP_RCU)) {\n\t\tpath_put(&nd->path);\n\t} else {\n\t\tnd->flags &= ~LOOKUP_RCU;\n\t\tif (!(nd->flags & LOOKUP_ROOT))\n\t\t\tnd->root.mnt = NULL;\n\t\trcu_read_unlock();\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2014-5045",
        "length": 78
    },
    {
        "index": 91122,
        "code": "int ip_mc_validate_source(struct sk_buff *skb, __be32 daddr, __be32 saddr,\n\t\t\t  u8 tos, struct net_device *dev,\n\t\t\t  struct in_device *in_dev, u32 *itag)\n{\n\tint err;\n\n\t/* Primary sanity checks. */\n\tif (!in_dev)\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_multicast(saddr) || ipv4_is_lbcast(saddr) ||\n\t    skb->protocol != htons(ETH_P_IP))\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_loopback(saddr) && !IN_DEV_ROUTE_LOCALNET(in_dev))\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_zeronet(saddr)) {\n\t\tif (!ipv4_is_local_multicast(daddr) &&\n\t\t    ip_hdr(skb)->protocol != IPPROTO_IGMP)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\terr = fib_validate_source(skb, saddr, 0, tos, 0, dev,\n\t\t\t\t\t  in_dev, itag);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-10638",
        "length": 225
    },
    {
        "index": 72829,
        "code": "static int jp2_getct(int colorspace, int type, int assoc)\n{\n\tif (type == 1 && assoc == 0) {\n\t\treturn JAS_IMAGE_CT_OPACITY;\n\t}\n\tif (type == 0 && assoc >= 1 && assoc <= 65534) {\n\t\tswitch (colorspace) {\n\t\tcase JAS_CLRSPC_FAM_RGB:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_RGB_R:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_G:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_RGB_B:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_YCBCR:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_YCBCR_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_Y);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CB:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CB);\n\t\t\t\tbreak;\n\t\t\tcase JP2_CDEF_YCBCR_CR:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_YCBCR_CR);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase JAS_CLRSPC_FAM_GRAY:\n\t\t\tswitch (assoc) {\n\t\t\tcase JP2_CDEF_GRAY_Y:\n\t\t\t\treturn JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn JAS_IMAGE_CT_COLOR(assoc - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn JAS_IMAGE_CT_UNKNOWN;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-9557",
        "length": 386
    },
    {
        "index": 104911,
        "code": "PP_Bool GetLocation(PP_Resource resource, PP_Rect* location) {\n  scoped_refptr<PPB_Widget_Impl> widget(\n      Resource::GetAs<PPB_Widget_Impl>(resource));\n  return BoolToPPBool(widget && widget->GetLocation(location));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2789",
        "length": 55
    },
    {
        "index": 161765,
        "code": "bool PlatformSensorFusion::IsSuspended() {\n  for (auto& client : clients_) {\n    if (!client.IsSuspended())\n      return false;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-6057",
        "length": 41
    },
    {
        "index": 15086,
        "code": "PHP_MINFO_FUNCTION(fileinfo)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"fileinfo support\", \"enabled\");\n\tphp_info_print_table_row(2, \"version\", PHP_FILEINFO_VERSION);\n\tphp_info_print_table_end();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-3412",
        "length": 58
    },
    {
        "index": 113843,
        "code": "void AudioManagerBase::Init() {\n  base::AutoLock lock(audio_thread_lock_);\n  DCHECK(!audio_thread_.get());\n  audio_thread_.reset(new base::Thread(\"AudioThread\"));\n  CHECK(audio_thread_->Start());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 47
    },
    {
        "index": 26034,
        "code": "perf_cgroup_from_task(struct task_struct *task)\n{\n\treturn container_of(task_subsys_state(task, perf_subsys_id),\n\t\t\tstruct perf_cgroup, css);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 36
    },
    {
        "index": 18342,
        "code": "dump_config() {\n    g_hash_table_foreach(uzbl.comm.proto_var, dump_var_hash, NULL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2010-0011",
        "length": 25
    },
    {
        "index": 153757,
        "code": "GLboolean GLES2Implementation::IsQueryEXT(GLuint id) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix() << \"] IsQueryEXT(\" << id << \")\");\n\n  return query_tracker_->GetQuery(id) != nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 57
    },
    {
        "index": 61677,
        "code": "xml_parse_file_flags(struct xar *xar, const char *name)\n{\n\tconst char *flag = NULL;\n\n\tif (strcmp(name, \"UserNoDump\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_NODUMP;\n\t\tflag = \"nodump\";\n\t}\n\telse if (strcmp(name, \"UserImmutable\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_IMMUTABLE;\n\t\tflag = \"uimmutable\";\n\t}\n\telse if (strcmp(name, \"UserAppend\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_APPEND;\n\t\tflag = \"uappend\";\n\t}\n\telse if (strcmp(name, \"UserOpaque\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_OPAQUE;\n\t\tflag = \"opaque\";\n\t}\n\telse if (strcmp(name, \"UserNoUnlink\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_NOUNLINK;\n\t\tflag = \"nouunlink\";\n\t}\n\telse if (strcmp(name, \"SystemArchived\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_ARCHIVED;\n\t\tflag = \"archived\";\n\t}\n\telse if (strcmp(name, \"SystemImmutable\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_IMMUTABLE;\n\t\tflag = \"simmutable\";\n\t}\n\telse if (strcmp(name, \"SystemAppend\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_APPEND;\n\t\tflag = \"sappend\";\n\t}\n\telse if (strcmp(name, \"SystemNoUnlink\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_NOUNLINK;\n\t\tflag = \"nosunlink\";\n\t}\n\telse if (strcmp(name, \"SystemSnapshot\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_SNAPSHOT;\n\t\tflag = \"snapshot\";\n\t}\n\n\tif (flag == NULL)\n\t\treturn (0);\n\txar->file->has |= HAS_FFLAGS;\n\tif (archive_strlen(&(xar->file->fflags_text)) > 0)\n\t\tarchive_strappend_char(&(xar->file->fflags_text), ',');\n\tarchive_strcat(&(xar->file->fflags_text), flag);\n\treturn (1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-14166",
        "length": 481
    },
    {
        "index": 99935,
        "code": "PluginHost *PluginHost::Singleton() {\n  if (singleton_.get() == NULL) {\n    singleton_ = new PluginHost();\n  }\n\n  DCHECK(singleton_.get() != NULL);\n  return singleton_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 46
    },
    {
        "index": 3451,
        "code": "unhook_all_plugin (struct t_weechat_plugin *plugin)\n{\n    int type;\n    struct t_hook *ptr_hook, *next_hook;\n    \n    for (type = 0; type < HOOK_NUM_TYPES; type++)\n    {\n        ptr_hook = weechat_hooks[type];\n        while (ptr_hook)\n        {\n            next_hook = ptr_hook->next_hook;\n            if (ptr_hook->plugin == plugin)\n                unhook (ptr_hook);\n            ptr_hook = next_hook;\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1428",
        "length": 109
    },
    {
        "index": 144948,
        "code": "void RenderWidgetHostViewAura::OnHostMovedInPixels(\n    const aura::WindowTreeHost* host,\n    const gfx::Point& new_origin_in_pixels) {\n  TRACE_EVENT1(\"ui\", \"RenderWidgetHostViewAura::OnHostMovedInPixels\",\n               \"new_origin_in_pixels\", new_origin_in_pixels.ToString());\n\n  UpdateScreenInfo(window_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-1615",
        "length": 76
    },
    {
        "index": 144793,
        "code": "bool TabLifecycleUnitSource::TabLifecycleUnit::IsDiscarded() const {\n  return IsDiscardedOrPendingDiscard(GetState());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1613",
        "length": 30
    },
    {
        "index": 36281,
        "code": "SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)\n{\n\treturn sys_mknodat(AT_FDCWD, filename, mode, dev);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2014-5045",
        "length": 45
    },
    {
        "index": 59395,
        "code": "namePop(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *ret;\n\n    if ((ctxt == NULL) || (ctxt->nameNr <= 0))\n        return (NULL);\n    ctxt->nameNr--;\n    if (ctxt->nameNr > 0)\n        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];\n    else\n        ctxt->name = NULL;\n    ret = ctxt->nameTab[ctxt->nameNr];\n    ctxt->nameTab[ctxt->nameNr] = NULL;\n    return (ret);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-16932",
        "length": 118
    },
    {
        "index": 158849,
        "code": "void Browser::RendererResponsive(\n    WebContents* source,\n    content::RenderWidgetHost* render_widget_host) {\n  TabDialogs::FromWebContents(source)->HideHungRendererDialog(\n      render_widget_host);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17476",
        "length": 46
    },
    {
        "index": 107094,
        "code": "    LoadStartedCatcher(QQuickWebView* webView)\n        : m_webView(webView)\n    {\n        connect(m_webView, SIGNAL(loadingChanged(QWebLoadRequest*)), this, SLOT(onLoadingChanged(QWebLoadRequest*)));\n    }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-1800",
        "length": 52
    },
    {
        "index": 140068,
        "code": "void HTMLMediaElement::removedFrom(ContainerNode* insertionPoint) {\n  BLINK_MEDIA_LOG << \"removedFrom(\" << (void*)this << \", \" << insertionPoint\n                  << \")\";\n\n  HTMLElement::removedFrom(insertionPoint);\n  if (insertionPoint->inActiveDocument()) {\n    updateControlsVisibility();\n    if (m_networkState > kNetworkEmpty)\n      pauseInternal();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-1213",
        "length": 85
    },
    {
        "index": 185302,
        "code": " static void reflectUrlStringAttributeAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)\n {\n     v8::Local<v8::Object> holder = info.Holder();\n    Element* impl = V8Element::toImpl(holder);\n     V8StringResource<> cppValue = v8Value;\n     if (!cppValue.prepare())\n         return;\n    impl->setAttribute(HTMLNames::reflecturlstringattributeAttr, cppValue);\n}\n",
        "line": "    Element* impl = V8Element::toImpl(holder);\n",
        "label": 1,
        "cwe": "CWE-189",
        "cve": "CVE-2014-7901",
        "length": 107
    },
    {
        "index": 30210,
        "code": "struct ftrace_rec_iter *ftrace_rec_iter_next(struct ftrace_rec_iter *iter)\n{\n\titer->index++;\n\n\tif (iter->index >= iter->pg->index) {\n\t\titer->pg = iter->pg->next;\n\t\titer->index = 0;\n\n\t\t/* Could have empty pages */\n\t\twhile (iter->pg && !iter->pg->index)\n\t\t\titer->pg = iter->pg->next;\n\t}\n\n\tif (!iter->pg)\n\t\treturn NULL;\n\n\treturn iter;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-3301",
        "length": 106
    },
    {
        "index": 13971,
        "code": "gsicc_init_hash_cs(cmm_profile_t *picc_profile, gs_gstate *pgs)\n{\n    if ( !(picc_profile->hash_is_valid) ) {\n        gsicc_get_icc_buff_hash(picc_profile->buffer, &(picc_profile->hashcode),\n                                picc_profile->buffer_size);\n        picc_profile->hash_is_valid = true;\n    }\n    gsicc_set_default_cs_value(picc_profile, pgs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-7976",
        "length": 95
    },
    {
        "index": 102883,
        "code": "void RenderMenuList::setTextFromOption(int optionIndex)\n{\n    HTMLSelectElement* select = toHTMLSelectElement(node());\n    const Vector<HTMLElement*>& listItems = select->listItems();\n    int size = listItems.size();\n\n    int i = select->optionToListIndex(optionIndex);\n    String text = \"\";\n    if (i >= 0 && i < size) {\n        Element* element = listItems[i];\n        if (element->hasTagName(optionTag)) {\n            text = toHTMLOptionElement(element)->textIndentedToRespectGroupLabel();\n            m_optionStyle = element->renderStyle();\n        }\n    }\n\n    setText(text.stripWhiteSpace());\n    didUpdateActiveOption(optionIndex);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2830",
        "length": 147
    },
    {
        "index": 71199,
        "code": "static int kvm_debugfs_open(struct inode *inode, struct file *file,\n\t\t\t   int (*get)(void *, u64 *), int (*set)(void *, u64),\n\t\t\t   const char *fmt)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)\n\t\t\t\t\t  inode->i_private;\n\n\t/* The debugfs files are a reference to the kvm struct which\n\t * is still valid when kvm_destroy_vm is called.\n\t * To avoid the race between open and the removal of the debugfs\n\t * directory we test against the users count.\n\t */\n\tif (!atomic_add_unless(&stat_data->kvm->users_count, 1, 0))\n\t\treturn -ENOENT;\n\n\tif (simple_attr_open(inode, file, get, set, fmt)) {\n\t\tkvm_put_kvm(stat_data->kvm);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10150",
        "length": 187
    },
    {
        "index": 86221,
        "code": "static int __init i8042_init(void)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tdbg_init();\n\n\terr = i8042_platform_init();\n\tif (err)\n\t\treturn err;\n\n\terr = i8042_controller_check();\n\tif (err)\n\t\tgoto err_platform_exit;\n\n\tpdev = platform_create_bundle(&i8042_driver, i8042_probe, NULL, 0, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\terr = PTR_ERR(pdev);\n\t\tgoto err_platform_exit;\n\t}\n\n\tbus_register_notifier(&serio_bus, &i8042_kbd_bind_notifier_block);\n\tpanic_blink = i8042_panic_blink;\n\n\treturn 0;\n\n err_platform_exit:\n\ti8042_platform_exit();\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18079",
        "length": 156
    },
    {
        "index": 1169,
        "code": "void JBIG2Bitmap::duplicateRow(int yDest, int ySrc) {\n  memcpy(data + yDest * line, data + ySrc * line, line);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 37
    },
    {
        "index": 108685,
        "code": "bool PPB_URLLoader_Impl::RecordUploadProgress() const {\n  return request_data_.record_upload_progress;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2012-5140",
        "length": 24
    },
    {
        "index": 8236,
        "code": "static void v9fs_statfs(void *opaque)\n{\n    int32_t fid;\n    ssize_t retval = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    struct statfs stbuf;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    retval = pdu_unmarshal(pdu, offset, \"d\", &fid);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_statfs(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval = v9fs_fill_statfs(s, pdu, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-8577",
        "length": 247
    },
    {
        "index": 132768,
        "code": "void PepperVideoRenderer2D::ReturnBuffer(webrtc::DesktopFrame* buffer) {\n  DCHECK(CalledOnValidThread());\n\n  if (buffer->size().width() >= clip_area_.width() &&\n      buffer->size().height() >= clip_area_.height()) {\n    software_video_renderer_->DrawBuffer(buffer);\n  } else {\n    FreeBuffer(buffer);\n    AllocateBuffers();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 83
    },
    {
        "index": 56173,
        "code": "static int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *l2cap_sk;\n\tstruct l2cap_conn *conn;\n\tstruct rfcomm_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tswitch (rfcomm_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = RFCOMM_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE | RFCOMM_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rfcomm_pi(sk)->role_switch)\n\t\t\topt |= RFCOMM_LM_MASTER;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase RFCOMM_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t\t\t\t!rfcomm_pi(sk)->dlc->defer_setup) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;\n\t\tconn = l2cap_pi(l2cap_sk)->chan->conn;\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8956",
        "length": 511
    },
    {
        "index": 114175,
        "code": "void ChromeContentClient::SetActiveURL(const GURL& url) {\n  child_process_logging::SetActiveURL(url);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 24
    },
    {
        "index": 73452,
        "code": "MagickExport Cache DestroyPixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count--;\n  if (cache_info->reference_count != 0)\n    {\n      UnlockSemaphoreInfo(cache_info->semaphore);\n      return((Cache) NULL);\n    }\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"destroy %s\",\n        cache_info->filename);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  RelinquishPixelCachePixels(cache_info);\n  if (cache_info->server_info != (DistributeCacheInfo *) NULL)\n    cache_info->server_info=DestroyDistributeCacheInfo((DistributeCacheInfo *)\n      cache_info->server_info);\n  if (cache_info->nexus_info != (NexusInfo **) NULL)\n    cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,\n      cache_info->number_threads);\n  if (cache_info->random_info != (RandomInfo *) NULL)\n    cache_info->random_info=DestroyRandomInfo(cache_info->random_info);\n  if (cache_info->file_semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&cache_info->file_semaphore);\n  if (cache_info->semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&cache_info->semaphore);\n  cache_info->signature=(~MagickSignature);\n  cache_info=(CacheInfo *) RelinquishMagickMemory(cache_info);\n  cache=(Cache) NULL;\n  return(cache);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-7539",
        "length": 438
    },
    {
        "index": 13820,
        "code": "ZEND_API int zend_parse_parameters_ex(int flags, int num_args TSRMLS_DC, const char *type_spec, ...) /* {{{ */\n{\n\tva_list va;\n\tint retval;\n\n\tRETURN_IF_ZERO_ARGS(num_args, type_spec, flags & ZEND_PARSE_PARAMS_QUIET);\n\n\tva_start(va, type_spec);\n\tretval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);\n\tva_end(va);\n\n\treturn retval;\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9137",
        "length": 92
    },
    {
        "index": 121186,
        "code": "bool HTMLInputElement::isRequiredFormControl() const\n{\n    return m_inputType->supportsRequired() && isRequired();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2871",
        "length": 25
    },
    {
        "index": 67800,
        "code": "void MD5_Final(unsigned char digest[16], MD5_CTX *ctx) {\n  unsigned count;\n  unsigned char *p;\n  uint32_t *a;\n\n  count = (ctx->bits[0] >> 3) & 0x3F;\n\n  p = ctx->in + count;\n  *p++ = 0x80;\n  count = 64 - 1 - count;\n  if (count < 8) {\n    memset(p, 0, count);\n    byteReverse(ctx->in, 16);\n    MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n    memset(ctx->in, 0, 56);\n  } else {\n    memset(p, 0, count - 8);\n  }\n  byteReverse(ctx->in, 14);\n\n  a = (uint32_t *) ctx->in;\n  a[14] = ctx->bits[0];\n  a[15] = ctx->bits[1];\n\n  MD5Transform(ctx->buf, (uint32_t *) ctx->in);\n  byteReverse((unsigned char *) ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset((char *) ctx, 0, sizeof(*ctx));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-7185",
        "length": 265
    },
    {
        "index": 83649,
        "code": "static int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-8099",
        "length": 203
    },
    {
        "index": 123626,
        "code": "void InspectorPageAgent::setContinuousPaintingEnabled(ErrorString* errorString, bool enabled)\n{\n    m_state->setBoolean(PageAgentState::pageAgentContinuousPaintingEnabled, enabled);\n    if (enabled && !forceCompositingMode(errorString))\n        return;\n    m_client->setContinuousPaintingEnabled(enabled && !m_deviceMetricsOverridden);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0892",
        "length": 76
    },
    {
        "index": 54762,
        "code": "static int snd_usbmidi_detect_roland(struct snd_usb_midi *umidi,\n\t\t\t\t     struct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tu8 *cs_desc;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\t/*\n\t * Some devices have a descriptor <06 24 F1 02 <inputs> <outputs>>,\n\t * some have standard class descriptors, or both kinds, or neither.\n\t */\n\tfor (cs_desc = hostif->extra;\n\t     cs_desc < hostif->extra + hostif->extralen && cs_desc[0] >= 2;\n\t     cs_desc += cs_desc[0]) {\n\t\tif (cs_desc[0] >= 6 &&\n\t\t    cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t    cs_desc[2] == 0xf1 &&\n\t\t    cs_desc[3] == 0x02) {\n\t\t\tendpoint->in_cables  = (1 << cs_desc[4]) - 1;\n\t\t\tendpoint->out_cables = (1 << cs_desc[5]) - 1;\n\t\t\treturn snd_usbmidi_detect_endpoints(umidi, endpoint, 1);\n\t\t} else if (cs_desc[0] >= 7 &&\n\t\t\t   cs_desc[1] == USB_DT_CS_INTERFACE &&\n\t\t\t   cs_desc[2] == UAC_HEADER) {\n\t\t\treturn snd_usbmidi_get_ms_info(umidi, endpoint);\n\t\t}\n\t}\n\n\treturn -ENODEV;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-2384",
        "length": 337
    },
    {
        "index": 56609,
        "code": "int ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-8839",
        "length": 211
    },
    {
        "index": 99921,
        "code": "NPError NPN_PostURLNotify(NPP id,\n                          const char* url,\n                          const char* target,\n                          uint32 len,\n                          const char* buf,\n                          NPBool file,\n                          void* notify_data) {\n  return PostURLNotify(id, url, target, len, buf, file, true, notify_data);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 70
    },
    {
        "index": 65047,
        "code": "static int check_reg_arg(struct bpf_reg_state *regs, u32 regno,\n\t\t\t enum reg_arg_type t)\n{\n\tif (regno >= MAX_BPF_REG) {\n\t\tverbose(\"R%d is invalid\\n\", regno);\n\t\treturn -EINVAL;\n\t}\n\n\tif (t == SRC_OP) {\n\t\t/* check whether register used as source operand can be read */\n\t\tif (regs[regno].type == NOT_INIT) {\n\t\t\tverbose(\"R%d !read_ok\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t} else {\n\t\t/* check whether register used as dest operand can be written to */\n\t\tif (regno == BPF_REG_FP) {\n\t\t\tverbose(\"frame pointer is read only\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == DST_OP)\n\t\t\tmark_reg_unknown_value(regs, regno);\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-9150",
        "length": 197
    },
    {
        "index": 136954,
        "code": "String HTMLInputElement::ResultForDialogSubmit() {\n  return input_type_->ResultForDialogSubmit();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 22
    },
    {
        "index": 49592,
        "code": "static void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ffs_data *ffs = req->context;\n\n\tcomplete_all(&ffs->ep0req_completion);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7912",
        "length": 46
    },
    {
        "index": 73192,
        "code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8860",
        "length": 111
    },
    {
        "index": 82853,
        "code": "struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(RBuffer * buf, bool verbose) {\n\tstruct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->kv = sdb_new0 ();\n\tbin->b = r_buf_new ();\n\tbin->verbose = verbose;\n\tbin->size = buf->length;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, bin->size)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\tif (!bin_pe_init (bin)) {\n\t\treturn PE_(r_bin_pe_free)(bin);\n\t}\n\treturn bin;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-11379",
        "length": 156
    },
    {
        "index": 23053,
        "code": "static inline void encode_claim_delegate_cur(struct xdr_stream *xdr, const struct qstr *name, const nfs4_stateid *stateid)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE);\n\tWRITE32(NFS4_OPEN_CLAIM_DELEGATE_CUR);\n\tWRITEMEM(stateid->data, NFS4_STATEID_SIZE);\n\tencode_string(xdr, name->len, name->name);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4324",
        "length": 97
    },
    {
        "index": 129333,
        "code": "void GLES2DecoderImpl::DoUniformMatrix4fv(\n    GLint fake_location, GLsizei count, GLboolean transpose,\n    const GLfloat* value) {\n  GLenum type = 0;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(fake_location,\n                                   \"glUniformMatrix4fv\",\n                                   Program::kUniformMatrix4f,\n                                   &real_location,\n                                   &type,\n                                   &count)) {\n    return;\n  }\n  glUniformMatrix4fv(real_location, count, transpose, value);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3173",
        "length": 111
    },
    {
        "index": 35643,
        "code": "file_regerror(file_regex_t *rx, int rc, struct magic_set *ms)\n{\n\tchar errmsg[512];\n\n\t(void)regerror(rc, &rx->rx, errmsg, sizeof(errmsg));\n \tfile_magerror(ms, \"regex error %d for `%s', (%s)\", rc, rx->pat,\n \t    errmsg);\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-8117",
        "length": 71
    },
    {
        "index": 127818,
        "code": "void PepperMediaDeviceManager::StopEnumerateDevices(int request_id) {\n  enumerate_callbacks_.erase(request_id);\n\n#if defined(ENABLE_WEBRTC)\n  base::MessageLoop::current()->PostTask(\n      FROM_HERE,\n      base::Bind(&PepperMediaDeviceManager::StopEnumerateDevicesDelayed,\n                 AsWeakPtr(),\n                 request_id));\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-7906",
        "length": 75
    },
    {
        "index": 116053,
        "code": "ExtensionSettingsHandler::ExtensionSettingsHandler()\n    : extension_service_(NULL),\n      ignore_notifications_(false),\n      deleting_rvh_(NULL),\n      registered_for_notifications_(false) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3104",
        "length": 38
    },
    {
        "index": 59031,
        "code": "void dbus_handler_manager1_init(GDBusConnection *connection)\n{\n\tGError *error = NULL;\n\tTCMUService1HandlerManager1 *interface;\n\tgboolean ret;\n\n\tinterface = tcmuservice1_handler_manager1_skeleton_new();\n\tret = g_dbus_interface_skeleton_export(\n\t\t\tG_DBUS_INTERFACE_SKELETON(interface),\n\t\t\tconnection,\n\t\t\t\"/org/kernel/TCMUService1/HandlerManager1\",\n\t\t\t&error);\n\tg_signal_connect(interface,\n\t\t\t \"handle-register-handler\",\n\t\t\t G_CALLBACK (on_register_handler),\n\t\t\t NULL);\n\tg_signal_connect(interface,\n\t\t\t \"handle-unregister-handler\",\n\t\t\t G_CALLBACK (on_unregister_handler),\n\t\t\t NULL);\n\tif (!ret)\n\t\ttcmu_err(\"Handler manager export failed: %s\\n\",\n\t\t     error ? error->message : \"unknown error\");\n\tif (error)\n\t\tg_error_free(error);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-1000201",
        "length": 181
    },
    {
        "index": 152908,
        "code": "DevToolsWindow* DevToolsWindow::Create(\n    Profile* profile,\n    const GURL& frontend_url,\n    content::WebContents* inspected_web_contents,\n    bool shared_worker_frontend,\n    bool v8_only_frontend,\n    const std::string& remote_frontend,\n    bool can_dock,\n    const std::string& settings) {\n  if (profile->GetPrefs()->GetBoolean(prefs::kDevToolsDisabled) ||\n      base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))\n    return nullptr;\n\n  if (inspected_web_contents) {\n    Browser* browser = NULL;\n    int tab;\n    if (!FindInspectedBrowserAndTabIndex(inspected_web_contents,\n                                         &browser, &tab) ||\n        browser->is_type_popup()) {\n      can_dock = false;\n    }\n  }\n\n  GURL url(GetDevToolsURL(profile, frontend_url,\n                          shared_worker_frontend,\n                          v8_only_frontend,\n                          remote_frontend,\n                          can_dock));\n  std::unique_ptr<WebContents> main_web_contents(\n      WebContents::Create(WebContents::CreateParams(profile)));\n  main_web_contents->GetController().LoadURL(\n      DecorateFrontendURL(url), content::Referrer(),\n      ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string());\n  DevToolsUIBindings* bindings =\n      DevToolsUIBindings::ForWebContents(main_web_contents.get());\n  if (!bindings)\n    return nullptr;\n  if (!settings.empty())\n    SetPreferencesFromJson(profile, settings);\n  return new DevToolsWindow(profile, main_web_contents.release(), bindings,\n                            inspected_web_contents, can_dock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-5212",
        "length": 340
    },
    {
        "index": 11268,
        "code": "static void vapic_realize(DeviceState *dev, Error **errp)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n    VAPICROMState *s = VAPIC(dev);\n\n    memory_region_init_io(&s->io, OBJECT(s), &vapic_ops, s, \"kvmvapic\", 2);\n    sysbus_add_io(sbd, VAPIC_IO_PORT, &s->io);\n    sysbus_init_ioports(sbd, VAPIC_IO_PORT, 2);\n\n    option_rom[nb_option_roms].name = \"kvmvapic.bin\";\n    option_rom[nb_option_roms].bootindex = -1;\n    nb_option_roms++;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-4020",
        "length": 151
    },
    {
        "index": 101175,
        "code": "  virtual ~GatherUsageTaskBase() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 11
    },
    {
        "index": 108799,
        "code": "bool ChildProcessSecurityPolicyImpl::IsWebSafeScheme(\n    const std::string& scheme) {\n  base::AutoLock lock(lock_);\n\n  return (web_safe_schemes_.find(scheme) != web_safe_schemes_.end());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5138",
        "length": 51
    },
    {
        "index": 37596,
        "code": "static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,\n\t\t\t  bool prefault)\n{\n\tpfn_t pfn;\n\tint r;\n\tint level;\n\tint force_pt_level;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tint write = error_code & PFERR_WRITE_MASK;\n\tbool map_writable;\n\n\tASSERT(vcpu);\n\tASSERT(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, gpa, error_code, true);\n\n\t\tif (likely(r != RET_MMIO_PF_INVALID))\n\t\t\treturn r;\n\t}\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tforce_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);\n\tif (likely(!force_pt_level)) {\n\t\tlevel = mapping_level(vcpu, gfn);\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t} else\n\t\tlevel = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, 0, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, gpa, write, map_writable,\n\t\t\t level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 484
    },
    {
        "index": 147218,
        "code": "static void BooleanOrNullAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  bool is_null = false;\n\n  bool cpp_value(impl->booleanOrNullAttribute(is_null));\n\n  if (is_null) {\n    V8SetReturnValueNull(info);\n    return;\n  }\n\n  V8SetReturnValueBool(info, cpp_value);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 106
    },
    {
        "index": 40351,
        "code": "int bt_sock_wait_ready(struct sock *sk, unsigned long flags)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long timeo;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (test_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\tlock_sock(sk);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\terr = sock_error(sk);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-7271",
        "length": 207
    },
    {
        "index": 164171,
        "code": "  void FindMainResponseExclusionsInDatabase() {\n    FindMainResponseExclusions(true);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-5837",
        "length": 22
    },
    {
        "index": 17778,
        "code": "AttachOffloadGPU(ScreenPtr pScreen, ScreenPtr new)\n{\n    assert(new->isGPU);\n    assert(!new->is_offload_slave);\n    assert(new->current_master == pScreen);\n    new->is_offload_slave = TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-12176",
        "length": 53
    },
    {
        "index": 171946,
        "code": "void btif_pan_cleanup()\n{\n if (!stack_initialized)\n return;\n\n for (int i = 0; i < MAX_PAN_CONNS; i++)\n        btpan_cleanup_conn(&btpan_cb.conns[i]);\n\n    pan_disable();\n    stack_initialized = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3839",
        "length": 59
    },
    {
        "index": 76329,
        "code": "static void chmd_close(struct mschm_decompressor *base,\n\t\t       struct mschmd_header *chm)\n{\n  struct mschm_decompressor_p *self = (struct mschm_decompressor_p *) base;\n  struct mschmd_file *fi, *nfi;\n  struct mspack_system *sys;\n  unsigned int i;\n\n  if (!base) return;\n  sys = self->system;\n\n  self->error = MSPACK_ERR_OK;\n\n  /* free files */\n  for (fi = chm->files; fi; fi = nfi) {\n    nfi = fi->next;\n    sys->free(fi);\n  }\n  for (fi = chm->sysfiles; fi; fi = nfi) {\n    nfi = fi->next;\n    sys->free(fi);\n  }\n\n  /* if this CHM was being decompressed, free decompression state */\n  if (self->d && (self->d->chm == chm)) {\n    if (self->d->infh) sys->close(self->d->infh);\n    if (self->d->state) lzxd_free(self->d->state);\n    sys->free(self->d);\n    self->d = NULL;\n  }\n\n  /* if this CHM had a chunk cache, free it and contents */\n  if (chm->chunk_cache) {\n      for (i = 0; i < chm->num_chunks; i++) sys->free(chm->chunk_cache[i]);\n      sys->free(chm->chunk_cache);\n  }\n\n  sys->free(chm);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-18585",
        "length": 340
    },
    {
        "index": 123498,
        "code": "SafeBrowsingBlockingPage::SafeBrowsingBlockingPage(\n    SafeBrowsingUIManager* ui_manager,\n    WebContents* web_contents,\n    const UnsafeResourceList& unsafe_resources)\n    : malware_details_proceed_delay_ms_(\n          kMalwareDetailsProceedDelayMilliSeconds),\n      ui_manager_(ui_manager),\n      report_loop_(NULL),\n      is_main_frame_load_blocked_(IsMainPageLoadBlocked(unsafe_resources)),\n      unsafe_resources_(unsafe_resources),\n      proceeded_(false),\n      web_contents_(web_contents),\n      url_(unsafe_resources[0].url),\n      has_expanded_see_more_section_(false) {\n  bool malware = false;\n  bool phishing = false;\n  for (UnsafeResourceList::const_iterator iter = unsafe_resources_.begin();\n       iter != unsafe_resources_.end(); ++iter) {\n    const UnsafeResource& resource = *iter;\n    SBThreatType threat_type = resource.threat_type;\n    if (threat_type == SB_THREAT_TYPE_URL_MALWARE) {\n      malware = true;\n    } else {\n      DCHECK(threat_type == SB_THREAT_TYPE_URL_PHISHING ||\n             threat_type == SB_THREAT_TYPE_CLIENT_SIDE_PHISHING_URL);\n      phishing = true;\n    }\n  }\n  DCHECK(phishing || malware);\n  if (malware && phishing)\n    interstitial_type_ = TYPE_MALWARE_AND_PHISHING;\n  else if (malware)\n    interstitial_type_ = TYPE_MALWARE;\n  else\n    interstitial_type_ = TYPE_PHISHING;\n  RecordUserAction(SHOW);\n  if (!is_main_frame_load_blocked_) {\n    navigation_entry_index_to_remove_ =\n        web_contents->GetController().GetLastCommittedEntryIndex();\n  } else {\n    navigation_entry_index_to_remove_ = -1;\n  }\n\n  if (unsafe_resources.size() == 1 &&\n      unsafe_resources[0].threat_type == SB_THREAT_TYPE_URL_MALWARE &&\n      malware_details_ == NULL &&\n      CanShowMalwareDetailsOption()) {\n    malware_details_ = MalwareDetails::NewMalwareDetails(\n        ui_manager_, web_contents, unsafe_resources[0]);\n  }\n\n  interstitial_page_ = InterstitialPage::Create(\n      web_contents, IsMainPageLoadBlocked(unsafe_resources), url_, this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0890",
        "length": 478
    },
    {
        "index": 158366,
        "code": "void RenderWidgetHostImpl::SetNeedsBeginFrame(bool needs_begin_frames) {\n  if (needs_begin_frames_ == needs_begin_frames)\n    return;\n\n  needs_begin_frames_ = needs_begin_frames || browser_fling_needs_begin_frame_;\n  if (view_)\n    view_->SetNeedsBeginFrames(needs_begin_frames_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17467",
        "length": 68
    },
    {
        "index": 111616,
        "code": "    virtual ~CallbackHelper() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 8
    },
    {
        "index": 39570,
        "code": "int license_recv(rdpLicense* license, wStream* s)\n{\n\tBYTE flags;\n\tBYTE bMsgType;\n\tUINT16 wMsgSize;\n\tUINT16 length;\n\tUINT16 channelId;\n\tUINT16 securityFlags;\n\n\tif (!rdp_read_header(license->rdp, s, &length, &channelId))\n\t{\n\t\tfprintf(stderr, \"Incorrect RDP header.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!rdp_read_security_header(s, &securityFlags))\n\t\treturn -1;\n\n\tif (securityFlags & SEC_ENCRYPT)\n\t{\n\t\tif (!rdp_decrypt(license->rdp, s, length - 4, securityFlags))\n\t\t{\n\t\t\tfprintf(stderr, \"rdp_decrypt failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(securityFlags & SEC_LICENSE_PKT))\n\t{\n\t\tint status;\n\n\t\tif (!(securityFlags & SEC_ENCRYPT))\n\t\t\tStream_Rewind(s, RDP_SECURITY_HEADER_LENGTH);\n\n\t\tstatus = rdp_recv_out_of_sequence_pdu(license->rdp, s);\n\n\t\tif (status < 0)\n\t\t{\n\t\t\tfprintf(stderr, \"Unexpected license packet.\\n\");\n\t\t\treturn status;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!license_read_preamble(s, &bMsgType, &flags, &wMsgSize)) /* preamble (4 bytes) */\n\t\treturn -1;\n\n\tDEBUG_LICENSE(\"Receiving %s Packet\", LICENSE_MESSAGE_STRINGS[bMsgType & 0x1F]);\n\n\tswitch (bMsgType)\n\t{\n\t\tcase LICENSE_REQUEST:\n\t\t\tif (!license_read_license_request_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tlicense_send_new_license_request_packet(license);\n\t\t\tbreak;\n\n\t\tcase PLATFORM_CHALLENGE:\n\t\t\tif (!license_read_platform_challenge_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tlicense_send_platform_challenge_response_packet(license);\n\t\t\tbreak;\n\n\t\tcase NEW_LICENSE:\n\t\t\tlicense_read_new_license_packet(license, s);\n\t\t\tbreak;\n\n\t\tcase UPGRADE_LICENSE:\n\t\t\tlicense_read_upgrade_license_packet(license, s);\n\t\t\tbreak;\n\n\t\tcase ERROR_ALERT:\n\t\t\tif (!license_read_error_alert_packet(license, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"invalid bMsgType:%d\\n\", bMsgType);\n\t\t\treturn FALSE;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-0791",
        "length": 493
    },
    {
        "index": 74221,
        "code": "ntp_exit(int retval)\n{\n\tmsyslog(LOG_ERR, \"EXITING with return code %d\", retval);\n\texit(retval);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-5195",
        "length": 28
    },
    {
        "index": 91501,
        "code": "static int gifPutWord(int w, gdIOCtx *out)\n{\n\t/* Byte order is little-endian */\n\tgdPutC(w & 0xFF, out);\n\tgdPutC((w >> 8) & 0xFF, out);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2019-6978",
        "length": 59
    },
    {
        "index": 138674,
        "code": "void RenderFrameHostImpl::ExtendSelectionAndDelete(size_t before,\n                                                   size_t after) {\n  Send(new InputMsg_ExtendSelectionAndDelete(routing_id_, before, after));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1278",
        "length": 40
    },
    {
        "index": 44477,
        "code": "static int do_setup_cgroup_limits(struct cgfs_data *d,\n\t\t\t   struct lxc_list *cgroup_settings, bool do_devices)\n{\n\tstruct lxc_list *iterator, *sorted_cgroup_settings, *next;\n\tstruct lxc_cgroup *cg;\n\tint ret = -1;\n\n\tif (lxc_list_empty(cgroup_settings))\n\t\treturn 0;\n\n\tsorted_cgroup_settings = sort_cgroup_settings(cgroup_settings);\n\tif (!sorted_cgroup_settings) {\n\t\treturn -1;\n\t}\n\n\tlxc_list_for_each(iterator, sorted_cgroup_settings) {\n\t\tcg = iterator->elem;\n\n\t\tif (do_devices == !strncmp(\"devices\", cg->subsystem, 7)) {\n\t\t\tif (strcmp(cg->subsystem, \"devices.deny\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, false))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(cg->subsystem, \"devices.allow\") == 0 &&\n\t\t\t\t\tcgroup_devices_has_allow_or_deny(d, cg->value, true))\n\t\t\t\tcontinue;\n\t\t\tif (lxc_cgroup_set_data(cg->subsystem, cg->value, d)) {\n\t\t\t\tERROR(\"Error setting %s to %s for %s\",\n\t\t\t\t      cg->subsystem, cg->value, d->name);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tDEBUG(\"cgroup '%s' set to '%s'\", cg->subsystem, cg->value);\n\t}\n\n\tret = 0;\n\tINFO(\"cgroup has been setup\");\nout:\n\tlxc_list_for_each_safe(iterator, sorted_cgroup_settings, next) {\n\t\tlxc_list_del(iterator);\n\t\tfree(iterator);\n\t}\n\tfree(sorted_cgroup_settings);\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2015-1335",
        "length": 361
    },
    {
        "index": 29455,
        "code": "static int set_deep_fifo(struct sb_uart_port *port, int status)\n{\n\tint afr_status = 0;\n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\n\tif(status == ENABLE)\n\t{\n\t\tafr_status |= SB105X_AFR_AFEN;\n\t}\n\telse\n\t{\n\t\tafr_status &= ~SB105X_AFR_AFEN;\n\t}\n\t\t\n\tsb1054_set_register(port,PAGE_4,SB105X_AFR,afr_status);\n\tsb1054_set_register(port,PAGE_4,SB105X_TTR,ttr[port->line]); \n\tsb1054_set_register(port,PAGE_4,SB105X_RTR,rtr[port->line]); \n\tafr_status = sb1054_get_register(port, PAGE_4, SB105X_AFR);\n\t\t\n\treturn afr_status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-4516",
        "length": 181
    },
    {
        "index": 135013,
        "code": "bool AppCacheUpdateJob::URLFetcher::MaybeRetryRequest() {\n  if (retry_503_attempts_ >= kMax503Retries ||\n      !request_->response_headers()->HasHeaderValue(\"retry-after\", \"0\")) {\n    return false;\n  }\n  ++retry_503_attempts_;\n  result_ = UPDATE_OK;\n  request_ = job_->service_->request_context()->CreateRequest(\n      url_, net::DEFAULT_PRIORITY, this);\n  Start();\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6765",
        "length": 99
    },
    {
        "index": 95566,
        "code": "static void _S_AL_SanitiseVector( vec3_t v, int line )\n{\n\tif( Q_isnan( v[ 0 ] ) || Q_isnan( v[ 1 ] ) || Q_isnan( v[ 2 ] ) )\n\t{\n\t\tCom_DPrintf( S_COLOR_YELLOW \"WARNING: vector with one or more NaN components \"\n\t\t\t\t\"being passed to OpenAL at %s:%d -- zeroing\\n\", __FILE__, line );\n\t\tVectorClear( v );\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 110
    },
    {
        "index": 186401,
        "code": "InputHandlerProxy::InputHandlerProxy(cc::InputHandler* input_handler,\n                                     InputHandlerProxyClient* client,\n                                     bool force_input_to_main_thread)\n    : client_(client),\n      input_handler_(input_handler),\n      synchronous_input_handler_(nullptr),\n      allow_root_animate_(true),\n#if DCHECK_IS_ON()\n      expect_scroll_update_end_(false),\n#endif\n      gesture_scroll_on_impl_thread_(false),\n      scroll_sequence_ignored_(false),\n      smooth_scroll_enabled_(false),\n      touch_result_(kEventDispositionUndefined),\n      mouse_wheel_result_(kEventDispositionUndefined),\n       current_overscroll_params_(nullptr),\n       has_ongoing_compositor_scroll_or_pinch_(false),\n       is_first_gesture_scroll_update_(false),\n      last_injected_gesture_was_begin_(false),\n       tick_clock_(base::DefaultTickClock::GetInstance()),\n       snap_fling_controller_(std::make_unique<cc::SnapFlingController>(this)),\n       compositor_touch_action_enabled_(\n          base::FeatureList::IsEnabled(features::kCompositorTouchAction)),\n      force_input_to_main_thread_(force_input_to_main_thread) {\n  DCHECK(client);\n  input_handler_->BindToClient(this);\n  cc::ScrollElasticityHelper* scroll_elasticity_helper =\n      input_handler_->CreateScrollElasticityHelper();\n  if (scroll_elasticity_helper) {\n    scroll_elasticity_controller_.reset(\n        new InputScrollElasticityController(scroll_elasticity_helper));\n  }\n  compositor_event_queue_ = std::make_unique<CompositorThreadEventQueue>();\n  scroll_predictor_ = std::make_unique<ScrollPredictor>(\n      base::FeatureList::IsEnabled(features::kResamplingScrollEvents));\n\n  if (base::FeatureList::IsEnabled(features::kSkipTouchEventFilter) &&\n      GetFieldTrialParamValueByFeature(\n          features::kSkipTouchEventFilter,\n          features::kSkipTouchEventFilterFilteringProcessParamName) ==\n          features::\n              kSkipTouchEventFilterFilteringProcessParamValueBrowserAndRenderer) {\n    skip_touch_filter_discrete_ = true;\n    if (GetFieldTrialParamValueByFeature(\n            features::kSkipTouchEventFilter,\n            features::kSkipTouchEventFilterTypeParamName) ==\n        features::kSkipTouchEventFilterTypeParamValueAll) {\n      skip_touch_filter_all_ = true;\n    }\n  }\n}\n",
        "line": "      last_injected_gesture_was_begin_(false),\n",
        "label": 1,
        "cwe": "CWE-281",
        "cve": "CVE-2017-5033",
        "length": 490
    },
    {
        "index": 154154,
        "code": "const CompressedFormatInfo* GetCompressedFormatInfo(GLenum format) {\n  for (size_t i = 0; i < base::size(kCompressedFormatInfoArray); i++) {\n    if (kCompressedFormatInfoArray[i].format == format) {\n      return &kCompressedFormatInfoArray[i];\n    }\n  }\n  return nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 78
    },
    {
        "index": 113890,
        "code": "bool HTMLDocumentParser::isScheduledForResume() const\n{\n    return m_parserScheduler && m_parserScheduler->isScheduledForResume();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 30
    },
    {
        "index": 182264,
        "code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n\n    /*\n     * Do some sanity checking on the aliases. We can't do it before\n     * because keys and their aliases may be added out-of-order.\n     */\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        /* Check that ->real is a key. */\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        /* Check that ->alias is not a key. */\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n\n        num_key_aliases++;\n    }\n\n    /* Copy key aliases. */\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n    }\n \n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n         }\n     }\n \n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}\n",
        "line": "    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n",
        "label": 1,
        "cwe": "CWE-476",
        "cve": "CVE-2018-15858",
        "length": 450
    },
    {
        "index": 89526,
        "code": "SWFShape_setRightFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\t\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->rightFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE1FLAG;\n\t\treturn;\n\t}\n\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) // fill not present in array\n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\t\t\t\t\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->rightFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE1FLAG;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-12981",
        "length": 250
    },
    {
        "index": 33115,
        "code": "static int dump_one_state(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct xfrm_usersa_info *p;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).pid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWSA, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-1826",
        "length": 186
    },
    {
        "index": 115153,
        "code": "void GraphicsContext3D::setContextLostCallback(PassOwnPtr<ContextLostCallback>)\n{\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-3956",
        "length": 22
    },
    {
        "index": 119416,
        "code": "void RenderThreadImpl::OnTempCrashWithData(const GURL& data) {\n  GetContentClient()->SetActiveURL(data);\n  CHECK(false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2013-2906",
        "length": 31
    },
    {
        "index": 32744,
        "code": "static int tg3_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint ret;\n\tu32 offset, len, b_offset, odd_len;\n\tu8 *buf;\n\t__be32 start, end;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\n\t\treturn -EAGAIN;\n\n\tif (tg3_flag(tp, NO_NVRAM) ||\n\t    eeprom->magic != TG3_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\toffset = eeprom->offset;\n\tlen = eeprom->len;\n\n\tif ((b_offset = (offset & 3))) {\n\t\t/* adjustments to start on required 4 byte boundary */\n\t\tret = tg3_nvram_read_be32(tp, offset-b_offset, &start);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlen += b_offset;\n\t\toffset &= ~3;\n\t\tif (len < 4)\n\t\t\tlen = 4;\n\t}\n\n\todd_len = 0;\n\tif (len & 3) {\n\t\t/* adjustments to end on required 4 byte boundary */\n\t\todd_len = 1;\n\t\tlen = (len + 3) & ~3;\n\t\tret = tg3_nvram_read_be32(tp, offset+len-4, &end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbuf = data;\n\tif (b_offset || odd_len) {\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tif (b_offset)\n\t\t\tmemcpy(buf, &start, 4);\n\t\tif (odd_len)\n\t\t\tmemcpy(buf+len-4, &end, 4);\n\t\tmemcpy(buf + b_offset, data, eeprom->len);\n\t}\n\n\tret = tg3_nvram_write_block(tp, offset, len, buf);\n\n\tif (buf != data)\n\t\tkfree(buf);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "length": 410
    },
    {
        "index": 175250,
        "code": "RIL_startEventLoop(void) {\n /* spin up eventLoop thread and wait for it to get started */\n    s_started = 0;\n    pthread_mutex_lock(&s_startupMutex);\n\n pthread_attr_t attr;\n    pthread_attr_init(&attr);\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n int result = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);\n if (result != 0) {\n        RLOGE(\"Failed to create dispatch thread: %s\", strerror(result));\n goto done;\n }\n\n while (s_started == 0) {\n        pthread_cond_wait(&s_startupCond, &s_startupMutex);\n }\n\ndone:\n    pthread_mutex_unlock(&s_startupMutex);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-0823",
        "length": 149
    },
    {
        "index": 173841,
        "code": " virtual status_t allocateBufferWithBackup(\n            node_id node, OMX_U32 port_index, const sp<IMemory> &params,\n            buffer_id *buffer, OMX_U32 allottedSize) {\n Parcel data, reply;\n        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());\n        data.writeInt32((int32_t)node);\n        data.writeInt32(port_index);\n        data.writeStrongBinder(IInterface::asBinder(params));\n        data.writeInt32(allottedSize);\n        remote()->transact(ALLOC_BUFFER_WITH_BACKUP, data, &reply);\n\n status_t err = reply.readInt32();\n if (err != OK) {\n *buffer = 0;\n\n return err;\n }\n\n *buffer = (buffer_id)reply.readInt32();\n\n return err;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 154
    },
    {
        "index": 90434,
        "code": "static ssize_t support_device_change_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_device_change);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-11810",
        "length": 32
    },
    {
        "index": 168275,
        "code": "ExclusiveAccessBubbleViews* BrowserView::GetExclusiveAccessBubble() {\n  return exclusive_access_bubble();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-16080",
        "length": 23
    },
    {
        "index": 184530,
        "code": "void RegistrationManager::SetRegisteredIds(const ObjectIdSet& ids) {\n   DCHECK(CalledOnValidThread());\n \n   const ObjectIdSet& old_ids = GetRegisteredIds();\n  const ObjectIdSet& to_register = ids;\n  ObjectIdSet to_unregister;\n  std::set_difference(old_ids.begin(), old_ids.end(),\n                      ids.begin(), ids.end(),\n                      std::inserter(to_unregister, to_unregister.begin()),\n                      ObjectIdLessThan());\n\n  for (ObjectIdSet::const_iterator it = to_unregister.begin();\n       it != to_unregister.end(); ++it) {\n    UnregisterId(*it);\n  }\n\n  for (ObjectIdSet::const_iterator it = to_register.begin();\n       it != to_register.end(); ++it) {\n    if (!ContainsKey(registration_statuses_, *it)) {\n      registration_statuses_.insert(\n          std::make_pair(*it, new RegistrationStatus(*it, this)));\n    }\n    if (!IsIdRegistered(*it)) {\n      TryRegisterId(*it, false /* is-retry */);\n    }\n  }\n}\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 214
    },
    {
        "index": 134942,
        "code": "bool ShouldHideActiveAppsFromShelf() {\n  return base::CommandLine::ForCurrentProcess()->HasSwitch(\n      kHideActiveAppsFromShelf);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6791",
        "length": 34
    },
    {
        "index": 179144,
        "code": "static int newary(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tint id;\n\tint retval;\n\tstruct sem_array *sma;\n\tint size;\n\tkey_t key = params->key;\n\tint nsems = params->u.nsems;\n\tint semflg = params->flg;\n\tint i;\n\n\tif (!nsems)\n\t\treturn -EINVAL;\n\tif (ns->used_sems + nsems > ns->sc_semmns)\n\t\treturn -ENOSPC;\n\n\tsize = sizeof (*sma) + nsems * sizeof (struct sem);\n\tsma = ipc_rcu_alloc(size);\n\tif (!sma) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset (sma, 0, size);\n\n\tsma->sem_perm.mode = (semflg & S_IRWXUGO);\n\tsma->sem_perm.key = key;\n\n\tsma->sem_perm.security = NULL;\n\tretval = security_sem_alloc(sma);\n\tif (retval) {\n\t\tipc_rcu_putref(sma);\n\t\treturn retval;\n\t}\n\n\tid = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);\n\tif (id < 0) {\n\t\tsecurity_sem_free(sma);\n\t\tipc_rcu_putref(sma);\n\t\treturn id;\n\t}\n\tns->used_sems += nsems;\n \n \tsma->sem_base = (struct sem *) &sma[1];\n \n\tfor (i = 0; i < nsems; i++)\n \t\tINIT_LIST_HEAD(&sma->sem_base[i].sem_pending);\n \n \tsma->complex_count = 0;\n \tINIT_LIST_HEAD(&sma->sem_pending);\n \tINIT_LIST_HEAD(&sma->list_id);\n \tsma->sem_nsems = nsems;\n \tsma->sem_ctime = get_seconds();\n\tsem_unlock(sma);\n \n \treturn sma->sem_perm.id;\n }\n",
        "line": "\tfor (i = 0; i < nsems; i++)\n\tsem_unlock(sma);\n",
        "label": 1,
        "cwe": "CWE-189",
        "cve": "CVE-2013-4483",
        "length": 409
    },
    {
        "index": 147157,
        "code": "static void ActivityLoggingAccessPerWorldBindingsLongAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueInt(info, impl->activityLoggingAccessPerWorldBindingsLongAttribute());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 79
    },
    {
        "index": 39063,
        "code": "txid_snapshot_xmin(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap = (TxidSnapshot *) PG_GETARG_VARLENA_P(0);\n\n\tPG_RETURN_INT64(snap->xmin);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 45
    },
    {
        "index": 185320,
        "code": "void AwContents::ScrollContainerViewTo(gfx::Vector2d new_value) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n   JNIEnv* env = AttachCurrentThread();\n   ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);\n  if (obj.is_null())\n    return;\n  Java_AwContents_scrollContainerViewTo(\n       env, obj.obj(), new_value.x(), new_value.y());\n }\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1743",
        "length": 90
    },
    {
        "index": 141689,
        "code": "    v8::MaybeLocal<v8::Map> privateMap(const char* name)\n    {\n        v8::Local<v8::Object> console = ensureConsole();\n        v8::Local<v8::Private> privateKey = v8::Private::ForApi(m_isolate, toV8StringInternalized(m_isolate, name));\n        v8::Local<v8::Value> mapValue;\n        if (!console->GetPrivate(m_context, privateKey).ToLocal(&mapValue))\n            return v8::MaybeLocal<v8::Map>();\n        if (mapValue->IsUndefined()) {\n            v8::Local<v8::Map> map = v8::Map::New(m_isolate);\n            if (!console->SetPrivate(m_context, privateKey, map).FromMaybe(false))\n                return v8::MaybeLocal<v8::Map>();\n            return map;\n        }\n        return mapValue->IsMap() ? mapValue.As<v8::Map>() : v8::MaybeLocal<v8::Map>();\n    }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2016-5164",
        "length": 211
    },
    {
        "index": 33076,
        "code": "static int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tSCTP_DEBUG_PRINTK(\"%s: asoc=%p, timeo=%ld\\n\", __func__, asoc,\n\t\t\t  (long)(*timeo_p));\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\n\t\tif (sctp_state(asoc, ESTABLISHED))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\tsctp_release_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tsctp_lock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\tif (asoc->init_err_counter + 1 > asoc->max_init_attempts)\n\t\terr = -ETIMEDOUT;\n\telse\n\t\terr = -ECONNREFUSED;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EINPROGRESS;\n\tgoto out;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1828",
        "length": 399
    },
    {
        "index": 64123,
        "code": "static int snd_msnd_pinnacle_cfg_reset(int cfg)\n{\n\tint i;\n\n\t/* Reset devices if told to */\n\tprintk(KERN_INFO LOGNAME \": Resetting all devices\\n\");\n\tfor (i = 0; i < 4; ++i)\n\t\tif (snd_msnd_write_cfg_logical(cfg, i, 0, 0, 0, 0))\n\t\t\treturn -EIO;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-9985",
        "length": 88
    },
    {
        "index": 122877,
        "code": "size_t RenderProcessHost::GetMaxRendererProcessCount() {\n  if (g_max_renderer_count_override)\n    return g_max_renderer_count_override;\n\n\n  static size_t max_count = 0;\n  if (!max_count) {\n    const size_t kEstimatedWebContentsMemoryUsage =\n#if defined(ARCH_CPU_64_BITS)\n        60;  // In MB\n#else\n        40;  // In MB\n#endif\n    max_count = base::SysInfo::AmountOfPhysicalMemoryMB() / 2;\n    max_count /= kEstimatedWebContentsMemoryUsage;\n\n    const size_t kMinRendererProcessCount = 3;\n    max_count = std::max(max_count, kMinRendererProcessCount);\n    max_count = std::min(max_count, kMaxRendererProcessCount);\n  }\n  return max_count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 173
    },
    {
        "index": 126812,
        "code": "bool BrowserView::IsMinimized() const {\n  return frame_->IsMinimized();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 20
    },
    {
        "index": 33848,
        "code": "cib_GCompareFunc(gconstpointer a, gconstpointer b)\n{\n    const xmlNode *a_msg = a;\n    const xmlNode *b_msg = b;\n\n    int msg_a_id = 0;\n    int msg_b_id = 0;\n    const char *value = NULL;\n\n    value = crm_element_value_const(a_msg, F_CIB_CALLID);\n    msg_a_id = crm_parse_int(value, NULL);\n\n    value = crm_element_value_const(b_msg, F_CIB_CALLID);\n    msg_b_id = crm_parse_int(value, NULL);\n\n    if (msg_a_id == msg_b_id) {\n        return 0;\n    } else if (msg_a_id < msg_b_id) {\n        return -1;\n    }\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-0281",
        "length": 167
    },
    {
        "index": 97145,
        "code": "NavigationController::~NavigationController() {\n  DiscardNonCommittedEntriesInternal();\n\n  NotificationService::current()->Notify(\n      NotificationType::TAB_CLOSED,\n      Source<NavigationController>(this),\n      NotificationService::NoDetails());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 48
    },
    {
        "index": 65423,
        "code": "clear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 30
    },
    {
        "index": 117928,
        "code": "static v8::Handle<v8::Value> multiTransferListCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.TestSerializedScriptValueInterface.multiTransferList\");\n    TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());\n    if (args.Length() <= 0) {\n        imp->multiTransferList();\n        return v8::Handle<v8::Value>();\n    }\n    MessagePortArray messagePortArrayTx;\n    ArrayBufferArray arrayBufferArrayTx;\n    if (args.Length() > 1) {\n        if (!extractTransferables(args[1], messagePortArrayTx, arrayBufferArrayTx))\n            return V8Proxy::throwTypeError(\"Could not extract transferables\");\n    }\n    bool firstDidThrow = false;\n    RefPtr<SerializedScriptValue> first = SerializedScriptValue::create(args[0], &messagePortArrayTx, &arrayBufferArrayTx, firstDidThrow, args.GetIsolate());\n    if (firstDidThrow)\n        return v8::Undefined();\n    if (args.Length() <= 1) {\n        imp->multiTransferList(first);\n        return v8::Handle<v8::Value>();\n    }\n    if (args.Length() <= 2) {\n        imp->multiTransferList(first, messagePortArrayTx);\n        return v8::Handle<v8::Value>();\n    }\n    MessagePortArray messagePortArrayTxx;\n    ArrayBufferArray arrayBufferArrayTxx;\n    if (args.Length() > 3) {\n        if (!extractTransferables(args[3], messagePortArrayTxx, arrayBufferArrayTxx))\n            return V8Proxy::throwTypeError(\"Could not extract transferables\");\n    }\n    bool secondDidThrow = false;\n    RefPtr<SerializedScriptValue> second = SerializedScriptValue::create(args[2], &messagePortArrayTxx, &arrayBufferArrayTxx, secondDidThrow, args.GetIsolate());\n    if (secondDidThrow)\n        return v8::Undefined();\n    if (args.Length() <= 3) {\n        imp->multiTransferList(first, messagePortArrayTx, second);\n        return v8::Handle<v8::Value>();\n    }\n    imp->multiTransferList(first, messagePortArrayTx, second, messagePortArrayTxx);\n    return v8::Handle<v8::Value>();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3055",
        "length": 493
    },
    {
        "index": 83732,
        "code": "static int index_entry_isrch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcasecmp((const char *)path, entry->path);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-8099",
        "length": 44
    },
    {
        "index": 153668,
        "code": "bool GLES2Implementation::GetActiveUniformsivHelper(GLuint program,\n                                                    GLsizei count,\n                                                    const GLuint* indices,\n                                                    GLenum pname,\n                                                    GLint* params) {\n  base::CheckedNumeric<uint32_t> bytes = count;\n  bytes *= sizeof(GLuint);\n  if (!bytes.IsValid()) {\n    SetGLError(GL_INVALID_VALUE, \"glGetActiveUniformsiv\", \"count overflow\");\n    return false;\n  }\n  SetBucketContents(kResultBucketId, indices, bytes.ValueOrDefault(0));\n  typedef cmds::GetActiveUniformsiv::Result Result;\n  auto result = GetResultAs<Result>();\n  if (!result) {\n    return false;\n  }\n  result->SetNumResults(0);\n  helper_->GetActiveUniformsiv(program, kResultBucketId, pname,\n                               GetResultShmId(), result.offset());\n  WaitForCmd();\n  bool success = result->GetNumResults() == count;\n  if (success) {\n    if (params) {\n      result->CopyResult(params);\n    }\n    GPU_CLIENT_LOG_CODE_BLOCK({\n      for (int32_t i = 0; i < result->GetNumResults(); ++i) {\n        GPU_CLIENT_LOG(\"  \" << i << \": \" << result->GetData()[i]);\n      }\n    });\n  }\n  helper_->SetBucketSize(kResultBucketId, 0);\n  return success;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 288
    },
    {
        "index": 116325,
        "code": "bool QQuickWebViewPrivate::transparentBackground() const\n{\n    return webPageProxy->drawsTransparentBackground();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3107",
        "length": 25
    },
    {
        "index": 70002,
        "code": "void checkTcpBacklogSettings(void) {\n#ifdef HAVE_PROC_SOMAXCONN\n    FILE *fp = fopen(\"/proc/sys/net/core/somaxconn\",\"r\");\n    char buf[1024];\n    if (!fp) return;\n    if (fgets(buf,sizeof(buf),fp) != NULL) {\n        int somaxconn = atoi(buf);\n        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {\n            serverLog(LL_WARNING,\"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.\", server.tcp_backlog, somaxconn);\n        }\n    }\n    fclose(fp);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10517",
        "length": 151
    },
    {
        "index": 70037,
        "code": "void linuxMemoryWarnings(void) {\n    if (linuxOvercommitMemoryValue() == 0) {\n        serverLog(LL_WARNING,\"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\");\n    }\n    if (THPIsEnabled()) {\n        serverLog(LL_WARNING,\"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.\");\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10517",
        "length": 192
    },
    {
        "index": 30194,
        "code": "static void ftrace_pid_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t    struct ftrace_ops *op, struct pt_regs *regs)\n{\n\tif (!test_tsk_trace_trace(current))\n\t\treturn;\n\n\tftrace_pid_function(ip, parent_ip, op, regs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-3301",
        "length": 57
    },
    {
        "index": 44985,
        "code": "AP_DECLARE(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)\n{\n    const char *auth_line = apr_table_get(r->headers_in,\n                                          (PROXYREQ_PROXY == r->proxyreq)\n                                              ? \"Proxy-Authorization\"\n                                              : \"Authorization\");\n    const char *t;\n\n    if (!(t = ap_auth_type(r)) || strcasecmp(t, \"Basic\"))\n        return DECLINED;\n\n    if (!ap_auth_name(r)) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00572) \n                      \"need AuthName: %s\", r->uri);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    if (!auth_line) {\n        ap_note_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), \"Basic\")) {\n        /* Client tried to authenticate using wrong auth scheme */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00573)\n                      \"client used wrong authentication scheme: %s\", r->uri);\n        ap_note_auth_failure(r);\n        return HTTP_UNAUTHORIZED;\n    }\n\n    while (*auth_line == ' ' || *auth_line == '\\t') {\n        auth_line++;\n    }\n\n    t = ap_pbase64decode(r->pool, auth_line);\n    r->user = ap_getword_nulls (r->pool, &t, ':');\n    r->ap_auth_type = \"Basic\";\n\n    *pw = t;\n\n    return OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-0253",
        "length": 335
    },
    {
        "index": 185192,
        "code": "GDataDirectory::GDataDirectory(GDataDirectory* parent,\n                               GDataDirectoryService* directory_service)\n    : GDataEntry(parent, directory_service) {\n   file_info_.is_directory = true;\n }\n",
        "line": "                               GDataDirectoryService* directory_service)\n    : GDataEntry(parent, directory_service) {\n",
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2013-0839",
        "length": 44
    },
    {
        "index": 150818,
        "code": "void WebBluetoothServiceImpl::RemoteCharacteristicWriteValue(\n    const std::string& characteristic_instance_id,\n    const std::vector<uint8_t>& value,\n    RemoteCharacteristicWriteValueCallback callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  if (value.size() > 512) {\n    CrashRendererAndClosePipe(bad_message::BDH_INVALID_WRITE_VALUE_LENGTH);\n    return;\n  }\n\n  const CacheQueryResult query_result =\n      QueryCacheForCharacteristic(characteristic_instance_id);\n\n  if (query_result.outcome == CacheQueryOutcome::BAD_RENDERER) {\n    return;\n  }\n\n  if (query_result.outcome != CacheQueryOutcome::SUCCESS) {\n    RecordCharacteristicWriteValueOutcome(query_result.outcome);\n    std::move(callback).Run(query_result.GetWebResult());\n    return;\n  }\n\n  if (BluetoothBlocklist::Get().IsExcludedFromWrites(\n          query_result.characteristic->GetUUID())) {\n    RecordCharacteristicWriteValueOutcome(UMAGATTOperationOutcome::BLOCKLISTED);\n    std::move(callback).Run(\n        blink::mojom::WebBluetoothResult::BLOCKLISTED_WRITE);\n    return;\n  }\n\n  auto copyable_callback = base::AdaptCallbackForRepeating(std::move(callback));\n  query_result.characteristic->WriteRemoteCharacteristic(\n      value,\n      base::Bind(&WebBluetoothServiceImpl::OnCharacteristicWriteValueSuccess,\n                 weak_ptr_factory_.GetWeakPtr(), copyable_callback),\n      base::Bind(&WebBluetoothServiceImpl::OnCharacteristicWriteValueFailed,\n                 weak_ptr_factory_.GetWeakPtr(), copyable_callback));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5044",
        "length": 327
    },
    {
        "index": 45486,
        "code": "void crypto_init_queue(struct crypto_queue *queue, unsigned int max_qlen)\n{\n\tINIT_LIST_HEAD(&queue->list);\n\tqueue->backlog = &queue->list;\n\tqueue->qlen = 0;\n\tqueue->max_qlen = max_qlen;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 59
    },
    {
        "index": 161018,
        "code": "void ChromeClientImpl::TextFieldDataListChanged(HTMLInputElement& input) {\n  if (auto* fill_client =\n          AutofillClientFromFrame(input.GetDocument().GetFrame())) {\n    fill_client->DataListOptionsChanged(WebInputElement(&input));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 55
    },
    {
        "index": 15967,
        "code": "ImportArrayTIFF_Short ( const TIFF_Manager::TagInfo & tagInfo, const bool nativeEndian,\n\t\t\t\t\t\tSXMPMeta * xmp, const char * xmpNS, const char * xmpProp )\n{\n\ttry {\t// Don't let errors with one stop the others.\n\n\t\tXMP_Uns16 * binPtr = (XMP_Uns16*)tagInfo.dataPtr;\n\t\t\n\t\txmp->DeleteProperty ( xmpNS, xmpProp );\t// ! Don't keep appending, create a new array.\n\n\t\tfor ( size_t i = 0; i < tagInfo.count; ++i, ++binPtr ) {\n\n\t\t\tXMP_Uns16 binValue = *binPtr;\n\t\t\tif ( ! nativeEndian ) binValue = Flip2 ( binValue );\n\n\t\t\tchar strValue[20];\n\t\t\tsnprintf ( strValue, sizeof(strValue), \"%hu\", binValue );\t// AUDIT: Using sizeof(strValue) is safe.\n\n\t\t\txmp->AppendArrayItem ( xmpNS, xmpProp, kXMP_PropArrayIsOrdered, strValue );\n\n\t\t}\n\n\t} catch ( ... ) {\n\t}\n\n}\t// ImportArrayTIFF_Short\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-18234",
        "length": 251
    },
    {
        "index": 76726,
        "code": "checkAttr(const widechar c, const TranslationTableCharacterAttributes a, int m,\n\t\tconst TranslationTableHeader *table) {\n\tstatic widechar prevc = 0;\n\tstatic TranslationTableCharacterAttributes preva = 0;\n\tif (c != prevc) {\n\t\tpreva = (findCharOrDots(c, m, table))->attributes;\n\t\tprevc = c;\n\t}\n\treturn ((preva & a) ? 1 : 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-17294",
        "length": 96
    },
    {
        "index": 163852,
        "code": "void ExtensionBrowserTest::SetUpOnMainThread() {\n  observer_.reset(\n      new extensions::ChromeExtensionTestNotificationObserver(browser()));\n  if (extension_service()->updater()) {\n    extension_service()->updater()->SetExtensionCacheForTesting(\n        test_extension_cache_.get());\n  }\n\n  base::FilePath test_root_path;\n  PathService::Get(chrome::DIR_TEST_DATA, &test_root_path);\n  test_root_path = test_root_path.AppendASCII(\"extensions\");\n  test_protocol_handler_ =\n      base::Bind(&ExtensionProtocolTestHandler, test_root_path);\n  extensions::SetExtensionProtocolTestHandler(&test_protocol_handler_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-15391",
        "length": 131
    },
    {
        "index": 36362,
        "code": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2014-5045",
        "length": 26
    },
    {
        "index": 54040,
        "code": "static int ims_pcu_switch_to_bootloader(struct ims_pcu *pcu)\n{\n\tint error;\n\n\t/* Execute jump to the bootoloader */\n\terror = ims_pcu_execute_command(pcu, JUMP_TO_BTLDR, NULL, 0);\n\tif (error) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Failure when sending JUMP TO BOOLTLOADER command, error: %d\\n\",\n\t\t\terror);\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3689",
        "length": 102
    },
    {
        "index": 106189,
        "code": "JSValue jsTestObjWithScriptStateAttribute(ExecState* exec, JSValue slotBase, const Identifier&)\n{\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    JSValue result = jsNumber(impl->withScriptStateAttribute(exec));\n    return result;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2350",
        "length": 85
    },
    {
        "index": 161835,
        "code": "ClientDiscardableSharedMemoryManager::AllocateLockedDiscardableSharedMemory(\n    size_t size,\n    int32_t id) {\n  TRACE_EVENT2(\"renderer\",\n               \"ClientDiscardableSharedMemoryManager::\"\n               \"AllocateLockedDiscardableSharedMemory\",\n               \"size\", size, \"id\", id);\n  base::SharedMemoryHandle handle;\n  base::WaitableEvent event(base::WaitableEvent::ResetPolicy::MANUAL,\n                            base::WaitableEvent::InitialState::NOT_SIGNALED);\n  base::ScopedClosureRunner event_signal_runner(\n      base::Bind(&base::WaitableEvent::Signal, base::Unretained(&event)));\n  io_task_runner_->PostTask(\n      FROM_HERE, base::Bind(&ClientDiscardableSharedMemoryManager::AllocateOnIO,\n                            base::Unretained(this), size, id, &handle,\n                            base::Passed(&event_signal_runner)));\n  event.Wait();\n  auto memory = base::MakeUnique<base::DiscardableSharedMemory>(handle);\n  if (!memory->Map(size))\n    base::TerminateBecauseOutOfMemory(size);\n  return memory;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 237
    },
    {
        "index": 183445,
        "code": "void FrameLoaderClient::windowObjectCleared()\n{\n    g_signal_emit_by_name(m_frame, \"cleared\");\n\n    Frame* coreFrame = core(m_frame);\n    ASSERT(coreFrame);\n\n    Settings* settings = coreFrame->settings();\n    if (!settings || !settings->isJavaScriptEnabled())\n        return;\n \n    JSGlobalContextRef context = toGlobalRef(coreFrame->script()->globalObject()->globalExec());\n    JSObjectRef windowObject = toRef(coreFrame->script()->globalObject());\n     ASSERT(windowObject);\n \n     WebKitWebView* webView = getViewFromFrame(m_frame);\n    g_signal_emit_by_name(webView, \"window-object-cleared\", m_frame, context, windowObject);\n\n}\n",
        "line": "    JSGlobalContextRef context = toGlobalRef(coreFrame->script()->globalObject()->globalExec());\n    JSObjectRef windowObject = toRef(coreFrame->script()->globalObject());\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 146
    },
    {
        "index": 167728,
        "code": "void WebRuntimeFeatures::EnableMiddleClickAutoscroll(bool enable) {\n  RuntimeEnabledFeatures::SetMiddleClickAutoscrollEnabled(enable);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-16075",
        "length": 31
    },
    {
        "index": 185220,
        "code": "TabContents* TabStripModel::DetachTabContentsAt(int index) {\n  if (contents_data_.empty())\n    return NULL;\n\n  DCHECK(ContainsIndex(index));\n\n  TabContents* removed_contents = GetTabContentsAtImpl(index);\n  bool was_selected = IsTabSelected(index);\n  int next_selected_index = order_controller_->DetermineNewSelectedIndex(index);\n  delete contents_data_[index];\n  contents_data_.erase(contents_data_.begin() + index);\n  ForgetOpenersAndGroupsReferencing(removed_contents->web_contents());\n   if (empty())\n     closing_all_ = true;\n   FOR_EACH_OBSERVER(TabStripModelObserver, observers_,\n      TabDetachedAt(removed_contents, index));\n   if (empty()) {\n     selection_model_.Clear();\n    FOR_EACH_OBSERVER(TabStripModelObserver, observers_, TabStripEmpty());\n  } else {\n    int old_active = active_index();\n    selection_model_.DecrementFrom(index);\n    TabStripSelectionModel old_model;\n    old_model.Copy(selection_model_);\n    if (index == old_active) {\n      NotifyIfTabDeactivated(removed_contents);\n      if (!selection_model_.empty()) {\n        selection_model_.set_active(selection_model_.selected_indices()[0]);\n        selection_model_.set_anchor(selection_model_.active());\n      } else {\n        selection_model_.SetSelectedIndex(next_selected_index);\n      }\n      NotifyIfActiveTabChanged(removed_contents, NOTIFY_DEFAULT);\n    }\n\n    if (was_selected) {\n      FOR_EACH_OBSERVER(TabStripModelObserver, observers_,\n                        TabSelectionChanged(this, old_model));\n    }\n  }\n  return removed_contents;\n}\n",
        "line": "      TabDetachedAt(removed_contents, index));\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 338
    },
    {
        "index": 58665,
        "code": "void security_mac_salt_key(const BYTE* session_key_blob, const BYTE* client_random,\n\t\tconst BYTE* server_random, BYTE* output)\n{\n\t/* MacSaltKey = First128Bits(SessionKeyBlob) */\n\tmemcpy(output, session_key_blob, 16);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2013-4118",
        "length": 56
    },
    {
        "index": 35588,
        "code": "static int read_interrupt_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     u16 index, struct desc_struct *desc)\n{\n\tstruct desc_ptr dt;\n\tulong addr;\n\n\tctxt->ops->get_idt(ctxt, &dt);\n\n\tif (dt.size < index * 8 + 7)\n\t\treturn emulate_gp(ctxt, index << 3 | 0x2);\n\n\taddr = dt.address + index * 8;\n\treturn ctxt->ops->read_std(ctxt, addr, desc, sizeof *desc,\n\t\t\t\t   &ctxt->exception);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-8481",
        "length": 115
    },
    {
        "index": 44840,
        "code": "local voidpf zlib_alloc(voidpf opaque, uInt items, uInt size)\n{\n    return malloc_track(opaque, items * (size_t)size);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2015-1191",
        "length": 34
    },
    {
        "index": 13219,
        "code": "getPluginDescription() \n{\n    static const char* desc = NULL;\n    if (!desc) {\n        desc = std::getenv(\"GNASH_PLUGIN_DESCRIPTION\");\n        if (desc == NULL) desc = PLUGIN_DESCRIPTION;\n    }\n    return desc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4328",
        "length": 54
    },
    {
        "index": 49718,
        "code": "void set_disk_ro(struct gendisk *disk, int flag)\n{\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\n\tif (disk->part0.policy != flag) {\n\t\tset_disk_ro_uevent(disk, flag);\n\t\tdisk->part0.policy = flag;\n\t}\n\n\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tpart->policy = flag;\n\tdisk_part_iter_exit(&piter);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-7910",
        "length": 111
    },
    {
        "index": 51426,
        "code": "int gdImageColorExact (gdImagePtr im, int r, int g, int b)\n{\n\treturn gdImageColorExactAlpha (im, r, g, b, gdAlphaOpaque);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-5767",
        "length": 42
    },
    {
        "index": 112282,
        "code": "void ShellWindow::AddNewContents(WebContents* source,\n                                 WebContents* new_contents,\n                                 WindowOpenDisposition disposition,\n                                 const gfx::Rect& initial_pos,\n                                 bool user_gesture) {\n  DCHECK(source == web_contents_);\n  DCHECK(Profile::FromBrowserContext(new_contents->GetBrowserContext()) ==\n      profile_);\n  Browser* browser = browser::FindOrCreateTabbedBrowser(profile_);\n  disposition =\n      disposition == NEW_BACKGROUND_TAB ? disposition : NEW_FOREGROUND_TAB;\n  browser->AddWebContents(\n      new_contents, disposition, initial_pos, user_gesture);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 119
    },
    {
        "index": 161267,
        "code": "gfx::Vector2dF CssPixelsToVector2dF(double x,\n                                    double y,\n                                    float page_scale_factor) {\n  return gfx::Vector2dF(x * page_scale_factor, y * page_scale_factor);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6111",
        "length": 49
    },
    {
        "index": 35986,
        "code": "SMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\t__constant_cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-7145",
        "length": 152
    },
    {
        "index": 13790,
        "code": "ZEND_API int zend_fcall_info_argp(zend_fcall_info *fci TSRMLS_DC, int argc, zval ***argv) /* {{{ */\n{\n\tint i;\n\n\tif (argc < 0) {\n\t\treturn FAILURE;\n\t}\n\n\tzend_fcall_info_args_clear(fci, !argc);\n\n\tif (argc) {\n\t\tfci->param_count = argc;\n\t\tfci->params = (zval ***) erealloc(fci->params, fci->param_count * sizeof(zval **));\n\n\t\tfor (i = 0; i < argc; ++i) {\n\t\t\tfci->params[i] = argv[i];\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9137",
        "length": 146
    },
    {
        "index": 158695,
        "code": "void GLES2DecoderImpl::DoTexParameterfv(GLenum target,\n                                        GLenum pname,\n                                        const volatile GLfloat* params) {\n  TextureRef* texture = texture_manager()->GetTextureInfoForTarget(\n      &state_, target);\n  if (!texture) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, \"glTexParameterfv\", \"unknown texture\");\n    return;\n  }\n\n  texture_manager()->SetParameterf(\n      \"glTexParameterfv\", GetErrorState(), texture, pname, *params);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-17470",
        "length": 102
    },
    {
        "index": 15510,
        "code": "static int bcast_or_ucast(struct dhcp_packet *packet, uint32_t ciaddr, uint32_t server)\n{\n\tif (server)\n\t\treturn udhcp_send_kernel_packet(packet,\n\t\t\tciaddr, CLIENT_PORT,\n\t\t\tserver, SERVER_PORT);\n\treturn raw_bcast_from_client_config_ifindex(packet);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2148",
        "length": 65
    },
    {
        "index": 25338,
        "code": "const struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n\treturn &user_arm_view;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 27
    },
    {
        "index": 165436,
        "code": "void StoragePartitionImpl::WaitForDeletionTasksForTesting() {\n  if (deletion_helpers_running_) {\n    base::RunLoop loop;\n    on_deletion_helpers_done_callback_ = loop.QuitClosure();\n    loop.Run();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2019-5797",
        "length": 50
    },
    {
        "index": 5363,
        "code": "  static void  Ins_ALIGNPTS( INS_ARG )\n  {\n    Int         p1, p2;\n    TT_F26Dot6  distance;\n\n    p1 = (Int)args[0];\n   p2 = (Int)args[1];\n\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) ||\n         BOUNDS( args[1], CUR.zp0.n_points ) )\n    {\n      CUR.error = TT_Err_Invalid_Reference;\n      return;\n    }\n\n    distance = CUR_Func_project( CUR.zp0.cur_x[p2] -\n                                   CUR.zp1.cur_x[p1],\n                                 CUR.zp0.cur_y[p2] -\n                                   CUR.zp1.cur_y[p1] ) / 2;\n\n    CUR_Func_move( &CUR.zp1, p1, distance );\n\n    CUR_Func_move( &CUR.zp0, p2, -distance );\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-9739",
        "length": 196
    },
    {
        "index": 131908,
        "code": "static void voidMethodFloatArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"voidMethodFloatArg\", \"TestObjectPython\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(float, floatArg, static_cast<float>(info[0]->NumberValue()));\n    imp->voidMethodFloatArg(floatArg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 131
    },
    {
        "index": 185548,
        "code": " void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)\n {\n     ASSERT(m_form);\n    if (toHTMLElement(this)->highestAncestor() != formRoot)\n        setForm(0);\n }\n",
        "line": "    if (toHTMLElement(this)->highestAncestor() != formRoot)\n        setForm(0);\n",
        "label": 1,
        "cwe": "CWE-287",
        "cve": "CVE-2013-6643",
        "length": 44
    },
    {
        "index": 125272,
        "code": "void RenderViewImpl::OnEnumerateDirectoryResponse(\n    int id,\n    const std::vector<FilePath>& paths) {\n  if (!enumeration_completions_[id])\n    return;\n\n  WebVector<WebString> ws_file_names(paths.size());\n  for (size_t i = 0; i < paths.size(); ++i)\n    ws_file_names[i] = webkit_base::FilePathToWebString(paths[i]);\n\n  enumeration_completions_[id]->didChooseFile(ws_file_names);\n  enumeration_completions_.erase(id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 115
    },
    {
        "index": 171011,
        "code": "void AudioFlinger::EffectModule::process()\n{\n Mutex::Autolock _l(mLock);\n\n if (mState == DESTROYED || mEffectInterface == NULL ||\n            mConfig.inputCfg.buffer.raw == NULL ||\n            mConfig.outputCfg.buffer.raw == NULL) {\n return;\n }\n\n if (isProcessEnabled()) {\n if ((mDescriptor.flags & EFFECT_FLAG_TYPE_MASK) == EFFECT_FLAG_TYPE_AUXILIARY) {\n            ditherAndClamp(mConfig.inputCfg.buffer.s32,\n                                        mConfig.inputCfg.buffer.s32,\n                                        mConfig.inputCfg.buffer.frameCount/2);\n }\n\n int ret = (*mEffectInterface)->process(mEffectInterface,\n &mConfig.inputCfg.buffer,\n &mConfig.outputCfg.buffer);\n\n if (mState == STOPPED && ret == -ENODATA) {\n            mDisableWaitCnt = 1;\n }\n\n if ((mDescriptor.flags & EFFECT_FLAG_TYPE_MASK) == EFFECT_FLAG_TYPE_AUXILIARY) {\n            memset(mConfig.inputCfg.buffer.raw, 0,\n                   mConfig.inputCfg.buffer.frameCount*sizeof(int32_t));\n }\n } else if ((mDescriptor.flags & EFFECT_FLAG_TYPE_MASK) == EFFECT_FLAG_TYPE_INSERT &&\n                mConfig.inputCfg.buffer.raw != mConfig.outputCfg.buffer.raw) {\n        sp<EffectChain> chain = mChain.promote();\n if (chain != 0 && chain->activeTrackCnt() != 0) {\n size_t frameCnt = mConfig.inputCfg.buffer.frameCount * 2; //always stereo here\n int16_t *in = mConfig.inputCfg.buffer.s16;\n int16_t *out = mConfig.outputCfg.buffer.s16;\n for (size_t i = 0; i < frameCnt; i++) {\n                out[i] = clamp16((int32_t)out[i] + (int32_t)in[i]);\n }\n }\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3924",
        "length": 382
    },
    {
        "index": 128939,
        "code": "    void doWriteUint64(uint64_t value)\n    {\n        doWriteUintHelper(value);\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3171",
        "length": 23
    },
    {
        "index": 25905,
        "code": "static unsigned long ptrace_get_debugreg(struct task_struct *tsk, int n)\n{\n\tstruct thread_struct *thread = &(tsk->thread);\n\tunsigned long val = 0;\n\n\tif (n < HBP_NUM) {\n\t\tstruct perf_event *bp;\n\n\t\tif (ptrace_get_breakpoints(tsk) < 0)\n\t\t\treturn -ESRCH;\n\n\t\tbp = thread->ptrace_bps[n];\n\t\tif (!bp)\n\t\t\tval = 0;\n\t\telse\n\t\t\tval = bp->hw.info.address;\n\n\t\tptrace_put_breakpoints(tsk);\n\t} else if (n == 6) {\n\t\tval = thread->debugreg6;\n\t } else if (n == 7) {\n\t\tval = thread->ptrace_dr7;\n\t}\n\treturn val;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 168
    },
    {
        "index": 120075,
        "code": "size_t SharedMemory::GetHandleLimit() {\n  return base::GetMaxFds();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-2905",
        "length": 21
    },
    {
        "index": 94676,
        "code": "int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)\n\t{\n\treturn ASN1_i2d_bio_of(PKCS8_PRIV_KEY_INFO,i2d_PKCS8_PRIV_KEY_INFO,bp,\n\t\t\t       p8inf);\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2014-8275",
        "length": 64
    },
    {
        "index": 53841,
        "code": "static void acpi_os_execute_deferred(struct work_struct *work)\n{\n\tstruct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);\n\n\tdpc->function(dpc->context);\n\tkfree(dpc);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-3699",
        "length": 54
    },
    {
        "index": 13545,
        "code": "static void  Free_PosClassRule( HB_PosClassRule*  pcr )\n{\n  FREE( pcr->PosLookupRecord );\n  FREE( pcr->Class );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3193",
        "length": 38
    },
    {
        "index": 67184,
        "code": "static int mpol_new_bind(struct mempolicy *pol, const nodemask_t *nodes)\n{\n\tif (nodes_empty(*nodes))\n\t\treturn -EINVAL;\n\tpol->v.nodes = *nodes;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-388",
        "cve": "CVE-2017-7616",
        "length": 48
    },
    {
        "index": 178358,
        "code": "static int rndis_set_response(USBNetState *s,\n                rndis_set_msg_type *buf, unsigned int length)\n{\n    rndis_set_cmplt_type *resp =\n            rndis_queue_response(s, sizeof(rndis_set_cmplt_type));\n    uint32_t bufoffs, buflen;\n    int ret;\n\n    if (!resp)\n        return USB_RET_STALL;\n\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));\n    if (ret < 0) {\n        /* OID not supported */\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n    return 0;\n}\n",
        "line": "    if (bufoffs + buflen > length)\n",
        "label": 1,
        "cwe": "CWE-189",
        "cve": "CVE-2016-2538",
        "length": 244
    },
    {
        "index": 80796,
        "code": "GF_Err mfro_dump(GF_Box *a, FILE * trace)\n{\n\tGF_MovieFragmentRandomAccessOffsetBox *p = (GF_MovieFragmentRandomAccessOffsetBox *)a;\n\n\tgf_isom_box_dump_start(a, \"MovieFragmentRandomAccessOffsetBox\", trace);\n\n\tfprintf(trace, \"container_size=\\\"%d\\\" >\\n\", p->container_size);\n\tgf_isom_box_dump_done(\"MovieFragmentRandomAccessOffsetBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 102
    },
    {
        "index": 146705,
        "code": "bool Document::AllowInlineEventHandler(Node* node,\n                                       EventListener* listener,\n                                       const String& context_url,\n                                       const WTF::OrdinalNumber& context_line) {\n  Element* element = node && node->IsElementNode() ? ToElement(node) : nullptr;\n  if (!ContentSecurityPolicy::ShouldBypassMainWorld(this) &&\n      !GetContentSecurityPolicy()->AllowInlineEventHandler(\n          element, listener->Code(), context_url, context_line))\n    return false;\n\n  LocalFrame* frame = ExecutingFrame();\n  if (!frame)\n    return false;\n  if (!ContextDocument()->CanExecuteScripts(kNotAboutToExecuteScript))\n    return false;\n  if (node && node->GetDocument() != this &&\n      !node->GetDocument().AllowInlineEventHandler(node, listener, context_url,\n                                                   context_line))\n    return false;\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 181
    },
    {
        "index": 103747,
        "code": "void RenderThread::DoNotSuspendWebKitSharedTimer() {\n  suspend_webkit_shared_timer_ = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 25
    },
    {
        "index": 87003,
        "code": "static TEE_Result set_tmem_param(const struct optee_msg_param_tmem *tmem,\n\t\t\t\t uint32_t attr, struct param_mem *mem)\n{\n\tstruct mobj __maybe_unused **mobj;\n\tpaddr_t pa = READ_ONCE(tmem->buf_ptr);\n\tsize_t sz = READ_ONCE(tmem->size);\n\n\t/* NULL Memory Rerefence? */\n\tif (!pa && !sz) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Non-contigous buffer from non sec DDR? */\n\tif (attr & OPTEE_MSG_ATTR_NONCONTIG) {\n\t\tuint64_t shm_ref = READ_ONCE(tmem->shm_ref);\n\n\t\tmem->mobj = msg_param_mobj_from_noncontig(pa, sz, shm_ref,\n\t\t\t\t\t\t\t  false);\n\t\tif (!mem->mobj)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tmem->offs = 0;\n\t\tmem->size = sz;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Belongs to nonsecure shared memory? */\n\tif (param_mem_from_mobj(mem, shm_mobj, pa, sz))\n\t\treturn TEE_SUCCESS;\n\n#ifdef CFG_SECURE_DATA_PATH\n\t/* Belongs to SDP memories? */\n\tfor (mobj = sdp_mem_mobjs; *mobj; mobj++)\n\t\tif (param_mem_from_mobj(mem, *mobj, pa, sz))\n\t\t\treturn TEE_SUCCESS;\n#endif\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-1010292",
        "length": 323
    },
    {
        "index": 65249,
        "code": "compose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 266
    },
    {
        "index": 181225,
        "code": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n \n        g_return_val_if_fail (client != NULL, TRUE);\n \n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }\n",
        "line": "        IceConn        ice_conn;\n        GsmXSMPClient *client;\n        client = ice_conn->context;\n        g_return_val_if_fail (client != NULL, TRUE);\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n",
        "label": 1,
        "cwe": "CWE-835",
        "cve": "CVE-2017-11171",
        "length": 205
    },
    {
        "index": 143644,
        "code": "bool RenderWidgetHostImpl::GotResponseToLockMouseRequest(bool allowed) {\n  if (!allowed) {\n    RejectMouseLockOrUnlockIfNecessary();\n    return false;\n  }\n\n  if (!pending_mouse_lock_request_) {\n    return false;\n  }\n\n  pending_mouse_lock_request_ = false;\n  if (!view_ || !view_->HasFocus()|| !view_->LockMouse()) {\n    Send(new ViewMsg_LockMouse_ACK(routing_id_, false));\n    return false;\n  }\n\n  Send(new ViewMsg_LockMouse_ACK(routing_id_, true));\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1647",
        "length": 124
    },
    {
        "index": 4734,
        "code": "user_get_local_account (User *user)\n{\n        return accounts_user_get_local_account (ACCOUNTS_USER (user));;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2018-14036",
        "length": 27
    },
    {
        "index": 74282,
        "code": "void pre_scan(char *parent_name, unsigned int start_block, unsigned int offset,\n\tstruct pathnames *paths)\n{\n\tunsigned int type;\n\tchar *name;\n\tstruct pathnames *new;\n\tstruct inode *i;\n\tstruct dir *dir = s_ops.squashfs_opendir(start_block, offset, &i);\n\n\tif(dir == NULL)\n\t\treturn;\n\n\twhile(squashfs_readdir(dir, &name, &start_block, &offset, &type)) {\n\t\tstruct inode *i;\n\t\tchar *pathname;\n\t\tint res;\n\n\t\tTRACE(\"pre_scan: name %s, start_block %d, offset %d, type %d\\n\",\n\t\t\tname, start_block, offset, type);\n\n\t\tif(!matches(paths, name, &new))\n\t\t\tcontinue;\n\n\t\tres = asprintf(&pathname, \"%s/%s\", parent_name, name);\n\t\tif(res == -1)\n\t\t\tEXIT_UNSQUASH(\"asprintf failed in dir_scan\\n\");\n\n\t\tif(type == SQUASHFS_DIR_TYPE)\n\t\t\tpre_scan(parent_name, start_block, offset, new);\n\t\telse if(new == NULL) {\n\t\t\tif(type == SQUASHFS_FILE_TYPE ||\n\t\t\t\t\ttype == SQUASHFS_LREG_TYPE) {\n\t\t\t\ti = s_ops.read_inode(start_block, offset);\n\t\t\t\tif(created_inode[i->inode_number - 1] == NULL) {\n\t\t\t\t\tcreated_inode[i->inode_number - 1] =\n\t\t\t\t\t\t(char *) i;\n\t\t\t\t\ttotal_blocks += (i->data +\n\t\t\t\t\t\t(block_size - 1)) >> block_log;\n\t\t\t\t}\n\t\t\t\ttotal_files ++;\n\t\t\t}\n\t\t\ttotal_inodes ++;\n\t\t}\n\n\t\tfree_subdir(new);\n\t\tfree(pathname);\n\t}\n\n\tsquashfs_closedir(dir);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2015-4645",
        "length": 362
    },
    {
        "index": 74498,
        "code": "static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)\n{\n\tstruct regulator_enable_gpio *pin = rdev->ena_pin;\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\t/* Enable GPIO at initial use */\n\t\tif (pin->enable_count == 0)\n\t\t\tgpiod_set_value_cansleep(pin->gpiod,\n\t\t\t\t\t\t !pin->ena_gpio_invert);\n\n\t\tpin->enable_count++;\n\t} else {\n\t\tif (pin->enable_count > 1) {\n\t\t\tpin->enable_count--;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Disable GPIO if not used */\n\t\tif (pin->enable_count <= 1) {\n\t\t\tgpiod_set_value_cansleep(pin->gpiod,\n\t\t\t\t\t\t pin->ena_gpio_invert);\n\t\t\tpin->enable_count = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-9940",
        "length": 192
    },
    {
        "index": 186344,
        "code": " PreresolveJob::PreresolveJob(PreconnectRequest preconnect_request,\n                              PreresolveInfo* info)\n    : url(std::move(preconnect_request.origin)),\n       num_sockets(preconnect_request.num_sockets),\n       allow_credentials(preconnect_request.allow_credentials),\n       network_isolation_key(\n          std::move(preconnect_request.network_isolation_key)),\n      info(info) {\n  DCHECK_GE(num_sockets, 0);\n}\n",
        "line": "    : url(std::move(preconnect_request.origin)),\n",
        "label": 1,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5077",
        "length": 91
    },
    {
        "index": 139854,
        "code": "void Shell::SetTouchHudProjectionEnabled(bool enabled) {\n  if (is_touch_hud_projection_enabled_ == enabled)\n    return;\n\n  is_touch_hud_projection_enabled_ = enabled;\n  FOR_EACH_OBSERVER(ShellObserver, observers_,\n                    OnTouchHudProjectionToggled(enabled));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 64
    },
    {
        "index": 30402,
        "code": "static void vmci_transport_qp_resumed_cb(u32 sub_id,\n\t\t\t\t\t const struct vmci_event_data *e_data,\n\t\t\t\t\t void *client_data)\n{\n\tvsock_for_each_connected_socket(vmci_transport_handle_detach);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-3236",
        "length": 46
    },
    {
        "index": 170721,
        "code": "inline static const char *asString(IOMX::InternalOptionType i, const char *def = \"??\") {\n switch (i) {\n case IOMX::INTERNAL_OPTION_SUSPEND: return \"SUSPEND\";\n case IOMX::INTERNAL_OPTION_REPEAT_PREVIOUS_FRAME_DELAY:\n return \"REPEAT_PREVIOUS_FRAME_DELAY\";\n case IOMX::INTERNAL_OPTION_MAX_TIMESTAMP_GAP: return \"MAX_TIMESTAMP_GAP\";\n case IOMX::INTERNAL_OPTION_START_TIME: return \"START_TIME\";\n case IOMX::INTERNAL_OPTION_TIME_LAPSE: return \"TIME_LAPSE\";\n default: return def;\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3835",
        "length": 126
    },
    {
        "index": 161137,
        "code": "bool MediaStreamManager::IsOriginAllowed(int render_process_id,\n                                         const url::Origin& origin) {\n  if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(\n          render_process_id, origin.GetURL())) {\n    LOG(ERROR) << \"MSM: Renderer requested a URL it's not allowed to use: \"\n               << origin.Serialize();\n    return false;\n  }\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6103",
        "length": 85
    },
    {
        "index": 127677,
        "code": "static void installV8TestInterfaceNodeTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::FunctionTemplate> interfaceTemplate)\n{\n    V8DOMConfiguration::initializeDOMInterfaceTemplate(isolate, interfaceTemplate, V8TestInterfaceNode::wrapperTypeInfo.interfaceName, V8Node::domTemplate(isolate, world), V8TestInterfaceNode::internalFieldCount);\n    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interfaceTemplate);\n    ALLOW_UNUSED_LOCAL(signature);\n    v8::Local<v8::ObjectTemplate> instanceTemplate = interfaceTemplate->InstanceTemplate();\n    ALLOW_UNUSED_LOCAL(instanceTemplate);\n    v8::Local<v8::ObjectTemplate> prototypeTemplate = interfaceTemplate->PrototypeTemplate();\n    ALLOW_UNUSED_LOCAL(prototypeTemplate);\n    V8DOMConfiguration::installAccessors(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8TestInterfaceNodeAccessors, WTF_ARRAY_LENGTH(V8TestInterfaceNodeAccessors));\n    V8DOMConfiguration::installMethods(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8TestInterfaceNodeMethods, WTF_ARRAY_LENGTH(V8TestInterfaceNodeMethods));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-7901",
        "length": 253
    },
    {
        "index": 2304,
        "code": "_PUBLIC_ char *talloc_strdup_upper(TALLOC_CTX *ctx, const char *src)\n{\n\treturn strupper_talloc(ctx, src);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5330",
        "length": 31
    },
    {
        "index": 18516,
        "code": "static void release_memory_resource(struct resource *res)\n{\n\tif (!res)\n\t\treturn;\n\trelease_resource(res);\n\tkfree(res);\n\treturn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5517",
        "length": 30
    },
    {
        "index": 143193,
        "code": "const KURL Document::firstPartyForCookies() const\n{\n    Frame* top = frame()->tree().top();\n    KURL topDocumentURL = top->isLocalFrame()\n        ? toLocalFrame(top)->document()->url()\n        : KURL(KURL(), top->securityContext()->getSecurityOrigin()->toString());\n    if (SchemeRegistry::shouldTreatURLSchemeAsFirstPartyWhenTopLevel(topDocumentURL.protocol()))\n        return topDocumentURL;\n\n    const OriginAccessEntry& accessEntry = top->isLocalFrame()\n        ? toLocalFrame(top)->document()->accessEntryFromURL()\n        : OriginAccessEntry(topDocumentURL.protocol(), topDocumentURL.host(), OriginAccessEntry::AllowRegisterableDomains);\n    const Frame* currentFrame = frame();\n    while (currentFrame) {\n        while (currentFrame->isLocalFrame() && toLocalFrame(currentFrame)->document()->isSrcdocDocument())\n            currentFrame = currentFrame->tree().parent();\n        DCHECK(currentFrame);\n\n        if (accessEntry.matchesDomain(*currentFrame->securityContext()->getSecurityOrigin()) == OriginAccessEntry::DoesNotMatchOrigin)\n            return SecurityOrigin::urlWithUniqueSecurityOrigin();\n\n        currentFrame = currentFrame->tree().parent();\n    }\n\n    return topDocumentURL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 263
    },
    {
        "index": 1079,
        "code": "void GfxCalRGBColorSpace::getXYZ(GfxColor *color, \n  double *pX, double *pY, double *pZ) {\n  double A, B, C;\n\n  A = colToDbl(color->c[0]);\n  B = colToDbl(color->c[1]);\n  C = colToDbl(color->c[2]);\n  *pX = mat[0]*pow(A,gammaR)+mat[3]*pow(B,gammaG)+mat[6]*pow(C,gammaB);\n  *pY = mat[1]*pow(A,gammaR)+mat[4]*pow(B,gammaG)+mat[7]*pow(C,gammaB);\n  *pZ = mat[2]*pow(A,gammaR)+mat[5]*pow(B,gammaG)+mat[8]*pow(C,gammaB);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 188
    },
    {
        "index": 27858,
        "code": "static ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\t  unsigned long nr_segs, loff_t pos)\n{\n\tstruct inode *inode = iocb->ki_filp->f_mapping->host;\n\n\tif (pos + iov_length(iov, nr_segs) > i_size_read(inode)) {\n\t\tint err;\n\t\t/*\n\t\t * If trying to read past EOF, make sure the i_size\n\t\t * attribute is up-to-date.\n\t\t */\n\t\terr = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn generic_file_aio_read(iocb, iov, nr_segs, pos);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2010-4650",
        "length": 158
    },
    {
        "index": 34566,
        "code": "struct socket *macvtap_get_socket(struct file *file)\n{\n\tstruct macvtap_queue *q;\n\tif (file->f_op != &macvtap_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\tq = file->private_data;\n\tif (!q)\n\t\treturn ERR_PTR(-EBADFD);\n\treturn &q->sock;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2119",
        "length": 71
    },
    {
        "index": 34971,
        "code": "static void rpc_release_task(struct rpc_task *task)\n{\n\tdprintk(\"RPC: %5u release task\\n\", task->tk_pid);\n\n\tBUG_ON (RPC_IS_QUEUED(task));\n\n\trpc_release_resources_task(task);\n\n\t/*\n\t * Note: at this point we have been removed from rpc_clnt->cl_tasks,\n\t * so it should be safe to use task->tk_count as a test for whether\n\t * or not any other processes still hold references to our rpc_task.\n\t */\n\tif (atomic_read(&task->tk_count) != 1 + !RPC_IS_ASYNC(task)) {\n\t\t/* Wake up anyone who may be waiting for task completion */\n\t\tif (!rpc_complete_task(task))\n\t\t\treturn;\n\t} else {\n\t\tif (!atomic_dec_and_test(&task->tk_count))\n\t\t\treturn;\n\t}\n\trpc_final_put_task(task, task->tk_workqueue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2491",
        "length": 188
    },
    {
        "index": 184505,
        "code": "AudioOutputStream* AudioManagerBase::MakeAudioOutputStreamProxy(\n    const AudioParameters& params) {\n  DCHECK(GetMessageLoop()->BelongsToCurrentThread());\n\n  scoped_refptr<AudioOutputDispatcher>& dispatcher =\n      output_dispatchers_[params];\n   if (!dispatcher) {\n     base::TimeDelta close_delay =\n         base::TimeDelta::FromSeconds(kStreamCloseDelaySeconds);\n#if defined(OS_WIN) || defined(OS_MACOSX)\n     const CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n    if (!cmd_line->HasSwitch(switches::kDisableAudioMixer)) {\n       dispatcher = new AudioOutputMixer(this, params, close_delay);\n    } else\n#endif\n    {\n       dispatcher = new AudioOutputDispatcherImpl(this, params, close_delay);\n     }\n   }\n  return new AudioOutputProxy(dispatcher);\n}\n",
        "line": "#if defined(OS_WIN) || defined(OS_MACOSX)\n    if (!cmd_line->HasSwitch(switches::kDisableAudioMixer)) {\n    } else\n#endif\n    {\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 171
    },
    {
        "index": 67228,
        "code": "static s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct net_device *ndev = cfg_to_ndev(cfg);\n\tstruct brcmf_if *ifp = netdev_priv(ndev);\n\n\tbrcmf_dbg(TRACE, \"Enter\\n\");\n\n\tif (cfg->wowl.active) {\n\t\tbrcmf_report_wowl_wakeind(wiphy, ifp);\n\t\tbrcmf_fil_iovar_int_set(ifp, \"wowl_clear\", 0);\n\t\tbrcmf_config_wowl_pattern(ifp, \"clr\", NULL, 0, NULL, 0);\n\t\tif (!brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_ARP_ND))\n\t\t\tbrcmf_configure_arp_nd_offload(ifp, true);\n\t\tbrcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM,\n\t\t\t\t      cfg->wowl.pre_pmmode);\n\t\tcfg->wowl.active = false;\n\t\tif (cfg->wowl.nd_enabled) {\n\t\t\tbrcmf_cfg80211_sched_scan_stop(cfg->wiphy, ifp->ndev, 0);\n\t\t\tbrcmf_fweh_unregister(cfg->pub, BRCMF_E_PFN_NET_FOUND);\n\t\t\tbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\n\t\t\t\t\t    brcmf_notify_sched_scan_results);\n\t\t\tcfg->wowl.nd_enabled = false;\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7541",
        "length": 327
    },
    {
        "index": 188530,
        "code": "void filter_average_block2d_8_c(const uint8_t *src_ptr,\n const unsigned int src_stride,\n const int16_t *HFilter,\n const int16_t *VFilter,\n uint8_t *dst_ptr,\n\n                                 unsigned int dst_stride,\n                                 unsigned int output_width,\n                                 unsigned int output_height) {\n  uint8_t tmp[64 * 64];\n \n  assert(output_width <= 64);\n  assert(output_height <= 64);\n   filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,\n                      output_width, output_height);\n   block2d_average_c(tmp, 64, dst_ptr, dst_stride,\n                     output_width, output_height);\n }\n",
        "line": "  uint8_t tmp[64 * 64];\n  assert(output_width <= 64);\n  assert(output_height <= 64);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 151
    },
    {
        "index": 3296,
        "code": "static inline FDrive *drv3(FDCtrl *fdctrl)\n{\n    if ((fdctrl->tdr & FD_TDR_BOOTSEL) < (3 << 2))\n        return &fdctrl->drives[3];\n    else\n        return &fdctrl->drives[2];\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3456",
        "length": 64
    },
    {
        "index": 6317,
        "code": "static inline zend_object_value date_object_new_date_ex(zend_class_entry *class_type, php_date_obj **ptr TSRMLS_DC)\n{\n\tphp_date_obj *intern;\n\tzend_object_value retval;\n\n\tintern = emalloc(sizeof(php_date_obj));\n\tmemset(intern, 0, sizeof(php_date_obj));\n\tif (ptr) {\n\t\t*ptr = intern;\n\t}\n\t\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\t\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t)zend_objects_destroy_object, (zend_objects_free_object_storage_t) date_object_free_storage_date, NULL TSRMLS_CC);\n\tretval.handlers = &date_object_handlers_date;\n\t\n\treturn retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-0273",
        "length": 162
    },
    {
        "index": 100817,
        "code": "void HttpResponseHeaders::Persist(Pickle* pickle, PersistOptions options) {\n  if (options == PERSIST_RAW) {\n    pickle->WriteString(raw_headers_);\n    return;  // Done.\n  }\n\n  HeaderSet filter_headers;\n\n  if ((options & PERSIST_SANS_NON_CACHEABLE) == PERSIST_SANS_NON_CACHEABLE)\n    AddNonCacheableHeaders(&filter_headers);\n\n  if ((options & PERSIST_SANS_COOKIES) == PERSIST_SANS_COOKIES)\n    AddCookieHeaders(&filter_headers);\n\n  if ((options & PERSIST_SANS_CHALLENGES) == PERSIST_SANS_CHALLENGES)\n    AddChallengeHeaders(&filter_headers);\n\n  if ((options & PERSIST_SANS_HOP_BY_HOP) == PERSIST_SANS_HOP_BY_HOP)\n    AddHopByHopHeaders(&filter_headers);\n\n  if ((options & PERSIST_SANS_RANGES) == PERSIST_SANS_RANGES)\n    AddHopContentRangeHeaders(&filter_headers);\n\n  std::string blob;\n  blob.reserve(raw_headers_.size());\n\n  blob.assign(raw_headers_.c_str(), strlen(raw_headers_.c_str()) + 1);\n\n  for (size_t i = 0; i < parsed_.size(); ++i) {\n    DCHECK(!parsed_[i].is_continuation());\n\n    size_t k = i;\n    while (++k < parsed_.size() && parsed_[k].is_continuation()) {}\n    --k;\n\n    std::string header_name(parsed_[i].name_begin, parsed_[i].name_end);\n    StringToLowerASCII(&header_name);\n\n    if (filter_headers.find(header_name) == filter_headers.end()) {\n      blob.append(parsed_[i].name_begin, parsed_[k].value_end);\n      blob.push_back('\\0');\n    }\n\n    i = k;\n  }\n  blob.push_back('\\0');\n\n  pickle->WriteString(blob);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 393
    },
    {
        "index": 169712,
        "code": "ScopedAvoidIdentityHashForTesting::ScopedAvoidIdentityHashForTesting(\n    content::V8ValueConverterImpl* converter)\n    : converter_(converter) {\n  CHECK(converter_);\n  converter_->avoid_identity_hash_for_testing_ = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1679",
        "length": 51
    },
    {
        "index": 185376,
        "code": "void ChildThread::Shutdown() {\n   file_system_dispatcher_.reset();\n   quota_dispatcher_.reset();\n }\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": "CVE-2014-3154",
        "length": 22
    },
    {
        "index": 150430,
        "code": "  bool has_delegate() const { return has_delegate_; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2017-5032",
        "length": 13
    },
    {
        "index": 78773,
        "code": "struct sc_card_driver * sc_get_muscle_driver(void)\n{\n\treturn sc_get_driver();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-16425",
        "length": 21
    },
    {
        "index": 141955,
        "code": "std::unique_ptr<views::View> AutofillPopupViewViews::CreateWrapperView() {\n  auto wrapper_view = std::make_unique<views::ScrollView>();\n  scroll_view_ = wrapper_view.get();\n  scroll_view_->set_hide_horizontal_scrollbar(true);\n  scroll_view_->SetContents(this);\n  return wrapper_view;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5185",
        "length": 69
    },
    {
        "index": 60896,
        "code": "file_list_cancel (NautilusDirectory *directory)\n{\n    directory_load_cancel (directory);\n\n    if (directory->details->dequeue_pending_idle_id != 0)\n    {\n        g_source_remove (directory->details->dequeue_pending_idle_id);\n        directory->details->dequeue_pending_idle_id = 0;\n    }\n\n    if (directory->details->pending_file_info != NULL)\n    {\n        g_list_free_full (directory->details->pending_file_info, g_object_unref);\n        directory->details->pending_file_info = NULL;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-14604",
        "length": 115
    },
    {
        "index": 186292,
        "code": " void WebContentsImpl::AttachInterstitialPage(\n     InterstitialPageImpl* interstitial_page) {\n  DCHECK(interstitial_page);\n  GetRenderManager()->set_interstitial_page(interstitial_page);\n \n  CancelActiveAndPendingDialogs();\n\n  for (auto& observer : observers_)\n    observer.DidAttachInterstitialPage();\n\n  if (frame_tree_.IsLoading())\n    LoadingStateChanged(true, true, nullptr);\n\n  if (node_.OuterContentsFrameTreeNode()) {\n    if (GetRenderManager()->GetProxyToOuterDelegate()) {\n      DCHECK(\n          static_cast<RenderWidgetHostViewBase*>(interstitial_page->GetView())\n              ->IsRenderWidgetHostViewChildFrame());\n      RenderWidgetHostViewChildFrame* view =\n          static_cast<RenderWidgetHostViewChildFrame*>(\n              interstitial_page->GetView());\n      GetRenderManager()->SetRWHViewForInnerContents(view);\n    }\n  }\n}\n",
        "line": "  DCHECK(interstitial_page);\n  GetRenderManager()->set_interstitial_page(interstitial_page);\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 185
    },
    {
        "index": 131465,
        "code": "static void longAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"longAttribute\", \"TestObjectPython\", info.Holder(), info.GetIsolate());\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);\n    imp->setLongAttribute(cppValue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 115
    },
    {
        "index": 3390,
        "code": "static apr_status_t php_apache_server_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n\tsapi_shutdown();\n#ifdef ZTS\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-3330",
        "length": 48
    },
    {
        "index": 55329,
        "code": "static void atl2_reinit_locked(struct atl2_adapter *adapter)\n{\n\tWARN_ON(in_interrupt());\n\twhile (test_and_set_bit(__ATL2_RESETTING, &adapter->flags))\n\t\tmsleep(1);\n\tatl2_down(adapter);\n\tatl2_up(adapter);\n\tclear_bit(__ATL2_RESETTING, &adapter->flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-2117",
        "length": 73
    },
    {
        "index": 108803,
        "code": "void ChildProcessSecurityPolicyImpl::RegisterPseudoScheme(\n    const std::string& scheme) {\n  base::AutoLock lock(lock_);\n  DCHECK(pseudo_schemes_.count(scheme) == 0) << \"Add schemes at most once.\";\n  DCHECK(web_safe_schemes_.count(scheme) == 0) <<\n      \"Pseudo implies not web-safe.\";\n\n  pseudo_schemes_.insert(scheme);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5138",
        "length": 88
    },
    {
        "index": 173474,
        "code": "void* message_thread(void *input)\n{\n    omx_vdec* omx = reinterpret_cast<omx_vdec*>(input);\n unsigned char id;\n int n;\n\n    DEBUG_PRINT_HIGH(\"omx_vdec: message thread start\");\n    prctl(PR_SET_NAME, (unsigned long)\"VideoDecMsgThread\", 0, 0, 0);\n while (1) {\n\n        n = read(omx->m_pipe_in, &id, 1);\n\n if (0 == n) {\n break;\n }\n\n if (1 == n) {\n            omx->process_event_cb(omx, id);\n }\n if ((n < 0) && (errno != EINTR)) {\n            DEBUG_PRINT_LOW(\"ERROR: read from pipe failed, ret %d errno %d\", n, errno);\n break;\n }\n }\n    DEBUG_PRINT_HIGH(\"omx_vdec: message thread stop\");\n return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3746",
        "length": 190
    },
    {
        "index": 176004,
        "code": "void smp_start_enc(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  tBTM_STATUS cmd;\n uint8_t reason = SMP_ENC_FAIL;\n\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (p_data != NULL)\n    cmd = btm_ble_start_encrypt(p_cb->pairing_bda, true, p_data->key.p_data);\n else\n    cmd = btm_ble_start_encrypt(p_cb->pairing_bda, false, NULL);\n\n if (cmd != BTM_CMD_STARTED && cmd != BTM_BUSY)\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-9508",
        "length": 137
    },
    {
        "index": 111787,
        "code": "void SyncBackendHost::Core::DoSetEncryptionPassphrase(\n    const std::string& passphrase,\n    bool is_explicit) {\n  DCHECK_EQ(MessageLoop::current(), sync_loop_);\n  sync_manager_->SetEncryptionPassphrase(passphrase, is_explicit);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 56
    },
    {
        "index": 25514,
        "code": "static noinline void do_sigbus(struct pt_regs *regs, long int_code,\n\t\t\t       unsigned long trans_exc_code)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long address;\n\tstruct siginfo si;\n\n\t/*\n\t * Send a sigbus, regardless of whether we were in kernel\n\t * or user mode.\n\t */\n\taddress = trans_exc_code & __FAIL_ADDR_MASK;\n\ttsk->thread.prot_addr = address;\n\ttsk->thread.trap_no = int_code;\n\tsi.si_signo = SIGBUS;\n\tsi.si_errno = 0;\n\tsi.si_code = BUS_ADRERR;\n\tsi.si_addr = (void __user *) address;\n\tforce_sig_info(SIGBUS, &si, tsk);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 153
    },
    {
        "index": 131357,
        "code": "static void documentFragmentAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectPythonV8Internal::documentFragmentAttributeAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 92
    },
    {
        "index": 39294,
        "code": "int security_read_policy(void **data, size_t *len)\n{\n\tint rc;\n\tstruct policy_file fp;\n\n\tif (!ss_initialized)\n\t\treturn -EINVAL;\n\n\t*len = security_policydb_len();\n\n\t*data = vmalloc_user(*len);\n\tif (!*data)\n\t\treturn -ENOMEM;\n\n\tfp.data = *data;\n\tfp.len = *len;\n\n\tread_lock(&policy_rwlock);\n\trc = policydb_write(&policydb, &fp);\n\tread_unlock(&policy_rwlock);\n\n\tif (rc)\n\t\treturn rc;\n\n\t*len = (unsigned long)fp.data - (unsigned long)*data;\n\treturn 0;\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-1874",
        "length": 128
    },
    {
        "index": 15323,
        "code": "static PHP_FUNCTION(xmlwriter_end_dtd_attlist)\n{\n\tphp_xmlwriter_end(INTERNAL_FUNCTION_PARAM_PASSTHRU, xmlTextWriterEndDTDAttlist);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-3412",
        "length": 36
    },
    {
        "index": 53016,
        "code": "static inline double Permutate(const ssize_t n,const ssize_t k)\n{\n  double\n    r;\n\n  register ssize_t\n    i;\n\n  r=1.0;\n  for (i=k+1; i <= n; i++)\n    r*=i;\n  for (i=1; i <= (n-k); i++)\n    r/=i;\n  return(r);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4564",
        "length": 82
    },
    {
        "index": 141919,
        "code": "views::View* PasswordPopupSuggestionView::CreateValueLabel() {\n  views::View* label = AutofillPopupSuggestionView::CreateValueLabel();\n  return new ConstrainedWidthView(label, kAutofillPopupUsernameMaxWidth);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5185",
        "length": 53
    },
    {
        "index": 72307,
        "code": "sshkey_load_private_cert(int type, const char *filename, const char *passphrase,\n    struct sshkey **keyp, int *perm_ok)\n{\n\tstruct sshkey *key = NULL, *cert = NULL;\n\tint r;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tswitch (type) {\n#ifdef WITH_OPENSSL\n\tcase KEY_RSA:\n\tcase KEY_DSA:\n\tcase KEY_ECDSA:\n#endif /* WITH_OPENSSL */\n\tcase KEY_ED25519:\n\tcase KEY_UNSPEC:\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_KEY_TYPE_UNKNOWN;\n\t}\n\n\tif ((r = sshkey_load_private_type(type, filename,\n\t    passphrase, &key, NULL, perm_ok)) != 0 ||\n\t    (r = sshkey_load_cert(filename, &cert)) != 0)\n\t\tgoto out;\n\n\t/* Make sure the private key matches the certificate */\n\tif (sshkey_equal_public(key, cert) == 0) {\n\t\tr = SSH_ERR_KEY_CERT_MISMATCH;\n\t\tgoto out;\n\t}\n\n\tif ((r = sshkey_to_certified(key)) != 0 ||\n\t    (r = sshkey_cert_copy(cert, key)) != 0)\n\t\tgoto out;\n\tr = 0;\n\tif (keyp != NULL) {\n\t\t*keyp = key;\n\t\tkey = NULL;\n\t}\n out:\n\tsshkey_free(key);\n\tsshkey_free(cert);\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-320",
        "cve": "CVE-2016-10011",
        "length": 293
    },
    {
        "index": 12156,
        "code": "int XMLRPC_GetValueStringLen(XMLRPC_VALUE value) {\n    return ((value) ? value->str.len : 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3668",
        "length": 29
    },
    {
        "index": 15471,
        "code": "check_end (const char *p)\n{\n  if (!p)\n    return false;\n  while (c_isspace (*p))\n    ++p;\n  if (!*p\n      || (p[0] == 'G' && p[1] == 'M' && p[2] == 'T')\n      || ((p[0] == '+' || p[0] == '-') && c_isdigit (p[1])))\n    return true;\n  else\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-0494",
        "length": 104
    },
    {
        "index": 22573,
        "code": "int sched_setscheduler_nocheck(struct task_struct *p, int policy,\n\t\t\t       struct sched_param *param)\n{\n\treturn __sched_setscheduler(p, policy, param, false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4621",
        "length": 38
    },
    {
        "index": 122152,
        "code": "    RenderGeometryMap& geometryMap() { return m_geometryMap; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-0881",
        "length": 16
    },
    {
        "index": 53972,
        "code": "void ndp_msgra_flag_other_set(struct ndp_msgra *msgra, bool flag_other)\n{\n\tif (flag_other)\n\t\tmsgra->ra->nd_ra_flags_reserved |= ND_RA_FLAG_OTHER;\n\telse\n\t\tmsgra->ra->nd_ra_flags_reserved &= ~ND_RA_FLAG_OTHER;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3698",
        "length": 64
    },
    {
        "index": 101811,
        "code": "void Browser::ShowAppMenu() {\n  window_->ShowAppMenu();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3896",
        "length": 17
    },
    {
        "index": 152545,
        "code": "bool RenderFrameImpl::SwapIn() {\n  CHECK_NE(previous_routing_id_, MSG_ROUTING_NONE);\n  CHECK(!in_frame_tree_);\n\n  RenderFrameProxy* proxy =\n      RenderFrameProxy::FromRoutingID(previous_routing_id_);\n  CHECK(proxy);\n\n  unique_name_helper_.set_propagated_name(proxy->unique_name());\n\n  if (!proxy->web_frame()->Swap(frame_)) {\n    DCHECK(!is_main_frame_);\n    return false;\n  }\n\n  previous_routing_id_ = MSG_ROUTING_NONE;\n  in_frame_tree_ = true;\n\n  if (is_main_frame_) {\n    CHECK(!render_view_->main_render_frame_);\n    render_view_->main_render_frame_ = this;\n    if (render_view_->GetWidget()->is_frozen()) {\n      render_view_->GetWidget()->SetIsFrozen(false);\n    }\n    render_view_->GetWidget()->UpdateWebViewWithDeviceScaleFactor();\n\n    render_view_->webview()->DidAttachLocalMainFrame(render_view_->GetWidget());\n  }\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5019",
        "length": 207
    },
    {
        "index": 29923,
        "code": "static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\n\t/* Don't allow gaining capabilities by reentering\n\t * the same user namespace.\n\t */\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\n\t/* Threaded processes may not enter a different user namespace */\n\tif (atomic_read(&current->mm->mm_users) > 1)\n\t\treturn -EINVAL;\n\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\n\treturn commit_creds(cred);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4205",
        "length": 181
    },
    {
        "index": 79670,
        "code": "R_API RBinJavaAnnotationsArray *r_bin_java_annotation_array_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaAnnotation *annotation;\n\tRBinJavaAnnotationsArray *annotation_array;\n\tut32 i;\n\tut64 offset = 0;\n\tannotation_array = (RBinJavaAnnotationsArray *) malloc (sizeof (RBinJavaAnnotationsArray));\n\tif (annotation_array == NULL) {\n\t\treturn NULL;\n\t}\n\tannotation_array->num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation_array->annotations = r_list_new ();\n\tfor (i = 0; i < annotation_array->num_annotations; i++) {\n\t\tannotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (annotation) {\n\t\t\toffset += annotation->size;\n\t\t}\n\t\tif (annotation == NULL) {\n\t\t}\n\t\tr_list_append (annotation_array->annotations, (void *) annotation);\n\t}\n\tannotation_array->size = offset;\n\treturn annotation_array;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-14017",
        "length": 226
    },
    {
        "index": 153658,
        "code": "uint32_t GenerateNextFlushId() {\n  return static_cast<uint32_t>(g_flush_id.GetNext());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 25
    },
    {
        "index": 181107,
        "code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n {\n     const char *s;\n \n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n \t(*pptr)++;\n \t(*len)--;\n     }\n     (*pptr)++;\n     (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     return s;\n }\n",
        "line": "    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n",
        "label": 1,
        "cwe": "CWE-125",
        "cve": "CVE-2017-12902",
        "length": 158
    },
    {
        "index": 57763,
        "code": "void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-7513",
        "length": 88
    },
    {
        "index": 31591,
        "code": "sctp_disposition_t sctp_sf_do_9_1_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2206",
        "length": 322
    },
    {
        "index": 99608,
        "code": "void InterstitialPage::SetSize(const gfx::Size& size) {\n#if defined(OS_WIN) || defined(OS_LINUX)\n  if (render_view_host_->view())\n    render_view_host_->view()->SetSize(size);\n#else\n  NOTIMPLEMENTED();\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 56
    },
    {
        "index": 50675,
        "code": "static struct se_portal_group *srpt_make_tpg(struct se_wwn *wwn,\n\t\t\t\t\t     struct config_group *group,\n\t\t\t\t\t     const char *name)\n{\n\tstruct srpt_port *sport = container_of(wwn, struct srpt_port, port_wwn);\n\tint res;\n\n\t/* Initialize sport->port_wwn and sport->port_tpg_1 */\n\tres = core_tpg_register(&sport->port_wwn, &sport->port_tpg_1, SCSI_PROTOCOL_SRP);\n\tif (res)\n\t\treturn ERR_PTR(res);\n\n\treturn &sport->port_tpg_1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-6327",
        "length": 128
    },
    {
        "index": 89633,
        "code": "static void _devm_mdiobus_free(struct device *dev, void *res)\n{\n\tmdiobus_free(*(struct mii_bus **)res);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-12819",
        "length": 33
    },
    {
        "index": 41321,
        "code": "static void do_cpuid_1_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t   u32 index)\n{\n\tentry->function = function;\n\tentry->index = index;\n\tcpuid_count(entry->function, entry->index,\n\t\t    &entry->eax, &entry->ebx, &entry->ecx, &entry->edx);\n\tentry->flags = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2010-5313",
        "length": 80
    },
    {
        "index": 170200,
        "code": "void WebContentsLoadedOrDestroyedWatcher::DidStopLoading() {\n  message_loop_runner_->Quit();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1691",
        "length": 22
    },
    {
        "index": 65133,
        "code": "static MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps,\n  const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,\n  ExceptionInfo *exception)\n{\n  Image*\n    resize_image;\n\n  register ssize_t\n    i;\n\n  size_t\n    columns,\n    rows;\n\n  columns = image->columns;\n  rows = image->rows;\n\n  for (i=0; i< (ssize_t) mipmaps; i++)\n  {\n    resize_image = ResizeImage(image,DIV2(columns),DIV2(rows),TriangleFilter,1.0,\n      exception);\n\n    if (resize_image == (Image *) NULL)\n      return(MagickFalse);\n\n    DestroyBlob(resize_image);\n    resize_image->blob=ReferenceBlob(image->blob);\n\n    WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,\n      clusterFit,exception);\n\n    resize_image=DestroyImage(resize_image);\n\n    columns = DIV2(columns);\n    rows = DIV2(rows);\n  }\n\n  return(MagickTrue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-9141",
        "length": 232
    },
    {
        "index": 118967,
        "code": "void WebContentsImpl::Observe(int type,\n                              const NotificationSource& source,\n                              const NotificationDetails& details) {\n  switch (type) {\n    case NOTIFICATION_RENDER_WIDGET_HOST_DESTROYED: {\n      RenderWidgetHost* host = Source<RenderWidgetHost>(source).ptr();\n      for (PendingWidgetViews::iterator i = pending_widget_views_.begin();\n           i != pending_widget_views_.end(); ++i) {\n        if (host->GetView() == i->second) {\n          pending_widget_views_.erase(i);\n          break;\n        }\n      }\n      break;\n    }\n    default:\n      NOTREACHED();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6626",
        "length": 134
    },
    {
        "index": 90221,
        "code": "static void handle_flags(struct smi_info *smi_info)\n{\nretry:\n\tif (smi_info->msg_flags & WDT_PRE_TIMEOUT_INT) {\n\t\t/* Watchdog pre-timeout */\n\t\tsmi_inc_stat(smi_info, watchdog_pretimeouts);\n\n\t\tstart_clear_flags(smi_info);\n\t\tsmi_info->msg_flags &= ~WDT_PRE_TIMEOUT_INT;\n\t\tipmi_smi_watchdog_pretimeout(smi_info->intf);\n\t} else if (smi_info->msg_flags & RECEIVE_MSG_AVAIL) {\n\t\t/* Messages available. */\n\t\tsmi_info->curr_msg = alloc_msg_handle_irq(smi_info);\n\t\tif (!smi_info->curr_msg)\n\t\t\treturn;\n\n\t\tstart_getting_msg_queue(smi_info);\n\t} else if (smi_info->msg_flags & EVENT_MSG_BUFFER_FULL) {\n\t\t/* Events available. */\n\t\tsmi_info->curr_msg = alloc_msg_handle_irq(smi_info);\n\t\tif (!smi_info->curr_msg)\n\t\t\treturn;\n\n\t\tstart_getting_events(smi_info);\n\t} else if (smi_info->msg_flags & OEM_DATA_AVAIL &&\n\t\t   smi_info->oem_data_avail_handler) {\n\t\tif (smi_info->oem_data_avail_handler(smi_info))\n\t\t\tgoto retry;\n\t} else\n\t\tsmi_info->si_state = SI_NORMAL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11811",
        "length": 287
    },
    {
        "index": 163935,
        "code": "InlineTextBox* SearchAheadForBetterMatch(LayoutObject* layout_object) {\n  LayoutBlock* container = layout_object->ContainingBlock();\n  for (LayoutObject* next = layout_object->NextInPreOrder(container); next;\n       next = next->NextInPreOrder(container)) {\n    if (next->IsLayoutBlock())\n      return nullptr;\n    if (next->IsBR())\n      return nullptr;\n    if (IsNonTextLeafChild(next))\n      return nullptr;\n    if (next->IsText()) {\n      InlineTextBox* match = nullptr;\n      int min_offset = INT_MAX;\n      for (InlineTextBox* box : InlineTextBoxesOf(*ToLayoutText(next))) {\n        int caret_min_offset = box->CaretMinOffset();\n        if (caret_min_offset < min_offset) {\n          match = box;\n          min_offset = caret_min_offset;\n        }\n      }\n      if (match)\n        return match;\n    }\n  }\n  return nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 201
    },
    {
        "index": 47630,
        "code": "static void ap_reset_all(void)\n{\n\tint i, j;\n\n\tfor (i = 0; i < AP_DOMAINS; i++) {\n\t\tif (!ap_test_config_domain(i))\n\t\t\tcontinue;\n\t\tfor (j = 0; j < AP_DEVICES; j++) {\n\t\t\tif (!ap_test_config_card_id(j))\n\t\t\t\tcontinue;\n\t\t\tap_reset_queue(AP_MKQID(j, i));\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 90
    },
    {
        "index": 17665,
        "code": "SProcXFixesHideCursor(ClientPtr client)\n{\n    REQUEST(xXFixesHideCursorReq);\n\n    swaps(&stuff->length);\n    REQUEST_SIZE_MATCH(xXFixesHideCursorReq);\n    swapl(&stuff->window);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-12183",
        "length": 71
    },
    {
        "index": 182947,
        "code": "setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  /* save one level of indirection */\n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n       else\n         poolDiscard(&dtd->pool);\n       elementType->prefix = prefix;\n     }\n   }\n   return 1;\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-611",
        "cve": "CVE-2018-20843",
        "length": 238
    },
    {
        "index": 26155,
        "code": "static inline void perf_put_cgroup(struct perf_event *event)\n{\n\tcss_put(&event->cgrp->css);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 27
    },
    {
        "index": 138592,
        "code": "void NavigatorImpl::DidFailLoadWithError(\n    RenderFrameHostImpl* render_frame_host,\n    const GURL& url,\n    int error_code,\n    const base::string16& error_description,\n    bool was_ignored_by_handler) {\n  if (delegate_) {\n    delegate_->DidFailLoadWithError(\n        render_frame_host, url, error_code,\n        error_description, was_ignored_by_handler);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1278",
        "length": 87
    },
    {
        "index": 47422,
        "code": "static void __exit zlib_mod_fini(void)\n{\n\tcrypto_unregister_pcomp(&zlib_alg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 23
    },
    {
        "index": 86160,
        "code": "static void amd_gpio_irq_disable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-18174",
        "length": 134
    },
    {
        "index": 91178,
        "code": "get_bytes (uint8_t * rpt, size_t len, size_t num_bytes, size_t cur)\n{\n  /* Return if there aren't enough bytes. */\n  if (cur + num_bytes >= len)\n    return 0;\n\n  if (num_bytes == 0)\n    return 0;\n  else if (num_bytes == 1)\n    {\n      return rpt[cur + 1];\n    }\n  else if (num_bytes == 2)\n    {\n      return (rpt[cur + 2] * 256 + rpt[cur + 1]);\n    }\n  else\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-9578",
        "length": 129
    },
    {
        "index": 86728,
        "code": "static void blk_mq_queue_exit(struct request_queue *q)\n{\n\tpercpu_ref_put(&q->mq_usage_counter);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-9016",
        "length": 28
    },
    {
        "index": 117336,
        "code": "xmlXPtrRangeCheckOrder(xmlXPathObjectPtr range) {\n    int tmp;\n    xmlNodePtr tmp2;\n    if (range == NULL)\n\treturn;\n    if (range->type != XPATH_RANGE)\n\treturn;\n    if (range->user2 == NULL)\n\treturn;\n    tmp = xmlXPtrCmpPoints(range->user, range->index,\n\t                     range->user2, range->index2);\n    if (tmp == -1) {\n\ttmp2 = range->user;\n\trange->user = range->user2;\n\trange->user2 = tmp2;\n\ttmp = range->index;\n\trange->index = range->index2;\n\trange->index2 = tmp;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-3102",
        "length": 146
    },
    {
        "index": 135576,
        "code": "void Editor::PasteAsPlainText(EditorCommandSource source) {\n  if (TryDHTMLPaste(kPlainTextOnly))\n    return;\n  if (!CanPaste())\n    return;\n\n  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();\n\n  if (source == kCommandFromMenuOrKeyBinding &&\n      !GetFrame().Selection().SelectionHasFocus())\n    return;\n\n  GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(false);\n  PasteAsPlainTextWithPasteboard(Pasteboard::GeneralPasteboard());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-6773",
        "length": 109
    },
    {
        "index": 139816,
        "code": "const aura::Window* Shell::GetContainer(const aura::Window* root_window,\n                                        int container_id) {\n  return root_window->GetChildById(container_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 36
    },
    {
        "index": 141380,
        "code": "void Document::writeln(v8::Isolate* isolate,\n                       TrustedHTML* text,\n                       ExceptionState& exception_state) {\n  DCHECK(origin_trials::TrustedDOMTypesEnabled(this));\n  writeln(text->toString(), EnteredDOMWindow(isolate)->document(),\n          exception_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 57
    },
    {
        "index": 52462,
        "code": "static const char *ssl_authz_verify_client_parse(cmd_parms *cmd,\n                                                 const char *require_line,\n                                                 const void **parsed)\n{\n    if (require_line && require_line[0])\n        return \"'Require ssl-verify-client' does not take arguments\";\n\n    return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-4979",
        "length": 60
    },
    {
        "index": 143933,
        "code": "png_get_header_version(png_structp png_ptr)\n{\n   /* Returns longer string containing both version and date */\n   PNG_UNUSED(png_ptr) /* Silence compiler warning about unused png_ptr */\n#ifdef __STDC__\n   return ((png_charp) PNG_HEADER_VERSION_STRING\n#ifndef PNG_READ_SUPPORTED\n   \"     (NO READ SUPPORT)\"\n#endif\n   PNG_STRING_NEWLINE);\n#else\n   return ((png_charp) PNG_HEADER_VERSION_STRING);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8126",
        "length": 93
    },
    {
        "index": 15709,
        "code": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n{\n    uint16_t *v = pv;\n    uint16_t v2;\n    qemu_get_be16s(f, &v2);\n\n    if (*v == v2) {\n        return 0;\n    }\n    return -EINVAL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4531",
        "length": 72
    },
    {
        "index": 89435,
        "code": "static int nfc_genl_dev_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12984",
        "length": 105
    },
    {
        "index": 29107,
        "code": "static bool memslot_is_readonly(struct kvm_memory_slot *slot)\n{\n\treturn slot->flags & KVM_MEM_READONLY;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4592",
        "length": 27
    },
    {
        "index": 41715,
        "code": "static int maybe_insert_hole(struct btrfs_root *root, struct inode *inode,\n\t\t\t     u64 offset, u64 len)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\n\t/*\n\t * Still need to make sure the inode looks like it's been updated so\n\t * that any holes get logged if we fsync.\n\t */\n\tif (btrfs_fs_incompat(root->fs_info, NO_HOLES)) {\n\t\tBTRFS_I(inode)->last_trans = root->fs_info->generation;\n\t\tBTRFS_I(inode)->last_sub_trans = root->log_transid;\n\t\tBTRFS_I(inode)->last_log_commit = root->last_log_commit;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * 1 - for the one we're dropping\n\t * 1 - for the one we're adding\n\t * 1 - for updating the inode.\n\t */\n\ttrans = btrfs_start_transaction(root, 3);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = btrfs_drop_extents(trans, root, inode, offset, offset + len, 1);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_insert_file_extent(trans, root, btrfs_ino(inode), offset,\n\t\t\t\t       0, 0, len, 0, len, 0, 0, 0);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\telse\n\t\tbtrfs_update_inode(trans, root, inode);\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-8374",
        "length": 345
    },
    {
        "index": 90961,
        "code": "\t\tvoid CWebServer::ClearUserPasswords()\n\t\t{\n\t\t\tm_users.clear();\n\t\t\tm_pWebEm->ClearUserPasswords();\n\t\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-89",
        "cve": "CVE-2019-10664",
        "length": 32
    },
    {
        "index": 85214,
        "code": "list_update_cgroup_event(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx, bool add)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct list_head *cpuctx_entry;\n\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tif (add && ctx->nr_cgroups++)\n\t\treturn;\n\telse if (!add && --ctx->nr_cgroups)\n\t\treturn;\n\t/*\n\t * Because cgroup events are always per-cpu events,\n\t * this will always be called from the right CPU.\n\t */\n\tcpuctx = __get_cpu_context(ctx);\n\tcpuctx_entry = &cpuctx->cgrp_cpuctx_entry;\n\t/* cpuctx->cgrp is NULL unless a cgroup event is active in this CPU .*/\n\tif (add) {\n\t\tlist_add(cpuctx_entry, this_cpu_ptr(&cgrp_cpuctx_list));\n\t\tif (perf_cgroup_from_task(current, ctx) == event->cgrp)\n\t\t\tcpuctx->cgrp = event->cgrp;\n\t} else {\n\t\tlist_del(cpuctx_entry);\n\t\tcpuctx->cgrp = NULL;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-18255",
        "length": 239
    },
    {
        "index": 63038,
        "code": "static void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)\n{\n       struct vcpu_vmx *vmx = to_vmx(vcpu);\n       int r;\n\n       r = vcpu_load(vcpu);\n       BUG_ON(r);\n       vmx_switch_vmcs(vcpu, &vmx->vmcs01);\n       free_nested(vmx);\n       vcpu_put(vcpu);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-12154",
        "length": 83
    },
    {
        "index": 13127,
        "code": "static void init_packet(struct dhcp_packet *packet, struct dhcp_packet *oldpacket, char type)\n{\n\t/* Sets op, htype, hlen, cookie fields\n\t * and adds DHCP_MESSAGE_TYPE option */\n\tudhcp_init_header(packet, type);\n\n\tpacket->xid = oldpacket->xid;\n\tmemcpy(packet->chaddr, oldpacket->chaddr, sizeof(oldpacket->chaddr));\n\tpacket->flags = oldpacket->flags;\n\tpacket->gateway_nip = oldpacket->gateway_nip;\n\tpacket->ciaddr = oldpacket->ciaddr;\n\tudhcp_add_simple_option(packet, DHCP_SERVER_ID, server_config.server_nip);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-20679",
        "length": 136
    },
    {
        "index": 71600,
        "code": "ModuleExport size_t RegisterMIFFImage(void)\n{\n  char\n    version[MaxTextExtent];\n\n  MagickInfo\n    *entry;\n\n  *version='\\0';\n#if defined(MagickImageCoderSignatureText)\n  (void) CopyMagickString(version,MagickLibVersionText,MaxTextExtent);\n#if defined(ZLIB_VERSION)\n  (void) ConcatenateMagickString(version,\" with Zlib \",MaxTextExtent);\n  (void) ConcatenateMagickString(version,ZLIB_VERSION,MaxTextExtent);\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n  (void) ConcatenateMagickString(version,\" and BZlib\",MaxTextExtent);\n#endif\n#endif\n  entry=SetMagickInfo(\"MIFF\");\n  entry->decoder=(DecodeImageHandler *) ReadMIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteMIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsMIFF;\n  entry->seekable_stream=MagickTrue;\n  entry->description=ConstantString(\"Magick Image File Format\");\n  if (*version != '\\0')\n    entry->version=ConstantString(version);\n  entry->module=ConstantString(\"MIFF\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10066",
        "length": 275
    },
    {
        "index": 186184,
        "code": "void LocalSiteCharacteristicsWebContentsObserver::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\n  DCHECK(navigation_handle);\n\n  if (!navigation_handle->IsInMainFrame() ||\n      navigation_handle->IsSameDocument()) {\n    return;\n  }\n\n  first_time_title_set_ = false;\n  first_time_favicon_set_ = false;\n\n  if (!navigation_handle->HasCommitted())\n    return;\n\n  const url::Origin new_origin =\n      url::Origin::Create(navigation_handle->GetURL());\n\n  if (writer_ && new_origin == writer_origin_)\n    return;\n\n   writer_.reset();\n   writer_origin_ = url::Origin();\n \n  if (!navigation_handle->GetURL().SchemeIsHTTPOrHTTPS())\n     return;\n \n   Profile* profile =\n      Profile::FromBrowserContext(web_contents()->GetBrowserContext());\n  DCHECK(profile);\n  SiteCharacteristicsDataStore* data_store =\n      LocalSiteCharacteristicsDataStoreFactory::GetForProfile(profile);\n  DCHECK(data_store);\n  writer_ = data_store->GetWriterForOrigin(\n      new_origin,\n      ContentVisibilityToRCVisibility(web_contents()->GetVisibility()));\n\n  if (TabLoadTracker::Get()->GetLoadingState(web_contents()) ==\n      LoadingState::LOADED) {\n    writer_->NotifySiteLoaded();\n  }\n\n  writer_origin_ = new_origin;\n}\n",
        "line": "  if (!navigation_handle->GetURL().SchemeIsHTTPOrHTTPS())\n",
        "label": 1,
        "cwe": null,
        "cve": "CVE-2016-1613",
        "length": 290
    },
    {
        "index": 176811,
        "code": "void MediaPlayerService::removeClient(wp<Client> client)\n{\n Mutex::Autolock lock(mLock);\n    mClients.remove(client);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3861",
        "length": 29
    },
    {
        "index": 138526,
        "code": "bool WorkerThread::terminated()\n{\n    MutexLocker lock(m_threadStateMutex);\n    return m_terminated;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1281",
        "length": 24
    },
    {
        "index": 173009,
        "code": "buffer_read(struct display *dp, struct buffer *bp, png_bytep data,\n png_size_t size)\n{\n struct buffer_list *last = bp->current;\n size_t read_count = bp->read_count;\n\n while (size > 0)\n {\n size_t avail;\n\n if (last == NULL ||\n (last == bp->last && read_count >= bp->end_count))\n {\n         display_log(dp, USER_ERROR, \"file truncated (%lu bytes)\",\n (unsigned long)size);\n /*NOTREACHED*/\n break;\n }\n\n else if (read_count >= sizeof last->buffer)\n {\n /* Move to the next buffer: */\n         last = last->next;\n         read_count = 0;\n         bp->current = last; /* Avoid update outside the loop */\n\n /* And do a sanity check (the EOF case is caught above) */\n if (last == NULL)\n {\n            display_log(dp, INTERNAL_ERROR, \"damaged buffer list\");\n /*NOTREACHED*/\n break;\n }\n }\n\n      avail = (sizeof last->buffer) - read_count;\n if (avail > size)\n         avail = size;\n\n      memcpy(data, last->buffer + read_count, avail);\n      read_count += avail;\n      size -= avail;\n      data += avail;\n }\n\n   bp->read_count = read_count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 263
    },
    {
        "index": 48939,
        "code": "static bool sd_has_rps_ipi_waiting(struct softnet_data *sd)\n{\n#ifdef CONFIG_RPS\n\treturn sd->rps_ipi_list != NULL;\n#else\n\treturn false;\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2016-8666",
        "length": 42
    },
    {
        "index": 75660,
        "code": "static void usb_audio_make_longname(struct usb_device *dev,\n\t\t\t\t    struct snd_usb_audio *chip,\n\t\t\t\t    const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\tint len;\n\n\t/* shortcut - if any pre-defined string is given, use it */\n\tif (quirk && quirk->profile_name && *quirk->profile_name) {\n\t\tstrlcpy(card->longname, quirk->profile_name,\n\t\t\tsizeof(card->longname));\n\t\treturn;\n\t}\n\n\tif (quirk && quirk->vendor_name && *quirk->vendor_name) {\n\t\tlen = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));\n\t} else {\n\t\t/* retrieve the vendor and device strings as longname */\n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tlen = usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t\t card->longname, sizeof(card->longname));\n\t\telse\n\t\t\tlen = 0;\n\t\t/* we don't really care if there isn't any vendor string */\n\t}\n\tif (len > 0) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-19824",
        "length": 497
    },
    {
        "index": 39099,
        "code": "bittoint8(PG_FUNCTION_ARGS)\n{\n\tVarBit\t   *arg = PG_GETARG_VARBIT_P(0);\n\tuint64\t\tresult;\n\tbits8\t   *r;\n\n\t/* Check that the bit string is not too long */\n\tif (VARBITLEN(arg) > sizeof(result) * BITS_PER_BYTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"bigint out of range\")));\n\n\tresult = 0;\n\tfor (r = VARBITS(arg); r < VARBITEND(arg); r++)\n\t{\n\t\tresult <<= BITS_PER_BYTE;\n\t\tresult |= *r;\n\t}\n\t/* Now shift the result to take account of the padding at the end */\n\tresult >>= VARBITPAD(arg);\n\n\tPG_RETURN_INT64(result);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 164
    },
    {
        "index": 53905,
        "code": "void ndp_close(struct ndp *ndp)\n{\n\tndp_sock_close(ndp);\n\tfree(ndp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3698",
        "length": 26
    },
    {
        "index": 6178,
        "code": "int tls1_set_curves(unsigned char **pext, size_t *pextlen,\n                    int *curves, size_t ncurves)\n{\n    unsigned char *clist, *p;\n    size_t i;\n    /*\n     * Bitmap of curves included to detect duplicates: only works while curve\n     * ids < 32\n     */\n    unsigned long dup_list = 0;\n# ifdef OPENSSL_NO_EC2M\n    EC_GROUP *curve;\n# endif\n\n    clist = OPENSSL_malloc(ncurves * 2);\n    if (!clist)\n        return 0;\n    for (i = 0, p = clist; i < ncurves; i++) {\n        unsigned long idmask;\n        int id;\n        id = tls1_ec_nid2curve_id(curves[i]);\n# ifdef OPENSSL_FIPS\n        /* NB: 25 is last curve ID supported by FIPS module */\n        if (FIPS_mode() && id > 25) {\n            OPENSSL_free(clist);\n            return 0;\n        }\n# endif\n# ifdef OPENSSL_NO_EC2M\n        curve = EC_GROUP_new_by_curve_name(curves[i]);\n        if (!curve || EC_METHOD_get_field_type(EC_GROUP_method_of(curve))\n            == NID_X9_62_characteristic_two_field) {\n            if (curve)\n                EC_GROUP_free(curve);\n            OPENSSL_free(clist);\n            return 0;\n        } else\n            EC_GROUP_free(curve);\n# endif\n        idmask = 1L << id;\n        if (!id || (dup_list & idmask)) {\n            OPENSSL_free(clist);\n            return 0;\n        }\n        dup_list |= idmask;\n        s2n(id, p);\n    }\n    if (*pext)\n        OPENSSL_free(*pext);\n    *pext = clist;\n    *pextlen = ncurves * 2;\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-0291",
        "length": 411
    },
    {
        "index": 81343,
        "code": "static int __init set_cmdline_ftrace(char *str)\n{\n\tstrlcpy(bootup_tracer_buf, str, MAX_TRACER_SIZE);\n\tdefault_bootup_tracer = bootup_tracer_buf;\n\t/* We are using ftrace early, expand it */\n\tring_buffer_expanded = true;\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 70
    },
    {
        "index": 160781,
        "code": "gfx::RectF RenderViewImpl::ElementBoundsInWindow(\n    const blink::WebElement& element) {\n  blink::WebRect bounding_box_in_window = element.BoundsInViewport();\n  ConvertViewportToWindowViaWidget(&bounding_box_in_window);\n  return gfx::RectF(bounding_box_in_window);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 64
    },
    {
        "index": 111303,
        "code": "BlackBerry::Platform::String WebPage::renderTreeAsText()\n{\n    return externalRepresentation(d->m_mainFrame);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 27
    },
    {
        "index": 134762,
        "code": "bool GuestViewBase::ZoomPropagatesFromEmbedderToGuest() const {\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 23
    },
    {
        "index": 67747,
        "code": "void r_pkcs7_free_digestalgorithmidentifier (RPKCS7DigestAlgorithmIdentifiers *dai) {\n\tut32 i;\n\tif (dai) {\n\t\tfor (i = 0; i < dai->length; ++i) {\n\t\t\tif (dai->elements[i]) {\n\t\t\t\tr_x509_free_algorithmidentifier (dai->elements[i]);\n\t\t\t\tR_FREE (dai->elements[i]);\n\t\t\t}\n\t\t}\n\t\tR_FREE (dai->elements);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-7274",
        "length": 105
    },
    {
        "index": 150091,
        "code": "  void CreateResource() {\n    ui_resources_[num_ui_resources_++] =\n        FakeScopedUIResource::Create(layer_tree_host()->GetUIResourceManager());\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-5061",
        "length": 34
    },
    {
        "index": 4386,
        "code": "PHP_METHOD(Phar, getSignature)\n{\n\tPHAR_ARCHIVE_OBJECT();\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->signature) {\n\t\tchar *unknown;\n\t\tint unknown_len;\n\n\t\tarray_init(return_value);\n\t\tadd_assoc_stringl(return_value, \"hash\", phar_obj->arc.archive->signature, phar_obj->arc.archive->sig_len, 1);\n\t\tswitch(phar_obj->arc.archive->sig_flags) {\n\t\t\tcase PHAR_SIG_MD5:\n\t\t\t\tadd_assoc_stringl(return_value, \"hash_type\", \"MD5\", 3, 1);\n\t\t\t\tbreak;\n\t\t\tcase PHAR_SIG_SHA1:\n\t\t\t\tadd_assoc_stringl(return_value, \"hash_type\", \"SHA-1\", 5, 1);\n\t\t\t\tbreak;\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tadd_assoc_stringl(return_value, \"hash_type\", \"SHA-256\", 7, 1);\n\t\t\t\tbreak;\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\t\tadd_assoc_stringl(return_value, \"hash_type\", \"SHA-512\", 7, 1);\n\t\t\t\tbreak;\n\t\t\tcase PHAR_SIG_OPENSSL:\n\t\t\t\tadd_assoc_stringl(return_value, \"hash_type\", \"OpenSSL\", 7, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunknown_len = spprintf(&unknown, 0, \"Unknown (%u)\", phar_obj->arc.archive->sig_flags);\n\t\t\t\tadd_assoc_stringl(return_value, \"hash_type\", unknown, unknown_len, 0);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-2301",
        "length": 345
    },
    {
        "index": 177177,
        "code": "uint32_t SoftVideoDecoderOMXComponent::outputBufferHeight() {\n return mIsAdaptive ? mAdaptiveMaxHeight : mHeight;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 32
    },
    {
        "index": 132921,
        "code": "void RenderWidgetHostViewAura::CopyFromCompositingSurface(\n    const gfx::Rect& src_subrect,\n    const gfx::Size& dst_size,\n    const base::Callback<void(bool, const SkBitmap&)>& callback,\n    bool readback_config_rgb565) {\n  if (!CanCopyToBitmap()) {\n    callback.Run(false, SkBitmap());\n    return;\n  }\n\n  const gfx::Size& dst_size_in_pixel = ConvertViewSizeToPixel(this, dst_size);\n  scoped_ptr<cc::CopyOutputRequest> request =\n      cc::CopyOutputRequest::CreateRequest(base::Bind(\n          &RenderWidgetHostViewAura::CopyFromCompositingSurfaceHasResult,\n          dst_size_in_pixel,\n          readback_config_rgb565,\n          callback));\n  gfx::Rect src_subrect_in_pixel =\n      ConvertRectToPixel(current_device_scale_factor_, src_subrect);\n  request->set_area(src_subrect_in_pixel);\n  RequestCopyOfOutput(request.Pass());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 203
    },
    {
        "index": 160381,
        "code": "void BaseArena::makeConsistentForGC() {\n  clearFreeLists();\n  ASSERT(isConsistentForGC());\n  for (BasePage* page = m_firstPage; page; page = page->next()) {\n    page->markAsUnswept();\n    page->invalidateObjectStartBitmap();\n  }\n\n  CHECK(!m_firstUnsweptPage);\n\n  HeapCompact* heapCompactor = getThreadState()->heap().compaction();\n  if (!heapCompactor->isCompactingArena(arenaIndex()))\n    return;\n\n  BasePage* nextPage = m_firstPage;\n  while (nextPage) {\n    if (!nextPage->isLargeObjectPage())\n      heapCompactor->addCompactingPage(nextPage);\n    nextPage = nextPage->next();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-6094",
        "length": 162
    },
    {
        "index": 116171,
        "code": "ResourceDispatcherHostImpl::~ResourceDispatcherHostImpl() {\n  DCHECK(g_resource_dispatcher_host);\n  g_resource_dispatcher_host = NULL;\n  AsyncResourceHandler::GlobalCleanup();\n  for (PendingRequestList::const_iterator i = pending_requests_.begin();\n       i != pending_requests_.end(); ++i) {\n    transferred_navigations_.erase(i->first);\n  }\n  STLDeleteValues(&pending_requests_);\n  DCHECK(transferred_navigations_.empty());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3106",
        "length": 95
    },
    {
        "index": 88033,
        "code": "static int ctrl_fill_mcgrp_info(const struct genl_family *family,\n\t\t\t\tconst struct genl_multicast_group *grp,\n\t\t\t\tint grp_id, u32 portid, u32 seq, u32 flags,\n\t\t\t\tstruct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nla_grps;\n\tstruct nlattr *nest;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id))\n\t\tgoto nla_put_failure;\n\n\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\tif (nla_grps == NULL)\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, 1);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID, grp_id) ||\n\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t   grp->name))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\tnla_nest_end(skb, nla_grps);\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2019-15921",
        "length": 311
    },
    {
        "index": 89089,
        "code": "static int get_seg_base_limit(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int regoff, unsigned long *base,\n\t\t\t      unsigned long *limit)\n{\n\tint seg_reg_idx;\n\n\tif (!base)\n\t\treturn -EINVAL;\n\n\tseg_reg_idx = resolve_seg_reg(insn, regs, regoff);\n\tif (seg_reg_idx < 0)\n\t\treturn seg_reg_idx;\n\n\t*base = insn_get_seg_base(regs, seg_reg_idx);\n\tif (*base == -1L)\n\t\treturn -EINVAL;\n\n\tif (!limit)\n\t\treturn 0;\n\n\t*limit = get_seg_limit(regs, seg_reg_idx);\n\tif (!(*limit))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2019-13233",
        "length": 146
    },
    {
        "index": 27175,
        "code": "static void thread_check_init(void)\n{\n  g_main_thread = pthread_self();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2486",
        "length": 18
    },
    {
        "index": 44161,
        "code": " static size_t __iovec_copy_from_user_inatomic(char *vaddr,\n \t\t\tconst struct iovec *iov, size_t base, size_t bytes)\n {\n\tsize_t copied = 0, left = 0;\n\n\twhile (bytes) {\n\t\tchar __user *buf = iov->iov_base + base;\n\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\tbase = 0;\n\t\tleft = __copy_from_user_inatomic(vaddr, buf, copy);\n\t\tcopied += copy;\n\t\tbytes -= copy;\n\t\tvaddr += copy;\n\t\tiov++;\n\n\t\tif (unlikely(left))\n\t\t\tbreak;\n\t}\n\treturn copied - left;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2015-1805",
        "length": 141
    },
    {
        "index": 1110,
        "code": "GfxState *GfxState::restore() {\n  GfxState *oldState;\n\n  if (saved) {\n    oldState = saved;\n\n    oldState->path = path;\n    oldState->curX = curX;\n    oldState->curY = curY;\n    oldState->lineX = lineX;\n    oldState->lineY = lineY;\n\n    path = NULL;\n    saved = NULL;\n    delete this;\n\n  } else {\n    oldState = this;\n  }\n\n  return oldState;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 112
    },
    {
        "index": 83399,
        "code": "FreeStartupData(STARTUP_DATA *sud)\n{\n    free(sud->directory);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-9336",
        "length": 21
    },
    {
        "index": 152852,
        "code": "MetricsWebContentsObserver::TestingObserver::TestingObserver(\n    content::WebContents* web_contents)\n    : observer_(page_load_metrics::MetricsWebContentsObserver::FromWebContents(\n          web_contents)) {\n  observer_->AddTestingObserver(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2016-5204",
        "length": 52
    },
    {
        "index": 167276,
        "code": "void FetchManager::Trace(blink::Visitor* visitor) {\n  visitor->Trace(loaders_);\n  ContextLifecycleObserver::Trace(visitor);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-4117",
        "length": 30
    },
    {
        "index": 104079,
        "code": "bool GLES2DecoderImpl::GenRenderbuffersHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    if (GetRenderbufferInfo(client_ids[ii])) {\n      return false;\n    }\n  }\n  scoped_array<GLuint> service_ids(new GLuint[n]);\n  glGenRenderbuffersEXT(n, service_ids.get());\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    CreateRenderbufferInfo(client_ids[ii], service_ids[ii]);\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2858",
        "length": 122
    },
    {
        "index": 120983,
        "code": "  void DoRestartWithAuth(SocketStreamEvent* event) {\n    VLOG(1) << \"RestartWithAuth username=\" << credentials_.username()\n            << \" password=\" << credentials_.password();\n    event->socket->RestartWithAuth(credentials_);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2870",
        "length": 54
    },
    {
        "index": 137933,
        "code": "static inline LayoutObject* endOfContinuations(LayoutObject* layoutObject) {\n  LayoutObject* prev = layoutObject;\n  LayoutObject* cur = layoutObject;\n\n  if (!cur->isLayoutInline() && !cur->isLayoutBlockFlow())\n    return layoutObject;\n\n  while (cur) {\n    prev = cur;\n    if (cur->isLayoutInline()) {\n      cur = toLayoutInline(cur)->inlineElementContinuation();\n      ASSERT(cur || !toLayoutInline(prev)->continuation());\n    } else {\n      cur = toLayoutBlockFlow(cur)->inlineElementContinuation();\n    }\n  }\n\n  return prev;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 132
    },
    {
        "index": 66325,
        "code": "static void gen_cmovcc1(CPUX86State *env, DisasContext *s, TCGMemOp ot, int b,\n                        int modrm, int reg)\n{\n    CCPrepare cc;\n\n    gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n    cc = gen_prepare_cc(s, b, cpu_T1);\n    if (cc.mask != -1) {\n        TCGv t0 = tcg_temp_new();\n        tcg_gen_andi_tl(t0, cc.reg, cc.mask);\n        cc.reg = t0;\n    }\n    if (!cc.use_reg2) {\n        cc.reg2 = tcg_const_tl(cc.imm);\n    }\n\n    tcg_gen_movcond_tl(cc.cond, cpu_T0, cc.reg, cc.reg2,\n                       cpu_T0, cpu_regs[reg]);\n    gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n    if (cc.mask != -1) {\n        tcg_temp_free(cc.reg);\n    }\n    if (!cc.use_reg2) {\n        tcg_temp_free(cc.reg2);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-94",
        "cve": "CVE-2017-8284",
        "length": 239
    },
    {
        "index": 53276,
        "code": "int xmlrpc_getlast_error(void)\n{\n\treturn xmlrpc_error_code;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4478",
        "length": 17
    },
    {
        "index": 118088,
        "code": "void ConfirmEmailDialogDelegate::OnLinkClicked(\n    WindowOpenDisposition disposition) {\n  content::OpenURLParams params(\n      GURL(chrome::kChromeSyncMergeTroubleshootingURL),\n      content::Referrer(),\n      NEW_POPUP,\n      content::PAGE_TRANSITION_AUTO_TOPLEVEL,\n      false);\n  web_contents_->OpenURL(params);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-6634",
        "length": 73
    },
    {
        "index": 117163,
        "code": "    static gboolean attachCallback(WebKitWebInspector*, InspectorTest* test)\n    {\n        return test->attach();\n    }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3099",
        "length": 26
    },
    {
        "index": 69486,
        "code": "int ceph_crypto_key_unarmor(struct ceph_crypto_key *key, const char *inkey)\n{\n\tint inlen = strlen(inkey);\n\tint blen = inlen * 3 / 4;\n\tvoid *buf, *p;\n\tint ret;\n\n\tdout(\"crypto_key_unarmor %s\\n\", inkey);\n\tbuf = kmalloc(blen, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tblen = ceph_unarmor(buf, inkey, inkey+inlen);\n\tif (blen < 0) {\n\t\tkfree(buf);\n\t\treturn blen;\n\t}\n\n\tp = buf;\n\tret = ceph_crypto_key_decode(key, &p, p + blen);\n\tkfree(buf);\n\tif (ret)\n\t\treturn ret;\n\tdout(\"crypto_key_unarmor key %p type %d len %d\\n\", key,\n\t     key->type, key->len);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "length": 192
    },
    {
        "index": 84380,
        "code": "flatpak_proxy_finalize (GObject *object)\n{\n  FlatpakProxy *proxy = FLATPAK_PROXY (object);\n\n  if (g_socket_service_is_active (G_SOCKET_SERVICE (proxy)))\n    unlink (proxy->socket_path);\n\n  g_assert (proxy->clients == NULL);\n\n  g_hash_table_destroy (proxy->policy);\n  g_hash_table_destroy (proxy->wildcard_policy);\n  g_hash_table_destroy (proxy->filters);\n\n  g_free (proxy->socket_path);\n  g_free (proxy->dbus_address);\n\n  G_OBJECT_CLASS (flatpak_proxy_parent_class)->finalize (object);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-436",
        "cve": "CVE-2018-6560",
        "length": 126
    },
    {
        "index": 80671,
        "code": "GF_Err void_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 37
    },
    {
        "index": 96073,
        "code": "char *expand_home(const char *path, const char* homedir) {\n\tassert(path);\n\tassert(homedir);\n\n\tchar *new_name = NULL;\n\tif (strncmp(path, \"${HOME}\", 7) == 0) {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 7) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\telse if (*path == '~') {\n\t\tif (asprintf(&new_name, \"%s%s\", homedir, path + 1) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\treturn new_name;\n\t}\n\n\treturn strdup(path);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-5940",
        "length": 139
    },
    {
        "index": 171267,
        "code": "status_t SoundTriggerHwService::Module::unloadSoundModel_l(sound_model_handle_t handle)\n{\n ssize_t index = mModels.indexOfKey(handle);\n if (index < 0) {\n return BAD_VALUE;\n }\n    sp<Model> model = mModels.valueAt(index);\n    mModels.removeItem(handle);\n if (model->mState == Model::STATE_ACTIVE) {\n        mHwDevice->stop_recognition(mHwDevice, model->mHandle);\n        model->mState = Model::STATE_IDLE;\n }\n AudioSystem::releaseSoundTriggerSession(model->mCaptureSession);\n return mHwDevice->unload_sound_model(mHwDevice, handle);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-3910",
        "length": 137
    },
    {
        "index": 142200,
        "code": "base::FilePath FileManagerBrowserTestBase::MaybeMountCrostini(\n    const std::string& source_path,\n    const std::vector<std::string>& mount_options) {\n  GURL source_url(source_path);\n  DCHECK(source_url.is_valid());\n  if (source_url.scheme() != \"sshfs\") {\n    return {};\n  }\n  CHECK(crostini_volume_->Mount(profile()));\n  return crostini_volume_->mount_path();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-5194",
        "length": 90
    },
    {
        "index": 125251,
        "code": "void DatabaseMessageFilter::OnDatabaseGetSpaceAvailable(\n    const string16& origin_identifier, IPC::Message* reply_msg) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n  DCHECK(db_tracker_->quota_manager_proxy());\n\n  QuotaManager* quota_manager =\n      db_tracker_->quota_manager_proxy()->quota_manager();\n  if (!quota_manager) {\n    NOTREACHED();  // The system is shutting down, messages are unexpected.\n    DatabaseHostMsg_GetSpaceAvailable::WriteReplyParams(\n        reply_msg, static_cast<int64>(0));\n    Send(reply_msg);\n    return;\n  }\n\n  quota_manager->GetUsageAndQuota(\n      DatabaseUtil::GetOriginFromIdentifier(origin_identifier),\n      quota::kStorageTypeTemporary,\n      base::Bind(&DatabaseMessageFilter::OnDatabaseGetUsageAndQuota,\n                 this, reply_msg));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2013-0911",
        "length": 180
    },
    {
        "index": 127074,
        "code": "void ChromeClientImpl::setStatusbarVisible(bool value)\n{\n    m_statusbarVisible = value;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-5150",
        "length": 22
    },
    {
        "index": 151166,
        "code": "void InspectorNetworkAgent::DidFinishXHRLoading(ExecutionContext* context,\n                                                XMLHttpRequest* xhr,\n                                                ThreadableLoaderClient* client,\n                                                const AtomicString& method,\n                                                const String& url) {\n  DidFinishXHRInternal(context, xhr, client, method, url, true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 60
    },
    {
        "index": 22252,
        "code": "SYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n\tcurrent->clear_child_tid = tidptr;\n\n\treturn task_pid_vnr(current);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4621",
        "length": 34
    },
    {
        "index": 170969,
        "code": "String8 MediaHTTP::getMIMEType() const {\n if (mInitCheck != OK) {\n return String8(\"application/octet-stream\");\n }\n\n String8 mimeType;\n status_t err = mHTTPConnection->getMIMEType(&mimeType);\n\n if (err != OK) {\n return String8(\"application/octet-stream\");\n }\n\n return mimeType;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-6699",
        "length": 71
    },
    {
        "index": 162086,
        "code": "base::SequencedTaskRunner& RenderProcessHostImpl::GetAecDumpFileTaskRunner() {\n  if (!audio_debug_recordings_file_task_runner_) {\n    audio_debug_recordings_file_task_runner_ =\n        base::CreateSequencedTaskRunnerWithTraits(\n            {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN,\n             base::TaskPriority::USER_BLOCKING});\n  }\n  return *audio_debug_recordings_file_task_runner_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 99
    },
    {
        "index": 53772,
        "code": "static void mtrr_lookup_start(struct mtrr_iter *iter)\n{\n\tif (!mtrr_is_enabled(iter->mtrr_state)) {\n\t\titer->mtrr_disabled = true;\n\t\treturn;\n\t}\n\n\tif (!mtrr_lookup_fixed_start(iter))\n\t\tmtrr_lookup_var_start(iter);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3713",
        "length": 67
    },
    {
        "index": 5912,
        "code": "static void ohci_die(OHCIState *ohci)\n{\n    OHCIPCIState *dev = container_of(ohci, OHCIPCIState, state);\n\n    trace_usb_ohci_die();\n\n    ohci_set_interrupt(ohci, OHCI_INTR_UE);\n    ohci_bus_stop(ohci);\n    pci_set_word(dev->parent_obj.config + PCI_STATUS,\n                 PCI_STATUS_DETECTED_PARITY);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-9330",
        "length": 91
    },
    {
        "index": 137635,
        "code": " MockDownloadController::~MockDownloadController() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1296",
        "length": 10
    },
    {
        "index": 162134,
        "code": "void RenderProcessHostImpl::ReleaseOnCloseACK(\n    RenderProcessHost* host,\n    const SessionStorageNamespaceMap& sessions,\n    int view_route_id) {\n  DCHECK(host);\n  if (sessions.empty())\n    return;\n  SessionStorageHolder* holder = static_cast<SessionStorageHolder*>(\n      host->GetUserData(kSessionStorageHolderKey));\n  if (!holder) {\n    holder = new SessionStorageHolder();\n    host->SetUserData(kSessionStorageHolderKey, base::WrapUnique(holder));\n  }\n  holder->Hold(sessions, view_route_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 119
    },
    {
        "index": 57544,
        "code": "int ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_get_blocks At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, blocks_for_truncate(inode));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8324",
        "length": 176
    },
    {
        "index": 176010,
        "code": "static void bta_av_close_all_rc(tBTA_AV_CB* p_cb) {\n int i;\n\n for (i = 0; i < BTA_AV_NUM_RCB; i++) {\n if ((p_cb->disabling) || (bta_av_cb.rcb[i].shdl != 0))\n      bta_av_del_rc(&bta_av_cb.rcb[i]);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-9507",
        "length": 82
    },
    {
        "index": 94250,
        "code": "static enum test_return test_binary_decrq(void) {\n    return test_binary_decr_impl(\"test_binary_decrq\",\n                                 PROTOCOL_BINARY_CMD_DECREMENTQ);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-1152",
        "length": 37
    },
    {
        "index": 94214,
        "code": "static int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).pid,\n\t\t\t   cb_arg->seq, &netlbl_cipsov4_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_CIPSOV4_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\tret_val = nla_put_u32(cb_arg->skb,\n\t\t\t      NLBL_CIPSOV4_A_MTYPE,\n\t\t\t      doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\treturn genlmsg_end(cb_arg->skb, data);\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2007-6762",
        "length": 251
    },
    {
        "index": 53854,
        "code": "acpi_os_physical_table_override(struct acpi_table_header *existing_table,\n\t\t\t\tacpi_physical_address *address, u32 *length)\n{\n\tint table_offset = 0;\n\tint table_index = 0;\n\tstruct acpi_table_header *table;\n\tu32 table_length;\n\n\t*length = 0;\n\t*address = 0;\n\tif (!acpi_tables_addr)\n\t\treturn AE_OK;\n\n\twhile (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {\n\t\ttable = acpi_os_map_memory(acpi_tables_addr + table_offset,\n\t\t\t\t\t   ACPI_HEADER_SIZE);\n\t\tif (table_offset + table->length > all_tables_size) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tWARN_ON(1);\n\t\t\treturn AE_OK;\n\t\t}\n\n\t\ttable_length = table->length;\n\n\t\t/* Only override tables matched */\n\t\tif (test_bit(table_index, acpi_initrd_installed) ||\n\t\t    memcmp(existing_table->signature, table->signature, 4) ||\n\t\t    memcmp(table->oem_table_id, existing_table->oem_table_id,\n\t\t\t   ACPI_OEM_TABLE_ID_SIZE)) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tgoto next_table;\n\t\t}\n\n\t\t*length = table_length;\n\t\t*address = acpi_tables_addr + table_offset;\n\t\tacpi_table_taint(existing_table);\n\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\tset_bit(table_index, acpi_initrd_installed);\n\t\tbreak;\n\nnext_table:\n\t\ttable_offset += table_length;\n\t\ttable_index++;\n\t}\n\treturn AE_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-3699",
        "length": 333
    },
    {
        "index": 38186,
        "code": "SYSCALL_DEFINE6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct timespec __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = NULL;\n\tu32 val2 = 0;\n\tint cmd = op & FUTEX_CMD_MASK;\n\n\tif (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||\n\t\t      cmd == FUTEX_WAIT_BITSET ||\n\t\t      cmd == FUTEX_WAIT_REQUEUE_PI)) {\n\t\tif (copy_from_user(&ts, utime, sizeof(ts)) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -EINVAL;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == FUTEX_WAIT)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\t/*\n\t * requeue parameter in 'utime' if cmd == FUTEX_*_REQUEUE_*.\n\t * number of waiters to wake in 'utime' if cmd == FUTEX_WAKE_OP.\n\t */\n\tif (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||\n\t    cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)\n\t\tval2 = (u32) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3153",
        "length": 330
    },
    {
        "index": 29075,
        "code": "static long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = kvm_dev_ioctl_create_vm(arg);\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_dev_ioctl_check_extension_generic(arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     /* struct kvm_run */\n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    /* pio data page */\n#endif\n#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET\n\t\tr += PAGE_SIZE;    /* coalesced mmio ring page */\n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4592",
        "length": 249
    },
    {
        "index": 186545,
        "code": "void ProfileChooserView::RemoveAccount() {\n  DCHECK(!account_id_to_remove_.empty());\n   ProfileOAuth2TokenService* oauth2_token_service =\n       ProfileOAuth2TokenServiceFactory::GetForProfile(browser_->profile());\n   if (oauth2_token_service) {\n    oauth2_token_service->RevokeCredentials(account_id_to_remove_);\n     PostActionPerformed(ProfileMetrics::PROFILE_DESKTOP_MENU_REMOVE_ACCT);\n   }\n   account_id_to_remove_.clear();\n\n  ShowViewFromMode(profiles::BUBBLE_VIEW_MODE_ACCOUNT_MANAGEMENT);\n}\n",
        "line": "    oauth2_token_service->RevokeCredentials(account_id_to_remove_);\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1665",
        "length": 112
    },
    {
        "index": 120325,
        "code": "  void ForceTimeout() {\n    if (IsRunning()) {\n      user_task().Run();\n      Stop();\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2887",
        "length": 27
    },
    {
        "index": 186134,
        "code": " png_get_mmx_bitdepth_threshold (png_structp png_ptr)\n {\n     /* Obsolete, to be removed from libpng-1.4.0 */\n    return (png_ptr? 0: 0);\n }\n",
        "line": "    return (png_ptr? 0: 0);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8126",
        "length": 47
    },
    {
        "index": 27012,
        "code": "static int do_send_XMotionEvent(rpc_message_t *message, XEvent *xevent)\n{\n  int error;\n  if ((error = do_send_XAnyEvent(message, xevent)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_uint32(message, xevent->xmotion.root)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_uint32(message, xevent->xmotion.subwindow)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_uint32(message, xevent->xmotion.time)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_int32(message, xevent->xmotion.x)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_int32(message, xevent->xmotion.y)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_int32(message, xevent->xmotion.x_root)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_int32(message, xevent->xmotion.y_root)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_uint32(message, xevent->xmotion.state)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_char(message, xevent->xmotion.is_hint)) < 0)\n\treturn error;\n  if ((error = rpc_message_send_int32(message, xevent->xmotion.same_screen)) < 0)\n\treturn error;\n  return RPC_ERROR_NO_ERROR;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2486",
        "length": 320
    },
    {
        "index": 102823,
        "code": "bool OutdatedPluginInfoBarDelegate::Cancel() {\n  UserMetrics::RecordAction(\n      UserMetricsAction(\"OutdatedPluginInfobar.AllowThisTime\"));\n  return PluginInfoBarDelegate::Cancel();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2836",
        "length": 43
    },
    {
        "index": 123622,
        "code": "static bool prepareResourceBuffer(Resource* cachedResource, bool* hasZeroSize)\n{\n    *hasZeroSize = false;\n    if (!cachedResource)\n        return false;\n\n    if (cachedResource->dataBufferingPolicy() == DoNotBufferData)\n        return false;\n\n    if (!cachedResource->encodedSize()) {\n        *hasZeroSize = true;\n        return true;\n    }\n\n    if (cachedResource->isPurgeable()) {\n        if (!cachedResource->makePurgeable(false))\n            return false;\n    }\n\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0892",
        "length": 115
    },
    {
        "index": 176386,
        "code": "bt_status_t btif_av_execute_service(bool b_enable) {\n if (b_enable) {\n/* TODO: Removed BTA_SEC_AUTHORIZE since the Java/App does not\n * handle this request in order to allow incoming connections to succeed.\n * We need to put this back once support for this is added */\n\n/* Added BTA_AV_FEAT_NO_SCO_SSPD - this ensures that the BTA does not\n * auto-suspend av streaming on AG events(SCO or Call). The suspend shall\n * be initiated by the app/audioflinger layers */\n/* Support for browsing for SDP record should work only if we enable BROWSE\n * while registering. */\n#if (AVRC_METADATA_INCLUDED == TRUE)\n    BTA_AvEnable(BTA_SEC_AUTHENTICATE,\n                 BTA_AV_FEAT_RCTG | BTA_AV_FEAT_METADATA | BTA_AV_FEAT_VENDOR |\n                     BTA_AV_FEAT_NO_SCO_SSPD\n#if (AVRC_ADV_CTRL_INCLUDED == TRUE)\n | BTA_AV_FEAT_RCCT | BTA_AV_FEAT_ADV_CTRL |\n                     BTA_AV_FEAT_BROWSE\n#endif\n ,\n                 bte_av_callback);\n#else\n    BTA_AvEnable(BTA_SEC_AUTHENTICATE,\n (BTA_AV_FEAT_RCTG | BTA_AV_FEAT_NO_SCO_SSPD), bte_av_callback);\n#endif\n    BTA_AvRegister(BTA_AV_CHNL_AUDIO, BTIF_AV_SERVICE_NAME, 0, NULL,\n                   UUID_SERVCLASS_AUDIO_SOURCE);\n } else {\n    BTA_AvDeregister(btif_av_cb.bta_handle);\n    BTA_AvDisable();\n }\n return BT_STATUS_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-9476",
        "length": 352
    },
    {
        "index": 46434,
        "code": "xfs_file_aio_write_checks(\n\tstruct file\t\t*file,\n\tloff_t\t\t\t*pos,\n\tsize_t\t\t\t*count,\n\tint\t\t\t*iolock)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\nrestart:\n\terror = generic_write_checks(file, pos, count, S_ISBLK(inode->i_mode));\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the offset is beyond the size of the file, we need to zero any\n\t * blocks that fall between the existing EOF and the start of this\n\t * write.  If zeroing is needed and we are currently holding the\n\t * iolock shared, we need to update it to exclusive which implies\n\t * having to redo all checks before.\n\t */\n\tif (*pos > i_size_read(inode)) {\n\t\tif (*iolock == XFS_IOLOCK_SHARED) {\n\t\t\txfs_rw_iunlock(ip, *iolock);\n\t\t\t*iolock = XFS_IOLOCK_EXCL;\n\t\t\txfs_rw_ilock(ip, *iolock);\n\t\t\tgoto restart;\n\t\t}\n\t\terror = -xfs_zero_eof(ip, *pos, i_size_read(inode));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Updating the timestamps will grab the ilock again from\n\t * xfs_fs_dirty_inode, so we have to call it after dropping the\n\t * lock above.  Eventually we should look into a way to avoid\n\t * the pointless lock roundtrip.\n\t */\n\tif (likely(!(file->f_mode & FMODE_NOCMTIME))) {\n\t\terror = file_update_time(file);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * If we're writing the file then make sure to clear the setuid and\n\t * setgid bits if the process is not being run by root.  This keeps\n\t * people from modifying setuid and setgid binaries.\n\t */\n\treturn file_remove_suid(file);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-7822",
        "length": 436
    },
    {
        "index": 165595,
        "code": "void FrameLoader::LoadInSameDocument(\n    const KURL& url,\n    scoped_refptr<SerializedScriptValue> state_object,\n    WebFrameLoadType frame_load_type,\n    HistoryItem* history_item,\n    ClientRedirectPolicy client_redirect,\n    Document* initiating_document,\n    std::unique_ptr<WebDocumentLoader::ExtraData> extra_data) {\n  DCHECK(!state_object || frame_load_type == WebFrameLoadType::kBackForward);\n\n  DetachDocumentLoader(provisional_document_loader_);\n\n  if (!frame_->GetPage())\n    return;\n  SaveScrollState();\n\n  KURL old_url = frame_->GetDocument()->Url();\n  bool hash_change = EqualIgnoringFragmentIdentifier(url, old_url) &&\n                     url.FragmentIdentifier() != old_url.FragmentIdentifier();\n  if (hash_change) {\n    frame_->GetEventHandler().StopAutoscroll();\n    frame_->DomWindow()->EnqueueHashchangeEvent(old_url, url);\n  }\n  document_loader_->SetIsClientRedirect(client_redirect ==\n                                        ClientRedirectPolicy::kClientRedirect);\n  if (history_item)\n    document_loader_->SetItemForHistoryNavigation(history_item);\n  if (extra_data)\n    Client()->UpdateDocumentLoader(document_loader_, std::move(extra_data));\n  UpdateForSameDocumentNavigation(url, kSameDocumentNavigationDefault, nullptr,\n                                  kScrollRestorationAuto, frame_load_type,\n                                  initiating_document);\n\n  ClearInitialScrollState();\n\n  frame_->GetDocument()->CheckCompleted();\n\n  std::unique_ptr<HistoryItem::ViewState> view_state;\n  if (history_item && history_item->GetViewState()) {\n    view_state =\n        std::make_unique<HistoryItem::ViewState>(*history_item->GetViewState());\n  }\n\n  frame_->DomWindow()->StatePopped(state_object\n                                       ? std::move(state_object)\n                                       : SerializedScriptValue::NullValue());\n\n  if (history_item) {\n    RestoreScrollPositionAndViewState(\n        frame_load_type, true /* is_same_document */, view_state.get(),\n        history_item->ScrollRestorationType());\n  }\n\n  ProcessFragment(url, frame_load_type, kNavigationWithinSameDocument);\n\n  TakeObjectSnapshot();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2019-5799",
        "length": 440
    },
    {
        "index": 29453,
        "code": "static void serial_unlink_irq_chain(struct mp_port *mtpt)\n{\n\tstruct irq_info *i = irq_lists + mtpt->port.irq;\n\n\tif (list_empty(i->head))\n\t{\n\t\tfree_irq(mtpt->port.irq, i);\n\t}\n\tserial_do_unlink(i, mtpt);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-4516",
        "length": 67
    },
    {
        "index": 135227,
        "code": "void Document::enqueueAnimationFrameEvent(PassRefPtrWillBeRawPtr<Event> event)\n{\n    ensureScriptedAnimationController().enqueueEvent(event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6768",
        "length": 31
    },
    {
        "index": 52717,
        "code": "int snd_timer_stop(struct snd_timer_instance *timeri)\n{\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\treturn snd_timer_stop_slave(timeri, true);\n\telse\n\t\treturn snd_timer_stop1(timeri, true);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-4578",
        "length": 53
    },
    {
        "index": 70418,
        "code": "static int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-10248",
        "length": 73
    },
    {
        "index": 167605,
        "code": "bool SiteInstanceImpl::IsOriginLockASite(const GURL& lock_url) {\n  return lock_url.has_scheme() && lock_url.has_host();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-285",
        "cve": "CVE-2018-16073",
        "length": 32
    },
    {
        "index": 157387,
        "code": "void HTMLMediaElement::AudioSourceProviderImpl::ProvideInput(\n    AudioBus* bus,\n    size_t frames_to_process) {\n  DCHECK(bus);\n\n  MutexTryLocker try_locker(provide_input_lock);\n  if (!try_locker.Locked() || !web_audio_source_provider_ || !client_.Get()) {\n    bus->Zero();\n    return;\n  }\n\n  unsigned n = bus->NumberOfChannels();\n  WebVector<float*> web_audio_data(n);\n  for (unsigned i = 0; i < n; ++i)\n    web_audio_data[i] = bus->Channel(i)->MutableData();\n\n  web_audio_source_provider_->ProvideInput(web_audio_data, frames_to_process);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 144
    },
    {
        "index": 88708,
        "code": "static dma_addr_t dwc3_trb_dma_offset(struct dwc3_ep *dep,\n\t\tstruct dwc3_trb *trb)\n{\n\tu32\t\toffset = (char *) trb - (char *) dep->trb_pool;\n\n\treturn dep->trb_pool_dma + offset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2019-14763",
        "length": 63
    },
    {
        "index": 5096,
        "code": "static int curl_debug(CURL *cp, curl_infotype type, char *buf, size_t buf_len, void *ctx) /* {{{ */\n{\n\tphp_curl *ch = (php_curl *)ctx;\n\n\tif (type == CURLINFO_HEADER_OUT) {\n\t\tif (ch->header.str) {\n\t\t\tzend_string_release(ch->header.str);\n\t\t}\n\t\tif (buf_len > 0) {\n\t\t\tch->header.str = zend_string_init(buf, buf_len, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n/* }}} */\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1352",
        "length": 118
    },
    {
        "index": 111301,
        "code": "void WebPage::removeOriginAccessWhitelistEntry(const BlackBerry::Platform::String& sourceOrigin, const BlackBerry::Platform::String& destinationOrigin, bool allowDestinationSubdomains)\n{\n    d->removeOriginAccessWhitelistEntry(sourceOrigin, destinationOrigin, allowDestinationSubdomains);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 59
    },
    {
        "index": 183264,
        "code": "static void copy_xauthority(void) {\n\tchar *src = RUN_XAUTHORITY_FILE ;\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tif (is_link(dest)) {\n\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n \t\n \tunlink(src);\n}\n",
        "line": "\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n",
        "label": 1,
        "cwe": "CWE-269",
        "cve": "CVE-2017-5940",
        "length": 207
    },
    {
        "index": 102935,
        "code": "void DefaultTabHandler::TabPinnedStateChanged(TabContentsWrapper* contents,\n                                              int index) {\n  delegate_->AsBrowser()->TabPinnedStateChanged(contents, index);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2840",
        "length": 37
    },
    {
        "index": 188292,
        "code": "bool Cluster::EOS() const\n//// long long element_size)\n {\n    return (m_pSegment == NULL);\n }\n",
        "line": "    return (m_pSegment == NULL);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 25
    },
    {
        "index": 81411,
        "code": "int trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & TRACE_ITER_OVERWRITE) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 47
    },
    {
        "index": 57404,
        "code": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-8539",
        "length": 93
    },
    {
        "index": 165422,
        "code": "void StoragePartitionImpl::OpenLocalStorage(\n    const url::Origin& origin,\n    blink::mojom::StorageAreaRequest request) {\n  int process_id = bindings_.dispatch_context();\n  if (!ChildProcessSecurityPolicy::GetInstance()->CanAccessDataForOrigin(\n          process_id, origin.GetURL())) {\n    SYSLOG(WARNING) << \"Killing renderer: illegal localStorage request.\";\n    bindings_.ReportBadMessage(\"Access denied for localStorage request\");\n    return;\n  }\n  dom_storage_context_->OpenLocalStorage(origin, std::move(request));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2019-5797",
        "length": 112
    },
    {
        "index": 107030,
        "code": "void QQuickWebView::mouseMoveEvent(QMouseEvent* event)\n{\n    Q_D(QQuickWebView);\n    d->pageView->eventHandler()->handleMouseMoveEvent(event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-1800",
        "length": 37
    },
    {
        "index": 115919,
        "code": "bool ewk_frame_init(Evas_Object* ewkFrame, Evas_Object* view, WebCore::Frame* frame)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    if (!smartData->frame) {\n        WebCore::FrameLoaderClientEfl* frameLoaderClient = _ewk_frame_loader_efl_get(frame);\n        frameLoaderClient->setWebFrame(ewkFrame);\n        smartData->frame = frame;\n        smartData->view = view;\n        frame->init();\n        return true;\n    }\n\n    ERR(\"frame %p already set for %p, ignored new %p\",\n        smartData->frame, ewkFrame, frame);\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3103",
        "length": 153
    },
    {
        "index": 128290,
        "code": "PaintBehavior FrameView::paintBehavior() const\n{\n    return m_paintBehavior;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-3191",
        "length": 19
    },
    {
        "index": 123903,
        "code": "void RenderViewImpl::OnReplaceMisspelling(const string16& text) {\n  if (!webview())\n    return;\n\n  WebFrame* frame = webview()->focusedFrame();\n  if (!frame->hasSelection())\n    return;\n\n  frame->replaceMisspelledRange(text);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0918",
        "length": 61
    },
    {
        "index": 15308,
        "code": "static PHP_FUNCTION(xmlwriter_end_cdata)\n{\n\tphp_xmlwriter_end(INTERNAL_FUNCTION_PARAM_PASSTHRU, xmlTextWriterEndCDATA);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-3412",
        "length": 32
    },
    {
        "index": 126192,
        "code": "string16 Browser::GetWindowTitleForCurrentTab() const {\n  WebContents* contents = chrome::GetActiveWebContents(this);\n  string16 title;\n\n  if (contents) {\n    title = contents->GetTitle();\n    FormatTitleForDisplay(&title);\n  }\n  if (title.empty())\n    title = CoreTabHelper::GetDefaultTitle();\n\n#if defined(OS_MACOSX) || defined(USE_ASH)\n  return title;\n#else\n  return is_app() ?\n      title :\n      l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT, title);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 124
    },
    {
        "index": 171021,
        "code": "status_t AudioFlinger::EffectModule::setDevice(audio_devices_t device)\n{\n if (device == AUDIO_DEVICE_NONE) {\n return NO_ERROR;\n }\n\n Mutex::Autolock _l(mLock);\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n status_t status = NO_ERROR;\n if ((mDescriptor.flags & EFFECT_FLAG_DEVICE_MASK) == EFFECT_FLAG_DEVICE_IND) {\n status_t cmdStatus;\n uint32_t size = sizeof(status_t);\n uint32_t cmd = audio_is_output_devices(device) ? EFFECT_CMD_SET_DEVICE :\n                            EFFECT_CMD_SET_INPUT_DEVICE;\n        status = (*mEffectInterface)->command(mEffectInterface,\n                                              cmd,\n sizeof(uint32_t),\n &device,\n &size,\n &cmdStatus);\n }\n return status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3924",
        "length": 155
    },
    {
        "index": 95551,
        "code": "void S_AL_SrcShutdown( void )\n{\n\tint i;\n\tsrc_t *curSource;\n\n\tif(!alSourcesInitialised)\n\t\treturn;\n\n\tfor(i = 0; i < srcCount; i++)\n\t{\n\t\tcurSource = &srcList[i];\n\t\t\n\t\tif(curSource->isLocked)\n\t\t\tCom_DPrintf( S_COLOR_YELLOW \"WARNING: Source %d is locked\\n\", i);\n\n\t\tif(curSource->entity > 0)\n\t\t\tentityList[curSource->entity].srcAllocated = qfalse;\n\n\t\tqalSourceStop(srcList[i].alSource);\n\t\tqalDeleteSources(1, &srcList[i].alSource);\n\t}\n\n\tmemset(srcList, 0, sizeof(srcList));\n\n\talSourcesInitialised = qfalse;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 159
    },
    {
        "index": 140623,
        "code": "std::string OutOfProcessInstance::GetURL() {\n  return url_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-1302",
        "length": 18
    },
    {
        "index": 97346,
        "code": "ResourceError FrameLoader::blockedError(const ResourceRequest& request) const\n{\n    return m_client->blockedError(request);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 27
    },
    {
        "index": 167317,
        "code": "void ScrollableShelfView::StartShelfScrollAnimation(float scroll_distance) {\n  const gfx::Transform current_transform = shelf_view_->GetTransform();\n  gfx::Transform reverse_transform = current_transform;\n  if (ShouldAdaptToRTL())\n    scroll_distance = -scroll_distance;\n  if (GetShelf()->IsHorizontalAlignment())\n    reverse_transform.Translate(gfx::Vector2dF(scroll_distance, 0));\n  else\n    reverse_transform.Translate(gfx::Vector2dF(0, scroll_distance));\n  shelf_view_->layer()->SetTransform(reverse_transform);\n  ui::ScopedLayerAnimationSettings animation_settings(\n      shelf_view_->layer()->GetAnimator());\n  animation_settings.SetTweenType(gfx::Tween::EASE_OUT);\n  animation_settings.SetPreemptionStrategy(\n      ui::LayerAnimator::IMMEDIATELY_SET_NEW_TARGET);\n  shelf_view_->layer()->SetTransform(current_transform);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 185
    },
    {
        "index": 56942,
        "code": "static inline unsigned long fuse_get_user_addr(const struct iov_iter *ii)\n{\n\treturn (unsigned long)ii->iov->iov_base + ii->iov_offset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2015-8785",
        "length": 35
    },
    {
        "index": 138710,
        "code": "void RenderFrameHostImpl::Init() {\n  ResumeBlockedRequestsForFrame();\n  if (!waiting_for_init_)\n    return;\n\n  waiting_for_init_ = false;\n  if (pendinging_navigate_) {\n    frame_tree_node()->navigator()->OnBeginNavigation(\n        frame_tree_node(), pendinging_navigate_->first,\n        pendinging_navigate_->second);\n    pendinging_navigate_.reset();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1278",
        "length": 86
    },
    {
        "index": 28288,
        "code": "static ssize_t event_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", (unsigned int)atomic_read(&idev->event));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-6763",
        "length": 57
    },
    {
        "index": 131901,
        "code": "static void voidMethodElementArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::voidMethodElementArgMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 71
    },
    {
        "index": 101602,
        "code": "void Browser::ConfirmSetDefaultSearchProvider(\n    TabContents* tab_contents,\n    TemplateURL* template_url,\n    TemplateURLService* template_url_service) {\n  window()->ConfirmSetDefaultSearchProvider(tab_contents, template_url,\n                                            template_url_service);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3896",
        "length": 54
    },
    {
        "index": 46984,
        "code": "static void __exit fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 18
    },
    {
        "index": 92745,
        "code": "static inline void unthrottle_offline_cfs_rqs(struct rq *rq) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2018-20784",
        "length": 19
    },
    {
        "index": 1643,
        "code": "ENUM_PTRS_WITH(dc_pattern_enum_ptrs, gx_device_color *cptr)\n{\n    return ENUM_USING(st_dc_pure_masked, vptr, size, index - 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-19134",
        "length": 41
    },
    {
        "index": 17730,
        "code": "FreeMarkedVisuals(ScreenPtr pScreen)\n{\n    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);\n    FakedVisualList *prev, *curr, *tmp;\n\n    if (!pScreenPriv->fakedVisuals)\n        return;\n\n    prev = NULL;\n    curr = pScreenPriv->fakedVisuals;\n\n    while (curr) {\n        if (curr->free) {\n            tmp = curr;\n            curr = curr->next;\n            if (prev)\n                prev->next = curr;\n            else\n                pScreenPriv->fakedVisuals = curr;\n            free(tmp->pVisual);\n            free(tmp);\n        }\n        else {\n            prev = curr;\n            curr = curr->next;\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-12182",
        "length": 161
    },
    {
        "index": 172850,
        "code": "static bt_status_t btif_in_fetch_bonded_device(const char *bdstr)\n{\n    BOOLEAN bt_linkkey_file_found=FALSE;\n\n        LINK_KEY link_key;\n size_t size = sizeof(link_key);\n if(btif_config_get_bin(bdstr, \"LinkKey\", (uint8_t *)link_key, &size))\n {\n int linkkey_type;\n if(btif_config_get_int(bdstr, \"LinkKeyType\", &linkkey_type))\n {\n                bt_linkkey_file_found = TRUE;\n }\n else\n {\n                bt_linkkey_file_found = FALSE;\n }\n }\n#if (BLE_INCLUDED == TRUE)\n if((btif_in_fetch_bonded_ble_device(bdstr, FALSE, NULL) != BT_STATUS_SUCCESS)\n && (!bt_linkkey_file_found))\n {\n            BTIF_TRACE_DEBUG(\"Remote device:%s, no link key or ble key found\", bdstr);\n return BT_STATUS_FAIL;\n }\n#else\n if((!bt_linkkey_file_found))\n {\n            BTIF_TRACE_DEBUG(\"Remote device:%s, no link key found\", bdstr);\n return BT_STATUS_FAIL;\n }\n#endif\n return BT_STATUS_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-3760",
        "length": 232
    },
    {
        "index": 35097,
        "code": "static ssize_t enabled_store(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tret = double_flag_store(kobj, attr, buf, count,\n\t\t\t\tTRANSPARENT_HUGEPAGE_FLAG,\n\t\t\t\tTRANSPARENT_HUGEPAGE_REQ_MADV_FLAG);\n\n\tif (ret > 0) {\n\t\tint err = start_khugepaged();\n\t\tif (err)\n\t\t\tret = err;\n\t}\n\n\tif (ret > 0 &&\n\t    (test_bit(TRANSPARENT_HUGEPAGE_FLAG,\n\t\t      &transparent_hugepage_flags) ||\n\t     test_bit(TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,\n\t\t      &transparent_hugepage_flags)))\n\t\tset_recommended_min_free_kbytes();\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2479",
        "length": 168
    },
    {
        "index": 122008,
        "code": "base::FilePath GetAppHostPathForInstallationLevel(InstallationLevel level) {\n  return FindExeRelativeToSetupExe(\n      GetSetupExeFromRegistry(level, kAppHostAppId), kChromeAppHostExe);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2861",
        "length": 50
    },
    {
        "index": 143885,
        "code": "ComponentControllerImpl::~ComponentControllerImpl() {\n  for (WaitCallback& next_callback : termination_wait_callbacks_) {\n    next_callback(did_terminate_abnormally_ ? 1 : 0);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-1636",
        "length": 44
    },
    {
        "index": 57776,
        "code": "static int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_interrupt_allowed(vcpu) &&\n\t\t!kvm_cpu_has_interrupt(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-7513",
        "length": 67
    },
    {
        "index": 33042,
        "code": "static int sctp_setsockopt_autoclose(struct sock *sk, char __user *optval,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t/* Applicable to UDP-style socket only */\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sp->autoclose, optval, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1828",
        "length": 110
    },
    {
        "index": 94946,
        "code": "static int ecryptfs_release(struct inode *inode, struct file *file)\n{\n\tecryptfs_put_lower_file(inode);\n\tkmem_cache_free(ecryptfs_file_info_cache,\n\t\t\tecryptfs_file_to_private(file));\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1583",
        "length": 53
    },
    {
        "index": 88677,
        "code": "int dwc3_gadget_resume(struct dwc3 *dwc)\n{\n\tint\t\t\tret;\n\n\tif (!dwc->gadget_driver)\n\t\treturn 0;\n\n\tret = __dwc3_gadget_start(dwc);\n\tif (ret < 0)\n\t\tgoto err0;\n\n\tret = dwc3_gadget_run_stop(dwc, true, false);\n\tif (ret < 0)\n\t\tgoto err1;\n\n\treturn 0;\n\nerr1:\n\t__dwc3_gadget_stop(dwc);\n\nerr0:\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2019-14763",
        "length": 112
    },
    {
        "index": 35683,
        "code": "static const char *direct_chunkreader(lua_State *lvm, void *udata,\n                                      size_t *plen)\n{\n    const char *p;\n    struct cr_ctx *ctx = udata;\n\n    if (ctx->startline) {\n        *plen = ctx->startline > N_LF ? N_LF : ctx->startline;\n        ctx->startline -= *plen;\n        return lf;\n    }\n    *plen = config_getstr(ctx->cfp, ctx->buf, HUGE_STRING_LEN);\n\n    for (p = ctx->buf; isspace(*p); ++p);\n    if (p[0] == '<' && p[1] == '/') {\n        apr_size_t i = 0;\n        while (i < strlen(ctx->endstr)) {\n            if (tolower(p[i + 2]) != ctx->endstr[i])\n                return ctx->buf;\n            ++i;\n        }\n        *plen = 0;\n        return NULL;\n    }\n    /*fprintf(stderr, \"buf read: %s\\n\", ctx->buf); */\n    return ctx->buf;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-8109",
        "length": 231
    },
    {
        "index": 36422,
        "code": "static void pppol2tp_session_destruct(struct sock *sk)\n{\n\tstruct l2tp_session *session = sk->sk_user_data;\n\tif (session) {\n\t\tsk->sk_user_data = NULL;\n\t\tBUG_ON(session->magic != L2TP_SESSION_MAGIC);\n\t\tl2tp_session_dec_refcount(session);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-4943",
        "length": 73
    },
    {
        "index": 32721,
        "code": "static inline void tg3_reset_task_schedule(struct tg3 *tp)\n{\n\tif (!test_and_set_bit(TG3_FLAG_RESET_TASK_PENDING, tp->tg3_flags))\n\t\tschedule_work(&tp->reset_task);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "length": 47
    },
    {
        "index": 126752,
        "code": "TabContents* BrowserView::GetActiveTabContents() const {\n  return chrome::GetActiveTabContents(browser_.get());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 27
    },
    {
        "index": 42057,
        "code": "static void sysvipc_proc_stop(struct seq_file *s, void *it)\n{\n\tstruct kern_ipc_perm *ipc = it;\n\tstruct ipc_proc_iter *iter = s->private;\n\tstruct ipc_proc_iface *iface = iter->iface;\n\tstruct ipc_ids *ids;\n\n\t/* If we had a locked structure, release it */\n\tif (ipc && ipc != SEQ_START_TOKEN)\n\t\tipc_unlock(ipc);\n\n\tids = &iter->ns->ids[iface->ids];\n\t/* Release the lock we took in start() */\n\tup_read(&ids->rwsem);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7613",
        "length": 119
    },
    {
        "index": 75231,
        "code": "static void conn_release_items(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        item_remove(c->item);\n        c->item = 0;\n    }\n\n    while (c->ileft > 0) {\n        item *it = *(c->icurr);\n        assert((it->it_flags & ITEM_SLABBED) == 0);\n        item_remove(it);\n        c->icurr++;\n        c->ileft--;\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n#ifdef EXTSTORE\n    if (c->io_wraplist) {\n        io_wrap *tmp = c->io_wraplist;\n        while (tmp) {\n            io_wrap *next = tmp->next;\n            recache_or_free(c, tmp);\n            do_cache_free(c->thread->io_cache, tmp); // lockless\n            tmp = next;\n        }\n        c->io_wraplist = NULL;\n    }\n#endif\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-1000115",
        "length": 267
    },
    {
        "index": 148792,
        "code": "    InterstitialPageRVHDelegateView(InterstitialPageImpl* page)\n    : interstitial_page_(page) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 26
    },
    {
        "index": 148646,
        "code": "gpu::SurfaceHandle SkiaOutputSurfaceImpl::GetSurfaceHandle() const {\n  return dependency_->GetSurfaceHandle();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2017-5094",
        "length": 26
    },
    {
        "index": 135396,
        "code": "bool Document::shouldScheduleLayoutTreeUpdate() const\n{\n    if (!isActive())\n        return false;\n    if (inStyleRecalc())\n        return false;\n    if (m_lifecycle.state() == DocumentLifecycle::InPreLayout)\n        return false;\n    if (!shouldScheduleLayout())\n        return false;\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6768",
        "length": 70
    },
    {
        "index": 184622,
        "code": "ChromotingHost::ChromotingHost(ChromotingHostContext* context,\n                               MutableHostConfig* config,\n                               DesktopEnvironment* environment,\n                               AccessVerifier* access_verifier,\n                               bool allow_nat_traversal)\n    : context_(context),\n      desktop_environment_(environment),\n       config_(config),\n       access_verifier_(access_verifier),\n       allow_nat_traversal_(allow_nat_traversal),\n      state_(kInitial),\n       stopping_recorders_(0),\n       protocol_config_(protocol::CandidateSessionConfig::CreateDefault()),\n       is_curtained_(false),\n       is_it2me_(false) {\n  DCHECK(desktop_environment_);\n  desktop_environment_->set_host(this);\n}\n",
        "line": "      state_(kInitial),\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 142
    },
    {
        "index": 163887,
        "code": "void DevToolsEventForwarder::SetWhitelistedShortcuts(\n    const std::string& message) {\n  std::unique_ptr<base::Value> parsed_message = base::JSONReader::Read(message);\n  base::ListValue* shortcut_list;\n  if (!parsed_message || !parsed_message->GetAsList(&shortcut_list))\n      return;\n  base::ListValue::iterator it = shortcut_list->begin();\n  for (; it != shortcut_list->end(); ++it) {\n    base::DictionaryValue* dictionary;\n    if (!it->GetAsDictionary(&dictionary))\n      continue;\n    int key_code = 0;\n    dictionary->GetInteger(\"keyCode\", &key_code);\n    if (key_code == 0)\n      continue;\n    int modifiers = 0;\n    dictionary->GetInteger(\"modifiers\", &modifiers);\n    if (!KeyWhitelistingAllowed(key_code, modifiers)) {\n      LOG(WARNING) << \"Key whitelisting forbidden: \"\n                   << \"(\" << key_code << \",\" << modifiers << \")\";\n      continue;\n    }\n    whitelisted_keys_.insert(CombineKeyCodeAndModifiers(key_code, modifiers));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-668",
        "cve": "CVE-2017-15393",
        "length": 239
    },
    {
        "index": 65063,
        "code": "static void init_reg_state(struct bpf_reg_state *regs)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_BPF_REG; i++) {\n\t\tregs[i].type = NOT_INIT;\n\t\tregs[i].imm = 0;\n\t\tregs[i].min_value = BPF_REGISTER_MIN_RANGE;\n\t\tregs[i].max_value = BPF_REGISTER_MAX_RANGE;\n\t}\n\n\t/* frame pointer */\n\tregs[BPF_REG_FP].type = FRAME_PTR;\n\n\t/* 1st arg to a function */\n\tregs[BPF_REG_1].type = PTR_TO_CTX;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-9150",
        "length": 127
    },
    {
        "index": 8292,
        "code": "XRRFreeMonitors(XRRMonitorInfo *monitors)\n{\n    Xfree(monitors);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2016-7948",
        "length": 22
    },
    {
        "index": 155127,
        "code": "bool OmniboxViewViews::MaybeFocusTabButton() {\n  if (SelectedSuggestionHasTabMatch() &&\n      model()->popup_model()->selected_line_state() ==\n          OmniboxPopupModel::NORMAL) {\n    model()->popup_model()->SetSelectedLineState(\n        OmniboxPopupModel::BUTTON_FOCUSED);\n    popup_view_->ProvideButtonFocusHint(\n        model()->popup_model()->selected_line());\n    return true;\n  }\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-5220",
        "length": 95
    },
    {
        "index": 158938,
        "code": "int GetBlockForJpeg(void* param,\n                    unsigned long pos,\n                    unsigned char* buf,\n                    unsigned long size) {\n  std::vector<uint8_t>* data_vector = static_cast<std::vector<uint8_t>*>(param);\n  if (pos + size < pos || pos + size > data_vector->size())\n    return 0;\n  memcpy(buf, data_vector->data() + pos, size);\n  return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-6031",
        "length": 94
    },
    {
        "index": 165778,
        "code": "SVGUseElement* SVGElement::CorrespondingUseElement() const {\n  if (ShadowRoot* root = ContainingShadowRoot()) {\n    if (IsSVGUseElement(root->host()))\n      return &ToSVGUseElement(root->host());\n  }\n  return nullptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2019-5757",
        "length": 59
    },
    {
        "index": 188192,
        "code": " bool InputWindowInfo::isTrustedOverlay() const {\n     return layoutParamsType == TYPE_INPUT_METHOD\n             || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n             || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n             || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n }\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-264",
        "cve": "CVE-2016-2496",
        "length": 56
    },
    {
        "index": 36559,
        "code": "static void block_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, flags & ~O_NONBLOCK);\n#else\n\tu_long flags = 0;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-4503",
        "length": 69
    },
    {
        "index": 186295,
        "code": " void WebContentsImpl::FocusThroughTabTraversal(bool reverse) {\n   if (ShowingInterstitialPage()) {\n    GetRenderManager()->interstitial_page()->FocusThroughTabTraversal(reverse);\n     return;\n   }\n   RenderWidgetHostView* const fullscreen_view =\n      GetFullscreenRenderWidgetHostView();\n  if (fullscreen_view) {\n    fullscreen_view->Focus();\n    return;\n  }\n  GetRenderViewHost()->SetInitialFocus(reverse);\n }\n",
        "line": "    GetRenderManager()->interstitial_page()->FocusThroughTabTraversal(reverse);\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 90
    },
    {
        "index": 102853,
        "code": "int RenderMenuList::clientPaddingLeft() const\n{\n    return paddingLeft() + m_innerBlock->paddingLeft();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2830",
        "length": 26
    },
    {
        "index": 37221,
        "code": "static int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage)\n{\n\treturn X86EMUL_CONTINUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-3690",
        "length": 43
    },
    {
        "index": 49811,
        "code": "static void arcmsr_iop_init(struct AdapterControlBlock *acb)\n{\n\tuint32_t intmask_org;\n\t/* disable all outbound interrupt */\n\tintmask_org = arcmsr_disable_outbound_ints(acb);\n\tarcmsr_wait_firmware_ready(acb);\n\tarcmsr_iop_confirm(acb);\n\t/*start background rebuild*/\n\tarcmsr_start_adapter_bgrb(acb);\n\t/* empty doorbell Qbuffer if door bell ringed */\n\tarcmsr_clear_doorbell_queue_buffer(acb);\n\tarcmsr_enable_eoi_mode(acb);\n\t/* enable outbound Post Queue,outbound doorbell Interrupt */\n\tarcmsr_enable_outbound_ints(acb, intmask_org);\n\tacb->acb_flags |= ACB_F_IOP_INITED;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-7425",
        "length": 164
    },
    {
        "index": 27819,
        "code": "void br_multicast_init(struct net_bridge *br)\n{\n\tbr->hash_elasticity = 4;\n\tbr->hash_max = 512;\n\n\tbr->multicast_router = 1;\n\tbr->multicast_last_member_count = 2;\n\tbr->multicast_startup_query_count = 2;\n\n\tbr->multicast_last_member_interval = HZ;\n\tbr->multicast_query_response_interval = 10 * HZ;\n\tbr->multicast_startup_query_interval = 125 * HZ / 4;\n\tbr->multicast_query_interval = 125 * HZ;\n\tbr->multicast_querier_interval = 255 * HZ;\n\tbr->multicast_membership_interval = 260 * HZ;\n\n\tspin_lock_init(&br->multicast_lock);\n\tsetup_timer(&br->multicast_router_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_querier_timer,\n\t\t    br_multicast_local_router_expired, 0);\n\tsetup_timer(&br->multicast_query_timer, br_multicast_query_expired,\n\t\t    (unsigned long)br);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-0716",
        "length": 223
    },
    {
        "index": 10217,
        "code": "  _iup_worker_shift( IUP_Worker  worker,\n                     FT_UInt     p1,\n                     FT_UInt     p2,\n                     FT_UInt     p )\n  {\n    FT_UInt     i;\n    FT_F26Dot6  dx;\n\n\n    dx = worker->curs[p].x - worker->orgs[p].x;\n    if ( dx != 0 )\n    {\n      for ( i = p1; i < p; i++ )\n        worker->curs[i].x += dx;\n\n      for ( i = p + 1; i <= p2; i++ )\n        worker->curs[i].x += dx;\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2010-2520",
        "length": 144
    },
    {
        "index": 85397,
        "code": "static struct page *get_next_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct page *src_page, *dst_page;\n\tpgoff_t src_off, dst_off;\n\tvoid *src_addr, *dst_addr;\n\n\tsrc_off = current_sit_addr(sbi, start);\n\tdst_off = next_sit_addr(sbi, src_off);\n\n\t/* get current sit block page without lock */\n\tsrc_page = get_meta_page(sbi, src_off);\n\tdst_page = grab_meta_page(sbi, dst_off);\n\tf2fs_bug_on(sbi, PageDirty(src_page));\n\n\tsrc_addr = page_address(src_page);\n\tdst_addr = page_address(dst_page);\n\tmemcpy(dst_addr, src_addr, PAGE_SIZE);\n\n\tset_page_dirty(dst_page);\n\tf2fs_put_page(src_page, 1);\n\n\tset_to_next_sit(sit_i, start);\n\n\treturn dst_page;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18241",
        "length": 199
    },
    {
        "index": 131255,
        "code": "static void callWithExecutionContextAnyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());\n    v8SetReturnValue(info, imp->callWithExecutionContextAnyAttribute(scriptContext).v8Value());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 79
    },
    {
        "index": 24623,
        "code": "struct fuse_req *fuse_request_alloc(void)\n{\n\tstruct fuse_req *req = kmem_cache_alloc(fuse_req_cachep, GFP_KERNEL);\n\tif (req)\n\t\tfuse_request_init(req);\n\treturn req;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3353",
        "length": 46
    },
    {
        "index": 95882,
        "code": "void CL_InitServerInfo( serverInfo_t *server, netadr_t *address ) {\n\tserver->adr = *address;\n\tserver->clients = 0;\n\tserver->hostName[0] = '\\0';\n\tserver->mapName[0] = '\\0';\n\tserver->maxClients = 0;\n\tserver->maxPing = 0;\n\tserver->minPing = 0;\n\tserver->ping = -1;\n\tserver->game[0] = '\\0';\n\tserver->gameType = 0;\n\tserver->netType = 0;\n\tserver->g_humanplayers = 0;\n\tserver->g_needpass = 0;\n\tserver->allowAnonymous = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 140
    },
    {
        "index": 151564,
        "code": "void ResourceFetcher::InsertAsPreloadIfNecessary(Resource* resource,\n                                                 const FetchParameters& params,\n                                                 Resource::Type type) {\n  if (!params.IsSpeculativePreload() && !params.IsLinkPreload())\n    return;\n  if (resource->GetResourceError().IsAccessCheck())\n    return;\n  PreloadKey key(params.Url(), type);\n  if (preloads_.find(key) == preloads_.end()) {\n    preloads_.insert(key, resource);\n    resource->MarkAsPreload();\n    if (preloaded_urls_for_test_)\n      preloaded_urls_for_test_->insert(resource->Url().GetString());\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 136
    },
    {
        "index": 3429,
        "code": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    \n    /*\n     * close stdin, so that process will fail to read stdin (process reading\n     * stdin should not be run inside WeeChat!)\n     */\n    close (STDIN_FILENO);\n    \n    /* redirect stdout/stderr to pipe (so that father process can read them) */\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    \n    /* launch command */\n    exec_args[2] = HOOK_PROCESS(hook_process, command);\n    execvp (exec_args[0], exec_args);\n    \n    /* should not be executed if execvp was ok */\n    fprintf (stderr, \"Error with command '%s'\\n\",\n             HOOK_PROCESS(hook_process, command));\n    _exit (EXIT_FAILURE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1428",
        "length": 284
    },
    {
        "index": 4005,
        "code": "void EmbedStream::moveStart(int delta) {\n  error(errInternal, -1, \"Internal: called moveStart() on EmbedStream\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1790",
        "length": 31
    },
    {
        "index": 83729,
        "code": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-8099",
        "length": 70
    },
    {
        "index": 54403,
        "code": "static ZIPARCHIVE_METHOD(getExternalAttributesName)\n{\n\tstruct zip *intern;\n\tzval *self = getThis(), *z_opsys, *z_attr;\n\tsize_t name_len;\n\tchar *name;\n\tzend_long flags=0;\n\tzip_uint8_t opsys;\n\tzip_uint32_t attr;\n\tzip_int64_t idx;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/|l\",\n\t\t\t&name, &name_len, &z_opsys, &z_attr, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (name_len < 1) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as entry name\");\n\t}\n\n\tidx = zip_name_locate(intern, name, 0);\n\tif (idx < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zip_file_get_external_attributes(intern, idx,\n\t\t\t(zip_flags_t)flags, &opsys, &attr) < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tzval_ptr_dtor(z_opsys);\n\tZVAL_LONG(z_opsys, opsys);\n\tzval_ptr_dtor(z_attr);\n\tZVAL_LONG(z_attr, attr);\n\tRETURN_TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-3078",
        "length": 272
    },
    {
        "index": 70289,
        "code": "OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)\n{\n\tuint16 mlen;\n\tuint8* mmem;\n\tuint16 n;\n\tassert(len>0);\n\tmlen=len;\n\tmmem=mem;\n\tdo\n\t{\n\t\tif (sp->in_buffer_togo==0)\n\t\t{\n\t\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\t\treturn(0);\n\t\t\tassert(sp->in_buffer_togo>0);\n\t\t}\n\t\tn=mlen;\n\t\tif (n>sp->in_buffer_togo)\n\t\t\tn=sp->in_buffer_togo;\n\t\t_TIFFmemcpy(mmem,sp->in_buffer_cur,n);\n\t\tsp->in_buffer_cur+=n;\n\t\tsp->in_buffer_togo-=n;\n\t\tmlen-=n;\n\t\tmmem+=n;\n\t} while(mlen>0);\n\treturn(1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2016-10267",
        "length": 188
    },
    {
        "index": 35345,
        "code": "static int ipip_rcv(struct sk_buff *skb)\n{\n\tstruct ip_tunnel *tunnel;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\n\trcu_read_lock();\n\ttunnel = ipip_tunnel_lookup(dev_net(skb->dev), iph->saddr, iph->daddr);\n\tif (tunnel != NULL) {\n\t\tstruct pcpu_tstats *tstats;\n\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tsecpath_reset(skb);\n\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tskb->pkt_type = PACKET_HOST;\n\n\t\ttstats = this_cpu_ptr(tunnel->dev->tstats);\n\t\ttstats->rx_packets++;\n\t\ttstats->rx_bytes += skb->len;\n\n\t\t__skb_tunnel_rx(skb, tunnel->dev);\n\n\t\tipip_ecn_decapsulate(iph, skb);\n\n\t\tnetif_rx(skb);\n\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-1019",
        "length": 254
    },
    {
        "index": 142963,
        "code": "TimeRanges* HTMLMediaElement::played() {\n  if (playing_) {\n    double time = currentTime();\n    if (time > last_seek_time_)\n      AddPlayedRange(last_seek_time_, time);\n  }\n\n  if (!played_time_ranges_)\n    played_time_ranges_ = TimeRanges::Create();\n\n  return played_time_ranges_->Copy();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 71
    },
    {
        "index": 31300,
        "code": "static struct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint match = 0;\n\n\t\tif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\n\t\t\tcontinue;\n\n\t\tif (strlen(p->cru_driver_name))\n\t\t\tmatch = !strcmp(q->cra_driver_name,\n\t\t\t\t\tp->cru_driver_name);\n\t\telse if (!exact)\n\t\t\tmatch = !strcmp(q->cra_name, p->cru_name);\n\n\t\tif (match) {\n\t\t\talg = q;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2013-2548",
        "length": 171
    },
    {
        "index": 177360,
        "code": "void Tags::Tag::Clear() {\n while (m_simple_tags_count > 0) {\n SimpleTag& d = m_simple_tags[--m_simple_tags_count];\n    d.Clear();\n }\n\n delete[] m_simple_tags;\n  m_simple_tags = NULL;\n\n  m_simple_tags_size = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-2464",
        "length": 62
    },
    {
        "index": 165101,
        "code": "FileSystemOperationRunner::FileSystemOperationRunner(\n    FileSystemContext* file_system_context)\n    : file_system_context_(file_system_context), weak_factory_(this) {\n  weak_ptr_ = weak_factory_.GetWeakPtr();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-5788",
        "length": 46
    },
    {
        "index": 17026,
        "code": "void OxideQQuickWebViewPrivate::CloseRequested() {\n  Q_Q(OxideQQuickWebView);\n\n  emit q->closeRequested();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1586",
        "length": 31
    },
    {
        "index": 69007,
        "code": "int FLTIsSimpleFilter(FilterEncodingNode *psNode)\n{\n  if (FLTValidForBBoxFilter(psNode)) {\n    if (FLTNumberOfFilterType(psNode, \"DWithin\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Intersect\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Intersects\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Equals\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Disjoint\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Touches\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Crosses\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Within\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Contains\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Overlaps\") == 0 &&\n        FLTNumberOfFilterType(psNode, \"Beyond\") == 0)\n      return TRUE;\n  }\n\n  return FALSE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5522",
        "length": 211
    },
    {
        "index": 149927,
        "code": "float LayerTreeHostImpl::DeviceSpaceDistanceToLayer(\n    const gfx::PointF& device_viewport_point,\n    LayerImpl* layer_impl) {\n  if (!layer_impl)\n    return std::numeric_limits<float>::max();\n\n  gfx::Rect layer_impl_bounds(layer_impl->bounds());\n\n  gfx::RectF device_viewport_layer_impl_bounds = MathUtil::MapClippedRect(\n      layer_impl->ScreenSpaceTransform(), gfx::RectF(layer_impl_bounds));\n\n  return device_viewport_layer_impl_bounds.ManhattanDistanceToPoint(\n      device_viewport_point);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-5061",
        "length": 116
    },
    {
        "index": 50668,
        "code": "static void srpt_handle_new_iu(struct srpt_rdma_ch *ch,\n\t\t\t       struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t       struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_cmd *srp_cmd;\n\tenum rdma_ch_state ch_state;\n\n\tBUG_ON(!ch);\n\tBUG_ON(!recv_ioctx);\n\n\tib_dma_sync_single_for_cpu(ch->sport->sdev->device,\n\t\t\t\t   recv_ioctx->ioctx.dma, srp_max_req_size,\n\t\t\t\t   DMA_FROM_DEVICE);\n\n\tch_state = srpt_get_ch_state(ch);\n\tif (unlikely(ch_state == CH_CONNECTING)) {\n\t\tlist_add_tail(&recv_ioctx->wait_list, &ch->cmd_wait_list);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(ch_state != CH_LIVE))\n\t\tgoto out;\n\n\tsrp_cmd = recv_ioctx->ioctx.buf;\n\tif (srp_cmd->opcode == SRP_CMD || srp_cmd->opcode == SRP_TSK_MGMT) {\n\t\tif (!send_ioctx)\n\t\t\tsend_ioctx = srpt_get_send_ioctx(ch);\n\t\tif (unlikely(!send_ioctx)) {\n\t\t\tlist_add_tail(&recv_ioctx->wait_list,\n\t\t\t\t      &ch->cmd_wait_list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (srp_cmd->opcode) {\n\tcase SRP_CMD:\n\t\tsrpt_handle_cmd(ch, recv_ioctx, send_ioctx);\n\t\tbreak;\n\tcase SRP_TSK_MGMT:\n\t\tsrpt_handle_tsk_mgmt(ch, recv_ioctx, send_ioctx);\n\t\tbreak;\n\tcase SRP_I_LOGOUT:\n\t\tpr_err(\"Not yet implemented: SRP_I_LOGOUT\\n\");\n\t\tbreak;\n\tcase SRP_CRED_RSP:\n\t\tpr_debug(\"received SRP_CRED_RSP\\n\");\n\t\tbreak;\n\tcase SRP_AER_RSP:\n\t\tpr_debug(\"received SRP_AER_RSP\\n\");\n\t\tbreak;\n\tcase SRP_RSP:\n\t\tpr_err(\"Received SRP_RSP\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"received IU with unknown opcode 0x%x\\n\",\n\t\t       srp_cmd->opcode);\n\t\tbreak;\n\t}\n\n\tsrpt_post_recv(ch->sport->sdev, recv_ioctx);\nout:\n\treturn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-6327",
        "length": 463
    },
    {
        "index": 118705,
        "code": "bool V8Window::indexedSecurityCheckCustom(v8::Local<v8::Object> host, uint32_t index, v8::AccessType type, v8::Local<v8::Value>)\n{\n    v8::Isolate* isolate = v8::Isolate::GetCurrent();\n    v8::Handle<v8::Object> window = host->FindInstanceInPrototypeChain(V8Window::GetTemplate(isolate, worldTypeInMainThread(isolate)));\n    if (window.IsEmpty())\n        return false;\n\n    DOMWindow* targetWindow = V8Window::toNative(window);\n\n    ASSERT(targetWindow);\n\n    Frame* target = targetWindow->frame();\n    if (!target)\n        return false;\n\n    if (target->loader()->stateMachine()->isDisplayingInitialEmptyDocument())\n        target->loader()->didAccessInitialDocument();\n\n    Frame* childFrame =  target->tree().scopedChild(index);\n\n    if (type == v8::ACCESS_HAS && childFrame)\n        return true;\n    if (type == v8::ACCESS_GET\n        && childFrame\n        && !host->HasRealIndexedProperty(index)\n        && !window->HasRealIndexedProperty(index))\n        return true;\n\n    return BindingSecurity::shouldAllowAccessToFrame(target, DoNotReportSecurityError);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-6624",
        "length": 262
    },
    {
        "index": 161186,
        "code": "  std::string MakeMediaAccessRequest(int index) {\n    const int render_process_id = 1;\n    const int render_frame_id = 1;\n    const int page_request_id = 1;\n    const url::Origin security_origin;\n    MediaStreamManager::MediaAccessRequestCallback callback =\n        base::BindOnce(&MediaStreamManagerTest::ResponseCallback,\n                       base::Unretained(this), index);\n    StreamControls controls(true, true);\n    return media_stream_manager_->MakeMediaAccessRequest(\n        render_process_id, render_frame_id, page_request_id, controls,\n        security_origin, std::move(callback));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6103",
        "length": 131
    },
    {
        "index": 6749,
        "code": " static void ide_nop_restart(void *opaque, int x, RunState y)\n {\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-9718",
        "length": 20
    },
    {
        "index": 112981,
        "code": "void DownloadFileManager::CancelDownload(DownloadId global_id) {\n  VLOG(20) << __FUNCTION__ << \"()\" << \" id = \" << global_id;\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n  DownloadFileMap::iterator it = downloads_.find(global_id);\n  if (it == downloads_.end())\n    return;\n\n  DownloadFile* download_file = it->second;\n  VLOG(20) << __FUNCTION__ << \"()\"\n           << \" download_file = \" << download_file->DebugString();\n  download_file->Cancel();\n\n   EraseDownload(global_id);\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2895",
        "length": 128
    },
    {
        "index": 128224,
        "code": "void FrameView::calculateScrollbarModesForLayoutAndSetViewportRenderer(ScrollbarMode& hMode, ScrollbarMode& vMode, ScrollbarModesCalculationStrategy strategy)\n{\n    m_viewportRenderer = 0;\n\n    const HTMLFrameOwnerElement* owner = m_frame->deprecatedLocalOwner();\n    if (owner && (owner->scrollingMode() == ScrollbarAlwaysOff)) {\n        hMode = ScrollbarAlwaysOff;\n        vMode = ScrollbarAlwaysOff;\n        return;\n    }\n\n    if (m_canHaveScrollbars || strategy == RulesFromWebContentOnly) {\n        hMode = ScrollbarAuto;\n        vMode = ScrollbarAuto;\n    } else {\n        hMode = ScrollbarAlwaysOff;\n        vMode = ScrollbarAlwaysOff;\n    }\n\n    if (!isSubtreeLayout()) {\n        Document* document = m_frame->document();\n        Node* body = document->body();\n        if (isHTMLFrameSetElement(body) && body->renderer()) {\n            vMode = ScrollbarAlwaysOff;\n            hMode = ScrollbarAlwaysOff;\n        } else if (Element* viewportElement = document->viewportDefiningElement()) {\n            if (RenderObject* viewportRenderer = viewportElement->renderer()) {\n                if (viewportRenderer->style())\n                    applyOverflowToViewportAndSetRenderer(viewportRenderer, hMode, vMode);\n            }\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-3191",
        "length": 290
    },
    {
        "index": 20183,
        "code": "int sock_no_mmap(struct file *file, struct socket *sock, struct vm_area_struct *vma)\n{\n\t/* Mirror missing mmap method error code */\n\treturn -ENODEV;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-2136",
        "length": 40
    },
    {
        "index": 52983,
        "code": "static int ui_release(struct inode *inode, struct file *filp)\n{\n\t/* nothing to do */\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-4565",
        "length": 28
    },
    {
        "index": 178621,
        "code": "static void nbd_recv_coroutines_enter_all(NBDClientSession *s)\n {\n     int i;\n \n     for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n            qemu_coroutine_enter(s->recv_coroutine[i]);\n             qemu_coroutine_enter(s->recv_coroutine[i]);\n         }\n     }\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-7539",
        "length": 70
    },
    {
        "index": 81601,
        "code": "static int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 42
    },
    {
        "index": 50468,
        "code": "perf_event_aux(perf_event_aux_output_cb output, void *data,\n\t       struct perf_event_context *task_ctx)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_aux_ctx(&cpuctx->ctx, output, data);\n\t\tif (task_ctx)\n\t\t\tgoto next;\n\t\tctxn = pmu->task_ctx_nr;\n\t\tif (ctxn < 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\tif (ctx)\n\t\t\tperf_event_aux_ctx(ctx, output, data);\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\n\tif (task_ctx) {\n\t\tpreempt_disable();\n\t\tperf_event_aux_ctx(task_ctx, output, data);\n\t\tpreempt_enable();\n\t}\n\trcu_read_unlock();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-6787",
        "length": 247
    },
    {
        "index": 132600,
        "code": "void WebKitTestResultPrinter::PrintTextBlock(const std::string& block) {\n  if (state_ != IN_TEXT_BLOCK)\n    return;\n  *output_ << block;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 40
    },
    {
        "index": 24761,
        "code": "static inline struct page *alloc_slab_page(gfp_t flags, int node,\n\t\t\t\t\tstruct kmem_cache_order_objects oo)\n{\n\tint order = oo_order(oo);\n\n\tif (node == -1)\n\t\treturn alloc_pages(flags, order);\n\telse\n\t\treturn alloc_pages_node(node, flags, order);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-3209",
        "length": 65
    },
    {
        "index": 48558,
        "code": "struct ion_handle *ion_import_dma_buf_fd(struct ion_client *client, int fd)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct ion_handle *handle;\n\n\tdmabuf = dma_buf_get(fd);\n\tif (IS_ERR(dmabuf))\n\t\treturn ERR_CAST(dmabuf);\n\n\thandle = ion_import_dma_buf(client, dmabuf);\n\tdma_buf_put(dmabuf);\n\treturn handle;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-9120",
        "length": 84
    },
    {
        "index": 52248,
        "code": "static inline void compat_release_entry(struct compat_arpt_entry *e)\n{\n\tstruct xt_entry_target *t;\n\n\tt = compat_arpt_get_target(e);\n\tmodule_put(t->u.kernel.target->me);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4998",
        "length": 43
    },
    {
        "index": 65577,
        "code": "static void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 153
    },
    {
        "index": 173116,
        "code": "sRGB(double linear /*range 0.0 .. 1.0*/)\n{\n return u8d(255 * sRGB_from_linear(linear));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 33
    },
    {
        "index": 98479,
        "code": "bool AeroPeekManager::GetTabThumbnail(int tab_id, SkBitmap* thumbnail) {\n  DCHECK(thumbnail);\n\n  TabContents* contents = GetTabContents(tab_id);\n  if (!contents)\n    return false;\n\n  ThumbnailGenerator* generator = g_browser_process->GetThumbnailGenerator();\n  DCHECK(generator);\n  *thumbnail = generator->GetThumbnailForRenderer(contents->render_view_host());\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 85
    },
    {
        "index": 10474,
        "code": "static void megasas_scsi_reset(DeviceState *dev)\n{\n    MegasasState *s = MEGASAS(dev);\n\n    megasas_soft_reset(s);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-5337",
        "length": 38
    },
    {
        "index": 136813,
        "code": "BarProp* LocalDOMWindow::menubar() const {\n  if (!menubar_)\n    menubar_ = BarProp::Create(GetFrame(), BarProp::kMenubar);\n  return menubar_.Get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 46
    },
    {
        "index": 122523,
        "code": "void InspectorClientImpl::hideHighlight()\n{\n    if (WebDevToolsAgentImpl* agent = devToolsAgent())\n        agent->hideHighlight();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0884",
        "length": 32
    },
    {
        "index": 83571,
        "code": "POINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-8786",
        "length": 108
    },
    {
        "index": 109448,
        "code": "void FileReaderLoader::setRange(unsigned start, unsigned length)\n{\n    ASSERT(length > 0);\n    m_hasRange = true;\n    m_rangeStart = start;\n    m_rangeEnd = start + length - 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5131",
        "length": 48
    },
    {
        "index": 83182,
        "code": "mrb_gc_arena_shrink(mrb_state *mrb, int idx)\n{\n  mrb_gc *gc = &mrb->gc;\n  int capa = gc->arena_capa;\n\n  if (idx < capa / 4) {\n    capa >>= 2;\n    if (capa < MRB_GC_ARENA_SIZE) {\n      capa = MRB_GC_ARENA_SIZE;\n    }\n    if (capa != gc->arena_capa) {\n      gc->arena = (struct RBasic**)mrb_realloc(mrb, gc->arena, sizeof(struct RBasic*)*capa);\n      gc->arena_capa = capa;\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-10191",
        "length": 148
    },
    {
        "index": 144914,
        "code": "gfx::Size RenderWidgetHostViewAura::GetRequestedRendererSize() const {\n  return delegated_frame_host_\n             ? delegated_frame_host_->GetRequestedRendererSize()\n             : RenderWidgetHostViewBase::GetRequestedRendererSize();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-1615",
        "length": 48
    },
    {
        "index": 34961,
        "code": "rpc_init_mempool(void)\n{\n\t/*\n\t * The following is not strictly a mempool initialisation,\n\t * but there is no harm in doing it here\n\t */\n\trpc_init_wait_queue(&delay_queue, \"delayq\");\n\tif (!rpciod_start())\n\t\tgoto err_nomem;\n\n\trpc_task_slabp = kmem_cache_create(\"rpc_tasks\",\n\t\t\t\t\t     sizeof(struct rpc_task),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (!rpc_task_slabp)\n\t\tgoto err_nomem;\n\trpc_buffer_slabp = kmem_cache_create(\"rpc_buffers\",\n\t\t\t\t\t     RPC_BUFFER_MAXSIZE,\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (!rpc_buffer_slabp)\n\t\tgoto err_nomem;\n\trpc_task_mempool = mempool_create_slab_pool(RPC_TASK_POOLSIZE,\n\t\t\t\t\t\t    rpc_task_slabp);\n\tif (!rpc_task_mempool)\n\t\tgoto err_nomem;\n\trpc_buffer_mempool = mempool_create_slab_pool(RPC_BUFFER_POOLSIZE,\n\t\t\t\t\t\t      rpc_buffer_slabp);\n\tif (!rpc_buffer_mempool)\n\t\tgoto err_nomem;\n\treturn 0;\nerr_nomem:\n\trpc_destroy_mempool();\n\treturn -ENOMEM;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2491",
        "length": 262
    },
    {
        "index": 83423,
        "code": "UpdateWaitHandles(LPHANDLE *handles_ptr, LPDWORD count,\n                  HANDLE io_event, HANDLE exit_event, list_item_t *threads)\n{\n    static DWORD size = 10;\n    static LPHANDLE handles = NULL;\n    DWORD pos = 0;\n\n    if (handles == NULL)\n    {\n        handles = malloc(size * sizeof(HANDLE));\n        *handles_ptr = handles;\n        if (handles == NULL)\n        {\n            return ERROR_OUTOFMEMORY;\n        }\n    }\n\n    handles[pos++] = io_event;\n\n    if (!threads)\n    {\n        handles[pos++] = exit_event;\n    }\n\n    while (threads)\n    {\n        if (pos == size)\n        {\n            LPHANDLE tmp;\n            size += 10;\n            tmp = realloc(handles, size * sizeof(HANDLE));\n            if (tmp == NULL)\n            {\n                size -= 10;\n                *count = pos;\n                return ERROR_OUTOFMEMORY;\n            }\n            handles = tmp;\n            *handles_ptr = handles;\n        }\n        handles[pos++] = threads->data;\n        threads = threads->next;\n    }\n\n    *count = pos;\n    return NO_ERROR;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-9336",
        "length": 240
    },
    {
        "index": 152580,
        "code": "  typename T::Param ProcessAndReadIPC() {\n    base::RunLoop().RunUntilIdle();\n    const IPC::Message* message =\n        render_thread_->sink().GetUniqueMessageMatching(T::ID);\n    typename T::Param param;\n    EXPECT_TRUE(message);\n    if (message)\n      T::Read(message, &param);\n    return param;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5019",
        "length": 75
    },
    {
        "index": 88202,
        "code": "XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {\n  XML_Char tmp[2];\n  *tmp = nsSep;\n  return XML_ParserCreate_MM(encodingName, NULL, tmp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-611",
        "cve": "CVE-2019-15903",
        "length": 48
    },
    {
        "index": 184846,
        "code": "void V8WindowShell::namedItemRemoved(HTMLDocument* document, const AtomicString& name)\n{\n    ASSERT(m_world->isMainWorld());\n\n     if (m_context.isEmpty())\n         return;\n \n    if (document->hasNamedItem(name.impl()) || document->hasExtraNamedItem(name.impl()))\n         return;\n \n     v8::HandleScope handleScope(m_isolate);\n    v8::Context::Scope contextScope(m_context.newLocal(m_isolate));\n\n    ASSERT(!m_document.isEmpty());\n    v8::Handle<v8::Object> documentHandle = m_document.newLocal(m_isolate);\n    checkDocumentWrapper(documentHandle, document);\n    documentHandle->Delete(v8String(name, m_isolate));\n}\n",
        "line": "    if (document->hasNamedItem(name.impl()) || document->hasExtraNamedItem(name.impl()))\n",
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2013-6624",
        "length": 149
    },
    {
        "index": 31048,
        "code": "static int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2635",
        "length": 103
    },
    {
        "index": 106458,
        "code": "PassRefPtr<WebPageProxy> WebPageProxy::create(PageClient* pageClient, WebContext* context, WebPageGroup* pageGroup, uint64_t pageID)\n{\n    return adoptRef(new WebPageProxy(pageClient, context, pageGroup, pageID));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 58
    },
    {
        "index": 156538,
        "code": "GURL ChildProcessSecurityPolicyImpl::GetOriginLock(int child_id) {\n  base::AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(child_id);\n  if (state == security_state_.end())\n    return GURL();\n  return state->second->origin_lock();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-18345",
        "length": 64
    },
    {
        "index": 145562,
        "code": "ProtocolVersion ConvertStringToProtocolVersion(base::StringPiece version) {\n  if (version == kCtap2Version)\n    return ProtocolVersion::kCtap;\n  if (version == kU2fVersion)\n    return ProtocolVersion::kU2f;\n\n  return ProtocolVersion::kUnknown;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2016-1671",
        "length": 65
    },
    {
        "index": 161266,
        "code": "gfx::PointF CssPixelsToPointF(double x, double y, float page_scale_factor) {\n  return gfx::PointF(x * page_scale_factor, y * page_scale_factor);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6111",
        "length": 38
    },
    {
        "index": 20012,
        "code": "static int nfs4_recover_expired_lease(struct nfs_server *server)\n{\n\treturn nfs4_client_recover_expired_lease(server->nfs_client);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 33
    },
    {
        "index": 14412,
        "code": "session_destroy_all(void (*closefunc)(Session *))\n{\n\tint i;\n\tfor (i = 0; i < sessions_nalloc; i++) {\n\t\tSession *s = &sessions[i];\n\t\tif (s->used) {\n\t\t\tif (closefunc != NULL)\n\t\t\t\tclosefunc(s);\n\t\t\telse\n\t\t\t\tsession_close(s);\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-8325",
        "length": 76
    },
    {
        "index": 162978,
        "code": "QuicStreamOffset QuicStreamSequencerBuffer::BytesConsumed() const {\n  return total_bytes_read_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2017-15407",
        "length": 26
    },
    {
        "index": 147390,
        "code": "void V8TestObject::EventHandlerAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_eventHandlerAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::EventHandlerAttributeAttributeSetter(v8_value, info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 90
    },
    {
        "index": 10183,
        "code": "  Ins_SSWCI( INS_ARG )\n  {\n    DO_SSWCI\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2010-2520",
        "length": 20
    },
    {
        "index": 161351,
        "code": "DispatchResponse NetworkHandler::SetRequestInterception(\n    std::unique_ptr<protocol::Array<protocol::Network::RequestPattern>>\n        patterns) {\n  WebContents* web_contents = WebContents::FromRenderFrameHost(host_);\n  if (!web_contents)\n    return Response::InternalError();\n\n  DevToolsInterceptorController* interceptor =\n      DevToolsInterceptorController::FromBrowserContext(\n          web_contents->GetBrowserContext());\n  if (!interceptor)\n    return Response::Error(\"Interception not supported\");\n\n  if (!patterns->length()) {\n    interception_handle_.reset();\n    return Response::OK();\n  }\n\n  std::vector<DevToolsURLRequestInterceptor::Pattern> interceptor_patterns;\n  for (size_t i = 0; i < patterns->length(); ++i) {\n    base::flat_set<ResourceType> resource_types;\n    std::string resource_type = patterns->get(i)->GetResourceType(\"\");\n    if (!resource_type.empty()) {\n      if (!AddInterceptedResourceType(resource_type, &resource_types)) {\n        return Response::InvalidParams(base::StringPrintf(\n            \"Cannot intercept resources of type '%s'\", resource_type.c_str()));\n      }\n    }\n    interceptor_patterns.push_back(DevToolsURLRequestInterceptor::Pattern(\n        patterns->get(i)->GetUrlPattern(\"*\"), std::move(resource_types),\n        ToInterceptorStage(patterns->get(i)->GetInterceptionStage(\n            protocol::Network::InterceptionStageEnum::Request))));\n  }\n\n  if (interception_handle_) {\n    interception_handle_->UpdatePatterns(std::move(interceptor_patterns));\n  } else {\n    interception_handle_ = interceptor->StartInterceptingRequests(\n        host_->frame_tree_node(), std::move(interceptor_patterns),\n        base::Bind(&NetworkHandler::RequestIntercepted,\n                   weak_factory_.GetWeakPtr()));\n  }\n\n  return Response::OK();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6111",
        "length": 384
    },
    {
        "index": 172072,
        "code": "int btsock_thread_create(btsock_signaled_cb callback, btsock_cmd_cb cmd_callback)\n{\n    asrt(callback || cmd_callback);\n    pthread_mutex_lock(&thread_slot_lock);\n int h = alloc_thread_slot();\n    pthread_mutex_unlock(&thread_slot_lock);\n    APPL_TRACE_DEBUG(\"alloc_thread_slot ret:%d\", h);\n if(h >= 0)\n {\n        init_poll(h);\n pthread_t thread;\n int status = create_thread(sock_poll_thread, (void*)(uintptr_t)h, &thread);\n if (status)\n {\n            APPL_TRACE_ERROR(\"create_thread failed: %s\", strerror(status));\n            free_thread_slot(h);\n return -1;\n }\n\n        ts[h].thread_id = thread;\n        APPL_TRACE_DEBUG(\"h:%d, thread id:%d\", h, ts[h].thread_id);\n        ts[h].callback = callback;\n        ts[h].cmd_callback = cmd_callback;\n }\n return h;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3839",
        "length": 192
    },
    {
        "index": 138305,
        "code": "void AXTableCell::rowIndexRange(std::pair<unsigned, unsigned>& rowRange) {\n  if (!m_layoutObject || !m_layoutObject->isTableCell())\n    return;\n\n  LayoutTableCell* layoutCell = toLayoutTableCell(m_layoutObject);\n  rowRange.first = layoutCell->rowIndex();\n  rowRange.second = layoutCell->rowSpan();\n\n  LayoutTableSection* section = layoutCell->section();\n  LayoutTable* table = layoutCell->table();\n  if (!table || !section)\n    return;\n\n  LayoutTableSection* tableSection = table->topSection();\n  unsigned rowOffset = 0;\n  while (tableSection) {\n    if (tableSection == section)\n      break;\n    rowOffset += tableSection->numRows();\n    tableSection = table->sectionBelow(tableSection, SkipEmptySections);\n  }\n\n  rowRange.first += rowOffset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 182
    },
    {
        "index": 22780,
        "code": "static inline void nfs4_init_once(struct nfs_inode *nfsi)\n{\n#ifdef CONFIG_NFS_V4\n\tINIT_LIST_HEAD(&nfsi->open_states);\n\tnfsi->delegation = NULL;\n\tnfsi->delegation_state = 0;\n\tinit_rwsem(&nfsi->rwsem);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4324",
        "length": 70
    },
    {
        "index": 137917,
        "code": "void AXLayoutObject::ariaLabelledbyElements(AXObjectVector& labelledby) const {\n  accessibilityChildrenFromAttribute(aria_labelledbyAttr, labelledby);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 37
    },
    {
        "index": 1440,
        "code": "ct_build_group(const struct nf_conntrack *ct, int a, struct nethdr *n, \n\t      int b, int size)\n{\n\tvoid *ptr = put_header(n, b, size);\n\tnfct_get_attr_grp(ct, a, ptr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2015-6496",
        "length": 56
    },
    {
        "index": 48635,
        "code": "h2_session *h2_session_create(conn_rec *c, h2_ctx *ctx, h2_workers *workers)\n{\n    return h2_session_create_int(c, NULL, ctx, workers);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-8740",
        "length": 43
    },
    {
        "index": 51526,
        "code": "static struct sk_buff *tcp_collapse_one(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\tstruct sk_buff_head *list)\n{\n\tstruct sk_buff *next = NULL;\n\n\tif (!skb_queue_is_last(list, skb))\n\t\tnext = skb_queue_next(list, skb);\n\n\t__skb_unlink(skb, list);\n\t__kfree_skb(skb);\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVCOLLAPSED);\n\n\treturn next;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-5696",
        "length": 97
    },
    {
        "index": 117686,
        "code": "void InProcessBrowserTest::PrepareTestCommandLine(CommandLine* command_line) {\n  test_launcher_utils::PrepareBrowserCommandLineForTests(command_line);\n\n  if (dom_automation_enabled_)\n    command_line->AppendSwitch(switches::kDomAutomationController);\n\n  command_line->AppendSwitchASCII(switches::kTestType, kBrowserTestType);\n\n#if defined(OS_WIN)\n  command_line->AppendSwitchPath(switches::kBrowserSubprocessPath,\n                                 command_line->GetProgram());\n#else\n  FilePath subprocess_path;\n  PathService::Get(base::FILE_EXE, &subprocess_path);\n#if defined(OS_MACOSX)\n  subprocess_path = subprocess_path.DirName().DirName();\n  DCHECK_EQ(subprocess_path.BaseName().value(), \"Contents\");\n  subprocess_path =\n      subprocess_path.Append(\"Versions\").Append(chrome::kChromeVersion);\n  subprocess_path =\n      subprocess_path.Append(chrome::kHelperProcessExecutablePath);\n#endif\n  command_line->AppendSwitchPath(switches::kBrowserSubprocessPath,\n                                 subprocess_path);\n#endif\n\n  if (!tab_closeable_state_watcher_enabled_)\n    command_line->AppendSwitch(switches::kDisableTabCloseableStateWatcher);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3053",
        "length": 249
    },
    {
        "index": 34487,
        "code": "static noinline int commit_fs_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *gang[8];\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint i;\n\tint ret;\n\tint err = 0;\n\n\tspin_lock(&fs_info->fs_roots_radix_lock);\n\twhile (1) {\n\t\tret = radix_tree_gang_lookup_tag(&fs_info->fs_roots_radix,\n\t\t\t\t\t\t (void **)gang, 0,\n\t\t\t\t\t\t ARRAY_SIZE(gang),\n\t\t\t\t\t\t BTRFS_ROOT_TRANS_TAG);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\troot = gang[i];\n\t\t\tradix_tree_tag_clear(&fs_info->fs_roots_radix,\n\t\t\t\t\t(unsigned long)root->root_key.objectid,\n\t\t\t\t\tBTRFS_ROOT_TRANS_TAG);\n\t\t\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\n\t\t\tbtrfs_free_log(trans, root);\n\t\t\tbtrfs_update_reloc_root(trans, root);\n\t\t\tbtrfs_orphan_commit_root(trans, root);\n\n\t\t\tbtrfs_save_ino_cache(root, trans);\n\n\t\t\t/* see comments in should_cow_block() */\n\t\t\troot->force_cow = 0;\n\t\t\tsmp_wmb();\n\n\t\t\tif (root->commit_root != root->node) {\n\t\t\t\tmutex_lock(&root->fs_commit_mutex);\n\t\t\t\tswitch_commit_root(root);\n\t\t\t\tbtrfs_unpin_free_ino(root);\n\t\t\t\tmutex_unlock(&root->fs_commit_mutex);\n\n\t\t\t\tbtrfs_set_root_node(&root->root_item,\n\t\t\t\t\t\t    root->node);\n\t\t\t}\n\n\t\t\terr = btrfs_update_root(trans, fs_info->tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\t&root->root_item);\n\t\t\tspin_lock(&fs_info->fs_roots_radix_lock);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->fs_roots_radix_lock);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2012-5375",
        "length": 418
    },
    {
        "index": 149359,
        "code": "void BinaryUploadService::ResetAuthorizationData() {\n  can_upload_data_ = base::nullopt;\n\n  IsAuthorized(base::DoNothing());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5089",
        "length": 32
    },
    {
        "index": 14977,
        "code": "ProcFreePixmap(ClientPtr client)\n{\n    PixmapPtr pMap;\n    int rc;\n\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n\n    rc = dixLookupResourceByType((void **) &pMap, stuff->id, RT_PIXMAP,\n                                 client, DixDestroyAccess);\n    if (rc == Success) {\n        FreeResource(stuff->id, RT_NONE);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->id;\n        return rc;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2015-3418",
        "length": 110
    },
    {
        "index": 103909,
        "code": "void RenderView::postAccessibilityNotification(\n    const WebAccessibilityObject& obj,\n    WebAccessibilityNotification notification) {\n  if (!accessibility_.get() && webview()) {\n    if (notification != WebKit::WebAccessibilityNotificationLoadComplete)\n      return;\n\n    accessibility_.reset(WebAccessibilityCache::create());\n    accessibility_->initialize(webview());\n  }\n\n  if (!accessibility_->isCached(obj)) {\n    WebAccessibilityObject parent = obj;\n    while (parent.isValid() && !accessibility_->isCached(parent))\n      parent = parent.parentObject();\n\n    DCHECK(parent.isValid() && accessibility_->isCached(parent));\n    if (!parent.isValid())\n      return;\n    postAccessibilityNotification(\n        parent, WebKit::WebAccessibilityNotificationChildrenChanged);\n\n    if (notification == WebKit::WebAccessibilityNotificationChildrenChanged)\n      return;\n  }\n\n  RendererAccessibilityNotification acc_notification;\n  acc_notification.id = accessibility_->addOrGetId(obj);\n  acc_notification.type = notification;\n  if (acc_notification.id < 0)\n    return;\n\n  ViewHostMsg_AccessibilityNotification_Type::Value temp;\n  if (!WebAccessibilityNotificationToViewHostMsg(notification, &temp))\n    return;\n\n  for (uint32 i = 0; i < pending_accessibility_notifications_.size(); i++) {\n    if (pending_accessibility_notifications_[i].id == acc_notification.id &&\n        pending_accessibility_notifications_[i].type == acc_notification.type) {\n      return;\n    }\n  }\n  pending_accessibility_notifications_.push_back(acc_notification);\n\n  if (!accessibility_ack_pending_ && accessibility_method_factory_.empty()) {\n    MessageLoop::current()->PostTask(\n        FROM_HERE,\n        accessibility_method_factory_.NewRunnableMethod(\n            &RenderView::SendPendingAccessibilityNotifications));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 364
    },
    {
        "index": 58391,
        "code": "static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->active_mm;\n\n\t/*\n\t * If we are in kernel mode at this point, we have no context to\n\t * handle this fault with.\n\t */\n\tif (user_mode(regs))\n\t\t__do_user_fault(tsk, addr, esr, SIGSEGV, SEGV_MAPERR, regs);\n\telse\n\t\t__do_kernel_fault(mm, addr, esr, regs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2014-9803",
        "length": 122
    },
    {
        "index": 175826,
        "code": "static int get_free_fb (VP8_COMMON *cm)\n{\n int i;\n for (i = 0; i < NUM_YV12_BUFFERS; i++)\n if (cm->fb_idx_ref_cnt[i] == 0)\n break;\n\n    assert(i < NUM_YV12_BUFFERS);\n    cm->fb_idx_ref_cnt[i] = 1;\n return i;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-0393",
        "length": 79
    },
    {
        "index": 80594,
        "code": "GF_Box *trgr_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupBox, GF_ISOM_BOX_TYPE_TRGR);\n\ttmp->groups = gf_list_new();\n\tif (!tmp->groups) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 64
    },
    {
        "index": 32423,
        "code": "vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tbr_write_lock(&vfsmount_lock);\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tbr_write_unlock(&vfsmount_lock);\n\treturn &mnt->mnt;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-1957",
        "length": 219
    },
    {
        "index": 32223,
        "code": "void skb_gro_reset_offset(struct sk_buff *skb)\n{\n\tNAPI_GRO_CB(skb)->data_offset = 0;\n\tNAPI_GRO_CB(skb)->frag0 = NULL;\n\tNAPI_GRO_CB(skb)->frag0_len = 0;\n\n\tif (skb->mac_header == skb->tail &&\n\t    !PageHighMem(skb_shinfo(skb)->frags[0].page)) {\n\t\tNAPI_GRO_CB(skb)->frag0 =\n\t\t\tpage_address(skb_shinfo(skb)->frags[0].page) +\n\t\t\tskb_shinfo(skb)->frags[0].page_offset;\n\t\tNAPI_GRO_CB(skb)->frag0_len = skb_shinfo(skb)->frags[0].size;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2017",
        "length": 151
    },
    {
        "index": 186116,
        "code": "bool ComponentControllerImpl::BindToRequest(\n    fuchsia::sys::Package package,\n    fuchsia::sys::StartupInfo startup_info,\n    fidl::InterfaceRequest<fuchsia::sys::ComponentController>\n        controller_request) {\n  DCHECK(!service_directory_);\n  DCHECK(!view_provider_binding_);\n\n  url_ = GURL(*package.resolved_url);\n  if (!url_.is_valid()) {\n    LOG(ERROR) << \"Rejected invalid URL: \" << url_;\n    return false;\n  }\n\n  if (controller_request.is_valid()) {\n    controller_binding_.Bind(std::move(controller_request));\n    controller_binding_.set_error_handler(\n         fit::bind_member(this, &ComponentControllerImpl::Kill));\n   }\n \n  runner_->context()->CreateFrame(frame_observer_binding_.NewBinding(),\n                                  frame_.NewRequest());\n   frame_->GetNavigationController(navigation_controller_.NewRequest());\n   navigation_controller_->LoadUrl(url_.spec(), nullptr);\n \n  service_directory_ = std::make_unique<base::fuchsia::ServiceDirectory>(\n      std::move(startup_info.launch_info.directory_request));\n  view_provider_binding_ = std::make_unique<\n      base::fuchsia::ScopedServiceBinding<fuchsia::ui::viewsv1::ViewProvider>>(\n      service_directory_.get(), this);\n\n  return true;\n}\n",
        "line": "  runner_->context()->CreateFrame(frame_observer_binding_.NewBinding(),\n                                  frame_.NewRequest());\n",
        "label": 1,
        "cwe": "CWE-264",
        "cve": "CVE-2016-1636",
        "length": 268
    },
    {
        "index": 159089,
        "code": "void DownloadItemImpl::AutoResumeIfValid() {\n  DVLOG(20) << __func__ << \"() \" << DebugString(true);\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  ResumeMode mode = GetResumeMode();\n\n  if (mode != RESUME_MODE_IMMEDIATE_RESTART &&\n      mode != RESUME_MODE_IMMEDIATE_CONTINUE) {\n    return;\n  }\n\n  auto_resume_count_++;\n\n  ResumeInterruptedDownload(ResumptionRequestSource::AUTOMATIC);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6033",
        "length": 100
    },
    {
        "index": 132187,
        "code": "blink::WebPlugin* RenderFrameImpl::CreatePlugin(\n    blink::WebFrame* frame,\n    const WebPluginInfo& info,\n    const blink::WebPluginParams& params,\n    scoped_ptr<content::PluginInstanceThrottler> throttler) {\n  DCHECK_EQ(frame_, frame);\n#if defined(ENABLE_PLUGINS)\n  if (info.type == WebPluginInfo::PLUGIN_TYPE_BROWSER_PLUGIN) {\n    return BrowserPluginManager::Get()->CreateBrowserPlugin(\n        this, GetContentClient()\n                  ->renderer()\n                  ->CreateBrowserPluginDelegate(this, params.mimeType.utf8(),\n                                                GURL(params.url))\n                  ->GetWeakPtr());\n  }\n\n  bool pepper_plugin_was_registered = false;\n  scoped_refptr<PluginModule> pepper_module(PluginModule::Create(\n      this, info, &pepper_plugin_was_registered));\n  if (pepper_plugin_was_registered) {\n    if (pepper_module.get()) {\n      return new PepperWebPluginImpl(\n          pepper_module.get(), params, this,\n          make_scoped_ptr(\n              static_cast<PluginInstanceThrottlerImpl*>(throttler.release())));\n    }\n  }\n#if defined(OS_CHROMEOS)\n  LOG(WARNING) << \"Pepper module/plugin creation failed.\";\n#else\n  if (info.type == WebPluginInfo::PLUGIN_TYPE_NPAPI) {\n    return new WebPluginImpl(frame, params, info.path, render_view_, this);\n  }\n#endif\n#endif\n  return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 302
    },
    {
        "index": 137263,
        "code": "void Textfield::OnMouseReleased(const ui::MouseEvent& event) {\n  selection_controller_.OnMouseReleased(event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 26
    },
    {
        "index": 142599,
        "code": "bool TabHelper::CanCreateBookmarkApp() const {\n  return !profile_->IsGuestSession() &&\n         !profile_->IsSystemProfile() &&\n         IsValidBookmarkAppUrl(web_contents()->GetURL());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 43
    },
    {
        "index": 64673,
        "code": "onig_number_of_captures(regex_t* reg)\n{\n  return reg->num_mem;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-9229",
        "length": 22
    },
    {
        "index": 162598,
        "code": "static void FillIQMatrix(const JpegQuantizationTable* q_table,\n                         VAIQMatrixBufferJPEGBaseline* iq_matrix) {\n  static_assert(kJpegMaxQuantizationTableNum ==\n                    std::extent<decltype(iq_matrix->load_quantiser_table)>(),\n                \"max number of quantization table mismatched\");\n  static_assert(\n      sizeof(iq_matrix->quantiser_table[0]) == sizeof(q_table[0].value),\n      \"number of quantization entries mismatched\");\n  for (size_t i = 0; i < kJpegMaxQuantizationTableNum; i++) {\n    if (!q_table[i].valid)\n      continue;\n    iq_matrix->load_quantiser_table[i] = 1;\n    for (size_t j = 0; j < base::size(q_table[i].value); j++)\n      iq_matrix->quantiser_table[i][j] = q_table[i].value[j];\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2018-6070",
        "length": 199
    },
    {
        "index": 131867,
        "code": "static void voidMethodArrayStringArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::voidMethodArrayStringArgMethod(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 73
    },
    {
        "index": 85232,
        "code": "static void perf_remove_from_context(struct perf_event *event, unsigned long flags)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tevent_function_call(event, __perf_remove_from_context, (void *)flags);\n\n\t/*\n\t * The above event_function_call() can NO-OP when it hits\n\t * TASK_TOMBSTONE. In that case we must already have been detached\n\t * from the context (by perf_event_exit_event()) but the grouping\n\t * might still be in-tact.\n\t */\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tif ((flags & DETACH_GROUP) &&\n\t    (event->attach_state & PERF_ATTACH_GROUP)) {\n\t\t/*\n\t\t * Since in that case we cannot possibly be scheduled, simply\n\t\t * detach now.\n\t\t */\n\t\traw_spin_lock_irq(&ctx->lock);\n\t\tperf_group_detach(event);\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-18255",
        "length": 205
    },
    {
        "index": 1162,
        "code": "void JBIG2Bitmap::clearToOne() {\n  memset(data, 0xff, h * line);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 24
    },
    {
        "index": 41194,
        "code": "static void tcp_remove_reno_sacks(struct sock *sk, int acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (acked > 0) {\n\t\t/* One ACK acked hole. The rest eat duplicate ACKs. */\n\t\tif (acked - 1 >= tp->sacked_out)\n\t\t\ttp->sacked_out = 0;\n\t\telse\n\t\t\ttp->sacked_out -= acked - 1;\n\t}\n\ttcp_check_reno_reordering(sk, acked);\n\ttcp_verify_left_out(tp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-6638",
        "length": 116
    },
    {
        "index": 41962,
        "code": "static int _vivid_fb_check_var(struct fb_var_screeninfo *var, struct vivid_dev *dev)\n{\n\tdprintk(dev, 1, \"vivid_fb_check_var\\n\");\n\n\tvar->bits_per_pixel = 16;\n\tif (var->green.length == 5) {\n\t\tvar->red.offset = 10;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 5;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 15;\n\t\tvar->transp.length = 1;\n\t} else {\n\t\tvar->red.offset = 11;\n\t\tvar->red.length = 5;\n\t\tvar->green.offset = 5;\n\t\tvar->green.length = 6;\n\t\tvar->blue.offset = 0;\n\t\tvar->blue.length = 5;\n\t\tvar->transp.offset = 0;\n\t\tvar->transp.length = 0;\n\t}\n\tvar->xoffset = var->yoffset = 0;\n\tvar->left_margin = var->upper_margin = 0;\n\tvar->nonstd = 0;\n\n\tvar->vmode &= ~FB_VMODE_MASK;\n\tvar->vmode = FB_VMODE_NONINTERLACED;\n\n\t/* Dummy values */\n\tvar->hsync_len = 24;\n\tvar->vsync_len = 2;\n\tvar->pixclock = 84316;\n\tvar->right_margin = 776;\n\tvar->lower_margin = 591;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-7884",
        "length": 326
    },
    {
        "index": 146142,
        "code": "void WebGL2RenderingContextBase::texImage3D(ExecutionContext* execution_context,\n                                            GLenum target,\n                                            GLint level,\n                                            GLint internalformat,\n                                            GLsizei width,\n                                            GLsizei height,\n                                            GLsizei depth,\n                                            GLint border,\n                                            GLenum format,\n                                            GLenum type,\n                                            HTMLImageElement* image,\n                                            ExceptionState& exception_state) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                      \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n    return;\n  }\n\n  TexImageHelperHTMLImageElement(execution_context->GetSecurityOrigin(),\n                                 kTexImage3D, target, level, internalformat,\n                                 format, type, 0, 0, 0, image,\n                                 GetTextureSourceSubRectangle(width, height),\n                                 depth, unpack_image_height_, exception_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 185
    },
    {
        "index": 95289,
        "code": "AcpiNsGetInternalNameLength (\n    ACPI_NAMESTRING_INFO    *Info)\n{\n    const char              *NextExternalChar;\n    UINT32                  i;\n\n\n    ACPI_FUNCTION_ENTRY ();\n\n\n    NextExternalChar = Info->ExternalName;\n    Info->NumCarats = 0;\n    Info->NumSegments = 0;\n    Info->FullyQualified = FALSE;\n\n    /*\n     * For the internal name, the required length is 4 bytes per segment,\n     * plus 1 each for RootPrefix, MultiNamePrefixOp, segment count,\n     * trailing null (which is not really needed, but no there's harm in\n     * putting it there)\n     *\n     * strlen() + 1 covers the first NameSeg, which has no path separator\n     */\n    if (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n    {\n        Info->FullyQualified = TRUE;\n        NextExternalChar++;\n\n        /* Skip redundant RootPrefix, like \\\\_SB.PCI0.SBRG.EC0 */\n\n        while (ACPI_IS_ROOT_PREFIX (*NextExternalChar))\n        {\n            NextExternalChar++;\n        }\n    }\n    else\n    {\n        /* Handle Carat prefixes */\n\n        while (ACPI_IS_PARENT_PREFIX (*NextExternalChar))\n        {\n            Info->NumCarats++;\n            NextExternalChar++;\n        }\n    }\n\n    /*\n     * Determine the number of ACPI name \"segments\" by counting the number of\n     * path separators within the string. Start with one segment since the\n     * segment count is [(# separators) + 1], and zero separators is ok.\n     */\n    if (*NextExternalChar)\n    {\n        Info->NumSegments = 1;\n        for (i = 0; NextExternalChar[i]; i++)\n        {\n            if (ACPI_IS_PATH_SEPARATOR (NextExternalChar[i]))\n            {\n                Info->NumSegments++;\n            }\n        }\n    }\n\n    Info->Length = (ACPI_NAME_SIZE * Info->NumSegments) +\n        4 + Info->NumCarats;\n\n    Info->NextExternalChar = NextExternalChar;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-755",
        "cve": "CVE-2017-11472",
        "length": 434
    },
    {
        "index": 51770,
        "code": "static gboolean cosine_check_file_type(wtap *wth, int *err, gchar **err_info)\n{\n\tchar\tbuf[COSINE_LINE_LENGTH];\n\tgsize\treclen;\n\tguint\tline;\n\n\tbuf[COSINE_LINE_LENGTH-1] = '\\0';\n\n\tfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\n\t\tif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\n\t\t\t/* EOF or error. */\n\t\t\t*err = file_error(wth->fh, err_info);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treclen = strlen(buf);\n\t\tif (reclen < strlen(COSINE_HDR_MAGIC_STR1) ||\n\t\t\treclen < strlen(COSINE_HDR_MAGIC_STR2)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\n\t\t    strstr(buf, COSINE_HDR_MAGIC_STR2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\t*err = 0;\n\treturn FALSE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5356",
        "length": 217
    },
    {
        "index": 142183,
        "code": "bool FileManagerBrowserTestBase::GetRequiresStartupBrowser() const {\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-5194",
        "length": 19
    },
    {
        "index": 122574,
        "code": "void WebDevToolsAgent::processPendingMessages()\n{\n    PageScriptDebugServer::shared().runPendingTasks();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0884",
        "length": 25
    },
    {
        "index": 115067,
        "code": "void TestingAutomationProvider::WebkitMouseDrag(DictionaryValue* args,\n                                                IPC::Message* reply_message) {\n  if (SendErrorIfModalDialogActive(this, reply_message))\n    return;\n\n  RenderViewHost* view;\n  std::string error;\n  if (!GetRenderViewFromJSONArgs(args, profile(), &view, &error)) {\n    AutomationJSONReply(this, reply_message).SendError(error);\n    return;\n  }\n\n  WebKit::WebMouseEvent mouse_event;\n  int start_x, start_y, end_x, end_y;\n  if (!args->GetInteger(\"start_x\", &start_x) ||\n      !args->GetInteger(\"start_y\", &start_y) ||\n      !args->GetInteger(\"end_x\", &end_x) ||\n      !args->GetInteger(\"end_y\", &end_y)) {\n    AutomationJSONReply(this, reply_message)\n        .SendError(\"Invalid start/end positions\");\n    return;\n  }\n\n  mouse_event.type = WebKit::WebInputEvent::MouseMove;\n  mouse_event.x = start_x;\n  mouse_event.y = start_y;\n  view->ForwardMouseEvent(mouse_event);\n\n  mouse_event.type = WebKit::WebInputEvent::MouseDown;\n  mouse_event.button = WebKit::WebMouseEvent::ButtonLeft;\n  mouse_event.clickCount = 1;\n  view->ForwardMouseEvent(mouse_event);\n\n  mouse_event.type = WebKit::WebInputEvent::MouseMove;\n  mouse_event.x = end_x;\n  mouse_event.y = end_y;\n  mouse_event.clickCount = 0;\n  view->ForwardMouseEvent(mouse_event);\n\n  mouse_event.type = WebKit::WebInputEvent::MouseUp;\n  mouse_event.clickCount = 1;\n  new InputEventAckNotificationObserver(this, reply_message, mouse_event.type,\n                                        1);\n  view->ForwardMouseEvent(mouse_event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 383
    },
    {
        "index": 188371,
        "code": "long Track::GetNumber() const\n{\n    return m_info.number;\n}\n",
        "line": "{\n    return m_info.number;\n}\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 17
    },
    {
        "index": 169822,
        "code": "exsltStrRegister (void) {\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"tokenize\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrTokenizeFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"split\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrSplitFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"encode-uri\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrEncodeUriFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"decode-uri\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrDecodeUriFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"padding\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrPaddingFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"align\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrAlignFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"concat\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrConcatFunction);\n    xsltRegisterExtModuleFunction ((const xmlChar *) \"replace\",\n\t\t\t\t   EXSLT_STRINGS_NAMESPACE,\n\t\t\t\t   exsltStrReplaceFunction);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 256
    },
    {
        "index": 125757,
        "code": "void TabSpecificContentSettings::OnCookiesRead(\n    const GURL& url,\n    const GURL& frame_url,\n    const net::CookieList& cookie_list,\n    bool blocked_by_policy) {\n  if (cookie_list.empty())\n    return;\n  if (blocked_by_policy) {\n    blocked_local_shared_objects_.cookies()->AddReadCookies(\n        frame_url, url, cookie_list);\n    OnContentBlocked(CONTENT_SETTINGS_TYPE_COOKIES, std::string());\n  } else {\n    allowed_local_shared_objects_.cookies()->AddReadCookies(\n        frame_url, url, cookie_list);\n    OnContentAccessed(CONTENT_SETTINGS_TYPE_COOKIES);\n  }\n\n  NotifySiteDataObservers();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-0841",
        "length": 143
    },
    {
        "index": 123966,
        "code": "void RenderViewImpl::didChangeIcon(WebFrame* frame, WebIconURL::Type type) {\n  favicon_helper_->DidChangeIcon(frame, type);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0918",
        "length": 33
    },
    {
        "index": 65782,
        "code": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 106
    },
    {
        "index": 119568,
        "code": "void RenderBlock::appendRunsForObject(BidiRunList<BidiRun>& runs, int start, int end, RenderObject* obj, InlineBidiResolver& resolver)\n{\n    if (start > end || shouldSkipCreatingRunsForObject(obj))\n        return;\n\n    LineMidpointState& lineMidpointState = resolver.midpointState();\n    bool haveNextMidpoint = (lineMidpointState.currentMidpoint < lineMidpointState.numMidpoints);\n    InlineIterator nextMidpoint;\n    if (haveNextMidpoint)\n        nextMidpoint = lineMidpointState.midpoints[lineMidpointState.currentMidpoint];\n    if (lineMidpointState.betweenMidpoints) {\n        if (!(haveNextMidpoint && nextMidpoint.m_obj == obj))\n            return;\n        lineMidpointState.betweenMidpoints = false;\n        start = nextMidpoint.m_pos;\n        lineMidpointState.currentMidpoint++;\n        if (start < end)\n            return appendRunsForObject(runs, start, end, obj, resolver);\n    } else {\n        if (!haveNextMidpoint || (obj != nextMidpoint.m_obj)) {\n            runs.addRun(createRun(start, end, obj, resolver));\n            return;\n        }\n\n        if (static_cast<int>(nextMidpoint.m_pos + 1) <= end) {\n            lineMidpointState.betweenMidpoints = true;\n            lineMidpointState.currentMidpoint++;\n            if (nextMidpoint.m_pos != INT_MAX) { // INT_MAX means stop at the object and don't include any of it.\n                if (static_cast<int>(nextMidpoint.m_pos + 1) > start)\n                    runs.addRun(createRun(start, nextMidpoint.m_pos + 1, obj, resolver));\n                return appendRunsForObject(runs, nextMidpoint.m_pos + 1, end, obj, resolver);\n            }\n        } else\n           runs.addRun(createRun(start, end, obj, resolver));\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2909",
        "length": 407
    },
    {
        "index": 82585,
        "code": "void jswrap_graphics_setPixel(JsVar *parent, int x, int y, JsVar *color) {\n  JsGraphics gfx; if (!graphicsGetFromVar(&gfx, parent)) return;\n  unsigned int col = gfx.data.fgColor;\n  if (!jsvIsUndefined(color))\n    col = (unsigned int)jsvGetInteger(color);\n  graphicsSetPixel(&gfx, (short)x, (short)y, col);\n  gfx.data.cursorX = (short)x;\n  gfx.data.cursorY = (short)y;\n  graphicsSetVar(&gfx); // gfx data changed because modified area\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-11592",
        "length": 130
    },
    {
        "index": 23201,
        "code": "nfs4_find_slot(struct nfs4_slot_table *tbl)\n{\n\tint slotid;\n\tu8 ret_id = NFS4_MAX_SLOT_TABLE;\n\tBUILD_BUG_ON((u8)NFS4_MAX_SLOT_TABLE != (int)NFS4_MAX_SLOT_TABLE);\n\n\tdprintk(\"--> %s used_slots=%04lx highest_used=%d max_slots=%d\\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid,\n\t\ttbl->max_slots);\n\tslotid = find_first_zero_bit(tbl->used_slots, tbl->max_slots);\n\tif (slotid >= tbl->max_slots)\n\t\tgoto out;\n\t__set_bit(slotid, tbl->used_slots);\n\tif (slotid > tbl->highest_used_slotid)\n\t\ttbl->highest_used_slotid = slotid;\n\tret_id = slotid;\nout:\n\tdprintk(\"<-- %s used_slots=%04lx highest_used=%d slotid=%d \\n\",\n\t\t__func__, tbl->used_slots[0], tbl->highest_used_slotid, ret_id);\n\treturn ret_id;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-4131",
        "length": 229
    },
    {
        "index": 74917,
        "code": "deconst(const void *c)\n{\n\treturn (char *)0x1 + (((const char *)c) - (const char *)0x1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-1000880",
        "length": 33
    },
    {
        "index": 124702,
        "code": "static inline TextRun constructTextRunInternal(RenderObject* context, const Font& font, const CharacterType* characters, int length, RenderStyle* style, TextDirection direction, TextRun::ExpansionBehavior expansion, TextRunFlags flags)\n{\n    ASSERT(style);\n\n    TextDirection textDirection = direction;\n    bool directionalOverride = style->rtlOrdering() == VisualOrder;\n    if (flags != DefaultTextRunFlags) {\n        if (flags & RespectDirection)\n            textDirection = style->direction();\n        if (flags & RespectDirectionOverride)\n            directionalOverride |= isOverride(style->unicodeBidi());\n    }\n\n    TextRun run(characters, length, 0, 0, expansion, textDirection, directionalOverride);\n    if (textRunNeedsRenderingContext(font))\n        run.setRenderingContext(SVGTextRunRenderingContext::create(context));\n\n    return run;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 177
    },
    {
        "index": 13015,
        "code": "sshpkt_get_u64(struct ssh *ssh, u_int64_t *valp)\n{\n\treturn sshbuf_get_u64(ssh->state->incoming_packet, valp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1907",
        "length": 39
    },
    {
        "index": 110106,
        "code": "  ~PluginNetworkObserver() {\n    net::NetworkChangeNotifier::RemoveConnectionTypeObserver(this);\n    net::NetworkChangeNotifier::RemoveIPAddressObserver(this);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5111",
        "length": 35
    },
    {
        "index": 93012,
        "code": "rdp_out_newpointer_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_POINTER);\n\tout_uint16_le(s, RDP_CAPLEN_NEWPOINTER);\n\n\tout_uint16_le(s, 1);\t/* Colour pointer */\n\tout_uint16_le(s, 20);\t/* Cache size */\n\tout_uint16_le(s, 20);\t/* Cache size for new pointers */\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-20182",
        "length": 84
    },
    {
        "index": 136328,
        "code": "void FragmentPaintPropertyTreeBuilder::UpdateForChildren() {\n#if DCHECK_IS_ON()\n  FindObjectPropertiesNeedingUpdateScope check_needs_update_scope(\n      object_, fragment_data_, full_context_.force_subtree_update);\n#endif\n\n  if (properties_) {\n    UpdateInnerBorderRadiusClip();\n    UpdateOverflowClip();\n    UpdatePerspective();\n    UpdateSvgLocalToBorderBoxTransform();\n    UpdateScrollAndScrollTranslation();\n  }\n  UpdateOutOfFlowContext();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 96
    },
    {
        "index": 74987,
        "code": "static UINT dvcman_receive_channel_data_first(drdynvcPlugin* drdynvc,\n        IWTSVirtualChannelManager* pChannelMgr,\n        UINT32 ChannelId, UINT32 length)\n{\n\tDVCMAN_CHANNEL* channel;\n\tchannel = (DVCMAN_CHANNEL*) dvcman_find_channel_by_id(pChannelMgr, ChannelId);\n\n\tif (!channel)\n\t{\n\t\t/**\n\t\t * Windows Server 2012 R2 can send some messages over Microsoft::Windows::RDS::Geometry::v08.01\n\t\t * even if the dynamic virtual channel wasn't registered on our side. Ignoring it works.\n\t\t */\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"ChannelId %\"PRIu32\" not found!\", ChannelId);\n\t\treturn CHANNEL_RC_OK;\n\t}\n\n\tif (channel->dvc_data)\n\t\tStream_Release(channel->dvc_data);\n\n\tchannel->dvc_data = StreamPool_Take(channel->dvcman->pool, length);\n\n\tif (!channel->dvc_data)\n\t{\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"StreamPool_Take failed!\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tchannel->dvc_data_length = length;\n\treturn CHANNEL_RC_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-1000852",
        "length": 262
    },
    {
        "index": 117135,
        "code": "static void webkitWebViewBaseFinalize(GObject* gobject)\n{\n    WebKitWebViewBase* webkitWebViewBase = WEBKIT_WEB_VIEW_BASE(gobject);\n    webkitWebViewBase->priv->pageProxy->close();\n\n    webkitWebViewBase->priv->~WebKitWebViewBasePrivate();\n    G_OBJECT_CLASS(webkit_web_view_base_parent_class)->finalize(gobject);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3099",
        "length": 79
    },
    {
        "index": 155778,
        "code": "void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {\n  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n    if (it->get() == token_fetcher) {\n      token_fetchers_.erase(it);\n      return;\n    }\n  }\n  NOTREACHED();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1665",
        "length": 77
    },
    {
        "index": 161161,
        "code": "  void SetVideoType(MediaStreamType video_type) {\n    DCHECK(IsVideoMediaType(video_type) || video_type == MEDIA_NO_SERVICE);\n    video_type_ = video_type;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6103",
        "length": 39
    },
    {
        "index": 69140,
        "code": "ZEND_API void ZEND_FASTCALL _zend_hash_init_ex(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection ZEND_FILE_LINE_DC)\n{\n\t_zend_hash_init(ht, nSize, pDestructor, persistent ZEND_FILE_LINE_RELAY_CC);\n\tif (!bApplyProtection) {\n\t\tht->u.flags &= ~HASH_FLAG_APPLY_PROTECTION;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-5340",
        "length": 92
    },
    {
        "index": 21723,
        "code": "static u32 desc_limit_scaled(struct desc_struct *desc)\n{\n\tu32 limit = get_desc_limit(desc);\n\n\treturn desc->g ? (limit << 12) | 0xfff : limit;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-0045",
        "length": 42
    },
    {
        "index": 142639,
        "code": "void WebstoreStandaloneInstaller::AbortInstall() {\n  callback_.Reset();\n  if (webstore_data_fetcher_) {\n    webstore_data_fetcher_.reset();\n    scoped_active_install_.reset();\n    Release();  // Matches the AddRef in BeginInstall.\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 59
    },
    {
        "index": 145169,
        "code": "void GpuProcessHost::OnDestroyingVideoSurfaceAck() {\n  TRACE_EVENT0(\"gpu\", \"GpuProcessHost::OnDestroyingVideoSurfaceAck\");\n  if (!send_destroying_video_surface_done_cb_.is_null())\n    base::ResetAndReturn(&send_destroying_video_surface_done_cb_).Run();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1620",
        "length": 68
    },
    {
        "index": 79566,
        "code": "void imap_cmd_finish(struct ImapData *idata)\n{\n  if (idata->status == IMAP_FATAL)\n  {\n    cmd_handle_fatal(idata);\n    return;\n  }\n\n  if (!(idata->state >= IMAP_SELECTED) || idata->ctx->closing)\n    return;\n\n  if (idata->reopen & IMAP_REOPEN_ALLOW)\n  {\n    unsigned int count = idata->new_mail_count;\n\n    if (!(idata->reopen & IMAP_EXPUNGE_PENDING) &&\n        (idata->reopen & IMAP_NEWMAIL_PENDING) && count > idata->max_msn)\n    {\n      /* read new mail messages */\n      mutt_debug(2, \"Fetching new mail\\n\");\n      /* check_status: curs_main uses imap_check_mailbox to detect\n       *   whether the index needs updating */\n      idata->check_status = IMAP_NEWMAIL_PENDING;\n      imap_read_headers(idata, idata->max_msn + 1, count);\n    }\n    else if (idata->reopen & IMAP_EXPUNGE_PENDING)\n    {\n      mutt_debug(2, \"Expunging mailbox\\n\");\n      imap_expunge_mailbox(idata);\n      /* Detect whether we've gotten unexpected EXPUNGE messages */\n      if ((idata->reopen & IMAP_EXPUNGE_PENDING) && !(idata->reopen & IMAP_EXPUNGE_EXPECTED))\n        idata->check_status = IMAP_EXPUNGE_PENDING;\n      idata->reopen &=\n          ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);\n    }\n  }\n\n  idata->status = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2018-14357",
        "length": 342
    },
    {
        "index": 129016,
        "code": "    bool writeCryptoKey(v8::Handle<v8::Value> value)\n    {\n        CryptoKey* key = V8CryptoKey::toNative(value.As<v8::Object>());\n        if (!key)\n            return false;\n        return m_writer.writeCryptoKey(key->key());\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3171",
        "length": 61
    },
    {
        "index": 33143,
        "code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-1826",
        "length": 188
    },
    {
        "index": 106819,
        "code": "void RenderBox::addShadowOverflow()\n{\n    int shadowLeft;\n    int shadowRight;\n    int shadowTop;\n    int shadowBottom;\n    style()->getBoxShadowExtent(shadowTop, shadowRight, shadowBottom, shadowLeft);\n    IntRect borderBox = borderBoxRect();\n    int overflowLeft = borderBox.x() + shadowLeft;\n    int overflowRight = borderBox.maxX() + shadowRight;\n    int overflowTop = borderBox.y() + shadowTop;\n    int overflowBottom = borderBox.maxY() + shadowBottom;\n    addVisualOverflow(IntRect(overflowLeft, overflowTop, overflowRight - overflowLeft, overflowBottom - overflowTop));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1799",
        "length": 140
    },
    {
        "index": 111912,
        "code": "void ProfileSyncService::OnEncryptionComplete() {\n  DVLOG(1) << \"Encryption complete\";\n  if (encryption_pending_ && encrypt_everything_) {\n    encryption_pending_ = false;\n    NotifyObservers();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 48
    },
    {
        "index": 163286,
        "code": "NOINLINE void ResetThread_CACHE() {\n  volatile int inhibit_comdat = __LINE__;\n  ALLOW_UNUSED_LOCAL(inhibit_comdat);\n  BrowserThreadImpl::StopRedirectionOfThreadID(BrowserThread::CACHE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2017-15423",
        "length": 46
    },
    {
        "index": 6421,
        "code": "const char* menu_cache_app_get_generic_name( MenuCacheApp* app )\n{\n\treturn app->generic_name;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-8933",
        "length": 25
    },
    {
        "index": 40101,
        "code": "static int kiocb_cancel(struct kioctx *ctx, struct kiocb *kiocb)\n{\n\tkiocb_cancel_fn *old, *cancel;\n\n\t/*\n\t * Don't want to set kiocb->ki_cancel = KIOCB_CANCELLED unless it\n\t * actually has a cancel function, hence the cmpxchg()\n\t */\n\n\tcancel = ACCESS_ONCE(kiocb->ki_cancel);\n\tdo {\n\t\tif (!cancel || cancel == KIOCB_CANCELLED)\n\t\t\treturn -EINVAL;\n\n\t\told = cancel;\n\t\tcancel = cmpxchg(&kiocb->ki_cancel, old, KIOCB_CANCELLED);\n\t} while (cancel != old);\n\n\treturn cancel(kiocb);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-7348",
        "length": 149
    },
    {
        "index": 36990,
        "code": "static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-3690",
        "length": 135
    },
    {
        "index": 55371,
        "code": "void __init evm_load_x509(void)\n{\n\tint rc;\n\n\trc = integrity_load_x509(INTEGRITY_KEYRING_EVM, CONFIG_EVM_X509_PATH);\n\tif (!rc)\n\t\tevm_initialized |= EVM_INIT_X509;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2016-2085",
        "length": 52
    },
    {
        "index": 6769,
        "code": "static void trim_aio_cancel(BlockAIOCB *acb)\n{\n    TrimAIOCB *iocb = container_of(acb, TrimAIOCB, common);\n\n    /* Exit the loop so ide_issue_trim_cb will not continue  */\n    iocb->j = iocb->qiov->niov - 1;\n    iocb->i = (iocb->qiov->iov[iocb->j].iov_len / 8) - 1;\n\n    iocb->ret = -ECANCELED;\n\n    if (iocb->aiocb) {\n        blk_aio_cancel_async(iocb->aiocb);\n        iocb->aiocb = NULL;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-9718",
        "length": 152
    },
    {
        "index": 148871,
        "code": "bool RenderFrameHostManager::CreateSpeculativeRenderFrameHost(\n    SiteInstance* old_instance,\n    SiteInstance* new_instance) {\n  CHECK(new_instance);\n  CHECK_NE(old_instance, new_instance);\n\n  if (!new_instance->GetProcess()->Init())\n    return false;\n\n  CreateProxiesForNewRenderFrameHost(old_instance, new_instance);\n\n  speculative_render_frame_host_ =\n      CreateRenderFrame(new_instance, delegate_->IsHidden(), nullptr);\n\n  return !!speculative_render_frame_host_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 104
    },
    {
        "index": 93791,
        "code": "virDomainFSTrim(virDomainPtr dom,\n                const char *mountPoint,\n                unsigned long long minimum,\n                unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"mountPoint=%s, minimum=%llu, flags=%x\",\n                     mountPoint, minimum, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainFSTrim) {\n        int ret = dom->conn->driver->domainFSTrim(dom, mountPoint,\n                                                  minimum, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10746",
        "length": 167
    },
    {
        "index": 39162,
        "code": "int nfs_generic_flush(struct nfs_pageio_descriptor *desc,\n\t\t      struct nfs_pgio_header *hdr)\n{\n\tif (desc->pg_bsize < PAGE_CACHE_SIZE)\n\t\treturn nfs_flush_multi(desc, hdr);\n\treturn nfs_flush_one(desc, hdr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2038",
        "length": 53
    },
    {
        "index": 147896,
        "code": "void V8TestObject::TestEnumAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_testEnumAttribute_Setter\");\n\n  v8::Local<v8::Value> v8_value = info[0];\n\n  test_object_v8_internal::TestEnumAttributeAttributeSetter(v8_value, info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 92
    },
    {
        "index": 103204,
        "code": "void Browser::SyncHistoryWithTabs(int index) {\n  if (!profile()->HasSessionService())\n    return;\n  SessionService* session_service = profile()->GetSessionService();\n  if (session_service) {\n    for (int i = index; i < tab_count(); ++i) {\n      TabContents* contents = GetTabContentsAt(i);\n      if (contents) {\n        session_service->SetTabIndexInWindow(\n            session_id(), contents->controller().session_id(), i);\n        session_service->SetPinnedState(\n            session_id(),\n            contents->controller().session_id(),\n            tab_handler_->GetTabStripModel()->IsTabPinned(i));\n      }\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2840",
        "length": 144
    },
    {
        "index": 138073,
        "code": "bool AXNodeObject::isMenuButton() const {\n  return roleValue() == MenuButtonRole;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 23
    },
    {
        "index": 13458,
        "code": "void js_pushboolean(js_State *J, int v)\n{\n\tCHECKSTACK(1);\n\tSTACK[TOP].type = JS_TBOOLEAN;\n\tSTACK[TOP].u.boolean = !!v;\n\t++TOP;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10133",
        "length": 46
    },
    {
        "index": 151144,
        "code": "InspectorNetworkAgent::BuildInitiatorObject(\n    Document* document,\n    const FetchInitiatorInfo& initiator_info) {\n  if (!initiator_info.imported_module_referrer.IsEmpty()) {\n    std::unique_ptr<protocol::Network::Initiator> initiator_object =\n        protocol::Network::Initiator::create()\n            .setType(protocol::Network::Initiator::TypeEnum::Script)\n            .build();\n    initiator_object->setUrl(initiator_info.imported_module_referrer);\n    initiator_object->setLineNumber(\n        initiator_info.position.line_.ZeroBasedInt());\n    return initiator_object;\n  }\n\n  std::unique_ptr<v8_inspector::protocol::Runtime::API::StackTrace>\n      current_stack_trace =\n          SourceLocation::Capture(document)->BuildInspectorObject();\n  if (current_stack_trace) {\n    std::unique_ptr<protocol::Network::Initiator> initiator_object =\n        protocol::Network::Initiator::create()\n            .setType(protocol::Network::Initiator::TypeEnum::Script)\n            .build();\n    initiator_object->setStack(std::move(current_stack_trace));\n    return initiator_object;\n  }\n\n  while (document && !document->GetScriptableDocumentParser())\n    document = document->LocalOwner() ? document->LocalOwner()->ownerDocument()\n                                      : nullptr;\n  if (document && document->GetScriptableDocumentParser()) {\n    std::unique_ptr<protocol::Network::Initiator> initiator_object =\n        protocol::Network::Initiator::create()\n            .setType(protocol::Network::Initiator::TypeEnum::Parser)\n            .build();\n    initiator_object->setUrl(UrlWithoutFragment(document->Url()).GetString());\n    if (TextPosition::BelowRangePosition() != initiator_info.position)\n      initiator_object->setLineNumber(\n          initiator_info.position.line_.ZeroBasedInt());\n    else\n      initiator_object->setLineNumber(\n          document->GetScriptableDocumentParser()->LineNumber().ZeroBasedInt());\n    return initiator_object;\n  }\n\n  return protocol::Network::Initiator::create()\n      .setType(protocol::Network::Initiator::TypeEnum::Other)\n      .build();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 432
    },
    {
        "index": 144108,
        "code": "png_set_flush(png_structp png_ptr, int nrows)\n{\n   png_debug(1, \"in png_set_flush\");\n\n   if (png_ptr == NULL)\n      return;\n   png_ptr->flush_dist = (nrows < 0 ? 0 : nrows);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8126",
        "length": 57
    },
    {
        "index": 172372,
        "code": "bool omx_video::release_done(void)\n{\n bool bRet = false;\n    DEBUG_PRINT_LOW(\"Inside release_done()\");\n if (release_input_done()) {\n if (release_output_done()) {\n            bRet = true;\n }\n }\n return bRet;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3835",
        "length": 53
    },
    {
        "index": 144916,
        "code": "base::i18n::TextDirection RenderWidgetHostViewAura::GetTextDirection() const {\n  NOTIMPLEMENTED();\n  return base::i18n::UNKNOWN_DIRECTION;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-1615",
        "length": 38
    },
    {
        "index": 146336,
        "code": "WebGLRenderingContextBase* WebGLRenderingContextBase::OldestContext() {\n  if (ActiveContexts().IsEmpty())\n    return nullptr;\n\n  WebGLRenderingContextBase* candidate = *(ActiveContexts().begin());\n  DCHECK(!candidate->isContextLost());\n  for (WebGLRenderingContextBase* context : ActiveContexts()) {\n    DCHECK(!context->isContextLost());\n    if (context->ContextGL()->GetLastFlushIdCHROMIUM() <\n        candidate->ContextGL()->GetLastFlushIdCHROMIUM()) {\n      candidate = context;\n    }\n  }\n\n  return candidate;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 123
    },
    {
        "index": 89639,
        "code": "static int mdio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mdio_device *mdio = to_mdio_device(dev);\n\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (mdio->bus_match)\n\t\treturn mdio->bus_match(dev, drv);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-12819",
        "length": 72
    },
    {
        "index": 150156,
        "code": "void ImageProcessorClient::FrameReady(size_t frame_index,\n                                      scoped_refptr<VideoFrame> frame) {\n  DCHECK_CALLED_ON_VALID_THREAD(image_processor_client_thread_checker_);\n\n  base::AutoLock auto_lock_(output_lock_);\n  EXPECT_EQ(frame_index, num_processed_frames_);\n  for (auto& processor : frame_processors_)\n    processor->ProcessVideoFrame(std::move(frame), frame_index);\n  num_processed_frames_++;\n  output_cv_.Signal();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5067",
        "length": 94
    },
    {
        "index": 76579,
        "code": "static int on_http_message_begin(http_parser* parser)\n{\n    struct clt_info *info = parser->data;\n    if (info->request)\n        http_request_release(info->request);\n    info->request = http_request_new();\n    if (info->request == NULL) {\n        return -__LINE__;\n    }\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-17570",
        "length": 73
    },
    {
        "index": 26609,
        "code": "static void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n\tto->pkt_type = from->pkt_type;\n\tto->priority = from->priority;\n\tto->protocol = from->protocol;\n\tskb_dst_drop(to);\n\tskb_dst_set(to, dst_clone(skb_dst(from)));\n\tto->dev = from->dev;\n\tto->mark = from->mark;\n\n#ifdef CONFIG_NET_SCHED\n\tto->tc_index = from->tc_index;\n#endif\n\tnf_copy(to, from);\n#if defined(CONFIG_NETFILTER_XT_TARGET_TRACE) || \\\n    defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE)\n\tto->nf_trace = from->nf_trace;\n#endif\n\tskb_copy_secmark(to, from);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-2699",
        "length": 149
    },
    {
        "index": 18003,
        "code": "jbig2_ctx_new(Jbig2Allocator *allocator, Jbig2Options options, Jbig2GlobalCtx *global_ctx, Jbig2ErrorCallback error_callback, void *error_callback_data)\n{\n    Jbig2Ctx *result;\n\n    if (allocator == NULL)\n        allocator = &jbig2_default_allocator;\n    if (error_callback == NULL)\n        error_callback = &jbig2_default_error;\n\n    result = (Jbig2Ctx *) jbig2_alloc(allocator, sizeof(Jbig2Ctx), 1);\n    if (result == NULL) {\n        error_callback(error_callback_data, \"initial context allocation failed!\", JBIG2_SEVERITY_FATAL, -1);\n        return result;\n    }\n\n    result->allocator = allocator;\n    result->options = options;\n    result->global_ctx = (const Jbig2Ctx *)global_ctx;\n    result->error_callback = error_callback;\n    result->error_callback_data = error_callback_data;\n\n    result->state = (options & JBIG2_OPTIONS_EMBEDDED) ? JBIG2_FILE_SEQUENTIAL_HEADER : JBIG2_FILE_HEADER;\n\n    result->buf = NULL;\n\n    result->n_segments = 0;\n    result->n_segments_max = 16;\n    result->segments = jbig2_new(result, Jbig2Segment *, result->n_segments_max);\n    if (result->segments == NULL) {\n        error_callback(error_callback_data, \"initial segments allocation failed!\", JBIG2_SEVERITY_FATAL, -1);\n        jbig2_free(allocator, result);\n        return result;\n    }\n    result->segment_index = 0;\n\n    result->current_page = 0;\n    result->max_page_index = 4;\n    result->pages = jbig2_new(result, Jbig2Page, result->max_page_index);\n    if (result->pages == NULL) {\n        error_callback(error_callback_data, \"initial pages allocation failed!\", JBIG2_SEVERITY_FATAL, -1);\n        jbig2_free(allocator, result->segments);\n        jbig2_free(allocator, result);\n        return result;\n    }\n    {\n        int index;\n\n        for (index = 0; index < result->max_page_index; index++) {\n            result->pages[index].state = JBIG2_PAGE_FREE;\n            result->pages[index].number = 0;\n            result->pages[index].image = NULL;\n        }\n    }\n\n    return result;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9601",
        "length": 511
    },
    {
        "index": 113906,
        "code": "void HTMLDocumentParser::suspendScheduledTasks()\n{\n    if (m_parserScheduler)\n        m_parserScheduler->suspend();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 26
    },
    {
        "index": 55965,
        "code": "static void skcipher_free_async_sgls(struct skcipher_async_req *sreq)\n{\n\tstruct skcipher_async_rsgl *rsgl, *tmp;\n\tstruct scatterlist *sgl;\n\tstruct scatterlist *sg;\n\tint i, n;\n\n\tlist_for_each_entry_safe(rsgl, tmp, &sreq->list, list) {\n\t\taf_alg_free_sg(&rsgl->sgl);\n\t\tif (rsgl != &sreq->first_sgl)\n\t\t\tkfree(rsgl);\n\t}\n\tsgl = sreq->tsg;\n\tn = sg_nents(sgl);\n\tfor_each_sg(sgl, sg, n, i)\n\t\tput_page(sg_page(sg));\n\n\tkfree(sreq->tsg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2015-8970",
        "length": 155
    },
    {
        "index": 99628,
        "code": "void VaapiVideoDecodeAccelerator::Destroy() {\n  DCHECK_EQ(message_loop_, base::MessageLoop::current());\n  Cleanup();\n  delete this;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 33
    },
    {
        "index": 153249,
        "code": "bool DesktopWindowTreeHostX11::IsFullscreen() const {\n  return is_fullscreen_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5217",
        "length": 21
    },
    {
        "index": 98380,
        "code": "gchar* webkit_web_frame_dump_render_tree(WebKitWebFrame* frame)\n{\n    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), NULL);\n\n    Frame* coreFrame = core(frame);\n    if (!coreFrame)\n        return g_strdup(\"\");\n\n    FrameView* view = coreFrame->view();\n\n    if (view && view->layoutPending())\n        view->layout();\n\n    String string = externalRepresentation(coreFrame->contentRenderer());\n    return g_strdup(string.utf8().data());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 104
    },
    {
        "index": 167788,
        "code": "void WebRuntimeFeatures::EnableWebGL2ComputeContext(bool enable) {\n  RuntimeEnabledFeatures::SetWebGL2ComputeContextEnabled(enable);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-16075",
        "length": 31
    },
    {
        "index": 130181,
        "code": "void RenderFrameHostImpl::OnCrossSiteResponse(\n    const GlobalRequestID& global_request_id,\n    scoped_ptr<CrossSiteTransferringRequest> cross_site_transferring_request,\n    const std::vector<GURL>& transfer_url_chain,\n    const Referrer& referrer,\n    PageTransition page_transition,\n    bool should_replace_current_entry) {\n  frame_tree_node_->render_manager()->OnCrossSiteResponse(\n      this, global_request_id, cross_site_transferring_request.Pass(),\n      transfer_url_chain, referrer, page_transition,\n      should_replace_current_entry);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 120
    },
    {
        "index": 47582,
        "code": "static ssize_t ap_config_time_store(struct bus_type *bus,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tint time;\n\n\tif (sscanf(buf, \"%d\\n\", &time) != 1 || time < 5 || time > 120)\n\t\treturn -EINVAL;\n\tap_config_time = time;\n\tif (!timer_pending(&ap_config_timer) ||\n\t    !mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ)) {\n\t\tap_config_timer.expires = jiffies + ap_config_time * HZ;\n\t\tadd_timer(&ap_config_timer);\n\t}\n\treturn count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 126
    },
    {
        "index": 64811,
        "code": "int skcipher_walk_async(struct skcipher_walk *walk,\n\t\t\tstruct skcipher_request *req)\n{\n\twalk->flags |= SKCIPHER_WALK_PHYS;\n\n\tINIT_LIST_HEAD(&walk->buffers);\n\n\treturn skcipher_walk_skcipher(walk, req);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-9211",
        "length": 56
    },
    {
        "index": 32965,
        "code": "static struct sctp_transport *sctp_addr_id2transport(struct sock *sk,\n\t\t\t\t\t      struct sockaddr_storage *addr,\n\t\t\t\t\t      sctp_assoc_t id)\n{\n\tstruct sctp_association *addr_asoc = NULL, *id_asoc = NULL;\n\tstruct sctp_transport *transport;\n\tunion sctp_addr *laddr = (union sctp_addr *)addr;\n\n\taddr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)->ep,\n\t\t\t\t\t       laddr,\n\t\t\t\t\t       &transport);\n\n\tif (!addr_asoc)\n\t\treturn NULL;\n\n\tid_asoc = sctp_id2assoc(sk, id);\n\tif (id_asoc && (id_asoc != addr_asoc))\n\t\treturn NULL;\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_v4map(sctp_sk(sk),\n\t\t\t\t\t\t(union sctp_addr *)addr);\n\n\treturn transport;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1828",
        "length": 174
    },
    {
        "index": 19983,
        "code": "static void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)\n{\n\tdata->timestamp   = jiffies;\n\tdata->read_done_cb = nfs4_read_done_cb;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];\n\tnfs41_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 85
    },
    {
        "index": 29144,
        "code": "static int nfs4_commit_done(struct rpc_task *task, struct nfs_commit_data *data)\n{\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn -EAGAIN;\n\treturn data->commit_done_cb(task, data);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4591",
        "length": 54
    },
    {
        "index": 115666,
        "code": "void ClientSession::RecordKeyEvent(const KeyEvent& event) {\n  if (event.pressed()) {\n    pressed_keys_.insert(event.keycode());\n  } else {\n    pressed_keys_.erase(event.keycode());\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 46
    },
    {
        "index": 35681,
        "code": "static void *create_server_config(apr_pool_t *p, server_rec *s)\n{\n\n    ap_lua_server_cfg *cfg = apr_pcalloc(p, sizeof(ap_lua_server_cfg));\n    cfg->vm_reslists = apr_hash_make(p);\n    apr_thread_rwlock_create(&cfg->vm_reslists_lock, p);\n    cfg->root_path = NULL;\n\n    return cfg;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-8109",
        "length": 79
    },
    {
        "index": 118348,
        "code": "CardUnmaskPromptViews::CardUnmaskPromptViews(\n    CardUnmaskPromptController* controller)\n    : controller_(controller),\n      main_contents_(nullptr),\n      permanent_error_label_(nullptr),\n      input_row_(nullptr),\n      cvc_input_(nullptr),\n      month_input_(nullptr),\n      year_input_(nullptr),\n      error_label_(nullptr),\n      storage_row_(nullptr),\n      storage_checkbox_(nullptr),\n      progress_overlay_(nullptr),\n      progress_throbber_(nullptr),\n      progress_label_(nullptr),\n      overlay_animation_(this),\n      weak_ptr_factory_(this) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-6636",
        "length": 119
    },
    {
        "index": 61351,
        "code": "static int asf_read_ext_content_desc(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int desc_count, i, ret;\n\n    desc_count = avio_rl16(pb);\n    for (i = 0; i < desc_count; i++) {\n        int name_len, value_type, value_len;\n        char name[1024];\n\n        name_len = avio_rl16(pb);\n        if (name_len % 2)   // must be even, broken lavf versions wrote len-1\n            name_len += 1;\n        if ((ret = avio_get_str16le(pb, name_len, name, sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        value_type = avio_rl16(pb);\n        value_len  = avio_rl16(pb);\n        if (!value_type && value_len % 2)\n            value_len += 1;\n        /* My sample has that stream set to 0 maybe that mean the container.\n         * ASF stream count starts at 1. I am using 0 to the container value\n         * since it's unused. */\n        if (!strcmp(name, \"AspectRatioX\"))\n            asf->dar[0].num = get_value(s->pb, value_type, 32);\n        else if (!strcmp(name, \"AspectRatioY\"))\n            asf->dar[0].den = get_value(s->pb, value_type, 32);\n        else\n            get_tag(s, name, value_type, value_len, 32);\n    }\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2017-14223",
        "length": 352
    },
    {
        "index": 132575,
        "code": "void WebKitTestController::OnClearDevToolsLocalStorage() {\n  ShellBrowserContext* browser_context =\n      ShellContentBrowserClient::Get()->browser_context();\n  StoragePartition* storage_partition =\n      BrowserContext::GetStoragePartition(browser_context, NULL);\n  storage_partition->GetDOMStorageContext()->DeleteLocalStorage(\n      content::LayoutTestDevToolsFrontend::GetDevToolsPathAsURL(\"\", \"\")\n          .GetOrigin());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 88
    },
    {
        "index": 80084,
        "code": "GF_Err elng_Size(GF_Box *s)\n{\n\tGF_ExtendedLanguageBox *ptr = (GF_ExtendedLanguageBox *)s;\n\n\tif (ptr->extended_language) {\n\t\tptr->size += strlen(ptr->extended_language)+1;\n\t}\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 59
    },
    {
        "index": 42799,
        "code": "static bool check_minimal_bt_rating(const char *event_name)\n{\n    bool acceptable_rating = true;\n    event_config_t *event_cfg = NULL;\n\n    if (!event_name)\n        error_msg_and_die(_(\"Cannot check backtrace rating because of invalid event name\"));\n    else if (prefixcmp(event_name, \"report\") != 0)\n    {\n        log_info(\"No checks for bactrace rating because event '%s' doesn't report.\", event_name);\n        return acceptable_rating;\n    }\n    else\n        event_cfg = get_event_config(event_name);\n\n    char *description = NULL;\n    acceptable_rating = check_problem_rating_usability(event_cfg, g_cd, &description, NULL);\n    if (description)\n    {\n        add_warning(description);\n        free(description);\n    }\n\n    return acceptable_rating;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5302",
        "length": 167
    },
    {
        "index": 101878,
        "code": "void Browser::ViewSelectedSource() {\n  ViewSource(GetSelectedTabContentsWrapper());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3896",
        "length": 19
    },
    {
        "index": 85345,
        "code": "static void __refresh_next_blkoff(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *seg)\n{\n\tif (seg->alloc_type == SSR)\n\t\t__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);\n\telse\n\t\tseg->next_blkoff++;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18241",
        "length": 68
    },
    {
        "index": 131191,
        "code": "static void activityLoggingGetterForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterForMainWorld(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValueInt(info, imp->activityLoggingGetterForIsolatedWorldsPerWorldBindingsLongAttribute());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 80
    },
    {
        "index": 180450,
        "code": "cJSON *cJSON_CreateString( const char *string )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_String;\n\t\titem->valuestring = cJSON_strdup( string );\n\t}\n\treturn item;\n}\n",
        "line": "{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_String;\n\t\titem->valuestring = cJSON_strdup( string );\n\t}\n\treturn item;\n}\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4303",
        "length": 54
    },
    {
        "index": 164920,
        "code": "void ResourceDispatcherHostImpl::CancelRequestsForRoute(\n    const GlobalFrameRoutingId& global_routing_id) {\n\n  int child_id = global_routing_id.child_id;\n  int route_id = global_routing_id.frame_routing_id;\n  bool cancel_all_routes = (route_id == MSG_ROUTING_NONE);\n\n  std::vector<GlobalRequestID> matching_requests;\n  for (const auto& loader : pending_loaders_) {\n    if (loader.first.child_id != child_id)\n      continue;\n\n    ResourceRequestInfoImpl* info = loader.second->GetRequestInfo();\n\n    GlobalRequestID id(child_id, loader.first.request_id);\n    DCHECK(id == loader.first);\n    if (cancel_all_routes || route_id == info->GetRenderFrameID()) {\n      if (info->keepalive() && !cancel_all_routes) {\n      } else if (info->detachable_handler()) {\n        info->detachable_handler()->Detach();\n      } else if (!info->IsDownload() && !info->is_stream()) {\n        matching_requests.push_back(id);\n      }\n    }\n  }\n\n  for (size_t i = 0; i < matching_requests.size(); ++i) {\n    auto iter = pending_loaders_.find(matching_requests[i]);\n    if (iter != pending_loaders_.end())\n      RemovePendingLoader(iter);\n  }\n\n  if (!cancel_all_routes) {\n    if (blocked_loaders_map_.find(global_routing_id) !=\n        blocked_loaders_map_.end()) {\n      CancelBlockedRequestsForRoute(global_routing_id);\n    }\n  } else {\n    std::set<GlobalFrameRoutingId> routing_ids;\n    for (const auto& blocked_loaders : blocked_loaders_map_) {\n      if (blocked_loaders.first.child_id == child_id)\n        routing_ids.insert(blocked_loaders.first);\n    }\n    for (const GlobalFrameRoutingId& frame_route_id : routing_ids) {\n      CancelBlockedRequestsForRoute(frame_route_id);\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2019-5822",
        "length": 407
    },
    {
        "index": 83198,
        "code": "top_proc(mrb_state *mrb, struct RProc *proc)\n{\n  while (proc->upper) {\n    if (MRB_PROC_SCOPE_P(proc) || MRB_PROC_STRICT_P(proc))\n      return proc;\n    proc = proc->upper;\n  }\n  return proc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-10191",
        "length": 62
    },
    {
        "index": 165110,
        "code": "OperationID FileSystemOperationRunner::RemoveDirectory(\n    const FileSystemURL& url,\n    StatusCallback callback) {\n  base::File::Error error = base::File::FILE_OK;\n  std::unique_ptr<FileSystemOperation> operation = base::WrapUnique(\n      file_system_context_->CreateFileSystemOperation(url, &error));\n  FileSystemOperation* operation_raw = operation.get();\n  OperationID id = BeginOperation(std::move(operation));\n  base::AutoReset<bool> beginning(&is_beginning_operation_, true);\n  if (!operation_raw) {\n    DidFinish(id, std::move(callback), error);\n    return id;\n  }\n  PrepareForWrite(id, url);\n  operation_raw->RemoveDirectory(\n      url, base::BindOnce(&FileSystemOperationRunner::DidFinish, weak_ptr_, id,\n                          std::move(callback)));\n  return id;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-5788",
        "length": 176
    },
    {
        "index": 141188,
        "code": "void Document::ProcessJavaScriptUrl(\n    const KURL& url,\n    ContentSecurityPolicyDisposition disposition) {\n  DCHECK(url.ProtocolIsJavaScript());\n  if (frame_->Loader().StateMachine()->IsDisplayingInitialEmptyDocument())\n    load_event_progress_ = kLoadEventNotRun;\n  frame_->Loader().Progress().ProgressStarted();\n  if (frame_->Loader().StateMachine()->IsDisplayingInitialEmptyDocument() &&\n      (url == \"javascript:''\" || url == \"javascript:\\\"\\\"\")) {\n    ExecuteJavaScriptUrl(url, disposition);\n    return;\n  }\n  javascript_url_task_handle_ = PostCancellableTask(\n      *GetTaskRunner(TaskType::kNetworking), FROM_HERE,\n      WTF::Bind(&Document::ExecuteJavaScriptUrl, WrapWeakPersistent(this), url,\n                disposition));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 163
    },
    {
        "index": 4615,
        "code": "PHP_GSHUTDOWN_FUNCTION(openssl)\n{\n\tif (openssl_globals->errors) {\n\t\tpefree(openssl_globals->errors, 1);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-754",
        "cve": "CVE-2017-11144",
        "length": 36
    },
    {
        "index": 27698,
        "code": "ebt_make_names(struct ebt_entry *e, const char *base, char __user *ubase)\n{\n\tint ret;\n\tchar __user *hlp;\n\tconst struct ebt_entry_target *t;\n\n\tif (e->bitmask == 0)\n\t\treturn 0;\n\n\thlp = ubase + (((char *)e + e->target_offset) - base);\n\tt = (struct ebt_entry_target *)(((char *)e) + e->target_offset);\n\n\tret = EBT_MATCH_ITERATE(e, ebt_make_matchname, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tret = EBT_WATCHER_ITERATE(e, ebt_make_watchername, base, ubase);\n\tif (ret != 0)\n\t\treturn ret;\n\tif (copy_to_user(hlp, t->u.target->name, EBT_FUNCTION_MAXNAMELEN))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1080",
        "length": 194
    },
    {
        "index": 177527,
        "code": "void destroy_rate_histogram(struct rate_hist *hist) {\n if (hist) {\n    free(hist->pts);\n    free(hist->sz);\n    free(hist);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 35
    },
    {
        "index": 147708,
        "code": "static void PromiseMethodWithoutExceptionStateMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"promiseMethodWithoutExceptionState\");\n  ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);\n\n  if (!V8TestObject::HasInstance(info.Holder(), info.GetIsolate())) {\n    exception_state.ThrowTypeError(\"Illegal invocation\");\n    return;\n  }\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  Dictionary arg_1;\n  if (!info[0]->IsNullOrUndefined() && !info[0]->IsObject()) {\n    exception_state.ThrowTypeError(\"parameter 1 ('arg1') is not an object.\");\n    return;\n  }\n  arg_1 = NativeValueTraits<Dictionary>::NativeValue(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n\n  V8SetReturnValue(info, impl->promiseMethodWithoutExceptionState(arg_1).V8Value());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 262
    },
    {
        "index": 48800,
        "code": "static inline struct hlist_head *dev_name_hash(struct net *net, const char *name)\n{\n\tunsigned int hash = full_name_hash(name, strnlen(name, IFNAMSIZ));\n\n\treturn &net->dev_name_head[hash_32(hash, NETDEV_HASHBITS)];\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2016-8666",
        "length": 59
    },
    {
        "index": 152651,
        "code": "bool HTMLFormControlElement::isReadOnly() const {\n  return fastHasAttribute(HTMLNames::readonlyAttr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-1021",
        "cve": "CVE-2017-5016",
        "length": 24
    },
    {
        "index": 165619,
        "code": "void Location::href(USVStringOrTrustedURL& result) const {\n  result.SetUSVString(Url().StrippedForUseAsHref());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2019-5803",
        "length": 35
    },
    {
        "index": 161777,
        "code": "  void PlatformSensorFusionCallback(scoped_refptr<PlatformSensor> sensor) {\n    platform_sensor_fusion_callback_called_ = true;\n    fusion_sensor_ = static_cast<PlatformSensorFusion*>(sensor.get());\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-6057",
        "length": 47
    },
    {
        "index": 169607,
        "code": "int32_t TestURLLoader::Open(const pp::URLRequestInfo& request,\n                            bool trusted,\n                            std::string* response_body) {\n  pp::URLLoader loader(instance_);\n  if (trusted)\n    url_loader_trusted_interface_->GrantUniversalAccess(loader.pp_resource());\n\n  {\n    TestCompletionCallback open_callback(instance_->pp_instance(),\n                                         callback_type());\n    open_callback.WaitForResult(\n        loader.Open(request, open_callback.GetCallback()));\n    if (open_callback.result() != PP_OK)\n      return open_callback.result();\n  }\n\n  int32_t bytes_read = 0;\n  do {\n    char buffer[1024];\n    TestCompletionCallback read_callback(instance_->pp_instance(),\n                                         callback_type());\n    read_callback.WaitForResult(loader.ReadResponseBody(\n        &buffer, sizeof(buffer), read_callback.GetCallback()));\n    bytes_read = read_callback.result();\n    if (bytes_read < 0)\n      return bytes_read;\n    if (response_body)\n      response_body->append(std::string(buffer, bytes_read));\n  } while (bytes_read > 0);\n\n  return PP_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-1675",
        "length": 222
    },
    {
        "index": 93589,
        "code": "nvmet_fc_abort_op(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tstruct nvmet_fc_fcp_iod *fod)\n{\n\tstruct nvmefc_tgt_fcp_req *fcpreq = fod->fcpreq;\n\n\t/* data no longer needed */\n\tnvmet_fc_free_tgt_pgs(fod);\n\n\t/*\n\t * if an ABTS was received or we issued the fcp_abort early\n\t * don't call abort routine again.\n\t */\n\t/* no need to take lock - lock was taken earlier to get here */\n\tif (!fod->aborted)\n\t\ttgtport->ops->fcp_abort(&tgtport->fc_target_port, fcpreq);\n\n\tnvmet_fc_free_fcp_iod(fod->queue, fod);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18379",
        "length": 161
    },
    {
        "index": 47672,
        "code": "static inline int err_block_err(int ret)\n{\n\tif (ret && ret != -ENOSPC && ret != -ENODATA && ret != -EAGAIN)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10088",
        "length": 45
    },
    {
        "index": 153820,
        "code": "void GLES2Implementation::StencilThenCoverStrokePathInstancedCHROMIUM(\n    GLsizei num_paths,\n    GLenum path_name_type,\n    const GLvoid* paths,\n    GLuint path_base,\n    GLint ref,\n    GLuint mask,\n    GLenum cover_mode,\n    GLenum transform_type,\n    const GLfloat* transform_values) {\n  GPU_CLIENT_SINGLE_THREAD_CHECK();\n  GPU_CLIENT_LOG(\"[\" << GetLogPrefix()\n                     << \"] glStencilThenCoverStrokePathInstancedCHROMIUM(\"\n                     << num_paths << \", \" << path_name_type << \", \" << paths\n                     << \", \" << path_base << \", \" << cover_mode << \", \" << ref\n                     << \", \" << mask << \", \" << transform_type << \", \"\n                     << transform_values << \")\");\n\n  ScopedTransferBufferPtr buffer(helper_, transfer_buffer_);\n  uint32_t paths_shm_id = 0;\n  uint32_t paths_offset = 0;\n  uint32_t transforms_shm_id = 0;\n  uint32_t transforms_offset = 0;\n  if (!PrepareInstancedPathCommand(\n          \"glStencilThenCoverStrokePathInstancedCHROMIUM\", num_paths,\n          path_name_type, paths, transform_type, transform_values, &buffer,\n          &paths_shm_id, &paths_offset, &transforms_shm_id,\n          &transforms_offset)) {\n    return;\n  }\n\n  helper_->StencilThenCoverStrokePathInstancedCHROMIUM(\n      num_paths, path_name_type, paths_shm_id, paths_offset, path_base, ref,\n      mask, cover_mode, transform_type, transforms_shm_id, transforms_offset);\n\n  CheckGLError();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 344
    },
    {
        "index": 1032,
        "code": "void GfxDeviceCMYKColorSpace::getDefaultColor(GfxColor *color) {\n  color->c[0] = 0;\n  color->c[1] = 0;\n  color->c[2] = 0;\n  color->c[3] = gfxColorComp1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2009-3605",
        "length": 66
    },
    {
        "index": 107807,
        "code": "void Browser::OpenSyncMyBookmarksDialog() {\n  sync_ui_util::OpenSyncMyBookmarksDialog(\n      profile_, ProfileSyncService::START_FROM_WRENCH);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 38
    },
    {
        "index": 142092,
        "code": "unsigned __stdcall CGaiaCredentialBase::WaitForLoginUI(void* param) {\n  USES_CONVERSION;\n  DCHECK(param);\n  std::unique_ptr<UIProcessInfo> uiprocinfo(\n      reinterpret_cast<UIProcessInfo*>(param));\n\n  base::win::ScopedCOMInitializer com_initializer(\n      base::win::ScopedCOMInitializer::kMTA);\n  if (!com_initializer.Succeeded()) {\n    HRESULT hr = HRESULT_FROM_WIN32(::GetLastError());\n    LOGFN(ERROR) << \"ScopedCOMInitializer failed hr=\" << putHR(hr);\n    return hr;\n  }\n\n  CComBSTR status_text;\n  DWORD exit_code;\n  std::string json_result;\n  HRESULT hr = WaitForLoginUIAndGetResult(uiprocinfo.get(), &json_result,\n                                          &exit_code, &status_text);\n  if (SUCCEEDED(hr)) {\n    hr = uiprocinfo->credential->OnUserAuthenticated(\n        CComBSTR(A2COLE(json_result.c_str())), &status_text);\n  }\n\n  if (FAILED(hr) && exit_code != kUiecKilled) {\n    if (hr != E_ABORT)\n      LOGFN(ERROR) << \"WaitForLoginUIAndGetResult hr=\" << putHR(hr);\n\n    LONG sts = hr == E_ABORT ? STATUS_SUCCESS : HRESULT_CODE(hr);\n\n    DCHECK(sts == STATUS_SUCCESS || status_text != nullptr);\n    hr = uiprocinfo->credential->ReportError(sts, STATUS_SUCCESS, status_text);\n    if (FAILED(hr))\n      LOGFN(ERROR) << \"uiprocinfo->credential->ReportError hr=\" << putHR(hr);\n  }\n\n  LOGFN(INFO) << \"done\";\n  return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5189",
        "length": 354
    },
    {
        "index": 25947,
        "code": "pgtable_bad(struct pt_regs *regs, unsigned long error_code,\n\t    unsigned long address)\n{\n\tstruct task_struct *tsk;\n\tunsigned long flags;\n\tint sig;\n\n\tflags = oops_begin();\n\ttsk = current;\n\tsig = SIGKILL;\n\n\tprintk(KERN_ALERT \"%s: Corrupted page table at address %lx\\n\",\n\t       tsk->comm, address);\n\tdump_pagetable(address);\n\n\ttsk->thread.cr2\t\t= address;\n\ttsk->thread.trap_no\t= 14;\n\ttsk->thread.error_code\t= error_code;\n\n\tif (__die(\"Bad pagetable\", regs, error_code))\n\t\tsig = 0;\n\n\toops_end(flags, regs, sig);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 145
    },
    {
        "index": 176312,
        "code": " static Maybe<bool> IncludesValueImpl(Isolate* isolate,\n Handle<JSObject> receiver,\n Handle<Object> value,\n uint32_t start_from, uint32_t length) {\n    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));\n DisallowHeapAllocation no_gc;\n\n if (WasNeutered(*receiver)) {\n return Just(value->IsUndefined(isolate) && length > start_from);\n }\n\n BackingStore* elements = BackingStore::cast(receiver->elements());\n if (value->IsUndefined(isolate) &&\n        length > static_cast<uint32_t>(elements->length())) {\n return Just(true);\n }\n if (!value->IsNumber()) return Just(false);\n\n double search_value = value->Number();\n\n if (!std::isfinite(search_value)) {\n if (AccessorClass::kind() < FLOAT32_ELEMENTS ||\n AccessorClass::kind() > FLOAT64_ELEMENTS) {\n return Just(false);\n }\n } else if (search_value < std::numeric_limits<ctype>::lowest() ||\n               search_value > std::numeric_limits<ctype>::max()) {\n return Just(false);\n }\n\n if (static_cast<uint32_t>(elements->length()) < length) {\n      length = elements->length();\n }\n\n if (!std::isnan(search_value)) {\n for (uint32_t k = start_from; k < length; ++k) {\n double element_k = elements->get_scalar(k);\n if (element_k == search_value) return Just(true);\n }\n return Just(false);\n } else {\n for (uint32_t k = start_from; k < length; ++k) {\n double element_k = elements->get_scalar(k);\n if (std::isnan(element_k)) return Just(true);\n }\n return Just(false);\n }\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-9490",
        "length": 348
    },
    {
        "index": 58872,
        "code": "ioeventfd_check_collision(struct kvm *kvm, struct _ioeventfd *p)\n{\n\tstruct _ioeventfd *_p;\n\n\tlist_for_each_entry(_p, &kvm->ioeventfds, list)\n\t\tif (_p->bus_idx == p->bus_idx &&\n\t\t    _p->addr == p->addr &&\n\t\t    (!_p->length || !p->length ||\n\t\t     (_p->length == p->length &&\n\t\t      (_p->wildcard || p->wildcard ||\n\t\t       _p->datamatch == p->datamatch))))\n\t\t\treturn true;\n\n\treturn false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-1000252",
        "length": 124
    },
    {
        "index": 28740,
        "code": "static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6376",
        "length": 302
    },
    {
        "index": 17008,
        "code": "void WebContext::setHostMappingRules(const QStringList& rules) {\n  DCHECK(!IsInitialized());\n\n  construct_props_->host_mapping_rules.clear();\n\n  for (QStringList::const_iterator it = rules.cbegin();\n       it != rules.cend(); ++it) {\n    construct_props_->host_mapping_rules.push_back((*it).toStdString());\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1586",
        "length": 73
    },
    {
        "index": 56452,
        "code": "static void show_instructions(struct pt_regs *regs)\n{\n\tint i;\n\tunsigned long pc = regs->nip - (instructions_to_print * 3 / 4 *\n\t\t\tsizeof(int));\n\n\tprintk(\"Instruction dump:\");\n\n\tfor (i = 0; i < instructions_to_print; i++) {\n\t\tint instr;\n\n\t\tif (!(i % 8))\n\t\t\tprintk(\"\\n\");\n\n#if !defined(CONFIG_BOOKE)\n\t\t/* If executing with the IMMU off, adjust pc rather\n\t\t * than print XXXXXXXX.\n\t\t */\n\t\tif (!(regs->msr & MSR_IR))\n\t\t\tpc = (unsigned long)phys_to_virt(pc);\n#endif\n\n\t\tif (!__kernel_text_address(pc) ||\n\t\t     probe_kernel_address((unsigned int __user *)pc, instr)) {\n\t\t\tprintk(KERN_CONT \"XXXXXXXX \");\n\t\t} else {\n\t\t\tif (regs->nip == pc)\n\t\t\t\tprintk(KERN_CONT \"<%08x> \", instr);\n\t\t\telse\n\t\t\t\tprintk(KERN_CONT \"%08x \", instr);\n\t\t}\n\n\t\tpc += sizeof(int);\n\t}\n\n\tprintk(\"\\n\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2015-8845",
        "length": 222
    },
    {
        "index": 179969,
        "code": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}\n",
        "line": "{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}\n",
        "label": 1,
        "cwe": "CWE-17",
        "cve": "CVE-2014-8172",
        "length": 37
    },
    {
        "index": 80760,
        "code": "GF_Err href_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextHyperTextBox*p = (GF_TextHyperTextBox*)a;\n\tgf_isom_box_dump_start(a, \"TextHyperTextBox\", trace);\n\tfprintf(trace, \"startcharoffset=\\\"%d\\\" endcharoffset=\\\"%d\\\" URL=\\\"%s\\\" altString=\\\"%s\\\">\\n\", p->startcharoffset, p->endcharoffset, p->URL ? p->URL : \"NULL\", p->URL_hint ? p->URL_hint : \"NULL\");\n\tgf_isom_box_dump_done(\"TextHyperTextBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 131
    },
    {
        "index": 75309,
        "code": "int stb_vorbis_get_frame_float(stb_vorbis *f, int *channels, float ***output)\n{\n   int len, right,left,i;\n   if (IS_PUSH_MODE(f)) return error(f, VORBIS_invalid_api_mixing);\n\n   if (!vorbis_decode_packet(f, &len, &left, &right)) {\n      f->channel_buffer_start = f->channel_buffer_end = 0;\n      return 0;\n   }\n\n   len = vorbis_finish_frame(f, len, left, right);\n   for (i=0; i < f->channels; ++i)\n      f->outputs[i] = f->channel_buffers[i] + left;\n\n   f->channel_buffer_start = left;\n   f->channel_buffer_end   = left+len;\n\n   if (channels) *channels = f->channels;\n   if (output)   *output = f->outputs;\n   return len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1000050",
        "length": 195
    },
    {
        "index": 93845,
        "code": "virDomainManagedSaveRemove(virDomainPtr dom, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(dom, \"flags=%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    conn = dom->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainManagedSaveRemove) {\n        int ret;\n\n        ret = conn->driver->domainManagedSaveRemove(dom, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10746",
        "length": 140
    },
    {
        "index": 96894,
        "code": "static long vmsplice_to_pipe(struct file *file, struct iov_iter *iter,\n\t\t\t     unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret = 0;\n\tunsigned buf_flag = 0;\n\n\tif (flags & SPLICE_F_GIFT)\n\t\tbuf_flag = PIPE_BUF_FLAG_GIFT;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tpipe_lock(pipe);\n\tret = wait_for_space(pipe, flags);\n\tif (!ret)\n\t\tret = iter_to_pipe(iter, pipe, buf_flag);\n\tpipe_unlock(pipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(pipe);\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "length": 138
    },
    {
        "index": 5066,
        "code": "InitBuffer(Buffer *b)\n{\n    b->room = INIT_BUFFER_SIZE;\n    b->used = 0;\n    b->buff = (char *)malloc(INIT_BUFFER_SIZE*sizeof(char));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-0465",
        "length": 42
    },
    {
        "index": 76166,
        "code": "install_sublevel(void)\n{\n\tsublevel++;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2018-19044",
        "length": 11
    },
    {
        "index": 123937,
        "code": "void RenderViewImpl::SetDeviceScaleFactor(float device_scale_factor) {\n  RenderWidget::SetDeviceScaleFactor(device_scale_factor);\n  if (webview()) {\n    webview()->setDeviceScaleFactor(device_scale_factor);\n    webview()->settings()->setAcceleratedCompositingForFixedPositionEnabled(\n        ShouldUseFixedPositionCompositing(device_scale_factor_));\n  }\n  if (auto_resize_mode_)\n    AutoResizeCompositor();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0918",
        "length": 92
    },
    {
        "index": 19407,
        "code": "static int efx_probe_channel(struct efx_channel *channel)\n{\n\tstruct efx_tx_queue *tx_queue;\n\tstruct efx_rx_queue *rx_queue;\n\tint rc;\n\n\tnetif_dbg(channel->efx, probe, channel->efx->net_dev,\n\t\t  \"creating channel %d\\n\", channel->channel);\n\n\trc = efx_probe_eventq(channel);\n\tif (rc)\n\t\tgoto fail1;\n\n\tefx_for_each_channel_tx_queue(tx_queue, channel) {\n\t\trc = efx_probe_tx_queue(tx_queue);\n\t\tif (rc)\n\t\t\tgoto fail2;\n\t}\n\n\tefx_for_each_channel_rx_queue(rx_queue, channel) {\n\t\trc = efx_probe_rx_queue(rx_queue);\n\t\tif (rc)\n\t\t\tgoto fail3;\n\t}\n\n\tchannel->n_rx_frm_trunc = 0;\n\n\treturn 0;\n\n fail3:\n\tefx_for_each_channel_rx_queue(rx_queue, channel)\n\t\tefx_remove_rx_queue(rx_queue);\n fail2:\n\tefx_for_each_channel_tx_queue(tx_queue, channel)\n\t\tefx_remove_tx_queue(tx_queue);\n fail1:\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-3412",
        "length": 232
    },
    {
        "index": 33343,
        "code": "static int edge_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tmcr = edge_port->shadow_mcr;\n\tif (set & TIOCM_RTS)\n\t\tmcr |= MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= MCR_LOOPBACK;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~MCR_LOOPBACK;\n\n\tedge_port->shadow_mcr = mcr;\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\trestore_mcr(edge_port, mcr);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-1774",
        "length": 236
    },
    {
        "index": 116134,
        "code": "void ResourceDispatcherHostImpl::FollowDeferredRedirect(\n    int child_id,\n    int request_id,\n    bool has_new_first_party_for_cookies,\n    const GURL& new_first_party_for_cookies) {\n  PendingRequestList::iterator i = pending_requests_.find(\n      GlobalRequestID(child_id, request_id));\n  if (i == pending_requests_.end() || !i->second->status().is_success()) {\n    DVLOG(1) << \"FollowDeferredRedirect for invalid request\";\n    return;\n  }\n\n  if (has_new_first_party_for_cookies)\n    i->second->set_first_party_for_cookies(new_first_party_for_cookies);\n  i->second->FollowDeferredRedirect();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3106",
        "length": 142
    },
    {
        "index": 65844,
        "code": "svcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 69
    },
    {
        "index": 125973,
        "code": "void InitialLoadObserver::Observe(int type,\n                                  const content::NotificationSource& source,\n                                  const content::NotificationDetails& details) {\n  if (type == content::NOTIFICATION_LOAD_START) {\n    if (outstanding_tab_count_ > loading_tabs_.size())\n      loading_tabs_.insert(TabTimeMap::value_type(\n          source.map_key(),\n          TabTime(base::TimeTicks::Now())));\n  } else if (type == content::NOTIFICATION_LOAD_STOP) {\n    if (outstanding_tab_count_ > finished_tabs_.size()) {\n      TabTimeMap::iterator iter = loading_tabs_.find(source.map_key());\n      if (iter != loading_tabs_.end()) {\n        finished_tabs_.insert(source.map_key());\n        iter->second.set_stop_time(base::TimeTicks::Now());\n      }\n    }\n  } else if (type == content::NOTIFICATION_RENDERER_PROCESS_CLOSED) {\n    base::TerminationStatus status =\n        content::Details<content::RenderProcessHost::RendererClosedDetails>(\n            details)->status;\n    switch (status) {\n      case base::TERMINATION_STATUS_NORMAL_TERMINATION:\n        break;\n\n      case base::TERMINATION_STATUS_ABNORMAL_TERMINATION:\n      case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:\n      case base::TERMINATION_STATUS_PROCESS_CRASHED:\n        crashed_tab_count_++;\n        break;\n\n      case base::TERMINATION_STATUS_STILL_RUNNING:\n        LOG(ERROR) << \"Got RENDERER_PROCESS_CLOSED notification, \"\n                   << \"but the process is still running. We may miss further \"\n                   << \"crash notification, resulting in hangs.\";\n        break;\n\n      default:\n        LOG(ERROR) << \"Unhandled termination status \" << status;\n        NOTREACHED();\n        break;\n    }\n  } else {\n    NOTREACHED();\n  }\n\n  if (finished_tabs_.size() + crashed_tab_count_ >= outstanding_tab_count_)\n    ConditionMet();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 399
    },
    {
        "index": 41762,
        "code": "static void addrconf_del_dad_work(struct inet6_ifaddr *ifp)\n{\n\tif (cancel_delayed_work(&ifp->dad_work))\n\t\t__in6_ifa_put(ifp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-8215",
        "length": 44
    },
    {
        "index": 162944,
        "code": "bool IsPortValid(int port) {\n  return port >= 0 && port <= std::numeric_limits<uint16_t>::max();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-6082",
        "length": 29
    },
    {
        "index": 47276,
        "code": "static inline u32 F(u32 x, u32 y, u32 z)\n{\n\treturn (x & y) | ((~x) & z);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 34
    },
    {
        "index": 120545,
        "code": "bool Element::hasPendingResources() const\n{\n    return hasRareData() && elementRareData()->hasPendingResources();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2884",
        "length": 27
    },
    {
        "index": 159282,
        "code": "bool DownloadManagerDelegate::DetermineDownloadTarget(\n    DownloadItem* item,\n    const DownloadTargetCallback& callback) {\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6033",
        "length": 31
    },
    {
        "index": 160023,
        "code": "void BackendImpl::DestroyInvalidEntry(EntryImpl* entry) {\n  LOG(WARNING) << \"Destroying invalid entry.\";\n  Trace(\"Destroying invalid entry 0x%p\", entry);\n\n  entry->SetPointerForInvalidEntry(GetCurrentEntryId());\n\n  eviction_.OnDoomEntry(entry);\n  entry->InternalDoom();\n\n  if (!new_eviction_)\n    DecreaseNumEntries();\n  stats_.OnEvent(Stats::INVALID_ENTRY);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6085",
        "length": 95
    },
    {
        "index": 118897,
        "code": "base::TimeTicks WebContentsImpl::GetLastSelectedTime() const {\n  return last_selected_time_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6626",
        "length": 23
    },
    {
        "index": 113022,
        "code": "void DownloadItemImpl::Delegate::Detach() {\n  DCHECK_LT(0, count_);\n  --count_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2895",
        "length": 24
    },
    {
        "index": 74181,
        "code": "free_config_auth(\n\tconfig_tree *ptree\n\t)\n{\n\tdestroy_attr_val_fifo(ptree->auth.crypto_cmd_list);\n\tptree->auth.crypto_cmd_list = NULL;\n\tdestroy_attr_val_fifo(ptree->auth.trusted_key_list);\n\tptree->auth.trusted_key_list = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-5195",
        "length": 63
    },
    {
        "index": 49338,
        "code": "static int fwnet_open(struct net_device *net)\n{\n\tstruct fwnet_device *dev = netdev_priv(net);\n\tint ret;\n\n\tret = fwnet_broadcast_start(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_start_queue(net);\n\n\tspin_lock_irq(&dev->lock);\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8633",
        "length": 80
    },
    {
        "index": 166989,
        "code": "void CSSStyleSheet::WillMutateRules() {\n  if (!contents_->IsUsedFromTextCache() &&\n      !contents_->IsReferencedFromResource()) {\n    contents_->ClearRuleSet();\n    contents_->SetMutable();\n    return;\n  }\n  DCHECK(contents_->IsCacheableForStyleElement() ||\n         contents_->IsCacheableForResource());\n\n  contents_->UnregisterClient(this);\n  contents_ = contents_->Copy();\n  contents_->RegisterClient(this);\n\n  contents_->SetMutable();\n\n  ReattachChildRuleCSSOMWrappers();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-6164",
        "length": 112
    },
    {
        "index": 92925,
        "code": "cliprdr_set_mode(const char *optarg)\n{\n\tui_clip_set_mode(optarg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-20182",
        "length": 20
    },
    {
        "index": 107690,
        "code": "Eina_Bool ewk_view_zoom_animated_mark_stop(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    _ewk_view_zoom_animated_mark_stop(smartData);\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 58
    },
    {
        "index": 121271,
        "code": "bool HTMLInputElement::shouldAppearChecked() const\n{\n    return checked() && m_inputType->isCheckable();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2871",
        "length": 26
    },
    {
        "index": 95335,
        "code": "psf_get_date_str (char *str, int maxlen)\n{\ttime_t\t\tcurrent ;\n\tstruct tm\ttimedata, *tmptr ;\n\n\ttime (&current) ;\n\n#if defined (HAVE_GMTIME_R)\n\t/* If the re-entrant version is available, use it. */\n\ttmptr = gmtime_r (&current, &timedata) ;\n#elif defined (HAVE_GMTIME)\n\t/* Otherwise use the standard one and copy the data to local storage. */\n\ttmptr = gmtime (&current) ;\n\tmemcpy (&timedata, tmptr, sizeof (timedata)) ;\n#else\n\ttmptr = NULL ;\n#endif\n\n\tif (tmptr)\n\t\tsnprintf (str, maxlen, \"%4d-%02d-%02d %02d:%02d:%02d UTC\",\n\t\t\t1900 + timedata.tm_year, timedata.tm_mon, timedata.tm_mday,\n\t\t\ttimedata.tm_hour, timedata.tm_min, timedata.tm_sec) ;\n\telse\n\t\tsnprintf (str, maxlen, \"Unknown date\") ;\n\n\treturn ;\n} /* psf_get_date_str */\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7586",
        "length": 224
    },
    {
        "index": 107792,
        "code": "FindBarController* Browser::GetFindBarController() {\n  if (!find_bar_controller_.get()) {\n    FindBar* find_bar = BrowserWindow::CreateFindBar(this);\n    find_bar_controller_.reset(new FindBarController(find_bar));\n    find_bar->SetFindBarController(find_bar_controller_.get());\n    find_bar_controller_->ChangeTabContents(GetSelectedTabContents());\n    find_bar_controller_->find_bar()->MoveWindowIfNecessary(gfx::Rect(), true);\n  }\n  return find_bar_controller_.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 105
    },
    {
        "index": 119236,
        "code": "PassRefPtr<HTMLFormElement> HTMLFormElement::create(Document& document)\n{\n    UseCounter::count(&document, UseCounter::FormElement);\n    return adoptRef(new HTMLFormElement(formTag, document));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2927",
        "length": 45
    },
    {
        "index": 74903,
        "code": "int ff_mms_read_header(MMSContext *mms, uint8_t *buf, const int size)\n{\n    char *pos;\n    int size_to_copy;\n    int remaining_size = mms->asf_header_size - mms->asf_header_read_size;\n    size_to_copy = FFMIN(size, remaining_size);\n    pos = mms->asf_header + mms->asf_header_read_size;\n    memcpy(buf, pos, size_to_copy);\n    if (mms->asf_header_read_size == mms->asf_header_size) {\n        av_freep(&mms->asf_header); // which contains asf header\n    }\n    mms->asf_header_read_size += size_to_copy;\n    return size_to_copy;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-1999010",
        "length": 162
    },
    {
        "index": 59814,
        "code": "static int hid_resume_common(struct hid_device *hid, bool driver_suspended)\n{\n\tint status = 0;\n\n\thid_restart_io(hid);\n\tif (driver_suspended && hid->driver && hid->driver->resume)\n\t\tstatus = hid->driver->resume(hid);\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-16533",
        "length": 62
    },
    {
        "index": 1312,
        "code": "char *copyString(char *s) {\n  char *s1;\n\n  s1 = (char *)gmalloc(strlen(s) + 1);\n  strcpy(s1, s);\n  return s1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2009-3604",
        "length": 45
    },
    {
        "index": 110729,
        "code": "void AutocompleteInput::Clear() {\n  text_.clear();\n  type_ = INVALID;\n  parts_ = url_parse::Parsed();\n  scheme_.clear();\n  desired_tld_.clear();\n  prevent_inline_autocomplete_ = false;\n  prefer_keyword_ = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 58
    },
    {
        "index": 34148,
        "code": "static void ccid3_hc_rx_get_info(struct sock *sk, struct tcp_info *info)\n{\n\tinfo->tcpi_ca_state = ccid3_hc_rx_sk(sk)->rx_state;\n\tinfo->tcpi_options  |= TCPI_OPT_TIMESTAMPS;\n\tinfo->tcpi_rcv_rtt  = ccid3_hc_rx_sk(sk)->rx_rtt;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2012-6541",
        "length": 81
    },
    {
        "index": 138106,
        "code": "AXObject* AXNodeObject::rawNextSibling() const {\n  if (!getNode())\n    return 0;\n\n  Node* nextSibling = getNode()->nextSibling();\n  if (!nextSibling)\n    return 0;\n\n  return axObjectCache().getOrCreate(nextSibling);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 58
    },
    {
        "index": 169937,
        "code": "xsltUTF8Size(xmlChar *utf) {\n    xmlChar mask;\n    int len;\n\n    if (utf == NULL)\n        return -1;\n    if (*utf < 0x80)\n        return 1;\n    /* check valid UTF8 character */\n    if (!(*utf & 0x40))\n        return -1;\n    /* determine number of bytes in char */\n    len = 2;\n    for (mask=0x20; mask != 0; mask>>=1) {\n        if (!(*utf & mask))\n            return len;\n        len++;\n    }\n    return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 130
    },
    {
        "index": 60959,
        "code": "nautilus_directory_add_file_to_work_queue (NautilusDirectory *directory,\n                                           NautilusFile      *file)\n{\n    g_return_if_fail (file->details->directory == directory);\n\n    nautilus_file_queue_enqueue (directory->details->high_priority_queue,\n                                 file);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-14604",
        "length": 58
    },
    {
        "index": 146866,
        "code": "void Document::UpdateStyleAndLayoutTreeForNode(const Node* node) {\n  DCHECK(node);\n  if (!NeedsLayoutTreeUpdateForNode(*node))\n    return;\n  UpdateStyleAndLayoutTree();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 44
    },
    {
        "index": 93463,
        "code": "static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)\n{\n\tif (tx_path)\n\t\treturn skb->ip_summed != CHECKSUM_PARTIAL;\n\n\treturn skb->ip_summed == CHECKSUM_NONE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-7191",
        "length": 49
    },
    {
        "index": 173093,
        "code": "gpc_sG(Pixel *out, const Pixel *in, const Background *back)\n{\n (void)back;\n\n   out->r = out->g = out->b = sRGB(YfromRGBint(in->r, in->g, in->b)/65535);\n   out->a = 255;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 69
    },
    {
        "index": 38478,
        "code": "static inline u8 cma_get_ip_ver(struct cma_hdr *hdr)\n{\n\treturn hdr->ip_version >> 4;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2739",
        "length": 28
    },
    {
        "index": 21263,
        "code": "void tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)\n{\n\tstruct mmu_gather_batch *batch, *next;\n\n\ttlb_flush_mmu(tlb);\n\n\t/* keep the page table cache within bounds */\n\tcheck_pgt_cache();\n\n\tfor (batch = tlb->local.next; batch; batch = next) {\n\t\tnext = batch->next;\n\t\tfree_pages((unsigned long)batch, 0);\n\t}\n\ttlb->local.next = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-1179",
        "length": 107
    },
    {
        "index": 77085,
        "code": "parse_UNROLL_XLATE(char *arg OVS_UNUSED, struct ofpbuf *ofpacts OVS_UNUSED,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n    return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-17206",
        "length": 53
    },
    {
        "index": 18043,
        "code": "jbig2_huffman_free(Jbig2Ctx *ctx, Jbig2HuffmanState *hs)\n{\n    if (hs != NULL)\n        jbig2_free(ctx->allocator, hs);\n    return;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9601",
        "length": 46
    },
    {
        "index": 162067,
        "code": "RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(\n    BrowserContext* browser_context,\n    StoragePartitionImpl* storage_partition_impl,\n    SiteInstance* site_instance,\n    bool is_for_guests_only) {\n  if (g_render_process_host_factory_) {\n    return g_render_process_host_factory_->CreateRenderProcessHost(\n        browser_context, site_instance);\n  }\n\n  if (!storage_partition_impl) {\n    storage_partition_impl = static_cast<StoragePartitionImpl*>(\n        BrowserContext::GetStoragePartition(browser_context, site_instance));\n  }\n  if (is_for_guests_only && site_instance &&\n      storage_partition_impl->site_for_service_worker().is_empty()) {\n    storage_partition_impl->set_site_for_service_worker(\n        site_instance->GetSiteURL());\n  }\n\n  return new RenderProcessHostImpl(browser_context, storage_partition_impl,\n                                   is_for_guests_only);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 184
    },
    {
        "index": 159084,
        "code": " void ChromeDownloadManagerDelegate::ShowDownloadInShell(\n     DownloadItem* download) {\n   if (!download->CanShowInFolder())\n    return;\n\n  MaybeSendDangerousDownloadOpenedReport(download,\n                                         true /* show_download_in_folder */);\n\n  base::FilePath platform_path(\n      GetPlatformDownloadPath(profile_, download, PLATFORM_CURRENT_PATH));\n  DCHECK(!platform_path.empty());\n  platform_util::ShowItemInFolder(profile_, platform_path);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6033",
        "length": 92
    },
    {
        "index": 136471,
        "code": "int PropertyTreeManager::EnsureCompositorClipNode(\n    const ClipPaintPropertyNode* clip_node) {\n  DCHECK(clip_node);\n  if (!clip_node)\n    return kSecondaryRootNodeId;\n\n  auto it = clip_node_map_.find(clip_node);\n  if (it != clip_node_map_.end())\n    return it->value;\n\n  int parent_id = EnsureCompositorClipNode(clip_node->Parent());\n  int id = GetClipTree().Insert(cc::ClipNode(), parent_id);\n\n  cc::ClipNode& compositor_node = *GetClipTree().Node(id);\n\n  compositor_node.clip = clip_node->ClipRect().Rect();\n  compositor_node.transform_id =\n      EnsureCompositorTransformNode(clip_node->LocalTransformSpace());\n  compositor_node.clip_type = cc::ClipNode::ClipType::APPLIES_LOCAL_CLIP;\n\n  auto result = clip_node_map_.Set(clip_node, id);\n  DCHECK(result.is_new_entry);\n  GetClipTree().set_needs_update(true);\n  return id;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 217
    },
    {
        "index": 59691,
        "code": "RBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif ( o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-16805",
        "length": 115
    },
    {
        "index": 131780,
        "code": "static void testInterfaceEmptyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValueFast(info, WTF::getPtr(imp->testInterfaceEmptyAttribute()), imp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 66
    },
    {
        "index": 138882,
        "code": "size_t WallpaperManager::GetPendingListSizeForTesting() const {\n  return loading_.size();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-1285",
        "length": 22
    },
    {
        "index": 43337,
        "code": "void CLASS parse_external_jpeg()\n{\n  const char *file, *ext;\n  char *jname, *jfile, *jext;\n  FILE *save=ifp;\n\n  ext  = strrchr (ifname, '.');\n  file = strrchr (ifname, '/');\n  if (!file) file = strrchr (ifname, '\\\\');\n  if (!file) file = ifname-1;\n  file++;\n  if (!ext || strlen(ext) != 4 || ext-file != 8) return;\n  jname = (char *) malloc (strlen(ifname) + 1);\n  merror (jname, \"parse_external_jpeg()\");\n  strcpy (jname, ifname);\n  jfile = file - ifname + jname;\n  jext  = ext  - ifname + jname;\n  if (strcasecmp (ext, \".jpg\")) {\n    strcpy (jext, isupper(ext[1]) ? \".JPG\":\".jpg\");\n    if (isdigit(*file)) {\n      memcpy (jfile, file+4, 4);\n      memcpy (jfile+4, file, 4);\n    }\n  } else\n    while (isdigit(*--jext)) {\n      if (*jext != '9') {\n\t(*jext)++;\n\tbreak;\n      }\n      *jext = '0';\n    }\n  if (strcmp (jname, ifname)) {\n    if ((ifp = fopen (jname, \"rb\"))) {\n      dcraw_message (DCRAW_VERBOSE,_(\"Reading metadata from %s ...\\n\"), jname);\n      parse_tiff (12);\n      thumb_offset = 0;\n      is_raw = 1;\n      fclose (ifp);\n    }\n  }\n  if (!timestamp)\n    dcraw_message (DCRAW_WARNING,_(\"Failed to read metadata from %s\\n\"), jname);\n  free (jname);\n  ifp = save;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2015-3885",
        "length": 406
    },
    {
        "index": 33870,
        "code": "local_notify_destroy_callback(gpointer data)\n{\n    cib_local_notify_t *notify = data;\n\n    free_xml(notify->notify_src);\n    free(notify->client_id);\n    free(notify);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-0281",
        "length": 44
    },
    {
        "index": 84744,
        "code": "static void loop_reread_partitions(struct loop_device *lo,\n\t\t\t\t   struct block_device *bdev)\n{\n\tint rc;\n\n\t/*\n\t * bd_mutex has been held already in release path, so don't\n\t * acquire it if this function is called in such case.\n\t *\n\t * If the reread partition isn't from release path, lo_refcnt\n\t * must be at least one and it can only become zero when the\n\t * current holder is released.\n\t */\n\tif (!atomic_read(&lo->lo_refcnt))\n\t\trc = __blkdev_reread_part(bdev);\n\telse\n\t\trc = blkdev_reread_part(bdev);\n\tif (rc)\n\t\tpr_warn(\"%s: partition scan of loop%d (%s) failed (rc=%d)\\n\",\n\t\t\t__func__, lo->lo_number, lo->lo_file_name, rc);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-5344",
        "length": 185
    },
    {
        "index": 115836,
        "code": "  virtual ~TestSafeBrowsingService() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 11
    },
    {
        "index": 173782,
        "code": "OMX_ERRORTYPE SoftOpus::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch ((int)index) {\n case OMX_IndexParamAudioAndroidOpus:\n {\n            OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =\n (OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;\n\n if (!isValidOMXParam(opusParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (opusParams->nPortIndex != 0) {\n return OMX_ErrorUndefined;\n }\n\n            opusParams->nAudioBandWidth = 0;\n            opusParams->nSampleRate = kRate;\n            opusParams->nBitRate = 0;\n\n if (!isConfigured()) {\n                opusParams->nChannels = 1;\n } else {\n                opusParams->nChannels = mHeader->channels;\n }\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n\n if (!isValidOMXParam(pcmParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (pcmParams->nPortIndex != 1) {\n return OMX_ErrorUndefined;\n }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n            pcmParams->nSamplingRate = kRate;\n\n if (!isConfigured()) {\n                pcmParams->nChannels = 1;\n } else {\n                pcmParams->nChannels = mHeader->channels;\n }\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-2487",
        "length": 417
    },
    {
        "index": 186518,
        "code": "CreateDataReductionProxyChromeIOData(\n    Profile* profile,\n    const scoped_refptr<base::SingleThreadTaskRunner>& io_task_runner,\n    const scoped_refptr<base::SingleThreadTaskRunner>& ui_task_runner) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n   DCHECK(profile);\n   DCHECK(profile->GetPrefs());\n \n  data_reduction_proxy::DataReductionProxySettings*\n      data_reduction_proxy_settings =\n          DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n              profile);\n  bool enabled = data_reduction_proxy_settings &&\n                 data_reduction_proxy_settings->IsDataSaverEnabledByUser();\n \n   std::unique_ptr<data_reduction_proxy::DataReductionProxyIOData>\n       data_reduction_proxy_io_data(\n          new data_reduction_proxy::DataReductionProxyIOData(\n              DataReductionProxyChromeSettings::GetClient(),\n              profile->GetPrefs(), content::GetNetworkConnectionTracker(),\n              io_task_runner, ui_task_runner, enabled, GetUserAgent(),\n              version_info::GetChannelString(chrome::GetChannel())));\n\n  data_reduction_proxy_io_data->set_lofi_decider(\n      std::make_unique<data_reduction_proxy::ContentLoFiDecider>());\n  data_reduction_proxy_io_data->set_resource_type_provider(\n      std::make_unique<data_reduction_proxy::ContentResourceTypeProvider>());\n  data_reduction_proxy_io_data->set_lofi_ui_service(\n      std::make_unique<data_reduction_proxy::ContentLoFiUIService>(\n          ui_task_runner, base::Bind(&OnLoFiResponseReceivedOnUI)));\n\n  return data_reduction_proxy_io_data;\n}\n",
        "line": "  data_reduction_proxy::DataReductionProxySettings*\n      data_reduction_proxy_settings =\n          DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n              profile);\n  bool enabled = data_reduction_proxy_settings &&\n                 data_reduction_proxy_settings->IsDataSaverEnabledByUser();\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5199",
        "length": 326
    },
    {
        "index": 85862,
        "code": "static void clone_endio(struct bio *bio)\n{\n\tblk_status_t error = bio->bi_status;\n\tstruct dm_target_io *tio = container_of(bio, struct dm_target_io, clone);\n\tstruct dm_io *io = tio->io;\n\tstruct mapped_device *md = tio->io->md;\n\tdm_endio_fn endio = tio->ti->type->end_io;\n\n\tif (unlikely(error == BLK_STS_TARGET)) {\n\t\tif (bio_op(bio) == REQ_OP_WRITE_SAME &&\n\t\t    !bio->bi_disk->queue->limits.max_write_same_sectors)\n\t\t\tdisable_write_same(md);\n\t\tif (bio_op(bio) == REQ_OP_WRITE_ZEROES &&\n\t\t    !bio->bi_disk->queue->limits.max_write_zeroes_sectors)\n\t\t\tdisable_write_zeroes(md);\n\t}\n\n\tif (endio) {\n\t\tint r = endio(tio->ti, bio, &error);\n\t\tswitch (r) {\n\t\tcase DM_ENDIO_REQUEUE:\n\t\t\terror = BLK_STS_DM_REQUEUE;\n\t\t\t/*FALLTHRU*/\n\t\tcase DM_ENDIO_DONE:\n\t\t\tbreak;\n\t\tcase DM_ENDIO_INCOMPLETE:\n\t\t\t/* The target will handle the io */\n\t\t\treturn;\n\t\tdefault:\n\t\t\tDMWARN(\"unimplemented target endio return value: %d\", r);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tfree_tio(tio);\n\tdec_pending(io, error);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-18203",
        "length": 305
    },
    {
        "index": 160276,
        "code": "void MimeHandlerViewContainer::OnGuestAttached(int /* unused */,\n                                               int guest_proxy_routing_id) {\n  guest_proxy_routing_id_ = guest_proxy_routing_id;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6089",
        "length": 35
    },
    {
        "index": 124488,
        "code": "LayoutUnit RenderBlock::adjustForUnsplittableChild(RenderBox* child, LayoutUnit logicalOffset, bool includeMargins)\n{\n    bool checkColumnBreaks = view()->layoutState()->isPaginatingColumns() || flowThreadContainingBlock();\n    bool checkPageBreaks = !checkColumnBreaks && view()->layoutState()->pageLogicalHeight();\n    bool isUnsplittable = child->isUnsplittableForPagination() || (checkColumnBreaks && child->style()->columnBreakInside() == PBAVOID)\n        || (checkPageBreaks && child->style()->pageBreakInside() == PBAVOID);\n    if (!isUnsplittable)\n        return logicalOffset;\n    LayoutUnit childLogicalHeight = logicalHeightForChild(child) + (includeMargins ? marginBeforeForChild(child) + marginAfterForChild(child) : LayoutUnit());\n    LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);\n    updateMinimumPageHeight(logicalOffset, childLogicalHeight);\n    if (!pageLogicalHeight || childLogicalHeight > pageLogicalHeight)\n        return logicalOffset;\n    LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);\n    if (remainingLogicalHeight < childLogicalHeight)\n        return logicalOffset + remainingLogicalHeight;\n    return logicalOffset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 277
    },
    {
        "index": 164001,
        "code": "bool ServiceWorkerPaymentInstrument::IsValidForCanMakePayment() const {\n  DCHECK(can_make_payment_result_);\n  if (base::FeatureList::IsEnabled(\n          ::features::kPaymentRequestHasEnrolledInstrument)) {\n    return has_enrolled_instrument_result_;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-5828",
        "length": 62
    },
    {
        "index": 46026,
        "code": "svcauth_gss_destroy(SVCAUTH *auth)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tOM_uint32\t\t min_stat;\n\n\tlog_debug(\"in svcauth_gss_destroy()\");\n\n\tgd = SVCAUTH_PRIVATE(auth);\n\n\tgss_delete_sec_context(&min_stat, &gd->ctx, GSS_C_NO_BUFFER);\n\tgss_release_buffer(&min_stat, &gd->cname);\n\tgss_release_buffer(&min_stat, &gd->checksum);\n\n\tif (gd->client_name)\n\t\tgss_release_name(&min_stat, &gd->client_name);\n\n\tmem_free(gd, sizeof(*gd));\n\tmem_free(auth, sizeof(*auth));\n\n\treturn (TRUE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2014-9423",
        "length": 144
    },
    {
        "index": 170108,
        "code": "  int send_key_event_call_count() const { return send_key_event_call_count_; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1686",
        "length": 19
    },
    {
        "index": 167945,
        "code": "bool LocalFrame::IsCrossOriginSubframe() const {\n  const SecurityOrigin* security_origin =\n      GetSecurityContext()->GetSecurityOrigin();\n  return !security_origin->CanAccess(\n      Tree().Top().GetSecurityContext()->GetSecurityOrigin());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-285",
        "cve": "CVE-2018-16077",
        "length": 53
    },
    {
        "index": 109392,
        "code": "    void setLoader(PassRefPtr<ThreadableLoader> loader)\n    {\n        m_loader = loader;\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 25
    },
    {
        "index": 150634,
        "code": "  ScrollLatencyCompositedScrollbarBrowserTest() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-281",
        "cve": "CVE-2017-5033",
        "length": 13
    },
    {
        "index": 69363,
        "code": "WORK_STATE ossl_statem_client_pre_work(SSL *s, WORK_STATE wst)\n{\n    OSSL_STATEM *st = &s->statem;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        s->shutdown = 0;\n        if (SSL_IS_DTLS(s)) {\n            /* every DTLS ClientHello resets Finished MAC */\n            if (!ssl3_init_finished_mac(s)) {\n                ossl_statem_set_error(s);\n                return WORK_ERROR;\n            }\n        }\n        break;\n\n    case TLS_ST_CW_CHANGE:\n        if (SSL_IS_DTLS(s)) {\n            if (s->hit) {\n                /*\n                 * We're into the last flight so we don't retransmit these\n                 * messages unless we need to.\n                 */\n                st->use_timer = 0;\n            }\n#ifndef OPENSSL_NO_SCTP\n            if (BIO_dgram_is_sctp(SSL_get_wbio(s)))\n                return dtls_wait_for_dry(s);\n#endif\n        }\n        return WORK_FINISHED_CONTINUE;\n\n    case TLS_ST_OK:\n        return tls_finish_handshake(s, wst);\n\n    default:\n        /* No pre work to be done */\n        break;\n    }\n\n    return WORK_FINISHED_CONTINUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-3730",
        "length": 270
    },
    {
        "index": 47950,
        "code": "static int em_pop_sreg(struct x86_emulate_ctxt *ctxt)\n{\n\tint seg = ctxt->src2.val;\n\tunsigned long selector;\n\tint rc;\n\n\trc = emulate_pop(ctxt, &selector, 2);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->modrm_reg == VCPU_SREG_SS)\n\t\tctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;\n\tif (ctxt->op_bytes > 2)\n\t\trsp_increment(ctxt, ctxt->op_bytes - 2);\n\n\trc = load_segment_descriptor(ctxt, (u16)selector, seg);\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-9756",
        "length": 135
    },
    {
        "index": 151521,
        "code": "WorkerFetchContext::~WorkerFetchContext() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 10
    },
    {
        "index": 146745,
        "code": "Node* EventTargetNodeForDocument(Document* doc) {\n  if (!doc)\n    return 0;\n  Node* node = doc->FocusedElement();\n  if (!node && doc->IsPluginDocument()) {\n    PluginDocument* plugin_document = ToPluginDocument(doc);\n    node = plugin_document->PluginNode();\n  }\n  if (!node && doc->IsHTMLDocument())\n    node = doc->body();\n  if (!node)\n    node = doc->documentElement();\n  return node;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 104
    },
    {
        "index": 67809,
        "code": "static int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_info *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\terr = verify_newsa_info(p, attrs);\n\tif (err)\n\t\treturn err;\n\n\tx = xfrm_state_construct(net, p, attrs, &err);\n\tif (!x)\n\t\treturn err;\n\n\txfrm_state_hold(x);\n\tif (nlh->nlmsg_type == XFRM_MSG_NEWSA)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-7184",
        "length": 259
    },
    {
        "index": 134307,
        "code": "void TabStrip::AddMessageLoopObserver() {\n  if (!mouse_watcher_.get()) {\n    mouse_watcher_.reset(\n        new views::MouseWatcher(\n            new views::MouseWatcherViewHost(\n                this, gfx::Insets(0, 0, kTabStripAnimationVSlop, 0)),\n            this));\n  }\n  mouse_watcher_->Start();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 79
    },
    {
        "index": 169090,
        "code": "void ReportInitializationAttemptsSpent(int attempts_spent) {\n  UMA_HISTOGRAM_EXACT_LINEAR(\"OfflinePages.Model.InitAttemptsSpent\",\n                             attempts_spent, kInitializeAttemptsMax);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6144",
        "length": 43
    },
    {
        "index": 97538,
        "code": "void ProfileSyncComponentsFactoryImpl::RegisterCommonDataTypes(\n    ProfileSyncService* pss) {\n  if (!command_line_->HasSwitch(switches::kDisableSyncAutofill)) {\n    pss->RegisterDataTypeController(\n        new AutofillDataTypeController(this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncAutofillProfile)) {\n    pss->RegisterDataTypeController(\n        new AutofillProfileDataTypeController(this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncBookmarks)) {\n    pss->RegisterDataTypeController(\n        new BookmarkDataTypeController(this, profile_, pss));\n  }\n\n  if (!profile_->GetPrefs()->GetBoolean(prefs::kSavingBrowserHistoryDisabled) &&\n      !command_line_->HasSwitch(switches::kDisableSyncTypedUrls)) {\n    pss->RegisterDataTypeController(\n        new TypedUrlDataTypeController(this, profile_, pss));\n  }\n\n  if (command_line_->HasSwitch(switches::kHistoryEnableFullHistorySync) &&\n      !command_line_->HasSwitch(\n          switches::kDisableSyncHistoryDeleteDirectives)) {\n    pss->RegisterDataTypeController(\n        new UIDataTypeController(\n            syncer::HISTORY_DELETE_DIRECTIVES, this, profile_, pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncTabs)) {\n    pss->RegisterDataTypeController(\n        new ProxyDataTypeController(syncer::PROXY_TABS));\n    pss->RegisterDataTypeController(\n        new SessionDataTypeController(this, profile_, pss));\n  }\n\n  if (command_line_->HasSwitch(switches::kEnableSyncFavicons)) {\n    pss->RegisterDataTypeController(\n        new UIDataTypeController(syncer::FAVICON_IMAGES,\n                                 this,\n                                 profile_,\n                                 pss));\n    pss->RegisterDataTypeController(\n        new UIDataTypeController(syncer::FAVICON_TRACKING,\n                                 this,\n                                 profile_,\n                                 pss));\n  }\n\n  if (!command_line_->HasSwitch(switches::kDisableSyncPasswords)) {\n    pss->RegisterDataTypeController(\n        new PasswordDataTypeController(this, profile_, pss));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 475
    },
    {
        "index": 136382,
        "code": "bool PaintArtifactCompositor::PendingLayer::CanMerge(\n    const PendingLayer& guest) const {\n  if (requires_own_layer || guest.requires_own_layer)\n    return false;\n  if (property_tree_state.Effect() != guest.property_tree_state.Effect())\n    return false;\n  return CanUpcastTo(guest.property_tree_state, property_tree_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 76
    },
    {
        "index": 120887,
        "code": "  explicit InlineLoginUIHandler(Profile* profile) : profile_(profile) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-2879",
        "length": 17
    },
    {
        "index": 7181,
        "code": "    Private() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-290",
        "cve": "CVE-2017-8422",
        "length": 5
    },
    {
        "index": 25833,
        "code": "static void intel_pmu_disable_bts(void)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tunsigned long debugctlmsr;\n\n\tif (!cpuc->ds)\n\t\treturn;\n\n\tdebugctlmsr = get_debugctlmsr();\n\n\tdebugctlmsr &=\n\t\t~(DEBUGCTLMSR_TR | DEBUGCTLMSR_BTS | DEBUGCTLMSR_BTINT |\n\t\t  DEBUGCTLMSR_BTS_OFF_OS | DEBUGCTLMSR_BTS_OFF_USR);\n\n\tupdate_debugctlmsr(debugctlmsr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 118
    },
    {
        "index": 76945,
        "code": "format_SET_FIELD(const struct ofpact_set_field *a, struct ds *s)\n{\n    if (a->ofpact.raw == NXAST_RAW_REG_LOAD) {\n        struct mf_subfield dst;\n        uint64_t value;\n\n        dst.ofs = dst.n_bits = 0;\n        while (next_load_segment(a, &dst, &value)) {\n            ds_put_format(s, \"%sload:%s%#\"PRIx64\"%s->%s\",\n                          colors.special, colors.end, value,\n                          colors.special, colors.end);\n            mf_format_subfield(&dst, s);\n            ds_put_char(s, ',');\n        }\n        ds_chomp(s, ',');\n    } else {\n        ds_put_format(s, \"%sset_field:%s\", colors.special, colors.end);\n        mf_format(a->field, a->value, ofpact_set_field_mask(a), s);\n        ds_put_format(s, \"%s->%s%s\",\n                      colors.special, colors.end, a->field->name);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-17206",
        "length": 216
    },
    {
        "index": 118409,
        "code": "WebURLResponseExtraDataImpl* GetExtraDataFromResponse(\n    const WebURLResponse& response) {\n  return static_cast<WebURLResponseExtraDataImpl*>(response.extraData());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-6621",
        "length": 40
    },
    {
        "index": 132049,
        "code": "void LayoutBlockFlow::clearShouldBreakAtLineToAvoidWidow() const\n{\n    ASSERT(shouldBreakAtLineToAvoidWidow());\n    if (!m_rareData)\n        return;\n\n    m_rareData->m_lineBreakToAvoidWidow = -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2014-1715",
        "length": 63
    },
    {
        "index": 167901,
        "code": "Document* Document::open(LocalDOMWindow* entered_window,\n                         const AtomicString& type,\n                         const AtomicString& replace,\n                         ExceptionState& exception_state) {\n  open(entered_window->document(), exception_state);\n  return this;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-285",
        "cve": "CVE-2018-16077",
        "length": 51
    },
    {
        "index": 109174,
        "code": "void RenderViewImpl::willClose(WebFrame* frame) {\n  FOR_EACH_OBSERVER(RenderViewObserver, observers_, FrameWillClose(frame));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 32
    },
    {
        "index": 141306,
        "code": "Range* Document::caretRangeFromPoint(int x, int y) {\n  if (!GetLayoutView())\n    return nullptr;\n\n  HitTestResult result = HitTestInDocument(this, x, y);\n  PositionWithAffinity position_with_affinity = result.GetPosition();\n  if (position_with_affinity.IsNull())\n    return nullptr;\n\n  Position range_compliant_position =\n      position_with_affinity.GetPosition().ParentAnchoredEquivalent();\n  return CreateRangeAdjustedToTreeScope(*this, range_compliant_position);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5170",
        "length": 108
    },
    {
        "index": 26157,
        "code": "perf_read_hw(struct perf_event *event, char __user *buf, size_t count)\n{\n\tu64 read_format = event->attr.read_format;\n\tint ret;\n\n\t/*\n\t * Return end-of-file for a read on a event that is in\n\t * error state (i.e. because it was pinned but it couldn't be\n\t * scheduled on to the CPU at some point).\n\t */\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\treturn 0;\n\n\tif (count < event->read_size)\n\t\treturn -ENOSPC;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\n\tif (read_format & PERF_FORMAT_GROUP)\n\t\tret = perf_event_read_group(event, read_format, buf);\n\telse\n\t\tret = perf_event_read_one(event, read_format, buf);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 170
    },
    {
        "index": 146817,
        "code": "void Document::RemoveFromTopLayer(Element* element) {\n  if (!element->IsInTopLayer())\n    return;\n  size_t position = top_layer_elements_.Find(element);\n  DCHECK_NE(position, kNotFound);\n  top_layer_elements_.erase(position);\n  element->SetIsInTopLayer(false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 65
    },
    {
        "index": 181381,
        "code": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n \tstruct cp2112_device *dev = gpiochip_get_data(chip);\n \tstruct hid_device *hdev = dev->hdev;\n \tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n \tint ret;\n \n\tspin_lock_irqsave(&dev->lock, flags);\n \n \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n \t\tgoto fail;\n \t}\n \n\tspin_unlock_irqrestore(&dev->lock, flags);\n \n \t/*\n \t * Set gpio value when output direction is already set,\n\t * as specified in AN495, Rev. 0.2, cpt. 4.4\n\t */\n\tcp2112_gpio_set(chip, offset, value);\n\n \treturn 0;\n \n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n \treturn ret < 0 ? ret : -EIO;\n }\n",
        "line": "\tunsigned long flags;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n",
        "label": 1,
        "cwe": "CWE-404",
        "cve": "CVE-2017-8071",
        "length": 341
    },
    {
        "index": 101907,
        "code": "void PrintDialogGtk::OnJobCompleted(GtkPrintJob* print_job, GError* error) {\n  if (error)\n    LOG(ERROR) << \"Printing failed: \" << error->message;\n  if (print_job)\n    g_object_unref(print_job);\n  base::FileUtilProxy::Delete(\n      BrowserThread::GetMessageLoopProxyForThread(BrowserThread::FILE),\n      path_to_pdf_,\n      false,\n      NULL);\n  Release();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3897",
        "length": 95
    },
    {
        "index": 183747,
        "code": "     CCLayerTreeHostTest()\n         : m_beginning(false)\n         , m_endWhenBeginReturns(false)\n        , m_running(false)\n         , m_timedOut(false)\n     {\n         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(\"CCLayerTreeHostTest\"));\n         WebCompositor::setThread(m_webThread.get());\n#if USE(THREADED_COMPOSITING)\n        m_settings.enableCompositorThread = true;\n#else\n        m_settings.enableCompositorThread = false;\n #endif\n     }\n",
        "line": "        , m_running(false)\n#if USE(THREADED_COMPOSITING)\n        m_settings.enableCompositorThread = true;\n#else\n        m_settings.enableCompositorThread = false;\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2881",
        "length": 112
    },
    {
        "index": 135182,
        "code": "PassRefPtrWillBeRawPtr<Element> Document::createElement(const AtomicString& localName, const AtomicString& typeExtension, ExceptionState& exceptionState)\n{\n    if (!isValidName(localName)) {\n        exceptionState.throwDOMException(InvalidCharacterError, \"The tag name provided ('\" + localName + \"') is not a valid name.\");\n        return nullptr;\n    }\n\n    RefPtrWillBeRawPtr<Element> element;\n\n    if (CustomElement::isValidName(localName) && registrationContext()) {\n        element = registrationContext()->createCustomTagElement(*this, QualifiedName(nullAtom, convertLocalName(localName), xhtmlNamespaceURI));\n    } else {\n        element = createElement(localName, exceptionState);\n        if (exceptionState.hadException())\n            return nullptr;\n    }\n\n    if (!typeExtension.isEmpty())\n        CustomElementRegistrationContext::setIsAttributeAndTypeExtension(element.get(), typeExtension);\n\n    return element.release();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2015-6768",
        "length": 193
    },
    {
        "index": 79118,
        "code": "_pango_Is_Emoji_Keycap_Base (gunichar ch)\n{\n  return (ch >= '0' && ch <= '9') || ch == '#' || ch == '*';\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-15120",
        "length": 41
    },
    {
        "index": 11526,
        "code": "bool first_word(const char *s, const char *word) {\n        size_t sl, wl;\n\n        assert(s);\n        assert(word);\n\n        sl = strlen(s);\n        wl = strlen(word);\n\n        if (sl < wl)\n                return false;\n\n        if (wl == 0)\n                return true;\n\n        if (memcmp(s, word, wl) != 0)\n                return false;\n\n        return s[wl] == 0 ||\n                strchr(WHITESPACE, s[wl]);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-1174",
        "length": 105
    },
    {
        "index": 74922,
        "code": "acl_special(struct archive_acl *acl, int type, int permset, int tag)\n{\n\tif (type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS\n\t    && ((permset & ~007) == 0)) {\n\t\tswitch (tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl->mode &= ~0700;\n\t\t\tacl->mode |= (permset & 7) << 6;\n\t\t\treturn (0);\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl->mode &= ~0070;\n\t\t\tacl->mode |= (permset & 7) << 3;\n\t\t\treturn (0);\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl->mode &= ~0007;\n\t\t\tacl->mode |= permset & 7;\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1000879",
        "length": 178
    },
    {
        "index": 65878,
        "code": "__be32 nfsd4_set_nfs4_label(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct xdr_netobj *label)\n{\n\treturn nfserr_notsupp;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 45
    },
    {
        "index": 110821,
        "code": "bool AutocompleteEditModel::query_in_progress() const {\n  return !autocomplete_controller_->done();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 22
    },
    {
        "index": 88006,
        "code": "static void pf_get_capacity(struct pf_unit *pf)\n{\n\tchar rc_cmd[12] = { ATAPI_CAPACITY, pf->lun << 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[8];\n\tint bs;\n\n\tif (pf_atapi(pf, rc_cmd, 8, buf, \"get capacity\")) {\n\t\tpf->media_status = PF_NM;\n\t\treturn;\n\t}\n\tset_capacity(pf->disk, xl(buf, 0) + 1);\n\tbs = xl(buf, 4);\n\tif (bs != 512) {\n\t\tset_capacity(pf->disk, 0);\n\t\tif (verbose)\n\t\t\tprintk(\"%s: Drive %d, LUN %d,\"\n\t\t\t       \" unsupported block size %d\\n\",\n\t\t\t       pf->name, pf->drive, pf->lun, bs);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-15922",
        "length": 193
    },
    {
        "index": 29850,
        "code": "static int get_option_uid(substring_t args[], kuid_t *result)\n{\n\tunsigned long value;\n\tkuid_t uid;\n\tint rc;\n\n\trc = get_option_ul(args, &value);\n\tif (rc)\n\t\treturn rc;\n\n\tuid = make_kuid(current_user_ns(), value);\n\tif (!uid_valid(uid))\n\t\treturn -EINVAL;\n\n\t*result = uid;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-4247",
        "length": 82
    },
    {
        "index": 99651,
        "code": "void VaapiVideoDecodeAccelerator::ResetTask() {\n  DCHECK(decoder_thread_task_runner_->BelongsToCurrentThread());\n  DVLOG(1) << \"ResetTask\";\n\n  decoder_->Reset();\n\n  base::AutoLock auto_lock(lock_);\n\n  if (curr_input_buffer_.get())\n    ReturnCurrInputBuffer_Locked();\n\n  message_loop_->PostTask(FROM_HERE, base::Bind(\n      &VaapiVideoDecodeAccelerator::FinishReset, weak_this_));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 98
    },
    {
        "index": 113864,
        "code": "void SelectFileDialogImpl::MultiFilesSelected(\n    const std::vector<FilePath>& selected_files,\n    void* params,\n    RunState run_state) {\n  if (listener_)\n    listener_->MultiFilesSelected(selected_files, params);\n  EndRun(run_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 56
    },
    {
        "index": 94400,
        "code": "static void sd_prot_op(struct scsi_cmnd *scmd, unsigned int dif)\n{\n\tunsigned int prot_op = SCSI_PROT_NORMAL;\n\tunsigned int dix = scsi_prot_sg_count(scmd);\n\n\tif (scmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tif (dif && dix)\n\t\t\tprot_op = SCSI_PROT_READ_PASS;\n\t\telse if (dif && !dix)\n\t\t\tprot_op = SCSI_PROT_READ_STRIP;\n\t\telse if (!dif && dix)\n\t\t\tprot_op = SCSI_PROT_READ_INSERT;\n\t} else {\n\t\tif (dif && dix)\n\t\t\tprot_op = SCSI_PROT_WRITE_PASS;\n\t\telse if (dif && !dix)\n\t\t\tprot_op = SCSI_PROT_WRITE_INSERT;\n\t\telse if (!dif && dix)\n\t\t\tprot_op = SCSI_PROT_WRITE_STRIP;\n\t}\n\n\tscsi_set_prot_op(scmd, prot_op);\n\tscsi_set_prot_type(scmd, dif);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4127",
        "length": 205
    },
    {
        "index": 53628,
        "code": "u8 cdc_ncm_select_altsetting(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt;\n\n\t/* The MBIM spec defines a NCM compatible default altsetting,\n\t * which we may have matched:\n\t *\n\t *  \"Functions that implement both NCM 1.0 and MBIM (an\n\t *   \u201cNCM/MBIM function\u201d) according to this recommendation\n\t *   shall provide two alternate settings for the\n\t *   Communication Interface.  Alternate setting 0, and the\n\t *   associated class and endpoint descriptors, shall be\n\t *   constructed according to the rules given for the\n\t *   Communication Interface in section 5 of [USBNCM10].\n\t *   Alternate setting 1, and the associated class and\n\t *   endpoint descriptors, shall be constructed according to\n\t *   the rules given in section 6 (USB Device Model) of this\n\t *   specification.\"\n\t */\n\tif (intf->num_altsetting < 2)\n\t\treturn intf->cur_altsetting->desc.bAlternateSetting;\n\n\tif (prefer_mbim) {\n\t\talt = usb_altnum_to_altsetting(intf, CDC_NCM_COMM_ALTSETTING_MBIM);\n\t\tif (alt && cdc_ncm_comm_intf_is_mbim(alt))\n\t\t\treturn CDC_NCM_COMM_ALTSETTING_MBIM;\n\t}\n\treturn CDC_NCM_COMM_ALTSETTING_NCM;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3951",
        "length": 299
    },
    {
        "index": 144639,
        "code": "void WebContentsImpl::RenderWidgetCreated(\n    RenderWidgetHostImpl* render_widget_host) {\n  created_widgets_.insert(render_widget_host);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1641",
        "length": 31
    },
    {
        "index": 112598,
        "code": "void Document::unregisterForCaptionPreferencesChangedCallbacks(Element* e)\n{\n    m_captionPreferencesChangedElements.remove(e);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 26
    },
    {
        "index": 106830,
        "code": "LayoutUnit RenderBox::clientWidth() const\n{\n    return width() - borderLeft() - borderRight() - verticalScrollbarWidth();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1799",
        "length": 30
    },
    {
        "index": 64996,
        "code": "IW_IMPL(void) iw_set_input_colorspace(struct iw_context *ctx, const struct iw_csdescr *csdescr)\n{\n\tctx->img1cs = *csdescr; // struct copy\n\toptimize_csdescr(&ctx->img1cs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2017-9202",
        "length": 52
    },
    {
        "index": 89707,
        "code": "static void nfc_llcp_recv_cc(struct nfc_llcp_local *local, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_sock *llcp_sock;\n\tstruct sock *sk;\n\tu8 dsap, ssap;\n\n\tdsap = nfc_llcp_dsap(skb);\n\tssap = nfc_llcp_ssap(skb);\n\n\tllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\n\tif (llcp_sock == NULL) {\n\t\tpr_err(\"Invalid CC\\n\");\n\t\tnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\n\n\t\treturn;\n\t}\n\n\tsk = &llcp_sock->sk;\n\n\t/* Unlink from connecting and link to the client array */\n\tnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tllcp_sock->dsap = ssap;\n\n\tnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\n\t\t\t\t      skb->len - LLCP_HEADER_SIZE);\n\n\tsk->sk_state = LLCP_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tnfc_llcp_sock_put(llcp_sock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12818",
        "length": 254
    },
    {
        "index": 110536,
        "code": "bool GLES2DecoderImpl::GenQueriesEXTHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    if (query_manager_->GetQuery(client_ids[ii])) {\n      return false;\n    }\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2896",
        "length": 68
    },
    {
        "index": 27800,
        "code": "static int br_mdb_copy(struct net_bridge_mdb_htable *new,\n\t\t       struct net_bridge_mdb_htable *old,\n\t\t       int elasticity)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *p;\n\tint maxlen;\n\tint len;\n\tint i;\n\n\tfor (i = 0; i < old->max; i++)\n\t\thlist_for_each_entry(mp, p, &old->mhash[i], hlist[old->ver])\n\t\t\thlist_add_head(&mp->hlist[new->ver],\n\t\t\t\t       &new->mhash[br_ip_hash(new, &mp->addr)]);\n\n\tif (!elasticity)\n\t\treturn 0;\n\n\tmaxlen = 0;\n\tfor (i = 0; i < new->max; i++) {\n\t\tlen = 0;\n\t\thlist_for_each_entry(mp, p, &new->mhash[i], hlist[new->ver])\n\t\t\tlen++;\n\t\tif (len > maxlen)\n\t\t\tmaxlen = len;\n\t}\n\n\treturn maxlen > elasticity ? -EINVAL : 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-0716",
        "length": 220
    },
    {
        "index": 26097,
        "code": "static u64 perf_event_read(struct perf_event *event)\n{\n\t/*\n\t * If event is enabled and currently active on a CPU, update the\n\t * value in the event structure:\n\t */\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\tsmp_call_function_single(event->oncpu,\n\t\t\t\t\t __perf_event_read, event, 1);\n\t} else if (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tstruct perf_event_context *ctx = event->ctx;\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t\t/*\n\t\t * may read while context is not active\n\t\t * (e.g., thread is blocked), in that case\n\t\t * we cannot update context time\n\t\t */\n\t\tif (ctx->is_active) {\n\t\t\tupdate_context_time(ctx);\n\t\t\tupdate_cgrp_time_from_event(event);\n\t\t}\n\t\tupdate_event_times(event);\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\n\treturn perf_event_count(event);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 214
    },
    {
        "index": 23917,
        "code": "static void fr_set_link_state(int reliable, struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\tstate(hdlc)->reliable = reliable;\n\tif (reliable) {\n\t\tnetif_dormant_off(dev);\n\t\tstate(hdlc)->n391cnt = 0; /* Request full status */\n\t\tstate(hdlc)->dce_changed = 1;\n\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE) {\n\t\t\twhile (pvc) {\t/* Activate all PVCs */\n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.exist = pvc->state.active = 1;\n\t\t\t\tpvc->state.new = 0;\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnetif_dormant_on(dev);\n\t\twhile (pvc) {\t\t/* Deactivate all PVCs */\n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.exist = pvc->state.active = 0;\n\t\t\tpvc->state.new = 0;\n\t\t\tif (!state(hdlc)->settings.dce)\n\t\t\t\tpvc->state.bandwidth = 0;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 290
    },
    {
        "index": 158967,
        "code": "bool IsLinkArea(PDFiumPage::Area area) {\n  return area == PDFiumPage::WEBLINK_AREA || area == PDFiumPage::DOCLINK_AREA;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-6031",
        "length": 38
    },
    {
        "index": 99990,
        "code": "NPObject* WebPluginImpl::GetWindowScriptNPObject() {\n  if (!webframe_) {\n    NOTREACHED();\n    return NULL;\n  }\n  return webframe_->windowObject();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 42
    },
    {
        "index": 44129,
        "code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2015-1805",
        "length": 131
    },
    {
        "index": 153486,
        "code": "TabAnimationDelegate::TabAnimationDelegate(TabStrip* tab_strip, Tab* tab)\n    : tab_strip_(tab_strip), tab_(tab) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-5218",
        "length": 32
    },
    {
        "index": 85048,
        "code": "static CURLcode smtp_multi_statemach(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  if((conn->handler->flags & PROTOPT_SSL) && !smtpc->ssldone) {\n    result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &smtpc->ssldone);\n    if(result || !smtpc->ssldone)\n      return result;\n  }\n\n  result = Curl_pp_statemach(&smtpc->pp, FALSE);\n  *done = (smtpc->state == SMTP_STOP) ? TRUE : FALSE;\n\n  return result;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-0500",
        "length": 147
    },
    {
        "index": 81386,
        "code": "static int trace_die_handler(struct notifier_block *self,\n\t\t\t     unsigned long val,\n\t\t\t     void *data)\n{\n\tswitch (val) {\n\tcase DIE_OOPS:\n\t\tif (ftrace_dump_on_oops)\n\t\t\tftrace_dump(ftrace_dump_on_oops);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 69
    },
    {
        "index": 9814,
        "code": "int http_send_name_header(struct http_txn *txn, struct proxy* be, const char* srv_name) {\n\n\tstruct hdr_ctx ctx;\n\n\tchar *hdr_name = be->server_id_hdr_name;\n\tint hdr_name_len = be->server_id_hdr_len;\n\tstruct channel *chn = txn->req.chn;\n\tchar *hdr_val;\n\tunsigned int old_o, old_i;\n\n\tctx.idx = 0;\n\n\told_o = http_hdr_rewind(&txn->req);\n\tif (old_o) {\n\t\t/* The request was already skipped, let's restore it */\n\t\tb_rew(chn->buf, old_o);\n\t\ttxn->req.next += old_o;\n\t\ttxn->req.sov  += old_o;\n\t}\n\n\told_i = chn->buf->i;\n\twhile (http_find_header2(hdr_name, hdr_name_len, txn->req.chn->buf->p, &txn->hdr_idx, &ctx)) {\n\t\t/* remove any existing values from the header */\n\t        http_remove_header2(&txn->req, &txn->hdr_idx, &ctx);\n\t}\n\n\t/* Add the new header requested with the server value */\n\thdr_val = trash.str;\n\tmemcpy(hdr_val, hdr_name, hdr_name_len);\n\thdr_val += hdr_name_len;\n\t*hdr_val++ = ':';\n\t*hdr_val++ = ' ';\n\thdr_val += strlcpy2(hdr_val, srv_name, trash.str + trash.size - hdr_val);\n\thttp_header_add_tail2(&txn->req, &txn->hdr_idx, trash.str, hdr_val - trash.str);\n\n\tif (old_o) {\n\t\t/* If this was a forwarded request, we must readjust the amount of\n\t\t * data to be forwarded in order to take into account the size\n\t\t * variations. Note that the current state is >= HTTP_MSG_BODY,\n\t\t * so we don't have to adjust ->sol.\n\t\t */\n\t\told_o += chn->buf->i - old_i;\n\t\tb_adv(chn->buf, old_o);\n\t\ttxn->req.next -= old_o;\n\t\ttxn->req.sov  -= old_o;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-6269",
        "length": 450
    },
    {
        "index": 147246,
        "code": "void V8TestObject::CachedAttributeRaisesExceptionGetterAnyAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_cachedAttributeRaisesExceptionGetterAnyAttribute_Getter\");\n\n  test_object_v8_internal::CachedAttributeRaisesExceptionGetterAnyAttributeAttributeGetter(info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 80
    },
    {
        "index": 36088,
        "code": "isofs_dentry_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-5472",
        "length": 60
    },
    {
        "index": 47616,
        "code": "static int ap_poll_write(struct ap_device *ap_dev, unsigned long *flags)\n{\n\tstruct ap_queue_status status;\n\tstruct ap_message *ap_msg;\n\n\tif (ap_dev->requestq_count <= 0 ||\n\t    ap_dev->queue_count >= ap_dev->queue_depth)\n\t\treturn 0;\n\t/* Start the next request on the queue. */\n\tap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);\n\tstatus = __ap_send(ap_dev->qid, ap_msg->psmid,\n\t\t\t   ap_msg->message, ap_msg->length, ap_msg->special);\n\tswitch (status.response_code) {\n\tcase AP_RESPONSE_NORMAL:\n\t\tatomic_inc(&ap_poll_requests);\n\t\tap_increase_queue_count(ap_dev);\n\t\tlist_move_tail(&ap_msg->list, &ap_dev->pendingq);\n\t\tap_dev->requestq_count--;\n\t\tap_dev->pendingq_count++;\n\t\tif (ap_dev->queue_count < ap_dev->queue_depth &&\n\t\t    ap_dev->requestq_count > 0)\n\t\t\t*flags |= 1;\n\t\t*flags |= 2;\n\t\tbreak;\n\tcase AP_RESPONSE_RESET_IN_PROGRESS:\n\t\t__ap_schedule_poll_timer();\n\tcase AP_RESPONSE_Q_FULL:\n\t\t*flags |= 2;\n\t\tbreak;\n\tcase AP_RESPONSE_MESSAGE_TOO_BIG:\n\tcase AP_RESPONSE_REQ_FAC_NOT_INST:\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 297
    },
    {
        "index": 96818,
        "code": "void fuse_queue_forget(struct fuse_conn *fc, struct fuse_forget_link *forget,\n\t\t       u64 nodeid, u64 nlookup)\n{\n\tstruct fuse_iqueue *fiq = &fc->iq;\n\n\tforget->forget_one.nodeid = nodeid;\n\tforget->forget_one.nlookup = nlookup;\n\n\tspin_lock(&fiq->waitq.lock);\n\tif (fiq->connected) {\n\t\tfiq->forget_list_tail->next = forget;\n\t\tfiq->forget_list_tail = forget;\n\t\twake_up_locked(&fiq->waitq);\n\t\tkill_fasync(&fiq->fasync, SIGIO, POLL_IN);\n\t} else {\n\t\tkfree(forget);\n\t}\n\tspin_unlock(&fiq->waitq.lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "length": 160
    },
    {
        "index": 7558,
        "code": "PHPAPI void var_push_dtor_no_addref(php_unserialize_data_t *var_hashx, zval **rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last_dtor;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push_dtor_no_addref(%ld): %d (%d)\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(rval), Z_REFCOUNT_PP(rval));\n#endif\n\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\n\t\tif (!(*var_hashx)->first_dtor) {\n\t\t\t(*var_hashx)->first_dtor = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last_dtor)->next = var_hash;\n\t\t}\n\n\t\t(*var_hashx)->last_dtor = var_hash;\n\t}\n\n\tvar_hash->data[var_hash->used_slots++] = *rval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-8142",
        "length": 230
    },
    {
        "index": 66859,
        "code": "void __init free_initrd_mem(unsigned long start, unsigned long end)\n{\n\t/*\n\t * end could be not aligned, and We can not align that,\n\t * decompresser could be confused by aligned initrd_end\n\t * We already reserve the end partial page before in\n\t *   - i386_start_kernel()\n\t *   - x86_64_start_kernel()\n\t *   - relocate_initrd()\n\t * So here We can do PAGE_ALIGN() safely to get partial page to be freed\n\t */\n\tfree_init_pages(\"initrd\", start, PAGE_ALIGN(end));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-7889",
        "length": 123
    },
    {
        "index": 6140,
        "code": "static char ssl_next_proto_validate(unsigned char *d, unsigned len)\n{\n    unsigned int off = 0;\n\n    while (off < len) {\n        if (d[off] == 0)\n            return 0;\n        off += d[off];\n        off++;\n    }\n\n    return off == len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-0291",
        "length": 67
    },
    {
        "index": 148087,
        "code": "void V8TestObject::VoidMethodDoubleOrDOMStringOrNullArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodDoubleOrDOMStringOrNullArg\");\n\n  test_object_v8_internal::VoidMethodDoubleOrDOMStringOrNullArgMethod(info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 79
    },
    {
        "index": 43805,
        "code": "krb5_anonymous_realm()\n{\n    return &anon_realm_data;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-2697",
        "length": 19
    },
    {
        "index": 142059,
        "code": "HRESULT CGaiaCredentialBase::GetComboBoxValueCount(DWORD field_id,\n                                                   DWORD* pcItems,\n                                                   DWORD* pdwSelectedItem) {\n  return E_NOTIMPL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5189",
        "length": 38
    },
    {
        "index": 138971,
        "code": "void WallpaperManagerBase::MoveCustomWallpapersOnWorker(\n    const AccountId& account_id,\n    const WallpaperFilesId& wallpaper_files_id,\n    const scoped_refptr<base::SingleThreadTaskRunner>& reply_task_runner,\n    base::WeakPtr<WallpaperManagerBase> weak_ptr) {\n  const std::string& temporary_wallpaper_dir =\n      account_id.GetUserEmail();  // Migrated\n  if (MoveCustomWallpaperDirectory(kOriginalWallpaperSubDir,\n                                   temporary_wallpaper_dir,\n                                   wallpaper_files_id.id())) {\n    reply_task_runner->PostTask(\n        FROM_HERE,\n        base::Bind(&WallpaperManagerBase::MoveCustomWallpapersSuccess, weak_ptr,\n                   account_id, wallpaper_files_id));\n  }\n  MoveCustomWallpaperDirectory(kLargeWallpaperSubDir, temporary_wallpaper_dir,\n                               wallpaper_files_id.id());\n  MoveCustomWallpaperDirectory(kSmallWallpaperSubDir, temporary_wallpaper_dir,\n                               wallpaper_files_id.id());\n  MoveCustomWallpaperDirectory(kThumbnailWallpaperSubDir,\n                               temporary_wallpaper_dir,\n                               wallpaper_files_id.id());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-1285",
        "length": 227
    },
    {
        "index": 124163,
        "code": "void RenderViewHostManager::SetIsLoading(bool is_loading) {\n  render_view_host_->SetIsLoading(is_loading);\n  if (pending_render_view_host_)\n    pending_render_view_host_->SetIsLoading(is_loading);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0921",
        "length": 47
    },
    {
        "index": 71731,
        "code": "static void SVGIgnorableWhitespace(void *context,const xmlChar *c,int length)\n{\n  SVGInfo\n    *svg_info;\n\n  /*\n    Receiving some ignorable whitespaces from the parser.\n  */\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  SAX.ignorableWhitespace(%.30s, %d)\",c,length);\n  svg_info=(SVGInfo *) context;\n  (void) svg_info;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10066",
        "length": 98
    },
    {
        "index": 82905,
        "code": "static void free_cv_nb10_header(SCV_NB10_HEADER* cv_nb10_header) {\n\tR_FREE (cv_nb10_header->file_name);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-11379",
        "length": 32
    },
    {
        "index": 20276,
        "code": "int cap_ptrace_traceme(struct task_struct *parent)\n{\n\tint ret = 0;\n\tconst struct cred *cred, *child_cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(parent);\n\tchild_cred = current_cred();\n\tif (cred->user->user_ns == child_cred->user->user_ns &&\n\t    cap_issubset(child_cred->cap_permitted, cred->cap_permitted))\n\t\tgoto out;\n\tif (has_ns_capability(parent, child_cred->user->user_ns, CAP_SYS_PTRACE))\n\t\tgoto out;\n\tret = -EPERM;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-2123",
        "length": 131
    },
    {
        "index": 144175,
        "code": "LoginBigUserView* LockContentsView::CurrentBigUserView() {\n  if (opt_secondary_big_view_ && opt_secondary_big_view_->IsAuthEnabled()) {\n    DCHECK(!primary_big_view_->IsAuthEnabled());\n    return opt_secondary_big_view_;\n  }\n\n  return primary_big_view_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1639",
        "length": 62
    },
    {
        "index": 42410,
        "code": "max_sync_store(struct mddev *mddev, const char *buf, size_t len)\n{\n\tint err;\n\tspin_lock(&mddev->lock);\n\tif (strncmp(buf, \"max\", 3) == 0)\n\t\tmddev->resync_max = MaxSector;\n\telse {\n\t\tunsigned long long max;\n\t\tint chunk;\n\n\t\terr = -EINVAL;\n\t\tif (kstrtoull(buf, 10, &max))\n\t\t\tgoto out_unlock;\n\t\tif (max < mddev->resync_min)\n\t\t\tgoto out_unlock;\n\n\t\terr = -EBUSY;\n\t\tif (max < mddev->resync_max &&\n\t\t    mddev->ro == 0 &&\n\t\t    test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))\n\t\t\tgoto out_unlock;\n\n\t\t/* Must be a multiple of chunk_size */\n\t\tchunk = mddev->chunk_sectors;\n\t\tif (chunk) {\n\t\t\tsector_t temp = max;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (sector_div(temp, chunk))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\tmddev->resync_max = max;\n\t}\n\twake_up(&mddev->recovery_wait);\n\terr = 0;\nout_unlock:\n\tspin_unlock(&mddev->lock);\n\treturn err ?: len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5697",
        "length": 267
    },
    {
        "index": 48493,
        "code": "void register_sysctl_root(struct ctl_table_root *root)\n{\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-9191",
        "length": 15
    },
    {
        "index": 5432,
        "code": "  static void  Ins_ROUND( INS_ARG )\n  {\n    args[0] = CUR_Func_round( args[0],\n                              CUR.metrics.compensations[CUR.opcode - 0x68] );\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-9739",
        "length": 47
    },
    {
        "index": 166530,
        "code": "  DisableWebRtcEncryptionFlagTest()\n      : from_command_line_(base::CommandLine::NO_PROGRAM),\n        to_command_line_(base::CommandLine::NO_PROGRAM) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2019-5779",
        "length": 36
    },
    {
        "index": 58020,
        "code": "static int nft_dump_stats(struct sk_buff *skb, struct nft_stats __percpu *stats)\n{\n\tstruct nft_stats *cpu_stats, total;\n\tstruct nlattr *nest;\n\tunsigned int seq;\n\tu64 pkts, bytes;\n\tint cpu;\n\n\tmemset(&total, 0, sizeof(total));\n\tfor_each_possible_cpu(cpu) {\n\t\tcpu_stats = per_cpu_ptr(stats, cpu);\n\t\tdo {\n\t\t\tseq = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\n\t\t\tpkts = cpu_stats->pkts;\n\t\t\tbytes = cpu_stats->bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, seq));\n\t\ttotal.pkts += pkts;\n\t\ttotal.bytes += bytes;\n\t}\n\tnest = nla_nest_start(skb, NFTA_CHAIN_COUNTERS);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.pkts)) ||\n\t    nla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOSPC;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1573",
        "length": 261
    },
    {
        "index": 164094,
        "code": "bool AppCacheDatabase::DeleteDeletableResponseIds(\n    const std::vector<int64_t>& response_ids) {\n  static const char kSql[] =\n      \"DELETE FROM DeletableResponseIds WHERE response_id = ?\";\n  return RunCachedStatementWithIds(SQL_FROM_HERE, kSql, response_ids);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-5837",
        "length": 66
    },
    {
        "index": 136646,
        "code": "void FrameLoader::CommitProvisionalLoad() {\n  DCHECK(Client()->HasWebView());\n\n  if (frame_->GetDocument()) {\n    scoped_refptr<const SecurityOrigin> security_origin =\n        SecurityOrigin::Create(provisional_document_loader_->Url());\n    provisional_document_loader_->GetTiming()\n        .SetHasSameOriginAsPreviousDocument(\n            security_origin->CanRequest(frame_->GetDocument()->Url()));\n  }\n\n  if (!PrepareForCommit())\n    return;\n\n  if (frame_->IsLocalRoot()) {\n    frame_->GetPage()->GetChromeClient().SetEventListenerProperties(\n        frame_, WebEventListenerClass::kTouchStartOrMove,\n        WebEventListenerProperties::kNothing);\n    frame_->GetPage()->GetChromeClient().SetEventListenerProperties(\n        frame_, WebEventListenerClass::kMouseWheel,\n        WebEventListenerProperties::kNothing);\n    frame_->GetPage()->GetChromeClient().SetEventListenerProperties(\n        frame_, WebEventListenerClass::kTouchEndOrCancel,\n        WebEventListenerProperties::kNothing);\n  }\n\n  Client()->TransitionToCommittedForNewPage();\n\n  frame_->GetNavigationScheduler().Cancel();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-6761",
        "length": 230
    },
    {
        "index": 158149,
        "code": "  void MonitorRequestOnMainThread(\n      const net::test_server::HttpRequest& request) {\n    accumulated_requests_.push_back(request);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-20068",
        "length": 30
    },
    {
        "index": 183918,
        "code": "void InitChromeDriverLogging(const CommandLine& command_line) {\n  bool success = InitLogging(\n      FILE_PATH_LITERAL(\"chromedriver.log\"),\n      logging::LOG_TO_BOTH_FILE_AND_SYSTEM_DEBUG_LOG,\n      logging::LOCK_LOG_FILE,\n      logging::DELETE_OLD_LOG_FILE,\n      logging::DISABLE_DCHECK_FOR_NON_OFFICIAL_RELEASE_BUILDS);\n  if (!success) {\n    PLOG(ERROR) << \"Unable to initialize logging\";\n  }\n  logging::SetLogItems(false,  // enable_process_id\n                       false,  // enable_thread_id\n                       true,   // enable_timestamp\n                       false); // enable_tickcount\n  if (command_line.HasSwitch(switches::kLoggingLevel)) {\n    std::string log_level = command_line.GetSwitchValueASCII(\n        switches::kLoggingLevel);\n    int level = 0;\n    if (base::StringToInt(log_level, &level)) {\n      logging::SetMinLogLevel(level);\n    } else {\n      LOG(WARNING) << \"Bad log level: \" << log_level;\n    }\n  }\n}\n",
        "line": "  bool success = InitLogging(\n      FILE_PATH_LITERAL(\"chromedriver.log\"),\n      logging::LOG_TO_BOTH_FILE_AND_SYSTEM_DEBUG_LOG,\n      logging::LOCK_LOG_FILE,\n      logging::DELETE_OLD_LOG_FILE,\n      logging::DISABLE_DCHECK_FOR_NON_OFFICIAL_RELEASE_BUILDS);\n  if (!success) {\n    PLOG(ERROR) << \"Unable to initialize logging\";\n  }\n  logging::SetLogItems(false,  // enable_process_id\n                       false,  // enable_thread_id\n                       true,   // enable_timestamp\n                       false); // enable_tickcount\n  if (command_line.HasSwitch(switches::kLoggingLevel)) {\n    std::string log_level = command_line.GetSwitchValueASCII(\n        switches::kLoggingLevel);\n    int level = 0;\n    if (base::StringToInt(log_level, &level)) {\n      logging::SetMinLogLevel(level);\n    } else {\n      LOG(WARNING) << \"Bad log level: \" << log_level;\n    }\n  }\n}\n",
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2802",
        "length": 221
    },
    {
        "index": 3651,
        "code": "int test_gf2m_mod(BIO *bp)\n{\n    BIGNUM *a, *b[2], *c, *d, *e;\n    int i, j, ret = 0;\n    int p0[] = { 163, 7, 6, 3, 0, -1 };\n    int p1[] = { 193, 15, 0, -1 };\n\n    a = BN_new();\n    b[0] = BN_new();\n    b[1] = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_GF2m_arr2poly(p0, b[0]);\n    BN_GF2m_arr2poly(p1, b[1]);\n\n    for (i = 0; i < num0; i++) {\n        BN_bntest_rand(a, 1024, 0, 0);\n        for (j = 0; j < 2; j++) {\n            BN_GF2m_mod(c, a, b[j]);\n# if 0                          /* make test uses ouput in bc but bc can't\n                                 * handle GF(2^m) arithmetic */\n            if (bp != NULL) {\n                if (!results) {\n                    BN_print(bp, a);\n                    BIO_puts(bp, \" % \");\n                    BN_print(bp, b[j]);\n                    BIO_puts(bp, \" - \");\n                    BN_print(bp, c);\n                    BIO_puts(bp, \"\\n\");\n                }\n            }\n# endif\n            BN_GF2m_add(d, a, c);\n            BN_GF2m_mod(e, d, b[j]);\n            /* Test that a + (a mod p) mod p == 0. */\n            if (!BN_is_zero(e)) {\n                fprintf(stderr, \"GF(2^m) modulo test failed!\\n\");\n                goto err;\n            }\n        }\n    }\n    ret = 1;\n err:\n    BN_free(a);\n    BN_free(b[0]);\n    BN_free(b[1]);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-3193",
        "length": 447
    },
    {
        "index": 83817,
        "code": "static inline void hwsim_set_sta_magic(struct ieee80211_sta *sta)\n{\n\tstruct hwsim_sta_priv *sp = (void *)sta->drv_priv;\n\tsp->magic = HWSIM_STA_MAGIC;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-772",
        "cve": "CVE-2018-8087",
        "length": 47
    },
    {
        "index": 24290,
        "code": "static void vlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrcpy(info->driver, vlan_fullname);\n\tstrcpy(info->version, vlan_version);\n\tstrcpy(info->fw_version, \"N/A\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4112",
        "length": 55
    },
    {
        "index": 124393,
        "code": "int ExtensionTabUtil::GetWindowIdOfTabStripModel(\n    const TabStripModel* tab_strip_model) {\n  for (BrowserList::const_iterator it = BrowserList::begin();\n       it != BrowserList::end(); ++it) {\n    if ((*it)->tab_strip_model() == tab_strip_model)\n      return GetWindowId(*it);\n  }\n  return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0925",
        "length": 82
    },
    {
        "index": 116933,
        "code": "void IndexedDBDispatcher::CursorDestroyed(int32 cursor_id) {\n  cursors_.erase(cursor_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3091",
        "length": 23
    },
    {
        "index": 68541,
        "code": "gst_asf_demux_get_bytes (guint8 ** p_buf, guint num_bytes_to_read,\n    guint8 ** p_data, guint64 * p_size)\n{\n  *p_buf = NULL;\n\n  if (*p_size < num_bytes_to_read)\n    return FALSE;\n\n  *p_buf = g_memdup (*p_data, num_bytes_to_read);\n  *p_data += num_bytes_to_read;\n  *p_size -= num_bytes_to_read;\n  return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5847",
        "length": 100
    },
    {
        "index": 30327,
        "code": "static void vsock_connect_timeout(struct work_struct *work)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\n\tvsk = container_of(work, struct vsock_sock, dwork.work);\n\tsk = sk_vsock(vsk);\n\n\tlock_sock(sk);\n\tif (sk->sk_state == SS_CONNECTING &&\n\t    (sk->sk_shutdown != SHUTDOWN_MASK)) {\n\t\tsk->sk_state = SS_UNCONNECTED;\n\t\tsk->sk_err = ETIMEDOUT;\n\t\tsk->sk_error_report(sk);\n\t}\n\trelease_sock(sk);\n\n\tsock_put(sk);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-3237",
        "length": 124
    },
    {
        "index": 160489,
        "code": "void RenderFrameHostImpl::SetUpMojoIfNeeded() {\n  if (registry_.get())\n    return;\n\n  associated_registry_ = std::make_unique<AssociatedInterfaceRegistryImpl>();\n  registry_ = std::make_unique<service_manager::BinderRegistry>();\n\n  auto make_binding = [](RenderFrameHostImpl* impl,\n                         mojom::FrameHostAssociatedRequest request) {\n    impl->frame_host_associated_binding_.Bind(std::move(request));\n  };\n  static_cast<blink::AssociatedInterfaceRegistry*>(associated_registry_.get())\n      ->AddInterface(base::Bind(make_binding, base::Unretained(this)));\n\n  RegisterMojoInterfaces();\n  mojom::FrameFactoryPtr frame_factory;\n  BindInterface(GetProcess(), &frame_factory);\n  frame_factory->CreateFrame(routing_id_, MakeRequest(&frame_));\n\n  service_manager::mojom::InterfaceProviderPtr remote_interfaces;\n  frame_->GetInterfaceProvider(mojo::MakeRequest(&remote_interfaces));\n  remote_interfaces_.reset(new service_manager::InterfaceProvider);\n  remote_interfaces_->Bind(std::move(remote_interfaces));\n\n  if (base::FeatureList::IsEnabled(features::kMojoInputMessages)) {\n    remote_interfaces_->GetInterface(&frame_input_handler_);\n  } else {\n    legacy_frame_input_handler_.reset(new LegacyIPCFrameInputHandler(this));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 271
    },
    {
        "index": 115723,
        "code": "ScreenRecorder::~ScreenRecorder() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 9
    },
    {
        "index": 63073,
        "code": "int __platform_register_drivers(struct platform_driver * const *drivers,\n\t\t\t\tunsigned int count, struct module *owner)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"registering platform driver %ps\\n\", drivers[i]);\n\n\t\terr = __platform_driver_register(drivers[i], owner);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"failed to register platform driver %ps: %d\\n\",\n\t\t\t       drivers[i], err);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\twhile (i--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[i]);\n\t\tplatform_driver_unregister(drivers[i]);\n\t}\n\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-12146",
        "length": 157
    },
    {
        "index": 505,
        "code": "static void pdf_run_Tstar(fz_context *ctx, pdf_processor *proc)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_tos_newline(&pr->tos, gstate->text.leading);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-1000039",
        "length": 69
    },
    {
        "index": 132630,
        "code": "void BlinkTestRunner::CloseDevTools() {\n  Send(new ShellViewHostMsg_CloseDevTools(routing_id()));\n  WebDevToolsAgent* agent =\n      render_view()->GetMainRenderFrame()->GetWebFrame()->devToolsAgent();\n  if (agent)\n    agent->detach();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 61
    },
    {
        "index": 74829,
        "code": "static int64_t mxf_compute_sample_count(MXFContext *mxf, AVStream *st,\n                                        int64_t edit_unit)\n{\n    int i, total = 0, size = 0;\n    MXFTrack *track = st->priv_data;\n    AVRational time_base = av_inv_q(track->edit_rate);\n    AVRational sample_rate = av_inv_q(st->time_base);\n    const MXFSamplesPerFrame *spf = NULL;\n    int64_t sample_count;\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO)\n        return edit_unit;\n\n    if ((sample_rate.num / sample_rate.den) == 48000)\n        spf = ff_mxf_get_samples_per_frame(mxf->fc, time_base);\n    if (!spf) {\n        int remainder = (sample_rate.num * time_base.num) %\n                        (time_base.den * sample_rate.den);\n        if (remainder)\n            av_log(mxf->fc, AV_LOG_WARNING,\n                   \"seeking detected on stream #%d with time base (%d/%d) and \"\n                   \"sample rate (%d/%d), audio pts won't be accurate.\\n\",\n                   st->index, time_base.num, time_base.den,\n                   sample_rate.num, sample_rate.den);\n        return av_rescale_q(edit_unit, sample_rate, track->edit_rate);\n    }\n\n    while (spf->samples_per_frame[size]) {\n        total += spf->samples_per_frame[size];\n        size++;\n    }\n\n    av_assert2(size);\n\n    sample_count = (edit_unit / size) * (uint64_t)total;\n    for (i = 0; i < edit_unit % size; i++) {\n        sample_count += spf->samples_per_frame[i];\n    }\n\n    return sample_count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-1999014",
        "length": 377
    },
    {
        "index": 84581,
        "code": "form2str(FormItemList *fi)\n{\n    Str tmp = Strnew();\n\n    if (fi->type != FORM_SELECT && fi->type != FORM_TEXTAREA)\n\tStrcat_charp(tmp, \"input type=\");\n    Strcat_charp(tmp, _formtypetbl[fi->type]);\n    if (fi->name && fi->name->length)\n\tStrcat_m_charp(tmp, \" name=\\\"\", fi->name->ptr, \"\\\"\", NULL);\n    if ((fi->type == FORM_INPUT_RADIO || fi->type == FORM_INPUT_CHECKBOX ||\n\t fi->type == FORM_SELECT) && fi->value)\n\tStrcat_m_charp(tmp, \" value=\\\"\", fi->value->ptr, \"\\\"\", NULL);\n    Strcat_m_charp(tmp, \" (\", _formmethodtbl[fi->parent->method], \" \",\n\t\t   fi->parent->action->ptr, \")\", NULL);\n    return tmp->ptr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-6197",
        "length": 197
    },
    {
        "index": 111816,
        "code": "void SyncBackendHost::NotifyUpdatedToken(const std::string& token) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  TokenAvailableDetails details(GaiaConstants::kSyncService, token);\n  content::NotificationService::current()->Notify(\n      chrome::NOTIFICATION_TOKEN_UPDATED,\n      content::Source<Profile>(profile_),\n      content::Details<const TokenAvailableDetails>(&details));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 87
    },
    {
        "index": 30657,
        "code": "static void irda_selective_discovery_indication(discinfo_t *discovery,\n\t\t\t\t\t\tDISCOVERY_MODE mode,\n\t\t\t\t\t\tvoid *priv)\n{\n\tstruct irda_sock *self;\n\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\n\tself = priv;\n\tif (!self) {\n\t\tIRDA_WARNING(\"%s: lost myself!\\n\", __func__);\n\t\treturn;\n\t}\n\n\t/* Pass parameter to the caller */\n\tself->cachedaddr = discovery->daddr;\n\n\t/* Wake up process if its waiting for device to be discovered */\n\twake_up_interruptible(&self->query_wait);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-3228",
        "length": 130
    },
    {
        "index": 30026,
        "code": "void br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tmp->timer_armed = false;\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-4129",
        "length": 287
    },
    {
        "index": 20706,
        "code": "static void inject_pending_event(struct kvm_vcpu *vcpu)\n{\n\t/* try to reinject previous events if any */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\t\tkvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,\n\t\t\t\t\t  vcpu->arch.exception.has_error_code,\n\t\t\t\t\t  vcpu->arch.exception.error_code,\n\t\t\t\t\t  vcpu->arch.exception.reinject);\n\t\treturn;\n\t}\n\n\tif (vcpu->arch.nmi_injected) {\n\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\treturn;\n\t}\n\n\tif (vcpu->arch.interrupt.pending) {\n\t\tkvm_x86_ops->set_irq(vcpu);\n\t\treturn;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.nmi_pending) {\n\t\tif (kvm_x86_ops->nmi_allowed(vcpu)) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tkvm_x86_ops->set_nmi(vcpu);\n\t\t}\n\t} else if (kvm_cpu_has_interrupt(vcpu)) {\n\t\tif (kvm_x86_ops->interrupt_allowed(vcpu)) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu),\n\t\t\t\t\t    false);\n\t\t\tkvm_x86_ops->set_irq(vcpu);\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-1601",
        "length": 320
    },
    {
        "index": 159268,
        "code": "void DownloadManagerImpl::ResumeInterruptedDownload(\n    std::unique_ptr<content::DownloadUrlParameters> params,\n    uint32_t id) {\n  BeginDownloadInternal(std::move(params), id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6033",
        "length": 44
    },
    {
        "index": 19010,
        "code": "static void *tcp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct tcp_iter_state *st = seq->private;\n\tvoid *rc = NULL;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\trc = tcp_get_idx(seq, 0);\n\t\tgoto out;\n\t}\n\n\tswitch (st->state) {\n\tcase TCP_SEQ_STATE_OPENREQ:\n\tcase TCP_SEQ_STATE_LISTENING:\n\t\trc = listening_get_next(seq, v);\n\t\tif (!rc) {\n\t\t\tst->state = TCP_SEQ_STATE_ESTABLISHED;\n\t\t\tst->bucket = 0;\n\t\t\tst->offset = 0;\n\t\t\trc\t  = established_get_first(seq);\n\t\t}\n\t\tbreak;\n\tcase TCP_SEQ_STATE_ESTABLISHED:\n\tcase TCP_SEQ_STATE_TIME_WAIT:\n\t\trc = established_get_next(seq, v);\n\t\tbreak;\n\t}\nout:\n\t++*pos;\n\tst->last_pos = *pos;\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 197
    },
    {
        "index": 150294,
        "code": "WebInputElement FindUsernameElementPrecedingPasswordElement(\n    WebLocalFrame* frame,\n    const WebInputElement& password_element) {\n  DCHECK(!password_element.IsNull());\n\n  std::vector<WebFormControlElement> elements;\n  if (password_element.Form().IsNull()) {\n    elements = form_util::GetUnownedAutofillableFormFieldElements(\n        frame->GetDocument().All(), nullptr);\n  } else {\n    WebVector<WebFormControlElement> web_control_elements;\n    password_element.Form().GetFormControlElements(web_control_elements);\n    elements.assign(web_control_elements.begin(), web_control_elements.end());\n  }\n\n  auto iter = std::find(elements.begin(), elements.end(), password_element);\n  if (iter == elements.end())\n    return WebInputElement();\n\n  for (auto begin = elements.begin(); iter != begin;) {\n    --iter;\n    const WebInputElement* input = ToWebInputElement(&*iter);\n    if (input && input->IsTextField() && !input->IsPasswordFieldForAutofill() &&\n        IsElementEditable(*input) && form_util::IsWebElementVisible(*input)) {\n      return *input;\n    }\n  }\n\n  return WebInputElement();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5053",
        "length": 241
    },
    {
        "index": 99198,
        "code": "bool V8DOMWrapper::maybeDOMWrapper(v8::Handle<v8::Value> value)\n{\n    if (value.IsEmpty() || !value->IsObject())\n        return false;\n\n    v8::Handle<v8::Object> object = v8::Handle<v8::Object>::Cast(value);\n    if (!object->InternalFieldCount())\n        return false;\n\n    ASSERT(object->InternalFieldCount() >= V8Custom::kDefaultWrapperInternalFieldCount);\n\n    v8::Handle<v8::Value> type = object->GetInternalField(V8Custom::kDOMWrapperTypeIndex);\n    ASSERT(type->IsInt32());\n    ASSERT(V8ClassIndex::INVALID_CLASS_INDEX < type->Int32Value() && type->Int32Value() < V8ClassIndex::CLASSINDEX_END);\n\n    v8::Handle<v8::Value> wrapper = object->GetInternalField(V8Custom::kDOMWrapperObjectIndex);\n    ASSERT(wrapper->IsNumber() || wrapper->IsExternal());\n\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 210
    },
    {
        "index": 120404,
        "code": "  virtual ~ScopedGestureRecognizerSetter() {\n    ui::SetGestureRecognizerForTesting(original_gr_);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2887",
        "length": 21
    },
    {
        "index": 19168,
        "code": "static inline struct sock *l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\n{\n\tstruct sock *sk = __l2tp_ip_bind_lookup(net, laddr, dif, tunnel_id);\n\tif (sk)\n\t\tsock_hold(sk);\n\n\treturn sk;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 67
    },
    {
        "index": 177232,
        "code": "void ACodec::BaseState::getMoreInputDataIfPossible() {\n if (mCodec->mPortEOS[kPortIndexInput]) {\n return;\n }\n\n BufferInfo *eligible = NULL;\n\n for (size_t i = 0; i < mCodec->mBuffers[kPortIndexInput].size(); ++i) {\n BufferInfo *info = &mCodec->mBuffers[kPortIndexInput].editItemAt(i);\n\n#if 0\n if (info->mStatus == BufferInfo::OWNED_BY_UPSTREAM) {\n return;\n }\n#endif\n\n if (info->mStatus == BufferInfo::OWNED_BY_US) {\n            eligible = info;\n }\n }\n\n if (eligible == NULL) {\n return;\n }\n\n    postFillThisBuffer(eligible);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 156
    },
    {
        "index": 165512,
        "code": "void ContentSecurityPolicy::EnforceStrictMixedContentChecking() {\n  insecure_request_policy_ |= kBlockAllMixedContent;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2019-5799",
        "length": 27
    },
    {
        "index": 119274,
        "code": "void HTMLFormElement::submit(Event* event, bool activateSubmitButton, bool processingUserGesture, FormSubmissionTrigger formSubmissionTrigger)\n{\n    FrameView* view = document().view();\n    Frame* frame = document().frame();\n    if (!view || !frame || !frame->page())\n        return;\n\n    if (m_isSubmittingOrPreparingForSubmission) {\n        m_shouldSubmit = true;\n        return;\n    }\n\n    m_isSubmittingOrPreparingForSubmission = true;\n    m_wasUserSubmitted = processingUserGesture;\n\n    HTMLFormControlElement* firstSuccessfulSubmitButton = 0;\n    bool needButtonActivation = activateSubmitButton; // do we need to activate a submit button?\n\n    for (unsigned i = 0; i < m_associatedElements.size(); ++i) {\n        FormAssociatedElement* associatedElement = m_associatedElements[i];\n        if (!associatedElement->isFormControlElement())\n            continue;\n        if (needButtonActivation) {\n            HTMLFormControlElement* control = toHTMLFormControlElement(associatedElement);\n            if (control->isActivatedSubmit())\n                needButtonActivation = false;\n            else if (firstSuccessfulSubmitButton == 0 && control->isSuccessfulSubmitButton())\n                firstSuccessfulSubmitButton = control;\n        }\n    }\n\n    if (needButtonActivation && firstSuccessfulSubmitButton)\n        firstSuccessfulSubmitButton->setActivatedSubmit(true);\n\n    scheduleFormSubmission(FormSubmission::create(this, m_attributes, event, formSubmissionTrigger));\n\n    if (needButtonActivation && firstSuccessfulSubmitButton)\n        firstSuccessfulSubmitButton->setActivatedSubmit(false);\n\n    m_shouldSubmit = false;\n    m_isSubmittingOrPreparingForSubmission = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2927",
        "length": 344
    },
    {
        "index": 8660,
        "code": "size_t mptsas_config_phy_0(MPTSASState *s, uint8_t **data, int address)\n{\n    int phy_handle = -1;\n    int dev_handle = -1;\n    int i = mptsas_phy_addr_get(s, address);\n    SCSIDevice *dev;\n\n    if (i < 0) {\n        trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n        return i;\n    }\n\n    dev = mptsas_phy_get_device(s, i, &phy_handle, &dev_handle);\n    trace_mptsas_config_sas_phy(s, address, i, phy_handle, dev_handle, 0);\n\n    return MPTSAS_CONFIG_PACK_EXT(0, MPI_CONFIG_EXTPAGETYPE_SAS_PHY, 0x01,\n                                  \"w*wqwb*blbb*b*b*l\",\n                                  dev_handle, s->sas_addr, dev_handle, i,\n                                  (dev\n                                   ? MPI_SAS_DEVICE_INFO_END_DEVICE /* | MPI_SAS_DEVICE_INFO_SSP_TARGET?? */\n                                   : MPI_SAS_DEVICE_INFO_NO_DEVICE),\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5,\n                                  (MPI_SAS_IOUNIT0_RATE_3_0 << 4) | MPI_SAS_IOUNIT0_RATE_1_5);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-7157",
        "length": 299
    },
    {
        "index": 11673,
        "code": "device_partition_create (Device *device,\n                         guint64 offset,\n                         guint64 size,\n                         const char *type,\n                         const char *label,\n                         char **flags,\n                         char **options,\n                         const char *fstype,\n                         char **fsoptions,\n                         DBusGMethodInvocation *context)\n{\n  if (!device->priv->device_is_partition_table)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not partitioned\");\n      goto out;\n    }\n\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           device->priv->device_is_system_internal ? \"org.freedesktop.udisks.change-system-internal\"\n                           : \"org.freedesktop.udisks.change\",\n                           \"PartitionCreate\",\n                           TRUE,\n                           device_partition_create_authorized_cb,\n                           context,\n                           8,\n                           g_memdup (&offset, sizeof(guint64)),\n                           g_free,\n                           g_memdup (&size, sizeof(guint64)),\n                           g_free,\n                           g_strdup (type),\n                           g_free,\n                           g_strdup (label),\n                           g_free,\n                           g_strdupv (flags),\n                           g_strfreev,\n                           g_strdupv (options),\n                           g_strfreev,\n                           g_strdup (fstype),\n                           g_free,\n                           g_strdupv (fsoptions),\n                           g_strfreev);\n\n out:\n  return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2010-1149",
        "length": 283
    },
    {
        "index": 35850,
        "code": "struct sctp_chunk *sctp_make_abort(const struct sctp_association *asoc,\n\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t      const size_t hint)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t/* Set the T-bit if we have no association and 'chunk' is not\n\t * an INIT (vtag will be reflected).\n\t */\n\tif (!asoc) {\n\t\tif (chunk && chunk->chunk_hdr &&\n\t\t    chunk->chunk_hdr->type == SCTP_CID_INIT)\n\t\t\tflags = 0;\n\t\telse\n\t\t\tflags = SCTP_CHUNK_FLAG_T;\n\t}\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ABORT, flags, hint);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ABORT back to where the offender came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-7841",
        "length": 262
    },
    {
        "index": 12009,
        "code": "DEFINE_RUN_ONCE_STATIC_ALT(ossl_init_no_add_all_digests,\n                           ossl_init_add_all_digests)\n{\n    /* Do nothing */\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-330",
        "cve": "CVE-2019-1549",
        "length": 36
    },
    {
        "index": 177056,
        "code": "SoftAVC::~SoftAVC() {\n    H264SwDecRelease(mHandle);\n    mHandle = NULL;\n\n while (mPicToHeaderMap.size() != 0) {\n        OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.editValueAt(0);\n        mPicToHeaderMap.removeItemsAt(0);\n delete header;\n        header = NULL;\n }\n List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);\n List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);\n    CHECK(outQueue.empty());\n    CHECK(inQueue.empty());\n\n delete[] mFirstPicture;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-2487",
        "length": 133
    },
    {
        "index": 58295,
        "code": "void arm_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,\n\t\t\tint nents, enum dma_data_direction dir)\n{\n\tstruct dma_map_ops *ops = get_dma_ops(dev);\n\tstruct scatterlist *s;\n\tint i;\n\n\tfor_each_sg(sg, s, nents, i)\n\t\tops->sync_single_for_cpu(dev, sg_dma_address(s), s->length,\n\t\t\t\t\t dir);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9888",
        "length": 88
    },
    {
        "index": 3916,
        "code": "inline void CCITTFaxStream::addPixels(int a1, int blackPixels) {\n  if (a1 > codingLine[a0i]) {\n    if (a1 > columns) {\n      error(errSyntaxError, getPos(),\n\t    \"CCITTFax row is wrong length ({0:d})\", a1);\n      err = gTrue;\n      a1 = columns;\n    }\n    if ((a0i & 1) ^ blackPixels) {\n      ++a0i;\n    }\n    codingLine[a0i] = a1;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1790",
        "length": 119
    },
    {
        "index": 90017,
        "code": "size_t ZSTD_compressCCtx(ZSTD_CCtx* cctx,\n                         void* dst, size_t dstCapacity,\n                   const void* src, size_t srcSize,\n                         int compressionLevel)\n{\n    DEBUGLOG(4, \"ZSTD_compressCCtx (srcSize=%u)\", (U32)srcSize);\n    assert(cctx != NULL);\n    return ZSTD_compress_usingDict(cctx, dst, dstCapacity, src, srcSize, NULL, 0, compressionLevel);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2019-11922",
        "length": 104
    },
    {
        "index": 171326,
        "code": "void OMXCodec::fillOutputBuffer(IOMX::buffer_id buffer) {\n Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];\n for (size_t i = 0; i < buffers->size(); ++i) {\n if ((*buffers)[i].mBuffer == buffer) {\n            fillOutputBuffer(&buffers->editItemAt(i));\n return;\n }\n }\n\n    CHECK(!\"should not be here.\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3899",
        "length": 90
    },
    {
        "index": 140506,
        "code": "int HttpProxyClientSocket::DoSendRequest() {\n  next_state_ = STATE_SEND_REQUEST_COMPLETE;\n\n  if (request_line_.empty()) {\n    DCHECK(request_headers_.IsEmpty());\n    HttpRequestHeaders authorization_headers;\n    if (auth_->HaveAuth())\n      auth_->AddAuthorizationHeader(&authorization_headers);\n    if (proxy_delegate_) {\n      proxy_delegate_->OnBeforeTunnelRequest(proxy_server_,\n                                             &authorization_headers);\n    }\n    BuildTunnelRequest(request_, authorization_headers, endpoint_,\n                       &request_line_, &request_headers_);\n\n    net_log_.AddEvent(\n        NetLog::TYPE_HTTP_TRANSACTION_SEND_TUNNEL_HEADERS,\n        base::Bind(&HttpRequestHeaders::NetLogCallback,\n                   base::Unretained(&request_headers_),\n                   &request_line_));\n  }\n\n  parser_buf_ = new GrowableIOBuffer();\n  http_stream_parser_.reset(new HttpStreamParser(\n      transport_.get(), &request_, parser_buf_.get(), net_log_));\n  return http_stream_parser_->SendRequest(\n      request_line_, request_headers_, &response_, io_callback_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1229",
        "length": 219
    },
    {
        "index": 123478,
        "code": "  SafeBrowsingBlockingPage* CreateSafeBrowsingPage(\n      SafeBrowsingUIManager* ui_manager,\n      WebContents* web_contents,\n      const SafeBrowsingBlockingPage::UnsafeResourceList& unsafe_resources) {\n    if (unsafe_resources.size() == 1 &&\n        (unsafe_resources[0].threat_type == SB_THREAT_TYPE_URL_MALWARE ||\n         unsafe_resources[0].threat_type == SB_THREAT_TYPE_URL_PHISHING)) {\n      return new SafeBrowsingBlockingPageV2(ui_manager, web_contents,\n          unsafe_resources);\n    }\n    return new SafeBrowsingBlockingPageV1(ui_manager, web_contents,\n                                          unsafe_resources);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0890",
        "length": 140
    },
    {
        "index": 130230,
        "code": "void ClipboardUtil::CFHtmlToHtml(const std::string& cf_html,\n                                 std::string* html,\n                                 std::string* base_url) {\n  size_t fragment_start = std::string::npos;\n  size_t fragment_end = std::string::npos;\n\n  ClipboardUtil::CFHtmlExtractMetadata(\n      cf_html, base_url, NULL, &fragment_start, &fragment_end);\n\n  if (html &&\n      fragment_start != std::string::npos &&\n      fragment_end != std::string::npos) {\n    *html = cf_html.substr(fragment_start, fragment_end - fragment_start);\n    base::TrimWhitespace(*html, base::TRIM_ALL, html);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 144
    },
    {
        "index": 115150,
        "code": "PlatformLayer* GraphicsContext3D::platformLayer() const\n{\n    return m_private.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-3956",
        "length": 22
    },
    {
        "index": 130610,
        "code": "static void activityLoggedInIsolatedWorldsAttrAttributeSetterCallbackForMainWorld(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectV8Internal::activityLoggedInIsolatedWorldsAttrAttributeSetterForMainWorld(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 105
    },
    {
        "index": 89576,
        "code": "newSWFInput_allocedBuffer(unsigned char *buffer, int length)\n{\n\tSWFInput input = newSWFInput_buffer(buffer, length);\n\tinput->destroy = SWFInput_buffer_dtor;\n#if TRACK_ALLOCS\n\tinput->gcnode = ming_gc_add_node(input, (dtorfunctype) destroySWFInput);\n#endif\n\treturn input;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-12980",
        "length": 76
    },
    {
        "index": 149580,
        "code": "  ConnectionTracker* preconnecting_server_connection_tracker() const {\n    return preconnecting_server_connection_tracker_.get();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5077",
        "length": 25
    },
    {
        "index": 171928,
        "code": "void btif_hl_stop_cch_timer(UINT8 app_idx, UINT8 mcl_idx)\n{\n btif_hl_mcl_cb_t *p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);\n    BTIF_TRACE_DEBUG(\"%s app_idx=%d, mcl_idx=%d timer_in_use=%d\",\n                      __FUNCTION__,app_idx, mcl_idx, p_mcb->cch_timer.in_use);\n\n    p_mcb->cch_timer_active = FALSE;\n if (p_mcb->cch_timer.in_use)\n {\n        BTIF_TRACE_DEBUG(\"stop CCH timer \");\n        btu_stop_timer(&p_mcb->cch_timer);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3839",
        "length": 147
    },
    {
        "index": 69987,
        "code": "void setDeferredMultiBulkLength(client *c, void *node, long length) {\n    listNode *ln = (listNode*)node;\n    robj *len, *next;\n\n    /* Abort when *node is NULL (see addDeferredMultiBulkLength). */\n    if (node == NULL) return;\n\n    len = listNodeValue(ln);\n    len->ptr = sdscatprintf(sdsempty(),\"*%ld\\r\\n\",length);\n    len->encoding = OBJ_ENCODING_RAW; /* in case it was an EMBSTR. */\n    c->reply_bytes += sdsZmallocSize(len->ptr);\n    if (ln->next != NULL) {\n        next = listNodeValue(ln->next);\n\n        /* Only glue when the next node is non-NULL (an sds in this case) */\n        if (next->ptr != NULL) {\n            c->reply_bytes -= sdsZmallocSize(len->ptr);\n            c->reply_bytes -= getStringObjectSdsUsedMemory(next);\n            len->ptr = sdscatlen(len->ptr,next->ptr,sdslen(next->ptr));\n            c->reply_bytes += sdsZmallocSize(len->ptr);\n            listDelNode(c->reply,ln->next);\n        }\n    }\n    asyncCloseClientOnOutputBufferLimitReached(c);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2016-10517",
        "length": 275
    },
    {
        "index": 34076,
        "code": "static int udf_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      struct nameidata *nd)\n{\n\tstruct udf_fileident_bh fibh;\n\tstruct inode *inode;\n\tstruct fileIdentDesc cfi, *fi;\n\tint err;\n\tstruct udf_inode_info *iinfo;\n\n\tinode = udf_new_inode(dir, mode, &err);\n\tif (!inode) {\n\t\treturn err;\n\t}\n\n\tiinfo = UDF_I(inode);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tinode->i_data.a_ops = &udf_adinicb_aops;\n\telse\n\t\tinode->i_data.a_ops = &udf_aops;\n\tinode->i_op = &udf_file_inode_operations;\n\tinode->i_fop = &udf_file_operations;\n\tmark_inode_dirty(inode);\n\n\tfi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n\tif (!fi) {\n\t\tinode_dec_link_count(inode);\n\t\tiput(inode);\n\t\treturn err;\n\t}\n\tcfi.icb.extLength = cpu_to_le32(inode->i_sb->s_blocksize);\n\tcfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n\t*(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n\t\tcpu_to_le32(iinfo->i_unique & 0x00000000FFFFFFFFUL);\n\tudf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n\tif (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n\t\tmark_inode_dirty(dir);\n\tif (fibh.sbh != fibh.ebh)\n\t\tbrelse(fibh.ebh);\n\tbrelse(fibh.sbh);\n\td_instantiate(dentry, inode);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2012-6548",
        "length": 403
    },
    {
        "index": 68356,
        "code": "void perf_event_exec(void)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = current->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_event_enable_on_exec(ctxn);\n\n\t\tperf_iterate_ctx(ctx, perf_event_addr_filters_exec, NULL,\n\t\t\t\t   true);\n\t}\n\trcu_read_unlock();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6001",
        "length": 91
    },
    {
        "index": 69548,
        "code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? key_wait_bit_intr : key_wait_bit,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->type_data.reject_error;\n\t}\n\treturn key_validate(key);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-2647",
        "length": 109
    },
    {
        "index": 81044,
        "code": "static void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tif (kvm_inject_realmode_interrupt(vcpu, irq, inc_eip) != EMULATE_DONE)\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n\n\tvmx_clear_hlt(vcpu);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-12904",
        "length": 253
    },
    {
        "index": 56295,
        "code": "SAPI_API void sapi_shutdown(void)\n{\n#ifdef ZTS\n\tts_free_id(sapi_globals_id);\n#else\n\tsapi_globals_dtor(&sapi_globals);\n#endif\n\n\treentrancy_shutdown();\n\n\tvirtual_cwd_shutdown();\n\n#ifdef PHP_WIN32\n\ttsrm_win32_shutdown();\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2015-8935",
        "length": 60
    },
    {
        "index": 116028,
        "code": "PanelSettingsMenuModel::~PanelSettingsMenuModel() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3104",
        "length": 13
    },
    {
        "index": 105737,
        "code": "std::string PrintProp(IBusProperty *prop, int tree_level) {\n  if (!prop) {\n    return \"\";\n  }\n\n  std::stringstream stream;\n  stream << Spacer(tree_level) << \"=========================\" << std::endl;\n  stream << Spacer(tree_level) << \"key: \" << Or(prop->key, \"<none>\")\n         << std::endl;\n  stream << Spacer(tree_level) << \"icon: \" << Or(prop->icon, \"<none>\")\n         << std::endl;\n  stream << Spacer(tree_level) << \"label: \"\n         << ((prop->label && prop->label->text) ? prop->label->text : \"<none>\")\n         << std::endl;\n  stream << Spacer(tree_level) << \"tooptip: \"\n         << ((prop->tooltip && prop->tooltip->text)\n             ? prop->tooltip->text : \"<none>\") << std::endl;\n  stream << Spacer(tree_level) << \"sensitive: \"\n         << (prop->sensitive ? \"YES\" : \"NO\") << std::endl;\n  stream << Spacer(tree_level) << \"visible: \" << (prop->visible ? \"YES\" : \"NO\")\n         << std::endl;\n  stream << Spacer(tree_level) << \"type: \" << PropTypeToString(prop->type)\n         << std::endl;\n  stream << Spacer(tree_level) << \"state: \" << PropStateToString(prop->state)\n         << std::endl;\n  stream << Spacer(tree_level) << \"sub_props: \"\n         << (PropertyHasChildren(prop) ? \"\" : \"<none>\") << std::endl;\n  stream << PrintPropList(prop->sub_props, tree_level + 1);\n  stream << Spacer(tree_level) << \"=========================\" << std::endl;\n\n  return stream.str();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2804",
        "length": 377
    },
    {
        "index": 63720,
        "code": "grub_disk_write (grub_disk_t disk, grub_disk_addr_t sector,\n\t\t grub_off_t offset, grub_size_t size, const void *buf)\n{\n  unsigned real_offset;\n\n  grub_dprintf (\"disk\", \"Writing `%s'...\\n\", disk->name);\n\n  if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE)\n    return grub_errno;\n\n  real_offset = offset;\n\n  while (size)\n    {\n      if (real_offset != 0 || (size < GRUB_DISK_SECTOR_SIZE && size != 0))\n\t{\n\t  char tmp_buf[GRUB_DISK_SECTOR_SIZE];\n\t  grub_size_t len;\n\t  grub_partition_t part;\n\n\t  part = disk->partition;\n\t  disk->partition = 0;\n\t  if (grub_disk_read (disk, sector, 0, GRUB_DISK_SECTOR_SIZE, tmp_buf)\n\t      != GRUB_ERR_NONE)\n\t    {\n\t      disk->partition = part;\n\t      goto finish;\n\t    }\n\t  disk->partition = part;\n\n\t  len = GRUB_DISK_SECTOR_SIZE - real_offset;\n\t  if (len > size)\n\t    len = size;\n\n\t  grub_memcpy (tmp_buf + real_offset, buf, len);\n\n\t  grub_disk_cache_invalidate (disk->dev->id, disk->id, sector);\n\n\t  if ((disk->dev->write) (disk, sector, 1, tmp_buf) != GRUB_ERR_NONE)\n\t    goto finish;\n\n\t  sector++;\n\t  buf = (char *) buf + len;\n\t  size -= len;\n\t  real_offset = 0;\n\t}\n      else\n\t{\n\t  grub_size_t len;\n\t  grub_size_t n;\n\n\t  len = size & ~(GRUB_DISK_SECTOR_SIZE - 1);\n\t  n = size >> GRUB_DISK_SECTOR_BITS;\n\n\t  if ((disk->dev->write) (disk, sector, n, buf) != GRUB_ERR_NONE)\n\t    goto finish;\n\n\t  while (n--)\n\t    grub_disk_cache_invalidate (disk->dev->id, disk->id, sector++);\n\n\t  buf = (char *) buf + len;\n\t  size -= len;\n\t}\n    }\n\n finish:\n\n  return grub_errno;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-10929",
        "length": 461
    },
    {
        "index": 161203,
        "code": "void OnMimeTypeResult(std::string* output, const std::string& mime_type) {\n  *output = mime_type;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6110",
        "length": 28
    },
    {
        "index": 65886,
        "code": "nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\tif (isdotent(fname, flen))\n\t\treturn nfserr_exist;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_NOP);\n\tif (err)\n\t\treturn err;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\treturn nfserrno(host_err);\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild))\n\t\treturn nfserrno(host_err);\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t/*\n\t * We unconditionally drop our ref to dchild as fh_compose will have\n\t * already grabbed its own ref for it.\n\t */\n\tdput(dchild);\n\tif (err)\n\t\treturn err;\n\treturn nfsd_create_locked(rqstp, fhp, fname, flen, iap, type,\n\t\t\t\t\trdev, resfhp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 313
    },
    {
        "index": 166107,
        "code": "void PaymentRequest::Pay() {\n  journey_logger_.SetEventOccurred(JourneyLogger::EVENT_PAY_CLICKED);\n\n  DCHECK(state_->selected_instrument());\n  JourneyLogger::Event selected_event =\n      JourneyLogger::Event::EVENT_SELECTED_OTHER;\n  switch (state_->selected_instrument()->type()) {\n    case PaymentInstrument::Type::AUTOFILL:\n      selected_event = JourneyLogger::Event::EVENT_SELECTED_CREDIT_CARD;\n      break;\n    case PaymentInstrument::Type::SERVICE_WORKER_APP:\n      selected_event = JourneyLogger::Event::EVENT_SELECTED_OTHER;\n      break;\n    case PaymentInstrument::Type::NATIVE_MOBILE_APP:\n      NOTREACHED();\n      break;\n  }\n  journey_logger_.SetEventOccurred(selected_event);\n\n  state_->GeneratePaymentResponse();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2019-5755",
        "length": 158
    },
    {
        "index": 33745,
        "code": "static void hidp_process_handshake(struct hidp_session *session,\n\t\t\t\t\tunsigned char param)\n{\n\tBT_DBG(\"session %p param 0x%02x\", session, param);\n\tsession->output_report_success = 0; /* default condition */\n\n\tswitch (param) {\n\tcase HIDP_HSHK_SUCCESSFUL:\n\t\t/* FIXME: Call into SET_ GET_ handlers here */\n\t\tsession->output_report_success = 1;\n\t\tbreak;\n\n\tcase HIDP_HSHK_NOT_READY:\n\tcase HIDP_HSHK_ERR_INVALID_REPORT_ID:\n\tcase HIDP_HSHK_ERR_UNSUPPORTED_REQUEST:\n\tcase HIDP_HSHK_ERR_INVALID_PARAMETER:\n\t\tif (test_and_clear_bit(HIDP_WAITING_FOR_RETURN, &session->flags))\n\t\t\twake_up_interruptible(&session->report_queue);\n\n\t\t/* FIXME: Call into SET_ GET_ handlers here */\n\t\tbreak;\n\n\tcase HIDP_HSHK_ERR_UNKNOWN:\n\t\tbreak;\n\n\tcase HIDP_HSHK_ERR_FATAL:\n\t\t/* Device requests a reboot, as this is the only way this error\n\t\t * can be recovered. */\n\t\t__hidp_send_ctrl_message(session,\n\t\t\tHIDP_TRANS_HID_CONTROL | HIDP_CTRL_SOFT_RESET, NULL, 0);\n\t\tbreak;\n\n\tdefault:\n\t\t__hidp_send_ctrl_message(session,\n\t\t\tHIDP_TRANS_HANDSHAKE | HIDP_HSHK_ERR_INVALID_PARAMETER, NULL, 0);\n\t\tbreak;\n\t}\n\n\t/* Wake up the waiting thread. */\n\tif (test_and_clear_bit(HIDP_WAITING_FOR_SEND_ACK, &session->flags))\n\t\twake_up_interruptible(&session->report_queue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-0349",
        "length": 343
    },
    {
        "index": 19546,
        "code": "static sector_t udf_scan_anchors(struct super_block *sb, sector_t lastblock,\n\t\t\t\t struct kernel_lb_addr *fileset)\n{\n\tsector_t last[6];\n\tint i;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tint last_count = 0;\n\n\t/* First try user provided anchor */\n\tif (sbi->s_anchor) {\n\t\tif (udf_check_anchor_block(sb, sbi->s_anchor, fileset))\n\t\t\treturn lastblock;\n\t}\n\t/*\n\t * according to spec, anchor is in either:\n\t *     block 256\n\t *     lastblock-256\n\t *     lastblock\n\t *  however, if the disc isn't closed, it could be 512.\n\t */\n\tif (udf_check_anchor_block(sb, sbi->s_session + 256, fileset))\n\t\treturn lastblock;\n\t/*\n\t * The trouble is which block is the last one. Drives often misreport\n\t * this so we try various possibilities.\n\t */\n\tlast[last_count++] = lastblock;\n\tif (lastblock >= 1)\n\t\tlast[last_count++] = lastblock - 1;\n\tlast[last_count++] = lastblock + 1;\n\tif (lastblock >= 2)\n\t\tlast[last_count++] = lastblock - 2;\n\tif (lastblock >= 150)\n\t\tlast[last_count++] = lastblock - 150;\n\tif (lastblock >= 152)\n\t\tlast[last_count++] = lastblock - 152;\n\n\tfor (i = 0; i < last_count; i++) {\n\t\tif (last[i] >= sb->s_bdev->bd_inode->i_size >>\n\t\t\t\tsb->s_blocksize_bits)\n\t\t\tcontinue;\n\t\tif (udf_check_anchor_block(sb, last[i], fileset))\n\t\t\treturn last[i];\n\t\tif (last[i] < 256)\n\t\t\tcontinue;\n\t\tif (udf_check_anchor_block(sb, last[i] - 256, fileset))\n\t\t\treturn last[i];\n\t}\n\n\t/* Finally try block 512 in case media is open */\n\tif (udf_check_anchor_block(sb, sbi->s_session + 512, fileset))\n\t\treturn last[0];\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3400",
        "length": 466
    },
    {
        "index": 42020,
        "code": "void exit_shm(struct task_struct *task)\n{\n\tstruct ipc_namespace *ns = task->nsproxy->ipc_ns;\n\tstruct shmid_kernel *shp, *n;\n\n\tif (list_empty(&task->sysvshm.shm_clist))\n\t\treturn;\n\n\t/*\n\t * If kernel.shm_rmid_forced is not set then only keep track of\n\t * which shmids are orphaned, so that a later set of the sysctl\n\t * can clean them up.\n\t */\n\tif (!ns->shm_rmid_forced) {\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\tlist_for_each_entry(shp, &task->sysvshm.shm_clist, shm_clist)\n\t\t\tshp->shm_creator = NULL;\n\t\t/*\n\t\t * Only under read lock but we are only called on current\n\t\t * so no entry on the list will be shared.\n\t\t */\n\t\tlist_del(&task->sysvshm.shm_clist);\n\t\tup_read(&shm_ids(ns).rwsem);\n\t\treturn;\n\t}\n\n\t/*\n\t * Destroy all already created segments, that were not yet mapped,\n\t * and mark any mapped as orphan to cover the sysctl toggling.\n\t * Destroy is skipped if shm_may_destroy() returns false.\n\t */\n\tdown_write(&shm_ids(ns).rwsem);\n\tlist_for_each_entry_safe(shp, n, &task->sysvshm.shm_clist, shm_clist) {\n\t\tshp->shm_creator = NULL;\n\n\t\tif (shm_may_destroy(ns, shp)) {\n\t\t\tshm_lock_by_ptr(shp);\n\t\t\tshm_destroy(ns, shp);\n\t\t}\n\t}\n\n\t/* Remove the list head from any segments still attached. */\n\tlist_del(&task->sysvshm.shm_clist);\n\tup_write(&shm_ids(ns).rwsem);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2015-7613",
        "length": 387
    },
    {
        "index": 167370,
        "code": "  explicit RemovePermissionPromptCountsTest(TestingProfile* profile)\n      : autoblocker_(PermissionDecisionAutoBlocker::GetForProfile(profile)) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-6151",
        "length": 31
    },
    {
        "index": 76232,
        "code": "static int cdrom_ioctl_eject_sw(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROMEJECT_SW\\n\");\n\n\tif (!CDROM_CAN(CDC_OPEN_TRAY))\n\t\treturn -ENOSYS;\n\tif (cdi->keeplocked)\n\t\treturn -EBUSY;\n\n\tcdi->options &= ~(CDO_AUTO_CLOSE | CDO_AUTO_EJECT);\n\tif (arg)\n\t\tcdi->options |= CDO_AUTO_CLOSE | CDO_AUTO_EJECT;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-18710",
        "length": 116
    },
    {
        "index": 181705,
        "code": " cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n {\n \twhile (rows-- > 0) {\n \t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}\n",
        "line": "    uint32 rows, uint32 cols, int outskew, int inskew)\n",
        "label": 1,
        "cwe": "CWE-190",
        "cve": "CVE-2016-10093",
        "length": 86
    },
    {
        "index": 171076,
        "code": " virtual status_t initCheck() const {\n return OK;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-3920",
        "length": 13
    },
    {
        "index": 26500,
        "code": "static void __devexit pmcraid_remove(struct pci_dev *pdev)\n{\n\tstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\n\n\t/* remove the management interface (/dev file) for this device */\n\tpmcraid_release_chrdev(pinstance);\n\n\t/* remove host template from scsi midlayer */\n\tscsi_remove_host(pinstance->host);\n\n\t/* block requests from mid-layer */\n\tscsi_block_requests(pinstance->host);\n\n\t/* initiate shutdown adapter */\n\tpmcraid_shutdown(pdev);\n\n\tpmcraid_disable_interrupts(pinstance, ~0);\n\tflush_work_sync(&pinstance->worker_q);\n\n\tpmcraid_kill_tasklets(pinstance);\n\tpmcraid_unregister_interrupt_handler(pinstance);\n\tpmcraid_release_buffers(pinstance);\n\tiounmap(pinstance->mapped_dma_addr);\n\tpci_release_regions(pdev);\n\tscsi_host_put(pinstance->host);\n\tpci_disable_device(pdev);\n\n\treturn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-2906",
        "length": 186
    },
    {
        "index": 113936,
        "code": "void RegistrationManager::RegistrationStatus::Disable() {\n  enabled = false;\n  state = invalidation::InvalidationListener::UNREGISTERED;\n  registration_timer.Stop();\n  delay = base::TimeDelta();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 44
    },
    {
        "index": 146699,
        "code": "HTMLDialogElement* Document::ActiveModalDialog() const {\n  if (top_layer_elements_.IsEmpty())\n    return 0;\n  return toHTMLDialogElement(top_layer_elements_.back().Get());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 42
    },
    {
        "index": 84887,
        "code": "decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1066",
        "length": 320
    },
    {
        "index": 141801,
        "code": "void ChromeMetricsServiceClient::OnURLOpenedFromOmnibox(OmniboxLog* log) {\n  metrics_service_->OnApplicationNotIdle();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2016-5165",
        "length": 34
    },
    {
        "index": 131689,
        "code": "static void runtimeEnabledLongAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValueInt(info, imp->runtimeEnabledLongAttribute());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 59
    },
    {
        "index": 134405,
        "code": "void TabStrip::RemoveAndDeleteTab(Tab* tab) {\n  scoped_ptr<Tab> deleter(tab);\n  for (TabsClosingMap::iterator i(tabs_closing_map_.begin());\n       i != tabs_closing_map_.end(); ++i) {\n    std::vector<Tab*>::iterator j =\n        std::find(i->second.begin(), i->second.end(), tab);\n    if (j != i->second.end()) {\n      i->second.erase(j);\n      if (i->second.empty())\n        tabs_closing_map_.erase(i);\n      return;\n    }\n  }\n  NOTREACHED();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 130
    },
    {
        "index": 130555,
        "code": "void drawRect(GraphicsContext& context, const TestDisplayItemClient& client, DisplayItem::Type type, const FloatRect& bounds)\n{\n    if (DrawingRecorder::useCachedDrawingIfPossible(context, client, type))\n        return;\n    DrawingRecorder drawingRecorder(context, client, type, bounds);\n    IntRect rect(0, 0, 10, 10);\n    context.drawRect(rect);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 85
    },
    {
        "index": 144733,
        "code": "void LocalSiteCharacteristicsDataImpl::NotifyLoadedSiteBackgrounded() {\n  if (loaded_tabs_in_background_count_ == 0)\n    background_session_begin_ = NowTicks();\n\n  loaded_tabs_in_background_count_++;\n\n  DCHECK_LE(loaded_tabs_in_background_count_, loaded_tabs_count_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1613",
        "length": 61
    },
    {
        "index": 149712,
        "code": "void SetFeatureEntries(const std::vector<FeatureEntry>& entries) {\n  GetEntriesForTesting()->clear();\n  for (const auto& entry : entries)\n    GetEntriesForTesting()->push_back(entry);\n  FlagsStateSingleton::GetInstance()->RebuildState(*GetEntriesForTesting());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5083",
        "length": 61
    },
    {
        "index": 162065,
        "code": "RenderProcessHost* RenderProcessHostImpl::CreateOrUseSpareRenderProcessHost(\n    BrowserContext* browser_context,\n    StoragePartitionImpl* storage_partition_impl,\n    SiteInstance* site_instance,\n    bool is_for_guests_only) {\n  RenderProcessHost* render_process_host =\n      g_spare_render_process_host_manager.Get().MaybeTakeSpareRenderProcessHost(\n          browser_context, storage_partition_impl, site_instance,\n          is_for_guests_only);\n\n  if (!render_process_host) {\n    render_process_host =\n        CreateRenderProcessHost(browser_context, storage_partition_impl,\n                                site_instance, is_for_guests_only);\n  }\n\n  DCHECK(render_process_host);\n  return render_process_host;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 146
    },
    {
        "index": 20633,
        "code": "static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);\n\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(&p->data, vcpu->mmio_data, 8);\n\tp->state = STATE_IORESP_READY;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-1601",
        "length": 72
    },
    {
        "index": 67239,
        "code": "brcmf_do_escan(struct brcmf_if *ifp, struct cfg80211_scan_request *request)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\ts32 err;\n\tu32 passive_scan;\n\tstruct brcmf_scan_results *results;\n\tstruct escan_info *escan = &cfg->escan_info;\n\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\tescan->ifp = ifp;\n\tescan->wiphy = cfg->wiphy;\n\tescan->escan_state = WL_ESCAN_STATE_SCANNING;\n\tpassive_scan = cfg->active_scan ? 0 : 1;\n\terr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\n\t\t\t\t    passive_scan);\n\tif (err) {\n\t\tbrcmf_err(\"error (%d)\\n\", err);\n\t\treturn err;\n\t}\n\tbrcmf_scan_config_mpc(ifp, 0);\n\tresults = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\n\tresults->version = 0;\n\tresults->count = 0;\n\tresults->buflen = WL_ESCAN_RESULTS_FIXED_SIZE;\n\n\terr = escan->run(cfg, ifp, request);\n\tif (err)\n\t\tbrcmf_scan_config_mpc(ifp, 1);\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7541",
        "length": 283
    },
    {
        "index": 91058,
        "code": "\t\tvoid CWebServer::RType_Notifications(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"Notifications\";\n\n\t\t\tint ii = 0;\n\n\t\t\tfor (const auto & ittNotifiers : m_notifications.m_notifiers)\n\t\t\t{\n\t\t\t\troot[\"notifiers\"][ii][\"name\"] = ittNotifiers.first;\n\t\t\t\troot[\"notifiers\"][ii][\"description\"] = ittNotifiers.first;\n\t\t\t\tii++;\n\t\t\t}\n\n\t\t\tuint64_t idx = 0;\n\t\t\tif (request::findValue(&req, \"idx\") != \"\")\n\t\t\t{\n\t\t\t\tidx = std::strtoull(request::findValue(&req, \"idx\").c_str(), nullptr, 10);\n\t\t\t}\n\t\t\tstd::vector<_tNotification> notifications = m_notifications.GetNotifications(idx);\n\t\t\tif (notifications.size() > 0)\n\t\t\t{\n\t\t\t\tii = 0;\n\t\t\t\tfor (const auto & itt : notifications)\n\t\t\t\t{\n\t\t\t\t\troot[\"result\"][ii][\"idx\"] = itt.ID;\n\t\t\t\t\tstd::string sParams = itt.Params;\n\t\t\t\t\tif (sParams.empty()) {\n\t\t\t\t\t\tsParams = \"S\";\n\t\t\t\t\t}\n\t\t\t\t\troot[\"result\"][ii][\"Params\"] = sParams;\n\t\t\t\t\troot[\"result\"][ii][\"Priority\"] = itt.Priority;\n\t\t\t\t\troot[\"result\"][ii][\"SendAlways\"] = itt.SendAlways;\n\t\t\t\t\troot[\"result\"][ii][\"CustomMessage\"] = itt.CustomMessage;\n\t\t\t\t\troot[\"result\"][ii][\"ActiveSystems\"] = itt.ActiveSystems;\n\t\t\t\t\tii++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-89",
        "cve": "CVE-2019-10664",
        "length": 354
    },
    {
        "index": 44266,
        "code": "int BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[],\n                         BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *u;\n\n    bn_check_top(a);\n\n    if (!p[0]) {\n        /* reduction mod 1 => return 0 */\n        BN_zero(r);\n        return 1;\n    }\n\n    BN_CTX_start(ctx);\n    if ((u = BN_CTX_get(ctx)) == NULL)\n        goto err;\n\n    if (!BN_set_bit(u, p[0] - 1))\n        goto err;\n    ret = BN_GF2m_mod_exp_arr(r, a, u, p, ctx);\n    bn_check_top(r);\n\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2015-1788",
        "length": 166
    },
    {
        "index": 11265,
        "code": "static int vapic_post_load(void *opaque, int version_id)\n{\n    VAPICROMState *s = opaque;\n\n    /*\n     * The old implementation of qemu-kvm did not provide the state\n     * VAPIC_STANDBY. Reconstruct it.\n     */\n    if (s->state == VAPIC_INACTIVE && s->rom_state_paddr != 0) {\n        s->state = VAPIC_STANDBY;\n    }\n\n    if (s->state != VAPIC_INACTIVE) {\n        if (vapic_prepare(s) < 0) {\n            return -1;\n        }\n    }\n\n    if (!s->vmsentry) {\n        s->vmsentry =\n            qemu_add_vm_change_state_handler(kvmvapic_vm_state_change, s);\n    }\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-4020",
        "length": 177
    },
    {
        "index": 66147,
        "code": "static inline int is_ctext(char ch)\n{\n  unsigned char uch = (unsigned char) ch;\n\n  if (is_no_ws_ctl(ch))\n    return TRUE;\n\n  if (uch < 33)\n    return FALSE;\n\n  if ((uch == 40) || (uch == 41))\n    return FALSE;\n  \n  if (uch == 92)\n    return FALSE;\n\n  if (uch == 127)\n    return FALSE;\n\n  return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-8825",
        "length": 96
    },
    {
        "index": 132361,
        "code": "void DeviceManagerImpl::OpenDevice(\n    const mojo::String& guid,\n    mojo::InterfaceRequest<Device> device_request,\n    const OpenDeviceCallback& callback) {\n  service_task_runner_->PostTask(\n      FROM_HERE, base::Bind(&OpenDeviceOnServiceThread, guid,\n                            base::Passed(&device_request), callback,\n                            base::ThreadTaskRunnerHandle::Get()));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 82
    },
    {
        "index": 128643,
        "code": "  void CreateSearchContextAndRequestSearchTerm(\n      const std::string& selected_text,\n      const base::string16& surrounding_text,\n      int start_offset,\n      int end_offset) {\n    test_context_ = new ContextualSearchContext(\n        selected_text, true, GURL(kSomeSpecificBasePage), \"utf-8\");\n    delegate_->set_context_for_testing(test_context_);\n\n    test_context_->start_offset = start_offset;\n    test_context_->end_offset = end_offset;\n    test_context_->surrounding_text = surrounding_text;\n    delegate_->ContinueSearchTermResolutionRequest();\n    fetcher_ = test_factory_.GetFetcherByID(\n        ContextualSearchDelegate::kContextualSearchURLFetcherID);\n    ASSERT_TRUE(fetcher_);\n    ASSERT_TRUE(fetcher());\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3200",
        "length": 161
    },
    {
        "index": 93492,
        "code": "static int l_set_timeout(lua_State *L) {\n    long timeout = luaL_checkinteger(L, 2);\n    struct ssh_userdata *state = NULL;\n    state = (struct ssh_userdata *) nseU_checkudata(L, 1, SSH2_UDATA, \"ssh2\");\n\n    libssh2_session_set_timeout(state->session, timeout);\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2017-18594",
        "length": 80
    },
    {
        "index": 142539,
        "code": "ShelfWidget::DelegateView::DelegateView(ShelfWidget* shelf_widget)\n    : shelf_widget_(shelf_widget),\n      focus_cycler_(nullptr),\n      opaque_background_(ui::LAYER_SOLID_COLOR) {\n  DCHECK(shelf_widget_);\n  set_owned_by_client();  // Deleted by DeleteDelegate().\n\n  SetLayoutManager(std::make_unique<views::FillLayout>());\n  set_allow_deactivate_on_esc(true);\n\n  UpdateOpaqueBackground();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 94
    },
    {
        "index": 58552,
        "code": "void transport_attach(rdpTransport* transport, int sockfd)\n{\n\ttransport->TcpIn->sockfd = sockfd;\n\n\ttransport->SplitInputOutput = FALSE;\n\ttransport->TcpOut = transport->TcpIn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2013-4119",
        "length": 46
    },
    {
        "index": 26244,
        "code": "static void __free_domain_allocs(struct s_data *d, enum s_alloc what,\n\t\t\t\t const struct cpumask *cpu_map)\n{\n\tswitch (what) {\n\tcase sa_rootdomain:\n\t\tif (!atomic_read(&d->rd->refcount))\n\t\t\tfree_rootdomain(&d->rd->rcu); /* fall through */\n\tcase sa_sd:\n\t\tfree_percpu(d->sd); /* fall through */\n\tcase sa_sd_storage:\n\t\t__sdt_free(cpu_map); /* fall through */\n\tcase sa_none:\n\t\tbreak;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 113
    },
    {
        "index": 139458,
        "code": "static bool ExecuteMovePageUp(LocalFrame& frame,\n                              Event*,\n                              EditorCommandSource,\n                              const String&) {\n  unsigned distance = VerticalScrollDistance(frame);\n  if (!distance)\n    return false;\n  return ModifySelectionyWithPageGranularity(\n      frame, SelectionModifyAlteration::kMove, distance,\n      SelectionModifyVerticalDirection::kUp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1265",
        "length": 77
    },
    {
        "index": 146095,
        "code": "String WebGL2RenderingContextBase::getActiveUniformBlockName(\n    WebGLProgram* program,\n    GLuint uniform_block_index) {\n  if (isContextLost() ||\n      !ValidateWebGLObject(\"getActiveUniformBlockName\", program))\n    return String();\n\n  if (!ValidateUniformBlockIndex(\"getActiveUniformBlockName\", program,\n                                 uniform_block_index))\n    return String();\n\n  GLint max_name_length = -1;\n  ContextGL()->GetProgramiv(ObjectOrZero(program),\n                            GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH,\n                            &max_name_length);\n  if (max_name_length <= 0) {\n    SynthesizeGLError(GL_INVALID_VALUE, \"getActiveUniformBlockName\",\n                      \"invalid uniform block index\");\n    return String();\n  }\n  std::unique_ptr<GLchar[]> name = WrapArrayUnique(new GLchar[max_name_length]);\n\n  GLsizei length = 0;\n  ContextGL()->GetActiveUniformBlockName(ObjectOrZero(program),\n                                         uniform_block_index, max_name_length,\n                                         &length, name.get());\n\n  return String(name.get(), length);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 221
    },
    {
        "index": 64293,
        "code": "static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy,\n                                        const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    int lim;\n\n    if (err != NULL) {\n        return err;\n    }\n\n    lim = atoi(arg);\n    if (lim < 0) {\n        return apr_pstrcat(cmd->temp_pool, \"LimitRequestFields \\\"\", arg,\n                           \"\\\" must be a non-negative integer (0 = no limit)\",\n                           NULL);\n    }\n\n    cmd->server->limit_req_fields = lim;\n    return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-9798",
        "length": 130
    },
    {
        "index": 168088,
        "code": "void AutofillManager::SetTestDelegate(AutofillManagerTestDelegate* delegate) {\n  test_delegate_ = delegate;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-16078",
        "length": 28
    },
    {
        "index": 32490,
        "code": "static int tg3_5700_link_polarity(struct tg3 *tp, u32 speed)\n{\n\tif (tp->led_ctrl == LED_CTRL_MODE_PHY_2)\n\t\treturn 1;\n\telse if ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5411) {\n\t\tif (speed != SPEED_10)\n\t\t\treturn 1;\n\t} else if (speed == SPEED_10)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-1929",
        "length": 101
    },
    {
        "index": 132360,
        "code": "void OnOpenDeviceOnServiceThread(\n    mojo::InterfaceRequest<Device> device_request,\n    const DeviceManager::OpenDeviceCallback& callback,\n    scoped_refptr<base::TaskRunner> callback_task_runner,\n    scoped_refptr<UsbDeviceHandle> device_handle) {\n  if (!device_handle) {\n    callback_task_runner->PostTask(FROM_HERE,\n                                   base::Bind(&RunOpenDeviceCallback, callback,\n                                              OPEN_DEVICE_ERROR_ACCESS_DENIED));\n    return;\n  }\n\n  new DeviceImpl(device_handle, device_request.Pass());\n\n  callback_task_runner->PostTask(\n      FROM_HERE,\n      base::Bind(&RunOpenDeviceCallback, callback, OPEN_DEVICE_ERROR_OK));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 140
    },
    {
        "index": 110986,
        "code": "void RootWindowHostWin::SetFocusWhenShown(bool focus_when_shown) {\n  NOTIMPLEMENTED();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 24
    },
    {
        "index": 168113,
        "code": "  void CreateTestAutofillProfiles() {\n    AutofillProfile profile1;\n    test::SetProfileInfo(&profile1, \"Elvis\", \"Aaron\", \"Presley\",\n                         \"theking@gmail.com\", \"RCA\", \"3734 Elvis Presley Blvd.\",\n                         \"Apt. 10\", \"Memphis\", \"Tennessee\", \"38116\", \"US\",\n                         \"12345678901\");\n    profile1.set_guid(\"00000000-0000-0000-0000-000000000001\");\n    personal_data_.AddProfile(profile1);\n\n    AutofillProfile profile2;\n    test::SetProfileInfo(&profile2, \"Charles\", \"Hardin\", \"Holley\",\n                         \"buddy@gmail.com\", \"Decca\", \"123 Apple St.\", \"unit 6\",\n                         \"Lubbock\", \"Texas\", \"79401\", \"US\", \"23456789012\");\n    profile2.set_guid(\"00000000-0000-0000-0000-000000000002\");\n    personal_data_.AddProfile(profile2);\n\n    AutofillProfile profile3;\n    test::SetProfileInfo(&profile3, \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n                         \"\");\n    profile3.set_guid(\"00000000-0000-0000-0000-000000000003\");\n    personal_data_.AddProfile(profile3);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-16078",
        "length": 290
    },
    {
        "index": 24904,
        "code": "static void slab_fix(struct kmem_cache *s, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[100];\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\tprintk(KERN_ERR \"FIX %s: %s\\n\", s->name, buf);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-3209",
        "length": 68
    },
    {
        "index": 34924,
        "code": "void rpc_task_release_client(struct rpc_task *task)\n{\n\tstruct rpc_clnt *clnt = task->tk_client;\n\n\tif (clnt != NULL) {\n\t\t/* Remove from client task list */\n\t\tspin_lock(&clnt->cl_lock);\n\t\tlist_del(&task->tk_task);\n\t\tspin_unlock(&clnt->cl_lock);\n\t\ttask->tk_client = NULL;\n\n\t\trpc_release_client(clnt);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2491",
        "length": 91
    },
    {
        "index": 98023,
        "code": "bool RenderView::ScheduleFileChooser(\n    const ViewHostMsg_RunFileChooser_Params& params,\n    WebFileChooserCompletion* completion) {\n  static const size_t kMaximumPendingFileChooseRequests = 4;\n  if (file_chooser_completions_.size() > kMaximumPendingFileChooseRequests) {\n    return false;\n  }\n\n  file_chooser_completions_.push_back(linked_ptr<PendingFileChooser>(\n      new PendingFileChooser(params, completion)));\n  if (file_chooser_completions_.size() == 1) {\n    Send(new ViewHostMsg_RunFileChooser(routing_id_, params));\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 132
    },
    {
        "index": 157787,
        "code": "TextInputManager* WebContentsImpl::GetTextInputManager() {\n  if (GetOuterWebContents())\n    return GetOuterWebContents()->GetTextInputManager();\n\n  if (!text_input_manager_) {\n    text_input_manager_.reset(new TextInputManager(\n        GetBrowserContext() &&\n        !GetBrowserContext()->IsOffTheRecord()) /* should_do_learning */);\n  }\n\n  return text_input_manager_.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-20067",
        "length": 84
    },
    {
        "index": 36758,
        "code": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\n\treturn (ret);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2014-4344",
        "length": 162
    },
    {
        "index": 174058,
        "code": "u32 CropPicture(u8 *pOutImage, u8 *pInImage,\n    u32 picWidth, u32 picHeight, CropParams *pCropParams)\n{\n\n    u32 i, j;\n    u32 outWidth, outHeight;\n    u8 *pOut, *pIn;\n\n if (pOutImage == NULL || pInImage == NULL || pCropParams == NULL ||\n !picWidth || !picHeight)\n {\n /* due to lint warning */\n        free(pOutImage);\n return(1);\n }\n\n if ( ((pCropParams->cropLeftOffset + pCropParams->cropOutWidth) >\n           picWidth ) ||\n ((pCropParams->cropTopOffset + pCropParams->cropOutHeight) >\n           picHeight ) )\n {\n /* due to lint warning */\n        free(pOutImage);\n return(1);\n }\n\n    outWidth = pCropParams->cropOutWidth;\n    outHeight = pCropParams->cropOutHeight;\n\n    pIn = pInImage + pCropParams->cropTopOffset*picWidth +\n        pCropParams->cropLeftOffset;\n    pOut = pOutImage;\n\n /* luma */\n for (i = outHeight; i; i--)\n {\n for (j = outWidth; j; j--)\n {\n *pOut++ = *pIn++;\n }\n        pIn += picWidth - outWidth;\n }\n\n    outWidth >>= 1;\n    outHeight >>= 1;\n\n    pIn = pInImage + picWidth*picHeight +\n        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;\n\n /* cb */\n for (i = outHeight; i; i--)\n {\n for (j = outWidth; j; j--)\n {\n *pOut++ = *pIn++;\n }\n        pIn += picWidth/2 - outWidth;\n }\n\n    pIn = pInImage + 5*picWidth*picHeight/4 +\n        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;\n\n /* cr */\n for (i = outHeight; i; i--)\n {\n for (j = outWidth; j; j--)\n {\n *pOut++ = *pIn++;\n }\n        pIn += picWidth/2 - outWidth;\n }\n\n return (0);\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2463",
        "length": 486
    },
    {
        "index": 36739,
        "code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2014-4344",
        "length": 69
    },
    {
        "index": 7185,
        "code": "AuthBackend::~AuthBackend()\n{\n    delete d;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-290",
        "cve": "CVE-2017-8422",
        "length": 13
    },
    {
        "index": 158609,
        "code": "void FrameFetchContext::DispatchDidDownloadToBlob(unsigned long identifier,\n                                                  BlobDataHandle* blob) {\n  if (IsDetached() || !blob)\n    return;\n\n  probe::didReceiveBlob(GetFrame()->GetDocument(), identifier,\n                        MasterDocumentLoader(), blob);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-17468",
        "length": 59
    },
    {
        "index": 113275,
        "code": "void PanelBrowserView::AnimationEnded(const ui::Animation* animation) {\n  panel_->manager()->OnPanelAnimationEnded(panel_.get());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 30
    },
    {
        "index": 135938,
        "code": "static inline LayoutObject* endOfContinuations(LayoutObject* layoutObject)\n{\n    LayoutObject* prev = nullptr;\n    LayoutObject* cur = layoutObject;\n\n    if (!cur->isLayoutInline() && !cur->isLayoutBlock())\n        return nullptr;\n\n    while (cur) {\n        prev = cur;\n        if (cur->isLayoutInline())\n            cur = toLayoutInline(cur)->continuation();\n        else\n            cur = toLayoutBlock(cur)->continuation();\n    }\n\n    return prev;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6777",
        "length": 107
    },
    {
        "index": 45735,
        "code": "static int crypto_gcm_encrypt(struct aead_request *req)\n{\n\tstruct crypto_gcm_req_priv_ctx *pctx = crypto_gcm_reqctx(req);\n\tstruct ablkcipher_request *abreq = &pctx->u.abreq;\n\tstruct crypto_gcm_ghash_ctx *gctx = &pctx->ghash_ctx;\n\tint err;\n\n\tcrypto_gcm_init_crypt(abreq, req, req->cryptlen);\n\tablkcipher_request_set_callback(abreq, aead_request_flags(req),\n\t\t\t\t\tgcm_encrypt_done, req);\n\n\tgctx->src = req->dst;\n\tgctx->cryptlen = req->cryptlen;\n\tgctx->complete = gcm_enc_hash_done;\n\n\terr = crypto_ablkcipher_encrypt(abreq);\n\tif (err)\n\t\treturn err;\n\n\terr = gcm_hash(req, pctx);\n\tif (err)\n\t\treturn err;\n\n\tcrypto_xor(pctx->auth_tag, pctx->iauth_tag, 16);\n\tgcm_enc_copy_hash(req, pctx);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 216
    },
    {
        "index": 50802,
        "code": "idr_extend_identifier(struct idrent *wnp, int numsize, int nullsize)\n{\n\tunsigned char *p;\n\tint wnp_ext_off;\n\n\twnp_ext_off = wnp->isoent->ext_off;\n\tif (wnp->noff + numsize != wnp_ext_off) {\n\t\tp = (unsigned char *)wnp->isoent->identifier;\n\t\t/* Extend the filename; foo.c --> foo___.c */\n\t\tmemmove(p + wnp->noff + numsize, p + wnp_ext_off,\n\t\t    wnp->isoent->ext_len + nullsize);\n\t\twnp->isoent->ext_off = wnp_ext_off = wnp->noff + numsize;\n\t\twnp->isoent->id_len = wnp_ext_off + wnp->isoent->ext_len;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-6250",
        "length": 181
    },
    {
        "index": 5330,
        "code": "gs_id get_mem_hdr_id (void *ptr)\n{\n    return (*((hdr_id_t *)((byte *)ptr) - HDR_ID_OFFSET));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-9835",
        "length": 30
    },
    {
        "index": 16736,
        "code": "static void str_skip_input_data(j_decompress_ptr cinfo, long num_bytes)\n{\n  struct str_src_mgr * src = (struct str_src_mgr *)cinfo->src;\n  if (num_bytes > 0) {\n    while (num_bytes > (long) src->pub.bytes_in_buffer) {\n      num_bytes -= (long) src->pub.bytes_in_buffer;\n      str_fill_input_buffer(cinfo);\n    }\n    src->pub.next_input_byte += (size_t) num_bytes;\n    src->pub.bytes_in_buffer -= (size_t) num_bytes;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-5110",
        "length": 122
    },
    {
        "index": 57930,
        "code": "__nf_tables_chain_type_lookup(int family, const struct nlattr *nla)\n{\n\tint i;\n\n\tfor (i = 0; i < NFT_CHAIN_T_MAX; i++) {\n\t\tif (chain_type[family][i] != NULL &&\n\t\t    !nla_strcmp(nla, chain_type[family][i]->name))\n\t\t\treturn chain_type[family][i];\n\t}\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1573",
        "length": 85
    },
    {
        "index": 8710,
        "code": "url_escape_dir (const char *dir)\n{\n  char *newdir = url_escape_1 (dir, urlchr_unsafe | urlchr_reserved, 1);\n  if (newdir == dir)\n    return (char *)dir;\n\n  unescape_single_char (newdir, '/');\n  return newdir;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-93",
        "cve": "CVE-2017-6508",
        "length": 67
    },
    {
        "index": 19592,
        "code": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-3375",
        "length": 27
    },
    {
        "index": 81494,
        "code": "tracing_readme_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\treadme_msg, strlen(readme_msg));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 57
    },
    {
        "index": 110606,
        "code": "error::Error GLES2DecoderImpl::HandleTexSubImage2DImmediate(\n    uint32 immediate_data_size, const gles2::TexSubImage2DImmediate& c) {\n  GLboolean internal = static_cast<GLboolean>(c.internal);\n  if (internal == GL_TRUE && tex_image_2d_failed_)\n    return error::kNoError;\n\n  GLenum target = static_cast<GLenum>(c.target);\n  GLint level = static_cast<GLint>(c.level);\n  GLint xoffset = static_cast<GLint>(c.xoffset);\n  GLint yoffset = static_cast<GLint>(c.yoffset);\n  GLsizei width = static_cast<GLsizei>(c.width);\n  GLsizei height = static_cast<GLsizei>(c.height);\n  GLenum format = static_cast<GLenum>(c.format);\n  GLenum type = static_cast<GLenum>(c.type);\n  uint32 data_size;\n  if (!GLES2Util::ComputeImageDataSizes(\n      width, height, format, type, unpack_alignment_, &data_size, NULL, NULL)) {\n    return error::kOutOfBounds;\n  }\n  const void* pixels = GetImmediateDataAs<const void*>(\n      c, data_size, immediate_data_size);\n  if (!validators_->texture_target.IsValid(target)) {\n    SetGLErrorInvalidEnum(\"glTexSubImage2D\", target, \"target\");\n    return error::kNoError;\n  }\n  if (width < 0) {\n    SetGLError(GL_INVALID_VALUE, \"glTexSubImage2D\", \"width < 0\");\n    return error::kNoError;\n  }\n  if (height < 0) {\n    SetGLError(GL_INVALID_VALUE, \"glTexSubImage2D\", \"height < 0\");\n    return error::kNoError;\n  }\n  if (!validators_->texture_format.IsValid(format)) {\n    SetGLErrorInvalidEnum(\"glTexSubImage2D\", format, \"format\");\n    return error::kNoError;\n  }\n  if (!validators_->pixel_type.IsValid(type)) {\n    SetGLErrorInvalidEnum(\"glTexSubImage2D\", type, \"type\");\n    return error::kNoError;\n  }\n  if (pixels == NULL) {\n    return error::kOutOfBounds;\n  }\n  DoTexSubImage2D(\n      target, level, xoffset, yoffset, width, height, format, type, pixels);\n  return error::kNoError;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2896",
        "length": 510
    },
    {
        "index": 108532,
        "code": "QuotaManagerProxy::QuotaManagerProxy(\n    QuotaManager* manager, base::SingleThreadTaskRunner* io_thread)\n    : manager_(manager), io_thread_(io_thread) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-5112",
        "length": 42
    },
    {
        "index": 89553,
        "code": "SWFInput_file_seek(SWFInput input, long offset, int whence)\n{\n\tif ( fseek((FILE *)input->data, offset, whence) == -1 )\n\t{\n\t\tif ( errno == EBADF )\n\t\t\tSWF_error(\"This is not a seekable stream- use newSWFInput_stream instead\");\n\t\telse if ( errno == EINVAL )\n\t\t\tSWF_error(\"Invalid whence argument\");\n\t\telse\n\t\t\tSWF_error(\"Unknown error\");\n\t}\n\n\tif ( whence == SEEK_SET )\n\t\tinput->offset = offset;\n\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = input->length - offset;\n\n\telse if ( whence == SEEK_CUR )\n\t\tinput->offset += offset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-12980",
        "length": 146
    },
    {
        "index": 34382,
        "code": "static u64 get_extent_allocation_hint(struct inode *inode, u64 start,\n\t\t\t\t      u64 num_bytes)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tu64 alloc_hint = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = search_extent_mapping(em_tree, start, num_bytes);\n\tif (em) {\n\t\t/*\n\t\t * if block start isn't an actual block number then find the\n\t\t * first block in this inode and use that as a hint.  If that\n\t\t * block is also bogus then just don't worry about it.\n\t\t */\n\t\tif (em->block_start >= EXTENT_MAP_LAST_BYTE) {\n\t\t\tfree_extent_map(em);\n\t\t\tem = search_extent_mapping(em_tree, 0, 0);\n\t\t\tif (em && em->block_start < EXTENT_MAP_LAST_BYTE)\n\t\t\t\talloc_hint = em->block_start;\n\t\t\tif (em)\n\t\t\t\tfree_extent_map(em);\n\t\t} else {\n\t\t\talloc_hint = em->block_start;\n\t\t\tfree_extent_map(em);\n\t\t}\n\t}\n\tread_unlock(&em_tree->lock);\n\n\treturn alloc_hint;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2012-5375",
        "length": 246
    },
    {
        "index": 159003,
        "code": "pp::Resource PDFiumEngine::PrintPages(\n    const PP_PrintPageNumberRange_Dev* page_ranges,\n    uint32_t page_range_count,\n    const PP_PrintSettings_Dev& print_settings) {\n  ScopedSubstFont scoped_subst_font(this);\n  if ((print_settings.format & PP_PRINTOUTPUTFORMAT_PDF) &&\n      HasPermission(PERMISSION_PRINT_HIGH_QUALITY)) {\n    return PrintPagesAsPDF(page_ranges, page_range_count, print_settings);\n  }\n  if (HasPermission(PERMISSION_PRINT_LOW_QUALITY))\n    return PrintPagesAsRasterPDF(page_ranges, page_range_count, print_settings);\n  return pp::Resource();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-6031",
        "length": 137
    },
    {
        "index": 119009,
        "code": "void WebContentsImpl::RenderProcessGoneFromRenderManager(\n    RenderViewHost* render_view_host) {\n  DCHECK(crashed_status_ != base::TERMINATION_STATUS_STILL_RUNNING);\n  RenderViewTerminated(render_view_host, crashed_status_, crashed_error_code_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6626",
        "length": 58
    },
    {
        "index": 155242,
        "code": "void HTMLFormElement::reset() {\n  LocalFrame* frame = document().frame();\n  if (m_isInResetFunction || !frame)\n    return;\n\n  m_isInResetFunction = true;\n\n  if (dispatchEvent(Event::createCancelableBubble(EventTypeNames::reset)) !=\n      DispatchEventResult::NotCanceled) {\n    m_isInResetFunction = false;\n    return;\n  }\n\n  const FormAssociatedElement::List& elements = associatedElements();\n  for (unsigned i = 0; i < elements.size(); ++i) {\n    if (elements[i]->isFormControlElement())\n      toHTMLFormControlElement(elements[i])->reset();\n  }\n\n  m_isInResetFunction = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2016-5225",
        "length": 146
    },
    {
        "index": 131267,
        "code": "static void callWithScriptStateVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    ScriptState* currentState = ScriptState::current();\n    if (!currentState)\n        return;\n    ScriptState& state = *currentState;\n    imp->callWithScriptStateVoidMethod(&state);\n    if (state.hadException()) {\n        v8::Local<v8::Value> exception = state.exception();\n        state.clearException();\n        throwError(exception, info.GetIsolate());\n        return;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 128
    },
    {
        "index": 20670,
        "code": "static void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tkvm_x86_ops->get_gdt(emul_to_vcpu(ctxt), dt);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-1601",
        "length": 43
    },
    {
        "index": 138423,
        "code": "void Document::hoveredNodeDetached(Node* node)\n{\n    ASSERT(node);\n    if (!m_hoverNode)\n        return;\n\n    m_hoverNode->updateDistribution();\n    if (node != m_hoverNode && (!m_hoverNode->isTextNode() || node != ComposedTreeTraversal::parent(*m_hoverNode)))\n        return;\n\n    m_hoverNode = ComposedTreeTraversal::parent(*node);\n    while (m_hoverNode && !m_hoverNode->layoutObject())\n        m_hoverNode = ComposedTreeTraversal::parent(*m_hoverNode);\n\n    if (!page()->isCursorVisible())\n        return;\n\n    if (frame())\n        frame()->eventHandler().scheduleHoverStateUpdate();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1281",
        "length": 144
    },
    {
        "index": 111326,
        "code": "BlackBerry::Platform::String WebPage::selectedText() const\n{\n    return d->m_selectionHandler->selectedText();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 28
    },
    {
        "index": 73971,
        "code": "do_map (char *b, int map, char c)\n{\n\tint n;\n\n\tswitch (c) {\n\tcase '\\x7f':\n\t\t/* DEL mapings */\n\t\tif ( map & M_DELBS ) {\n\t\t\tb[0] = '\\x08'; n = 1;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x08':\n\t\t/* BS mapings */\n\t\tif ( map & M_BSDEL ) {\n\t\t\tb[0] = '\\x7f'; n = 1;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x0d':\n\t\t/* CR mappings */\n\t\tif ( map & M_CRLF ) {\n\t\t\tb[0] = '\\x0a'; n = 1;\n\t\t} else if ( map & M_CRCRLF ) {\n\t\t\tb[0] = '\\x0d'; b[1] = '\\x0a'; n = 2;\n\t\t} else if ( map & M_IGNCR ) {\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tcase '\\x0a':\n\t\t/* LF mappings */\n\t\tif ( map & M_LFCR ) {\n\t\t\tb[0] = '\\x0d'; n = 1;\n\t\t} else if ( map & M_LFCRLF ) {\n\t\t\tb[0] = '\\x0d'; b[1] = '\\x0a'; n = 2;\n\t\t} else if ( map & M_IGNLF ) {\n\t\t\tn = 0;\n\t\t} else {\n\t\t\tb[0] = c; n = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tb[0] = c; n = 1;\n\t\tbreak;\n\t}\n\n\treturn n;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-77",
        "cve": "CVE-2015-9059",
        "length": 415
    },
    {
        "index": 12494,
        "code": "bus_activation_entry_unref (BusActivationEntry *entry)\n{\n  if (entry == NULL) /* hash table requires this */\n    return;\n\n  _dbus_assert (entry->refcount > 0);\n  entry->refcount--;\n\n  if (entry->refcount > 0)\n    return;\n\n  dbus_free (entry->name);\n  dbus_free (entry->exec);\n  dbus_free (entry->user);\n  dbus_free (entry->filename);\n  dbus_free (entry->systemd_service);\n\n  dbus_free (entry);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3477",
        "length": 111
    },
    {
        "index": 164726,
        "code": "  void TestClearOnlyAutofilledFields(const char* html) {\n    LoadHTML(html);\n\n    WebLocalFrame* web_frame = GetMainFrame();\n    ASSERT_NE(nullptr, web_frame);\n\n    FormCache form_cache(web_frame);\n    std::vector<FormData> forms = form_cache.ExtractNewForms();\n    ASSERT_EQ(1U, forms.size());\n\n    WebInputElement firstname = GetInputElementById(\"firstname\");\n    firstname.SetAutofillState(WebAutofillState::kNotFilled);\n    WebInputElement lastname = GetInputElementById(\"lastname\");\n    lastname.SetAutofillState(WebAutofillState::kAutofilled);\n    WebInputElement email = GetInputElementById(\"email\");\n    email.SetAutofillState(WebAutofillState::kAutofilled);\n    WebInputElement phone = GetInputElementById(\"phone\");\n    phone.SetAutofillState(WebAutofillState::kAutofilled);\n\n    EXPECT_TRUE(form_cache.ClearSectionWithElement(firstname));\n\n    EXPECT_EQ(ASCIIToUTF16(\"Wyatt\"), firstname.Value().Utf16());\n    EXPECT_TRUE(firstname.SuggestedValue().IsEmpty());\n    EXPECT_FALSE(firstname.IsAutofilled());\n    EXPECT_TRUE(lastname.Value().IsEmpty());\n    EXPECT_TRUE(lastname.SuggestedValue().IsEmpty());\n    EXPECT_FALSE(lastname.IsAutofilled());\n    EXPECT_TRUE(email.Value().IsEmpty());\n    EXPECT_TRUE(email.SuggestedValue().IsEmpty());\n    EXPECT_FALSE(email.IsAutofilled());\n    EXPECT_TRUE(phone.Value().IsEmpty());\n    EXPECT_TRUE(phone.SuggestedValue().IsEmpty());\n    EXPECT_FALSE(phone.IsAutofilled());\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2019-5810",
        "length": 328
    },
    {
        "index": 128404,
        "code": "int RenderLayerScrollableArea::horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy relevancy) const\n{\n    if (!m_hBar || (m_hBar->isOverlayScrollbar() && (relevancy == IgnoreOverlayScrollbarSize || !m_hBar->shouldParticipateInHitTesting())))\n        return 0;\n    return m_hBar->height();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-3191",
        "length": 78
    },
    {
        "index": 49483,
        "code": "static void hid_close_report(struct hid_device *device)\n{\n\tunsigned i, j;\n\n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = device->report_enum + i;\n\n\t\tfor (j = 0; j < HID_MAX_IDS; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\t\t\tif (report)\n\t\t\t\thid_free_report(report);\n\t\t}\n\t\tmemset(report_enum, 0, sizeof(*report_enum));\n\t\tINIT_LIST_HEAD(&report_enum->report_list);\n\t}\n\n\tkfree(device->rdesc);\n\tdevice->rdesc = NULL;\n\tdevice->rsize = 0;\n\n\tkfree(device->collection);\n\tdevice->collection = NULL;\n\tdevice->collection_size = 0;\n\tdevice->maxcollection = 0;\n\tdevice->maxapplication = 0;\n\n\tdevice->status &= ~HID_STAT_PARSED;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-7915",
        "length": 192
    },
    {
        "index": 148271,
        "code": "void PrintJobWorker::OnNewPage() {\n  if (!document_.get())  // Spurious message.\n    return;\n\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n\n  if (page_number_ == PageNumber::npos()) {\n    int page_count = document_->page_count();\n    if (!page_count) {\n      return;\n    }\n    page_number_.Init(document_->settings(), page_count);\n  }\n  DCHECK_NE(page_number_, PageNumber::npos());\n\n  while (true) {\n    scoped_refptr<PrintedPage> page = document_->GetPage(page_number_.ToInt());\n    if (!page.get()) {\n      base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n          FROM_HERE,\n          base::BindOnce(&PrintJobWorker::OnNewPage,\n                         weak_factory_.GetWeakPtr()),\n          base::TimeDelta::FromMilliseconds(500));\n      break;\n    }\n    SpoolPage(page.get());\n    ++page_number_;\n    if (page_number_ == PageNumber::npos()) {\n      OnDocumentDone();\n      break;\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5093",
        "length": 224
    },
    {
        "index": 32460,
        "code": "void kvm_free_physmem(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_memslots *slots = kvm->memslots;\n\n\tfor (i = 0; i < slots->nmemslots; ++i)\n\t\tkvm_free_physmem_slot(&slots->memslots[i], NULL);\n\n\tkfree(kvm->memslots);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1943",
        "length": 70
    },
    {
        "index": 45901,
        "code": "static int __init seqiv_module_init(void)\n{\n\treturn crypto_register_template(&seqiv_tmpl);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-9644",
        "length": 23
    },
    {
        "index": 3297,
        "code": "static void fd_init(FDrive *drv)\n{\n    /* Drive */\n    drv->drive = FDRIVE_DRV_NONE;\n    drv->perpendicular = 0;\n    /* Disk */\n    drv->last_sect = 0;\n    drv->max_track = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-3456",
        "length": 59
    },
    {
        "index": 82827,
        "code": "static ut64 addr_to_offset(struct MACH0_(obj_t)* bin, ut64 addr) {\n\tut64 segment_base, segment_size;\n\tint i;\n\n\tif (!bin->segs) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tsegment_base = (ut64)bin->segs[i].vmaddr;\n\t\tsegment_size = (ut64)bin->segs[i].vmsize;\n\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t}\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-11380",
        "length": 148
    },
    {
        "index": 154736,
        "code": "error::Error GLES2DecoderPassthroughImpl::DoIsPathCHROMIUM(GLuint path,\n                                                           uint32_t* result) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 44
    },
    {
        "index": 160269,
        "code": "void MimeHandlerViewContainer::CreateMimeHandlerViewGuestIfNecessary() {\n  if (guest_created_ || !element_size_.has_value() || view_id_.empty())\n    return;\n\n  if (loader_) {\n    DCHECK(is_embedded_);\n    loader_.reset();\n  }\n\n  DCHECK_NE(element_instance_id(), guest_view::kInstanceIDNone);\n\n  if (!render_frame())\n    return;\n\n  render_frame()->Send(\n      new ExtensionsGuestViewHostMsg_CreateMimeHandlerViewGuest(\n          render_frame()->GetRoutingID(), view_id_, element_instance_id(),\n          *element_size_));\n\n  guest_created_ = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6089",
        "length": 133
    },
    {
        "index": 164892,
        "code": "std::string DownloadResourceHandler::DebugString() const {\n  const ResourceRequestInfoImpl* info = GetRequestInfo();\n  return base::StringPrintf(\"{\"\n                            \" url_ = \" \"\\\"%s\\\"\"\n                            \" info = {\"\n                            \" child_id = \" \"%d\"\n                            \" request_id = \" \"%d\"\n                            \" route_id = \" \"%d\"\n                            \" }\"\n                            \" }\",\n                            request() ?\n                                request()->url().spec().c_str() :\n                                \"<NULL request>\",\n                            info->GetChildID(),\n                            info->GetRequestID(),\n                            info->GetRouteID());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2019-5822",
        "length": 128
    },
    {
        "index": 78810,
        "code": "int sc_pkcs15emu_sc_hsm_get_curve(struct ec_curve **curve, u8 *oid, size_t oidlen)\n{\n\tint i;\n\n\tfor (i = 0; curves[i].oid.value; i++) {\n\t\tif ((curves[i].oid.len == oidlen) && !memcmp(curves[i].oid.value, oid, oidlen)) {\n\t\t\t*curve = &curves[i];\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_INVALID_DATA;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-16425",
        "length": 104
    },
    {
        "index": 62847,
        "code": "void bio_unmap_user(struct bio *bio)\n{\n\t__bio_unmap_user(bio);\n\tbio_put(bio);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-772",
        "cve": "CVE-2017-12190",
        "length": 28
    },
    {
        "index": 21730,
        "code": "static int em_bsr(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 zf;\n\n\t__asm__ (\"bsr %2, %0; setz %1\"\n\t\t : \"=r\"(ctxt->dst.val), \"=q\"(zf)\n\t\t : \"r\"(ctxt->src.val));\n\n\tctxt->eflags &= ~X86_EFLAGS_ZF;\n\tif (zf) {\n\t\tctxt->eflags |= X86_EFLAGS_ZF;\n\t\t/* Disable writeback. */\n\t\tctxt->dst.type = OP_NONE;\n\t}\n\treturn X86EMUL_CONTINUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-0045",
        "length": 124
    },
    {
        "index": 81952,
        "code": "static void completionCallback(const char *buf, linenoiseCompletions *lc) {\n    size_t startpos = 0;\n    int mask;\n    int i;\n    size_t matchlen;\n    sds tmp;\n\n    if (strncasecmp(buf,\"help \",5) == 0) {\n        startpos = 5;\n        while (isspace(buf[startpos])) startpos++;\n        mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;\n    } else {\n        mask = CLI_HELP_COMMAND;\n    }\n\n    for (i = 0; i < helpEntriesLen; i++) {\n        if (!(helpEntries[i].type & mask)) continue;\n\n        matchlen = strlen(buf+startpos);\n        if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {\n            tmp = sdsnewlen(buf,startpos);\n            tmp = sdscat(tmp,helpEntries[i].full);\n            linenoiseAddCompletion(lc,tmp);\n            sdsfree(tmp);\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-12326",
        "length": 218
    },
    {
        "index": 55399,
        "code": "static int tcp_prune_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tSOCK_DEBUG(sk, \"prune_queue: c=%x\\n\", tp->copied_seq);\n\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PRUNECALLED);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\ttcp_clamp_window(sk);\n\telse if (tcp_under_memory_pressure(sk))\n\t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);\n\n\ttcp_collapse_ofo_queue(sk);\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\ttcp_collapse(sk, &sk->sk_receive_queue,\n\t\t\t     skb_peek(&sk->sk_receive_queue),\n\t\t\t     NULL,\n\t\t\t     tp->copied_seq, tp->rcv_nxt);\n\tsk_mem_reclaim(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* Collapsing did not help, destructive actions follow.\n\t * This must not ever occur. */\n\n\ttcp_prune_ofo_queue(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\treturn 0;\n\n\t/* If we are really being abused, tell the caller to silently\n\t * drop receive data on the floor.  It will get retransmitted\n\t * and hopefully then we'll have sufficient space.\n\t */\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_RCVPRUNED);\n\n\t/* Massive buffer overcommit. */\n\ttp->pred_flags = 0;\n\treturn -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2016-2070",
        "length": 363
    },
    {
        "index": 4451,
        "code": "static void destroy_phar_data(void *pDest) /* {{{ */\n{\n\tphar_archive_data *phar_data = *(phar_archive_data **) pDest;\n\tTSRMLS_FETCH();\n\n\tif (PHAR_GLOBALS->request_ends) {\n\t\t/* first, iterate over the manifest and close all PHAR_TMP entry fp handles,\n\t\tthis prevents unnecessary unfreed stream resources */\n\t\tzend_hash_apply(&(phar_data->manifest), phar_tmpclose_apply TSRMLS_CC);\n\t\tdestroy_phar_data_only(pDest);\n\t\treturn;\n\t}\n\n\tzend_hash_apply_with_argument(&(PHAR_GLOBALS->phar_alias_map), phar_unalias_apply, phar_data TSRMLS_CC);\n\n\tif (--phar_data->refcount < 0) {\n\t\tphar_destroy_phar_data(phar_data TSRMLS_CC);\n\t}\n}\n/* }}}*/\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-11147",
        "length": 177
    },
    {
        "index": 183465,
        "code": "bool WebPluginDelegateProxy::BindFakePluginWindowHandle(bool opaque) {\n  gfx::PluginWindowHandle fake_window = NULL;\n  if (render_view_)\n    fake_window = render_view_->AllocateFakePluginWindowHandle(opaque);\n  if (!fake_window)\n    return false;\n  OnSetWindow(fake_window);\n  if (!Send(new PluginMsg_SetFakeAcceleratedSurfaceWindowHandle(instance_id_,\n                                                                fake_window))) {\n    return false;\n  }\n\n   webkit_glue::WebPluginGeometry geom;\n   geom.window = fake_window;\n   geom.window_rect = plugin_rect_;\n  geom.clip_rect = gfx::Rect(0, 0, plugin_rect_.width(), plugin_rect_.height());\n   geom.rects_valid = true;\n   geom.visible = true;\n   render_view_->DidMovePlugin(geom);\n  render_view_->didInvalidateRect(WebKit::WebRect(plugin_rect_.x(),\n                                                  plugin_rect_.y(),\n                                                  plugin_rect_.width(),\n                                                  plugin_rect_.height()));\n\n  return true;\n}\n",
        "line": "  geom.clip_rect = gfx::Rect(0, 0, plugin_rect_.width(), plugin_rect_.height());\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 208
    },
    {
        "index": 28742,
        "code": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6376",
        "length": 33
    },
    {
        "index": 82070,
        "code": "mrb_class_inherited(mrb_state *mrb, struct RClass *super, struct RClass *klass)\n{\n  mrb_value s;\n  mrb_sym mid;\n\n  if (!super)\n    super = mrb->object_class;\n  super->flags |= MRB_FLAG_IS_INHERITED;\n  s = mrb_obj_value(super);\n  mc_clear_by_class(mrb, klass);\n  mid = mrb_intern_lit(mrb, \"inherited\");\n  if (!mrb_func_basic_p(mrb, s, mid, mrb_bob_init)) {\n    mrb_value c = mrb_obj_value(klass);\n    mrb_funcall_argv(mrb, s, mid, 1, &c);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-12249",
        "length": 146
    },
    {
        "index": 155762,
        "code": "bool SerializedScriptValue::containsTransferableArrayBuffer() const\n{\n    return m_arrayBufferContentsArray && !m_arrayBufferContentsArray->isEmpty();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1663",
        "length": 33
    },
    {
        "index": 103661,
        "code": "BrowserRenderProcessHost::BrowserRenderProcessHost(Profile* profile)\n    : RenderProcessHost(profile),\n      visible_widgets_(0),\n      backgrounded_(true),\n      ALLOW_THIS_IN_INITIALIZER_LIST(cached_dibs_cleaner_(\n            base::TimeDelta::FromSeconds(5),\n            this, &BrowserRenderProcessHost::ClearTransportDIBCache)),\n      accessibility_enabled_(false),\n      is_initialized_(false) {\n  widget_helper_ = new RenderWidgetHelper();\n\n  ChildProcessSecurityPolicy::GetInstance()->Add(id());\n\n  ChildProcessSecurityPolicy::GetInstance()->GrantPermissionsForFile(\n      id(), profile->GetPath().Append(\n          fileapi::SandboxMountPointProvider::kNewFileSystemDirectory),\n      base::PLATFORM_FILE_OPEN |\n      base::PLATFORM_FILE_CREATE |\n      base::PLATFORM_FILE_OPEN_ALWAYS |\n      base::PLATFORM_FILE_CREATE_ALWAYS |\n      base::PLATFORM_FILE_OPEN_TRUNCATED |\n      base::PLATFORM_FILE_READ |\n      base::PLATFORM_FILE_WRITE |\n      base::PLATFORM_FILE_EXCLUSIVE_READ |\n      base::PLATFORM_FILE_EXCLUSIVE_WRITE |\n      base::PLATFORM_FILE_ASYNC |\n      base::PLATFORM_FILE_WRITE_ATTRIBUTES |\n      base::PLATFORM_FILE_ENUMERATE);\n  ChildProcessSecurityPolicy::GetInstance()->GrantPermissionsForFile(\n      id(), profile->GetPath().Append(\n          fileapi::SandboxMountPointProvider::kOldFileSystemDirectory),\n      base::PLATFORM_FILE_READ | base::PLATFORM_FILE_WRITE |\n      base::PLATFORM_FILE_WRITE_ATTRIBUTES | base::PLATFORM_FILE_ENUMERATE);\n  ChildProcessSecurityPolicy::GetInstance()->GrantPermissionsForFile(\n      id(), profile->GetPath().Append(\n          fileapi::SandboxMountPointProvider::kRenamedOldFileSystemDirectory),\n      base::PLATFORM_FILE_CREATE | base::PLATFORM_FILE_CREATE_ALWAYS |\n      base::PLATFORM_FILE_WRITE);\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2861",
        "length": 369
    },
    {
        "index": 68542,
        "code": "gst_asf_demux_get_gst_tag_from_tag_name (const gchar * name_utf8)\n{\n  const struct\n  {\n    const gchar *asf_name;\n    const gchar *gst_name;\n  } tags[] = {\n    {\n    \"WM/Genre\", GST_TAG_GENRE}, {\n    \"WM/AlbumTitle\", GST_TAG_ALBUM}, {\n    \"WM/AlbumArtist\", GST_TAG_ARTIST}, {\n    \"WM/Picture\", GST_TAG_IMAGE}, {\n    \"WM/Track\", GST_TAG_TRACK_NUMBER}, {\n    \"WM/TrackNumber\", GST_TAG_TRACK_NUMBER}, {\n    \"WM/Year\", GST_TAG_DATE_TIME}\n    /* { \"WM/Composer\", GST_TAG_COMPOSER } */\n  };\n  gsize out;\n  guint i;\n\n  if (name_utf8 == NULL) {\n    GST_WARNING (\"Failed to convert name to UTF8, skipping\");\n    return NULL;\n  }\n\n  out = strlen (name_utf8);\n\n  for (i = 0; i < G_N_ELEMENTS (tags); ++i) {\n    if (strncmp (tags[i].asf_name, name_utf8, out) == 0) {\n      GST_LOG (\"map tagname '%s' -> '%s'\", name_utf8, tags[i].gst_name);\n      return tags[i].gst_name;\n    }\n  }\n\n  return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5847",
        "length": 285
    },
    {
        "index": 157432,
        "code": "PeriodicWave* BaseAudioContext::createPeriodicWave(\n    const Vector<float>& real,\n    const Vector<float>& imag,\n    const PeriodicWaveConstraints& options,\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n\n  bool disable = options.disableNormalization();\n\n  return PeriodicWave::Create(*this, real, imag, disable, exception_state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 78
    },
    {
        "index": 110822,
        "code": "const AutocompleteResult& AutocompleteEditModel::result() const {\n  return autocomplete_controller_->result();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 23
    },
    {
        "index": 89590,
        "code": "MG_INTERNAL void altbuf_append(struct altbuf *ab, char c) {\n  if (ab->len < ab->user_buf_size) {\n    /* The data fits into the original buffer */\n    ab->user_buf[ab->len++] = c;\n  } else {\n    /* The data can't fit into the original buffer, so write it to mbuf.  */\n\n    /*\n     * First of all, see if that's the first byte which overflows the original\n     * buffer: if so, copy the existing data from there to a newly allocated\n     * mbuf.\n     */\n    if (ab->len > 0 && ab->m.len == 0) {\n      mbuf_append(&ab->m, ab->user_buf, ab->len);\n    }\n\n    mbuf_append(&ab->m, &c, 1);\n    ab->len = ab->m.len;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2019-12951",
        "length": 192
    },
    {
        "index": 67983,
        "code": "find_KRB5SignedPath(krb5_context context,\n\t\t    const AuthorizationData *ad,\n\t\t    krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n\n    if (ad == NULL || ad->len == 0)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    pos = ad->len - 1;\n\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n\t\t\t\t   ad->val[pos].ad_data.length,\n\t\t\t\t   &child,\n\t\t\t\t   NULL);\n    if (ret) {\n\tkrb5_set_error_message(context, ret, \"Failed to decode \"\n\t\t\t       \"IF_RELEVANT with %d\", ret);\n\treturn ret;\n    }\n\n    if (child.len != 1) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n\tfree_AuthorizationData(&child);\n\treturn KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n\n    if (data)\n\tret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-295",
        "cve": "CVE-2017-6594",
        "length": 311
    },
    {
        "index": 149548,
        "code": "  void EnsurePredictorInitialized() {\n    if (predictor_->initialization_state_ ==\n        ResourcePrefetchPredictor::INITIALIZED) {\n      return;\n    }\n\n    if (predictor_->initialization_state_ ==\n        ResourcePrefetchPredictor::NOT_INITIALIZED) {\n      predictor_->StartInitialization();\n    }\n\n    run_loop_.Run();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-5077",
        "length": 75
    },
    {
        "index": 63474,
        "code": "SIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    string_obj = object;\n\n  va_end(args);\n\n  if (string_obj == NULL)\n    return NULL;\n\n  assertf(string_obj->type == OBJECT_TYPE_STRING,\n          \"type of \\\"%s\\\" is not string\\n\", field);\n\n  return string_obj->value.ss;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-11328",
        "length": 131
    },
    {
        "index": 126466,
        "code": "void TabContentsContainerGtk::OnSetFloatingPosition(\n    GtkFloatingContainer* floating_container, GtkAllocation* allocation,\n    TabContentsContainerGtk* tab_contents_container) {\n  StatusBubbleGtk* status = tab_contents_container->status_bubble_;\n\n  GtkRequisition requisition;\n  gtk_widget_size_request(status->widget(), &requisition);\n\n  bool ltr = !base::i18n::IsRTL();\n\n  GValue value = { 0, };\n  g_value_init(&value, G_TYPE_INT);\n  if (ltr ^ status->flip_horizontally())  // Is it on the left?\n    g_value_set_int(&value, 0);\n  else\n    g_value_set_int(&value, allocation->width - requisition.width);\n  gtk_container_child_set_property(GTK_CONTAINER(floating_container),\n                                   status->widget(), \"x\", &value);\n\n  int child_y = std::max(allocation->height - requisition.height, 0);\n  g_value_set_int(&value, child_y + status->y_offset());\n  gtk_container_child_set_property(GTK_CONTAINER(floating_container),\n                                   status->widget(), \"y\", &value);\n  g_value_unset(&value);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 246
    },
    {
        "index": 77511,
        "code": "ofputil_decode_meter_config(struct ofpbuf *msg,\n                            struct ofputil_meter_config *mc,\n                            struct ofpbuf *bands)\n{\n    const struct ofp13_meter_config *omc;\n    enum ofperr err;\n\n    /* Pull OpenFlow headers for the first call. */\n    if (!msg->header) {\n        ofpraw_pull_assert(msg);\n    }\n\n    if (!msg->size) {\n        return EOF;\n    }\n\n    omc = ofpbuf_try_pull(msg, sizeof *omc);\n    if (!omc) {\n        VLOG_WARN_RL(&bad_ofmsg_rl,\n                     \"OFPMP_METER_CONFIG reply has %\"PRIu32\" leftover bytes at end\",\n                     msg->size);\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n\n    ofpbuf_clear(bands);\n    err = ofputil_pull_bands(msg, ntohs(omc->length) - sizeof *omc,\n                             &mc->n_bands, bands);\n    if (err) {\n        return err;\n    }\n    mc->meter_id = ntohl(omc->meter_id);\n    mc->flags = ntohs(omc->flags);\n    mc->bands = bands->data;\n\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2018-17204",
        "length": 266
    },
    {
        "index": 120435,
        "code": "ElementData::ElementData(const ElementData& other, bool isUnique)\n    : m_isUnique(isUnique)\n    , m_arraySize(isUnique ? 0 : other.length())\n    , m_presentationAttributeStyleIsDirty(other.m_presentationAttributeStyleIsDirty)\n    , m_styleAttributeIsDirty(other.m_styleAttributeIsDirty)\n    , m_animatedSVGAttributesAreDirty(other.m_animatedSVGAttributesAreDirty)\n    , m_classNames(other.m_classNames)\n    , m_idForStyleResolution(other.m_idForStyleResolution)\n{\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2884",
        "length": 114
    },
    {
        "index": 185847,
        "code": "  void ProcessRequest() {\n    DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n    timer.Stop();  // Erase reference to self.\n\n    WallpaperManager* manager = WallpaperManager::Get();\n    if (manager->pending_inactive_ == this)\n      manager->pending_inactive_ = NULL;\n\n     started_load_at_ = base::Time::Now();\n \n     if (default_) {\n      manager->DoSetDefaultWallpaper(account_id_, std::move(on_finish_));\n     } else if (!user_wallpaper_.isNull()) {\n       SetWallpaper(user_wallpaper_, info_);\n     } else if (!wallpaper_path_.empty()) {\n      manager->task_runner_->PostTask(\n          FROM_HERE,\n          base::BindOnce(&WallpaperManager::GetCustomWallpaperInternal,\n                         account_id_, info_, wallpaper_path_,\n                         true /* update wallpaper */,\n                         base::ThreadTaskRunnerHandle::Get(),\n                          base::Passed(std::move(on_finish_)),\n                          manager->weak_factory_.GetWeakPtr()));\n     } else if (!info_.location.empty()) {\n      manager->LoadWallpaper(account_id_, info_, true, std::move(on_finish_));\n     } else {\n       NOTREACHED();\n      started_load_at_ = base::Time();\n    }\n    on_finish_.reset();\n  }\n",
        "line": "      manager->DoSetDefaultWallpaper(account_id_, std::move(on_finish_));\n      manager->LoadWallpaper(account_id_, info_, true, std::move(on_finish_));\n",
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2015-1285",
        "length": 265
    },
    {
        "index": 96322,
        "code": "bool CNBL::ParseLSO()\n{\n    ASSERT(IsLSO());\n\n    if (m_LsoInfo.LsoV1Transmit.Type != NDIS_TCP_LARGE_SEND_OFFLOAD_V1_TYPE &&\n        m_LsoInfo.LsoV2Transmit.Type != NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE)\n    {\n        return false;\n    }\n\n    if (NeedsLSO() &&\n        (!m_LsoInfo.LsoV2Transmit.MSS ||\n         !m_LsoInfo.LsoV2Transmit.TcpHeaderOffset))\n    {\n        return false;\n    }\n\n    if (!FitsLSO())\n    {\n        return false;\n    }\n\n    if (!LsoTcpHeaderOffset() != !MSS())\n    {\n        return false;\n    }\n\n    if ((!m_Context->Offload.flags.fTxLso || !m_Context->bOffloadv4Enabled) &&\n        m_LsoInfo.LsoV2Transmit.IPVersion == NDIS_TCP_LARGE_SEND_OFFLOAD_IPv4)\n    {\n        return false;\n    }\n\n    if (m_LsoInfo.LsoV2Transmit.Type == NDIS_TCP_LARGE_SEND_OFFLOAD_V2_TYPE &&\n        m_LsoInfo.LsoV2Transmit.IPVersion == NDIS_TCP_LARGE_SEND_OFFLOAD_IPv6 &&\n        (!m_Context->Offload.flags.fTxLsov6 || !m_Context->bOffloadv6Enabled))\n    {\n        return false;\n    }\n\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-3215",
        "length": 308
    },
    {
        "index": 152254,
        "code": "void RenderFrameImpl::DidChangeManifest() {\n  for (auto& observer : observers_)\n    observer.DidChangeManifest();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5019",
        "length": 27
    },
    {
        "index": 65561,
        "code": "nfsd4_cb_notify_lock_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\t/*\n\t * Since this is just an optimization, we don't try very hard if it\n\t * turns out not to succeed. We'll requeue it on NFS4ERR_DELAY, and\n\t * just quit trying on anything else.\n\t */\n\tswitch (task->tk_status) {\n\tcase -NFS4ERR_DELAY:\n\t\trpc_delay(task, 1 * HZ);\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 119
    },
    {
        "index": 94323,
        "code": "static void check_stack_usage(void)\n{\n\tstatic DEFINE_SPINLOCK(low_water_lock);\n\tstatic int lowest_to_date = THREAD_SIZE;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tprintk(KERN_WARNING \"%s used greatest stack depth: %lu bytes \"\n\t\t\t\t\"left\\n\",\n\t\t\t\tcurrent->comm, free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-0879",
        "length": 112
    },
    {
        "index": 172304,
        "code": "void onLinkStatsResults(wifi_request_id id, wifi_iface_stat *iface_stat,\n int num_radios, wifi_radio_stat *radio_stats)\n{\n if (iface_stat != 0) {\n        memcpy(&link_stat, iface_stat, sizeof(wifi_iface_stat));\n } else {\n        memset(&link_stat, 0, sizeof(wifi_iface_stat));\n }\n\n if (num_radios > 0 && radio_stats != 0) {\n        memcpy(&radio_stat, radio_stats, sizeof(wifi_radio_stat));\n } else {\n        memset(&radio_stat, 0, sizeof(wifi_radio_stat));\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3837",
        "length": 126
    },
    {
        "index": 39876,
        "code": "int skb_checksum_setup(struct sk_buff *skb, bool recalculate)\n{\n\tint err;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\terr = skb_checksum_setup_ip(skb, recalculate);\n\t\tbreak;\n\n\tcase htons(ETH_P_IPV6):\n\t\terr = skb_checksum_setup_ipv6(skb, recalculate);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EPROTO;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-0131",
        "length": 90
    },
    {
        "index": 175926,
        "code": "void smp_proc_confirm(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n\n if (smp_command_has_invalid_parameters(p_cb)) {\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = SMP_INVALID_PARAMETERS;\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n return;\n }\n\n if (p != NULL) {\n /* save the SConfirm for comparison later */\n    STREAM_TO_ARRAY(p_cb->rconfirm, p, BT_OCTET16_LEN);\n }\n\n  p_cb->flags |= SMP_PAIR_FLAGS_CMD_CONFIRM;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-9510",
        "length": 152
    },
    {
        "index": 89870,
        "code": "GetTotalBytesSent(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<NewTotalBytesSent>%lu</NewTotalBytesSent>\"\n\t\t\"</u:%sResponse>\";\n\n\tchar body[512];\n\tint bodylen;\n\tstruct ifdata data;\n\n\tr = getifstats(ext_if_name, &data);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t         action, ns, /* was \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n#ifdef UPNP_STRICT\n             r<0?0:(data.obytes & UPNP_UI4_MAX), action);\n#else /* UPNP_STRICT */\n             r<0?0:data.obytes, action);\n#endif /* UPNP_STRICT */\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12109",
        "length": 204
    },
    {
        "index": 22305,
        "code": "static int __migrate_task(struct task_struct *p, int src_cpu, int dest_cpu)\n{\n\tstruct rq *rq_dest, *rq_src;\n\tint ret = 0;\n\n\tif (unlikely(!cpu_active(dest_cpu)))\n\t\treturn ret;\n\n\trq_src = cpu_rq(src_cpu);\n\trq_dest = cpu_rq(dest_cpu);\n\n\tdouble_rq_lock(rq_src, rq_dest);\n\t/* Already moved. */\n\tif (task_cpu(p) != src_cpu)\n\t\tgoto done;\n\t/* Affinity changed (again). */\n\tif (!cpumask_test_cpu(dest_cpu, &p->cpus_allowed))\n\t\tgoto fail;\n\n\t/*\n\t * If we're not on a rq, the next wake-up will ensure we're\n\t * placed properly.\n\t */\n\tif (p->se.on_rq) {\n\t\tdeactivate_task(rq_src, p, 0);\n\t\tset_task_cpu(p, dest_cpu);\n\t\tactivate_task(rq_dest, p, 0);\n\t\tcheck_preempt_curr(rq_dest, p, 0);\n\t}\ndone:\n\tret = 1;\nfail:\n\tdouble_rq_unlock(rq_src, rq_dest);\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4621",
        "length": 240
    },
    {
        "index": 8143,
        "code": "void Gfx::opSetFillColor(Object args[], int numArgs) {\n  GfxColor color;\n  int i;\n\n  if (numArgs != state->getFillColorSpace()->getNComps()) {\n    error(getPos(), \"Incorrect number of arguments in 'sc' command\");\n    return;\n  }\n  state->setFillPattern(NULL);\n  for (i = 0; i < numArgs; ++i) {\n    color.c[i] = dblToCol(args[i].getNum());\n  }\n  state->setFillColor(&color);\n  out->updateFillColor(state);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-3702",
        "length": 122
    },
    {
        "index": 44644,
        "code": "static int setup_pivot_root(const struct lxc_rootfs *rootfs)\n{\n\tif (!rootfs->path)\n\t\treturn 0;\n\n\tif (detect_ramfs_rootfs()) {\n\t\tif (prepare_ramfs_root(rootfs->mount))\n\t\t\treturn -1;\n\t} else if (setup_rootfs_pivot_root(rootfs->mount, rootfs->pivot)) {\n\t\tERROR(\"failed to setup pivot root\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2015-1335",
        "length": 99
    },
    {
        "index": 134630,
        "code": "OSExchangeData::Provider* OSExchangeDataProviderAuraX11::Clone() const {\n  OSExchangeDataProviderAuraX11* ret = new OSExchangeDataProviderAuraX11();\n  ret->format_map_ = format_map_;\n  return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 51
    },
    {
        "index": 97677,
        "code": "xmlXPathFreeContext(xmlXPathContextPtr ctxt) {\n    if (ctxt == NULL) return;\n\n    if (ctxt->cache != NULL)\n\txmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n    xmlXPathRegisteredNsCleanup(ctxt);\n    xmlXPathRegisteredFuncsCleanup(ctxt);\n    xmlXPathRegisteredVariablesCleanup(ctxt);\n    xmlResetError(&ctxt->lastError);\n    xmlFree(ctxt);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 90
    },
    {
        "index": 40336,
        "code": "static void atrtr_set_default(struct net_device *dev)\n{\n\tatrtr_default.dev\t     = dev;\n\tatrtr_default.flags\t     = RTF_UP;\n\tatrtr_default.gateway.s_net  = htons(0);\n\tatrtr_default.gateway.s_node = 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-7271",
        "length": 59
    },
    {
        "index": 40208,
        "code": "static int rawv6_send_hdrinc(struct sock *sk, void *from, int length,\n\t\t\tstruct flowi6 *fl6, struct dst_entry **dstp,\n\t\t\tunsigned int flags)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct rt6_info *rt = (struct rt6_info *)*dstp;\n\tint hlen = LL_RESERVED_SPACE(rt->dst.dev);\n\tint tlen = rt->dst.dev->needed_tailroom;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tipv6_local_error(sk, EMSGSIZE, fl6, rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\tskb_dst_set(skb, &rt->dst);\n\t*dstp = NULL;\n\n\tskb_put(skb, length);\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb->transport_header = skb->network_header;\n\terr = memcpy_fromiovecend((void *)iph, from, 0, length);\n\tif (err)\n\t\tgoto error_fault;\n\n\tIP6_UPD_PO_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\n\t\t      rt->dst.dev, dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_fault:\n\terr = -EFAULT;\n\tkfree_skb(skb);\nerror:\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !np->recverr)\n\t\terr = 0;\n\treturn err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-7281",
        "length": 500
    },
    {
        "index": 91283,
        "code": "int ipmi_register_for_cmd(struct ipmi_user *user,\n\t\t\t  unsigned char netfn,\n\t\t\t  unsigned char cmd,\n\t\t\t  unsigned int  chans)\n{\n\tstruct ipmi_smi *intf = user->intf;\n\tstruct cmd_rcvr *rcvr;\n\tint rv = 0, index;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\trcvr = kmalloc(sizeof(*rcvr), GFP_KERNEL);\n\tif (!rcvr) {\n\t\trv = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\trcvr->cmd = cmd;\n\trcvr->netfn = netfn;\n\trcvr->chans = chans;\n\trcvr->user = user;\n\n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\t/* Make sure the command/netfn is not already registered. */\n\tif (!is_cmd_rcvr_exclusive(intf, netfn, cmd, chans)) {\n\t\trv = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tif (atomic_inc_return(&intf->event_waiters) == 1)\n\t\tneed_waiter(intf);\n\n\tlist_add_rcu(&rcvr->link, &intf->cmd_rcvrs);\n\nout_unlock:\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tif (rv)\n\t\tkfree(rcvr);\nout_release:\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-9003",
        "length": 293
    },
    {
        "index": 147488,
        "code": "void V8TestObject::LocationAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_location_Getter\");\n\n  test_object_v8_internal::LocationAttributeGetter(info);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 62
    },
    {
        "index": 27430,
        "code": "static int ip6ip6_rcv(struct sk_buff *skb)\n{\n\treturn ip6_tnl_rcv(skb, ETH_P_IPV6, IPPROTO_IPV6,\n\t\t\t   ip6ip6_dscp_ecn_decapsulate);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2011-1768",
        "length": 48
    },
    {
        "index": 115744,
        "code": "  virtual void SetUp() {\n    session_ = new protocol::FakeSession();\n    session_->set_message_loop(&message_loop_);\n\n    viewer_ = new ConnectionToClient(\n        base::MessageLoopProxy::current(), session_);\n    viewer_->set_host_stub(&host_stub_);\n    viewer_->set_input_stub(&input_stub_);\n    viewer_->SetEventHandler(&handler_);\n    EXPECT_CALL(handler_, OnConnectionOpened(viewer_.get()));\n    session_->state_change_callback().Run(\n        protocol::Session::CONNECTED);\n    session_->state_change_callback().Run(\n        protocol::Session::CONNECTED_CHANNELS);\n     message_loop_.RunAllPending();\n   }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 133
    },
    {
        "index": 185978,
        "code": " v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    int scriptId = function->ScriptId();\n    if (scriptId == v8::UnboundScript::kNoScriptId)\n        return v8::Null(m_isolate);\n    int lineNumber = function->GetScriptLineNumber();\n    int columnNumber = function->GetScriptColumnNumber();\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"columnNumber\"), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, location, V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-79",
        "cve": "CVE-2016-5164",
        "length": 340
    },
    {
        "index": 121406,
        "code": "DevToolsWindow* DevToolsWindow::FindDevToolsWindow(\n    DevToolsAgentHost* agent_host) {\n  DevToolsWindows* instances = &g_instances.Get();\n  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();\n  for (DevToolsWindows::iterator it(instances->begin()); it != instances->end();\n       ++it) {\n    if (manager->GetDevToolsAgentHostFor((*it)->frontend_host_.get()) ==\n        agent_host)\n      return *it;\n  }\n  return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-2874",
        "length": 114
    },
    {
        "index": 33528,
        "code": "static struct dentry *shmem_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_nodev(fs_type, flags, data, shmem_fill_super);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-1767",
        "length": 48
    },
    {
        "index": 92258,
        "code": "XML_MemRealloc(XML_Parser parser, void *ptr, size_t size)\n{\n  if (parser == NULL)\n    return NULL;\n  return REALLOC(parser, ptr, size);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-611",
        "cve": "CVE-2018-20843",
        "length": 42
    },
    {
        "index": 181998,
        "code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n",
        "line": "\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t\t\tsmb_flush_file(sr, file);\n",
        "label": 1,
        "cwe": "CWE-476",
        "cve": "CVE-2016-6561",
        "length": 286
    },
    {
        "index": 35225,
        "code": "void __dev_remove_pack(struct packet_type *pt)\n{\n\tstruct list_head *head = ptype_head(pt);\n\tstruct packet_type *pt1;\n\n\tspin_lock(&ptype_lock);\n\n\tlist_for_each_entry(pt1, head, list) {\n\t\tif (pt == pt1) {\n\t\t\tlist_del_rcu(&pt->list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tprintk(KERN_WARNING \"dev_remove_pack: %p not found.\\n\", pt);\nout:\n\tspin_unlock(&ptype_lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-1019",
        "length": 103
    },
    {
        "index": 22384,
        "code": "cpu_to_book_group(int cpu, const struct cpumask *cpu_map,\n\t\t  struct sched_group **sg, struct cpumask *mask)\n{\n\tint group = cpu;\n#ifdef CONFIG_SCHED_MC\n\tcpumask_and(mask, cpu_coregroup_mask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#elif defined(CONFIG_SCHED_SMT)\n\tcpumask_and(mask, topology_thread_cpumask(cpu), cpu_map);\n\tgroup = cpumask_first(mask);\n#endif\n\tif (sg)\n\t\t*sg = &per_cpu(sched_group_book, group).sg;\n\treturn group;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4621",
        "length": 123
    },
    {
        "index": 120344,
        "code": "  TestEventHandler() : touch_released_count_(0),\n                       touch_pressed_count_(0),\n                       touch_moved_count_(0),\n                       touch_cancelled_count_(0) {\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2887",
        "length": 39
    },
    {
        "index": 134016,
        "code": "void ExtensionAppItem::Move(const ExtensionAppItem* prev,\n                            const ExtensionAppItem* next) {\n  if (!prev && !next)\n    return;  // No reordering necessary\n\n  extensions::ExtensionPrefs* prefs = extensions::ExtensionPrefs::Get(profile_);\n  extensions::AppSorting* sorting = GetAppSorting(profile_);\n\n  syncer::StringOrdinal page;\n  std::string prev_id, next_id;\n  if (!prev) {\n    next_id = next->extension_id();\n    page = sorting->GetPageOrdinal(next_id);\n  } else if (!next) {\n    prev_id = prev->extension_id();\n    page = sorting->GetPageOrdinal(prev_id);\n  } else {\n    prev_id = prev->extension_id();\n    page = sorting->GetPageOrdinal(prev_id);\n    if (page.Equals(sorting->GetPageOrdinal(next->extension_id())))\n      next_id = next->extension_id();\n  }\n  prefs->SetAppDraggedByUser(extension_id_);\n  sorting->SetPageOrdinal(extension_id_, page);\n  sorting->OnExtensionMoved(extension_id_, prev_id, next_id);\n  UpdatePositionFromExtensionOrdering();\n }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6644",
        "length": 240
    },
    {
        "index": 169216,
        "code": "bool ExecuteScriptAndExtractDouble(const ToRenderFrameHost& adapter,\n                                   const std::string& script, double* result) {\n  DCHECK(result);\n  std::unique_ptr<base::Value> value;\n  if (!ExecuteScriptHelper(adapter.render_frame_host(), script, true, &value) ||\n      !value.get()) {\n    return false;\n  }\n\n  return value->GetAsDouble(result);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6121",
        "length": 85
    },
    {
        "index": 41027,
        "code": "void* Prelin16dup(cmsContext ContextID, const void* ptr)\n{\n    Prelin16Data* p16 = (Prelin16Data*) ptr;\n    Prelin16Data* Duped = _cmsDupMem(ContextID, p16, sizeof(Prelin16Data));\n\n    if (Duped == NULL) return NULL;\n\n    Duped ->EvalCurveOut16   = _cmsDupMem(ContextID, p16 ->EvalCurveOut16, p16 ->nOutputs * sizeof(_cmsInterpFn16));\n    Duped ->ParamsCurveOut16 = _cmsDupMem(ContextID, p16 ->ParamsCurveOut16, p16 ->nOutputs * sizeof(cmsInterpParams* ));\n\n    return Duped;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-4160",
        "length": 156
    },
    {
        "index": 104864,
        "code": "void Extension::InitEffectiveHostPermissions() {\n  if (HasApiPermission(api_permissions_, kProxyPermission) ||\n      !devtools_url_.is_empty()) {\n    URLPattern all_urls(URLPattern::SCHEME_ALL);\n    all_urls.set_match_all_urls(true);\n    effective_host_permissions_.AddPattern(all_urls);\n    return;\n  }\n\n  for (URLPatternList::const_iterator host = host_permissions().begin();\n       host != host_permissions().end(); ++host)\n    effective_host_permissions_.AddPattern(*host);\n\n  for (UserScriptList::const_iterator content_script =\n           content_scripts().begin();\n       content_script != content_scripts().end(); ++content_script) {\n    URLPatternList::const_iterator pattern =\n        content_script->url_patterns().begin();\n    for (; pattern != content_script->url_patterns().end(); ++pattern)\n      effective_host_permissions_.AddPattern(*pattern);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2785",
        "length": 186
    },
    {
        "index": 48695,
        "code": "static int close_input(h2_stream *stream) \n{\n    switch (stream->state) {\n        case H2_STREAM_ST_CLOSED_INPUT:\n        case H2_STREAM_ST_CLOSED:\n            return 0; /* ignore, idempotent */\n        case H2_STREAM_ST_CLOSED_OUTPUT:\n            /* both closed now */\n            set_state(stream, H2_STREAM_ST_CLOSED);\n            break;\n        default:\n            /* everything else we jump to here */\n            set_state(stream, H2_STREAM_ST_CLOSED_INPUT);\n            break;\n    }\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-8740",
        "length": 114
    },
    {
        "index": 19835,
        "code": "static int _nfs4_proc_secinfo(struct inode *dir, const struct qstr *name, struct nfs4_secinfo_flavors *flavors)\n{\n\tint status;\n\tstruct nfs4_secinfo_arg args = {\n\t\t.dir_fh = NFS_FH(dir),\n\t\t.name   = name,\n\t};\n\tstruct nfs4_secinfo_res res = {\n\t\t.flavors     = flavors,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SECINFO],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\n\tdprintk(\"NFS call  secinfo %s\\n\", name->name);\n\tstatus = nfs4_call_sync(NFS_SERVER(dir)->client, NFS_SERVER(dir), &msg, &args.seq_args, &res.seq_res, 0);\n\tdprintk(\"NFS reply  secinfo: %d\\n\", status);\n\treturn status;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 202
    },
    {
        "index": 142053,
        "code": "HRESULT CGaiaCredentialBase::ForkSaveAccountInfoStub(\n    const std::unique_ptr<base::DictionaryValue>& dict,\n    BSTR* status_text) {\n  LOGFN(INFO);\n  DCHECK(status_text);\n\n  ScopedStartupInfo startupinfo;\n  StdParentHandles parent_handles;\n  HRESULT hr =\n      InitializeStdHandles(CommDirection::kParentToChildOnly, kAllStdHandles,\n                           &startupinfo, &parent_handles);\n  if (FAILED(hr)) {\n    LOGFN(ERROR) << \"InitializeStdHandles hr=\" << putHR(hr);\n    *status_text = AllocErrorString(IDS_INTERNAL_ERROR_BASE);\n    return hr;\n  }\n\n  base::CommandLine command_line(base::CommandLine::NO_PROGRAM);\n  hr = GetCommandLineForEntrypoint(CURRENT_MODULE(), L\"SaveAccountInfo\",\n                                   &command_line);\n  if (hr == S_FALSE) {\n    LOGFN(INFO) << \"Not running SAIS\";\n    return S_OK;\n  } else if (FAILED(hr)) {\n    LOGFN(ERROR) << \"GetCommandLineForEntryPoint hr=\" << putHR(hr);\n    *status_text = AllocErrorString(IDS_INTERNAL_ERROR_BASE);\n    return hr;\n  }\n\n  command_line.AppendSwitchASCII(switches::kProcessType,\n                                 \"gcpw-save-account-info\");\n\n  base::win::ScopedProcessInformation procinfo;\n  hr = OSProcessManager::Get()->CreateRunningProcess(\n      command_line, startupinfo.GetInfo(), &procinfo);\n  if (FAILED(hr)) {\n    LOGFN(ERROR) << \"OSProcessManager::CreateRunningProcess hr=\" << putHR(hr);\n    *status_text = AllocErrorString(IDS_INTERNAL_ERROR_BASE);\n    return hr;\n  }\n\n  std::string json;\n  if (base::JSONWriter::Write(*dict, &json)) {\n    DWORD written;\n    if (!::WriteFile(parent_handles.hstdin_write.Get(), json.c_str(),\n                     json.length() + 1, &written, /*lpOverlapped=*/nullptr)) {\n      HRESULT hrWrite = HRESULT_FROM_WIN32(::GetLastError());\n      LOGFN(ERROR) << \"WriteFile hr=\" << putHR(hrWrite);\n    }\n  } else {\n    LOGFN(ERROR) << \"base::JSONWriter::Write failed\";\n  }\n\n  return S_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5189",
        "length": 477
    },
    {
        "index": 162950,
        "code": "  void GetManifestAndWait() {\n    shell()->web_contents()->GetManifest(\n        base::Bind(&ManifestBrowserTest::OnGetManifest,\n                   base::Unretained(this)));\n\n    message_loop_runner_ = new MessageLoopRunner();\n    message_loop_runner_->Run();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6083",
        "length": 58
    },
    {
        "index": 2169,
        "code": "void red_channel_pipes_new_add_push(RedChannel *channel,\n                              new_pipe_item_t creator, void *data)\n{\n    red_channel_pipes_create_batch(channel, creator, data,\n                                     red_channel_client_pipe_add);\n    red_channel_push(channel);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4130",
        "length": 54
    },
    {
        "index": 29680,
        "code": "static int persistent_prepare_merge(struct dm_exception_store *store,\n\t\t\t\t    chunk_t *last_old_chunk,\n\t\t\t\t    chunk_t *last_new_chunk)\n{\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tint nr_consecutive;\n\tint r;\n\n\t/*\n\t * When current area is empty, move back to preceding area.\n\t */\n\tif (!ps->current_committed) {\n\t\t/*\n\t\t * Have we finished?\n\t\t */\n\t\tif (!ps->current_area)\n\t\t\treturn 0;\n\n\t\tps->current_area--;\n\t\tr = area_io(ps, READ);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tps->current_committed = ps->exceptions_per_area;\n\t}\n\n\tread_exception(ps, ps->current_committed - 1, &ce);\n\t*last_old_chunk = ce.old_chunk;\n\t*last_new_chunk = ce.new_chunk;\n\n\t/*\n\t * Find number of consecutive chunks within the current area,\n\t * working backwards.\n\t */\n\tfor (nr_consecutive = 1; nr_consecutive < ps->current_committed;\n\t     nr_consecutive++) {\n\t\tread_exception(ps, ps->current_committed - 1 - nr_consecutive,\n\t\t\t       &ce);\n\t\tif (ce.old_chunk != *last_old_chunk - nr_consecutive ||\n\t\t    ce.new_chunk != *last_new_chunk - nr_consecutive)\n\t\t\tbreak;\n\t}\n\n\treturn nr_consecutive;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-4299",
        "length": 291
    },
    {
        "index": 151550,
        "code": "ResourceLoadPriority ResourceFetcher::ComputeLoadPriority(\n    Resource::Type type,\n    const ResourceRequest& resource_request,\n    ResourcePriority::VisibilityStatus visibility,\n    FetchParameters::DeferOption defer_option,\n    FetchParameters::SpeculativePreloadType speculative_preload_type,\n    bool is_link_preload) {\n  ResourceLoadPriority priority = TypeToPriority(type);\n\n  if (visibility == ResourcePriority::kVisible)\n    priority = kResourceLoadPriorityHigh;\n\n  if (type == Resource::kImage && !is_link_preload)\n    image_fetched_ = true;\n\n  if (type == Resource::kFont && is_link_preload)\n    priority = kResourceLoadPriorityHigh;\n\n  if (FetchParameters::kIdleLoad == defer_option) {\n    priority = kResourceLoadPriorityVeryLow;\n  } else if (type == Resource::kScript) {\n    if (FetchParameters::kLazyLoad == defer_option) {\n      priority = kResourceLoadPriorityLow;\n    } else if (speculative_preload_type ==\n                   FetchParameters::SpeculativePreloadType::kInDocument &&\n               image_fetched_) {\n      priority = kResourceLoadPriorityMedium;\n    }\n  } else if (FetchParameters::kLazyLoad == defer_option) {\n    priority = kResourceLoadPriorityVeryLow;\n  } else if (resource_request.GetRequestContext() ==\n                 WebURLRequest::kRequestContextBeacon ||\n             resource_request.GetRequestContext() ==\n                 WebURLRequest::kRequestContextPing ||\n             resource_request.GetRequestContext() ==\n                 WebURLRequest::kRequestContextCSPReport) {\n    priority = kResourceLoadPriorityVeryLow;\n  }\n\n  return std::max(priority, resource_request.Priority());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 355
    },
    {
        "index": 6207,
        "code": "int X509_REQ_get_attr_count(const X509_REQ *req)\n{\n    return X509at_get_attr_count(req->req_info->attributes);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-0288",
        "length": 32
    },
    {
        "index": 145279,
        "code": "  DetectedLanguage(const std::string& language, int percentage)\n      : language(language), percentage(percentage) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-1696",
        "length": 24
    },
    {
        "index": 183819,
        "code": "void MockWebRTCPeerConnectionHandler::setLocalDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& localDescription)\n{\n    if (!localDescription.isNull() && localDescription.type() == \"offer\") {\n        m_localDescription = localDescription;\n        postTask(new RTCVoidRequestTask(this, request, true));\n    } else\n        postTask(new RTCVoidRequestTask(this, request, false));\n}\n",
        "line": "{\n    if (!localDescription.isNull() && localDescription.type() == \"offer\") {\n        m_localDescription = localDescription;\n        postTask(new RTCVoidRequestTask(this, request, true));\n    } else\n        postTask(new RTCVoidRequestTask(this, request, false));\n}\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2875",
        "length": 91
    },
    {
        "index": 93352,
        "code": "static void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,\n\t\t\t\t\t       struct net_device *upper_dev,\n\t\t\t\t\t       u16 ref_nr,\n\t\t\t\t\t       struct list_head *up_list,\n\t\t\t\t\t       struct list_head *down_list)\n{\n\t__netdev_adjacent_dev_remove(dev, upper_dev, ref_nr, up_list);\n\t__netdev_adjacent_dev_remove(upper_dev, dev, ref_nr, down_list);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-7191",
        "length": 89
    },
    {
        "index": 114851,
        "code": "void TestingAutomationProvider::AutofillHighlightSuggestion(\n    Browser* browser,\n    DictionaryValue* args,\n    IPC::Message* reply_message) {\n  int tab_index;\n  if (!args->GetInteger(\"tab_index\", &tab_index)) {\n    AutomationJSONReply(this, reply_message).SendError(\n        \"Invalid or missing args\");\n    return;\n  }\n\n  WebContents* web_contents = browser->GetWebContentsAt(tab_index);\n  if (!web_contents) {\n    AutomationJSONReply(this, reply_message).SendError(\n        StringPrintf(\"No such tab at index %d\", tab_index));\n    return;\n  }\n\n  std::string direction;\n  if (!args->GetString(\"direction\", &direction) || (direction != \"up\" &&\n                                                    direction != \"down\")) {\n    AutomationJSONReply(this, reply_message).SendError(\n        \"Must specify a direction of either 'up' or 'down'.\");\n    return;\n  }\n  int key_code = (direction == \"up\") ? ui::VKEY_UP : ui::VKEY_DOWN;\n\n  new AutofillDisplayedObserver(\n      chrome::NOTIFICATION_AUTOFILL_DID_FILL_FORM_DATA,\n      web_contents->GetRenderViewHost(), this, reply_message);\n  SendWebKeyPressEventAsync(key_code, web_contents);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 271
    },
    {
        "index": 123959,
        "code": "WebPlugin* RenderViewImpl::createPlugin(WebFrame* frame,\n                                        const WebPluginParams& params) {\n  WebPlugin* plugin = NULL;\n  if (GetContentClient()->renderer()->OverrideCreatePlugin(\n          this, frame, params, &plugin)) {\n    return plugin;\n  }\n\n#if defined(ENABLE_PLUGINS)\n  if (UTF16ToASCII(params.mimeType) == kBrowserPluginMimeType) {\n    return browser_plugin_manager()->CreateBrowserPlugin(this, frame, params);\n  }\n\n  webkit::WebPluginInfo info;\n  std::string mime_type;\n  bool found = GetPluginInfo(params.url, frame->top()->document().url(),\n                             params.mimeType.utf8(), &info, &mime_type);\n  if (!found)\n    return NULL;\n\n  WebPluginParams params_to_use = params;\n  params_to_use.mimeType = WebString::fromUTF8(mime_type);\n  return CreatePlugin(frame, info, params_to_use);\n#else\n  return NULL;\n#endif  // defined(ENABLE_PLUGINS)\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0918",
        "length": 216
    },
    {
        "index": 55556,
        "code": "int migrate_swap(struct task_struct *cur, struct task_struct *p)\n{\n\tstruct migration_swap_arg arg;\n\tint ret = -EINVAL;\n\n\targ = (struct migration_swap_arg){\n\t\t.src_task = cur,\n\t\t.src_cpu = task_cpu(cur),\n\t\t.dst_task = p,\n\t\t.dst_cpu = task_cpu(p),\n\t};\n\n\tif (arg.src_cpu == arg.dst_cpu)\n\t\tgoto out;\n\n\t/*\n\t * These three tests are all lockless; this is OK since all of them\n\t * will be re-checked with proper locks held further down the line.\n\t */\n\tif (!cpu_active(arg.src_cpu) || !cpu_active(arg.dst_cpu))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.dst_cpu, tsk_cpus_allowed(arg.src_task)))\n\t\tgoto out;\n\n\tif (!cpumask_test_cpu(arg.src_cpu, tsk_cpus_allowed(arg.dst_task)))\n\t\tgoto out;\n\n\ttrace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);\n\tret = stop_two_cpus(arg.dst_cpu, arg.src_cpu, migrate_swap_stop, &arg);\n\nout:\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1583",
        "length": 231
    },
    {
        "index": 112449,
        "code": "PassRefPtr<StringImpl> Document::displayStringModifiedByEncoding(PassRefPtr<StringImpl> str) const\n{\n    if (m_decoder)\n        return m_decoder->encoding().displayString(str);\n    return str;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 46
    },
    {
        "index": 75770,
        "code": "\tvoid testUriHostIpFuture() {\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-19198",
        "length": 11
    },
    {
        "index": 65362,
        "code": "static inline u32 nfsd4_readlink_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + PAGE_SIZE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 50
    },
    {
        "index": 59575,
        "code": "endElementNsDebug(void *ctx ATTRIBUTE_UNUSED,\n                  const xmlChar *localname,\n                  const xmlChar *prefix,\n                  const xmlChar *URI)\n{\n    callbacks++;\n    if (quiet)\n\treturn;\n    fprintf(SAXdebug, \"SAX.endElementNs(%s\", (char *) localname);\n    if (prefix == NULL)\n\tfprintf(SAXdebug, \", NULL\");\n    else\n\tfprintf(SAXdebug, \", %s\", (char *) prefix);\n    if (URI == NULL)\n\tfprintf(SAXdebug, \", NULL)\\n\");\n    else\n\tfprintf(SAXdebug, \", '%s')\\n\", (char *) URI);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-16931",
        "length": 135
    },
    {
        "index": 52761,
        "code": "int vb2_ioctl_prepare_buf(struct file *file, void *priv,\n\t\t\t  struct v4l2_buffer *p)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\n\tif (vb2_queue_is_busy(vdev, file))\n\t\treturn -EBUSY;\n\treturn vb2_prepare_buf(vdev->queue, p);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4568",
        "length": 71
    },
    {
        "index": 183847,
        "code": "void ExtensionTtsSpeakFunction::SpeechFinished() {\n  error_ = utterance_->error();\n  bool success = error_.empty();\n  SendResponse(success);\n  Release();  // Balanced in RunImpl().\n}\n",
        "line": "  error_ = utterance_->error();\n  bool success = error_.empty();\n  SendResponse(success);\n  Release();  // Balanced in RunImpl().\n}\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2839",
        "length": 45
    },
    {
        "index": 122965,
        "code": "void RenderWidgetHostImpl::ForwardWheelEvent(\n    const WebMouseWheelEvent& wheel_event) {\n  TRACE_EVENT0(\"renderer_host\", \"RenderWidgetHostImpl::ForwardWheelEvent\");\n  if (ignore_input_events_ || process_->IgnoreInputEvents())\n    return;\n\n  if (mouse_wheel_pending_) {\n    if (coalesced_mouse_wheel_events_.empty() ||\n        !ShouldCoalesceMouseWheelEvents(coalesced_mouse_wheel_events_.back(),\n                                        wheel_event)) {\n      coalesced_mouse_wheel_events_.push_back(wheel_event);\n    } else {\n      WebMouseWheelEvent* last_wheel_event =\n          &coalesced_mouse_wheel_events_.back();\n      last_wheel_event->deltaX += wheel_event.deltaX;\n      last_wheel_event->deltaY += wheel_event.deltaY;\n      last_wheel_event->wheelTicksX += wheel_event.wheelTicksX;\n      last_wheel_event->wheelTicksY += wheel_event.wheelTicksY;\n      DCHECK_GE(wheel_event.timeStampSeconds,\n                last_wheel_event->timeStampSeconds);\n      last_wheel_event->timeStampSeconds = wheel_event.timeStampSeconds;\n    }\n    return;\n  }\n  mouse_wheel_pending_ = true;\n  current_wheel_event_ = wheel_event;\n\n  HISTOGRAM_COUNTS_100(\"MPArch.RWH_WheelQueueSize\",\n                       coalesced_mouse_wheel_events_.size());\n\n  ForwardInputEvent(wheel_event, sizeof(WebMouseWheelEvent), false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 301
    },
    {
        "index": 34719,
        "code": "static inline struct net_device *bridge_parent(const struct net_device *dev)\n{\n\tstruct net_bridge_port *port;\n\n\tport = br_port_get_rcu(dev);\n\treturn port ? port->br->dev : NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-4087",
        "length": 45
    },
    {
        "index": 29079,
        "code": "int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,\n\t\t\t      gpa_t gpa)\n{\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tint offset = offset_in_page(gpa);\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\n\tghc->gpa = gpa;\n\tghc->generation = slots->generation;\n\tghc->memslot = gfn_to_memslot(kvm, gfn);\n\tghc->hva = gfn_to_hva_many(ghc->memslot, gfn, NULL);\n\tif (!kvm_is_error_hva(ghc->hva))\n\t\tghc->hva += offset;\n\telse\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4592",
        "length": 169
    },
    {
        "index": 161782,
        "code": "bool HaveValuesChanged(const SensorReading& lhs, const SensorReading& rhs) {\n  for (size_t i = 0; i < SensorReadingRaw::kValuesCount; ++i) {\n    if (lhs.raw.values[i] != rhs.raw.values[i])\n      return true;\n  }\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-6057",
        "length": 67
    },
    {
        "index": 171975,
        "code": "const btrc_interface_t *btif_rc_get_interface(void)\n{\n    BTIF_TRACE_EVENT(\"%s\", __FUNCTION__);\n return &bt_rc_interface;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3839",
        "length": 34
    },
    {
        "index": 148118,
        "code": "static void VoidMethodLongLongArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodLongLongArg\");\n\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n\n  int64_t long_long_arg;\n  long_long_arg = NativeValueTraits<IDLLongLong>::NativeValue(info.GetIsolate(), info[0], exception_state);\n  if (exception_state.HadException())\n    return;\n\n  impl->voidMethodLongLongArg(long_long_arg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 163
    },
    {
        "index": 82557,
        "code": "NO_INLINE void jspeBlockNoBrackets() {\n  if (JSP_SHOULD_EXECUTE) {\n    while (lex->tk && lex->tk!='}') {\n      jsvUnLock(jspeStatement());\n      if (JSP_HAS_ERROR) {\n        if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {\n          execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);\n          JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);\n          if (stackTrace) {\n            jsvAppendPrintf(stackTrace, \"at \");\n            jspAppendStackTrace(stackTrace);\n            jsvUnLock(stackTrace);\n          }\n        }\n      }\n      if (JSP_SHOULDNT_PARSE)\n        return;\n    }\n  } else {\n    int brackets = 0;\n    while (lex->tk && (brackets || lex->tk != '}')) {\n      if (lex->tk == '{') brackets++;\n      if (lex->tk == '}') brackets--;\n      JSP_ASSERT_MATCH(lex->tk);\n    }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-11594",
        "length": 238
    },
    {
        "index": 79501,
        "code": "static int nntp_date(struct NntpServer *nserv, time_t *now)\n{\n  if (nserv->hasDATE)\n  {\n    struct NntpData nntp_data;\n    char buf[LONG_STRING];\n    struct tm tm;\n    memset(&tm, 0, sizeof(tm));\n\n    nntp_data.nserv = nserv;\n    nntp_data.group = NULL;\n    mutt_str_strfcpy(buf, \"DATE\\r\\n\", sizeof(buf));\n    if (nntp_query(&nntp_data, buf, sizeof(buf)) < 0)\n      return -1;\n\n    if (sscanf(buf, \"111 %4d%2d%2d%2d%2d%2d%*s\", &tm.tm_year, &tm.tm_mon,\n               &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec) == 6)\n    {\n      tm.tm_year -= 1900;\n      tm.tm_mon--;\n      *now = timegm(&tm);\n      if (*now >= 0)\n      {\n        mutt_debug(1, \"server time is %lu\\n\", *now);\n        return 0;\n      }\n    }\n  }\n  time(now);\n  return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-14361",
        "length": 264
    },
    {
        "index": 65189,
        "code": "int udpv6_offload_init(void)\n{\n\treturn inet6_add_offload(&udpv6_offload, IPPROTO_UDP);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-9074",
        "length": 28
    },
    {
        "index": 75013,
        "code": "map_activate(map_op_t op, bool use_default)\n{\n\tif (use_default)\n\t\tscript_run(s_def_map_scripts[op], false);\n\tscript_run(s_map->scripts[op], false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-1000524",
        "length": 40
    },
    {
        "index": 179976,
        "code": "void put_filp(struct file *file)\n {\n \tif (atomic_long_dec_and_test(&file->f_count)) {\n \t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n \t\tfile_free(file);\n \t}\n }\n",
        "line": "\t\tfile_sb_list_del(file);\n",
        "label": 1,
        "cwe": "CWE-17",
        "cve": "CVE-2014-8172",
        "length": 49
    },
    {
        "index": 151097,
        "code": "content::WebContents* DevToolsToolboxDelegate::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  DCHECK(source == web_contents());\n  if (!params.url.SchemeIs(content::kChromeDevToolsScheme))\n    return NULL;\n  content::NavigationController::LoadURLParams load_url_params(params.url);\n  source->GetController().LoadURLWithParams(load_url_params);\n  return source;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-5011",
        "length": 96
    },
    {
        "index": 159973,
        "code": "void DiskCacheBackendTest::BackendInvalidEntry7() {\n  const int kSize = 0x3000;  // 12 kB.\n  SetMaxSize(kSize * 10);\n  InitCache();\n\n  std::string first(\"some key\");\n  std::string second(\"something else\");\n  disk_cache::Entry* entry;\n  ASSERT_THAT(CreateEntry(first, &entry), IsOk());\n  entry->Close();\n  ASSERT_THAT(CreateEntry(second, &entry), IsOk());\n\n  disk_cache::EntryImpl* entry_impl =\n      static_cast<disk_cache::EntryImpl*>(entry);\n\n  entry_impl->rankings()->Data()->next = 0;\n  entry_impl->rankings()->Store();\n  entry->Close();\n  FlushQueueForTest();\n  EXPECT_EQ(2, cache_->GetEntryCount());\n\n  EXPECT_NE(net::OK, OpenEntry(second, &entry));\n  EXPECT_EQ(1, cache_->GetEntryCount());\n\n  std::unique_ptr<TestIterator> iter = CreateIterator();\n  EXPECT_NE(net::OK, iter->OpenNextEntry(&entry));\n  FlushQueueForTest();\n  EXPECT_EQ(0, cache_->GetEntryCount());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6085",
        "length": 243
    },
    {
        "index": 25879,
        "code": "kgdb_notify(struct notifier_block *self, unsigned long cmd, void *ptr)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = __kgdb_notify(ptr, cmd);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 50
    },
    {
        "index": 118772,
        "code": "void ContainerNode::parserRemoveChild(Node* oldChild)\n{\n    ASSERT(oldChild);\n    ASSERT(oldChild->parentNode() == this);\n    ASSERT(!oldChild->isDocumentFragment());\n\n    Node* prev = oldChild->previousSibling();\n    Node* next = oldChild->nextSibling();\n\n    oldChild->updateAncestorConnectedSubframeCountForRemoval();\n\n    ChildListMutationScope(this).willRemoveChild(oldChild);\n    oldChild->notifyMutationObserversNodeWillDetach();\n\n    removeBetween(prev, next, oldChild);\n\n    childrenChanged(true, prev, next, -1);\n    ChildNodeRemovalNotifier(this).notify(oldChild);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-6625",
        "length": 135
    },
    {
        "index": 81502,
        "code": "static int tracing_release_pipe(struct inode *inode, struct file *file)\n{\n\tstruct trace_iterator *iter = file->private_data;\n\tstruct trace_array *tr = inode->i_private;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->current_trace->ref--;\n\n\tif (iter->trace->pipe_close)\n\t\titer->trace->pipe_close(iter);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(iter->started);\n\tmutex_destroy(&iter->mutex);\n\tkfree(iter);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 107
    },
    {
        "index": 28936,
        "code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6367",
        "length": 259
    },
    {
        "index": 128228,
        "code": "bool FrameView::contentsInCompositedLayer() const\n{\n    RenderView* renderView = this->renderView();\n    if (renderView && renderView->compositingState() == PaintsIntoOwnBacking) {\n        GraphicsLayer* layer = renderView->layer()->compositedLayerMapping()->mainGraphicsLayer();\n        if (layer && layer->drawsContent())\n            return true;\n    }\n\n    return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-3191",
        "length": 92
    },
    {
        "index": 43094,
        "code": "static int vhost_scsi_get_cmd_state(struct se_cmd *se_cmd)\n{\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4036",
        "length": 23
    },
    {
        "index": 144293,
        "code": "void LoginDisplayHostWebUI::EmitLoginPromptVisibleCalled() {\n  OnLoginPromptVisible();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1639",
        "length": 23
    },
    {
        "index": 133290,
        "code": "void HandleLaunchAppN(int n) {\n  base::RecordAction(UserMetricsAction(\"Accel_Launch_App\"));\n  Shelf::ForPrimaryDisplay()->LaunchAppIndexAt(n);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 39
    },
    {
        "index": 12857,
        "code": "const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void)\n{\n    return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2016-2107",
        "length": 24
    },
    {
        "index": 171083,
        "code": "ID3::Version ID3::version() const {\n return mVersion;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-3920",
        "length": 17
    },
    {
        "index": 154695,
        "code": "error::Error GLES2DecoderPassthroughImpl::DoGetProgramInterfaceiv(\n    GLuint program,\n    GLenum program_interface,\n    GLenum pname,\n    GLsizei bufsize,\n    GLsizei* length,\n    GLint* params) {\n  if (bufsize < 1) {\n    return error::kOutOfBounds;\n  }\n  *length = 1;\n  api()->glGetProgramInterfaceivFn(GetProgramServiceID(program, resources_),\n                                   program_interface, pname, params);\n  return error::kNoError;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 106
    },
    {
        "index": 124166,
        "code": "bool RenderViewHostManager::ShouldCloseTabOnUnresponsiveRenderer() {\n  if (!cross_navigation_pending_)\n    return true;\n\n  int pending_request_id = pending_render_view_host_->GetPendingRequestId();\n  if (pending_request_id == -1) {\n    if (pending_render_view_host_->are_navigations_suspended())\n      pending_render_view_host_->SetNavigationsSuspended(false);\n  } else {\n    ViewMsg_SwapOut_Params params;\n    params.closing_process_id = render_view_host_->GetProcess()->GetID();\n    params.closing_route_id = render_view_host_->GetRoutingID();\n    params.new_render_process_host_id =\n        pending_render_view_host_->GetProcess()->GetID();\n    params.new_request_id = pending_request_id;\n    current_host()->GetProcess()->SimulateSwapOutACK(params);\n  }\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0921",
        "length": 177
    },
    {
        "index": 119306,
        "code": "bool TranslateInfoBarDelegate::ShouldShowMessageInfoBarButton() {\n  return !GetMessageInfoBarButtonText().empty();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2013-2906",
        "length": 26
    },
    {
        "index": 170050,
        "code": "xsltAllocateExtra(xsltStylesheetPtr style)\n{\n    return(style->extrasNr++);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 21
    },
    {
        "index": 152054,
        "code": "void RenderFrameHostImpl::PendingDeletionCheckCompleted() {\n  if (unload_state_ == UnloadState::Completed && children_.empty()) {\n    if (is_waiting_for_swapout_ack_)\n      OnSwappedOut();\n    else\n      parent_->RemoveChild(frame_tree_node_);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5019",
        "length": 63
    },
    {
        "index": 105277,
        "code": "String HTMLElement::title() const\n{\n    return getAttribute(titleAttr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2795",
        "length": 17
    },
    {
        "index": 122517,
        "code": "WebDevToolsAgentImpl* InspectorClientImpl::devToolsAgent()\n{\n    return static_cast<WebDevToolsAgentImpl*>(m_inspectedWebView->devToolsAgent());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0884",
        "length": 37
    },
    {
        "index": 148215,
        "code": "void CursorImpl::PrefetchReset(\n    int32_t used_prefetches,\n    int32_t unused_prefetches,\n    const std::vector<std::string>& unused_blob_uuids) {\n  for (const auto& uuid : unused_blob_uuids)\n    dispatcher_host_->DropBlobData(uuid);\n\n  idb_runner_->PostTask(\n      FROM_HERE,\n      base::Bind(&IDBThreadHelper::PrefetchReset, base::Unretained(helper_),\n                 used_prefetches, unused_prefetches));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5091",
        "length": 110
    },
    {
        "index": 180375,
        "code": " static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t/* delimiter found; check for singleton */\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\t/* a singleton; so send the position of token before the singleton */\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\t/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */\n\t\tresult =-1;\n\t}\n\treturn result;\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-125",
        "cve": "CVE-2016-5093",
        "length": 168
    },
    {
        "index": 98455,
        "code": "void Preferences::SetLanguageConfigBoolean(const char* section,\n                                           const char* name,\n                                           bool value) {\n  ImeConfigValue config;\n  config.type = ImeConfigValue::kValueTypeBool;\n  config.bool_value = value;\n  CrosLibrary::Get()->GetInputMethodLibrary()->\n      SetImeConfig(section, name, config);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 75
    },
    {
        "index": 96977,
        "code": "static struct page *alloc_fresh_huge_page(struct hstate *h,\n\t\tgfp_t gfp_mask, int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\tpage = alloc_gigantic_page(h, gfp_mask, nid, nmask);\n\telse\n\t\tpage = alloc_buddy_huge_page(h, gfp_mask,\n\t\t\t\tnid, nmask);\n\tif (!page)\n\t\treturn NULL;\n\n\tif (hstate_is_gigantic(h))\n\t\tprep_compound_gigantic_page(page, huge_page_order(h));\n\tprep_new_huge_page(h, page, page_to_nid(page));\n\n\treturn page;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "length": 149
    },
    {
        "index": 161014,
        "code": "void ChromeClientImpl::ShowVirtualKeyboardOnElementFocus(LocalFrame& frame) {\n  WebLocalFrameImpl::FromFrame(frame.LocalFrameRoot())\n      ->FrameWidget()\n      ->Client()\n      ->ShowVirtualKeyboardOnElementFocus();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 50
    },
    {
        "index": 147233,
        "code": "static void CSSAttributeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Local<v8::Object> holder = info.Holder();\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n\n  V8SetReturnValueInt(info, impl->cssAttribute());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 67
    },
    {
        "index": 122900,
        "code": "void RenderProcessHostImpl::RegisterHost(int host_id, RenderProcessHost* host) {\n  g_all_hosts.Get().AddWithID(host, host_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 35
    },
    {
        "index": 81534,
        "code": "tracing_thresh_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\tret = tracing_nsecs_write(&tracing_thresh, ubuf, cnt, ppos);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (tr->current_trace->update_thresh) {\n\t\tret = tr->current_trace->update_thresh(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = cnt;\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 138
    },
    {
        "index": 128803,
        "code": "ui::EglConfigCallbacks GetEglConfigCallbacks(EGLDisplay display) {\n  ui::EglConfigCallbacks callbacks;\n  callbacks.choose_config = base::Bind(EglChooseConfig, display);\n  callbacks.get_config_attribute = base::Bind(EglGetConfigAttribute, display);\n  callbacks.get_last_error_string = base::Bind(&ui::GetLastEGLErrorString);\n  return callbacks;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3176, CVE-2014-3177",
        "length": 83
    },
    {
        "index": 104732,
        "code": "void WebstorePrivateApi::SetTestingBrowserSignin(BrowserSignin* signin) {\n  test_signin = signin;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2358",
        "length": 28
    },
    {
        "index": 59053,
        "code": "static void usage(void) {\n\tprintf(\"\\nusage:\\n\");\n\tprintf(\"\\ttcmu-runner [options]\\n\");\n\tprintf(\"\\noptions:\\n\");\n\tprintf(\"\\t-h, --help: print this message and exit\\n\");\n\tprintf(\"\\t-V, --version: print version and exit\\n\");\n\tprintf(\"\\t-d, --debug: enable debug messages\\n\");\n\tprintf(\"\\t--handler-path: set path to search for handler modules\\n\");\n\tprintf(\"\\t\\tdefault is %s\\n\", DEFAULT_HANDLER_PATH);\n\tprintf(\"\\t-l, --tcmu-log-dir: tcmu log dir\\n\");\n\tprintf(\"\\t\\tdefault is %s\\n\", TCMU_LOG_DIR_DEFAULT);\n\tprintf(\"\\n\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-1000201",
        "length": 145
    },
    {
        "index": 106142,
        "code": "EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithOptionalStringIsUndefined(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    const String& str(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n    if (exec->hadException())\n        return JSValue::encode(jsUndefined());\n    impl->methodWithOptionalStringIsUndefined(str);\n    return JSValue::encode(jsUndefined());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2350",
        "length": 206
    },
    {
        "index": 96288,
        "code": "nfs_check_exportfs(void)\n{\n\tpid_t pid;\n\tint rc, status;\n\tstatic char nfs_exportfs_tempfile[] = \"/tmp/exportfs.XXXXXX\";\n\n\t/*\n\t * Close any existing temporary copies of output from exportfs.\n\t * We have already called unlink() so file will be deleted.\n\t */\n\tif (nfs_exportfs_temp_fd >= 0)\n\t\tclose(nfs_exportfs_temp_fd);\n\n\tnfs_exportfs_temp_fd = mkstemp(nfs_exportfs_tempfile);\n\n\tif (nfs_exportfs_temp_fd < 0)\n\t\treturn (SA_SYSTEM_ERR);\n\n\tunlink(nfs_exportfs_tempfile);\n\n\tfcntl(nfs_exportfs_temp_fd, F_SETFD, FD_CLOEXEC);\n\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\t(void) close(nfs_exportfs_temp_fd);\n\t\tnfs_exportfs_temp_fd = -1;\n\t\treturn (SA_SYSTEM_ERR);\n\t}\n\n\tif (pid > 0) {\n\t\twhile ((rc = waitpid(pid, &status, 0)) <= 0 && errno == EINTR);\n\n\t\tif (rc <= 0) {\n\t\t\t(void) close(nfs_exportfs_temp_fd);\n\t\t\tnfs_exportfs_temp_fd = -1;\n\t\t\treturn (SA_SYSTEM_ERR);\n\t\t}\n\n\t\tif (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {\n\t\t\t(void) close(nfs_exportfs_temp_fd);\n\t\t\tnfs_exportfs_temp_fd = -1;\n\t\t\treturn (SA_CONFIG_ERR);\n\t\t}\n\n\t\treturn (SA_OK);\n\t}\n\n\t/* child */\n\n\t/* exportfs -v */\n\n\tif (dup2(nfs_exportfs_temp_fd, STDOUT_FILENO) < 0)\n\t\texit(1);\n\n\trc = execlp(\"/usr/sbin/exportfs\", \"exportfs\", \"-v\", NULL);\n\n\tif (rc < 0) {\n\t\texit(1);\n\t}\n\n\texit(0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-3400",
        "length": 403
    },
    {
        "index": 101066,
        "code": "  QuotaDatabase* database() const { return database_; }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 14
    },
    {
        "index": 45411,
        "code": "int ecryptfs_derive_iv(char *iv, struct ecryptfs_crypt_stat *crypt_stat,\n\t\t       loff_t offset)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\tchar src[ECRYPTFS_MAX_IV_BYTES + 16];\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"root iv:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->root_iv, crypt_stat->iv_bytes);\n\t}\n\t/* TODO: It is probably secure to just cast the least\n\t * significant bits of the root IV into an unsigned long and\n\t * add the offset to that rather than go through all this\n\t * hashing business. -Halcrow */\n\tmemcpy(src, crypt_stat->root_iv, crypt_stat->iv_bytes);\n\tmemset((src + crypt_stat->iv_bytes), 0, 16);\n\tsnprintf((src + crypt_stat->iv_bytes), 16, \"%lld\", offset);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"source:\\n\");\n\t\tecryptfs_dump_hex(src, (crypt_stat->iv_bytes + 16));\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, src,\n\t\t\t\t    (crypt_stat->iv_bytes + 16));\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating IV for a page\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(iv, dst, crypt_stat->iv_bytes);\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"derived iv:\\n\");\n\t\tecryptfs_dump_hex(iv, crypt_stat->iv_bytes);\n\t}\nout:\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-9683",
        "length": 388
    },
    {
        "index": 33216,
        "code": "xfs_buf_iodone_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_buf\t\t*bp =\n\t\tcontainer_of(work, xfs_buf_t, b_iodone_work);\n\tbool\t\t\tread = !!(bp->b_flags & XBF_READ);\n\n\tbp->b_flags &= ~(XBF_READ | XBF_WRITE | XBF_READ_AHEAD);\n\tif (read && bp->b_ops)\n\t\tbp->b_ops->verify_read(bp);\n\n\tif (bp->b_iodone)\n\t\t(*(bp->b_iodone))(bp);\n\telse if (bp->b_flags & XBF_ASYNC)\n\t\txfs_buf_relse(bp);\n\telse {\n\t\tASSERT(read && bp->b_ops);\n\t\tcomplete(&bp->b_iowait);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1819",
        "length": 164
    },
    {
        "index": 149678,
        "code": "base::string16 SaveCardBubbleControllerImpl::GetExplanatoryMessage() const {\n  return is_uploading_ ? l10n_util::GetStringUTF16(\n                             IDS_AUTOFILL_SAVE_CARD_PROMPT_UPLOAD_EXPLANATION)\n                       : base::string16();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5080",
        "length": 57
    },
    {
        "index": 50918,
        "code": "SYSCALL_DEFINE2(umount, char __user *, name, int, flags)\n{\n\tstruct path path;\n\tstruct mount *mnt;\n\tint retval;\n\tint lookup_flags = 0;\n\n\tif (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))\n\t\treturn -EINVAL;\n\n\tif (!may_mount())\n\t\treturn -EPERM;\n\n\tif (!(flags & UMOUNT_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\n\tretval = user_path_mountpoint_at(AT_FDCWD, name, lookup_flags, &path);\n\tif (retval)\n\t\tgoto out;\n\tmnt = real_mount(path.mnt);\n\tretval = -EINVAL;\n\tif (path.dentry != path.mnt->mnt_root)\n\t\tgoto dput_and_out;\n\tif (!check_mnt(mnt))\n\t\tgoto dput_and_out;\n\tif (mnt->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto dput_and_out;\n\tretval = -EPERM;\n\tif (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))\n\t\tgoto dput_and_out;\n\n\tretval = do_umount(mnt, flags);\ndput_and_out:\n\t/* we mustn't call path_put() as that would clear mnt_expiry_mark */\n\tdput(path.dentry);\n\tmntput_no_expire(mnt);\nout:\n\treturn retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2016-6213",
        "length": 280
    },
    {
        "index": 40224,
        "code": "static void udp_v6_rehash(struct sock *sk)\n{\n\tu16 new_hash = udp6_portaddr_hash(sock_net(sk),\n\t\t\t\t\t  &sk->sk_v6_rcv_saddr,\n\t\t\t\t\t  inet_sk(sk)->inet_num);\n\n\tudp_lib_rehash(sk, new_hash);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-7281",
        "length": 59
    },
    {
        "index": 153648,
        "code": "void GLES2Implementation::GenFramebuffersHelper(\n    GLsizei /* n */,\n    const GLuint* /* framebuffers */) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 25
    },
    {
        "index": 144110,
        "code": "png_set_write_user_transform_fn(png_structp png_ptr, png_user_transform_ptr\n   write_user_transform_fn)\n{\n   png_debug(1, \"in png_set_write_user_transform_fn\");\n\n   if (png_ptr == NULL)\n      return;\n   png_ptr->transformations |= PNG_USER_TRANSFORM;\n   png_ptr->write_user_transform_fn = write_user_transform_fn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8126",
        "length": 77
    },
    {
        "index": 47763,
        "code": "static void netlink_remove(struct sock *sk)\n{\n\tstruct netlink_table *table;\n\n\ttable = &nl_table[sk->sk_protocol];\n\tif (!rhashtable_remove_fast(&table->hash, &nlk_sk(sk)->node,\n\t\t\t\t    netlink_rhashtable_params)) {\n\t\tWARN_ON(atomic_read(&sk->sk_refcnt) == 1);\n\t\t__sock_put(sk);\n\t}\n\n\tnetlink_table_grab();\n\tif (nlk_sk(sk)->subscriptions) {\n\t\t__sk_del_bind_node(sk);\n\t\tnetlink_update_listeners(sk);\n\t}\n\tif (sk->sk_protocol == NETLINK_GENERIC)\n\t\tatomic_inc(&genl_sk_destructing_cnt);\n\tnetlink_table_ungrab();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2016-9806",
        "length": 151
    },
    {
        "index": 57898,
        "code": "int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,\n\t\t\tstruct page *page)\n{\n\tif (addr < vma->vm_start || addr >= vma->vm_end)\n\t\treturn -EFAULT;\n\tif (!page_count(page))\n\t\treturn -EINVAL;\n\tif (!(vma->vm_flags & VM_MIXEDMAP)) {\n\t\tBUG_ON(down_read_trylock(&vma->vm_mm->mmap_sem));\n\t\tBUG_ON(vma->vm_flags & VM_PFNMAP);\n\t\tvma->vm_flags |= VM_MIXEDMAP;\n\t}\n\treturn insert_page(vma, addr, page, vma->vm_page_prot);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-3288",
        "length": 138
    },
    {
        "index": 113185,
        "code": "void LauncherView::GetOverflowItems(std::vector<LauncherItem>* items) {\n  int index = 0;\n  while (index < view_model_->view_size() &&\n         view_model_->view_at(index)->visible()) {\n    index++;\n  }\n  while (index < view_model_->view_size()) {\n    const LauncherItem& item = model_->items()[index];\n    if (item.type == TYPE_TABBED ||\n        item.type == TYPE_APP_PANEL ||\n        item.type == TYPE_APP_SHORTCUT)\n      items->push_back(item);\n    index++;\n   }\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-2895",
        "length": 119
    },
    {
        "index": 20342,
        "code": "void kvm_exit(void)\n{\n\tkvm_exit_debug();\n\tmisc_deregister(&kvm_dev);\n\tkmem_cache_destroy(kvm_vcpu_cache);\n\tkvm_async_pf_deinit();\n\tunregister_syscore_ops(&kvm_syscore_ops);\n\tunregister_reboot_notifier(&kvm_reboot_notifier);\n\tunregister_cpu_notifier(&kvm_cpu_notifier);\n\ton_each_cpu(hardware_disable_nolock, NULL, 1);\n\tkvm_arch_hardware_unsetup();\n\tkvm_arch_exit();\n\tfree_cpumask_var(cpus_hardware_enabled);\n\t__free_page(hwpoison_page);\n\t__free_page(bad_page);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-2121",
        "length": 129
    },
    {
        "index": 71212,
        "code": "int kvm_get_dirty_log(struct kvm *kvm,\n\t\t\tstruct kvm_dirty_log *log, int *is_dirty)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint r, i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\n\tr = -EINVAL;\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tr = -ENOENT;\n\tif (!memslot->dirty_bitmap)\n\t\tgoto out;\n\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = memslot->dirty_bitmap[i];\n\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, memslot->dirty_bitmap, n))\n\t\tgoto out;\n\n\tif (any)\n\t\t*is_dirty = 1;\n\n\tr = 0;\nout:\n\treturn r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-10150",
        "length": 246
    },
    {
        "index": 35776,
        "code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2014-7842",
        "length": 261
    },
    {
        "index": 158313,
        "code": "void RenderWidgetHostImpl::OnFrameSwapMessagesReceived(\n    uint32_t frame_token,\n    std::vector<IPC::Message> messages) {\n  frame_token_message_queue_->OnFrameSwapMessagesReceived(frame_token,\n                                                          std::move(messages));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17467",
        "length": 53
    },
    {
        "index": 77917,
        "code": "test_bson_initializer (void)\n{\n   bson_t b = BSON_INITIALIZER;\n\n   BSON_ASSERT (bson_empty (&b));\n   bson_append_bool (&b, \"foo\", -1, true);\n   BSON_ASSERT (!bson_empty (&b));\n   bson_destroy (&b);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16790",
        "length": 57
    },
    {
        "index": 143385,
        "code": "    Params(\n        const scoped_refptr<base::SingleThreadTaskRunner>& worker_task_runner,\n        int* num_outstanding_callbacks)\n        : v8_resolver(nullptr),\n          worker_task_runner(worker_task_runner),\n          num_outstanding_callbacks(num_outstanding_callbacks) {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 54
    },
    {
        "index": 64632,
        "code": "static int ip6_finish_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif ((skb->len > ip6_skb_dst_mtu(skb) && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && skb->len > IP6CB(skb)->frag_max_size))\n\t\treturn ip6_fragment(net, sk, skb, ip6_finish_output2);\n\telse\n\t\treturn ip6_finish_output2(net, sk, skb);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-9242",
        "length": 148
    },
    {
        "index": 155483,
        "code": "    ~OptimizationHintsComponentInstallerPolicy() {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5199",
        "length": 11
    },
    {
        "index": 133072,
        "code": "void HWNDMessageHandler::DidProcessEvent(const base::NativeEvent& event) {\n  RedrawInvalidRect();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 24
    },
    {
        "index": 133984,
        "code": "bool AppListSyncableService::RemoveDefaultApp(AppListItem* item,\n                                              SyncItem* sync_item) {\n  CHECK_EQ(sync_item->item_type,\n           sync_pb::AppListSpecifics::TYPE_REMOVE_DEFAULT_APP);\n\n  if (sync_item->item_type == sync_pb::AppListSpecifics::TYPE_APP &&\n      AppIsDefault(extension_system_->extension_service(), item->id())) {\n    VLOG(2) << this << \": HandleDefaultApp: Uninstall: \"\n            << sync_item->ToString();\n    UninstallExtension(extension_system_->extension_service(), item->id());\n    return true;\n  }\n\n  DeleteSyncItem(sync_item);\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6644",
        "length": 139
    },
    {
        "index": 150487,
        "code": "void NavigationControllerImpl::Restore(\n    int selected_navigation,\n    RestoreType type,\n    std::vector<std::unique_ptr<NavigationEntry>>* entries) {\n  DCHECK(GetEntryCount() == 0 && !GetPendingEntry());\n  DCHECK(selected_navigation >= 0 &&\n         selected_navigation < static_cast<int>(entries->size()));\n\n  needs_reload_ = true;\n  entries_.reserve(entries->size());\n  for (auto& entry : *entries)\n    entries_.push_back(\n        NavigationEntryImpl::FromNavigationEntry(std::move(entry)));\n\n  entries->clear();\n\n  FinishRestore(selected_navigation, type);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-5035",
        "length": 127
    },
    {
        "index": 75301,
        "code": "static int start_page_no_capturepattern(vorb *f)\n{\n   uint32 loc0,loc1,n;\n   if (0 != get8(f)) return error(f, VORBIS_invalid_stream_structure_version);\n   f->page_flag = get8(f);\n   loc0 = get32(f); \n   loc1 = get32(f);\n   get32(f);\n   n = get32(f);\n   f->last_page = n;\n   get32(f);\n   f->segment_count = get8(f);\n   if (!getn(f, f->segments, f->segment_count))\n      return error(f, VORBIS_unexpected_eof);\n   f->end_seg_with_known_loc = -2;\n   if (loc0 != ~0U || loc1 != ~0U) {\n      int i;\n      for (i=f->segment_count-1; i >= 0; --i)\n         if (f->segments[i] < 255)\n            break;\n      if (i >= 0) {\n         f->end_seg_with_known_loc = i;\n         f->known_loc_for_packet   = loc0;\n      }\n   }\n   if (f->first_decode) {\n      int i,len;\n      ProbedPage p;\n      len = 0;\n      for (i=0; i < f->segment_count; ++i)\n         len += f->segments[i];\n      len += 27 + f->segment_count;\n      p.page_start = f->first_audio_page_offset;\n      p.page_end = p.page_start + len;\n      p.last_decoded_sample = loc0;\n      f->p_first = p;\n   }\n   f->next_seg = 0;\n   return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-1000050",
        "length": 358
    },
    {
        "index": 98194,
        "code": "void TranslateManager::ShowInfoBar(TabContents* tab,\n                                   TranslateInfoBarDelegate* infobar) {\n  TranslateInfoBarDelegate* old_infobar = GetTranslateInfoBarDelegate(tab);\n  infobar->UpdateBackgroundAnimation(old_infobar);\n  if (old_infobar) {\n    tab->ReplaceInfoBar(old_infobar, infobar);\n  } else {\n    tab->AddInfoBar(infobar);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 90
    },
    {
        "index": 132549,
        "code": "ShellContentBrowserClient::GetDevToolsManagerDelegate() {\n  return new ShellDevToolsManagerDelegate(browser_context());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1700",
        "length": 25
    },
    {
        "index": 148896,
        "code": "void RenderFrameHostManager::OnCrossSiteResponse(\n    RenderFrameHostImpl* transferring_render_frame_host,\n    const GlobalRequestID& global_request_id,\n    const std::vector<GURL>& transfer_url_chain,\n    const Referrer& referrer,\n    ui::PageTransition page_transition,\n    bool should_replace_current_entry) {\n  DCHECK(transferring_render_frame_host == pending_render_frame_host_.get() ||\n         transferring_render_frame_host == render_frame_host_.get());\n\n  bool frame_tree_node_was_loading = frame_tree_node_->IsLoading();\n\n  transfer_navigation_handle_ =\n      transferring_render_frame_host->PassNavigationHandleOwnership();\n  CHECK(transfer_navigation_handle_);\n\n  transferring_render_frame_host->set_is_loading(false);\n\n  CHECK(transfer_url_chain.size());\n  GURL transfer_url = transfer_url_chain.back();\n  std::vector<GURL> rest_of_chain = transfer_url_chain;\n  rest_of_chain.pop_back();\n\n  std::string extra_headers;\n\n  transferring_render_frame_host->frame_tree_node()\n      ->navigator()\n      ->RequestTransferURL(\n          transferring_render_frame_host, transfer_url, nullptr, rest_of_chain,\n          referrer, page_transition, global_request_id,\n          should_replace_current_entry,\n          transfer_navigation_handle_->IsPost() ? \"POST\" : \"GET\",\n          transfer_navigation_handle_->resource_request_body(), extra_headers);\n\n  if (transfer_navigation_handle_) {\n    transfer_navigation_handle_->set_net_error_code(net::ERR_ABORTED);\n    transfer_navigation_handle_->set_is_transferring(false);\n    transfer_navigation_handle_.reset();\n  }\n\n  if (!frame_tree_node_->IsLoading() && frame_tree_node_was_loading)\n    frame_tree_node_->DidStopLoading();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 346
    },
    {
        "index": 188368,
        "code": "const CuePoint* Cues::GetNext(const CuePoint* pCurr) const\n{\n    if (pCurr == NULL)\n        return NULL;\n    assert(pCurr->GetTimeCode() >= 0);\n    assert(m_cue_points);\n    assert(m_count >= 1);\n \n #if 0\n     const size_t count = m_count + m_preload_count;\n\n size_t index = pCurr->m_index;\n    assert(index < count);\n\n CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    assert(pp[index] == pCurr);\n\n ++index;\n\n if (index >= count)\n return NULL;\n\n CuePoint* const pNext = pp[index];\n    assert(pNext);\n\n \n     pNext->Load(m_pSegment->m_pReader);\n #else\n    long index = pCurr->m_index;\n    assert(index < m_count);\n \n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    assert(pp[index] == pCurr);\n \n    ++index;\n \n    if (index >= m_count)\n        return NULL;\n \n    CuePoint* const pNext = pp[index];\n    assert(pNext);\n    assert(pNext->GetTimeCode() >= 0);\n #endif\n \n    return pNext;\n }\n",
        "line": "{\n    if (pCurr == NULL)\n        return NULL;\n    assert(pCurr->GetTimeCode() >= 0);\n    assert(m_cue_points);\n    assert(m_count >= 1);\n    long index = pCurr->m_index;\n    assert(index < m_count);\n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    assert(pp[index] == pCurr);\n    ++index;\n    if (index >= m_count)\n        return NULL;\n    CuePoint* const pNext = pp[index];\n    assert(pNext);\n    assert(pNext->GetTimeCode() >= 0);\n    return pNext;\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 268
    },
    {
        "index": 67394,
        "code": "static void debugfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-7533",
        "length": 48
    },
    {
        "index": 46839,
        "code": "static int ecb_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n\t\t       struct scatterlist *src, unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\treturn ecb_crypt(desc, &walk, blowfish_dec_blk, blowfish_dec_blk_4way);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 77
    },
    {
        "index": 6626,
        "code": "lib_file_open_search_with_no_combine(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                                     const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile,\n                                     gx_io_device *iodev, bool starting_arg_file, char *fmode)\n{\n    stream *s;\n    uint blen1 = blen;\n    struct stat fstat;\n\n    if (gp_file_name_reduce(fname, flen, buffer, &blen1) != gp_combine_success)\n      goto skip;\n\n    if (starting_arg_file || check_file_permissions_aux(i_ctx_p, buffer, blen1) >= 0) {\n        if (iodev_os_open_file(iodev, (const char *)buffer, blen1,\n                       (const char *)fmode, &s, (gs_memory_t *)mem) == 0) {\n            *pclen = blen1;\n            make_stream_file(pfile, s, \"r\");\n            return 0;\n        }\n    }\n    else {\n        /* If we are not allowed to open the file by check_file_permissions_aux()\n         * and if the file exists, throw an error.......\n         * Otherwise, keep searching.\n         */\n        if ((*iodev->procs.file_status)(iodev,  buffer, &fstat) >= 0) {\n            return_error(gs_error_invalidfileaccess);\n        }\n    }\n\n skip:\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-11645",
        "length": 315
    },
    {
        "index": 94627,
        "code": "int X509_REQ_digest(const X509_REQ *data, const EVP_MD *type, unsigned char *md,\n\t     unsigned int *len)\n\t{\n\treturn(ASN1_item_digest(ASN1_ITEM_rptr(X509_REQ),type,(char *)data,md,len));\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2014-8275",
        "length": 59
    },
    {
        "index": 74076,
        "code": "static void finalize_super_block(struct exfat* ef)\n{\n\tif (ef->ro)\n\t\treturn;\n\n\tef->sb->volume_state = cpu_to_le16(\n\t\t\tle16_to_cpu(ef->sb->volume_state) & ~EXFAT_STATE_MOUNTED);\n\n\t/* Some implementations set the percentage of allocated space to 0xff\n\t   on FS creation and never update it. In this case leave it as is. */\n\tif (ef->sb->allocated_percent != 0xff)\n\t{\n\t\tuint32_t free, total;\n\n\t\tfree = exfat_count_free_clusters(ef);\n\t\ttotal = le32_to_cpu(ef->sb->cluster_count);\n\t\tef->sb->allocated_percent = ((total - free) * 100 + total / 2) / total;\n\t}\n\n\tcommit_super_block(ef);\t/* ignore return code */\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-8026",
        "length": 182
    },
    {
        "index": 87423,
        "code": "static void HuffmanTree_cleanup(HuffmanTree* tree)\n{\n  free(tree->tree2d);\n  free(tree->tree1d);\n  free(tree->lengths);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-772",
        "cve": "CVE-2019-17178",
        "length": 37
    },
    {
        "index": 185810,
        "code": " bool AXTableCell::isColumnHeaderCell() const {\n   const AtomicString& scope = getAttribute(scopeAttr);\n  return equalIgnoringCase(scope, \"col\") ||\n         equalIgnoringCase(scope, \"colgroup\");\n }\n",
        "line": "  return equalIgnoringCase(scope, \"col\") ||\n         equalIgnoringCase(scope, \"colgroup\");\n",
        "label": 1,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 46
    },
    {
        "index": 161527,
        "code": "std::string ServiceWorkerDevToolsAgentHost::GetTitle() {\n  return \"Service Worker \" + url_.spec();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6111",
        "length": 27
    },
    {
        "index": 29696,
        "code": "void unregister_net_sysctl_table(struct ctl_table_header *header)\n{\n\tunregister_sysctl_table(header);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-4270",
        "length": 23
    },
    {
        "index": 177090,
        "code": "SoftAACEncoder::~SoftAACEncoder() {\n delete[] mInputFrame;\n    mInputFrame = NULL;\n\n if (mEncoderHandle) {\n        CHECK_EQ(VO_ERR_NONE, mApiHandle->Uninit(mEncoderHandle));\n        mEncoderHandle = NULL;\n }\n\n delete mApiHandle;\n    mApiHandle = NULL;\n\n delete mMemOperator;\n    mMemOperator = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2476",
        "length": 83
    },
    {
        "index": 80581,
        "code": "GF_Err tref_Write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 32
    },
    {
        "index": 67484,
        "code": "static const char * fileActionString(rpmFileAction a)\n{\n    switch (a) {\n    case FA_UNKNOWN:\treturn \"unknown\";\n    case FA_CREATE:\treturn \"create\";\n    case FA_BACKUP:\treturn \"backup\";\n    case FA_SAVE:\treturn \"save\";\n    case FA_SKIP:\treturn \"skip\";\n    case FA_ALTNAME:\treturn \"altname\";\n    case FA_ERASE:\treturn \"erase\";\n    case FA_SKIPNSTATE: return \"skipnstate\";\n    case FA_SKIPNETSHARED: return \"skipnetshared\";\n    case FA_SKIPCOLOR:\treturn \"skipcolor\";\n    case FA_TOUCH:     return \"touch\";\n    default:\t\treturn \"???\";\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2017-7501",
        "length": 147
    },
    {
        "index": 106622,
        "code": "void WebPageProxy::setDrawingArea(PassOwnPtr<DrawingAreaProxy> drawingArea)\n{\n    if (drawingArea == m_drawingArea)\n        return;\n\n    m_drawingArea = drawingArea;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 46
    },
    {
        "index": 104341,
        "code": "static PassRefPtr<CSSPrimitiveValue> fontSizeFromStyle(RenderStyle* style)\n{\n    return zoomAdjustedPixelValue(style->fontDescription().computedPixelSize(), style);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2806",
        "length": 36
    },
    {
        "index": 95895,
        "code": "void CL_startMultiplayer_f( void ) {\n\tchar binName[MAX_OSPATH];\n\n#if defined(_WIN64) || defined(__WIN64__)\n\tCom_sprintf(binName, sizeof(binName), \"ioWolfMP.\" ARCH_STRING \".exe\");\n\tSys_StartProcess( binName, qtrue );\n#elif defined(_WIN32) || defined(__WIN32__)\n\tCom_sprintf(binName, sizeof(binName), \"ioWolfMP.\" ARCH_STRING \".exe\");\n\tSys_StartProcess( binName, qtrue );\n#elif defined(__i386__) && (!defined(_WIN32) || !defined(__WIN32__))\n\tCom_sprintf(binName, sizeof(binName), \"./iowolfmp.\" BIN_STRING );\n\tSys_StartProcess( binName, qtrue );\n#else\n\tCom_sprintf(binName, sizeof(binName), \"./iowolfmp.\" ARCH_STRING );\n\tSys_StartProcess( binName, qtrue );\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 193
    },
    {
        "index": 78543,
        "code": "auth_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)\n{\n\tif (!serial)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tif (card->serialnr.len==0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\n\tmemcpy(serial, &card->serialnr, sizeof(*serial));\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 83
    },
    {
        "index": 59578,
        "code": "errorDebug(void *ctx ATTRIBUTE_UNUSED, const char *msg, ...)\n{\n    va_list args;\n\n    callbacks++;\n    if (quiet)\n\treturn;\n    va_start(args, msg);\n    fprintf(SAXdebug, \"SAX.error: \");\n    vfprintf(SAXdebug, msg, args);\n    va_end(args);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-16931",
        "length": 67
    },
    {
        "index": 120180,
        "code": "void Layer::SetOpacity(float opacity) {\n  DCHECK(IsPropertyChangeAllowed());\n  if (opacity_ == opacity)\n    return;\n  opacity_ = opacity;\n  SetNeedsCommit();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2902",
        "length": 40
    },
    {
        "index": 20050,
        "code": "static void update_changeattr(struct inode *dir, struct nfs4_change_info *cinfo)\n{\n\tstruct nfs_inode *nfsi = NFS_I(dir);\n\n\tspin_lock(&dir->i_lock);\n\tnfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE|NFS_INO_INVALID_DATA;\n\tif (!cinfo->atomic || cinfo->before != dir->i_version)\n\t\tnfs_force_lookup_revalidate(dir);\n\tdir->i_version = cinfo->after;\n\tspin_unlock(&dir->i_lock);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 116
    },
    {
        "index": 48409,
        "code": "PredictorVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->vsetparent != NULL);\n\n\tswitch (tag) {\n\tcase TIFFTAG_PREDICTOR:\n\t\tsp->predictor = (uint16) va_arg(ap, uint16_vap);\n\t\tTIFFSetFieldBit(tif, FIELD_PREDICTOR);\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9535",
        "length": 131
    },
    {
        "index": 184517,
        "code": "void ChromeInvalidationClient::ReissueRegistrations(\n    invalidation::InvalidationClient* client,\n     const std::string& prefix,\n     int prefix_length) {\n   DCHECK(CalledOnValidThread());\n   DVLOG(1) << \"AllRegistrationsLost\";\n   registration_manager_->MarkAllRegistrationsLost();\n }\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 68
    },
    {
        "index": 116893,
        "code": "void TestWebKitPlatformSupport::prefetchHostName(const WebKit::WebString&) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3087",
        "length": 19
    },
    {
        "index": 186649,
        "code": "bool WebRequestPermissions::HideRequest(\n    const extensions::InfoMap* extension_info_map,\n    const extensions::WebRequestInfo& request) {\n  if (request.is_web_view)\n    return false;\n\n  if (request.is_pac_request)\n    return true;\n \n  bool is_request_from_browser = request.render_process_id == -1;\n   bool is_request_from_webui_renderer = false;\n   if (!is_request_from_browser) {\n    if (request.is_web_view)\n      return false;\n\n    if (extension_info_map &&\n        extension_info_map->process_map().Contains(extensions::kWebStoreAppId,\n                                                   request.render_process_id)) {\n      return true;\n    }\n\n    is_request_from_webui_renderer =\n        content::ChildProcessSecurityPolicy::GetInstance()->HasWebUIBindings(\n            request.render_process_id);\n  }\n\n  return IsSensitiveURL(request.url, is_request_from_browser ||\n                                         is_request_from_webui_renderer) ||\n         !HasWebRequestScheme(request.url);\n}\n",
        "line": "  bool is_request_from_browser = request.render_process_id == -1;\n",
        "label": 1,
        "cwe": "CWE-200",
        "cve": "CVE-2018-6035",
        "length": 203
    },
    {
        "index": 102561,
        "code": "bool Start(const tracked_objects::Location& from_here,\n           scoped_refptr<base::MessageLoopProxy> message_loop_proxy,\n           scoped_refptr<MessageLoopRelay> relay) {\n  return relay->Start(message_loop_proxy, from_here);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2880",
        "length": 50
    },
    {
        "index": 1536,
        "code": "z2setgstate(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code;\n\n    check_stype(*op, st_igstate_obj);\n    code = restore_page_device(i_ctx_p, igs, igstate_ptr(op));\n    if (code < 0) return code;\n    if (code == 0)\n        return zsetgstate(i_ctx_p);\n    return push_callout(i_ctx_p, \"%setgstatepagedevice\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-19475",
        "length": 103
    },
    {
        "index": 52890,
        "code": "static int ib_uverbs_event_fasync(int fd, struct file *filp, int on)\n{\n\tstruct ib_uverbs_event_file *file = filp->private_data;\n\n\treturn fasync_helper(fd, filp, on, &file->async_queue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-4565",
        "length": 55
    },
    {
        "index": 78617,
        "code": "pgp_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 44
    },
    {
        "index": 130246,
        "code": "bool OSExchangeDataProviderWin::DidOriginateFromRenderer() const {\n  return HasCustomFormat(GetRendererTaintCustomType());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 28
    },
    {
        "index": 111919,
        "code": "void ProfileSyncService::OnSyncCycleCompleted() {\n  UpdateLastSyncedTime();\n  if (GetSessionModelAssociator()) {\n    MessageLoop::current()->PostTask(FROM_HERE,\n        base::Bind(&browser_sync::SessionModelAssociator::DeleteStaleSessions,\n                   GetSessionModelAssociator()->AsWeakPtr()));\n  }\n  DVLOG(2) << \"Notifying observers sync cycle completed\";\n  NotifyObservers();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 92
    },
    {
        "index": 89352,
        "code": "static int parse_sliteral(char **c, char **dst)\n{\n\tstruct token t;\n\tchar *s = *c;\n\n\tget_token(c, &t, L_SLITERAL);\n\n\tif (t.type != T_STRING) {\n\t\tprintf(\"Expected string literal: %.*s\\n\", (int)(*c - s), s);\n\t\treturn -EINVAL;\n\t}\n\n\t*dst = t.val;\n\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2019-13106",
        "length": 86
    },
    {
        "index": 15370,
        "code": "static int ssh_server_kexdh_init(ssh_session session, ssh_buffer packet){\n    ssh_string e;\n    e = buffer_get_ssh_string(packet);\n    if (e == NULL) {\n      ssh_set_error(session, SSH_FATAL, \"No e number in client request\");\n      return -1;\n    }\n    if (dh_import_e(session, e) < 0) {\n      ssh_set_error(session, SSH_FATAL, \"Cannot import e number\");\n      session->session_state=SSH_SESSION_STATE_ERROR;\n    } else {\n      session->dh_handshake_state=DH_STATE_INIT_SENT;\n      dh_handshake_server(session);\n    }\n    ssh_string_free(e);\n    return SSH_OK;\n }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-3146",
        "length": 143
    },
    {
        "index": 70969,
        "code": "void Type_ColorantOrderType_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    _cmsFree(self ->ContextID, Ptr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10165",
        "length": 34
    },
    {
        "index": 96981,
        "code": "struct page *alloc_huge_page_node(struct hstate *h, int nid)\n{\n\tgfp_t gfp_mask = htlb_alloc_mask(h);\n\tstruct page *page = NULL;\n\n\tif (nid != NUMA_NO_NODE)\n\t\tgfp_mask |= __GFP_THISNODE;\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0)\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, nid, NULL);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page)\n\t\tpage = alloc_migrate_huge_page(h, gfp_mask, nid, NULL);\n\n\treturn page;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11487",
        "length": 143
    },
    {
        "index": 186301,
        "code": "void WebContentsImpl::SetAsFocusedWebContentsIfNecessary() {\n  WebContentsImpl* old_contents = GetFocusedWebContents();\n  if (old_contents == this)\n    return;\n\n  GetOutermostWebContents()->node_.SetFocusedWebContents(this);\n\n  if (!GuestMode::IsCrossProcessFrameGuest(this) && browser_plugin_guest_)\n    return;\n\n  if (old_contents)\n    old_contents->GetMainFrame()->GetRenderWidgetHost()->SetPageFocus(false);\n\n  if (GetRenderManager()->GetProxyToOuterDelegate())\n     GetRenderManager()->GetProxyToOuterDelegate()->SetFocusedFrame();\n \n   if (ShowingInterstitialPage()) {\n    static_cast<RenderFrameHostImpl*>(\n        GetRenderManager()->interstitial_page()->GetMainFrame())\n         ->GetRenderWidgetHost()\n         ->SetPageFocus(true);\n   } else {\n    GetMainFrame()->GetRenderWidgetHost()->SetPageFocus(true);\n  }\n}\n",
        "line": "    static_cast<RenderFrameHostImpl*>(\n        GetRenderManager()->interstitial_page()->GetMainFrame())\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 193
    },
    {
        "index": 177650,
        "code": " static void TearDownTestCase() {\n    vpx_free(data_array_);\n    vpx_free(mi_);\n    vpx_free(mb_);\n    data_array_ = NULL;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 35
    },
    {
        "index": 155945,
        "code": "void PeopleHandler::OnDidClosePage(const base::ListValue* args) {\n  if (!args->GetList()[0].GetBool() && !IsProfileAuthNeededOrHasErrors()) {\n    MarkFirstSetupComplete();\n  }\n\n  CloseSyncSetup();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1665",
        "length": 56
    },
    {
        "index": 67382,
        "code": "static struct dentry *__debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\tconst struct file_operations *proxy_fops,\n\t\t\t\tconst struct file_operations *real_fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_private = data;\n\n\tinode->i_fop = proxy_fops;\n\tdentry->d_fsdata = (void *)real_fops;\n\n\td_instantiate(dentry, inode);\n\tfsnotify_create(d_inode(dentry->d_parent), dentry);\n\treturn end_creating(dentry);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-7533",
        "length": 207
    },
    {
        "index": 181283,
        "code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n \n         if (p->question->n_keys != 1)\n                 return 0;\n \n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-9217",
        "length": 159
    },
    {
        "index": 158291,
        "code": "void RenderWidgetHostImpl::GrantFileAccessFromDropData(DropData* drop_data) {\n  DCHECK_EQ(GetRoutingID(), drop_data->view_id);\n  RenderProcessHost* process = GetProcess();\n  PrepareDropDataForChildProcess(\n      drop_data, ChildProcessSecurityPolicyImpl::GetInstance(),\n      process->GetID(), process->GetStoragePartition()->GetFileSystemContext());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17467",
        "length": 81
    },
    {
        "index": 20237,
        "code": "static int hugetlbfs_write_begin(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn -EINVAL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2133",
        "length": 51
    },
    {
        "index": 45943,
        "code": "toomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-9621",
        "length": 55
    },
    {
        "index": 142420,
        "code": "  SkColor shelf_background_target_color() const {\n    return animator_->shelf_background_values_.target_color();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 24
    },
    {
        "index": 75356,
        "code": "static int ipddp_create(struct ipddp_route *new_rt)\n{\n        struct ipddp_route *rt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\n        if (rt == NULL)\n                return -ENOMEM;\n\n        rt->ip = new_rt->ip;\n        rt->at = new_rt->at;\n        rt->next = NULL;\n        if ((rt->dev = atrtr_get_dev(&rt->at)) == NULL) {\n\t\tkfree(rt);\n                return -ENETUNREACH;\n        }\n\n\tspin_lock_bh(&ipddp_route_lock);\n\tif (__ipddp_find_route(rt)) {\n\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\tkfree(rt);\n\t\treturn -EEXIST;\n\t}\n\n        rt->next = ipddp_route_list;\n        ipddp_route_list = rt;\n\n\tspin_unlock_bh(&ipddp_route_lock);\n\n        return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-20511",
        "length": 188
    },
    {
        "index": 131018,
        "code": "static void reflectedTreatNullAsNullStringStringAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectV8Internal::reflectedTreatNullAsNullStringStringAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 116
    },
    {
        "index": 113530,
        "code": "PassRefPtr<AccessibilityUIElement> AccessibilityUIElement::accessibilityElementForTextMarker(AccessibilityTextMarker* marker)\n{\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2867",
        "length": 33
    },
    {
        "index": 78850,
        "code": "int sc_mutex_create(const sc_context_t *ctx, void **mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->create_mutex != NULL)\n\t\treturn ctx->thread_ctx->create_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2018-16425",
        "length": 69
    },
    {
        "index": 68120,
        "code": "authz_status oidc_authz_checker(request_rec *r, const char *require_args, const void *parsed_require_args) {\n\n\t/* check for anonymous access and PASS mode */\n\tif (r->user != NULL && strlen(r->user) == 0) {\n\t\tr->user = NULL;\n\t\tif (oidc_dir_cfg_unauth_action(r) == OIDC_UNAUTH_PASS) return AUTHZ_GRANTED;\n\t}\n\n\t/* get the set of claims from the request state (they've been set in the authentication part earlier */\n\tjson_t *claims = NULL, *id_token = NULL;\n\toidc_authz_get_claims_and_idtoken(r, &claims, &id_token);\n\n\t/* merge id_token claims (e.g. \"iss\") in to claims json object */\n\tif (claims)\n\t\toidc_util_json_merge(id_token, claims);\n\n\t/* dispatch to the >=2.4 specific authz routine */\n\tauthz_status rc = oidc_authz_worker24(r, claims ? claims : id_token, require_args);\n\n\t/* cleanup */\n\tif (claims) json_decref(claims);\n\tif (id_token) json_decref(id_token);\n\n\tif ((rc == AUTHZ_DENIED) && ap_auth_type(r)\n\t\t\t&& (apr_strnatcasecmp((const char *) ap_auth_type(r), \"oauth20\")\n\t\t\t\t\t== 0))\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2017-6413",
        "length": 315
    },
    {
        "index": 154596,
        "code": "error::Error GLES2DecoderPassthroughImpl::DoCompressedTexImage2D(\n    GLenum target,\n    GLint level,\n    GLenum internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLint border,\n    GLsizei image_size,\n    GLsizei data_size,\n    const void* data) {\n  CheckErrorCallbackState();\n  api()->glCompressedTexImage2DRobustANGLEFn(target, level, internalformat,\n                                             width, height, border, image_size,\n                                             data_size, data);\n  if (CheckErrorCallbackState()) {\n    return error::kNoError;\n  }\n\n  UpdateTextureSizeFromTarget(target);\n\n  ExitCommandProcessingEarly();\n\n  return error::kNoError;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 144
    },
    {
        "index": 39287,
        "code": "int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = ebitmap_netlbl_import(&ctx_new.range.level[0].cat,\n\t\t\t\t\t\t   secattr->attr.mls.cat);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tmemcpy(&ctx_new.range.level[1].cat,\n\t\t\t       &ctx_new.range.level[0].cat,\n\t\t\t       sizeof(ctx_new.range.level[0].cat));\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-1874",
        "length": 455
    },
    {
        "index": 129631,
        "code": "bool SVGLayoutSupport::pointInClippingArea(const LayoutObject* object, const FloatPoint& point)\n{\n    ASSERT(object);\n\n    SVGResources* resources = SVGResourcesCache::cachedResourcesForLayoutObject(object);\n    if (!resources)\n        return true;\n\n    if (LayoutSVGResourceClipper* clipper = resources->clipper())\n        return clipper->hitTestClipContent(object->objectBoundingBox(), point);\n\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3167",
        "length": 92
    },
    {
        "index": 37566,
        "code": "static void paging_free(struct kvm_vcpu *vcpu)\n{\n\tnonpaging_free(vcpu);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 22
    },
    {
        "index": 20617,
        "code": "int kvm_dev_ioctl_check_extension(long ext)\n{\n\n\tint r;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_COALESCED_MMIO:\n\t\tr = KVM_COALESCED_MMIO_PAGE_OFFSET;\n\t\tbreak;\n\tcase KVM_CAP_IOMMU:\n\t\tr = iommu_present(&pci_bus_type);\n\t\tbreak;\n\tdefault:\n\t\tr = 0;\n\t}\n\treturn r;\n\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-1601",
        "length": 116
    },
    {
        "index": 95700,
        "code": "void CL_ReadDemoMessage( void ) {\n\tint\tr;\n\tmsg_t\tbuf;\n\tbyte\tbufData[ MAX_MSGLEN ];\n\tint\ts;\n\n\tif ( !clc.demofile ) {\n\t\tCL_DemoCompleted();\n\t\treturn;\n\t}\n\n\tr = FS_Read( &s, 4, clc.demofile );\n\tif ( r != 4 ) {\n\t\tCL_DemoCompleted();\n\t\treturn;\n\t}\n\tclc.serverMessageSequence = LittleLong( s );\n\n\tMSG_Init( &buf, bufData, sizeof( bufData ) );\n\n\tr = FS_Read( &buf.cursize, 4, clc.demofile );\n\tif ( r != 4 ) {\n\t\tCL_DemoCompleted();\n\t\treturn;\n\t}\n\tbuf.cursize = LittleLong( buf.cursize );\n\tif ( buf.cursize == -1 ) {\n\t\tCL_DemoCompleted();\n\t\treturn;\n\t}\n\tif ( buf.cursize > buf.maxsize ) {\n\t\tCom_Error( ERR_DROP, \"CL_ReadDemoMessage: demoMsglen > MAX_MSGLEN\" );\n\t}\n\tr = FS_Read( buf.data, buf.cursize, clc.demofile );\n\tif ( r != buf.cursize ) {\n\t\tCom_Printf( \"Demo file was truncated.\\n\" );\n\t\tCL_DemoCompleted();\n\t\treturn;\n\t}\n\n\tclc.lastPacketTime = cls.realtime;\n\tbuf.readcount = 0;\n\tCL_ParseServerMessage( &buf );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 308
    },
    {
        "index": 97343,
        "code": "KURL FrameLoader::baseURL() const\n{\n    ASSERT(m_frame->document());\n    return m_frame->document()->baseURL();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 30
    },
    {
        "index": 108817,
        "code": "  virtual void SetUp() {\n    old_browser_client_ = GetContentClient()->browser();\n    GetContentClient()->set_browser_for_testing(&test_browser_client_);\n\n    test_browser_client_.AddScheme(\"chrome\");\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-5138",
        "length": 45
    },
    {
        "index": 72755,
        "code": "static void jas_image_calcbbox2(jas_image_t *image, jas_image_coord_t *tlx,\n  jas_image_coord_t *tly, jas_image_coord_t *brx, jas_image_coord_t *bry)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t tmptlx;\n\tjas_image_coord_t tmptly;\n\tjas_image_coord_t tmpbrx;\n\tjas_image_coord_t tmpbry;\n\tjas_image_coord_t t;\n\tint i;\n\tif (image->numcmpts_ > 0) {\n\t\tcmpt = image->cmpts_[0];\n\t\ttmptlx = cmpt->tlx_;\n\t\ttmptly = cmpt->tly_;\n\t\ttmpbrx = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\ttmpbry = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\tfor (i = 0; i < image->numcmpts_; ++i) {\n\t\t\tcmpt = image->cmpts_[i];\n\t\t\tif (cmpt->tlx_ < tmptlx)\n\t\t\t\ttmptlx = cmpt->tlx_;\n\t\t\tif (cmpt->tly_ < tmptly)\n\t\t\t\ttmptly = cmpt->tly_;\n\t\t\tt = cmpt->tlx_ + cmpt->hstep_ * (cmpt->width_ - 1);\n\t\t\tif (t > tmpbrx)\n\t\t\t\ttmpbrx = t;\n\t\t\tt = cmpt->tly_ + cmpt->vstep_ * (cmpt->height_ - 1);\n\t\t\tif (t > tmpbry)\n\t\t\t\ttmpbry = t;\n\t\t}\n\t} else {\n\t\ttmptlx = 0;\n\t\ttmptly = 0;\n\t\ttmpbrx = -1;\n\t\ttmpbry = -1;\n\t}\n\t*tlx = tmptlx;\n\t*tly = tmptly;\n\t*brx = tmpbrx;\n \t*bry = tmpbry;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-9557",
        "length": 460
    },
    {
        "index": 57487,
        "code": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create, int *err)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create, err);\n\tif (!bh)\n\t\treturn bh;\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ_META, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\t*err = -EIO;\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8324",
        "length": 128
    },
    {
        "index": 2783,
        "code": "gs_deviceinitialmatrix(gx_device * dev, gs_matrix * pmat)\n{\n    fill_dev_proc(dev, get_initial_matrix, gx_default_get_initial_matrix);\n    (*dev_proc(dev, get_initial_matrix)) (dev, pmat);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-78",
        "cve": "CVE-2018-16863",
        "length": 51
    },
    {
        "index": 148976,
        "code": "static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){\n  UNUSED_PARAMETER(pWalker);\n  UNUSED_PARAMETER(pSelect);\n  return WRC_Continue;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-6991",
        "length": 40
    },
    {
        "index": 130893,
        "code": "static void namedPropertyGetterCallback(v8::Local<v8::String> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMNamedProperty\");\n    TestObjectV8Internal::namedPropertyGetter(name, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 80
    },
    {
        "index": 127900,
        "code": "SecurityOrigin* DocumentThreadableLoader::getSecurityOrigin() const\n{\n    return m_securityOrigin ? m_securityOrigin.get() : document().getSecurityOrigin();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-7909",
        "length": 35
    },
    {
        "index": 99878,
        "code": "CommandBufferProxy* WebPluginDelegateProxy::CreateCommandBuffer() {\n#if defined(ENABLE_GPU)\n  int command_buffer_id;\n  if (!Send(new PluginMsg_CreateCommandBuffer(instance_id_,\n                                              &command_buffer_id))) {\n    return NULL;\n  }\n\n  return new CommandBufferProxy(channel_host_, command_buffer_id);\n#else\n  return NULL;\n#endif  // ENABLE_GPU\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 79
    },
    {
        "index": 105227,
        "code": "void HTMLElement::adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child)\n{\n    ASSERT(selfOrAncestorHasDirAutoAttribute());\n    Node* strongDirectionalityTextNode;\n    TextDirection textDirection = directionality(&strongDirectionalityTextNode);\n    setHasDirAutoFlagRecursively(child, false);\n    if (renderer() && renderer()->style() && renderer()->style()->direction() != textDirection) {\n        Element* elementToAdjust = this;\n        for (; elementToAdjust; elementToAdjust = elementToAdjust->parentElement()) {\n            if (elementAffectsDirectionality(elementToAdjust)) {\n                elementToAdjust->setNeedsStyleRecalc();\n                return;\n            }\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2795",
        "length": 146
    },
    {
        "index": 48993,
        "code": "static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\t     const char *name,\n\t\t\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t\t\t     u32 *flags,\n\t\t\t\t\t\t     struct vif_params *params)\n{\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tbrcmf_dbg(TRACE, \"enter: %s type %d\\n\", name, type);\n\terr = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);\n\tif (err) {\n\t\tbrcmf_err(\"iface validation failed: err=%d\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tcase NL80211_IFTYPE_AP:\n\t\twdev = brcmf_ap_add_vif(wiphy, name, flags, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\twdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, flags, params);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (IS_ERR(wdev))\n\t\tbrcmf_err(\"add iface %s type %d failed: err=%d\\n\",\n\t\t\t  name, type, (int)PTR_ERR(wdev));\n\telse\n\t\tbrcmf_cfg80211_update_proto_addr_mode(wdev);\n\n\treturn wdev;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-8658",
        "length": 384
    },
    {
        "index": 125203,
        "code": "void RenderMessageFilter::OnDownloadUrl(const IPC::Message& message,\n                                        const GURL& url,\n                                        const Referrer& referrer,\n                                        const string16& suggested_name) {\n  scoped_ptr<DownloadSaveInfo> save_info(new DownloadSaveInfo());\n  save_info->suggested_name = suggested_name;\n  scoped_ptr<net::URLRequest> request(\n      resource_context_->GetRequestContext()->CreateRequest(url, NULL));\n  request->set_referrer(referrer.url.spec());\n  webkit_glue::ConfigureURLRequestForReferrerPolicy(\n      request.get(), referrer.policy);\n  RecordDownloadSource(INITIATED_BY_RENDERER);\n  resource_dispatcher_host_->BeginDownload(\n      request.Pass(),\n      true,  // is_content_initiated\n      resource_context_,\n      render_process_id_,\n      message.routing_id(),\n      false,\n      save_info.Pass(),\n      content::DownloadId::Invalid(),\n      ResourceDispatcherHostImpl::DownloadStartedCallback());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-0910",
        "length": 195
    },
    {
        "index": 83522,
        "code": "BOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->width = width;\n\tcontext->height = height;\n\treturn TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-8788",
        "length": 45
    },
    {
        "index": 153946,
        "code": "void GLES2DecoderImpl::DoBeginSharedImageAccessDirectCHROMIUM(GLuint client_id,\n                                                              GLenum mode) {\n  TextureRef* texture_ref = GetTexture(client_id);\n  if (!texture_ref) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"DoBeginSharedImageAccessCHROMIUM\",\n                       \"invalid texture id\");\n    return;\n  }\n\n  SharedImageRepresentationGLTexture* shared_image =\n      texture_ref->shared_image();\n  if (!shared_image) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"DoBeginSharedImageAccessCHROMIUM\",\n                       \"bound texture is not a shared image\");\n    return;\n  }\n\n  if (!shared_image->BeginAccess(mode)) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION, \"DoBeginSharedImageAccessCHROMIUM\",\n                       \"Unable to begin access\");\n    return;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 180
    },
    {
        "index": 174478,
        "code": " virtual status_t setPropertyString(String8 const &name, String8 const &value) const {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n\n        data.writeString8(name);\n        data.writeString8(value);\n status_t status = remote()->transact(SET_PROPERTY_STRING, data, &reply);\n if (status != OK) {\n return status;\n }\n\n return reply.readInt32();\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-2419",
        "length": 85
    },
    {
        "index": 118081,
        "code": "bool IsValidGaiaSigninRedirectOrResponseURL(const GURL& url) {\n  std::string hostname = url.host();\n  if (google_util::IsGoogleHostname(hostname, google_util::ALLOW_SUBDOMAIN)) {\n    return gaia::IsGaiaSignonRealm(url.GetOrigin()) ||\n        StartsWithASCII(hostname, \"accounts.\", false);\n  }\n\n  GURL origin = url.GetOrigin();\n  if (origin == GURL(\"https://accounts.youtube.com\") ||\n      origin == GURL(\"https://accounts.blogger.com\"))\n    return true;\n\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-6634",
        "length": 117
    },
    {
        "index": 52981,
        "code": "static int ui_open(struct inode *inode, struct file *filp)\n{\n\tstruct hfi1_devdata *dd;\n\n\tdd = container_of(inode->i_cdev, struct hfi1_devdata, ui_cdev);\n\tfilp->private_data = dd; /* for other methods */\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-4565",
        "length": 66
    },
    {
        "index": 56878,
        "code": "int iwch_resume_tid(struct iwch_ep *ep)\n{\n\tstruct cpl_set_tcb_field *req;\n\tstruct sk_buff *skb = get_skb(NULL, sizeof(*req), GFP_KERNEL);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\treq = (struct cpl_set_tcb_field *) skb_put(skb, sizeof(*req));\n\treq->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));\n\treq->wr.wr_lo = htonl(V_WR_TID(ep->hwtid));\n\tOPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, ep->hwtid));\n\treq->reply = 0;\n\treq->cpu_idx = 0;\n\treq->word = htons(W_TCB_RX_QUIESCE);\n\treq->mask = cpu_to_be64(1ULL << S_TCB_RX_QUIESCE);\n\treq->val = 0;\n\n\tskb->priority = CPL_PRIORITY_DATA;\n\treturn iwch_cxgb3_ofld_send(ep->com.tdev, skb);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8812",
        "length": 213
    },
    {
        "index": 108406,
        "code": "void AudioOutputController::Pause() {\n  DCHECK(message_loop_);\n  message_loop_->PostTask(\n      FROM_HERE,\n      NewRunnableMethod(this, &AudioOutputController::DoPause));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 40
    },
    {
        "index": 39411,
        "code": "static void raw_cmd_free(struct floppy_raw_cmd **ptr)\n{\n\tstruct floppy_raw_cmd *next;\n\tstruct floppy_raw_cmd *this;\n\n\tthis = *ptr;\n\t*ptr = NULL;\n\twhile (this) {\n\t\tif (this->buffer_length) {\n\t\t\tfd_dma_mem_free((unsigned long)this->kernel_data,\n\t\t\t\t\tthis->buffer_length);\n\t\t\tthis->buffer_length = 0;\n\t\t}\n\t\tnext = this->next;\n\t\tkfree(this);\n\t\tthis = next;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-1738",
        "length": 103
    },
    {
        "index": 37848,
        "code": "static void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3610",
        "length": 73
    },
    {
        "index": 136585,
        "code": "TestPaintArtifact& TestPaintArtifact::RectDrawing(const FloatRect& bounds,\n                                                  Color color) {\n  return RectDrawing(NewClient(), bounds, color);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 34
    },
    {
        "index": 70781,
        "code": "static void build_file_streams(void)\n{\n    FFServerStream *stream;\n    AVFormatContext *infile;\n    int i, ret;\n\n    /* gather all streams */\n    for(stream = config.first_stream; stream; stream = stream->next) {\n        infile = NULL;\n\n        if (stream->stream_type != STREAM_TYPE_LIVE || stream->feed)\n            continue;\n\n        /* the stream comes from a file */\n        /* try to open the file */\n        /* open stream */\n\n\n        /* specific case: if transport stream output to RTP,\n         * we use a raw transport stream reader */\n        if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\"))\n            av_dict_set(&stream->in_opts, \"mpeg2ts_compute_pcr\", \"1\", 0);\n\n        if (!stream->feed_filename[0]) {\n            http_log(\"Unspecified feed file for stream '%s'\\n\",\n                     stream->filename);\n            goto fail;\n        }\n\n        http_log(\"Opening feed file '%s' for stream '%s'\\n\",\n                 stream->feed_filename, stream->filename);\n\n        ret = avformat_open_input(&infile, stream->feed_filename,\n                                  stream->ifmt, &stream->in_opts);\n        if (ret < 0) {\n            http_log(\"Could not open '%s': %s\\n\", stream->feed_filename,\n                     av_err2str(ret));\n            /* remove stream (no need to spend more time on it) */\n        fail:\n            remove_stream(stream);\n        } else {\n            /* find all the AVStreams inside and reference them in\n             * 'stream' */\n            if (avformat_find_stream_info(infile, NULL) < 0) {\n                http_log(\"Could not find codec parameters from '%s'\\n\",\n                         stream->feed_filename);\n                avformat_close_input(&infile);\n                goto fail;\n            }\n\n            for(i=0;i<infile->nb_streams;i++)\n                add_av_stream1(stream, infile->streams[i]->codec, 1);\n\n            avformat_close_input(&infile);\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10192",
        "length": 431
    },
    {
        "index": 66871,
        "code": "void __init zone_sizes_init(void)\n{\n\tunsigned long max_zone_pfns[MAX_NR_ZONES];\n\n\tmemset(max_zone_pfns, 0, sizeof(max_zone_pfns));\n\n#ifdef CONFIG_ZONE_DMA\n\tmax_zone_pfns[ZONE_DMA]\t\t= min(MAX_DMA_PFN, max_low_pfn);\n#endif\n#ifdef CONFIG_ZONE_DMA32\n\tmax_zone_pfns[ZONE_DMA32]\t= min(MAX_DMA32_PFN, max_low_pfn);\n#endif\n\tmax_zone_pfns[ZONE_NORMAL]\t= max_low_pfn;\n#ifdef CONFIG_HIGHMEM\n\tmax_zone_pfns[ZONE_HIGHMEM]\t= max_pfn;\n#endif\n\n\tfree_area_init_nodes(max_zone_pfns);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-7889",
        "length": 143
    },
    {
        "index": 31702,
        "code": "SYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2141",
        "length": 24
    },
    {
        "index": 81731,
        "code": "void ff_mpv_common_defaults(MpegEncContext *s)\n{\n    s->y_dc_scale_table      =\n    s->c_dc_scale_table      = ff_mpeg1_dc_scale_table;\n    s->chroma_qscale_table   = ff_default_chroma_qscale_table;\n    s->progressive_frame     = 1;\n    s->progressive_sequence  = 1;\n    s->picture_structure     = PICT_FRAME;\n\n    s->coded_picture_number  = 0;\n    s->picture_number        = 0;\n\n    s->f_code                = 1;\n    s->b_code                = 1;\n\n    s->slice_context_count   = 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-12460",
        "length": 145
    },
    {
        "index": 87464,
        "code": "static void coin_copy(Coin* c1, const Coin* c2)\n{\n  c1->weight = c2->weight;\n  uivector_copy(&c1->symbols, &c2->symbols);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-772",
        "cve": "CVE-2019-17178",
        "length": 47
    },
    {
        "index": 32862,
        "code": "void __weak arch_release_task_struct(struct task_struct *tsk)\n{\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-1858",
        "length": 17
    },
    {
        "index": 81795,
        "code": "void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {\n    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {\n        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);\n        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);\n    } else {\n        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);\n        si->lp_ele = lpNext(si->lp,si->lp_ele);\n    }\n    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);\n    si->lp_ele = lpNext(si->lp,si->lp_ele);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-12453",
        "length": 176
    },
    {
        "index": 143022,
        "code": "void BaseAudioContext::ResolvePromisesForUnpause() {\n  DCHECK(IsAudioThread());\n  AssertGraphOwner();\n\n  if (!is_resolving_resume_promises_ && resume_resolvers_.size() > 0) {\n    is_resolving_resume_promises_ = true;\n    ScheduleMainThreadCleanup();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 66
    },
    {
        "index": 48734,
        "code": "void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason)\n{\n\tunsigned long flags;\n\n\tif (likely(atomic_read(&skb->users) == 1)) {\n\t\tsmp_rmb();\n\t\tatomic_set(&skb->users, 0);\n\t} else if (likely(!atomic_dec_and_test(&skb->users))) {\n\t\treturn;\n\t}\n\tget_kfree_skb_cb(skb)->reason = reason;\n\tlocal_irq_save(flags);\n\tskb->next = __this_cpu_read(softnet_data.completion_queue);\n\t__this_cpu_write(softnet_data.completion_queue, skb);\n\traise_softirq_irqoff(NET_TX_SOFTIRQ);\n\tlocal_irq_restore(flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2016-8666",
        "length": 145
    },
    {
        "index": 102182,
        "code": "void SyncManager::SaveChanges() {\n  data_->SaveChanges();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 16
    },
    {
        "index": 76591,
        "code": "void *ws_ses_privdata(nw_ses *ses)\n{\n    struct clt_info *info = ses->privdata;\n    return info->privdata;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-17570",
        "length": 37
    },
    {
        "index": 174848,
        "code": "status_t CameraService::getCameraCharacteristics(int cameraId,\n CameraMetadata* cameraInfo) {\n if (!cameraInfo) {\n        ALOGE(\"%s: cameraInfo is NULL\", __FUNCTION__);\n return BAD_VALUE;\n }\n\n if (!mModule) {\n        ALOGE(\"%s: camera hardware module doesn't exist\", __FUNCTION__);\n return -ENODEV;\n }\n\n if (mModule->common.module_api_version < CAMERA_MODULE_API_VERSION_2_0) {\n        ALOGE(\"%s: Only HAL module version V2 or higher supports static metadata\", __FUNCTION__);\n return BAD_VALUE;\n }\n\n if (cameraId < 0 || cameraId >= mNumberOfCameras) {\n        ALOGE(\"%s: Invalid camera id: %d\", __FUNCTION__, cameraId);\n return BAD_VALUE;\n }\n\n int facing;\n if (getDeviceVersion(cameraId, &facing) == CAMERA_DEVICE_API_VERSION_1_0) {\n        ALOGE(\"%s: HAL1 doesn't support static metadata yet\", __FUNCTION__);\n return BAD_VALUE;\n }\n\n if (getDeviceVersion(cameraId, &facing) <= CAMERA_DEVICE_API_VERSION_2_1) {\n        ALOGW(\"%s: HAL2.x doesn't support getCameraCharacteristics for now\", __FUNCTION__);\n return BAD_VALUE;\n }\n\n struct camera_info info;\n status_t ret = mModule->get_camera_info(cameraId, &info);\n *cameraInfo = info.static_camera_characteristics;\n\n return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0826",
        "length": 295
    },
    {
        "index": 140651,
        "code": "void OutOfProcessInstance::RotateClockwise() {\n  engine_->RotateClockwise();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-1302",
        "length": 20
    },
    {
        "index": 71132,
        "code": "int fchmod_and_fchown(int fd, mode_t mode, uid_t uid, gid_t gid) {\n        assert(fd >= 0);\n\n        /* Under the assumption that we are running privileged we\n         * first change the access mode and only then hand out\n         * ownership to avoid a window where access is too open. */\n\n        if (mode != MODE_INVALID)\n                if (fchmod(fd, mode) < 0)\n                        return -errno;\n\n        if (uid != UID_INVALID || gid != GID_INVALID)\n                if (fchown(fd, uid, gid) < 0)\n                        return -errno;\n\n        return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-10156",
        "length": 137
    },
    {
        "index": 142518,
        "code": "  void ProcessScrollNoBoundsCheck(ui::EventType type,\n                                  const gfx::Vector2dF& delta) {\n    ProcessScrollInternal(type, delta, false);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 37
    },
    {
        "index": 19268,
        "code": "static void nl_pid_hash_free(struct hlist_head *table, size_t size)\n{\n\tif (size <= PAGE_SIZE)\n\t\tkfree(table);\n\telse\n\t\tfree_pages((unsigned long)table, get_order(size));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2012-3520",
        "length": 46
    },
    {
        "index": 156562,
        "code": "ChildProcessSecurityPolicyImpl::~ChildProcessSecurityPolicyImpl() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-18345",
        "length": 15
    },
    {
        "index": 11787,
        "code": "partition_create_data_new (DBusGMethodInvocation *context,\n                           Device *device,\n                           guint64 offset,\n                           guint64 size,\n                           const char *fstype,\n                           char **fsoptions)\n{\n  CreatePartitionData *data;\n\n  data = g_new0 (CreatePartitionData, 1);\n  data->refcount = 1;\n\n  data->context = context;\n  data->device = g_object_ref (device);\n  data->offset = offset;\n  data->size = size;\n  data->fstype = g_strdup (fstype);\n  data->fsoptions = g_strdupv (fsoptions);\n\n  return data;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2010-1149",
        "length": 137
    },
    {
        "index": 23566,
        "code": " static int linear_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\n\t\t\tstruct bio_vec *biovec, int max_size)\n{\n\tstruct linear_c *lc = ti->private;\n\tstruct request_queue *q = bdev_get_queue(lc->dev->bdev);\n\n\tif (!q->merge_bvec_fn)\n\t\treturn max_size;\n\n\tbvm->bi_bdev = lc->dev->bdev;\n\tbvm->bi_sector = linear_map_sector(ti, bvm->bi_sector);\n\n\treturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4127",
        "length": 126
    },
    {
        "index": 15381,
        "code": "EC_PRE_COMP *EC_ec_pre_comp_dup(EC_PRE_COMP *pre)\n{\n    int i;\n    if (pre != NULL)\n        CRYPTO_UP_REF(&pre->references, &i, pre->lock);\n    return pre;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-320",
        "cve": "CVE-2018-0735",
        "length": 50
    },
    {
        "index": 78026,
        "code": "cmsBool DataFormatSection(cmsIT8* it8)\n{\n    int iField = 0;\n    TABLE* t = GetTable(it8);\n\n    InSymbol(it8);   // Eats \"BEGIN_DATA_FORMAT\"\n    CheckEOLN(it8);\n\n    while (it8->sy != SEND_DATA_FORMAT &&\n        it8->sy != SEOLN &&\n        it8->sy != SEOF &&\n        it8->sy != SSYNERROR)  {\n\n            if (it8->sy != SIDENT) {\n\n                return SynError(it8, \"Sample type expected\");\n            }\n\n            if (!SetDataFormat(it8, iField, it8->id)) return FALSE;\n            iField++;\n\n            InSymbol(it8);\n            SkipEOLN(it8);\n       }\n\n       SkipEOLN(it8);\n       Skip(it8, SEND_DATA_FORMAT);\n       SkipEOLN(it8);\n\n       if (iField != t ->nSamples) {\n           SynError(it8, \"Count mismatch. NUMBER_OF_FIELDS was %d, found %d\\n\", t ->nSamples, iField);\n\n\n       }\n\n       return TRUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-16435",
        "length": 239
    },
    {
        "index": 82142,
        "code": "mrb_undef_method(mrb_state *mrb, struct RClass *c, const char *name)\n{\n  undef_method(mrb, c, mrb_intern_cstr(mrb, name));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-12249",
        "length": 44
    },
    {
        "index": 63542,
        "code": "static int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct posix_msg_tree_node *leaf;\n\n\tp = &info->msg_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\n\n\t\tif (likely(leaf->priority == msg->m_type))\n\t\t\tgoto insert_msg;\n\t\telse if (msg->m_type < leaf->priority)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\tif (info->node_cache) {\n\t\tleaf = info->node_cache;\n\t\tinfo->node_cache = NULL;\n\t} else {\n\t\tleaf = kmalloc(sizeof(*leaf), GFP_ATOMIC);\n\t\tif (!leaf)\n\t\t\treturn -ENOMEM;\n\t\tINIT_LIST_HEAD(&leaf->msg_list);\n\t}\n\tleaf->priority = msg->m_type;\n\trb_link_node(&leaf->rb_node, parent, p);\n\trb_insert_color(&leaf->rb_node, &info->msg_tree);\ninsert_msg:\n\tinfo->attr.mq_curmsgs++;\n\tinfo->qsize += msg->m_ts;\n\tlist_add_tail(&msg->m_list, &leaf->msg_list);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-11176",
        "length": 278
    },
    {
        "index": 112509,
        "code": "void Document::pendingTasksTimerFired(Timer<Document>*)\n{\n    while (!m_pendingTasks.isEmpty()) {\n        OwnPtr<Task> task = m_pendingTasks[0].release();\n        m_pendingTasks.remove(0);\n        task->performTask(this);\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 57
    },
    {
        "index": 43087,
        "code": "static void vhost_scsi_evt_work(struct vhost_work *work)\n{\n\tstruct vhost_scsi *vs = container_of(work, struct vhost_scsi,\n\t\t\t\t\tvs_event_work);\n\tstruct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tstruct vhost_scsi_evt *evt;\n\tstruct llist_node *llnode;\n\n\tmutex_lock(&vq->mutex);\n\tllnode = llist_del_all(&vs->vs_event_list);\n\twhile (llnode) {\n\t\tevt = llist_entry(llnode, struct vhost_scsi_evt, list);\n\t\tllnode = llist_next(llnode);\n\t\tvhost_scsi_do_evt_work(vs, evt);\n\t\tvhost_scsi_free_evt(vs, evt);\n\t}\n\tmutex_unlock(&vq->mutex);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4036",
        "length": 175
    },
    {
        "index": 60734,
        "code": "dup_dh_params(const DH *src)\n{\n    const BIGNUM *oldp, *oldq, *oldg;\n    BIGNUM *p = NULL, *q = NULL, *g = NULL;\n    DH *dh;\n\n    DH_get0_pqg(src, &oldp, &oldq, &oldg);\n    p = BN_dup(oldp);\n    q = BN_dup(oldq);\n    g = BN_dup(oldg);\n    dh = DH_new();\n    if (p == NULL || q == NULL || g == NULL || dh == NULL) {\n        BN_free(p);\n        BN_free(q);\n        BN_free(g);\n        DH_free(dh);\n        return NULL;\n    }\n    DH_set0_pqg(dh, p, q, g);\n    return dh;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-15088",
        "length": 171
    },
    {
        "index": 123253,
        "code": "bool ShouldSendPinchGesture() {\n  static bool pinch_allowed =\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnableViewport) ||\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kEnablePinch);\n  return pinch_allowed;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 58
    },
    {
        "index": 55696,
        "code": "int __sched yield_to(struct task_struct *p, bool preempt)\n{\n\tstruct task_struct *curr = current;\n\tstruct rq *rq, *p_rq;\n\tunsigned long flags;\n\tint yielded = 0;\n\n\tlocal_irq_save(flags);\n\trq = this_rq();\n\nagain:\n\tp_rq = task_rq(p);\n\t/*\n\t * If we're the only runnable task on the rq and target rq also\n\t * has only one task, there's absolutely no point in yielding.\n\t */\n\tif (rq->nr_running == 1 && p_rq->nr_running == 1) {\n\t\tyielded = -ESRCH;\n\t\tgoto out_irq;\n\t}\n\n\tdouble_rq_lock(rq, p_rq);\n\tif (task_rq(p) != p_rq) {\n\t\tdouble_rq_unlock(rq, p_rq);\n\t\tgoto again;\n\t}\n\n\tif (!curr->sched_class->yield_to_task)\n\t\tgoto out_unlock;\n\n\tif (curr->sched_class != p->sched_class)\n\t\tgoto out_unlock;\n\n\tif (task_running(p_rq, p) || p->state)\n\t\tgoto out_unlock;\n\n\tyielded = curr->sched_class->yield_to_task(rq, p, preempt);\n\tif (yielded) {\n\t\tschedstat_inc(rq, yld_count);\n\t\t/*\n\t\t * Make p's CPU reschedule; pick_next_entity takes care of\n\t\t * fairness.\n\t\t */\n\t\tif (preempt && rq != p_rq)\n\t\t\tresched_curr(p_rq);\n\t}\n\nout_unlock:\n\tdouble_rq_unlock(rq, p_rq);\nout_irq:\n\tlocal_irq_restore(flags);\n\n\tif (yielded > 0)\n\t\tschedule();\n\n\treturn yielded;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1583",
        "length": 340
    },
    {
        "index": 86377,
        "code": "static void __init hugetlb_hstate_alloc_pages(struct hstate *h)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < h->max_huge_pages; ++i) {\n\t\tif (hstate_is_gigantic(h)) {\n\t\t\tif (!alloc_bootmem_huge_page(h))\n\t\t\t\tbreak;\n\t\t} else if (!alloc_fresh_huge_page(h,\n\t\t\t\t\t &node_states[N_MEMORY]))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\tif (i < h->max_huge_pages) {\n\t\tchar buf[32];\n\n\t\tstring_get_size(huge_page_size(h), 1, STRING_UNITS_2, buf, 32);\n\t\tpr_warn(\"HugeTLB: allocating %lu of page size %s failed.  Only allocated %lu hugepages.\\n\",\n\t\t\th->max_huge_pages, buf, i);\n\t\th->max_huge_pages = i;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-15128",
        "length": 196
    },
    {
        "index": 162161,
        "code": "void RenderProcessHostImpl::WidgetHidden() {\n  if (visible_widgets_ == 0)\n    return;\n\n  --visible_widgets_;\n  if (visible_widgets_ == 0) {\n    UpdateProcessPriority();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-6063",
        "length": 48
    },
    {
        "index": 127143,
        "code": "  void SendKeyToPopupAndWait(ui::KeyboardCode key) {\n    if (!external_delegate_) {\n      SendKeyToPageAndWait(key);\n      return;\n    }\n\n    content::NativeWebKeyboardEvent event;\n    event.windowsKeyCode = key;\n    test_delegate_.Reset();\n    external_delegate_->keyboard_listener()->HandleKeyPressEvent(event);\n    test_delegate_.Wait();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2012-5155",
        "length": 77
    },
    {
        "index": 153091,
        "code": "void PDFiumEngine::PrePaint() {\n  for (auto& paint : progressive_paints_)\n    paint.painted_ = false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5216",
        "length": 30
    },
    {
        "index": 154793,
        "code": "error::Error GLES2DecoderPassthroughImpl::DoSetDisjointValueSyncCHROMIUM(\n    DisjointValueSync* sync) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 45
    },
    {
        "index": 44548,
        "code": "static bool lxc_cgmanager_chmod(const char *controller,\n\t\tconst char *cgroup_path, const char *file, int mode)\n{\n\tif (cgmanager_chmod_sync(NULL, cgroup_manager, controller,\n\t\t\tcgroup_path, file, mode) != 0) {\n\t\tNihError *nerr;\n\t\tnerr = nih_error_get();\n\t\tERROR(\"call to cgmanager_chmod_sync failed: %s\", nerr->message);\n\t\tnih_free(nerr);\n\t\treturn false;\n\t}\n\treturn true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-59",
        "cve": "CVE-2015-1335",
        "length": 114
    },
    {
        "index": 87396,
        "code": "static enum bp_state update_schedule(enum bp_state state)\n{\n\tif (state == BP_WAIT)\n\t\treturn BP_WAIT;\n\n\tif (state == BP_ECANCELED)\n\t\treturn BP_ECANCELED;\n\n\tif (state == BP_DONE) {\n\t\tballoon_stats.schedule_delay = 1;\n\t\tballoon_stats.retry_count = 1;\n\t\treturn BP_DONE;\n\t}\n\n\t++balloon_stats.retry_count;\n\n\tif (balloon_stats.max_retry_count != RETRY_UNLIMITED &&\n\t\t\tballoon_stats.retry_count > balloon_stats.max_retry_count) {\n\t\tballoon_stats.schedule_delay = 1;\n\t\tballoon_stats.retry_count = 1;\n\t\treturn BP_ECANCELED;\n\t}\n\n\tballoon_stats.schedule_delay <<= 1;\n\n\tif (balloon_stats.schedule_delay > balloon_stats.max_schedule_delay)\n\t\tballoon_stats.schedule_delay = balloon_stats.max_schedule_delay;\n\n\treturn BP_EAGAIN;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-400",
        "cve": "CVE-2019-17351",
        "length": 188
    },
    {
        "index": 3797,
        "code": "_dbus_get_real_time (long *tv_sec,\n                     long *tv_usec)\n{\n  FILETIME ft;\n  dbus_uint64_t time64;\n\n  GetSystemTimeAsFileTime (&ft);\n\n  memcpy (&time64, &ft, sizeof (time64));\n\n  /* Convert from 100s of nanoseconds since 1601-01-01\n  * to Unix epoch. Yes, this is Y2038 unsafe.\n  */\n  time64 -= DBUS_INT64_CONSTANT (116444736000000000);\n  time64 /= 10;\n\n  if (tv_sec)\n    *tv_sec = time64 / 1000000;\n\n  if (tv_usec)\n    *tv_usec = time64 % 1000000;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2168",
        "length": 155
    },
    {
        "index": 5972,
        "code": "e1000e_fix_icr_asserted(E1000ECore *core)\n{\n    core->mac[ICR] &= ~E1000_ICR_ASSERTED;\n    if (core->mac[ICR]) {\n        core->mac[ICR] |= E1000_ICR_ASSERTED;\n    }\n\n    trace_e1000e_irq_fix_icr_asserted(core->mac[ICR]);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-9310",
        "length": 87
    },
    {
        "index": 127130,
        "code": "void SharedMemory::Unlock() {\n  DCHECK(lock_ != NULL);\n  ReleaseMutex(lock_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-5154",
        "length": 21
    },
    {
        "index": 176169,
        "code": "uint8_t* AMediaCodec_getInputBuffer(AMediaCodec *mData, size_t idx, size_t *out_size) {\n if (mData->mAsyncNotify != NULL) {\n        sp<MediaCodecBuffer> abuf;\n if (mData->mCodec->getInputBuffer(idx, &abuf) != 0) {\n return NULL;\n }\n\n if (out_size != NULL) {\n *out_size = abuf->capacity();\n }\n return abuf->data();\n }\n\n    android::Vector<android::sp<android::MediaCodecBuffer> > abufs;\n if (mData->mCodec->getInputBuffers(&abufs) == 0) {\n size_t n = abufs.size();\n if (idx >= n) {\n            ALOGE(\"buffer index %zu out of range\", idx);\n return NULL;\n }\n if (abufs[idx] == NULL) {\n            ALOGE(\"buffer index %zu is NULL\", idx);\n return NULL;\n }\n if (out_size != NULL) {\n *out_size = abufs[idx]->capacity();\n }\n return abufs[idx]->data();\n }\n    ALOGE(\"couldn't get input buffers\");\n return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2018-9491",
        "length": 243
    },
    {
        "index": 143650,
        "code": "void RenderWidgetHostImpl::Init() {\n  DCHECK(process_->HasConnection());\n\n  renderer_initialized_ = true;\n\n  if (view_) {\n    Send(new ViewMsg_SetSurfaceIdNamespace(routing_id_,\n                                           view_->GetSurfaceIdNamespace()));\n  }\n\n  SendScreenRects();\n  WasResized();\n\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidInit();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1647",
        "length": 80
    },
    {
        "index": 124508,
        "code": "void RenderBlock::checkPositionedObjectsNeedLayout()\n{\n    if (!gPositionedDescendantsMap)\n        return;\n\n    if (TrackedRendererListHashSet* positionedDescendantSet = positionedObjects()) {\n        TrackedRendererListHashSet::const_iterator end = positionedDescendantSet->end();\n        for (TrackedRendererListHashSet::const_iterator it = positionedDescendantSet->begin(); it != end; ++it) {\n            RenderBox* currBox = *it;\n            ASSERT(!currBox->needsLayout());\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0904",
        "length": 114
    },
    {
        "index": 50097,
        "code": "static CURLcode nss_cache_crl(SECItem *crl_der)\n{\n  CERTCertDBHandle *db = CERT_GetDefaultCertDB();\n  CERTSignedCrl *crl = SEC_FindCrlByDERCert(db, crl_der, 0);\n  if(crl) {\n    /* CRL already cached */\n    SEC_DestroyCrl(crl);\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    return CURLE_OK;\n  }\n\n  /* acquire lock before call of CERT_CacheCRL() and accessing nss_crl_list */\n  PR_Lock(nss_crllock);\n\n  /* store the CRL item so that we can free it in Curl_nss_cleanup() */\n  if(!Curl_llist_insert_next(nss_crl_list, nss_crl_list->tail, crl_der)) {\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    PR_Unlock(nss_crllock);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(SECSuccess != CERT_CacheCRL(db, crl_der)) {\n    /* unable to cache CRL */\n    PR_Unlock(nss_crllock);\n    return CURLE_SSL_CRL_BADFILE;\n  }\n\n  /* we need to clear session cache, so that the CRL could take effect */\n  SSL_ClearSessionCache();\n  PR_Unlock(nss_crllock);\n  return CURLE_OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2016-7141",
        "length": 298
    },
    {
        "index": 163603,
        "code": "htmlIsAutoClosed(htmlDocPtr doc, htmlNodePtr elem) {\n    htmlNodePtr child;\n\n    if (elem == NULL) return(1);\n    child = elem->children;\n    while (child != NULL) {\n\tif (htmlAutoCloseTag(doc, elem->name, child)) return(1);\n\tchild = child->next;\n    }\n    return(0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2017-5130",
        "length": 80
    },
    {
        "index": 165763,
        "code": "void SVGElement::AddToPropertyMap(SVGAnimatedPropertyBase* property) {\n  attribute_to_property_map_.Set(property->AttributeName(), property);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2019-5757",
        "length": 32
    },
    {
        "index": 73031,
        "code": "BGD_DECLARE(void) gdClearErrorMethod(void)\n{\n\tgd_error_method = gd_stderr_error;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-9317",
        "length": 23
    },
    {
        "index": 40198,
        "code": "void rawv6_exit(void)\n{\n\tinet6_unregister_protosw(&rawv6_protosw);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2013-7281",
        "length": 25
    },
    {
        "index": 140762,
        "code": "  void ExitCommandProcessingEarly() { commands_to_process_ = 0; }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 18
    },
    {
        "index": 128932,
        "code": "    void doWriteArrayBuffer(const ArrayBuffer& arrayBuffer)\n    {\n        uint32_t byteLength = arrayBuffer.byteLength();\n        doWriteUint32(byteLength);\n        append(static_cast<const uint8_t*>(arrayBuffer.data()), byteLength);\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3171",
        "length": 53
    },
    {
        "index": 53642,
        "code": "static void cdc_ncm_tx_timeout_start(struct cdc_ncm_ctx *ctx)\n{\n\t/* start timer, if not already started */\n\tif (!(hrtimer_active(&ctx->tx_timer) || atomic_read(&ctx->stop)))\n\t\thrtimer_start(&ctx->tx_timer,\n\t\t\t\tktime_set(0, ctx->timer_interval),\n\t\t\t\tHRTIMER_MODE_REL);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-3951",
        "length": 81
    },
    {
        "index": 109969,
        "code": "void AudioOutputDevice::PlayOnIOThread() {\n  DCHECK(message_loop()->BelongsToCurrentThread());\n  if (stream_id_ && is_started_)\n    ipc_->PlayStream(stream_id_);\n  else\n    play_on_start_ = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-5108",
        "length": 52
    },
    {
        "index": 123809,
        "code": "EntrySync* EntrySync::getParent() const\n{\n    String parentPath = DOMFilePath::getDirectory(fullPath());\n    return DirectoryEntrySync::create(m_fileSystem, parentPath);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0917",
        "length": 40
    },
    {
        "index": 182570,
        "code": " static int hns_gmac_get_sset_count(int stringset)\n {\n\tif (stringset == ETH_SS_STATS)\n \t\treturn ARRAY_SIZE(g_gmac_stats_string);\n \n \treturn 0;\n}\n",
        "line": "\tif (stringset == ETH_SS_STATS)\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2017-18222",
        "length": 42
    },
    {
        "index": 7926,
        "code": "static int emitjump(JF, int opcode)\n{\n\tint inst = F->codelen + 1;\n\temit(J, F, opcode);\n\temitraw(J, F, 0);\n\treturn inst;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-9294",
        "length": 44
    },
    {
        "index": 115025,
        "code": "void TestingAutomationProvider::SetAuth(int tab_handle,\n                                        const std::wstring& username,\n                                        const std::wstring& password,\n                                        IPC::Message* reply_message) {\n  if (tab_tracker_->ContainsHandle(tab_handle)) {\n    NavigationController* tab = tab_tracker_->GetResource(tab_handle);\n    LoginHandlerMap::iterator iter = login_handler_map_.find(tab);\n\n    if (iter != login_handler_map_.end()) {\n      LoginHandler* handler = iter->second;\n      new NavigationNotificationObserver(\n          tab, this, reply_message, 1, false, false);\n      handler->SetAuth(WideToUTF16Hack(username), WideToUTF16Hack(password));\n      return;\n    }\n  }\n\n  AutomationMsg_SetAuth::WriteReplyParams(\n      reply_message, AUTOMATION_MSG_NAVIGATION_AUTH_NEEDED);\n  Send(reply_message);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 178
    },
    {
        "index": 133187,
        "code": "  ~ScopedRedrawLock() {\n    if (!cancel_unlock_ && was_visible_ && ::IsWindow(hwnd_))\n      owner_->UnlockUpdates(force_);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 35
    },
    {
        "index": 69258,
        "code": "void ifbw_remove(IFBW *r) {\n\tif (ifbw == NULL)\n\t\treturn;\n\t\n\tif (ifbw == r) {\n\t\tifbw = ifbw->next;\n\t\treturn;\n\t}\n\t\n\tIFBW *ptr = ifbw->next;\n\tIFBW *prev = ifbw;\n\twhile (ptr) {\n\t\tif (ptr == r) {\n\t\t\tprev->next = ptr->next;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tprev = ptr;\n\t\tptr = ptr->next;\n\t}\t\n\t\n\treturn;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-5207",
        "length": 112
    },
    {
        "index": 98894,
        "code": "  virtual void OnClose(net::WebSocket* socket) {\n    events_.push_back(\n        WebSocketEvent(WebSocketEvent::EVENT_CLOSE, socket, std::string()));\n    if (onclose_)\n      onclose_->Run(&events_.back());\n    if (callback_)\n      callback_->Run(net::OK);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 66
    },
    {
        "index": 150437,
        "code": "bool NavigationControllerImpl::CanPruneAllButLastCommitted() {\n  if (last_committed_entry_index_ == -1)\n    return false;\n\n  if (pending_entry_index_ != -1)\n    return false;\n\n  if (transient_entry_index_ != -1)\n    return false;\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-5035",
        "length": 69
    },
    {
        "index": 62368,
        "code": "wb_dops(netdissect_options *ndo, const struct pkt_dop *dop,\n        uint32_t ss, uint32_t es)\n{\n\tconst struct dophdr *dh = (const struct dophdr *)((const u_char *)dop + sizeof(*dop));\n\n\tND_PRINT((ndo, \" <\"));\n\tfor ( ; ss <= es; ++ss) {\n\t\tint t;\n\n\t\tif (!ND_TTEST(*dh)) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\tbreak;\n\t\t}\n\t\tt = dh->dh_type;\n\n\t\tif (t > DT_MAXTYPE)\n\t\t\tND_PRINT((ndo, \" dop-%d!\", t));\n\t\telse {\n\t\t\tND_PRINT((ndo, \" %s\", dopstr[t]));\n\t\t\tif (t == DT_SKIP || t == DT_HOLE) {\n\t\t\t\tuint32_t ts = EXTRACT_32BITS(&dh->dh_ts);\n\t\t\t\tND_PRINT((ndo, \"%d\", ts - ss + 1));\n\t\t\t\tif (ss > ts || ts > es) {\n\t\t\t\t\tND_PRINT((ndo, \"[|]\"));\n\t\t\t\t\tif (ts < ss)\n\t\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tss = ts;\n\t\t\t}\n\t\t}\n\t\tdh = DOP_NEXT(dh);\n\t}\n\tND_PRINT((ndo, \" >\"));\n\treturn (0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13014",
        "length": 285
    },
    {
        "index": 21744,
        "code": "static int em_das(struct x86_emulate_ctxt *ctxt)\n{\n\tu8 al, old_al;\n\tbool af, cf, old_cf;\n\n\tcf = ctxt->eflags & X86_EFLAGS_CF;\n\tal = ctxt->dst.val;\n\n\told_al = al;\n\told_cf = cf;\n\tcf = false;\n\taf = ctxt->eflags & X86_EFLAGS_AF;\n\tif ((al & 0x0f) > 9 || af) {\n\t\tal -= 6;\n\t\tcf = old_cf | (al >= 250);\n\t\taf = true;\n\t} else {\n\t\taf = false;\n\t}\n\tif (old_al > 0x99 || old_cf) {\n\t\tal -= 0x60;\n\t\tcf = true;\n\t}\n\n\tctxt->dst.val = al;\n\t/* Set PF, ZF, SF */\n\tctxt->src.type = OP_IMM;\n\tctxt->src.val = 0;\n\tctxt->src.bytes = 1;\n\temulate_2op_SrcV(ctxt, \"or\");\n\tctxt->eflags &= ~(X86_EFLAGS_AF | X86_EFLAGS_CF);\n\tif (cf)\n\t\tctxt->eflags |= X86_EFLAGS_CF;\n\tif (af)\n\t\tctxt->eflags |= X86_EFLAGS_AF;\n\treturn X86EMUL_CONTINUE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-0045",
        "length": 281
    },
    {
        "index": 507,
        "code": "static void pdf_run_Tz(fz_context *ctx, pdf_processor *proc, float scale)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tgstate->text.scale = scale / 100;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-1000039",
        "length": 66
    },
    {
        "index": 25671,
        "code": "static void sparc_pmu_start(struct perf_event *event, int flags)\n{\n\tstruct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n\tint idx = active_event_index(cpuc, event);\n\n\tif (flags & PERF_EF_RELOAD) {\n\t\tWARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));\n\t\tsparc_perf_event_set_period(event, &event->hw, idx);\n\t}\n\n\tevent->hw.state = 0;\n\n\tsparc_pmu_enable_event(cpuc, &event->hw, idx);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 121
    },
    {
        "index": 47714,
        "code": "gsf_infile_tar_set_source (GsfInfileTar *tar, GsfInput *src)\n{\n\tif (src)\n\t\tsrc = gsf_input_proxy_new (src);\n\tif (tar->source)\n\t\tg_object_unref (tar->source);\n\ttar->source = src;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-9888",
        "length": 62
    },
    {
        "index": 179314,
        "code": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n \t\t}\n \t\t_iov = iov + ret;\n \t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n \t\t_iov->iov_base = (void __user *)(unsigned long)\n \t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n \t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n",
        "line": "\t\t_iov->iov_len = min((u64)len, size);\n",
        "label": 1,
        "cwe": null,
        "cve": "CVE-2013-0311",
        "length": 254
    },
    {
        "index": 85523,
        "code": "static int ocfs2_writepage(struct page *page, struct writeback_control *wbc)\n{\n\ttrace_ocfs2_writepage(\n\t\t(unsigned long long)OCFS2_I(page->mapping->host)->ip_blkno,\n\t\tpage->index);\n\n\treturn block_write_full_page(page, ocfs2_get_block, wbc);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-18224",
        "length": 71
    },
    {
        "index": 111560,
        "code": "static JSValueRef textZoomInCallback(JSContextRef context, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)\n{\n    notImplemented();\n    return JSValueMakeUndefined(context);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 56
    },
    {
        "index": 59905,
        "code": "static int uas_pre_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\t/* Block new requests */\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_block_requests(shost);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\tscsi_unblock_requests(shost);\n\t\treturn 1;\n\t}\n\n\tuas_free_streams(devinfo);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-16530",
        "length": 172
    },
    {
        "index": 77409,
        "code": "pick_fallback_dpid(void)\n{\n    struct eth_addr ea;\n    eth_addr_nicira_random(&ea);\n    return eth_addr_to_uint64(ea);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2018-17205",
        "length": 36
    },
    {
        "index": 165358,
        "code": "void CheckQuotaManagedDataDeletionStatus(size_t* deletion_task_count,\n                                         base::OnceClosure callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (*deletion_task_count == 0) {\n    delete deletion_task_count;\n    std::move(callback).Run();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2019-5797",
        "length": 65
    },
    {
        "index": 22495,
        "code": "unsigned long nr_iowait_cpu(int cpu)\n{\n\tstruct rq *this = cpu_rq(cpu);\n\treturn atomic_read(&this->nr_iowait);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4621",
        "length": 33
    },
    {
        "index": 120650,
        "code": "void Element::setSavedLayerScrollOffset(const IntSize& size)\n{\n    if (size.isZero() && !hasRareData())\n        return;\n    ensureElementRareData()->setSavedLayerScrollOffset(size);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2884",
        "length": 46
    },
    {
        "index": 14261,
        "code": "static void *php_libxml_streams_IO_open_write_wrapper(const char *filename)\n{\n\treturn php_libxml_streams_IO_open_wrapper(filename, \"wb\", 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8866",
        "length": 35
    },
    {
        "index": 55468,
        "code": "static struct rq *__migrate_task(struct rq *rq, struct task_struct *p, int dest_cpu)\n{\n\tif (unlikely(!cpu_active(dest_cpu)))\n\t\treturn rq;\n\n\t/* Affinity changed (again). */\n\tif (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))\n\t\treturn rq;\n\n\trq = move_queued_task(rq, p, dest_cpu);\n\n\treturn rq;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1583",
        "length": 85
    },
    {
        "index": 98228,
        "code": "  bool GetVarImpl(const char* variable_name, std::string* result) {\n#if defined(OS_POSIX)\n    const char* env_value = getenv(variable_name);\n    if (!env_value)\n      return false;\n    if (result)\n      *result = env_value;\n    return true;\n#elif defined(OS_WIN)\n    DWORD value_length = ::GetEnvironmentVariable(\n        UTF8ToWide(variable_name).c_str(), NULL, 0);\n    if (value_length == 0)\n      return false;\n    if (result) {\n      scoped_array<wchar_t> value(new wchar_t[value_length]);\n      ::GetEnvironmentVariable(UTF8ToWide(variable_name).c_str(), value.get(),\n                               value_length);\n      *result = WideToUTF8(value.get());\n    }\n    return true;\n#else\n#error need to port\n#endif\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 177
    },
    {
        "index": 38886,
        "code": "dist_ps(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLSEG\t   *lseg = PG_GETARG_LSEG_P(1);\n\n\tPG_RETURN_FLOAT8(dist_ps_internal(pt, lseg));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 52
    },
    {
        "index": 34415,
        "code": "static long btrfs_ioctl_ino_to_path(struct btrfs_root *root, void __user *arg)\n{\n\tint ret = 0;\n\tint i;\n\tu64 rel_ptr;\n\tint size;\n\tstruct btrfs_ioctl_ino_path_args *ipa = NULL;\n\tstruct inode_fs_paths *ipath = NULL;\n\tstruct btrfs_path *path;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tipa = memdup_user(arg, sizeof(*ipa));\n\tif (IS_ERR(ipa)) {\n\t\tret = PTR_ERR(ipa);\n\t\tipa = NULL;\n\t\tgoto out;\n\t}\n\n\tsize = min_t(u32, ipa->size, 4096);\n\tipath = init_ipath(size, root, path);\n\tif (IS_ERR(ipath)) {\n\t\tret = PTR_ERR(ipath);\n\t\tipath = NULL;\n\t\tgoto out;\n\t}\n\n\tret = paths_from_inode(ipa->inum, ipath);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < ipath->fspath->elem_cnt; ++i) {\n\t\trel_ptr = ipath->fspath->val[i] -\n\t\t\t  (u64)(unsigned long)ipath->fspath->val;\n\t\tipath->fspath->val[i] = rel_ptr;\n\t}\n\n\tret = copy_to_user((void *)(unsigned long)ipa->fspath,\n\t\t\t   (void *)(unsigned long)ipath->fspath, size);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\tbtrfs_free_path(path);\n\tfree_ipath(ipath);\n\tkfree(ipa);\n\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-310",
        "cve": "CVE-2012-5375",
        "length": 370
    },
    {
        "index": 61932,
        "code": "static int x509_get_ext_key_usage( unsigned char **p,\n                               const unsigned char *end,\n                               mbedtls_x509_sequence *ext_key_usage)\n{\n    int ret;\n\n    if( ( ret = mbedtls_asn1_get_sequence_of( p, end, ext_key_usage, MBEDTLS_ASN1_OID ) ) != 0 )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    /* Sequence length must be >= 1 */\n    if( ext_key_usage->buf.p == NULL )\n        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +\n                MBEDTLS_ERR_ASN1_INVALID_LENGTH );\n\n    return( 0 );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2017-14032",
        "length": 138
    },
    {
        "index": 77748,
        "code": "void dump_vma(const struct vm_area_struct *vma)\n{\n\tpr_emerg(\"vma %px start %px end %px\\n\"\n\t\t\"next %px prev %px mm %px\\n\"\n\t\t\"prot %lx anon_vma %px vm_ops %px\\n\"\n\t\t\"pgoff %lx file %px private_data %px\\n\"\n\t\t\"flags: %#lx(%pGv)\\n\",\n\t\tvma, (void *)vma->vm_start, (void *)vma->vm_end, vma->vm_next,\n\t\tvma->vm_prev, vma->vm_mm,\n\t\t(unsigned long)pgprot_val(vma->vm_page_prot),\n\t\tvma->anon_vma, vma->vm_ops, vma->vm_pgoff,\n\t\tvma->vm_file, vma->vm_private_data,\n\t\tvma->vm_flags, &vma->vm_flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-17182",
        "length": 198
    },
    {
        "index": 109575,
        "code": "void Document::attachRange(Range* range)\n{\n    ASSERT(!m_ranges.contains(range));\n    m_ranges.add(range);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5136",
        "length": 27
    },
    {
        "index": 77612,
        "code": "ofputil_format_version_bitmap__(struct ds *msg, uint32_t bitmap,\n                                void (*format_version)(struct ds *msg,\n                                                       enum ofp_version))\n{\n    while (bitmap) {\n        format_version(msg, raw_ctz(bitmap));\n        bitmap = zero_rightmost_1bit(bitmap);\n        if (bitmap) {\n            ds_put_cstr(msg, \", \");\n        }\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2018-17204",
        "length": 83
    },
    {
        "index": 89225,
        "code": "set_optimize_info_from_tree(Node* node, regex_t* reg, ScanEnv* scan_env)\n{\n  int r;\n  OptNode opt;\n  OptEnv env;\n\n  env.enc            = reg->enc;\n  env.options        = reg->options;\n  env.case_fold_flag = reg->case_fold_flag;\n  env.scan_env       = scan_env;\n  clear_mml(&env.mmd);\n\n  r = optimize_nodes(node, &opt, &env);\n  if (r != 0) return r;\n\n  reg->anchor = opt.anc.left & (ANCR_BEGIN_BUF |\n        ANCR_BEGIN_POSITION | ANCR_ANYCHAR_INF | ANCR_ANYCHAR_INF_ML |\n        ANCR_LOOK_BEHIND);\n\n  if ((opt.anc.left & (ANCR_LOOK_BEHIND | ANCR_PREC_READ_NOT)) != 0)\n    reg->anchor &= ~ANCR_ANYCHAR_INF_ML;\n\n  reg->anchor |= opt.anc.right & (ANCR_END_BUF | ANCR_SEMI_END_BUF |\n                                  ANCR_PREC_READ_NOT);\n\n  if (reg->anchor & (ANCR_END_BUF | ANCR_SEMI_END_BUF)) {\n    reg->anchor_dmin = opt.len.min;\n    reg->anchor_dmax = opt.len.max;\n  }\n\n  if (opt.sb.len > 0 || opt.sm.len > 0) {\n    select_opt_exact(reg->enc, &opt.sb, &opt.sm);\n    if (opt.map.value > 0 && comp_opt_exact_or_map(&opt.sb, &opt.map) > 0) {\n      goto set_map;\n    }\n    else {\n      r = set_optimize_exact(reg, &opt.sb);\n      set_sub_anchor(reg, &opt.sb.anc);\n    }\n  }\n  else if (opt.map.value > 0) {\n  set_map:\n    set_optimize_map(reg, &opt.map);\n    set_sub_anchor(reg, &opt.map.anc);\n  }\n  else {\n    reg->sub_anchor |= opt.anc.left & ANCR_BEGIN_LINE;\n    if (opt.len.max == 0)\n      reg->sub_anchor |= opt.anc.right & ANCR_END_LINE;\n  }\n\n#if defined(ONIG_DEBUG_COMPILE) || defined(ONIG_DEBUG_MATCH)\n  print_optimize_info(stderr, reg);\n#endif\n  return r;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-13225",
        "length": 491
    },
    {
        "index": 93283,
        "code": "static void tun_flow_delete(struct tun_struct *tun, struct tun_flow_entry *e)\n{\n\ttun_debug(KERN_INFO, tun, \"delete flow: hash %u index %u\\n\",\n\t\t  e->rxhash, e->queue_index);\n\thlist_del_rcu(&e->hash_link);\n\tkfree_rcu(e, rcu);\n\t--tun->flow_count;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-7191",
        "length": 80
    },
    {
        "index": 132430,
        "code": "const UsbConfigDescriptor* UsbDeviceImpl::GetConfiguration() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return configuration_.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1703",
        "length": 33
    },
    {
        "index": 122599,
        "code": "ExtensionFunctionDispatcher::Delegate::GetExtensionWindowController()\n    const {\n  return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0885",
        "length": 20
    },
    {
        "index": 116306,
        "code": "void QQuickWebViewExperimental::setFlickableViewportEnabled(bool enable)\n{\n    s_flickableViewportEnabled = enable;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3107",
        "length": 28
    },
    {
        "index": 75616,
        "code": "static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\n\tconst struct crypto_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > CRYPTO_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= CRYPTO_MSG_BASE;\n\tlink = &crypto_dispatch[type];\n\n\tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP))) {\n\t\tstruct crypto_alg *alg;\n\t\tu16 dump_alloc = 0;\n\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdown_read(&crypto_alg_sem);\n\t\tlist_for_each_entry(alg, &crypto_alg_list, cra_list)\n\t\t\tdump_alloc += CRYPTO_REPORT_MAXSIZE;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t\t.min_dump_alloc = dump_alloc,\n\t\t\t};\n\t\t\terr = netlink_dump_start(crypto_nlsk, skb, nlh, &c);\n\t\t}\n\t\tup_read(&crypto_alg_sem);\n\n\t\treturn err;\n\t}\n\n\terr = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,\n\t\t\t  crypto_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-19854",
        "length": 341
    },
    {
        "index": 59911,
        "code": "static void uas_shutdown(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (system_state != SYSTEM_RESTART)\n\t\treturn;\n\n\tdevinfo->shutdown = 1;\n\tuas_free_streams(devinfo);\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tusb_reset_device(udev);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-16530",
        "length": 132
    },
    {
        "index": 13059,
        "code": "_gcry_mpi_point_snatch_set (mpi_point_t point,\n                            gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z)\n{\n  if (!point)\n    point = mpi_point_new (0);\n\n  if (x)\n    mpi_snatch (point->x, x);\n  else\n    mpi_clear (point->x);\n  if (y)\n    mpi_snatch (point->y, y);\n  else\n    mpi_clear (point->y);\n  if (z)\n    mpi_snatch (point->z, z);\n  else\n    mpi_clear (point->z);\n\n  return point;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-0379",
        "length": 134
    },
    {
        "index": 28165,
        "code": "static void put_pixels_clamped4_c(const int16_t *block, uint8_t *av_restrict pixels,\n                                 int line_size)\n{\n    int i;\n\n    /* read the pixels */\n    for(i=0;i<4;i++) {\n        pixels[0] = av_clip_uint8(block[0]);\n        pixels[1] = av_clip_uint8(block[1]);\n        pixels[2] = av_clip_uint8(block[2]);\n        pixels[3] = av_clip_uint8(block[3]);\n\n        pixels += line_size;\n        block += 8;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-7010",
        "length": 122
    },
    {
        "index": 174458,
        "code": " virtual status_t getPropertyByteArray(String8 const &name, Vector<uint8_t> &value) const {\n Parcel data, reply;\n        data.writeInterfaceToken(IDrm::getInterfaceDescriptor());\n\n        data.writeString8(name);\n status_t status = remote()->transact(GET_PROPERTY_BYTE_ARRAY, data, &reply);\n if (status != OK) {\n return status;\n }\n\n        readVector(reply, value);\n return reply.readInt32();\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-2419",
        "length": 87
    },
    {
        "index": 23188,
        "code": "static struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,\n\t\tstruct nfs_open_context *ctx, struct nfs4_lock_state *lsp,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_lockdata *p;\n\tstruct inode *inode = lsp->ls_state->inode;\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->arg.fh = NFS_FH(inode);\n\tp->arg.fl = &p->fl;\n\tp->arg.open_seqid = nfs_alloc_seqid(&lsp->ls_state->owner->so_seqid, gfp_mask);\n\tif (p->arg.open_seqid == NULL)\n\t\tgoto out_free;\n\tp->arg.lock_seqid = nfs_alloc_seqid(&lsp->ls_seqid, gfp_mask);\n\tif (p->arg.lock_seqid == NULL)\n\t\tgoto out_free_seqid;\n\tp->arg.lock_stateid = &lsp->ls_stateid;\n\tp->arg.lock_owner.clientid = server->nfs_client->cl_clientid;\n\tp->arg.lock_owner.id = lsp->ls_id.id;\n\tp->arg.lock_owner.s_dev = server->s_dev;\n\tp->res.lock_seqid = p->arg.lock_seqid;\n\tp->lsp = lsp;\n\tp->server = server;\n\tatomic_inc(&lsp->ls_count);\n\tp->ctx = get_nfs_open_context(ctx);\n\tmemcpy(&p->fl, fl, sizeof(p->fl));\n\treturn p;\nout_free_seqid:\n\tnfs_free_seqid(p->arg.open_seqid);\nout_free:\n\tkfree(p);\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-4131",
        "length": 353
    },
    {
        "index": 183225,
        "code": " header_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n } /* header_put_byte */\n",
        "line": "{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7586",
        "length": 58
    },
    {
        "index": 112012,
        "code": "SyncTest::SyncTest(TestType test_type)\n    : test_type_(test_type),\n      server_type_(SERVER_TYPE_UNDECIDED),\n      num_clients_(-1),\n      use_verifier_(true),\n      notifications_enabled_(true),\n      test_server_handle_(base::kNullProcessHandle),\n      number_of_default_sync_items_(0) {\n  sync_datatype_helper::AssociateWithTest(this);\n  switch (test_type_) {\n    case SINGLE_CLIENT: {\n      num_clients_ = 1;\n      break;\n    }\n    case TWO_CLIENT: {\n      num_clients_ = 2;\n      break;\n    }\n    case MULTIPLE_CLIENT: {\n      num_clients_ = 3;\n      break;\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 151
    },
    {
        "index": 140712,
        "code": "  void CreateValuebuffer(GLuint client_id) {\n    return valuebuffer_manager()->CreateValuebuffer(client_id);\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 26
    },
    {
        "index": 77294,
        "code": "ofproto_aa_vlan_get_queue_size(struct ofproto *ofproto)\n{\n    if (!ofproto->ofproto_class->aa_vlan_get_queue_size) {\n        return EOPNOTSUPP;\n    }\n    return ofproto->ofproto_class->aa_vlan_get_queue_size(ofproto);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-617",
        "cve": "CVE-2018-17205",
        "length": 61
    },
    {
        "index": 42668,
        "code": "static int handle_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tstruct msr_data msr_info;\n\n\tmsr_info.index = ecx;\n\tmsr_info.host_initiated = false;\n\tif (vmx_get_msr(vcpu, &msr_info)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, msr_info.data);\n\n\t/* FIXME: handling of bits 32:63 of rax, rdx */\n\tvcpu->arch.regs[VCPU_REGS_RAX] = msr_info.data & -1u;\n\tvcpu->arch.regs[VCPU_REGS_RDX] = (msr_info.data >> 32) & -1u;\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2015-5307",
        "length": 199
    },
    {
        "index": 38176,
        "code": "setmodir(argv)\n    char **argv;\n{\n    if(*argv == NULL)\n\treturn 0;\n    if(!strcmp(*argv,\"in\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_IN;\n    } else if (!strcmp(*argv,\"out\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_OUT;\n    } else if (!strcmp(*argv,\"max\")) {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_MAXOVERAL;\n    } else {\n        maxoctets_dir = PPP_OCTETS_DIRECTION_SUM;\n    }\n    return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3158",
        "length": 123
    },
    {
        "index": 119504,
        "code": "    TestAccessInitialDocumentWebFrameClient() : m_didAccessInitialDocument(false)\n    {\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2908",
        "length": 23
    },
    {
        "index": 87493,
        "code": "static unsigned hash_init(Hash* hash, unsigned windowsize)\n{\n  unsigned i;\n  hash->head = (int*)calloc(sizeof(int), HASH_NUM_VALUES);\n  hash->val = (int*)calloc(sizeof(int), windowsize);\n  hash->chain = (unsigned short*)calloc(sizeof(unsigned short), windowsize);\n\n  hash->zeros = (unsigned short*)calloc(sizeof(unsigned short), windowsize);\n  hash->headz = (int*)calloc(sizeof(int), (MAX_SUPPORTED_DEFLATE_LENGTH + 1));\n  hash->chainz = (unsigned short*)calloc(sizeof(unsigned short), windowsize);\n\n  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros)\n  {\n    return 83; /*alloc fail*/\n  }\n\n  /*initialize hash table*/\n  for(i = 0; i < HASH_NUM_VALUES; i++) hash->head[i] = -1;\n  for(i = 0; i < windowsize; i++) hash->val[i] = -1;\n  for(i = 0; i < windowsize; i++) hash->chain[i] = i; /*same value as index indicates uninitialized*/\n\n  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; i++) hash->headz[i] = -1;\n  for(i = 0; i < windowsize; i++) hash->chainz[i] = i; /*same value as index indicates uninitialized*/\n\n  return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-772",
        "cve": "CVE-2019-17178",
        "length": 322
    },
    {
        "index": 79943,
        "code": "__xfs_inode_clear_blocks_tag(\n\txfs_inode_t\t*ip,\n\tvoid\t\t(*clear_tp)(struct xfs_mount *mp, xfs_agnumber_t agno,\n\t\t\t\t    int error, unsigned long caller_ip),\n\tint\t\ttag)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~xfs_iflag_for_tag(tag);\n\tspin_unlock(&ip->i_flags_lock);\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino), tag);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, tag)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     tag);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\tclear_tp(ip->i_mount, pag->pag_agno, -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-13093",
        "length": 320
    },
    {
        "index": 128898,
        "code": "    uint8_t* byteAt(int position)\n    {\n        return reinterpret_cast<uint8_t*>(m_buffer.data()) + position;\n    }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3171",
        "length": 30
    },
    {
        "index": 148139,
        "code": "static void VoidMethodPromiseArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  if (UNLIKELY(info.Length() < 1)) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"voidMethodPromiseArg\", \"TestObject\", ExceptionMessages::NotEnoughArguments(1, info.Length())));\n    return;\n  }\n\n  ScriptPromise promise_arg;\n  promise_arg = ScriptPromise::Cast(ScriptState::Current(info.GetIsolate()), info[0]);\n  if (!promise_arg.IsUndefinedOrNull() && !promise_arg.IsObject()) {\n    V8ThrowException::ThrowTypeError(info.GetIsolate(), ExceptionMessages::FailedToExecute(\"voidMethodPromiseArg\", \"TestObject\", \"parameter 1 ('promiseArg') is not an object.\"));\n    return;\n  }\n\n  impl->voidMethodPromiseArg(promise_arg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 203
    },
    {
        "index": 145595,
        "code": "bool ParseChallengeMessage(\n    base::span<const uint8_t> challenge_message,\n    NegotiateFlags* challenge_flags,\n    base::span<uint8_t, kChallengeLen> server_challenge) {\n  NtlmBufferReader challenge_reader(challenge_message);\n\n  return challenge_reader.MatchMessageHeader(MessageType::kChallenge) &&\n         challenge_reader.SkipSecurityBufferWithValidation() &&\n         challenge_reader.ReadFlags(challenge_flags) &&\n         challenge_reader.ReadBytes(server_challenge);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-22",
        "cve": "CVE-2016-1671",
        "length": 97
    },
    {
        "index": 126727,
        "code": "void BrowserView::Copy() {\n  if (!DoCutCopyPaste(&content::RenderWidgetHost::Copy)) {\n    ui_controls::SendKeyPress(GetNativeWindow(), ui::VKEY_C,\n                              true, false, false, false);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 53
    },
    {
        "index": 22478,
        "code": "static int __init isolated_cpu_setup(char *str)\n{\n\talloc_bootmem_cpumask_var(&cpu_isolated_map);\n\tcpulist_parse(str, cpu_isolated_map);\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4621",
        "length": 42
    },
    {
        "index": 106425,
        "code": "void BlobURLRequestJob::Seek(int64 offset) {\n  for (item_index_ = 0;\n       item_index_ < blob_data_->items().size() &&\n           offset >= item_length_list_[item_index_];\n       ++item_index_) {\n    offset -= item_length_list_[item_index_];\n  }\n\n  current_item_offset_ = offset;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 74
    },
    {
        "index": 95639,
        "code": "void CL_BeginDownload( const char *localName, const char *remoteName ) {\n\n\tCom_DPrintf( \"***** CL_BeginDownload *****\\n\"\n\t\t\t\t \"Localname: %s\\n\"\n\t\t\t\t \"Remotename: %s\\n\"\n\t\t\t\t \"****************************\\n\", localName, remoteName );\n\n\tQ_strncpyz( clc.downloadName, localName, sizeof( clc.downloadName ) );\n\tCom_sprintf( clc.downloadTempName, sizeof( clc.downloadTempName ), \"%s.tmp\", localName );\n\n\tCvar_Set( \"cl_downloadName\", remoteName );\n\tCvar_Set( \"cl_downloadSize\", \"0\" );\n\tCvar_Set( \"cl_downloadCount\", \"0\" );\n\tCvar_SetValue( \"cl_downloadTime\", cls.realtime );\n\n\tclc.downloadBlock = 0; // Starting new file\n\tclc.downloadCount = 0;\n\n\tCL_AddReliableCommand( va( \"download %s\", remoteName ), qfalse );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-269",
        "cve": "CVE-2017-6903",
        "length": 205
    },
    {
        "index": 95191,
        "code": "static void cmd_xstats(char *tag, int c)\n{\n    int metric;\n\n    if (backend_current) {\n        /* remote mailbox */\n        const char *cmd = \"Xstats\";\n\n        prot_printf(backend_current->out, \"%s %s \", tag, cmd);\n        if (!pipe_command(backend_current, 65536)) {\n            pipe_including_tag(backend_current, tag, 0);\n        }\n        return;\n    }\n\n    if (c == EOF) {\n        prot_printf(imapd_out, \"%s BAD Syntax error in Xstats arguments\\r\\n\", tag);\n        goto error;\n    }\n    if (c == '\\r') c = prot_getc(imapd_in);\n    if (c != '\\n') {\n        prot_printf(imapd_out,\n                    \"%s BAD Unexpected extra arguments to Xstats\\r\\n\", tag);\n        goto error;\n    }\n\n    prot_printf(imapd_out, \"* XSTATS\");\n    for (metric = 0 ; metric < XSTATS_NUM_METRICS ; metric++)\n        prot_printf(imapd_out, \" %s %u\", xstats_names[metric], xstats[metric]);\n    prot_printf(imapd_out, \"\\r\\n\");\n\n    prot_printf(imapd_out, \"%s OK %s\\r\\n\", tag,\n                error_message(IMAP_OK_COMPLETED));\n    return;\n\nerror:\n    eatline(imapd_in, (c == EOF ? ' ' : c));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-12843",
        "length": 304
    },
    {
        "index": 145232,
        "code": "void Dispatcher::OnDispatchOnConnect(\n    int target_port_id,\n    const std::string& channel_name,\n    const ExtensionMsg_TabConnectionInfo& source,\n    const ExtensionMsg_ExternalConnectionInfo& info,\n    const std::string& tls_channel_id) {\n  DCHECK(!ContainsKey(port_to_tab_id_map_, target_port_id));\n  DCHECK_EQ(1, target_port_id % 2);  // target renderer ports have odd IDs.\n  int sender_tab_id = -1;\n  source.tab.GetInteger(\"id\", &sender_tab_id);\n  port_to_tab_id_map_[target_port_id] = sender_tab_id;\n\n  MessagingBindings::DispatchOnConnect(*script_context_set_, target_port_id,\n                                       channel_name, source, info,\n                                       tls_channel_id,\n                                       NULL);  // All render frames.\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-1696",
        "length": 170
    },
    {
        "index": 40552,
        "code": "static void netlink_ring_set_copied(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_ring *ring = &nlk->rx_ring;\n\tstruct nl_mmap_hdr *hdr;\n\n\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\thdr = netlink_current_frame(ring, NL_MMAP_STATUS_UNUSED);\n\tif (hdr == NULL) {\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\tkfree_skb(skb);\n\t\tnetlink_overrun(sk);\n\t\treturn;\n\t}\n\tnetlink_increment_head(ring);\n\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\n\thdr->nm_len\t= skb->len;\n\thdr->nm_group\t= NETLINK_CB(skb).dst_group;\n\thdr->nm_pid\t= NETLINK_CB(skb).creds.pid;\n\thdr->nm_uid\t= from_kuid(sk_user_ns(sk), NETLINK_CB(skb).creds.uid);\n\thdr->nm_gid\t= from_kgid(sk_user_ns(sk), NETLINK_CB(skb).creds.gid);\n\tnetlink_set_status(hdr, NL_MMAP_STATUS_COPY);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-7271",
        "length": 253
    },
    {
        "index": 129680,
        "code": "bool ResourceFetcher::canAccessRedirect(Resource* resource, ResourceRequest& request, const ResourceResponse& redirectResponse, ResourceLoaderOptions& options)\n{\n    if (!canRequest(resource->type(), request.url(), options, false, FetchRequest::UseDefaultOriginRestrictionForType))\n        return false;\n    if (options.corsEnabled == IsCORSEnabled) {\n        SecurityOrigin* sourceOrigin = options.securityOrigin.get();\n        if (!sourceOrigin && document())\n            sourceOrigin = document()->securityOrigin();\n\n        String errorMessage;\n        if (!CrossOriginAccessControl::handleRedirect(resource, sourceOrigin, request, redirectResponse, options, errorMessage)) {\n            if (frame() && frame()->document())\n                frame()->document()->addConsoleMessage(JSMessageSource, ErrorMessageLevel, errorMessage);\n            return false;\n        }\n    }\n    if (resource->type() == Resource::Image && shouldDeferImageLoad(request.url()))\n        return false;\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-3160",
        "length": 199
    },
    {
        "index": 144417,
        "code": "int ExtensionInstallDialogView::GetDefaultDialogButton() const {\n  return ui::DIALOG_BUTTON_CANCEL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2016-1640",
        "length": 24
    },
    {
        "index": 114593,
        "code": "bool RenderThreadImpl::OnControlMessageReceived(const IPC::Message& msg) {\n  ObserverListBase<RenderProcessObserver>::Iterator it(observers_);\n  RenderProcessObserver* observer;\n  while ((observer = it.GetNext()) != NULL) {\n    if (observer->OnControlMessageReceived(msg))\n      return true;\n  }\n\n  if (appcache_dispatcher_->OnMessageReceived(msg))\n    return true;\n\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(RenderThreadImpl, msg)\n    IPC_MESSAGE_HANDLER(ViewMsg_SetZoomLevelForCurrentURL,\n                        OnSetZoomLevelForCurrentURL)\n    IPC_MESSAGE_HANDLER(ViewMsg_SetCSSColors, OnSetCSSColors)\n    IPC_MESSAGE_HANDLER(ViewMsg_New, OnCreateNewView)\n    IPC_MESSAGE_HANDLER(ViewMsg_PurgePluginListCache, OnPurgePluginListCache)\n    IPC_MESSAGE_HANDLER(ViewMsg_NetworkStateChanged, OnNetworkStateChanged)\n    IPC_MESSAGE_HANDLER(DOMStorageMsg_Event, OnDOMStorageEvent)\n    IPC_MESSAGE_HANDLER(ViewMsg_TempCrashWithData, OnTempCrashWithData)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  return handled;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 240
    },
    {
        "index": 98333,
        "code": "void FrameLoaderClient::frameLoaderDestroyed()\n{\n    webkit_web_frame_core_frame_gone(m_frame);\n    g_object_unref(m_frame);\n    m_frame = 0;\n    delete this;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 42
    },
    {
        "index": 165133,
        "code": "void HTMLFormElement::DidAssociateByParser() {\n  if (!did_finish_parsing_children_)\n    return;\n  has_elements_associated_by_parser_ = true;\n  UseCounter::Count(GetDocument(), WebFeature::kFormAssociationByParser);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-5790",
        "length": 53
    },
    {
        "index": 19543,
        "code": "static int udf_sb_alloc_partition_maps(struct super_block *sb, u32 count)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\n\tsbi->s_partmaps = kcalloc(count, sizeof(struct udf_part_map),\n\t\t\t\t  GFP_KERNEL);\n\tif (!sbi->s_partmaps) {\n\t\tudf_err(sb, \"Unable to allocate space for %d partition maps\\n\",\n\t\t\tcount);\n\t\tsbi->s_partitions = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->s_partitions = count;\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2012-3400",
        "length": 118
    },
    {
        "index": 37644,
        "code": "static inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12,\n\tstruct kvm_vcpu *vcpu)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 47
    },
    {
        "index": 134855,
        "code": "  float scale() const { return kScale; }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 12
    },
    {
        "index": 27417,
        "code": "static void ip6_tnl_link_config(struct ip6_tnl *t)\n{\n\tstruct net_device *dev = t->dev;\n\tstruct ip6_tnl_parm *p = &t->parms;\n\tstruct flowi *fl = &t->fl;\n\n\tmemcpy(dev->dev_addr, &p->laddr, sizeof(struct in6_addr));\n\tmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\n\n\t/* Set up flowi template */\n\tipv6_addr_copy(&fl->fl6_src, &p->laddr);\n\tipv6_addr_copy(&fl->fl6_dst, &p->raddr);\n\tfl->oif = p->link;\n\tfl->fl6_flowlabel = 0;\n\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl->fl6_flowlabel |= IPV6_TCLASS_MASK & p->flowinfo;\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl->fl6_flowlabel |= IPV6_FLOWLABEL_MASK & p->flowinfo;\n\n\tip6_tnl_set_cap(t);\n\n\tif (p->flags&IP6_TNL_F_CAP_XMIT && p->flags&IP6_TNL_F_CAP_RCV)\n\t\tdev->flags |= IFF_POINTOPOINT;\n\telse\n\t\tdev->flags &= ~IFF_POINTOPOINT;\n\n\tdev->iflink = p->link;\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tint strict = (ipv6_addr_type(&p->raddr) &\n\t\t\t      (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL));\n\n\t\tstruct rt6_info *rt = rt6_lookup(dev_net(dev),\n\t\t\t\t\t\t &p->raddr, &p->laddr,\n\t\t\t\t\t\t p->link, strict);\n\n\t\tif (rt == NULL)\n\t\t\treturn;\n\n\t\tif (rt->rt6i_dev) {\n\t\t\tdev->hard_header_len = rt->rt6i_dev->hard_header_len +\n\t\t\t\tsizeof (struct ipv6hdr);\n\n\t\t\tdev->mtu = rt->rt6i_dev->mtu - sizeof (struct ipv6hdr);\n\n\t\t\tif (dev->mtu < IPV6_MIN_MTU)\n\t\t\t\tdev->mtu = IPV6_MIN_MTU;\n\t\t}\n\t\tdst_release(&rt->u.dst);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2011-1768",
        "length": 490
    },
    {
        "index": 57225,
        "code": "static void nfs4_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)\n{\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs_removeargs *args = msg->rpc_argp;\n\tstruct nfs_removeres *res = msg->rpc_resp;\n\n\tres->server = server;\n\tmsg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_REMOVE];\n\tnfs4_init_sequence(&args->seq_args, &res->seq_res, 1);\n\n\tnfs_fattr_init(res->dir_attr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8746",
        "length": 114
    },
    {
        "index": 43313,
        "code": "void CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, jidx, c, i, j, row=0, col=0;\n  struct jhead jh;\n  int min=INT_MAX;\n  ushort *rp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = jh.wide * jh.clrs;\n\n  for (jrow=0; jrow < jh.high; jrow++) {\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow/2 : jrow/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = *rp++;\n      if (jh.bits <= 12)\n\tval = curve[val & 0xfff];\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx / (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx / cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if ((unsigned) (row-top_margin) < height) {\n\tc = FC(row-top_margin,col-left_margin);\n\tif ((unsigned) (col-left_margin) < width) {\n\t  BAYER(row-top_margin,col-left_margin) = val;\n\t  if (min > val) min = val;\n\t} else if (col > 1 && (unsigned) (col-left_margin+2) >\n\t\t    (unsigned) (width+3))\n\t  cblack[c] += (cblack[4+c]++,val);\n      }\n      if (++col >= raw_width)\n\tcol = (row++,0);\n    }\n  }\n  ljpeg_end (&jh);\n  FORC4 if (cblack[4+c]) cblack[c] /= cblack[4+c];\n  if (!strcasecmp(make,\"KODAK\"))\n    black = min;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2015-3885",
        "length": 503
    },
    {
        "index": 171108,
        "code": "int get_camera_metadata_ro_entry(const camera_metadata_t *src,\n size_t index,\n camera_metadata_ro_entry_t *entry) {\n return get_camera_metadata_entry((camera_metadata_t*)src, index,\n (camera_metadata_entry_t*)entry);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-3916",
        "length": 50
    },
    {
        "index": 172341,
        "code": "OMX_ERRORTYPE omx_video::fill_buffer_done(OMX_HANDLETYPE hComp,\n        OMX_BUFFERHEADERTYPE * buffer)\n{\n#ifdef _MSM8974_\n int index = buffer - m_out_mem_ptr;\n#endif\n    DEBUG_PRINT_LOW(\"fill_buffer_done: buffer->pBuffer[%p], flags=0x%x size = %u\",\n            buffer->pBuffer, (unsigned)buffer->nFlags, (unsigned int)buffer->nFilledLen);\n if (buffer == NULL || ((buffer - m_out_mem_ptr) > (int)m_sOutPortDef.nBufferCountActual)) {\n return OMX_ErrorBadParameter;\n }\n\n    pending_output_buffers--;\n\n if(!secure_session) {\n    extra_data_handle.create_extra_data(buffer);\n#ifndef _MSM8974_\n if (buffer->nFlags & OMX_BUFFERFLAG_EXTRADATA) {\n        DEBUG_PRINT_LOW(\"parsing extradata\");\n        extra_data_handle.parse_extra_data(buffer);\n }\n#endif\n }\n\n /* For use buffer we need to copy the data */\n if (m_pCallbacks.FillBufferDone) {\n if (buffer->nFilledLen > 0) {\n            m_fbd_count++;\n\n if (dev_get_output_log_flag()) {\n                dev_output_log_buffers((const char*)buffer->pBuffer, buffer->nFilledLen);\n }\n }\n#ifdef _MSM8974_\n if (buffer->nFlags & OMX_BUFFERFLAG_EXTRADATA) {\n if (!dev_handle_extradata((void *)buffer, index))\n                DEBUG_PRINT_ERROR(\"Failed to parse extradata\");\n\n            dev_extradata_log_buffers((char *)(((unsigned long)buffer->pBuffer + buffer->nOffset +\n                        buffer->nFilledLen + 3) & (~3)));\n }\n#endif\n        m_pCallbacks.FillBufferDone (hComp,m_app_data,buffer);\n } else {\n return OMX_ErrorBadParameter;\n }\n return OMX_ErrorNone;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-3835",
        "length": 390
    },
    {
        "index": 110444,
        "code": "void GLES2DecoderImpl::DeleteQueriesEXTHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    QueryManager::Query* query = query_manager_->GetQuery(client_ids[ii]);\n    if (query && !query->IsDeleted()) {\n      if (query == current_query_) {\n        current_query_ = NULL;\n      }\n      query->Destroy(true);\n      query_manager_->RemoveQuery(client_ids[ii]);\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2896",
        "length": 110
    },
    {
        "index": 33704,
        "code": "static int enable_single_step(struct task_struct *child)\n{\n\tstruct pt_regs *regs = task_pt_regs(child);\n\tunsigned long oflags;\n\n\t/*\n\t * If we stepped into a sysenter/syscall insn, it trapped in\n\t * kernel mode; do_debug() cleared TF and set TIF_SINGLESTEP.\n\t * If user-mode had set TF itself, then it's still clear from\n\t * do_debug() and we need to set it again to restore the user\n\t * state so we don't wrongly set TIF_FORCED_TF below.\n\t * If enable_single_step() was used last and that is what\n\t * set TIF_SINGLESTEP, then both TF and TIF_FORCED_TF are\n\t * already set and our bookkeeping is fine.\n\t */\n\tif (unlikely(test_tsk_thread_flag(child, TIF_SINGLESTEP)))\n\t\tregs->flags |= X86_EFLAGS_TF;\n\n\t/*\n\t * Always set TIF_SINGLESTEP - this guarantees that\n\t * we single-step system calls etc..  This will also\n\t * cause us to set TF when returning to user mode.\n\t */\n\tset_tsk_thread_flag(child, TIF_SINGLESTEP);\n\n\toflags = regs->flags;\n\n\t/* Set TF on the kernel stack.. */\n\tregs->flags |= X86_EFLAGS_TF;\n\n\t/*\n\t * ..but if TF is changed by the instruction we will trace,\n\t * don't mark it as being \"us\" that set it, so that we\n\t * won't clear it by hand later.\n\t *\n\t * Note that if we don't actually execute the popf because\n\t * of a signal arriving right now or suchlike, we will lose\n\t * track of the fact that it really was \"us\" that set it.\n\t */\n\tif (is_setting_trap_flag(child, regs)) {\n\t\tclear_tsk_thread_flag(child, TIF_FORCED_TF);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If TF was already set, check whether it was us who set it.\n\t * If not, we should never attempt a block step.\n\t */\n\tif (oflags & X86_EFLAGS_TF)\n\t\treturn test_tsk_thread_flag(child, TIF_FORCED_TF);\n\n\tset_tsk_thread_flag(child, TIF_FORCED_TF);\n\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2013-0871",
        "length": 489
    },
    {
        "index": 37534,
        "code": "static void mmu_pte_write_flush_tlb(struct kvm_vcpu *vcpu, bool zap_page,\n\t\t\t\t    bool remote_flush, bool local_flush)\n{\n\tif (zap_page)\n\t\treturn;\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_mmu_flush_tlb(vcpu);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 77
    },
    {
        "index": 185955,
        "code": "error::Error GLES2DecoderImpl::HandleGetUniformiv(uint32 immediate_data_size,\n                                                  const void* cmd_data) {\n  const gles2::cmds::GetUniformiv& c =\n      *static_cast<const gles2::cmds::GetUniformiv*>(cmd_data);\n  GLuint program = c.program;\n   GLint fake_location = c.location;\n   GLuint service_id;\n   GLenum result_type;\n   GLint real_location = -1;\n   Error error;\n   void* result;\n  if (GetUniformSetup(\n      program, fake_location, c.params_shm_id, c.params_shm_offset,\n      &error, &real_location, &service_id, &result, &result_type)) {\n     glGetUniformiv(\n         service_id, real_location,\n         static_cast<cmds::GetUniformiv::Result*>(result)->GetData());\n  }\n  return error;\n}\n",
        "line": "  if (GetUniformSetup(\n      program, fake_location, c.params_shm_id, c.params_shm_offset,\n      &error, &real_location, &service_id, &result, &result_type)) {\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 181
    },
    {
        "index": 1416,
        "code": "XcursorXcFileLoad (XcursorFile\t    *file,\n\t\t   XcursorComments  **commentsp,\n\t\t   XcursorImages    **imagesp)\n{\n    XcursorFileHeader\t*fileHeader;\n    int\t\t\tnimage;\n    int\t\t\tncomment;\n    XcursorImages\t*images;\n    XcursorImage\t*image;\n    XcursorComment\t*comment;\n    XcursorComments\t*comments;\n    int\t\t\ttoc;\n\n    if (!file)\n        return 0;\n    fileHeader = _XcursorReadFileHeader (file);\n    if (!fileHeader)\n\treturn 0;\n    nimage = 0;\n    ncomment = 0;\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tswitch (fileHeader->tocs[toc].type) {\n\tcase XCURSOR_COMMENT_TYPE:\n\t    ncomment++;\n\t    break;\n\tcase XCURSOR_IMAGE_TYPE:\n\t    nimage++;\n\t    break;\n\t}\n    }\n    images = XcursorImagesCreate (nimage);\n    if (!images)\n\treturn 0;\n    comments = XcursorCommentsCreate (ncomment);\n    if (!comments)\n    {\n\tXcursorImagesDestroy (images);\n\treturn 0;\n    }\n    for (toc = 0; toc < fileHeader->ntoc; toc++)\n    {\n\tswitch (fileHeader->tocs[toc].type) {\n\tcase XCURSOR_COMMENT_TYPE:\n\t    comment = _XcursorReadComment (file, fileHeader, toc);\n\t    if (comment)\n\t    {\n\t\tcomments->comments[comments->ncomment] = comment;\n\t\tcomments->ncomment++;\n\t    }\n\t    break;\n\tcase XCURSOR_IMAGE_TYPE:\n\t    image = _XcursorReadImage (file, fileHeader, toc);\n\t    if (image)\n\t    {\n\t\timages->images[images->nimage] = image;\n\t\timages->nimage++;\n\t    }\n\t    break;\n\t}\n    }\n    _XcursorFileHeaderDestroy (fileHeader);\n    if (images->nimage != nimage || comments->ncomment != ncomment)\n    {\n\tXcursorImagesDestroy (images);\n\tXcursorCommentsDestroy (comments);\n\timages = NULL;\n\tcomments = NULL;\n\treturn XcursorFalse;\n    }\n    *imagesp = images;\n    *commentsp = comments;\n    return XcursorTrue;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2017-16612",
        "length": 490
    },
    {
        "index": 146727,
        "code": "void Document::DidAssociateFormControl(Element* element) {\n  if (!GetFrame() || !GetFrame()->GetPage() || !HasFinishedParsing())\n    return;\n\n  if (!did_associate_form_controls_timer_.IsActive())\n    did_associate_form_controls_timer_.StartOneShot(0.3, BLINK_FROM_HERE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-5118",
        "length": 69
    },
    {
        "index": 133334,
        "code": "void PaletteTray::SetIconBorderForShelfAlignment() {\n  if (IsHorizontalAlignment(shelf_alignment())) {\n    icon_->SetBorder(views::Border::CreateEmptyBorder(gfx::Insets(\n        kHorizontalShelfVerticalPadding, kHorizontalShelfHorizontalPadding)));\n  } else {\n    icon_->SetBorder(views::Border::CreateEmptyBorder(gfx::Insets(\n        kVerticalShelfVerticalPadding, kVerticalShelfHorizontalPadding)));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 98
    },
    {
        "index": 106549,
        "code": "void WebPageProxy::goForward()\n{\n    if (isValid() && !canGoForward())\n        return;\n\n    WebBackForwardListItem* forwardItem = m_backForwardList->forwardItem();\n    if (forwardItem)\n        setPendingAPIRequestURL(forwardItem->url());\n\n    if (!isValid()) {\n        reattachToWebProcessWithItem(forwardItem);\n        return;\n    }\n\n    SandboxExtension::Handle sandboxExtensionHandle;\n    initializeSandboxExtensionHandle(KURL(KURL(), forwardItem->url()), sandboxExtensionHandle);\n    process()->send(Messages::WebPage::GoForward(forwardItem->itemID(), sandboxExtensionHandle), m_pageID);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 138
    },
    {
        "index": 104600,
        "code": "GURL Extension::GetBaseURLFromExtensionId(const std::string& extension_id) {\n  return GURL(std::string(chrome::kExtensionScheme) +\n              chrome::kStandardSchemeSeparator + extension_id + \"/\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-2839",
        "length": 47
    },
    {
        "index": 137898,
        "code": "AXARIAGridCell* AXARIAGridCell::create(LayoutObject* layoutObject,\n                                       AXObjectCacheImpl& axObjectCache) {\n  return new AXARIAGridCell(layoutObject, axObjectCache);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 47
    },
    {
        "index": 141873,
        "code": "void AutofillPopupBaseView::HideController() {\n  if (delegate_)\n    delegate_->Hide();\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5185",
        "length": 23
    },
    {
        "index": 164949,
        "code": "void ResourceDispatcherHostImpl::OnRenderViewHostCreated(\n    int child_id,\n    int route_id,\n    net::URLRequestContextGetter* url_request_context_getter) {\n  auto* host = ResourceDispatcherHostImpl::Get();\n  if (host && host->scheduler_) {\n    host->scheduler_->OnClientCreated(\n        child_id, route_id,\n        url_request_context_getter->GetURLRequestContext()\n            ->network_quality_estimator());\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2019-5822",
        "length": 95
    },
    {
        "index": 177522,
        "code": "MD5Final(md5byte digest[16], struct MD5Context *ctx) {\n int count = ctx->bytes[0] & 0x3f; /* Number of bytes in ctx->in */\n  md5byte *p = (md5byte *)ctx->in + count;\n\n /* Set the first char of padding to 0x80.  There is always room. */\n *p++ = 0x80;\n\n /* Bytes of padding needed to make 56 bytes (-8..55) */\n  count = 56 - 1 - count;\n\n if (count < 0) { /* Padding forces an extra block */\n    memset(p, 0, count + 8);\n    byteSwap(ctx->in, 16);\n    MD5Transform(ctx->buf, ctx->in);\n    p = (md5byte *)ctx->in;\n    count = 56;\n }\n\n  memset(p, 0, count);\n  byteSwap(ctx->in, 14);\n\n /* Append length in bits and transform */\n  ctx->in[14] = ctx->bytes[0] << 3;\n  ctx->in[15] = ctx->bytes[1] << 3 | ctx->bytes[0] >> 29;\n  MD5Transform(ctx->buf, ctx->in);\n\n  byteSwap(ctx->buf, 4);\n  memcpy(digest, ctx->buf, 16);\n  memset(ctx, 0, sizeof(*ctx)); /* In case it's sensitive */\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1621",
        "length": 312
    },
    {
        "index": 73521,
        "code": "static MagickBooleanType CorrectPSDOpacity(LayerInfo* layer_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  if (layer_info->opacity == OpaqueOpacity)\n    return(MagickTrue);\n\n  layer_info->image->matte=MagickTrue;\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(layer_info->image,layer_info->image,layer_info->image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) layer_info->image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(layer_info->image,0,y,layer_info->image->columns,1,\n      exception);\n    if (q == (PixelPacket *)NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) layer_info->image->columns; x++)\n    {\n      q->opacity=(Quantum) (QuantumRange-(Quantum) (QuantumScale*(\n        (QuantumRange-q->opacity)*(QuantumRange-layer_info->opacity))));\n      q++;\n    }\n    if (SyncAuthenticPixels(layer_info->image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  return(status);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2016-7538",
        "length": 333
    },
    {
        "index": 66949,
        "code": "AVCPBProperties *av_cpb_properties_alloc(size_t *size)\n{\n    AVCPBProperties *props = av_mallocz(sizeof(AVCPBProperties));\n    if (!props)\n        return NULL;\n\n    if (size)\n        *size = sizeof(*props);\n\n    props->vbv_delay = UINT64_MAX;\n\n    return props;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2017-7865",
        "length": 73
    },
    {
        "index": 85326,
        "code": "static struct discard_cmd *__create_discard_cmd(struct f2fs_sb_info *sbi,\n\t\tstruct block_device *bdev, block_t lstart,\n\t\tblock_t start, block_t len)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *pend_list;\n\tstruct discard_cmd *dc;\n\n\tf2fs_bug_on(sbi, !len);\n\n\tpend_list = &dcc->pend_list[plist_idx(len)];\n\n\tdc = f2fs_kmem_cache_alloc(discard_cmd_slab, GFP_NOFS);\n\tINIT_LIST_HEAD(&dc->list);\n\tdc->bdev = bdev;\n\tdc->lstart = lstart;\n\tdc->start = start;\n\tdc->len = len;\n\tdc->ref = 0;\n\tdc->state = D_PREP;\n\tdc->error = 0;\n\tinit_completion(&dc->wait);\n\tlist_add_tail(&dc->list, pend_list);\n\tatomic_inc(&dcc->discard_cmd_cnt);\n\tdcc->undiscard_blks += len;\n\n\treturn dc;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2017-18241",
        "length": 215
    },
    {
        "index": 119682,
        "code": "static inline void stopIgnoringSpaces(LineMidpointState& lineMidpointState, const InlineIterator& midpoint)\n{\n    ASSERT(lineMidpointState.numMidpoints % 2);\n    deprecatedAddMidpoint(lineMidpointState, midpoint);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2909",
        "length": 50
    },
    {
        "index": 149373,
        "code": "void DeepScanningClientResponseToDownloadCheckResult(\n    const DeepScanningClientResponse& response,\n    DownloadCheckResult* download_result,\n    DownloadCheckResultReason* download_reason) {\n  if (response.has_malware_scan_verdict() &&\n      response.malware_scan_verdict().verdict() ==\n          MalwareDeepScanningVerdict::MALWARE) {\n    *download_result = DownloadCheckResult::DANGEROUS;\n    *download_reason = DownloadCheckResultReason::REASON_DOWNLOAD_DANGEROUS;\n    return;\n  }\n\n  if (response.has_malware_scan_verdict() &&\n      response.malware_scan_verdict().verdict() ==\n          MalwareDeepScanningVerdict::UWS) {\n    *download_result = DownloadCheckResult::POTENTIALLY_UNWANTED;\n    *download_reason =\n        DownloadCheckResultReason::REASON_DOWNLOAD_POTENTIALLY_UNWANTED;\n    return;\n  }\n\n  if (response.has_dlp_scan_verdict()) {\n    bool should_dlp_block = std::any_of(\n        response.dlp_scan_verdict().triggered_rules().begin(),\n        response.dlp_scan_verdict().triggered_rules().end(),\n        [](const DlpDeepScanningVerdict::TriggeredRule& rule) {\n          return rule.action() == DlpDeepScanningVerdict::TriggeredRule::BLOCK;\n        });\n    if (should_dlp_block) {\n      *download_result = DownloadCheckResult::SENSITIVE_CONTENT_BLOCK;\n      *download_reason =\n          DownloadCheckResultReason::REASON_SENSITIVE_CONTENT_BLOCK;\n      return;\n    }\n\n    bool should_dlp_warn = std::any_of(\n        response.dlp_scan_verdict().triggered_rules().begin(),\n        response.dlp_scan_verdict().triggered_rules().end(),\n        [](const DlpDeepScanningVerdict::TriggeredRule& rule) {\n          return rule.action() == DlpDeepScanningVerdict::TriggeredRule::WARN;\n        });\n    if (should_dlp_warn) {\n      *download_result = DownloadCheckResult::SENSITIVE_CONTENT_WARNING;\n      *download_reason =\n          DownloadCheckResultReason::REASON_SENSITIVE_CONTENT_WARNING;\n      return;\n    }\n  }\n\n  *download_result = DownloadCheckResult::DEEP_SCANNED_SAFE;\n  *download_reason = DownloadCheckResultReason::REASON_DEEP_SCANNED_SAFE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5089",
        "length": 503
    },
    {
        "index": 26445,
        "code": "static void pmcraid_get_dump(struct pmcraid_instance *pinstance)\n{\n\tpmcraid_info(\"%s is not yet implemented\\n\", __func__);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-2906",
        "length": 34
    },
    {
        "index": 130491,
        "code": "bool AsyncReadPixelsCompletedQuery::End(base::subtle::Atomic32 submit_count) {\n  if (!AddToPendingQueue(submit_count)) {\n    return false;\n  }\n  manager()->decoder()->WaitForReadPixels(\n      base::Bind(&AsyncReadPixelsCompletedQuery::Complete,\n                 AsWeakPtr()));\n\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-1710",
        "length": 71
    },
    {
        "index": 28866,
        "code": "u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-6368",
        "length": 27
    },
    {
        "index": 97581,
        "code": "xmlXPathCastNodeSetToBoolean (xmlNodeSetPtr ns) {\n    if ((ns == NULL) || (ns->nodeNr == 0))\n\treturn(0);\n    return(1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 43
    },
    {
        "index": 157103,
        "code": "  MultibufferDataSource::Preload preload() { return data_source_->preload_; }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 19
    },
    {
        "index": 39336,
        "code": "static inline void debugt(const char *func, const char *msg) { }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-1738",
        "length": 18
    },
    {
        "index": 169884,
        "code": "xsltShutdownCtxtExt(xsltExtDataPtr data, xsltTransformContextPtr ctxt,\n                    const xmlChar * URI)\n{\n    xsltExtModulePtr module;\n\n    if ((data == NULL) || (ctxt == NULL) || (URI == NULL))\n        return;\n    module = data->extModule;\n    if ((module == NULL) || (module->shutdownFunc == NULL))\n        return;\n\n#ifdef WITH_XSLT_DEBUG_EXTENSIONS\n    xsltGenericDebug(xsltGenericDebugContext,\n                     \"Shutting down module : %s\\n\", URI);\n#endif\n    module->shutdownFunc(ctxt, URI, data->extData);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-1683",
        "length": 136
    },
    {
        "index": 12812,
        "code": "static int tls1_alpn_handle_client_hello(SSL *s, const unsigned char *data,\n                                         unsigned data_len, int *al)\n{\n    unsigned i;\n    unsigned proto_len;\n\n    if (data_len < 2)\n        goto parse_error;\n\n    /*\n     * data should contain a uint16 length followed by a series of 8-bit,\n     * length-prefixed strings.\n     */\n    i = ((unsigned)data[0]) << 8 | ((unsigned)data[1]);\n    data_len -= 2;\n    data += 2;\n    if (data_len != i)\n        goto parse_error;\n\n    if (data_len < 2)\n        goto parse_error;\n\n    for (i = 0; i < data_len;) {\n        proto_len = data[i];\n        i++;\n\n        if (proto_len == 0)\n            goto parse_error;\n\n        if (i + proto_len < i || i + proto_len > data_len)\n            goto parse_error;\n\n        i += proto_len;\n    }\n\n    if (s->cert->alpn_proposed != NULL)\n        OPENSSL_free(s->cert->alpn_proposed);\n    s->cert->alpn_proposed = OPENSSL_malloc(data_len);\n    if (s->cert->alpn_proposed == NULL) {\n        *al = SSL_AD_INTERNAL_ERROR;\n        return -1;\n    }\n    memcpy(s->cert->alpn_proposed, data, data_len);\n    s->cert->alpn_proposed_len = data_len;\n    return 0;\n\n parse_error:\n    *al = SSL_AD_DECODE_ERROR;\n    return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-2177",
        "length": 340
    },
    {
        "index": 31710,
        "code": "SYSCALL_DEFINE2(sigaltstack,const stack_t __user *,uss, stack_t __user *,uoss)\n{\n\treturn do_sigaltstack(uss, uoss, current_user_stack_pointer());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2141",
        "length": 42
    },
    {
        "index": 103496,
        "code": "SyncError ExtensionService::MergeDataAndStartSyncing(\n    syncable::ModelType type,\n    const SyncDataList& initial_sync_data,\n    SyncChangeProcessor* sync_processor) {\n  CHECK(sync_processor);\n\n  SyncBundle* bundle = NULL;\n\n  switch (type) {\n    case syncable::EXTENSIONS:\n      bundle = &extension_sync_bundle_;\n      bundle->filter = IsSyncableExtension;\n      break;\n\n    case syncable::APPS:\n      bundle = &app_sync_bundle_;\n      bundle->filter = IsSyncableApp;\n      break;\n\n    default:\n      LOG(FATAL) << \"Got \" << type << \" ModelType\";\n  }\n\n  bundle->sync_processor = sync_processor;\n\n  for (SyncDataList::const_iterator i = initial_sync_data.begin();\n       i != initial_sync_data.end();\n       ++i) {\n    ExtensionSyncData extension_sync_data = ExtensionSyncData(*i);\n    bundle->synced_extensions.insert(extension_sync_data.id());\n    ProcessExtensionSyncData(extension_sync_data, *bundle);\n  }\n\n  SyncDataList sync_data_list = GetAllSyncData(type);\n  SyncChangeList sync_change_list;\n  for (SyncDataList::const_iterator i = sync_data_list.begin();\n       i != sync_data_list.end();\n       ++i) {\n    if (bundle->HasExtensionId(i->GetTag()))\n      sync_change_list.push_back(SyncChange(SyncChange::ACTION_UPDATE, *i));\n    else\n      sync_change_list.push_back(SyncChange(SyncChange::ACTION_ADD, *i));\n  }\n  bundle->sync_processor->ProcessSyncChanges(FROM_HERE, sync_change_list);\n\n  return SyncError();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-2859",
        "length": 345
    },
    {
        "index": 153849,
        "code": "bool GLES2Implementation::ValidateSize(const char* func, GLsizeiptr size) {\n  if (size < 0) {\n    SetGLError(GL_INVALID_VALUE, func, \"size < 0\");\n    return false;\n  }\n  if (!base::IsValueInRangeForNumericType<int32_t>(size)) {\n    SetGLError(GL_INVALID_OPERATION, func, \"size more than 32-bit\");\n    return false;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 98
    },
    {
        "index": 91034,
        "code": "\t\tint CWebServer::FindUser(const char* szUserName)\n\t\t{\n\t\t\tint iUser = 0;\n\t\t\tfor (const auto & itt : m_users)\n\t\t\t{\n\t\t\t\tif (itt.Username == szUserName)\n\t\t\t\t\treturn iUser;\n\t\t\t\tiUser++;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-89",
        "cve": "CVE-2019-10664",
        "length": 70
    },
    {
        "index": 130200,
        "code": "bool base64Decode(const Vector<char>& in, Vector<char>& out, CharacterMatchFunctionPtr shouldIgnoreCharacter, Base64DecodePolicy policy)\n{\n    out.clear();\n\n    if (in.size() > UINT_MAX)\n        return false;\n\n    return base64Decode(in.data(), in.size(), out, shouldIgnoreCharacter, policy);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 69
    },
    {
        "index": 91505,
        "code": "static void fatal_jpeg_error (j_common_ptr cinfo)\n{\n\tjmpbuf_wrapper *jmpbufw;\n\tchar buffer[JMSG_LENGTH_MAX];\n\n\t(*cinfo->err->format_message)(cinfo, buffer);\n\tgd_error_ex(GD_WARNING, \"gd-jpeg: JPEG library reports unrecoverable error: %s\", buffer);\n\n\tjmpbufw = (jmpbuf_wrapper *) cinfo->client_data;\n\tjpeg_destroy (cinfo);\n\n\tif (jmpbufw != 0) {\n\t\tlongjmp (jmpbufw->jmpbuf, 1);\n\t\tgd_error_ex(GD_ERROR, \"gd-jpeg: EXTREMELY fatal error: longjmp returned control; terminating\");\n\t} else {\n\t\tgd_error_ex(GD_ERROR, \"gd-jpeg: EXTREMELY fatal error: jmpbuf unrecoverable; terminating\");\n\t}\n\n\texit (99);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2019-6978",
        "length": 185
    },
    {
        "index": 2339,
        "code": "static struct ldb_dn_ext_component ldb_dn_ext_copy_component(\n\t\t\t\t\t\tTALLOC_CTX *mem_ctx,\n\t\t\t\t\t\tstruct ldb_dn_ext_component *src)\n{\n\tstruct ldb_dn_ext_component dst;\n\n\tmemset(&dst, 0, sizeof(dst));\n\n\tif (src == NULL) {\n\t\treturn dst;\n\t}\n\n\tdst.value = ldb_val_dup(mem_ctx, &(src->value));\n\tif (dst.value.data == NULL) {\n\t\treturn dst;\n\t}\n\n\tdst.name = talloc_strdup(mem_ctx, src->name);\n\tif (dst.name == NULL) {\n\t\tLDB_FREE(dst.value.data);\n\t\treturn dst;\n\t}\n\n\treturn dst;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5330",
        "length": 129
    },
    {
        "index": 161190,
        "code": "  void SetNumAudioOutputDevices(size_t num_devices) {\n    num_output_devices_ = num_devices;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6103",
        "length": 25
    },
    {
        "index": 106856,
        "code": "LayoutUnit RenderBox::computeReplacedLogicalHeightUsing(Length logicalHeight) const\n{\n    switch (logicalHeight.type()) {\n        case Fixed:\n            return computeContentBoxLogicalHeight(logicalHeight.value());\n        case Percent:\n        {\n            RenderObject* cb = isPositioned() ? container() : containingBlock();\n            while (cb->isAnonymous()) {\n                cb = cb->containingBlock();\n                toRenderBlock(cb)->addPercentHeightDescendant(const_cast<RenderBox*>(this));\n            }\n\n            if (cb->isPositioned() && cb->style()->height().isAuto() && !(cb->style()->top().isAuto() || cb->style()->bottom().isAuto())) {\n                ASSERT(cb->isRenderBlock());\n                RenderBlock* block = toRenderBlock(cb);\n                LayoutUnit oldHeight = block->height();\n                block->computeLogicalHeight();\n                LayoutUnit newHeight = block->computeContentBoxLogicalHeight(block->contentHeight());\n                block->setHeight(oldHeight);\n                return computeContentBoxLogicalHeight(logicalHeight.calcValue(newHeight));\n            }\n            \n            LayoutUnit availableHeight;\n            if (isPositioned())\n                availableHeight = containingBlockLogicalHeightForPositioned(toRenderBoxModelObject(cb));\n            else {\n                availableHeight =  toRenderBox(cb)->availableLogicalHeight();\n                while (cb && !cb->isRenderView() && (cb->style()->logicalHeight().isAuto() || cb->style()->logicalHeight().isPercent())) {\n                    if (cb->isTableCell()) {\n                        availableHeight = max(availableHeight, intrinsicLogicalHeight());\n                        return logicalHeight.calcValue(availableHeight - borderAndPaddingLogicalHeight());\n                    }\n                    cb = cb->containingBlock();\n                }\n            }\n            return computeContentBoxLogicalHeight(logicalHeight.calcValue(availableHeight));\n        }\n        default:\n            return intrinsicLogicalHeight();\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2011-1799",
        "length": 394
    },
    {
        "index": 87119,
        "code": "CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)\n{\n    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-754",
        "cve": "CVE-2019-1010239",
        "length": 42
    },
    {
        "index": 23505,
        "code": "static void __write_bytes_to_xdr_buf(struct xdr_buf *subbuf, void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(subbuf->head[0].iov_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\tif (this_len)\n\t\t_copy_to_pages(subbuf->pages, subbuf->page_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(subbuf->tail[0].iov_base, obj, this_len);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2011-4131",
        "length": 167
    },
    {
        "index": 111749,
        "code": "void AddInternalName(const Experiment& e, std::set<std::string>* names) {\n  if (e.type == Experiment::SINGLE_VALUE) {\n    names->insert(e.internal_name);\n  } else {\n    DCHECK_EQ(Experiment::MULTI_VALUE, e.type);\n    for (int i = 0; i < e.num_choices; ++i)\n      names->insert(NameForChoice(e, i));\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-2880",
        "length": 90
    },
    {
        "index": 184201,
        "code": " void TranslateMessageInfoBar::Layout() {\n   TranslateInfoBarBase::Layout();\n \n  int x = icon_->bounds().right() + InfoBar::kIconLabelSpacing;\n   gfx::Size label_pref_size = label_->GetPreferredSize();\n   int available_width = GetAvailableWidth() - x;\n   gfx::Size button_pref_size;\n   if (button_) {\n     button_pref_size = button_->GetPreferredSize();\n     available_width -=\n        (button_pref_size.width() + InfoBar::kButtonInLabelSpacing);\n   }\n  label_->SetBounds(x, InfoBar::OffsetY(this, label_pref_size),\n                     std::min(label_pref_size.width(), available_width),\n                     label_pref_size.height());\n \n   if (button_) {\n     button_->SetBounds(label_->bounds().right() +\n                          InfoBar::kButtonInLabelSpacing,\n                       InfoBar::OffsetY(this, button_pref_size),\n                        button_pref_size.width(), button_pref_size.height());\n   }\n }\n",
        "line": "  int x = icon_->bounds().right() + InfoBar::kIconLabelSpacing;\n        (button_pref_size.width() + InfoBar::kButtonInLabelSpacing);\n  label_->SetBounds(x, InfoBar::OffsetY(this, label_pref_size),\n                          InfoBar::kButtonInLabelSpacing,\n                       InfoBar::OffsetY(this, button_pref_size),\n",
        "label": 1,
        "cwe": null,
        "cve": null,
        "length": 202
    },
    {
        "index": 9785,
        "code": "void http_capture_bad_message(struct error_snapshot *es, struct session *s,\n                              struct http_msg *msg,\n\t\t\t      enum ht_state state, struct proxy *other_end)\n{\n\tstruct channel *chn = msg->chn;\n\tint len1, len2;\n\n\tes->len = MIN(chn->buf->i, sizeof(es->buf));\n\tlen1 = chn->buf->data + chn->buf->size - chn->buf->p;\n\tlen1 = MIN(len1, es->len);\n\tlen2 = es->len - len1; /* remaining data if buffer wraps */\n\n\tmemcpy(es->buf, chn->buf->p, len1);\n\tif (len2)\n\t\tmemcpy(es->buf + len1, chn->buf->data, len2);\n\n\tif (msg->err_pos >= 0)\n\t\tes->pos = msg->err_pos;\n\telse\n\t\tes->pos = msg->next;\n\n\tes->when = date; // user-visible date\n\tes->sid  = s->uniq_id;\n\tes->srv  = objt_server(s->target);\n\tes->oe   = other_end;\n\tif (objt_conn(s->req->prod->end))\n\t\tes->src  = __objt_conn(s->req->prod->end)->addr.from;\n\telse\n\t\tmemset(&es->src, 0, sizeof(es->src));\n\n\tes->state = state;\n\tes->ev_id = error_snapshot_id++;\n\tes->b_flags = chn->flags;\n\tes->s_flags = s->flags;\n\tes->t_flags = s->txn.flags;\n\tes->m_flags = msg->flags;\n\tes->b_out = chn->buf->o;\n\tes->b_wrap = chn->buf->data + chn->buf->size - chn->buf->p;\n\tes->b_tot = chn->total;\n\tes->m_clen = msg->chunk_len;\n\tes->m_blen = msg->body_len;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-6269",
        "length": 408
    },
    {
        "index": 143497,
        "code": "viz::LocalSurfaceIdAllocation CompositorImpl::GenerateLocalSurfaceId() const {\n  if (enable_surface_synchronization_) {\n    viz::ParentLocalSurfaceIdAllocator& allocator =\n        CompositorDependencies::Get().surface_id_allocator;\n    allocator.GenerateId();\n    return allocator.GetCurrentLocalSurfaceIdAllocation();\n  }\n\n  return viz::LocalSurfaceIdAllocation();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2016-1705",
        "length": 75
    },
    {
        "index": 186584,
        "code": " Response PageHandler::SetDownloadBehavior(const std::string& behavior,\n                                           Maybe<std::string> download_path) {\n   WebContentsImpl* web_contents = GetWebContents();\n   if (!web_contents)\n     return Response::InternalError();\n\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow &&\n      !download_path.isJust())\n    return Response::Error(\"downloadPath not provided\");\n\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Default) {\n    DevToolsDownloadManagerHelper::RemoveFromWebContents(web_contents);\n    download_manager_delegate_ = nullptr;\n    return Response::OK();\n  }\n\n  content::BrowserContext* browser_context = web_contents->GetBrowserContext();\n  DCHECK(browser_context);\n  content::DownloadManager* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  download_manager_delegate_ =\n      DevToolsDownloadManagerDelegate::TakeOver(download_manager);\n\n  DevToolsDownloadManagerHelper::CreateForWebContents(web_contents);\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(web_contents);\n\n  download_helper->SetDownloadBehavior(\n      DevToolsDownloadManagerHelper::DownloadBehavior::DENY);\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow) {\n    download_helper->SetDownloadBehavior(\n        DevToolsDownloadManagerHelper::DownloadBehavior::ALLOW);\n    download_helper->SetDownloadPath(download_path.fromJust());\n  }\n\n  return Response::OK();\n}\n",
        "line": null,
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2018-18344",
        "length": 307
    },
    {
        "index": 98614,
        "code": "WidgetThumbnail* GetDataForHost(RenderWidgetHost* host) {\n  WidgetThumbnail* wt = GetThumbnailAccessor()->GetProperty(\n      host->property_bag());\n  if (wt)\n    return wt;\n\n  GetThumbnailAccessor()->SetProperty(host->property_bag(),\n                                      WidgetThumbnail());\n  return GetThumbnailAccessor()->GetProperty(host->property_bag());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 70
    },
    {
        "index": 138211,
        "code": "void AXObject::updateCachedAttributeValuesIfNeeded() const {\n  if (isDetached())\n    return;\n\n  AXObjectCacheImpl& cache = axObjectCache();\n\n  if (cache.modificationCount() == m_lastModificationCount)\n    return;\n\n  m_lastModificationCount = cache.modificationCount();\n  m_cachedBackgroundColor = computeBackgroundColor();\n  m_cachedIsInertOrAriaHidden = computeIsInertOrAriaHidden();\n  m_cachedIsDescendantOfLeafNode = (leafNodeAncestor() != 0);\n  m_cachedIsDescendantOfDisabledNode = (disabledAncestor() != 0);\n  m_cachedHasInheritedPresentationalRole =\n      (inheritsPresentationalRoleFrom() != 0);\n  m_cachedIsPresentationalChild =\n      (ancestorForWhichThisIsAPresentationalChild() != 0);\n  m_cachedIsIgnored = computeAccessibilityIsIgnored();\n  m_cachedLiveRegionRoot =\n      isLiveRegion()\n          ? const_cast<AXObject*>(this)\n          : (parentObjectIfExists() ? parentObjectIfExists()->liveRegionRoot()\n                                    : 0);\n  m_cachedAncestorExposesActiveDescendant =\n      computeAncestorExposesActiveDescendant();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 254
    },
    {
        "index": 10954,
        "code": "static int exif_process_undefined(char **result, char *value, size_t byte_count TSRMLS_DC) {\n\t/* we cannot use strlcpy - here the problem is that we have to copy NUL\n\t * chars up to byte_count, we also have to add a single NUL character to\n\t * force end of string.\n\t * estrndup does not return length\n\t */\n\tif (byte_count) {\n\t\t(*result) = estrndup(value, byte_count); /* NULL @ byte_count!!! */\n\t\treturn byte_count+1;\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4544",
        "length": 125
    },
    {
        "index": 37560,
        "code": "static void nonpaging_update_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t const void *pte)\n{\n\tWARN_ON(1);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-3645",
        "length": 45
    },
    {
        "index": 121407,
        "code": "bool DevToolsWindow::FindInspectedBrowserAndTabIndex(Browser** browser,\n                                                     int* tab) {\n  content::WebContents* inspected_web_contents = GetInspectedWebContents();\n  if (!inspected_web_contents)\n    return false;\n\n  for (chrome::BrowserIterator it; !it.done(); it.Next()) {\n    int tab_index = it->tab_strip_model()->GetIndexOfWebContents(\n        inspected_web_contents);\n    if (tab_index != TabStripModel::kNoTab) {\n      *browser = *it;\n      *tab = tab_index;\n      return true;\n    }\n  }\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-2874",
        "length": 131
    },
    {
        "index": 94797,
        "code": "MagickExport const Quantum *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-5688",
        "length": 159
    },
    {
        "index": 46028,
        "code": "svcauth_gss_nextverf(struct svc_req *rqst, u_int num)\n{\n\tstruct svc_rpc_gss_data\t*gd;\n\tgss_buffer_desc\t\t signbuf;\n\tOM_uint32\t\t maj_stat, min_stat;\n\n\tlog_debug(\"in svcauth_gss_nextverf()\");\n\n\tif (rqst->rq_xprt->xp_auth == NULL)\n\t\treturn (FALSE);\n\n\tgd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);\n\n\tgss_release_buffer(&min_stat, &gd->checksum);\n\n\tsignbuf.value = &num;\n\tsignbuf.length = sizeof(num);\n\n\tmaj_stat = gss_get_mic(&min_stat, gd->ctx, gd->sec.qop,\n\t\t\t       &signbuf, &gd->checksum);\n\n\tif (maj_stat != GSS_S_COMPLETE) {\n\t\tlog_status(\"gss_get_mic\", maj_stat, min_stat);\n\t\treturn (FALSE);\n\t}\n\trqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;\n\trqst->rq_xprt->xp_verf.oa_base = (caddr_t)gd->checksum.value;\n\trqst->rq_xprt->xp_verf.oa_length = (u_int)gd->checksum.length;\n\n\treturn (TRUE);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2014-9423",
        "length": 270
    },
    {
        "index": 25574,
        "code": "int do_unknown_trapa(unsigned long scId, struct pt_regs *regs)\n{\n\t/* Syscall debug */\n        printk(\"System call ID error: [0x1#args:8 #syscall:16  0x%lx]\\n\", scId);\n\n\tdie_if_kernel(\"unknown trapa\", regs, scId);\n\n\treturn -ENOSYS;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 76
    },
    {
        "index": 22778,
        "code": "static void init_once(void *foo)\n{\n\tstruct nfs_inode *nfsi = (struct nfs_inode *) foo;\n\n\tinode_init_once(&nfsi->vfs_inode);\n\tINIT_LIST_HEAD(&nfsi->open_files);\n\tINIT_LIST_HEAD(&nfsi->access_cache_entry_lru);\n\tINIT_LIST_HEAD(&nfsi->access_cache_inode_lru);\n\tINIT_RADIX_TREE(&nfsi->nfs_page_tree, GFP_ATOMIC);\n\tnfsi->ncommit = 0;\n\tnfsi->npages = 0;\n\tatomic_set(&nfsi->silly_count, 1);\n\tINIT_HLIST_HEAD(&nfsi->silly_list);\n\tinit_waitqueue_head(&nfsi->waitqueue);\n\tnfs4_init_once(nfsi);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-4324",
        "length": 167
    },
    {
        "index": 133986,
        "code": "void AppListSyncableService::RemoveSyncItem(const std::string& id) {\n  VLOG(2) << this << \": RemoveSyncItem: \" << id.substr(0, 8);\n  SyncItemMap::iterator iter = sync_items_.find(id);\n  if (iter == sync_items_.end()) {\n    DVLOG(2) << this << \" : RemoveSyncItem: No Item.\";\n    return;\n  }\n\n  SyncItem* sync_item = iter->second;\n  sync_pb::AppListSpecifics::AppListItemType type = sync_item->item_type;\n  if (type == sync_pb::AppListSpecifics::TYPE_REMOVE_DEFAULT_APP) {\n    DVLOG(2) << this << \" : RemoveDefault Item exists.\";\n    return;\n  }\n\n  if (type == sync_pb::AppListSpecifics::TYPE_APP &&\n      AppIsDefault(extension_system_->extension_service(), id)) {\n    VLOG(2) << this << \" -> SYNC UPDATE: REMOVE_DEFAULT: \"\n            << sync_item->item_id;\n    sync_item->item_type = sync_pb::AppListSpecifics::TYPE_REMOVE_DEFAULT_APP;\n    SendSyncChange(sync_item, SyncChange::ACTION_UPDATE);\n    return;\n  }\n\n  DeleteSyncItem(sync_item);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6644",
        "length": 263
    },
    {
        "index": 127583,
        "code": "  static XCustomCursorCache* GetInstance() {\n    return Singleton<XCustomCursorCache>::get();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0838",
        "length": 24
    },
    {
        "index": 181425,
        "code": " static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n \tRList *ret = NULL;\n \tRBinWasmGlobalEntry *ptr = NULL;\n\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n \n \tif (!(ret = r_list_newf ((RListFree)free))) {\n \t\treturn NULL;\n \t}\n \n \tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n \tut32 len =  sec->payload_len;\n \tut32 count = sec->count;\n \tut32 i = 0, r = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n }\n",
        "line": "\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n",
        "label": 1,
        "cwe": "CWE-125",
        "cve": "CVE-2017-7854",
        "length": 356
    },
    {
        "index": 35719,
        "code": "static const char *register_authz_provider(cmd_parms *cmd, void *_cfg,\n                                           const char *name, const char *file,\n                                           const char *function)\n{\n    lua_authz_provider_spec *spec;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err)\n        return err;\n\n    spec = apr_pcalloc(cmd->pool, sizeof(*spec));\n    spec->name = name;\n    spec->file_name = file;\n    spec->function_name = function;\n\n    apr_hash_set(lua_authz_providers, name, APR_HASH_KEY_STRING, spec);\n    ap_register_auth_provider(cmd->pool, AUTHZ_PROVIDER_GROUP, name,\n                              AUTHZ_PROVIDER_VERSION,\n                              &lua_authz_provider,\n                              AP_AUTH_INTERNAL_PER_CONF);\n    return NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-8109",
        "length": 166
    },
    {
        "index": 53275,
        "code": "void xmlrpc_generic_error(int code, const char *string)\n{\n\tchar buf[1024];\n\tconst char *ss;\n\tmowgli_string_t *s = mowgli_string_create();\n\tchar *s2;\n\tint len;\n\n\tif (xmlrpc.encode)\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\\r\\n<methodResponse>\\r\\n\", xmlrpc.encode);\n\t}\n\telse\n\t{\n\t\tsnprintf(buf, sizeof buf, \"<?xml version=\\\"1.0\\\"?>\\r\\n<methodResponse>\\r\\n\");\n\t}\n\ts->append(s, buf, strlen(buf));\n\n\tss = \" <fault>\\r\\n  <value>\\r\\n   <struct>\\r\\n    <member>\\r\\n     <name>faultCode</name>\\r\\n     <value><int>\";\n\ts->append(s, ss, strlen(ss));\n\tsnprintf(buf, sizeof buf, \"%d\", code);\n\ts->append(s, buf, strlen(buf));\n\tss = \"</int></value>\\r\\n    </member>\\r\\n    <member>\\r\\n     <name>faultString</name>\\r\\n     <value><string>\";\n\ts->append(s, ss, strlen(ss));\n\txmlrpc_append_char_encode(s, string);\n\tss = \"</string></value>\\r\\n    </member>\\r\\n   </struct>\\r\\n  </value>\\r\\n </fault>\\r\\n</methodResponse>\",\n\ts->append(s, ss, strlen(ss));\n\n\tlen = s->pos;\n\n\tif (xmlrpc.httpheader)\n\t{\n\t\tchar *header = xmlrpc_write_header(len);\n\t\ts2 = smalloc(strlen(header) + len + 1);\n\t\tstrcpy(s2, header);\n\t\tmemcpy(s2 + strlen(header), s->str, len);\n\t\txmlrpc.setbuffer(s2, len + strlen(header));\n\t\tfree(header);\n\t\tfree(s2);\n\t}\n\telse\n\t\txmlrpc.setbuffer(s->str, len);\n\n\ts->destroy(s);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-4478",
        "length": 416
    },
    {
        "index": 138765,
        "code": "void RenderFrameHostImpl::OnSerializeAsMHTMLResponse(\n    int job_id,\n    MhtmlSaveStatus save_status,\n    const std::set<std::string>& digests_of_uris_of_serialized_resources,\n    base::TimeDelta renderer_main_thread_time) {\n  MHTMLGenerationManager::GetInstance()->OnSerializeAsMHTMLResponse(\n      this, job_id, save_status, digests_of_uris_of_serialized_resources,\n      renderer_main_thread_time);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1278",
        "length": 98
    },
    {
        "index": 142308,
        "code": "void ChromePasswordManagerClient::NotifyStorePasswordCalled() {\n  helper_.NotifyStorePasswordCalled();\n  was_store_ever_called_ = true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 32
    },
    {
        "index": 80669,
        "code": "void vmhd_del(GF_Box *s)\n{\n\tGF_VideoMediaHeaderBox *ptr = (GF_VideoMediaHeaderBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-13006",
        "length": 46
    },
    {
        "index": 9703,
        "code": "  FT_Stream_OpenMemory( FT_Stream       stream,\n                        const FT_Byte*  base,\n                        FT_ULong        size )\n  {\n    stream->base   = (FT_Byte*) base;\n    stream->size   = size;\n    stream->pos    = 0;\n    stream->cursor = 0;\n    stream->read   = 0;\n    stream->close  = 0;\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2010-2805",
        "length": 88
    },
    {
        "index": 172877,
        "code": "int HAL_load(void)\n{\n int err = 0;\n\n hw_module_t* module;\n hw_device_t* device;\n\n    bdt_log(\"Loading HAL lib + extensions\");\n\n    err = hw_get_module(BT_HARDWARE_MODULE_ID, (hw_module_t const**)&module);\n if (err == 0)\n {\n        err = module->methods->open(module, BT_HARDWARE_MODULE_ID, &device);\n if (err == 0) {\n            bt_device = (bluetooth_device_t *)device;\n            sBtInterface = bt_device->get_bluetooth_interface();\n }\n }\n\n    bdt_log(\"HAL library loaded (%s)\", strerror(err));\n\n return err;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-3760",
        "length": 138
    },
    {
        "index": 150514,
        "code": "  DataReductionProxyWarmupURLBrowsertest()\n      : via_header_(std::get<1>(GetParam()) ? \"1.1 Chrome-Compression-Proxy\"\n                                            : \"bad\"),\n        primary_server_(GetTestServerType()),\n        secondary_server_(GetTestServerType()) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5039",
        "length": 62
    },
    {
        "index": 3744,
        "code": "_dbus_geteuid (void)\n{\n  return geteuid ();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-2168",
        "length": 17
    },
    {
        "index": 162583,
        "code": "static inline bool ShouldUpdateHeaderAfterRevalidation(\n    const AtomicString& header) {\n  for (size_t i = 0; i < WTF_ARRAY_LENGTH(kHeadersToIgnoreAfterRevalidation);\n       i++) {\n    if (DeprecatedEqualIgnoringCase(header,\n                                    kHeadersToIgnoreAfterRevalidation[i]))\n      return false;\n  }\n  for (size_t i = 0;\n       i < WTF_ARRAY_LENGTH(kHeaderPrefixesToIgnoreAfterRevalidation); i++) {\n    if (header.StartsWithIgnoringASCIICase(\n            kHeaderPrefixesToIgnoreAfterRevalidation[i]))\n      return false;\n  }\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-6066",
        "length": 134
    },
    {
        "index": 135081,
        "code": "void AppCacheHost::PrepareForTransfer() {\n  DCHECK(!associated_cache());\n  DCHECK(!is_selection_pending());\n  DCHECK(!group_being_updated_.get());\n  host_id_ = kAppCacheNoHostId;\n  frontend_ = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6766",
        "length": 53
    },
    {
        "index": 9343,
        "code": "static void sysbus_esp_realize(DeviceState *dev, Error **errp)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n    SysBusESPState *sysbus = ESP(dev);\n    ESPState *s = &sysbus->esp;\n    Error *err = NULL;\n\n    sysbus_init_irq(sbd, &s->irq);\n    assert(sysbus->it_shift != -1);\n\n    s->chip_id = TCHI_FAS100A;\n    memory_region_init_io(&sysbus->iomem, OBJECT(sysbus), &sysbus_esp_mem_ops,\n                          sysbus, \"esp\", ESP_REGS << sysbus->it_shift);\n    sysbus_init_mmio(sbd, &sysbus->iomem);\n\n    qdev_init_gpio_in(dev, sysbus_esp_gpio_demux, 2);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), dev, &esp_scsi_info, NULL);\n    scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n    if (err != NULL) {\n        error_propagate(errp, err);\n        return;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2016-6351",
        "length": 241
    },
    {
        "index": 160209,
        "code": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    default:\n      break;\n  }\n\n  DCHECK(defer_page_unload_);\n  defer_page_unload_ = false;\n\n  std::vector<int> pages_to_unload;\n  std::swap(pages_to_unload, deferred_page_unloads_);\n  for (int page_index : pages_to_unload)\n    pages_[page_index]->Unload();\n\n  return rv;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-6088",
        "length": 372
    },
    {
        "index": 176533,
        "code": "xmlPrintURI(FILE *stream, xmlURIPtr uri) {\n    xmlChar *out;\n\n    out = xmlSaveUri(uri);\n if (out != NULL) {\n\tfprintf(stream, \"%s\", (char *) out);\n\txmlFree(out);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-7376",
        "length": 53
    },
    {
        "index": 175054,
        "code": " virtual bool requiresSecureDecoderComponent(\n const char *mime) const {\n Parcel data, reply;\n        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());\n        data.writeCString(mime);\n        remote()->transact(REQUIRES_SECURE_COMPONENT, data, &reply);\n\n return reply.readInt32() != 0;\n }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2016-0811",
        "length": 64
    },
    {
        "index": 5977,
        "code": "e1000e_has_rxbufs(E1000ECore *core, const E1000E_RingInfo *r,\n                  size_t total_size)\n{\n    uint32_t bufs = e1000e_ring_free_descr_num(core, r);\n\n    trace_e1000e_rx_has_buffers(r->idx, bufs, total_size,\n                                core->rx_desc_buf_size);\n\n    return total_size <= bufs / (core->rx_desc_len / E1000_MIN_RX_DESC_LEN) *\n                         core->rx_desc_buf_size;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-835",
        "cve": "CVE-2017-9310",
        "length": 114
    },
    {
        "index": 112739,
        "code": "void PrintPreviewHandler::ClearInitiatorTabDetails() {\n  TabContents* initiator_tab = GetInitiatorTab();\n  if (!initiator_tab)\n    return;\n\n  printing::PrintPreviewTabController* tab_controller =\n      printing::PrintPreviewTabController::GetInstance();\n  if (tab_controller)\n    tab_controller->EraseInitiatorTabInfo(preview_tab_contents());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2012-2891",
        "length": 78
    },
    {
        "index": 120329,
        "code": "  GestureRecognizerTest() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-2887",
        "length": 7
    },
    {
        "index": 31985,
        "code": "void perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx,\n\t\t   struct task_struct *task)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\n\tstruct perf_raw_record raw = {\n\t\t.size = entry_size,\n\t\t.data = record,\n\t};\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdata.raw = &raw;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, &data, regs);\n\t}\n\n\t/*\n\t * If we got specified a target task, also iterate its context and\n\t * deliver this event there too.\n\t */\n\tif (task && task != current) {\n\t\tstruct perf_event_context *ctx;\n\t\tstruct trace_entry *entry = record;\n\n\t\trcu_read_lock();\n\t\tctx = rcu_dereference(task->perf_event_ctxp[perf_sw_context]);\n\t\tif (!ctx)\n\t\t\tgoto unlock;\n\n\t\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\t\tif (event->attr.type != PERF_TYPE_TRACEPOINT)\n\t\t\t\tcontinue;\n\t\t\tif (event->attr.config != entry->type)\n\t\t\t\tcontinue;\n\t\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\t\tperf_swevent_event(event, count, &data, regs);\n\t\t}\nunlock:\n\t\trcu_read_unlock();\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-2094",
        "length": 342
    },
    {
        "index": 31701,
        "code": "SYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current_thread_info()->restart_block;\n\treturn restart->fn(restart);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2141",
        "length": 33
    },
    {
        "index": 168541,
        "code": "static int get_sub_api(char* driver, int api){\n\tint i;\n\tconst char sep_str[2] = {LIST_SEPARATOR, 0};\n\tchar *tok, *tmp_str;\n\tsize_t len = safe_strlen(driver);\n\n\tif (len == 0) return SUB_API_NOTSET;\n\ttmp_str = (char*) calloc(len+1, 1);\n\tif (tmp_str == NULL) return SUB_API_NOTSET;\n\tmemcpy(tmp_str, driver, len+1);\n\ttok = strtok(tmp_str, sep_str);\n\twhile (tok != NULL) {\n\t\tfor (i=0; i<usb_api_backend[api].nb_driver_names; i++) {\n\t\t\tif (safe_stricmp(tok, usb_api_backend[api].driver_name_list[i]) == 0) {\n\t\t\t\tfree(tmp_str);\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\ttok = strtok(NULL, sep_str);\n\t}\n\tfree (tmp_str);\n\treturn SUB_API_NOTSET;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6125",
        "length": 199
    },
    {
        "index": 25872,
        "code": "int kgdb_arch_handle_exception(int e_vector, int signo, int err_code,\n\t\t\t       char *remcomInBuffer, char *remcomOutBuffer,\n\t\t\t       struct pt_regs *linux_regs)\n{\n\tunsigned long addr;\n\tchar *ptr;\n\n\tswitch (remcomInBuffer[0]) {\n\tcase 'c':\n\tcase 's':\n\t\t/* try to read optional parameter, pc unchanged if no parm */\n\t\tptr = &remcomInBuffer[1];\n\t\tif (kgdb_hex2long(&ptr, &addr))\n\t\t\tlinux_regs->ip = addr;\n\tcase 'D':\n\tcase 'k':\n\t\t/* clear the trace bit */\n\t\tlinux_regs->flags &= ~X86_EFLAGS_TF;\n\t\tatomic_set(&kgdb_cpu_doing_single_step, -1);\n\n\t\t/* set the trace bit if we're stepping */\n\t\tif (remcomInBuffer[0] == 's') {\n\t\t\tlinux_regs->flags |= X86_EFLAGS_TF;\n\t\t\tatomic_set(&kgdb_cpu_doing_single_step,\n\t\t\t\t   raw_smp_processor_id());\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* this means that we do not want to exit from the handler: */\n\treturn -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 255
    },
    {
        "index": 161017,
        "code": "void ChromeClientImpl::TakeFocus(WebFocusType type) {\n  if (!web_view_->Client())\n    return;\n  if (type == kWebFocusTypeBackward)\n    web_view_->Client()->FocusPrevious();\n  else\n    web_view_->Client()->FocusNext();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2018-6096",
        "length": 59
    },
    {
        "index": 98689,
        "code": "NPError WebPluginDelegatePepper::Device2DQueryCapability(int32 capability,\n                                                         int32* value) {\n  return NPERR_GENERIC_ERROR;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 33
    },
    {
        "index": 6586,
        "code": "Smb4KMountJob::Smb4KMountJob( QObject *parent ) : KJob( parent ),\n  m_started( false ), m_parent_widget( NULL ), m_processed( 0 )\n{\n  setCapabilities( KJob::Killable );\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-8849",
        "length": 55
    },
    {
        "index": 127841,
        "code": "void PepperPlatformVideoCapture::OnStateUpdate(VideoCaptureState state) {\n  if (!handler_)\n    return;\n  switch (state) {\n    case VIDEO_CAPTURE_STATE_STARTED:\n      handler_->OnStarted();\n      break;\n    case VIDEO_CAPTURE_STATE_STOPPED:\n      handler_->OnStopped();\n      break;\n    case VIDEO_CAPTURE_STATE_PAUSED:\n      handler_->OnPaused();\n      break;\n    case VIDEO_CAPTURE_STATE_ERROR:\n      handler_->OnError();\n      break;\n    default:\n      NOTREACHED() << \"Unexpected state: \" << state << \".\";\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-7906",
        "length": 117
    },
    {
        "index": 175285,
        "code": "static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI) {\n    RIL_SelectUiccSub uicc_sub;\n status_t status;\n int32_t  t;\n    memset(&uicc_sub, 0, sizeof(uicc_sub));\n\n    status = p.readInt32(&t);\n if (status != NO_ERROR) {\n goto invalid;\n }\n    uicc_sub.slot = (int) t;\n\n    status = p.readInt32(&t);\n if (status != NO_ERROR) {\n goto invalid;\n }\n    uicc_sub.app_index = (int) t;\n\n    status = p.readInt32(&t);\n if (status != NO_ERROR) {\n goto invalid;\n }\n    uicc_sub.sub_type = (RIL_SubscriptionType) t;\n\n    status = p.readInt32(&t);\n if (status != NO_ERROR) {\n goto invalid;\n }\n    uicc_sub.act_status = (RIL_UiccSubActStatus) t;\n\n    startRequest;\n    appendPrintBuf(\"slot=%d, app_index=%d, act_status = %d\", uicc_sub.slot, uicc_sub.app_index,\n            uicc_sub.act_status);\n    RLOGD(\"dispatchUiccSubscription, slot=%d, app_index=%d, act_status = %d\", uicc_sub.slot,\n            uicc_sub.app_index, uicc_sub.act_status);\n    closeRequest;\n    printRequest(pRI->token, pRI->pCI->requestNumber);\n\n    CALL_ONREQUEST(pRI->pCI->requestNumber, &uicc_sub, sizeof(uicc_sub), pRI, pRI->socket_id);\n\n#ifdef MEMSET_FREED\n    memset(&uicc_sub, 0, sizeof(uicc_sub));\n#endif\n return;\n\ninvalid:\n    invalidCommandBlock(pRI);\n return;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-0823",
        "length": 372
    },
    {
        "index": 72465,
        "code": "void gdImageColorTransparent (gdImagePtr im, int color)\n{\n\tif (color < 0) {\n\t\treturn;\n\t}\n\tif (!im->trueColor) {\n\t\tif((color >= im->colorsTotal)) {\n\t\t\treturn;\n\t\t}\n\t\t/* Make the old transparent color opaque again */\n\t\tif (im->transparent != -1) {\n\t\t\tim->alpha[im->transparent] = gdAlphaOpaque;\n\t\t}\n\t\tim->alpha[color] = gdAlphaTransparent;\n\t}\n\tim->transparent = color;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9933",
        "length": 113
    },
    {
        "index": 42884,
        "code": "void update_gui_state_from_problem_data(int flags)\n{\n    update_window_title();\n    remove_tabs_from_notebook(g_notebook);\n\n    const char *reason = problem_data_get_content_or_NULL(g_cd, FILENAME_REASON);\n    const char *not_reportable = problem_data_get_content_or_NULL(g_cd,\n                                                                  FILENAME_NOT_REPORTABLE);\n\n    char *t = xasprintf(\"%s%s%s\",\n                        not_reportable ? : \"\",\n                        not_reportable ? \" \" : \"\",\n                        reason ? : _(\"(no description)\"));\n\n    gtk_label_set_text(g_lbl_cd_reason, t);\n    free(t);\n\n    gtk_list_store_clear(g_ls_details);\n    struct cd_stats stats = { 0 };\n    g_hash_table_foreach(g_cd, append_item_to_ls_details, &stats);\n    char *msg = xasprintf(_(\"%llu bytes, %u files\"), (long long)stats.filesize, stats.filecount);\n    gtk_label_set_text(g_lbl_size, msg);\n    free(msg);\n\n    load_text_to_text_view(g_tv_comment, FILENAME_COMMENT);\n\n    add_workflow_buttons(g_box_workflows, g_workflow_list,\n                        G_CALLBACK(set_auto_event_chain));\n\n    /* Update event radio buttons\n     * show them only in expert mode\n    */\n    event_gui_data_t *active_button = NULL;\n    if (g_expert_mode == true)\n    {\n        gtk_widget_show(GTK_WIDGET(g_box_events));\n        active_button = add_event_buttons(\n                    g_box_events,\n                    &g_list_events,\n                    g_events,\n                    G_CALLBACK(event_rb_was_toggled)\n        );\n    }\n\n    if (flags & UPDATE_SELECTED_EVENT && g_expert_mode)\n    {\n        /* Update the value of currently selected event */\n        free(g_event_selected);\n        g_event_selected = NULL;\n        if (active_button)\n        {\n            g_event_selected = xstrdup(active_button->event_name);\n        }\n        log_info(\"g_event_selected='%s'\", g_event_selected);\n    }\n    /* We can't just do gtk_widget_show_all once in main:\n     * We created new widgets (buttons). Need to make them visible.\n     */\n    gtk_widget_show_all(GTK_WIDGET(g_wnd_assistant));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2015-5302",
        "length": 453
    },
    {
        "index": 25465,
        "code": "int register_fsl_emb_pmu(struct fsl_emb_pmu *pmu)\n{\n\tif (ppmu)\n\t\treturn -EBUSY;\t\t/* something's already registered */\n\n\tppmu = pmu;\n\tpr_info(\"%s performance monitor hardware support registered\\n\",\n\t\tpmu->name);\n\n\tperf_pmu_register(&fsl_emb_pmu, \"cpu\", PERF_TYPE_RAW);\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2918",
        "length": 86
    },
    {
        "index": 84938,
        "code": "fill_small_buf(__le16 smb2_command, struct cifs_tcon *tcon, void *buf,\n\t       unsigned int *total_len)\n{\n\tstruct smb2_sync_pdu *spdu = (struct smb2_sync_pdu *)buf;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_command)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(buf, 0, 256);\n\n\tsmb2_hdr_assemble(&spdu->sync_hdr, smb2_command, tcon);\n\tspdu->StructureSize2 = cpu_to_le16(parmsize);\n\n\t*total_len = parmsize + sizeof(struct smb2_sync_hdr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2018-1066",
        "length": 168
    },
    {
        "index": 48439,
        "code": "Strtruncate(Str s, int pos)\n{\n    STR_LENGTH_CHECK(s);\n    s->ptr[pos] = '\\0';\n    s->length = pos;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-9442",
        "length": 34
    },
    {
        "index": 10771,
        "code": "void SSL_set_debug(SSL *s, int debug)\n\t{\n\ts->debug = debug;\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-5139",
        "length": 23
    },
    {
        "index": 128599,
        "code": "void Instance::NotifyNumberOfFindResultsChanged(int total, bool final_result) {\n  NumberOfFindResultsChanged(total, final_result);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2014-3198",
        "length": 28
    },
    {
        "index": 38748,
        "code": "hstore_each(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tHStore\t   *hs;\n\tint\t\t\ti;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\ths = PG_GETARG_HS(0);\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\tsetup_firstcall(funcctx, hs, fcinfo);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\ths = (HStore *) funcctx->user_fctx;\n\ti = funcctx->call_cntr;\n\n\tif (i < HS_COUNT(hs))\n\t{\n\t\tHEntry\t   *entries = ARRPTR(hs);\n\t\tchar\t   *ptr = STRPTR(hs);\n\t\tDatum\t\tres,\n\t\t\t\t\tdvalues[2];\n\t\tbool\t\tnulls[2] = {false, false};\n\t\ttext\t   *item;\n\t\tHeapTuple\ttuple;\n\n\t\titem = cstring_to_text_with_len(HS_KEY(entries, ptr, i),\n\t\t\t\t\t\t\t\t\t\tHS_KEYLEN(entries, i));\n\t\tdvalues[0] = PointerGetDatum(item);\n\n\t\tif (HS_VALISNULL(entries, i))\n\t\t{\n\t\t\tdvalues[1] = (Datum) 0;\n\t\t\tnulls[1] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\titem = cstring_to_text_with_len(HS_VAL(entries, ptr, i),\n\t\t\t\t\t\t\t\t\t\t\tHS_VALLEN(entries, i));\n\t\t\tdvalues[1] = PointerGetDatum(item);\n\t\t}\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, dvalues, nulls);\n\t\tres = HeapTupleGetDatum(tuple);\n\n\t\tSRF_RETURN_NEXT(funcctx, PointerGetDatum(res));\n\t}\n\n\tSRF_RETURN_DONE(funcctx);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-2669",
        "length": 354
    },
    {
        "index": 135533,
        "code": "EditorClient& Editor::Client() const {\n  if (Page* page = GetFrame().GetPage())\n    return page->GetEditorClient();\n  return GetEmptyEditorClient();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-6773",
        "length": 39
    },
    {
        "index": 21996,
        "code": "raptor_world_get_option_from_uri(raptor_world* world, raptor_uri *uri)\n{\n  unsigned char *uri_string;\n  int i;\n  raptor_option option = (raptor_option)-1;\n  \n  if(!uri)\n    return option;\n  \n  RAPTOR_ASSERT_OBJECT_POINTER_RETURN_VALUE(world, raptor_world, (raptor_option)-1);\n\n  raptor_world_open(world);\n  \n  uri_string = raptor_uri_as_string(uri);\n  if(strncmp((const char*)uri_string, raptor_option_uri_prefix,\n             raptor_option_uri_prefix_len))\n    return option;\n\n  uri_string += raptor_option_uri_prefix_len;\n\n  for(i = 0; i <= RAPTOR_OPTION_LAST; i++)\n    if(!strcmp(raptor_options_list[i].name, (const char*)uri_string)) {\n      option = (raptor_option)i;\n      break;\n    }\n\n  return option;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2012-0037",
        "length": 193
    },
    {
        "index": 97889,
        "code": "void RenderView::DidDownloadImage(ImageResourceFetcher* fetcher,\n                                  const SkBitmap& image) {\n  Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_,\n                                          fetcher->id(),\n                                          fetcher->image_url(),\n                                          image.isNull(),\n                                          image));\n  DCHECK(image_fetchers_.find(fetcher) != image_fetchers_.end());\n  image_fetchers_.erase(fetcher);\n  MessageLoop::current()->DeleteSoon(FROM_HERE, fetcher);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 101
    },
    {
        "index": 117290,
        "code": "Texture::Texture(GLES2DecoderImpl* decoder)\n    : decoder_(decoder),\n      id_(0),\n      estimated_size_(0) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3101",
        "length": 31
    },
    {
        "index": 112414,
        "code": "PassRefPtr<Element> Document::createElement(const AtomicString& name, ExceptionCode& ec)\n{\n    if (!isValidName(name)) {\n        ec = INVALID_CHARACTER_ERR;\n        return 0;\n    }\n\n    if (m_isXHTML)\n        return HTMLElementFactory::createHTMLElement(QualifiedName(nullAtom, name, xhtmlNamespaceURI), this, 0, false);\n\n    return createElement(QualifiedName(nullAtom, name, nullAtom), false);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-2890",
        "length": 96
    },
    {
        "index": 137968,
        "code": "bool AXLayoutObject::liveRegionAtomic() const {\n  if (getAttribute(aria_atomicAttr).isEmpty() &&\n      (roleValue() == AlertRole || roleValue() == StatusRole)) {\n    return true;\n  }\n  return elementAttributeValue(aria_atomicAttr);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-1274",
        "length": 57
    },
    {
        "index": 101434,
        "code": "  virtual void TearDown() {\n    session_.reset();\n    context_.reset();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 20
    },
    {
        "index": 149269,
        "code": "  static CrostiniUpgrader* GetForProfile(Profile* profile) {\n    return static_cast<CrostiniUpgrader*>(\n        GetInstance()->GetServiceForBrowserContext(profile, true));\n  }\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5110",
        "length": 45
    },
    {
        "index": 74366,
        "code": "void ParaNdis_DeleteQueue(PARANDIS_ADAPTER *pContext, struct virtqueue **ppq, tCompletePhysicalAddress *ppa)\n{\n    if (*ppq) VirtIODeviceDeleteQueue(*ppq, NULL);\n    *ppq = NULL;\n    if (ppa->Virtual) ParaNdis_FreePhysicalMemory(pContext, ppa);\n    RtlZeroMemory(ppa, sizeof(*ppa));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-3215",
        "length": 89
    },
    {
        "index": 91704,
        "code": "const char *am_filepath_dirname(apr_pool_t *p, const char *path) \n{\n    char *cp;\n\n    /*\n     * Try Unix and then Windows style. Borrowed from\n     * apr_match_glob(), it seems it cannot be made more\n     * portable.\n     */\n    if (((cp = strrchr(path, (int)'/')) == NULL) &&\n        ((cp = strrchr(path, (int)'\\\\')) == NULL))\n            return \".\";\n   \n    return apr_pstrndup(p, path, cp - path);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-601",
        "cve": "CVE-2019-3877",
        "length": 116
    },
    {
        "index": 184685,
        "code": "SocketStreamDispatcherHost::SocketStreamDispatcherHost(\n     int render_process_id,\n     ResourceMessageFilter::URLRequestContextSelector* selector,\n     content::ResourceContext* resource_context)\n    : ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),\n      render_process_id_(render_process_id),\n       url_request_context_selector_(selector),\n       resource_context_(resource_context) {\n   DCHECK(selector);\n  net::WebSocketJob::EnsureInit();\n}\n",
        "line": "    : ALLOW_THIS_IN_INITIALIZER_LIST(ssl_delegate_weak_factory_(this)),\n      render_process_id_(render_process_id),\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2011-3106",
        "length": 91
    },
    {
        "index": 147147,
        "code": "static void ActivityLoggingAccessForAllWorldsMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  impl->activityLoggingAccessForAllWorldsMethod();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2017-5120",
        "length": 57
    },
    {
        "index": 120454,
        "code": "Attribute* UniqueElementData::attributeItem(unsigned index)\n{\n    ASSERT_WITH_SECURITY_IMPLICATION(index < length());\n    return &m_attributeVector.at(index);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2884",
        "length": 33
    },
    {
        "index": 156261,
        "code": "void RendererSchedulerImpl::SetRendererBackgrounded(bool backgrounded) {\n  helper_.CheckOnValidThread();\n  if (helper_.IsShutdown() ||\n      main_thread_only().renderer_backgrounded == backgrounded)\n    return;\n  if (backgrounded) {\n    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"renderer.scheduler\"),\n                 \"RendererSchedulerImpl::OnRendererBackgrounded\");\n    RendererMetricsHelper::RecordBackgroundedTransition(\n        BackgroundedRendererTransition::kBackgrounded);\n  } else {\n    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(\"renderer.scheduler\"),\n                 \"RendererSchedulerImpl::OnRendererForegrounded\");\n    RendererMetricsHelper::RecordBackgroundedTransition(\n        BackgroundedRendererTransition::kForegrounded);\n  }\n\n  main_thread_only().renderer_backgrounded = backgrounded;\n  internal::ProcessState::Get()->is_process_backgrounded = backgrounded;\n\n  main_thread_only().background_status_changed_at = tick_clock()->NowTicks();\n  seqlock_queueing_time_estimator_.seqlock.WriteBegin();\n  seqlock_queueing_time_estimator_.data.OnRendererStateChanged(\n      backgrounded, main_thread_only().background_status_changed_at);\n  seqlock_queueing_time_estimator_.seqlock.WriteEnd();\n\n  UpdatePolicy();\n\n  base::TimeTicks now = tick_clock()->NowTicks();\n  if (backgrounded) {\n    main_thread_only().metrics_helper.OnRendererBackgrounded(now);\n  } else {\n    main_thread_only().metrics_helper.OnRendererForegrounded(now);\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-18339",
        "length": 301
    },
    {
        "index": 118074,
        "code": "void OneClickSigninHelper::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (!SigninManager::IsWebBasedSigninFlowURL(params.url)) {\n    Profile* profile =\n        Profile::FromBrowserContext(web_contents()->GetBrowserContext());\n    SigninManager* manager = profile ?\n        SigninManagerFactory::GetForProfile(profile) : NULL;\n    int process_id = web_contents()->GetRenderProcessHost()->GetID();\n    if (manager && manager->IsSigninProcess(process_id))\n      manager->ClearSigninProcess();\n\n    if (!content::PageTransitionIsWebTriggerable(params.transition) &&\n        auto_accept_ != AUTO_ACCEPT_NONE) {\n      CleanTransientState();\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-287",
        "cve": "CVE-2013-6634",
        "length": 166
    },
    {
        "index": 70699,
        "code": "sockaddr_getport(struct sockaddr *sa)\n{\n\tif (sa->sa_family == AF_INET) {\n\t\treturn ntohs(((struct sockaddr_in *)sa)->sin_port);\n\t} else if (sa->sa_family == AF_INET6) {\n\t\treturn ntohs(((struct sockaddr_in6 *)sa)->sin6_port);\n\t} else {\n\t\treturn 0;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10197",
        "length": 77
    },
    {
        "index": 18622,
        "code": "SYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags)\n{\n\treturn __sys_sendmmsg(fd, mmsg, vlen, flags);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2012-4467",
        "length": 54
    },
    {
        "index": 159603,
        "code": "String Document::cookie(ExceptionState& exception_state) const {\n  if (GetSettings() && !GetSettings()->GetCookieEnabled())\n    return String();\n\n  UseCounter::Count(*this, WebFeature::kCookieGet);\n\n\n  if (!GetSecurityOrigin()->CanAccessCookies()) {\n    if (IsSandboxed(kSandboxOrigin))\n      exception_state.ThrowSecurityError(\n          \"The document is sandboxed and lacks the 'allow-same-origin' flag.\");\n    else if (Url().ProtocolIs(\"data\"))\n      exception_state.ThrowSecurityError(\n          \"Cookies are disabled inside 'data:' URLs.\");\n    else\n      exception_state.ThrowSecurityError(\"Access is denied for this document.\");\n    return String();\n  }\n\n  if (GetSecurityOrigin()->HasSuborigin() &&\n      !GetSecurityOrigin()->GetSuborigin()->PolicyContains(\n          Suborigin::SuboriginPolicyOptions::kUnsafeCookies))\n    return String();\n\n  KURL cookie_url = CookieURL();\n  if (cookie_url.IsEmpty())\n    return String();\n\n  return Cookies(this, cookie_url);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-6040",
        "length": 219
    },
    {
        "index": 153158,
        "code": "bool Compositor::HasObserver(const CompositorObserver* observer) const {\n  return observer_list_.HasObserver(observer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-5217",
        "length": 26
    },
    {
        "index": 32991,
        "code": "static int sctp_getsockopt_assoc_number(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tu32 val = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tval++;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-1828",
        "length": 159
    },
    {
        "index": 89339,
        "code": "static char *get_string(char **p, struct token *t, char delim, int lower)\n{\n\tchar *b, *e;\n\tsize_t len, i;\n\n\t/*\n\t * b and e both start at the beginning of the input stream.\n\t *\n\t * e is incremented until we find the ending delimiter, or a NUL byte\n\t * is reached. Then, we take e - b to find the length of the token.\n\t */\n\tb = *p;\n\te = *p;\n\n\twhile (*e) {\n\t\tif ((delim == ' ' && isspace(*e)) || delim == *e)\n\t\t\tbreak;\n\t\te++;\n\t}\n\n\tlen = e - b;\n\n\t/*\n\t * Allocate memory to hold the string, and copy it in, converting\n\t * characters to lowercase if lower is != 0.\n\t */\n\tt->val = malloc(len + 1);\n\tif (!t->val)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++, b++) {\n\t\tif (lower)\n\t\t\tt->val[i] = tolower(*b);\n\t\telse\n\t\t\tt->val[i] = *b;\n\t}\n\n\tt->val[len] = '\\0';\n\n\t/*\n\t * Update *p so the caller knows where to continue scanning.\n\t */\n\t*p = e;\n\n\tt->type = T_STRING;\n\n\treturn t->val;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2019-13106",
        "length": 288
    },
    {
        "index": 21991,
        "code": "raptor_option_get_option_area_for_domain(raptor_domain domain)\n{\n  raptor_option_area area = RAPTOR_OPTION_AREA_NONE;\n\n  if(domain == RAPTOR_DOMAIN_PARSER) \n    area = RAPTOR_OPTION_AREA_PARSER;\n  else if(domain == RAPTOR_DOMAIN_SERIALIZER)\n    area = RAPTOR_OPTION_AREA_SERIALIZER;\n  else if(domain == RAPTOR_DOMAIN_SAX2)\n    area = RAPTOR_OPTION_AREA_SAX2;\n  else if(domain == RAPTOR_DOMAIN_XML_WRITER)\n    area = RAPTOR_OPTION_AREA_XML_WRITER;\n  else if(domain == RAPTOR_DOMAIN_TURTLE_WRITER)\n    area = RAPTOR_OPTION_AREA_TURTLE_WRITER;\n\n  return area;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2012-0037",
        "length": 159
    },
    {
        "index": 148930,
        "code": " bool WebContentsImpl::IsSavable() {\n  return contents_mime_type_ == \"text/html\" ||\n         contents_mime_type_ == \"text/xml\" ||\n         contents_mime_type_ == \"application/xhtml+xml\" ||\n         contents_mime_type_ == \"text/plain\" ||\n         contents_mime_type_ == \"text/css\" ||\n         mime_util::IsSupportedJavascriptMimeType(contents_mime_type_);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2017-5104",
        "length": 82
    },
    {
        "index": 30040,
        "code": "static void vhost_net_clear_ubuf_info(struct vhost_net *n)\n{\n\tint i;\n\n\tfor (i = 0; i < VHOST_NET_VQ_MAX; ++i) {\n\t\tkfree(n->vqs[i].ubuf_info);\n\t\tn->vqs[i].ubuf_info = NULL;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4127",
        "length": 69
    },
    {
        "index": 123402,
        "code": "void RenderWidgetHostViewGuest::SetTakesFocusOnlyOnMouseDown(bool flag) {\n  NOTIMPLEMENTED();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0886",
        "length": 25
    },
    {
        "index": 121771,
        "code": "int UDPSocketLibevent::SetMulticastLoopbackMode(bool loopback) {\n  DCHECK(CalledOnValidThread());\n  if (is_connected())\n    return ERR_SOCKET_IS_CONNECTED;\n\n  if (loopback)\n    socket_options_ |= SOCKET_OPTION_MULTICAST_LOOP;\n  else\n    socket_options_ &= ~SOCKET_OPTION_MULTICAST_LOOP;\n  return OK;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2013-2856",
        "length": 78
    },
    {
        "index": 74187,
        "code": "free_config_phone(\n\tconfig_tree *ptree\n\t)\n{\n\tFREE_STRING_FIFO(ptree->phone);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2015-5195",
        "length": 24
    },
    {
        "index": 186908,
        "code": "bool IsBlockedNavigation(net::Error error_code) {\n  switch (error_code) {\n    case net::ERR_BLOCKED_BY_CLIENT:\n    case net::ERR_BLOCKED_BY_RESPONSE:\n    case net::ERR_BLOCKED_BY_XSS_AUDITOR:\n    case net::ERR_UNSAFE_REDIRECT:\n      return true;\n    default:\n      return false;\n  }\n}\n",
        "line": "  switch (error_code) {\n    case net::ERR_BLOCKED_BY_CLIENT:\n    case net::ERR_BLOCKED_BY_RESPONSE:\n    case net::ERR_BLOCKED_BY_XSS_AUDITOR:\n    case net::ERR_UNSAFE_REDIRECT:\n      return true;\n    default:\n      return false;\n  }\n}\n",
        "label": 1,
        "cwe": "CWE-20",
        "cve": "CVE-2017-15420",
        "length": 75
    },
    {
        "index": 16226,
        "code": "GahpClient::reset_user_timer_alarm()\n{\n\treset_user_timer(pending_timeout_tid);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-134",
        "cve": "CVE-2011-4930",
        "length": 21
    },
    {
        "index": 154201,
        "code": "error::Error GLES2DecoderImpl::HandleCompressedTexImage2DBucket(\n    uint32_t immediate_data_size, const volatile void* cmd_data) {\n  const volatile gles2::cmds::CompressedTexImage2DBucket& c =\n      *static_cast<const volatile gles2::cmds::CompressedTexImage2DBucket*>(\n          cmd_data);\n  GLenum target = static_cast<GLenum>(c.target);\n  GLint level = static_cast<GLint>(c.level);\n  GLenum internal_format = static_cast<GLenum>(c.internalformat);\n  GLsizei width = static_cast<GLsizei>(c.width);\n  GLsizei height = static_cast<GLsizei>(c.height);\n  GLuint bucket_id = static_cast<GLuint>(c.bucket_id);\n  GLint border = static_cast<GLint>(c.border);\n\n  if (state_.bound_pixel_unpack_buffer.get()) {\n    return error::kInvalidArguments;\n  }\n  Bucket* bucket = GetBucket(bucket_id);\n  if (!bucket)\n    return error::kInvalidArguments;\n  uint32_t image_size = bucket->size();\n  const void* data = bucket->GetData(0, image_size);\n  DCHECK(data || !image_size);\n  return DoCompressedTexImage(target, level, internal_format, width, height, 1,\n                              border, image_size, data, ContextState::k2D);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 282
    },
    {
        "index": 115820,
        "code": "  virtual ~TestSafeBrowsingServiceFactory() { }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 13
    },
    {
        "index": 120134,
        "code": "void Layer::RemoveClipChild(Layer* child) {\n  clip_children_->erase(child);\n  if (clip_children_->empty())\n    clip_children_.reset();\n  SetNeedsCommit();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-2902",
        "length": 40
    },
    {
        "index": 85266,
        "code": "static struct page *get_current_nat_page(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tpgoff_t index = current_nat_addr(sbi, nid);\n\treturn get_meta_page(sbi, index);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-18249",
        "length": 48
    },
    {
        "index": 57163,
        "code": "static int nfs4_lookup_root_sec(struct nfs_server *server, struct nfs_fh *fhandle,\n\t\t\t\tstruct nfs_fsinfo *info, rpc_authflavor_t flavor)\n{\n\tstruct rpc_auth_create_args auth_args = {\n\t\t.pseudoflavor = flavor,\n\t};\n\tstruct rpc_auth *auth;\n\tint ret;\n\n\tauth = rpcauth_create(&auth_args, server->client);\n\tif (IS_ERR(auth)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = nfs4_lookup_root(server, fhandle, info);\nout:\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8746",
        "length": 121
    },
    {
        "index": 129579,
        "code": "void LayoutSVGContainer::removeChild(LayoutObject* child)\n{\n    SVGResourcesCache::clientWillBeRemovedFromTree(child);\n    LayoutSVGModelObject::removeChild(child);\n\n    bool hadNonIsolatedDescendants = (child->isBlendingAllowed() && child->style()->hasBlendMode()) || child->hasNonIsolatedBlendingDescendants();\n    if (hadNonIsolatedDescendants)\n        descendantIsolationRequirementsChanged(DescendantIsolationNeedsUpdate);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3167",
        "length": 100
    },
    {
        "index": 142401,
        "code": "void ShelfBackgroundAnimator::PaintBackground(\n    ShelfBackgroundType background_type,\n    AnimationChangeType change_type) {\n  if (target_background_type_ == background_type &&\n      change_type == AnimationChangeType::ANIMATE) {\n    return;\n  }\n\n  AnimateBackground(background_type, change_type);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 63
    },
    {
        "index": 50910,
        "code": "zisofs_free(struct archive_write *a)\n{\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2016-6250",
        "length": 26
    },
    {
        "index": 83582,
        "code": "static BOOL update_send_bitmap_update(rdpContext* context,\n                                      const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-8786",
        "length": 157
    },
    {
        "index": 124093,
        "code": "std::string ChromeContentBrowserClient::GetApplicationLocale() {\n  if (BrowserThread::CurrentlyOn(BrowserThread::IO))\n    return io_thread_application_locale_;\n  return g_browser_process->GetApplicationLocale();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0921",
        "length": 46
    },
    {
        "index": 62193,
        "code": "INT_PTR CALLBACK LicenseCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tlong style;\n\tHWND hLicense;\n\tswitch (message) {\n\tcase WM_INITDIALOG:\n\t\thLicense = GetDlgItem(hDlg, IDC_LICENSE_TEXT);\n\t\tapply_localization(IDD_LICENSE, hDlg);\n\t\tCenterDialog(hDlg);\n\t\tstyle = GetWindowLong(hLicense, GWL_EXSTYLE);\n\t\tstyle &= ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);\n\t\tSetWindowLong(hLicense, GWL_EXSTYLE, style);\n\t\tstyle = GetWindowLong(hLicense, GWL_STYLE);\n\t\tstyle &= ~(ES_RIGHT);\n\t\tSetWindowLong(hLicense, GWL_STYLE, style);\n\t\tSetDlgItemTextA(hDlg, IDC_LICENSE_TEXT, gplv3);\n\t\tbreak;\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam)) {\n\t\tcase IDOK:\n\t\tcase IDCANCEL:\n\t\t\treset_localization(IDD_LICENSE);\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t}\n\treturn (INT_PTR)FALSE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-494",
        "cve": "CVE-2017-13083",
        "length": 236
    },
    {
        "index": 157402,
        "code": "void HTMLMediaElement::SourceWasAdded(HTMLSourceElement* source) {\n  BLINK_MEDIA_LOG << \"sourceWasAdded(\" << (void*)this << \", \" << source << \")\";\n\n  KURL url = source->GetNonEmptyURLAttribute(srcAttr);\n  BLINK_MEDIA_LOG << \"sourceWasAdded(\" << (void*)this << \") - 'src' is \"\n                  << UrlForLoggingMedia(url);\n\n  if (FastHasAttribute(srcAttr))\n    return;\n\n  if (getNetworkState() == HTMLMediaElement::kNetworkEmpty) {\n    InvokeResourceSelectionAlgorithm();\n    next_child_node_to_consider_ = source;\n    return;\n  }\n\n  if (current_source_node_ && source == current_source_node_->nextSibling()) {\n    BLINK_MEDIA_LOG << \"sourceWasAdded(\" << (void*)this\n                    << \") - <source> inserted immediately after current source\";\n    next_child_node_to_consider_ = source;\n    return;\n  }\n\n  if (next_child_node_to_consider_)\n    return;\n\n  if (load_state_ != kWaitingForSource)\n    return;\n\n  SetShouldDelayLoadEvent(true);\n\n  SetNetworkState(kNetworkLoading);\n\n  next_child_node_to_consider_ = source;\n  ScheduleNextSourceChild();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2018-18352",
        "length": 265
    },
    {
        "index": 139184,
        "code": "void RenderProcessHostImpl::OnChannelConnected(int32_t peer_pid) {\n  channel_connected_ = true;\n  if (IsReady()) {\n    DCHECK(!sent_render_process_ready_);\n    sent_render_process_ready_ = true;\n    for (auto& observer : observers_)\n      observer.RenderProcessReady(this);\n  }\n\n#if defined(IPC_MESSAGE_LOG_ENABLED)\n  Send(new ChildProcessMsg_SetIPCLoggingEnabled(\n      IPC::Logging::GetInstance()->Enabled()));\n#endif\n\n  tracked_objects::ThreadData::Status status =\n      tracked_objects::ThreadData::status();\n  Send(new ChildProcessMsg_SetProfilerStatus(status));\n\n  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                          base::Bind(&AudioInputRendererHost::set_renderer_pid,\n                                     audio_input_renderer_host_, peer_pid));\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1265",
        "length": 165
    },
    {
        "index": 30133,
        "code": "ftrace_allocate_pages(unsigned long num_to_init)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\tint cnt;\n\n\tif (!num_to_init)\n\t\treturn 0;\n\n\tstart_pg = pg = kzalloc(sizeof(*pg), GFP_KERNEL);\n\tif (!pg)\n\t\treturn NULL;\n\n\t/*\n\t * Try to allocate as much as possible in one continues\n\t * location that fills in all of the space. We want to\n\t * waste as little space as possible.\n\t */\n\tfor (;;) {\n\t\tcnt = ftrace_allocate_records(pg, num_to_init);\n\t\tif (cnt < 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->next = kzalloc(sizeof(*pg), GFP_KERNEL);\n\t\tif (!pg->next)\n\t\t\tgoto free_pages;\n\n\t\tpg = pg->next;\n\t}\n\n\treturn start_pg;\n\n free_pages:\n\twhile (start_pg) {\n\t\torder = get_count_order(pg->size / ENTRIES_PER_PAGE);\n\t\tfree_pages((unsigned long)pg->records, order);\n\t\tstart_pg = pg->next;\n\t\tkfree(pg);\n\t\tpg = start_pg;\n\t}\n\tpr_info(\"ftrace: FAILED to allocate memory for functions\\n\");\n\treturn NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-3301",
        "length": 270
    },
    {
        "index": 90865,
        "code": "static int burl_normalize_basic_required_fix (buffer *b, buffer *t, int i, int qs)\n{\n    int j = i;\n    const int used = (int)buffer_string_length(b);\n    const unsigned char * const s = (unsigned char *)b->ptr;\n    unsigned char * const p =\n      (unsigned char *)buffer_string_prepare_copy(t,i+(used-i)*3+1);\n    unsigned int n1, n2;\n    memcpy(p, s, (size_t)i);\n    for (; i < used; ++i, ++j) {\n        if (!encoded_chars_http_uri_reqd[s[i]]) {\n            if (s[i] == '?' && -1 == qs) qs = j;\n            p[j] = s[i];\n        }\n        else if (s[i]=='%' && li_cton(s[i+1], n1) && li_cton(s[i+2], n2)) {\n            const unsigned int x = (n1 << 4) | n2;\n            if (!encoded_chars_http_uri_reqd[x]\n                && (qs < 0 ? (x!='/'&&x!='?') : (x!='&'&&x!='='&&x!=';'))) {\n                p[j] = x;\n            }\n            else {\n                p[j]   = '%';\n                p[++j] = hex_chars_uc[n1]; /*(s[i+1] & 0xdf)*/\n                p[++j] = hex_chars_uc[n2]; /*(s[i+2] & 0xdf)*/\n                if (li_utf8_invalid_byte(x)) qs = -2;\n            }\n            i+=2;\n        }\n        else if (s[i] == '#') break; /* ignore fragment */\n        else {\n            p[j]   = '%';\n            p[++j] = hex_chars_uc[(s[i] >> 4) & 0xF];\n            p[++j] = hex_chars_uc[s[i] & 0xF];\n            if (li_utf8_invalid_byte(s[i])) qs = -2;\n        }\n    }\n    buffer_commit(t, (size_t)j);\n    buffer_copy_buffer(b, t);\n    return qs;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-190",
        "cve": "CVE-2019-11072",
        "length": 456
    },
    {
        "index": 93098,
        "code": "sec_disconnect(void)\n{\n\t/* Perform a User-initiated disconnect sequence, see\n\t   [MS-RDPBCGR] 1.3.1.4 Disconnect Sequences */\n\tmcs_disconnect(RN_USER_REQUESTED);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2018-20182",
        "length": 48
    },
    {
        "index": 36889,
        "code": "long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan,\n\t\t     int nid)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_walk_node(&sb->s_inode_lru, nid, inode_lru_isolate,\n\t\t\t\t       &freeable, &nr_to_scan);\n\tdispose_list(&freeable);\n\treturn freed;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2014-4014",
        "length": 78
    },
    {
        "index": 9508,
        "code": "step_time(double offset)\n{\n\tllist_t *item;\n\tdouble dtime;\n\tstruct timeval tvc, tvn;\n\tchar buf[sizeof(\"yyyy-mm-dd hh:mm:ss\") + /*paranoia:*/ 4];\n\ttime_t tval;\n\n\tgettimeofday(&tvc, NULL); /* never fails */\n\tdtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;\n\td_to_tv(dtime, &tvn);\n\tif (settimeofday(&tvn, NULL) == -1)\n\t\tbb_perror_msg_and_die(\"settimeofday\");\n\n\tVERB2 {\n\t\ttval = tvc.tv_sec;\n\t\tstrftime_YYYYMMDDHHMMSS(buf, sizeof(buf), &tval);\n\t\tbb_error_msg(\"current time is %s.%06u\", buf, (unsigned)tvc.tv_usec);\n\t}\n\ttval = tvn.tv_sec;\n\tstrftime_YYYYMMDDHHMMSS(buf, sizeof(buf), &tval);\n\tbb_error_msg(\"setting time to %s.%06u (offset %+fs)\", buf, (unsigned)tvn.tv_usec, offset);\n\n\t/* Correct various fields which contain time-relative values: */\n\n\t/* Globals: */\n\tG.cur_time += offset;\n\tG.last_update_recv_time += offset;\n\tG.last_script_run += offset;\n\n\t/* p->lastpkt_recv_time, p->next_action_time and such: */\n\tfor (item = G.ntp_peers; item != NULL; item = item->link) {\n\t\tpeer_t *pp = (peer_t *) item->data;\n\t\treset_peer_stats(pp, offset);\n\t\tpp->next_action_time += offset;\n\t\tif (pp->p_fd >= 0) {\n\t\t\t/* We wait for reply from this peer too.\n\t\t\t * But due to step we are doing, reply's data is no longer\n\t\t\t * useful (in fact, it'll be bogus). Stop waiting for it.\n\t\t\t */\n\t\t\tclose(pp->p_fd);\n\t\t\tpp->p_fd = -1;\n\t\t\tset_next(pp, RETRY_INTERVAL);\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-6301",
        "length": 437
    },
    {
        "index": 104232,
        "code": "static bool ValueInArray(GLint value, GLint* array, GLint count) {\n  for (GLint ii = 0; ii < count; ++ii) {\n    if (array[ii] == value) {\n      return true;\n    }\n  }\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2011-2858",
        "length": 59
    },
    {
        "index": 157995,
        "code": "void RenderViewImpl::SetValidationMessageDirection(\n    base::string16* wrapped_main_text,\n    blink::WebTextDirection main_text_hint,\n    base::string16* wrapped_sub_text,\n    blink::WebTextDirection sub_text_hint) {\n  if (main_text_hint == blink::kWebTextDirectionLeftToRight) {\n    *wrapped_main_text =\n        base::i18n::GetDisplayStringInLTRDirectionality(*wrapped_main_text);\n  } else if (main_text_hint == blink::kWebTextDirectionRightToLeft &&\n             !base::i18n::IsRTL()) {\n    base::i18n::WrapStringWithRTLFormatting(wrapped_main_text);\n  }\n\n  if (!wrapped_sub_text->empty()) {\n    if (sub_text_hint == blink::kWebTextDirectionLeftToRight) {\n      *wrapped_sub_text =\n          base::i18n::GetDisplayStringInLTRDirectionality(*wrapped_sub_text);\n    } else if (sub_text_hint == blink::kWebTextDirectionRightToLeft) {\n      base::i18n::WrapStringWithRTLFormatting(wrapped_sub_text);\n    }\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2018-20067",
        "length": 238
    },
    {
        "index": 124289,
        "code": "ExtensionInfoMap* ExtensionSystemImpl::Shared::info_map() {\n  if (!extension_info_map_)\n    extension_info_map_ = new ExtensionInfoMap();\n  return extension_info_map_.get();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-0924",
        "length": 42
    },
    {
        "index": 30,
        "code": "void free_list(struct name_list *names)\n{\n\tstruct name_list *next;\n\n\twhile (names) {\n\t\tnext = names->next;\n\t\tfree(names);\n\t\tnames = next;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2009-4411",
        "length": 41
    },
    {
        "index": 152538,
        "code": "int RenderFrameImpl::ShowContextMenu(ContextMenuClient* client,\n                                     const ContextMenuParams& params) {\n  DCHECK(client);  // A null client means \"internal\" when we issue callbacks.\n  ContextMenuParams our_params(params);\n\n  blink::WebRect position_in_window(params.x, params.y, 0, 0);\n  GetLocalRootRenderWidget()->ConvertViewportToWindow(&position_in_window);\n  our_params.x = position_in_window.x;\n  our_params.y = position_in_window.y;\n\n  our_params.custom_context.request_id = pending_context_menus_.Add(client);\n  Send(new FrameHostMsg_ContextMenu(routing_id_, our_params));\n  return our_params.custom_context.request_id;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-5019",
        "length": 145
    },
    {
        "index": 86284,
        "code": "static void net_free(struct net *net)\n{\n\tkfree(rcu_access_pointer(net->gen));\n\tkmem_cache_free(net_cachep, net);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2017-15129",
        "length": 32
    },
    {
        "index": 139735,
        "code": "int ResourceFetcher::NonblockingRequestCount() const {\n  return non_blocking_loaders_.size();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 22
    },
    {
        "index": 115215,
        "code": "void OmniboxViewWin::HandleKeystroke(UINT message,\n                                     TCHAR key,\n                                     UINT repeat_count,\n                                     UINT flags) {\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  OnBeforePossibleChange();\n\n  if (key == ui::VKEY_HOME || key == ui::VKEY_END) {\n    HKL layout = GetKeyboardLayout(0);\n    DefWindowProc(message, key, MAKELPARAM(repeat_count, flags));\n    ActivateKeyboardLayout(layout, KLF_REORDER);\n  } else {\n    DefWindowProc(message, key, MAKELPARAM(repeat_count, flags));\n  }\n\n  const int lang_options = SendMessage(EM_GETLANGOPTIONS, 0, 0);\n  if (lang_options & IMF_AUTOKEYBOARD)\n    SendMessage(EM_SETLANGOPTIONS, 0, lang_options & ~IMF_AUTOKEYBOARD);\n\n  OnAfterPossibleChange();\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2011-3964",
        "length": 186
    },
    {
        "index": 72457,
        "code": "static void row_prop_write(zval *object, zval *member, zval *value, const zend_literal *key TSRMLS_DC)\n{\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"This PDORow is not from a writable result set\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2016-9934",
        "length": 56
    },
    {
        "index": 159846,
        "code": "GURL TopSitesCache::GetGeneralizedCanonicalURL(const GURL& url) const {\n  CanonicalURLs::const_iterator it_hi =\n      canonical_urls_.lower_bound(CanonicalURLQuery(url).entry());\n  if (it_hi != canonical_urls_.end()) {\n    if (url.ReplaceComponents(clear_query_ref_) ==\n        GetURLFromIterator(it_hi).ReplaceComponents(clear_query_ref_)) {\n      return it_hi->first.first->url;\n    }\n  }\n\n  GURL base_url(url.ReplaceComponents(clear_path_query_ref_));\n  CanonicalURLs::const_iterator it_lo =\n      canonical_urls_.lower_bound(CanonicalURLQuery(base_url).entry());\n  if (it_lo == canonical_urls_.end())\n    return GURL::EmptyGURL();\n  GURL compare_url_lo(GetURLFromIterator(it_lo));\n  if (!HaveSameSchemeHostAndPort(base_url, compare_url_lo) ||\n      !IsPathPrefix(base_url.path(), compare_url_lo.path())) {\n    return GURL::EmptyGURL();\n  }\n\n  for (CanonicalURLs::const_iterator it = it_hi; it != it_lo;) {\n    --it;\n    GURL compare_url(GetURLFromIterator(it));\n    DCHECK(HaveSameSchemeHostAndPort(compare_url, url));\n    if (IsPathPrefix(compare_url.path(), url.path()))\n      return it->first.first->url;\n  }\n\n  return GURL::EmptyGURL();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-6053",
        "length": 291
    },
    {
        "index": 130683,
        "code": "static void conditionalAttr2AttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectV8Internal::conditionalAttr2AttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 79
    },
    {
        "index": 43364,
        "code": "void CLASS read_shorts (ushort *pixel, unsigned count)\n{\n  if (fread (pixel, 2, count, ifp) < count) derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab ((const char *)pixel, (char *)pixel, count*2); /*mingw support UF*/\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2015-3885",
        "length": 91
    },
    {
        "index": 151278,
        "code": "void InspectorPageAgent::searchInResource(\n    const String& frame_id,\n    const String& url,\n    const String& query,\n    Maybe<bool> optional_case_sensitive,\n    Maybe<bool> optional_is_regex,\n    std::unique_ptr<SearchInResourceCallback> callback) {\n  if (!enabled_) {\n    callback->sendFailure(Response::Error(\"Agent is not enabled.\"));\n    return;\n  }\n  inspector_resource_content_loader_->EnsureResourcesContentLoaded(\n      resource_content_loader_client_id_,\n      WTF::Bind(&InspectorPageAgent::SearchContentAfterResourcesContentLoaded,\n                WrapPersistent(this), frame_id, url, query,\n                optional_case_sensitive.fromMaybe(false),\n                optional_is_regex.fromMaybe(false),\n                WTF::Passed(std::move(callback))));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5009",
        "length": 154
    },
    {
        "index": 89844,
        "code": "write_ruleset_details(int s)\n{\n\tint proto = 0;\n\tunsigned short eport, iport;\n\tchar desc[64];\n\tchar iaddr[32];\n\tchar rhost[32];\n\tunsigned int timestamp;\n\tu_int64_t packets;\n\tu_int64_t bytes;\n\tint i = 0;\n\tchar buffer[256];\n\tint n;\n\n\twrite(s, \"Ruleset :\\n\", 10);\n\twhile(get_redirect_rule_by_index(i, 0/*ifname*/, &eport, iaddr, sizeof(iaddr),\n\t                                 &iport, &proto, desc, sizeof(desc),\n\t                                 rhost, sizeof(rhost),\n\t                                 &timestamp,\n\t                                 &packets, &bytes) >= 0)\n\t{\n\t\tn = snprintf(buffer, sizeof(buffer),\n\t\t             \"%2d %s %s:%hu->%s:%hu \"\n\t\t             \"'%s' %u %\" PRIu64 \" %\" PRIu64 \"\\n\",\n\t\t             /*\"'%s' %llu %llu\\n\",*/\n\t\t             i, proto_itoa(proto), rhost,\n\t\t             eport, iaddr, iport, desc, timestamp, packets, bytes);\n\t\twrite(s, buffer, n);\n\t\ti++;\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12110",
        "length": 251
    },
    {
        "index": 90250,
        "code": "static void setup_dell_poweredge_oem_data_handler(struct smi_info *smi_info)\n{\n\tstruct ipmi_device_id *id = &smi_info->device_id;\n\tif (id->manufacturer_id == DELL_IANA_MFR_ID) {\n\t\tif (id->device_id       == DELL_POWEREDGE_8G_BMC_DEVICE_ID  &&\n\t\t    id->device_revision == DELL_POWEREDGE_8G_BMC_DEVICE_REV &&\n\t\t    id->ipmi_version   == DELL_POWEREDGE_8G_BMC_IPMI_VERSION) {\n\t\t\tsmi_info->oem_data_avail_handler =\n\t\t\t\toem_data_avail_to_receive_msg_avail;\n\t\t} else if (ipmi_version_major(id) < 1 ||\n\t\t\t   (ipmi_version_major(id) == 1 &&\n\t\t\t    ipmi_version_minor(id) < 5)) {\n\t\t\tsmi_info->oem_data_avail_handler =\n\t\t\t\toem_data_avail_to_receive_msg_avail;\n\t\t}\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-11811",
        "length": 204
    },
    {
        "index": 158174,
        "code": "std::unique_ptr<NavigationRequestInfo> CreateNavigationRequestInfoForRedirect(\n    const NavigationRequestInfo& previous_request_info,\n    const network::ResourceRequest& updated_resource_request) {\n  DCHECK(!base::FeatureList::IsEnabled(network::features::kNetworkService));\n  DCHECK(IsLoaderInterceptionEnabled());\n\n  CommonNavigationParams new_common_params =\n      previous_request_info.common_params;\n  new_common_params.url = updated_resource_request.url;\n  new_common_params.referrer =\n      Referrer(updated_resource_request.referrer,\n               Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                   updated_resource_request.referrer_policy));\n  new_common_params.method = updated_resource_request.method;\n  new_common_params.post_data = updated_resource_request.request_body;\n\n  mojom::BeginNavigationParamsPtr new_begin_params =\n      previous_request_info.begin_params.Clone();\n  new_begin_params->headers = updated_resource_request.headers.ToString();\n\n  return std::make_unique<NavigationRequestInfo>(\n      std::move(new_common_params), std::move(new_begin_params),\n      updated_resource_request.site_for_cookies,\n      previous_request_info.is_main_frame,\n      previous_request_info.parent_is_main_frame,\n      previous_request_info.are_ancestors_secure,\n      previous_request_info.frame_tree_node_id,\n      previous_request_info.is_for_guests_only,\n      previous_request_info.report_raw_headers,\n      previous_request_info.is_prerendering,\n      previous_request_info.upgrade_if_insecure,\n      nullptr /* blob_url_loader_factory */,\n      previous_request_info.devtools_navigation_token,\n      previous_request_info.devtools_frame_token);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-20068",
        "length": 323
    },
    {
        "index": 151791,
        "code": "BackgroundLoaderOffliner::GetVisibleSecurityState(\n    content::WebContents* web_contents) {\n  SecurityStateTabHelper::CreateForWebContents(web_contents);\n  SecurityStateTabHelper* helper =\n      SecurityStateTabHelper::FromWebContents(web_contents);\n  DCHECK(helper);\n  return helper->GetVisibleSecurityState();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5014",
        "length": 68
    },
    {
        "index": 62246,
        "code": "bgp_header_print(netdissect_options *ndo,\n                 const u_char *dat, int length)\n{\n\tstruct bgp bgp;\n\n\tND_TCHECK2(dat[0], BGP_SIZE);\n\tmemcpy(&bgp, dat, BGP_SIZE);\n\tND_PRINT((ndo, \"\\n\\t%s Message (%u), length: %u\",\n               tok2str(bgp_msg_values, \"Unknown\", bgp.bgp_type),\n               bgp.bgp_type,\n               length));\n\n\tswitch (bgp.bgp_type) {\n\tcase BGP_OPEN:\n\t\tbgp_open_print(ndo, dat, length);\n\t\tbreak;\n\tcase BGP_UPDATE:\n\t\tbgp_update_print(ndo, dat, length);\n\t\tbreak;\n\tcase BGP_NOTIFICATION:\n\t\tbgp_notification_print(ndo, dat, length);\n\t\tbreak;\n        case BGP_KEEPALIVE:\n                break;\n        case BGP_ROUTE_REFRESH:\n                bgp_route_refresh_print(ndo, dat, length);\n                break;\n        default:\n                /* we have no decoder for the BGP message */\n                ND_TCHECK2(*dat, length);\n                ND_PRINT((ndo, \"\\n\\t  no Message %u decoder\", bgp.bgp_type));\n                print_unknown_data(ndo, dat, \"\\n\\t  \", length);\n                break;\n\t}\n\treturn 1;\ntrunc:\n\tND_PRINT((ndo, \"[|BGP]\"));\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2017-13053",
        "length": 295
    },
    {
        "index": 89777,
        "code": "handle_die_with_parent (void)\n{\n  if (opt_die_with_parent && prctl (PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0) != 0)\n    die_with_error (\"prctl\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2019-12439",
        "length": 53
    },
    {
        "index": 175903,
        "code": "void smp_br_check_authorization_request(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s rcvs i_keys=0x%x r_keys=0x%x (i-initiator r-responder)\",\n                  __func__, p_cb->local_i_key, p_cb->local_r_key);\n\n /* In LE SC mode LK field is ignored when BR/EDR transport is used */\n  p_cb->local_i_key &= ~SMP_SEC_KEY_TYPE_LK;\n  p_cb->local_r_key &= ~SMP_SEC_KEY_TYPE_LK;\n\n /* In LE SC mode only IRK, IAI, CSRK are exchanged with the peer.\n  ** Set local_r_key on master to expect only these keys. */\n if (p_cb->role == HCI_ROLE_MASTER) {\n    p_cb->local_r_key &= (SMP_SEC_KEY_TYPE_ID | SMP_SEC_KEY_TYPE_CSRK);\n }\n\n /* Check if H7 function needs to be used for key derivation*/\n if ((p_cb->loc_auth_req & SMP_H7_SUPPORT_BIT) &&\n (p_cb->peer_auth_req & SMP_H7_SUPPORT_BIT)) {\n    p_cb->key_derivation_h7_used = TRUE;\n }\n  SMP_TRACE_DEBUG(\"%s: use h7 = %d\", __func__, p_cb->key_derivation_h7_used);\n\n  SMP_TRACE_DEBUG(\n \"%s rcvs upgrades: i_keys=0x%x r_keys=0x%x (i-initiator r-responder)\",\n      __func__, p_cb->local_i_key, p_cb->local_r_key);\n\n if (/*((p_cb->peer_auth_req & SMP_AUTH_BOND) ||\n          (p_cb->loc_auth_req & SMP_AUTH_BOND)) &&*/\n (p_cb->local_i_key || p_cb->local_r_key)) {\n    smp_br_state_machine_event(p_cb, SMP_BR_BOND_REQ_EVT, NULL);\n\n /* if no peer key is expected, start master key distribution */\n if (p_cb->role == HCI_ROLE_MASTER && p_cb->local_r_key == 0)\n      smp_key_distribution_by_transport(p_cb, NULL);\n } else {\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = SMP_SUCCESS;\n    smp_br_state_machine_event(p_cb, SMP_BR_AUTH_CMPL_EVT, &smp_int_data);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2018-9510",
        "length": 495
    },
    {
        "index": 133782,
        "code": "void SSLClientSocketOpenSSL::SetOmniboxSpeculation() {\n  if (transport_.get() && transport_->socket()) {\n    transport_->socket()->SetOmniboxSpeculation();\n  } else {\n    NOTREACHED();\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 53
    },
    {
        "index": 51036,
        "code": "const char *page_get_link(struct dentry *dentry, struct inode *inode,\n\t\t\t  struct delayed_call *callback)\n{\n\tchar *kaddr;\n\tstruct page *page;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tif (!dentry) {\n\t\tpage = find_get_page(mapping, 0);\n\t\tif (!page)\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\tif (!PageUptodate(page)) {\n\t\t\tput_page(page);\n\t\t\treturn ERR_PTR(-ECHILD);\n\t\t}\n\t} else {\n\t\tpage = read_mapping_page(mapping, 0, NULL);\n\t\tif (IS_ERR(page))\n\t\t\treturn (char*)page;\n\t}\n\tset_delayed_call(callback, page_put_link, page);\n\tBUG_ON(mapping_gfp_mask(mapping) & __GFP_HIGHMEM);\n\tkaddr = page_address(page);\n\tnd_terminate_link(kaddr, inode->i_size, PAGE_SIZE - 1);\n\treturn kaddr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-6198",
        "length": 196
    },
    {
        "index": 47584,
        "code": "static int ap_configuration_available(void)\n{\n\treturn test_facility(2) && test_facility(12);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2013-7421",
        "length": 24
    },
    {
        "index": 55065,
        "code": "static struct tree_content *dup_tree_content(struct tree_content *s)\n{\n\tstruct tree_content *d;\n\tstruct tree_entry *a, *b;\n\tunsigned int i;\n\n\tif (!s)\n\t\treturn NULL;\n\td = new_tree_content(s->entry_count);\n\tfor (i = 0; i < s->entry_count; i++) {\n\t\ta = s->entries[i];\n\t\tb = new_tree_entry();\n\t\tmemcpy(b, a, sizeof(*a));\n\t\tif (a->tree && is_null_sha1(b->versions[1].sha1))\n\t\t\tb->tree = dup_tree_content(a->tree);\n\t\telse\n\t\t\tb->tree = NULL;\n\t\td->entries[i] = b;\n\t}\n\td->entry_count = s->entry_count;\n\td->delta_depth = s->delta_depth;\n\n\treturn d;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2315",
        "length": 172
    },
    {
        "index": 137474,
        "code": "void RunLoop::AddNestingObserverOnCurrentThread(NestingObserver* observer) {\n  Delegate* delegate = tls_delegate.Get().Get();\n  DCHECK(delegate);\n  CHECK(delegate->allow_nesting_);\n  delegate->nesting_observers_.AddObserver(observer);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-1294",
        "length": 55
    },
    {
        "index": 68387,
        "code": "void perf_event_task_tick(void)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\tstruct perf_event_context *ctx, *tmp;\n\tint throttled;\n\n\tWARN_ON(!irqs_disabled());\n\n\t__this_cpu_inc(perf_throttled_seq);\n\tthrottled = __this_cpu_xchg(perf_throttled_count, 0);\n\ttick_dep_clear_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\n\tlist_for_each_entry_safe(ctx, tmp, head, active_ctx_list)\n\t\tperf_adjust_freq_unthr_context(ctx, throttled);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2017-6001",
        "length": 123
    },
    {
        "index": 65836,
        "code": "nfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_clientid, 8);\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_confirm,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\telse if (nfserr == nfserr_clid_inuse) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-404",
        "cve": "CVE-2017-9059",
        "length": 215
    },
    {
        "index": 23556,
        "code": " static int flakey_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\n\t\t\tstruct bio_vec *biovec, int max_size)\n{\n\tstruct flakey_c *fc = ti->private;\n\tstruct request_queue *q = bdev_get_queue(fc->dev->bdev);\n\n\tif (!q->merge_bvec_fn)\n\t\treturn max_size;\n\n\tbvm->bi_bdev = fc->dev->bdev;\n\tbvm->bi_sector = flakey_map_sector(ti, bvm->bi_sector);\n\n\treturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2011-4127",
        "length": 131
    },
    {
        "index": 15337,
        "code": "static void php_xmlwriter_string_arg(INTERNAL_FUNCTION_PARAMETERS, xmlwriter_read_one_char_t internal_function, char *err_string)\n{\n\tzval *pind;\n\txmlwriter_object *intern;\n\txmlTextWriterPtr ptr;\n\tchar *name;\n\tint name_len, retval;\n\n#ifdef ZEND_ENGINE_2\n\tzval *this = getThis();\n\t\n\tif (this) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &name, &name_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tXMLWRITER_FROM_OBJECT(intern, this);\n\t} else\n#endif\n\t{\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &pind, &name, &name_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tZEND_FETCH_RESOURCE(intern,xmlwriter_object *, &pind, -1, \"XMLWriter\", le_xmlwriter);\n\t}\n\n\tif (err_string != NULL) {\n\t\tXMLW_NAME_CHK(err_string);\n\t}\n\n\tptr = intern->ptr;\n\n\tif (ptr) {\n\t\tretval = internal_function(ptr, (xmlChar *) name);\n\t\tif (retval != -1) {\n\t\t\tRETURN_TRUE;\n\t\t}\n\t}\n\t\n\tRETURN_FALSE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-254",
        "cve": "CVE-2015-3412",
        "length": 263
    },
    {
        "index": 64882,
        "code": "static int ok_to_move_to_unc(struct rle_context *rlectx)\n{\n\n\tif(rlectx->unc_len==0) {\n\t\treturn (rlectx->run_len<4);\n\t}\n\telse if(rlectx->unc_len<=2) {\n\t\treturn (rlectx->run_len<6);\n\t}\n\telse {\n\t\treturn (rlectx->run_len<8);\n\t}\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2017-9203",
        "length": 90
    },
    {
        "index": 135573,
        "code": "void Editor::Paste(EditorCommandSource source) {\n  DCHECK(GetFrame().GetDocument());\n  if (TryDHTMLPaste(kAllMimeTypes))\n    return;  // DHTML did the whole operation\n  if (!CanPaste())\n    return;\n\n  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();\n\n  if (source == kCommandFromMenuOrKeyBinding &&\n      !GetFrame().Selection().SelectionHasFocus())\n    return;\n\n  GetSpellChecker().UpdateMarkersForWordsAffectedByEditing(false);\n  ResourceFetcher* loader = GetFrame().GetDocument()->Fetcher();\n  ResourceCacheValidationSuppressor validation_suppressor(loader);\n\n  const PasteMode paste_mode = CanEditRichly() ? kAllMimeTypes : kPlainTextOnly;\n\n  if (source == kCommandFromMenuOrKeyBinding) {\n    DataTransfer* data_transfer =\n        DataTransfer::Create(DataTransfer::kCopyAndPaste, kDataTransferReadable,\n                             DataObject::CreateFromPasteboard(paste_mode));\n\n    if (DispatchBeforeInputDataTransfer(FindEventTargetFromSelection(),\n                                        InputEvent::InputType::kInsertFromPaste,\n                                        data_transfer) !=\n        DispatchEventResult::kNotCanceled)\n      return;\n    if (frame_->GetDocument()->GetFrame() != frame_)\n      return;\n  }\n\n  if (paste_mode == kAllMimeTypes)\n    PasteWithPasteboard(Pasteboard::GeneralPasteboard());\n  else\n    PasteAsPlainTextWithPasteboard(Pasteboard::GeneralPasteboard());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-6773",
        "length": 316
    },
    {
        "index": 143744,
        "code": " ShellContentUtilityClient::~ShellContentUtilityClient() {\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-1630",
        "length": 13
    },
    {
        "index": 97539,
        "code": "void ProfileSyncComponentsFactoryImpl::RegisterDataTypes(\n    ProfileSyncService* pss) {\n  RegisterCommonDataTypes(pss);\n#if !defined(OS_ANDROID)\n  RegisterDesktopDataTypes(pss);\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 46
    },
    {
        "index": 17050,
        "code": "OxideQQuickWebViewAttached::OxideQQuickWebViewAttached(QObject* parent) :\n    QObject(parent),\n    view_(nullptr) {}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-1586",
        "length": 31
    },
    {
        "index": 119122,
        "code": "int GetLastYear() {\n  Time last_year_time = Time::NowFromSystemTime() - TimeDelta::FromDays(365);\n  Time::Exploded exploded;\n  last_year_time.LocalExplode(&exploded);\n  return exploded.year;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2013-6630",
        "length": 53
    },
    {
        "index": 19847,
        "code": "static void nfs41_call_sync_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs41_call_sync_data *data = calldata;\n\n\tdprintk(\"--> %s data->seq_server %p\\n\", __func__, data->seq_server);\n\n\tif (nfs4_setup_sequence(data->seq_server, data->seq_args,\n\t\t\t\tdata->seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2012-2375",
        "length": 90
    },
    {
        "index": 500,
        "code": "static void pdf_run_Tf(fz_context *ctx, pdf_processor *proc, const char *name, pdf_font_desc *font, float size)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_drop_font(ctx, gstate->text.font);\n\tgstate->text.font = pdf_keep_font(ctx, font);\n\tgstate->text.size = size;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-1000039",
        "length": 99
    },
    {
        "index": 114241,
        "code": "void CommandBufferProxyImpl::SetOnConsoleMessageCallback(\n    const GpuConsoleMessageCallback& callback) {\n  console_message_callback_ = callback;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2816",
        "length": 33
    },
    {
        "index": 115695,
        "code": "void HostNPScriptObject::OnSignallingConnected(SignalStrategy* signal_strategy,\n                                               const std::string& full_jid) {\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 31
    },
    {
        "index": 131341,
        "code": "static void deprecatedLongAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"deprecatedLongAttribute\", \"TestObjectPython\", info.Holder(), info.GetIsolate());\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);\n    imp->setDeprecatedLongAttribute(cppValue);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 118
    },
    {
        "index": 42350,
        "code": "int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)\n{\n\tstruct inode *target = dentry->d_inode;\n\tint error = may_delete(dir, dentry, 0);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->unlink)\n\t\treturn -EPERM;\n\n\tmutex_lock(&target->i_mutex);\n\tif (is_local_mountpoint(dentry))\n\t\terror = -EBUSY;\n\telse {\n\t\terror = security_inode_unlink(dir, dentry);\n\t\tif (!error) {\n\t\t\terror = try_break_deleg(target, delegated_inode);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\terror = dir->i_op->unlink(dir, dentry);\n\t\t\tif (!error) {\n\t\t\t\tdont_mount(dentry);\n\t\t\t\tdetach_mounts(dentry);\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&target->i_mutex);\n\n\t/* We don't d_delete() NFS sillyrenamed files--they still exist. */\n\tif (!error && !(dentry->d_flags & DCACHE_NFSFS_RENAMED)) {\n\t\tfsnotify_link_count(target);\n\t\td_delete(dentry);\n\t}\n\n\treturn error;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-5706",
        "length": 252
    },
    {
        "index": 50017,
        "code": "archive_read_format_capabilities(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tif (a && a->format && a->format->format_capabilties) {\n\t\treturn (a->format->format_capabilties)(a);\n\t}\n\treturn ARCHIVE_READ_FORMAT_CAPS_NONE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-7166",
        "length": 71
    },
    {
        "index": 153689,
        "code": "bool GLES2Implementation::GetInteger64i_vHelper(GLenum pname,\n                                                GLuint index,\n                                                GLint64* data) {\n  return false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 32
    },
    {
        "index": 187719,
        "code": "standard_display_init(standard_display *dp, png_store* ps, png_uint_32 id,\n int do_interlace, int use_update_info)\n{\n   memset(dp, 0, sizeof *dp);\n\n   dp->ps = ps;\n   dp->colour_type = COL_FROM_ID(id);\n   dp->bit_depth = DEPTH_FROM_ID(id);\n if (dp->bit_depth < 1 || dp->bit_depth > 16)\n      internal_error(ps, \"internal: bad bit depth\");\n if (dp->colour_type == 3)\n      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT = 8;\n else\n      dp->red_sBIT = dp->blue_sBIT = dp->green_sBIT = dp->alpha_sBIT =\n         dp->bit_depth;\n   dp->interlace_type = INTERLACE_FROM_ID(id);\n   check_interlace_type(dp->interlace_type);\n   dp->id = id;\n /* All the rest are filled in after the read_info: */\n   dp->w = 0;\n   dp->h = 0;\n   dp->npasses = 0;\n   dp->pixel_size = 0;\n\n    dp->bit_width = 0;\n    dp->cbRow = 0;\n    dp->do_interlace = do_interlace;\n    dp->is_transparent = 0;\n    dp->speed = ps->speed;\n    dp->use_update_info = use_update_info;\n   dp->npalette = 0;\n /* Preset the transparent color to black: */\n   memset(&dp->transparent, 0, sizeof dp->transparent);\n /* Preset the palette to full intensity/opaque througout: */\n   memset(dp->palette, 0xff, sizeof dp->palette);\n}\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": "CVE-2016-3751",
        "length": 378
    },
    {
        "index": 122583,
        "code": "void WebDevToolsAgentImpl::setTouchEventEmulationEnabled(bool enabled)\n{\n    m_client->setTouchEventEmulationEnabled(enabled, m_emulateViewportEnabled);\n    m_touchEventEmulationEnabled = enabled;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-0884",
        "length": 45
    },
    {
        "index": 11243,
        "code": "static int php_snmp_write_info(php_snmp_object *snmp_object, zval *newval)\n{\n\tphp_error_docref(NULL, E_WARNING, \"info property is read-only\");\n\treturn FAILURE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-4071",
        "length": 46
    },
    {
        "index": 166145,
        "code": "void RenderFrameHostImpl::OnDocumentOnLoadCompleted() {\n  delegate_->DocumentOnLoadCompleted(this);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2019-5755",
        "length": 24
    },
    {
        "index": 165928,
        "code": "void RenderFrameImpl::PrepareFrameForCommit(\n    const GURL& url,\n    const RequestNavigationParams& request_params) {\n  browser_side_navigation_pending_ = false;\n  browser_side_navigation_pending_url_ = GURL();\n  sync_navigation_callback_.Cancel();\n\n  GetContentClient()->SetActiveURL(\n      url, frame_->Top()->GetSecurityOrigin().ToString().Utf8());\n\n  RenderFrameImpl::PrepareRenderViewForNavigation(url, request_params);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2019-5759",
        "length": 93
    },
    {
        "index": 73215,
        "code": "static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tFILE *fp;\n\tfp = JAS_CAST(FILE *, obj);\n\treturn fwrite(buf, 1, cnt, fp);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-415",
        "cve": "CVE-2016-8693",
        "length": 47
    },
    {
        "index": 105632,
        "code": "std::string SessionManager::url_base() const {\n  return url_base_;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-2802",
        "length": 18
    },
    {
        "index": 118226,
        "code": "int AutofillDialogViews::GetDialogButtons() const {\n  return delegate_->GetDialogButtons();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2013-6636",
        "length": 22
    },
    {
        "index": 72257,
        "code": "pubkey_cleanup(Authctxt *authctxt)\n{\n\tIdentity *id;\n\n\tif (authctxt->agent_fd != -1)\n\t\tssh_close_authentication_socket(authctxt->agent_fd);\n\tfor (id = TAILQ_FIRST(&authctxt->keys); id;\n\t    id = TAILQ_FIRST(&authctxt->keys)) {\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tsshkey_free(id->key);\n\t\tfree(id->filename);\n\t\tfree(id);\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10012",
        "length": 106
    },
    {
        "index": 113756,
        "code": "void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n    const PrintHostMsg_DidPreviewDocument_Params& params) {\n  StopWorker(params.document_cookie);\n\n  if (params.expected_pages_count <= 0) {\n    NOTREACHED();\n    return;\n  }\n\n  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n  if (!print_preview_ui)\n    return;\n\n  if (params.reuse_existing_data) {\n    PrintHostMsg_DidGetPreviewPageCount_Params temp_params;\n    temp_params.page_count = params.expected_pages_count;\n    temp_params.document_cookie = params.document_cookie;\n    temp_params.is_modifiable = params.modifiable;\n    temp_params.preview_request_id = params.preview_request_id;\n    print_preview_ui->OnDidGetPreviewPageCount(temp_params);\n    print_preview_ui->OnReusePreviewData(params.preview_request_id);\n    return;\n  }\n\n  base::RefCountedBytes* data_bytes =\n      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n  if (!data_bytes)\n    return;\n\n  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n                                                data_bytes);\n  print_preview_ui->OnPreviewDataIsAvailable(\n      params.expected_pages_count, params.preview_request_id);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 260
    },
    {
        "index": 50540,
        "code": "void update_perf_cpu_limits(void)\n{\n\tu64 tmp = perf_sample_period_ns;\n\n\ttmp *= sysctl_perf_cpu_time_max_percent;\n\tdo_div(tmp, 100);\n\tACCESS_ONCE(perf_sample_allowed_ns) = tmp;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-6787",
        "length": 48
    },
    {
        "index": 38347,
        "code": "static int cm_apr_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_apr_msg *apr_msg;\n\tint ret;\n\n\tapr_msg = (struct cm_apr_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(apr_msg->remote_comm_id,\n\t\t\t\t   apr_msg->local_comm_id);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL; /* Unmatched reply. */\n\n\twork->cm_event.param.apr_rcvd.ap_status = apr_msg->ap_status;\n\twork->cm_event.param.apr_rcvd.apr_info = &apr_msg->info;\n\twork->cm_event.param.apr_rcvd.info_len = apr_msg->info_length;\n\twork->cm_event.private_data = &apr_msg->private_data;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_ESTABLISHED ||\n\t    (cm_id_priv->id.lap_state != IB_CM_LAP_SENT &&\n\t     cm_id_priv->id.lap_state != IB_CM_MRA_LAP_RCVD)) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.lap_state = IB_CM_LAP_IDLE;\n\tib_cancel_mad(cm_id_priv->av.port->mad_agent, cm_id_priv->msg);\n\tcm_id_priv->msg = NULL;\n\n\tret = atomic_inc_and_test(&cm_id_priv->work_count);\n\tif (!ret)\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tif (ret)\n\t\tcm_process_work(cm_id_priv, work);\n\telse\n\t\tcm_deref_id(cm_id_priv);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2014-2739",
        "length": 378
    },
    {
        "index": 35877,
        "code": "struct sctp_chunk *sctp_make_shutdown_complete(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t/* Set the T-bit if we have no association (vtag will be\n\t * reflected)\n\t */\n\tflags |= asoc ? 0 : SCTP_CHUNK_FLAG_T;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [Report SHUTDOWN COMPLETE back to where the SHUTDOWN ACK\n\t * came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-7841",
        "length": 224
    },
    {
        "index": 154235,
        "code": "error::Error GLES2DecoderImpl::HandleGetProgramResourceName(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  return error::kUnknownCommand;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2016-5219",
        "length": 41
    },
    {
        "index": 54070,
        "code": "static u32 inet_addr_hash(const struct net *net, __be32 addr)\n{\n\tu32 val = (__force u32) addr ^ net_hash_mix(net);\n\n\treturn hash_32(val, IN4_ADDR_HSIZE_SHIFT);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2016-3156",
        "length": 49
    },
    {
        "index": 144389,
        "code": "std::string ExtensionInstallPrompt::PromptTypeToString(PromptType type) {\n  switch (type) {\n    case ExtensionInstallPrompt::INSTALL_PROMPT:\n      return \"INSTALL_PROMPT\";\n    case ExtensionInstallPrompt::INLINE_INSTALL_PROMPT:\n      return \"INLINE_INSTALL_PROMPT\";\n    case ExtensionInstallPrompt::BUNDLE_INSTALL_PROMPT:\n      return \"BUNDLE_INSTALL_PROMPT\";\n    case ExtensionInstallPrompt::RE_ENABLE_PROMPT:\n      return \"RE_ENABLE_PROMPT\";\n    case ExtensionInstallPrompt::PERMISSIONS_PROMPT:\n      return \"PERMISSIONS_PROMPT\";\n    case ExtensionInstallPrompt::EXTERNAL_INSTALL_PROMPT:\n      return \"EXTERNAL_INSTALL_PROMPT\";\n    case ExtensionInstallPrompt::POST_INSTALL_PERMISSIONS_PROMPT:\n      return \"POST_INSTALL_PERMISSIONS_PROMPT\";\n    case ExtensionInstallPrompt::REMOTE_INSTALL_PROMPT:\n      return \"REMOTE_INSTALL_PROMPT\";\n    case ExtensionInstallPrompt::REPAIR_PROMPT:\n      return \"REPAIR_PROMPT\";\n    case ExtensionInstallPrompt::DELEGATED_PERMISSIONS_PROMPT:\n      return \"DELEGATED_PERMISSIONS_PROMPT\";\n    case ExtensionInstallPrompt::DELEGATED_BUNDLE_PERMISSIONS_PROMPT:\n      return \"DELEGATED_BUNDLE_PERMISSIONS_PROMPT\";\n    case ExtensionInstallPrompt::LAUNCH_PROMPT_DEPRECATED:\n      NOTREACHED();\n    case ExtensionInstallPrompt::UNSET_PROMPT_TYPE:\n    case ExtensionInstallPrompt::NUM_PROMPT_TYPES:\n      break;\n  }\n  return \"OTHER\";\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2016-1640",
        "length": 305
    },
    {
        "index": 14793,
        "code": "ftp_getresp(ftpbuf_t *ftp)\n{\n\tchar *buf;\n\n\tif (ftp == NULL) {\n\t\treturn 0;\n\t}\n\tbuf = ftp->inbuf;\n\tftp->resp = 0;\n\n\twhile (1) {\n\n\t\tif (!ftp_readline(ftp)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* Break out when the end-tag is found */\n\t\tif (isdigit(ftp->inbuf[0]) && isdigit(ftp->inbuf[1]) && isdigit(ftp->inbuf[2]) && ftp->inbuf[3] == ' ') {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* translate the tag */\n\tif (!isdigit(ftp->inbuf[0]) || !isdigit(ftp->inbuf[1]) || !isdigit(ftp->inbuf[2])) {\n\t\treturn 0;\n\t}\n\n\tftp->resp = 100 * (ftp->inbuf[0] - '0') + 10 * (ftp->inbuf[1] - '0') + (ftp->inbuf[2] - '0');\n\n\tmemmove(ftp->inbuf, ftp->inbuf + 4, FTP_BUFSIZE - 4);\n\n\tif (ftp->extra) {\n\t\tftp->extra -= 4;\n\t}\n\treturn 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2015-4643",
        "length": 276
    },
    {
        "index": 126316,
        "code": "void BrowserWindowGtk::ConfirmBrowserCloseWithPendingDownloads() {\n  DownloadInProgressDialogGtk::Show(browser(), GetNativeWindow());\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2012-5148",
        "length": 28
    },
    {
        "index": 146083,
        "code": "void WebGL2RenderingContextBase::deleteSampler(WebGLSampler* sampler) {\n  if (isContextLost())\n    return;\n\n  for (size_t i = 0; i < sampler_units_.size(); ++i) {\n    if (sampler == sampler_units_[i]) {\n      sampler_units_[i] = nullptr;\n      ContextGL()->BindSampler(i, 0);\n    }\n  }\n\n  DeleteObject(sampler);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5112",
        "length": 90
    },
    {
        "index": 89432,
        "code": "int nfc_genl_dep_link_down_event(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is down\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_DEP_LINK_DOWN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-12984",
        "length": 184
    },
    {
        "index": 78289,
        "code": "coolkey_get_attribute_count(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tif (object_record_type == COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_count(obj, buf_len);\n\t}\n\tif (object_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn 0;\n\t}\n\treturn coolkey_v1_get_attribute_count(obj, buf_len);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 89
    },
    {
        "index": 45422,
        "code": "static unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n\t\t\t\t\t       unsigned int order)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (page)\n\t\treturn (unsigned long) page_address(page);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-189",
        "cve": "CVE-2014-9683",
        "length": 63
    },
    {
        "index": 115444,
        "code": "static double numericWindowPropertyValue(WKBundleFrameRef frame, const char* propertyName)\n{\n    JSGlobalContextRef context = WKBundleFrameGetJavaScriptContext(frame);\n    return propertyValueDouble(context, JSContextGetGlobalObject(context), propertyName);\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 50
    },
    {
        "index": 1704,
        "code": "gs_pattern2_make_pattern(gs_client_color * pcc,\n                         const gs_pattern_template_t * pcp,\n                         const gs_matrix * pmat, gs_gstate * pgs,\n                         gs_memory_t * mem)\n{\n    const gs_pattern2_template_t *ptemp =\n        (const gs_pattern2_template_t *)pcp;\n    int code = gs_make_pattern_common(pcc, pcp, pmat, pgs, mem,\n                                      &st_pattern2_instance);\n    gs_pattern2_instance_t *pinst;\n\n    if (code < 0)\n        return code;\n    pinst = (gs_pattern2_instance_t *)pcc->pattern;\n    pinst->templat = *ptemp;\n    pinst->shfill = false;\n    return 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-704",
        "cve": "CVE-2018-19134",
        "length": 162
    },
    {
        "index": 29058,
        "code": "static unsigned long __gfn_to_hva_many(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t       gfn_t *nr_pages, bool write)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn KVM_HVA_ERR_BAD;\n\n\tif (memslot_is_readonly(slot) && write)\n\t\treturn KVM_HVA_ERR_RO_BAD;\n\n\tif (nr_pages)\n\t\t*nr_pages = slot->npages - (gfn - slot->base_gfn);\n\n\treturn __gfn_to_hva_memslot(slot, gfn);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-4592",
        "length": 123
    },
    {
        "index": 14950,
        "code": "ProcChangeCloseDownMode(ClientPtr client)\n{\n    int rc;\n\n    REQUEST(xSetCloseDownModeReq);\n    REQUEST_SIZE_MATCH(xSetCloseDownModeReq);\n\n    rc = XaceHook(XACE_CLIENT_ACCESS, client, client, DixManageAccess);\n    if (rc != Success)\n        return rc;\n\n    if ((stuff->mode == AllTemporary) ||\n        (stuff->mode == RetainPermanent) || (stuff->mode == RetainTemporary)) {\n        client->closeDownMode = stuff->mode;\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->mode;\n        return BadValue;\n    }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2015-3418",
        "length": 135
    },
    {
        "index": 100894,
        "code": "void ExtensionInstallUI::OnImageLoaded(\n    SkBitmap* image, const ExtensionResource& resource, int index) {\n  SetIcon(image);\n\n  switch (prompt_type_) {\n    case PERMISSIONS_PROMPT:\n    case RE_ENABLE_PROMPT:\n    case INSTALL_PROMPT: {\n      content::NotificationService* service =\n          content::NotificationService::current();\n      service->Notify(chrome::NOTIFICATION_EXTENSION_WILL_SHOW_CONFIRM_DIALOG,\n          content::Source<ExtensionInstallUI>(this),\n          content::NotificationService::NoDetails());\n\n      Prompt prompt(prompt_type_);\n      prompt.SetPermissions(permissions_->GetWarningMessages());\n      ShowExtensionInstallDialog(\n          profile_, delegate_, extension_, &icon_, prompt);\n      break;\n    }\n    default:\n      NOTREACHED() << \"Unknown message\";\n      break;\n  }\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 170
    },
    {
        "index": 93211,
        "code": "METHODDEF(JDIMENSION)\nget_text_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading text-format PPM files with any maxval */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  FILE *infile = source->pub.input_file;\n  register JSAMPROW ptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n\n  ptr = source->pub.buffer[0];\n  if (maxval == MAXJSAMPLE) {\n    if (aindex >= 0)\n      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),\n                    ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(read_pbm_integer(cinfo, infile, maxval),)\n  } else {\n    if (aindex >= 0)\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],\n                    ptr[aindex] = 0xFF;)\n    else\n      RGB_READ_LOOP(rescale[read_pbm_integer(cinfo, infile, maxval)],)\n  }\n  return 1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-14498",
        "length": 332
    },
    {
        "index": 171369,
        "code": "void OMXCodec::setMinBufferSize(OMX_U32 portIndex, OMX_U32 size) {\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n\n status_t err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n    CHECK_EQ(err, (status_t)OK);\n\n if ((portIndex == kPortIndexInput && (mQuirks & kInputBufferSizesAreBogus))\n || (def.nBufferSize < size)) {\n        def.nBufferSize = size;\n }\n\n    err = mOMX->setParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n    CHECK_EQ(err, (status_t)OK);\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n    CHECK_EQ(err, (status_t)OK);\n\n if (portIndex == kPortIndexInput\n && (mQuirks & kInputBufferSizesAreBogus)) {\n        CHECK_EQ(def.nBufferSize, size);\n } else {\n        CHECK(def.nBufferSize >= size);\n }\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-284",
        "cve": "CVE-2016-3899",
        "length": 248
    },
    {
        "index": 131973,
        "code": "static void voidMethodTestInterfaceEmptyArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (UNLIKELY(info.Length() < 1)) {\n        throwTypeError(ExceptionMessages::failedToExecute(\"voidMethodTestInterfaceEmptyArg\", \"TestObjectPython\", ExceptionMessages::notEnoughArguments(1, info.Length())), info.GetIsolate());\n        return;\n    }\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(TestInterfaceEmpty*, testInterfaceEmptyArg, V8TestInterfaceEmpty::toNativeWithTypeCheck(info.GetIsolate(), info[0]));\n    imp->voidMethodTestInterfaceEmptyArg(testInterfaceEmptyArg);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 151
    },
    {
        "index": 13402,
        "code": "static int jsR_delproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto dontconf;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto dontconf;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto dontconf;\n\t\tif (!strcmp(name, \"global\")) goto dontconf;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto dontconf;\n\t\tif (!strcmp(name, \"multiline\")) goto dontconf;\n\t\tif (!strcmp(name, \"lastIndex\")) goto dontconf;\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.delete && obj->u.user.delete(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\n\tref = jsV_getownproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->atts & JS_DONTCONF)\n\t\t\tgoto dontconf;\n\t\tjsV_delproperty(J, obj, name);\n\t}\n\treturn 1;\n\ndontconf:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is non-configurable\", name);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-10133",
        "length": 331
    },
    {
        "index": 54988,
        "code": "static void file_add_remove(struct diff_options *options,\n\t\t    int addremove, unsigned mode,\n\t\t    const unsigned char *sha1,\n\t\t    int sha1_valid,\n\t\t    const char *fullpath, unsigned dirty_submodule)\n{\n\tint diff = addremove == '+' ? REV_TREE_NEW : REV_TREE_OLD;\n\n\ttree_difference |= diff;\n\tif (tree_difference == REV_TREE_DIFFERENT)\n\t\tDIFF_OPT_SET(options, HAS_CHANGES);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2016-2324",
        "length": 91
    },
    {
        "index": 185633,
        "code": "void FrameSelection::MoveCaretSelection(const IntPoint& point) {\n  DCHECK(!GetDocument().NeedsLayoutTreeUpdate());\n\n  Element* const editable =\n      ComputeVisibleSelectionInDOMTree().RootEditableElement();\n  if (!editable)\n    return;\n\n  const VisiblePosition position =\n       VisiblePositionForContentsPoint(point, GetFrame());\n   SelectionInDOMTree::Builder builder;\n   builder.SetIsDirectional(GetSelectionInDOMTree().IsDirectional());\n  builder.SetIsHandleVisible(true);\n   if (position.IsNotNull())\n     builder.Collapse(position.ToPositionWithAffinity());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetSetSelectionBy(SetSelectionBy::kUser)\n                                     .Build());\n }\n",
        "line": "  builder.SetIsHandleVisible(true);\n",
        "label": 1,
        "cwe": "CWE-119",
        "cve": "CVE-2015-6773",
        "length": 169
    },
    {
        "index": 115964,
        "code": "Eina_Bool ewk_frame_text_matches_nth_pos_get(const Evas_Object* ewkFrame, size_t number, int* x, int* y)\n{\n    EWK_FRAME_SD_GET_OR_RETURN(ewkFrame, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->frame, false);\n\n    Vector<WebCore::IntRect> intRects = smartData->frame->document()->markers()->renderedRectsForMarkers(WebCore::DocumentMarker::TextMatch);\n\n    /* remove useless values */\n    std::remove_if(intRects.begin(), intRects.end(), _ewk_frame_rect_is_negative_value);\n\n    if (intRects.isEmpty() || number > intRects.size())\n        return false;\n\n    std::sort(intRects.begin(), intRects.end(), _ewk_frame_rect_cmp_less_than);\n\n    if (x)\n        *x = intRects[number - 1].x();\n    if (y)\n        *y = intRects[number - 1].y();\n    return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2011-3103",
        "length": 222
    },
    {
        "index": 158772,
        "code": "void WebContentsImpl::SetHasPictureInPictureVideo(\n    bool has_picture_in_picture_video) {\n  if (has_picture_in_picture_video == has_picture_in_picture_video_)\n    return;\n  has_picture_in_picture_video_ = has_picture_in_picture_video;\n  NotifyNavigationStateChanged(INVALIDATE_TYPE_TAB);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2018-17471",
        "length": 65
    },
    {
        "index": 563,
        "code": "pdf_show_text(fz_context *ctx, pdf_run_processor *pr, pdf_obj *text)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_font_desc *fontdesc = gstate->text.font;\n\tint i;\n\n\tif (!fontdesc)\n\t{\n\t\tfz_warn(ctx, \"cannot draw text since font and size not set\");\n\t\treturn;\n\t}\n\n\tif (pdf_is_array(ctx, text))\n\t{\n\t\tint n = pdf_array_len(ctx, text);\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tpdf_obj *item = pdf_array_get(ctx, text, i);\n\t\t\tif (pdf_is_string(ctx, item))\n\t\t\t\tshow_string(ctx, pr, (unsigned char *)pdf_to_str_buf(ctx, item), pdf_to_str_len(ctx, item));\n\t\t\telse\n\t\t\t\tpdf_show_space(ctx, pr, - pdf_to_real(ctx, item) * gstate->text.size * 0.001f);\n\t\t}\n\t}\n\telse if (pdf_is_string(ctx, text))\n\t{\n\t\tpdf_show_string(ctx, pr, (unsigned char *)pdf_to_str_buf(ctx, text), pdf_to_str_len(ctx, text));\n\t}\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2018-1000039",
        "length": 260
    },
    {
        "index": 153408,
        "code": "gfx::Rect TabStrip::GetTabAnimationTargetBounds(const Tab* tab) {\n  return bounds_animator_.GetTargetBounds(tab);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-20",
        "cve": "CVE-2016-5218",
        "length": 30
    },
    {
        "index": 140460,
        "code": "bool GetHeaders(base::DictionaryValue* params, std::string* headers) {\n  if (!params)\n    return false;\n  base::ListValue* header_list;\n  if (!params->GetList(\"headers\", &header_list))\n    return false;\n  std::string double_quote_headers;\n  base::JSONWriter::Write(header_list, &double_quote_headers);\n  base::ReplaceChars(double_quote_headers, \"\\\"\", \"'\", headers);\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-19",
        "cve": "CVE-2015-1229",
        "length": 96
    },
    {
        "index": 79293,
        "code": "static uint32_t get_sample_flags(MOVTrack *track, MOVIentry *entry)\n{\n    return entry->flags & MOV_SYNC_SAMPLE ? MOV_FRAG_SAMPLE_FLAG_DEPENDS_NO :\n           (MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES | MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-369",
        "cve": "CVE-2018-14395",
        "length": 61
    },
    {
        "index": 56859,
        "code": "static void connect_request_upcall(struct iwch_ep *ep)\n{\n\tstruct iw_cm_event event;\n\n\tPDBG(\"%s ep %p tid %d\\n\", __func__, ep, ep->hwtid);\n\tmemset(&event, 0, sizeof(event));\n\tevent.event = IW_CM_EVENT_CONNECT_REQUEST;\n\tmemcpy(&event.local_addr, &ep->com.local_addr,\n\t       sizeof(ep->com.local_addr));\n\tmemcpy(&event.remote_addr, &ep->com.remote_addr,\n\t       sizeof(ep->com.local_addr));\n\tevent.private_data_len = ep->plen;\n\tevent.private_data = ep->mpa_pkt + sizeof(struct mpa_message);\n\tevent.provider_data = ep;\n\t/*\n\t * Until ird/ord negotiation via MPAv2 support is added, send max\n\t * supported values\n\t */\n\tevent.ird = event.ord = 8;\n\tif (state_read(&ep->parent_ep->com) != DEAD) {\n\t\tget_ep(&ep->com);\n\t\tep->parent_ep->com.cm_id->event_handler(\n\t\t\t\t\t\tep->parent_ep->com.cm_id,\n\t\t\t\t\t\t&event);\n\t}\n\tput_ep(&ep->parent_ep->com);\n\tep->parent_ep = NULL;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-8812",
        "length": 248
    },
    {
        "index": 185875,
        "code": "void VRDisplay::OnVSync(device::mojom::blink::VRPosePtr pose,\n                         mojo::common::mojom::blink::TimeDeltaPtr time,\n                         int16_t frame_id,\n                         device::mojom::blink::VRVSyncProvider::Status error) {\n   v_sync_connection_failed_ = false;\n   switch (error) {\n     case device::mojom::blink::VRVSyncProvider::Status::SUCCESS:\n      break;\n    case device::mojom::blink::VRVSyncProvider::Status::CLOSING:\n      return;\n  }\n  pending_vsync_ = false;\n\n  WTF::TimeDelta time_delta =\n      WTF::TimeDelta::FromMicroseconds(time->microseconds);\n  if (timebase_ < 0) {\n    timebase_ = WTF::MonotonicallyIncreasingTime() - time_delta.InSecondsF();\n  }\n\n  frame_pose_ = std::move(pose);\n  vr_frame_id_ = frame_id;\n\n  Platform::Current()->CurrentThread()->GetWebTaskRunner()->PostTask(\n      BLINK_FROM_HERE,\n      WTF::Bind(&VRDisplay::ProcessScheduledAnimations,\n                WrapWeakPersistent(this), timebase_ + time_delta.InSecondsF()));\n}\n",
        "line": null,
        "label": 1,
        "cwe": null,
        "cve": "CVE-2015-1265",
        "length": 249
    },
    {
        "index": 78598,
        "code": "pgp_match_card(sc_card_t *card)\n{\n\tint i;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\ti = _sc_match_atr(card, pgp_atrs, &card->type);\n\tif (i >= 0) {\n\t\tcard->name = pgp_atrs[i].name;\n\t\tLOG_FUNC_RETURN(card->ctx, 1);\n\t}\n\telse {\n\t\tsc_path_t\tpartial_aid;\n\t\tsc_file_t *file = NULL;\n\n\t\t/* select application \"OpenPGP\" */\n\t\tsc_format_path(\"D276:0001:2401\", &partial_aid);\n\t\tpartial_aid.type = SC_PATH_TYPE_DF_NAME;\n\t\t/* OpenPGP card only supports selection *with* requested FCI */\n\t\ti = iso_ops->select_file(card, &partial_aid, &file);\n\t\tif (SC_SUCCESS == i) {\n\t\t\tcard->type = SC_CARD_TYPE_OPENPGP_BASE;\n\t\t\tcard->name = default_cardname;\n\n\t\t\tif (file->namelen != 16)\n\t\t\t\t(void) get_full_pgp_aid(card, file);\n\t\t\tif (file->namelen == 16) {\n\t\t\t\tunsigned char major = BCD2UCHAR(file->name[6]);\n\n\t\t\t\tswitch (major) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcard->type = SC_CARD_TYPE_OPENPGP_V1;\n\t\t\t\t\t\tcard->name = default_cardname_v1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcard->type = SC_CARD_TYPE_OPENPGP_V2;\n\t\t\t\t\t\tcard->name = default_cardname_v2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcard->type = SC_CARD_TYPE_OPENPGP_V3;\n\t\t\t\t\t\tcard->name = default_cardname_v3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsc_file_free(file);\n\t\t\tLOG_FUNC_RETURN(card->ctx, 1);\n\t\t}\n\t}\n\tLOG_FUNC_RETURN(card->ctx, 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2018-16427",
        "length": 408
    },
    {
        "index": 99737,
        "code": "VP9Decoder::VP9Accelerator::VP9Accelerator() {}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": null,
        "length": 16
    },
    {
        "index": 18743,
        "code": "int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tif (sk->sk_state == DCCP_OPEN) { /* Fast path */\n\t\tif (dccp_rcv_established(sk, skb, dh, skb->len))\n\t\t\tgoto reset;\n\t\treturn 0;\n\t}\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies\n\t *\t      Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t *\n\t * NOTE: the check for the packet types is done in\n\t *\t dccp_rcv_state_process\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tstruct sock *nsk = dccp_v4_hnd_req(sk, skb);\n\n\t\tif (nsk == NULL)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tif (dccp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (dccp_rcv_state_process(sk, skb, dh, skb->len))\n\t\tgoto reset;\n\treturn 0;\n\nreset:\n\tdccp_v4_ctl_send_reset(sk, skb);\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-362",
        "cve": "CVE-2012-3552",
        "length": 481
    },
    {
        "index": 110121,
        "code": "gfx::NativeWindow ShellWindowViews::GetNativeWindow() {\n  return window_->GetNativeWindow();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-79",
        "cve": "CVE-2012-2889",
        "length": 23
    },
    {
        "index": 29186,
        "code": "nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\treturn _nfs4_opendata_reclaim_to_nfs4_state(data);\n\treturn _nfs4_opendata_to_nfs4_state(data);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-4591",
        "length": 73
    },
    {
        "index": 125542,
        "code": "GDataFile* FindFile(GDataDirectoryService* directory_service,\n                    const char* path) {\n  return directory_service->FindEntryByPathSync(FilePath(path))->AsGDataFile();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2013-0839",
        "length": 42
    },
    {
        "index": 69680,
        "code": "entry_guard_pick_for_circuit(guard_selection_t *gs,\n                             guard_usage_t usage,\n                             entry_guard_restriction_t *rst,\n                             const node_t **chosen_node_out,\n                             circuit_guard_state_t **guard_state_out)\n{\n  tor_assert(gs);\n  tor_assert(chosen_node_out);\n  tor_assert(guard_state_out);\n  *chosen_node_out = NULL;\n  *guard_state_out = NULL;\n\n  unsigned state = 0;\n  entry_guard_t *guard =\n    select_entry_guard_for_circuit(gs, usage, rst, &state);\n  if (! guard)\n    goto fail;\n  if (BUG(state == 0))\n    goto fail;\n  const node_t *node = node_get_by_id(guard->identity);\n  if (! node)\n    goto fail;\n  if (BUG(usage != GUARD_USAGE_DIRGUARD && !node_has_descriptor(node)))\n    goto fail;\n\n  *chosen_node_out = node;\n  *guard_state_out = tor_malloc_zero(sizeof(circuit_guard_state_t));\n  (*guard_state_out)->guard = entry_guard_handle_new(guard);\n  (*guard_state_out)->state = state;\n  (*guard_state_out)->state_set_at = approx_time();\n  (*guard_state_out)->restrictions = rst;\n\n  return 0;\n fail:\n  entry_guard_restriction_free(rst);\n  return -1;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-0377",
        "length": 282
    },
    {
        "index": 136412,
        "code": "  cc::Layer* ContentLayerAt(unsigned index) {\n    return paint_artifact_compositor_->GetExtraDataForTesting()\n        ->content_layers[index]\n        .get();\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6787",
        "length": 39
    },
    {
        "index": 151119,
        "code": "void DevToolsWindow::UpdateBrowserWindow() {\n  BrowserWindow* inspected_window = GetInspectedBrowserWindow();\n  if (inspected_window)\n    inspected_window->UpdateDevTools();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-200",
        "cve": "CVE-2017-5011",
        "length": 40
    },
    {
        "index": 140691,
        "code": "base::string16 ScreenLayoutObserverTest::GetDisplayNotificationText() const {\n  const message_center::Notification* notification = GetDisplayNotification();\n  return notification ? notification->title() : base::string16();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-17",
        "cve": "CVE-2015-1233",
        "length": 45
    },
    {
        "index": 110799,
        "code": "bool AutocompleteEditModel::OnEscapeKeyPressed() {\n  if (has_temporary_text_) {\n    AutocompleteMatch match;\n    InfoForCurrentSelection(&match, NULL);\n    if (match.destination_url != original_url_) {\n      RevertTemporaryText(true);\n      return true;\n    }\n  }\n\n  if (!user_input_in_progress_ && view_->IsSelectAll())\n    return false;\n\n  view_->RevertAll();\n  view_->SelectAll(true);\n  return true;\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 101
    },
    {
        "index": 136940,
        "code": "bool HTMLInputElement::PatternMismatch() const {\n  return willValidate() && input_type_->PatternMismatch(value());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6763",
        "length": 24
    },
    {
        "index": 122365,
        "code": "void HTMLInputElement::setWidth(unsigned width)\n{\n    setUnsignedIntegralAttribute(widthAttr, width);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2013-0882",
        "length": 21
    },
    {
        "index": 90375,
        "code": "megasas_ldio_outstanding_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->ldio_outstanding));\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-476",
        "cve": "CVE-2019-11810",
        "length": 85
    },
    {
        "index": 121846,
        "code": "void IOThread::ChangedToOnTheRecordOnIOThread() {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n\n  ClearHostCache();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2013-2858",
        "length": 35
    },
    {
        "index": 179388,
        "code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n \t\tgoto drop;\n \t}\n \n\t/* Zero out the CB buffer if no options present */\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n \t\treturn 0;\n\t}\n \n \topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n \tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}\n",
        "line": "\t/* Zero out the CB buffer if no options present */\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t}\n",
        "label": 1,
        "cwe": "CWE-399",
        "cve": "CVE-2011-4087",
        "length": 437
    },
    {
        "index": 128297,
        "code": "void FrameView::performPostLayoutTasks()\n{\n    ASSERT(!isInPerformLayout()); // Always before or after performLayout(), part of the highest-level layout() call.\n    TRACE_EVENT0(\"blink\", \"FrameView::performPostLayoutTasks\");\n    RefPtr<FrameView> protect(this);\n\n    m_postLayoutTasksTimer.stop();\n\n    m_frame->selection().setCaretRectNeedsUpdate();\n\n    {\n        DisableCompositingQueryAsserts disabler;\n        m_frame->selection().updateAppearance();\n    }\n\n    ASSERT(m_frame->document());\n    if (m_nestedLayoutCount <= 1) {\n        if (m_firstLayoutCallbackPending)\n            m_firstLayoutCallbackPending = false;\n\n        if (!m_frame->document()->parsing() && m_frame->loader().stateMachine()->committedFirstRealDocumentLoad())\n            m_isVisuallyNonEmpty = true;\n\n        if (m_isVisuallyNonEmpty && !m_frame->document()->didLayoutWithPendingStylesheets() && m_firstVisuallyNonEmptyLayoutCallbackPending) {\n            m_firstVisuallyNonEmptyLayoutCallbackPending = false;\n            m_frame->loader().client()->dispatchDidFirstVisuallyNonEmptyLayout();\n        }\n    }\n\n    FontFaceSet::didLayout(*m_frame->document());\n\n    updateWidgetPositions();\n\n    if (!renderView())\n        return;\n\n    scheduleUpdateWidgetsIfNecessary();\n\n    if (Page* page = m_frame->page()) {\n        if (ScrollingCoordinator* scrollingCoordinator = page->scrollingCoordinator())\n            scrollingCoordinator->notifyLayoutUpdated();\n    }\n\n    scrollToAnchor();\n\n    sendResizeEventIfNeeded();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-416",
        "cve": "CVE-2014-3191",
        "length": 334
    },
    {
        "index": 12230,
        "code": "static const SSL_METHOD *ssl23_get_server_method(int ver)\n\t{\n#ifndef OPENSSL_NO_SSL2\n\tif (ver == SSL2_VERSION)\n\t\treturn(SSLv2_server_method());\n#endif\n#ifndef OPENSSL_NO_SSL3\n\tif (ver == SSL3_VERSION)\n\t\treturn(SSLv3_server_method());\n#endif\n\tif (ver == TLS1_VERSION)\n\t\treturn(TLSv1_server_method());\n\telse if (ver == TLS1_1_VERSION)\n\t\treturn(TLSv1_1_server_method());\n\telse if (ver == TLS1_2_VERSION)\n\t\treturn(TLSv1_2_server_method());\n\telse\n\t\treturn(NULL);\n\t}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2014-3569",
        "length": 137
    },
    {
        "index": 87790,
        "code": "static int cmd_rap_run(void *data, const char *input) {\n\tRCore *core = (RCore *)data;\n\tchar *res = r_io_system (core->io, input);\n\tif (res) {\n\t\tint ret = atoi (res);\n\t\tfree (res);\n\t\treturn ret;\n\t}\n\treturn false;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-78",
        "cve": "CVE-2019-16718",
        "length": 70
    },
    {
        "index": 175130,
        "code": "static int wifi_add_membership(wifi_handle handle, const char *group)\n{\n    hal_info *info = getHalInfo(handle);\n\n int id = wifi_get_multicast_id(handle, \"nl80211\", group);\n if (id < 0) {\n        ALOGE(\"Could not find group %s\", group);\n return id;\n }\n\n int ret = nl_socket_add_membership(info->event_sock, id);\n if (ret < 0) {\n        ALOGE(\"Could not add membership to group %s\", group);\n }\n\n return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-264",
        "cve": "CVE-2016-0809",
        "length": 112
    },
    {
        "index": 68999,
        "code": "static int FLTIsGMLDefaultProperty(const char* pszName)\n{\n    return (strcmp(pszName, \"gml:name\") == 0 ||\n            strcmp(pszName, \"gml:description\") == 0 ||\n            strcmp(pszName, \"gml:descriptionReference\") == 0 ||\n            strcmp(pszName, \"gml:identifier\") == 0 ||\n            strcmp(pszName, \"gml:boundedBy\") == 0 ||\n            strcmp(pszName, \"@gml:id\") == 0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-119",
        "cve": "CVE-2017-5522",
        "length": 113
    },
    {
        "index": 17849,
        "code": "static int local_chmod(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n{\n    char *dirpath = g_path_get_dirname(fs_path->data);\n    char *name = g_path_get_basename(fs_path->data);\n    int ret = -1;\n    int dirfd;\n\n    dirfd = local_opendir_nofollow(fs_ctx, dirpath);\n    if (dirfd == -1) {\n        goto out;\n    }\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n        ret = local_set_xattrat(dirfd, name, credp);\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n        ret = local_set_mapped_file_attrat(dirfd, name, credp);\n    } else if (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH ||\n               fs_ctx->export_flags & V9FS_SM_NONE) {\n        ret = fchmodat_nofollow(dirfd, name, credp->fc_mode);\n    }\n    close_preserve_errno(dirfd);\n\nout:\n    g_free(dirpath);\n    g_free(name);\n    return ret;\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-732",
        "cve": "CVE-2017-7471",
        "length": 256
    },
    {
        "index": 111052,
        "code": "void WebPage::addCompositingThreadOverlay(WebOverlay* overlay)\n{\n#if USE(ACCELERATED_COMPOSITING)\n    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());\n    if (!d->compositor())\n        return;\n\n    overlay->d->setPage(d);\n    d->compositor()->addOverlay(overlay->d->layerCompositingThread());\n#endif\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2012-2875",
        "length": 84
    },
    {
        "index": 70249,
        "code": "LogLuvSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"LogLuvSetupDecode\";\n\tLogLuvState* sp = DecoderState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\ttif->tif_postdecode = _TIFFNoPostDecode;\n\tswitch (td->td_photometric) {\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tif (!LogLuvInitState(tif))\n\t\t\tbreak;\n\t\tif (td->td_compression == COMPRESSION_SGILOG24) {\n\t\t\ttif->tif_decoderow = LogLuvDecode24;\n\t\t\tswitch (sp->user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp->tfunc = Luv24toXYZ;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp->tfunc = Luv24toLuv48;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\t\tsp->tfunc = Luv24toRGB;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\ttif->tif_decoderow = LogLuvDecode32;\n\t\t\tswitch (sp->user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp->tfunc = Luv32toXYZ;\n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp->tfunc = Luv32toLuv48;\n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\t\tsp->tfunc = Luv32toRGB;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\tcase PHOTOMETRIC_LOGL:\n\t\tif (!LogL16InitState(tif))\n\t\t\tbreak;\n\t\ttif->tif_decoderow = LogL16Decode;\n\t\tswitch (sp->user_datafmt) {\n\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\tsp->tfunc = L16toY;\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\tsp->tfunc = L16toGry;\n\t\t\tbreak;\n\t\t}\n\t\treturn (1);\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Inappropriate photometric interpretation %d for SGILog compression; %s\",\n\t\t    td->td_photometric, \"must be either LogLUV or LogL\");\n\t\tbreak;\n\t}\n\treturn (0);\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-125",
        "cve": "CVE-2016-10269",
        "length": 511
    },
    {
        "index": 118790,
        "code": "  void GetSizeForRenderViewHost(\n      content::RenderViewHost* render_view_host,\n      gfx::Size* rwhv_create_size,\n      gfx::Size* rwhv_commit_size,\n      gfx::Size* wcv_commit_size) {\n    RenderViewSizes::const_iterator result = render_view_sizes_.end();\n    result = render_view_sizes_.find(render_view_host);\n    if (result != render_view_sizes_.end()) {\n      *rwhv_create_size = result->second.rwhv_create_size;\n      *rwhv_commit_size = result->second.rwhv_commit_size;\n      *wcv_commit_size = result->second.wcv_commit_size;\n    }\n  }\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2013-6626",
        "length": 146
    },
    {
        "index": 81227,
        "code": "void tasklet_kill_immediate(struct tasklet_struct *t, unsigned int cpu)\n{\n\tstruct tasklet_struct **i;\n\n\tBUG_ON(cpu_online(cpu));\n\tBUG_ON(test_bit(TASKLET_STATE_RUN, &t->state));\n\n\tif (!test_bit(TASKLET_STATE_SCHED, &t->state))\n\t\treturn;\n\n\t/* CPU is dead, so no lock needed. */\n\tfor (i = &per_cpu(tasklet_vec, cpu).head; *i; i = &(*i)->next) {\n\t\tif (*i == t) {\n\t\t\t*i = t->next;\n\t\t\t/* If this was the tail element, move the tail ptr */\n\t\t\tif (*i == NULL)\n\t\t\t\tper_cpu(tasklet_vec, cpu).tail = i;\n\t\t\treturn;\n\t\t}\n\t}\n\tBUG();\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-787",
        "cve": "CVE-2018-12714",
        "length": 170
    },
    {
        "index": 136079,
        "code": "void WebsiteSettingsPopupAndroid::SetIdentityInfo(\n    const IdentityInfo& identity_info) {\n  JNIEnv* env = base::android::AttachCurrentThread();\n  Java_WebsiteSettingsPopup_showDialog(env, popup_jobject_.obj());\n}\n",
        "line": null,
        "label": 0,
        "cwe": null,
        "cve": "CVE-2015-6780",
        "length": 50
    },
    {
        "index": 131603,
        "code": "static void perWorldBindingsVoidMethodTestInterfaceEmptyArgMethodCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMMethod\");\n    TestObjectPythonV8Internal::perWorldBindingsVoidMethodTestInterfaceEmptyArgMethodForMainWorld(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "line": null,
        "label": 0,
        "cwe": "CWE-399",
        "cve": "CVE-2014-1713",
        "length": 87
    }
]