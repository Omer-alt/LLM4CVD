[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax, void *user_data,\n const char *chunk, int size, const char *filename) {\n    xmlParserCtxtPtr ctxt;\n    xmlParserInputPtr inputStream;\n    xmlParserInputBufferPtr buf;\n    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n\n /*\n     * plug some encoding conversion routines\n     */\n if ((chunk != NULL) && (size >= 4))\n\tenc = xmlDetectCharEncoding((const xmlChar *) chunk, size);\n\n    buf = xmlAllocParserInputBuffer(enc);\n if (buf == NULL) return(NULL);\n\n    ctxt = xmlNewParserCtxt();\n if (ctxt == NULL) {\n        xmlErrMemory(NULL, \"creating parser: out of memory\\n\");\n\txmlFreeParserInputBuffer(buf);\n return(NULL);\n }\n    ctxt->dictNames = 1;\n    ctxt->pushTab = (void **) xmlMalloc(ctxt->nameMax * 3 * sizeof(xmlChar *));\n if (ctxt->pushTab == NULL) {\n        xmlErrMemory(ctxt, NULL);\n\txmlFreeParserInputBuffer(buf);\n\txmlFreeParserCtxt(ctxt);\n return(NULL);\n }\n if (sax != NULL) {\n#ifdef LIBXML_SAX1_ENABLED\n if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n#endif /* LIBXML_SAX1_ENABLED */\n\t    xmlFree(ctxt->sax);\n\tctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n if (ctxt->sax == NULL) {\n\t    xmlErrMemory(ctxt, NULL);\n\t    xmlFreeParserInputBuffer(buf);\n\t    xmlFreeParserCtxt(ctxt);\n return(NULL);\n }\n\tmemset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n if (sax->initialized == XML_SAX2_MAGIC)\n\t    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n else\n\t    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n if (user_data != NULL)\n\t    ctxt->userData = user_data;\n }\n if (filename == NULL) {\n\tctxt->directory = NULL;\n } else {\n        ctxt->directory = xmlParserGetDirectory(filename);\n }\n\n    inputStream = xmlNewInputStream(ctxt);\n if (inputStream == NULL) {\n\txmlFreeParserCtxt(ctxt);\n\txmlFreeParserInputBuffer(buf);\n return(NULL);\n }\n\n if (filename == NULL)\n\tinputStream->filename = NULL;\n else {\n\tinputStream->filename = (char *)\n\t    xmlCanonicPath((const xmlChar *) filename);\n if (inputStream->filename == NULL) {\n\t    xmlFreeParserCtxt(ctxt);\n\t    xmlFreeParserInputBuffer(buf);\n return(NULL);\n }\n }\n    inputStream->buf = buf;\n    xmlBufResetInput(inputStream->buf->buffer, inputStream);\n    inputPush(ctxt, inputStream);\n\n /*\n     * If the caller didn't provide an initial 'chunk' for determining\n     * the encoding, we set the context to XML_CHAR_ENCODING_NONE so\n     * that it can be automatically determined later\n     */\n if ((size == 0) || (chunk == NULL)) {\n\tctxt->charset = XML_CHAR_ENCODING_NONE;\n } else if ((ctxt->input != NULL) && (ctxt->input->buf != NULL)) {\n size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n size_t cur = ctxt->input->cur - ctxt->input->base;\n\n\txmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n\n        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input, base, cur);\n#ifdef DEBUG_PUSH\n\txmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n#endif\n }\n\n if (enc != XML_CHAR_ENCODING_NONE) {\n        xmlSwitchEncoding(ctxt, enc);\n }\n\n return(ctxt);\n}\n",
        "output": "0",
        "index": 176567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ap_lua_rstack_dump(lua_State *L, request_rec *r, const char *msg)\n{\n    int i;\n    int top = lua_gettop(L);\n    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01484) \"Lua Stack Dump: [%s]\", msg);\n    for (i = 1; i <= top; i++) {\n        int t = lua_type(L, i);\n        switch (t) {\n        case LUA_TSTRING:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  '%s'\", i, lua_tostring(L, i));\n                break;\n            }\n        case LUA_TUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  userdata\",\n                              i);\n                break;\n            }\n        case LUA_TLIGHTUSERDATA:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  lightuserdata\", i);\n                break;\n            }\n        case LUA_TNIL:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  NIL\", i);\n                break;\n            }\n        case LUA_TNONE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, \"%d:  None\", i);\n                break;\n            }\n        case LUA_TBOOLEAN:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %s\", i, lua_toboolean(L,\n                                                          i) ? \"true\" :\n                              \"false\");\n                break;\n            }\n        case LUA_TNUMBER:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  %g\", i, lua_tonumber(L, i));\n                break;\n            }\n        case LUA_TTABLE:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <table>\", i);\n                break;\n            }\n        case LUA_TFUNCTION:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  <function>\", i);\n                break;\n            }\n        default:{\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r,\n                              \"%d:  unknown: -[%s]-\", i, lua_typename(L, i));\n                break;\n            }\n        }\n    }\n}\n",
        "output": "0",
        "index": 45048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_build_env(job_env_t *job_env)\n{\n\tchar **env = xmalloc(sizeof(char *));\n\tbool user_name_set = 0;\n\n\tenv[0]  = NULL;\n\tif (!valid_spank_job_env(job_env->spank_job_env,\n\t\t\t\t job_env->spank_job_env_size,\n\t\t\t\t job_env->uid)) {\n\t\t/* If SPANK job environment is bad, log it and do not use */\n\t\tjob_env->spank_job_env_size = 0;\n\t\tjob_env->spank_job_env = (char **) NULL;\n\t}\n\tif (job_env->spank_job_env_size) {\n\t\tenv_array_merge_spank(&env,\n\t\t\t\t      (const char **) job_env->spank_job_env);\n\t}\n\n\tslurm_mutex_lock(&conf->config_mutex);\n\tsetenvf(&env, \"SLURMD_NODENAME\", \"%s\", conf->node_name);\n\tsetenvf(&env, \"SLURM_CONF\", conf->conffile);\n\tslurm_mutex_unlock(&conf->config_mutex);\n\n\tsetenvf(&env, \"SLURM_CLUSTER_NAME\", \"%s\", conf->cluster_name);\n\tsetenvf(&env, \"SLURM_JOB_ID\", \"%u\", job_env->jobid);\n\tsetenvf(&env, \"SLURM_JOB_UID\",   \"%u\", job_env->uid);\n\n#ifndef HAVE_NATIVE_CRAY\n\t/* uid_to_string on a cray is a heavy call, so try to avoid it */\n\tif (!job_env->user_name) {\n\t\tjob_env->user_name = uid_to_string(job_env->uid);\n\t\tuser_name_set = 1;\n\t}\n#endif\n\n\tsetenvf(&env, \"SLURM_JOB_USER\", \"%s\", job_env->user_name);\n\tif (user_name_set)\n\t\txfree(job_env->user_name);\n\n\tsetenvf(&env, \"SLURM_JOBID\", \"%u\", job_env->jobid);\n\tsetenvf(&env, \"SLURM_UID\",   \"%u\", job_env->uid);\n\tif (job_env->node_list)\n\t\tsetenvf(&env, \"SLURM_NODELIST\", \"%s\", job_env->node_list);\n\n\tif (job_env->partition)\n\t\tsetenvf(&env, \"SLURM_JOB_PARTITION\", \"%s\", job_env->partition);\n\n\tif (job_env->resv_id) {\n#if defined(HAVE_BG)\n\t\tsetenvf(&env, \"MPIRUN_PARTITION\", \"%s\", job_env->resv_id);\n# ifdef HAVE_BGP\n\t\t/* Needed for HTC jobs */\n\t\tsetenvf(&env, \"SUBMIT_POOL\", \"%s\", job_env->resv_id);\n# endif\n#elif defined(HAVE_ALPS_CRAY)\n\t\tsetenvf(&env, \"BASIL_RESERVATION_ID\", \"%s\", job_env->resv_id);\n#endif\n\t}\n\treturn env;\n}\n",
        "output": "0",
        "index": 72052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GBool Splash::pathAllOutside(SplashPath *path) {\n  SplashCoord xMin1, yMin1, xMax1, yMax1;\n  SplashCoord xMin2, yMin2, xMax2, yMax2;\n  SplashCoord x, y;\n  int xMinI, yMinI, xMaxI, yMaxI;\n  int i;\n\n  xMin1 = xMax1 = path->pts[0].x;\n  yMin1 = yMax1 = path->pts[0].y;\n  for (i = 1; i < path->length; ++i) {\n    if (path->pts[i].x < xMin1) {\n      xMin1 = path->pts[i].x;\n    } else if (path->pts[i].x > xMax1) {\n      xMax1 = path->pts[i].x;\n    }\n    if (path->pts[i].y < yMin1) {\n      yMin1 = path->pts[i].y;\n    } else if (path->pts[i].y > yMax1) {\n      yMax1 = path->pts[i].y;\n    }\n  }\n\n  transform(state->matrix, xMin1, yMin1, &x, &y);\n  xMin2 = xMax2 = x;\n  yMin2 = yMax2 = y;\n  transform(state->matrix, xMin1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMin1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  transform(state->matrix, xMax1, yMax1, &x, &y);\n  if (x < xMin2) {\n    xMin2 = x;\n  } else if (x > xMax2) {\n    xMax2 = x;\n  }\n  if (y < yMin2) {\n    yMin2 = y;\n  } else if (y > yMax2) {\n    yMax2 = y;\n  }\n  xMinI = splashFloor(xMin2);\n  yMinI = splashFloor(yMin2);\n  xMaxI = splashFloor(xMax2);\n  yMaxI = splashFloor(yMax2);\n\n  return state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI) ==\n         splashClipAllOutside;\n}\n",
        "output": "0",
        "index": 4114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n\t\t X509_STORE *store, BIO *dcont, BIO *out, unsigned int flags)\n\t{\n\tCMS_SignerInfo *si;\n\tSTACK_OF(CMS_SignerInfo) *sinfos;\n\tSTACK_OF(X509) *cms_certs = NULL;\n \tSTACK_OF(X509_CRL) *crls = NULL;\n \tX509 *signer;\n \tint i, scount = 0, ret = 0;\n\tBIO *cmsbio = NULL, *tmpin = NULL;\n \n \tif (!dcont && !check_content(cms))\n \t\treturn 0;\n\n\t/* Attempt to find all signer certificates */\n\n\tsinfos = CMS_get0_SignerInfos(cms);\n\n\tif (sk_CMS_SignerInfo_num(sinfos) <= 0)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_VERIFY, CMS_R_NO_SIGNERS);\n\t\tgoto err;\n\t\t}\n\n\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t{\n\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\tCMS_SignerInfo_get0_algs(si, NULL, &signer, NULL, NULL);\n\t\tif (signer)\n\t\t\tscount++;\n\t\t}\n\n\tif (scount != sk_CMS_SignerInfo_num(sinfos))\n\t\tscount += CMS_set1_signers_certs(cms, certs, flags);\n\n\tif (scount != sk_CMS_SignerInfo_num(sinfos))\n\t\t{\n\t\tCMSerr(CMS_F_CMS_VERIFY, CMS_R_SIGNER_CERTIFICATE_NOT_FOUND);\n\t\tgoto err;\n\t\t}\n\n\t/* Attempt to verify all signers certs */\n\n\tif (!(flags & CMS_NO_SIGNER_CERT_VERIFY))\n\t\t{\n\t\tcms_certs = CMS_get1_certs(cms);\n\t\tif (!(flags & CMS_NOCRL))\n\t\t\tcrls = CMS_get1_crls(cms);\n\t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t\t{\n\t\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\t\tif (!cms_signerinfo_verify_cert(si, store,\n\t\t\t\t\t\t\tcms_certs, crls, flags))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* Attempt to verify all SignerInfo signed attribute signatures */\n\n\tif (!(flags & CMS_NO_ATTR_VERIFY))\n\t\t{\n\t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t\t{\n\t\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\t\tif (CMS_signed_get_attr_count(si) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (CMS_SignerInfo_verify(si) <= 0)\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* Performance optimization: if the content is a memory BIO then\n\t * store its contents in a temporary read only memory BIO. This\n\t * avoids potentially large numbers of slow copies of data which will\n\t * occur when reading from a read write memory BIO when signatures\n\t * are calculated.\n\t */\n\n\tif (dcont && (BIO_method_type(dcont) == BIO_TYPE_MEM))\n\t\t{\n\t\tchar *ptr;\n\t\tlong len;\n\t\tlen = BIO_get_mem_data(dcont, &ptr);\n\t\ttmpin = BIO_new_mem_buf(ptr, len);\n\t\tif (tmpin == NULL)\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\t\treturn 0;\n\t\t\t}\n \t\t}\n \telse\n \t\ttmpin = dcont;\n \n\tcmsbio=CMS_dataInit(cms, tmpin);\n\tif (!cmsbio)\n\t\tgoto err;\n \n\tif (!cms_copy_content(out, cmsbio, flags))\n\t\tgoto err;\n \n \tif (!(flags & CMS_NO_CONTENT_VERIFY))\n \t\t{\n \t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n\t\t\t{\n\t\t\tsi = sk_CMS_SignerInfo_value(sinfos, i);\n\t\t\tif (CMS_SignerInfo_verify_content(si, cmsbio) <= 0)\n\t\t\t\t{\n\t\t\t\tCMSerr(CMS_F_CMS_VERIFY,\n\t\t\t\t\tCMS_R_CONTENT_VERIFY_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n \tret = 1;\n \n \terr:\n\tif (dcont && (tmpin == dcont))\n\t\tdo_free_upto(cmsbio, dcont);\n \telse\n\t\tBIO_free_all(cmsbio);\n \n \tif (cms_certs)\n \t\tsk_X509_pop_free(cms_certs, X509_free);\n\tif (crls)\n\t\tsk_X509_CRL_pop_free(crls, X509_CRL_free);\n\n\treturn ret;\n\t}\n",
        "output": "1",
        "index": 179860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sign_and_send_pubkey(Authctxt *authctxt, Identity *id)\n{\n\tBuffer b;\n\tIdentity *private_id;\n\tu_char *blob, *signature;\n\tsize_t slen;\n\tu_int bloblen, skip = 0;\n\tint matched, ret = -1, have_sig = 1;\n\tchar *fp;\n\n\tif ((fp = sshkey_fingerprint(id->key, options.fingerprint_hash,\n\t    SSH_FP_DEFAULT)) == NULL)\n\t\treturn 0;\n\tdebug3(\"%s: %s %s\", __func__, key_type(id->key), fp);\n\tfree(fp);\n\n\tif (key_to_blob(id->key, &blob, &bloblen) == 0) {\n\t\t/* we cannot handle this key */\n\t\tdebug3(\"sign_and_send_pubkey: cannot handle key\");\n\t\treturn 0;\n\t}\n\t/* data to be signed */\n\tbuffer_init(&b);\n\tif (datafellows & SSH_OLD_SESSIONID) {\n\t\tbuffer_append(&b, session_id2, session_id2_len);\n\t\tskip = session_id2_len;\n\t} else {\n\t\tbuffer_put_string(&b, session_id2, session_id2_len);\n\t\tskip = buffer_len(&b);\n\t}\n\tbuffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);\n\tbuffer_put_cstring(&b, authctxt->server_user);\n\tbuffer_put_cstring(&b,\n\t    datafellows & SSH_BUG_PKSERVICE ?\n\t    \"ssh-userauth\" :\n\t    authctxt->service);\n\tif (datafellows & SSH_BUG_PKAUTH) {\n\t\tbuffer_put_char(&b, have_sig);\n\t} else {\n\t\tbuffer_put_cstring(&b, authctxt->method->name);\n\t\tbuffer_put_char(&b, have_sig);\n\t\tbuffer_put_cstring(&b, identity_sign_encode(id));\n\t}\n\tbuffer_put_string(&b, blob, bloblen);\n\n\t/*\n\t * If the key is an certificate, try to find a matching private key\n\t * and use it to complete the signature.\n\t * If no such private key exists, fall back to trying the certificate\n\t * key itself in case it has a private half already loaded.\n\t */\n\tif (key_is_cert(id->key)) {\n\t\tmatched = 0;\n\t\tTAILQ_FOREACH(private_id, &authctxt->keys, next) {\n\t\t\tif (sshkey_equal_public(id->key, private_id->key) &&\n\t\t\t    id->key->type != private_id->key->type) {\n\t\t\t\tid = private_id;\n\t\t\t\tmatched = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (matched) {\n\t\t\tdebug2(\"%s: using private key \\\"%s\\\"%s for \"\n\t\t\t    \"certificate\", __func__, id->filename,\n\t\t\t    id->agent_fd != -1 ? \" from agent\" : \"\");\n\t\t} else {\n\t\t\tdebug(\"%s: no separate private key for certificate \"\n\t\t\t    \"\\\"%s\\\"\", __func__, id->filename);\n\t\t}\n\t}\n\n\t/* generate signature */\n\tret = identity_sign(id, &signature, &slen,\n\t    buffer_ptr(&b), buffer_len(&b), datafellows);\n\tif (ret != 0) {\n\t\tif (ret != SSH_ERR_KEY_NOT_FOUND)\n\t\t\terror(\"%s: signing failed: %s\", __func__, ssh_err(ret));\n\t\tfree(blob);\n\t\tbuffer_free(&b);\n\t\treturn 0;\n\t}\n#ifdef DEBUG_PK\n\tbuffer_dump(&b);\n#endif\n\tif (datafellows & SSH_BUG_PKSERVICE) {\n\t\tbuffer_clear(&b);\n\t\tbuffer_append(&b, session_id2, session_id2_len);\n\t\tskip = session_id2_len;\n\t\tbuffer_put_char(&b, SSH2_MSG_USERAUTH_REQUEST);\n\t\tbuffer_put_cstring(&b, authctxt->server_user);\n\t\tbuffer_put_cstring(&b, authctxt->service);\n\t\tbuffer_put_cstring(&b, authctxt->method->name);\n\t\tbuffer_put_char(&b, have_sig);\n\t\tif (!(datafellows & SSH_BUG_PKAUTH))\n\t\t\tbuffer_put_cstring(&b, key_ssh_name(id->key));\n\t\tbuffer_put_string(&b, blob, bloblen);\n\t}\n\tfree(blob);\n\n\t/* append signature */\n\tbuffer_put_string(&b, signature, slen);\n\tfree(signature);\n\n\t/* skip session id and packet type */\n\tif (buffer_len(&b) < skip + 1)\n\t\tfatal(\"userauth_pubkey: internal error\");\n\tbuffer_consume(&b, skip + 1);\n\n\t/* put remaining data from buffer into packet */\n\tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n\tpacket_put_raw(buffer_ptr(&b), buffer_len(&b));\n\tbuffer_free(&b);\n\tpacket_send();\n\n\treturn 1;\n}\n",
        "output": "0",
        "index": 72260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGLRenderingContextBase::ValidateTexFuncDimensions(\n    const char* function_name,\n    TexImageFunctionType function_type,\n    GLenum target,\n    GLint level,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth) {\n  if (width < 0 || height < 0 || depth < 0) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                      \"width, height or depth < 0\");\n    return false;\n  }\n\n  switch (target) {\n    case GL_TEXTURE_2D:\n      if (width > (max_texture_size_ >> level) ||\n          height > (max_texture_size_ >> level)) {\n        SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                          \"width or height out of range\");\n        return false;\n      }\n      break;\n    case GL_TEXTURE_CUBE_MAP_POSITIVE_X:\n    case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:\n    case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:\n    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:\n    case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:\n    case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:\n      if (function_type != kTexSubImage && width != height) {\n        SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                          \"width != height for cube map\");\n        return false;\n      }\n      if (width > (max_cube_map_texture_size_ >> level)) {\n        SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                          \"width or height out of range for cube map\");\n        return false;\n      }\n      break;\n    case GL_TEXTURE_3D:\n      if (IsWebGL2OrHigher()) {\n        if (width > (max3d_texture_size_ >> level) ||\n            height > (max3d_texture_size_ >> level) ||\n            depth > (max3d_texture_size_ >> level)) {\n          SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                            \"width, height or depth out of range\");\n          return false;\n        }\n        break;\n      }\n    case GL_TEXTURE_2D_ARRAY:\n      if (IsWebGL2OrHigher()) {\n        if (width > (max_texture_size_ >> level) ||\n            height > (max_texture_size_ >> level) ||\n            depth > max_array_texture_layers_) {\n          SynthesizeGLError(GL_INVALID_VALUE, function_name,\n                            \"width, height or depth out of range\");\n          return false;\n        }\n        break;\n      }\n    default:\n      SynthesizeGLError(GL_INVALID_ENUM, function_name, \"invalid target\");\n      return false;\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 146425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int canon_copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t    unsigned char __user **b,\n\t\t\t\t    size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail;\n\tint ret, found = 0;\n\tbool eof_push = 0;\n\n\t/* N.B. avoid overrun if nr == 0 */\n\tn = min(*nr, read_cnt(ldata));\n\tif (!n)\n\t\treturn 0;\n\n\ttail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t/* scan wrapped without finding set bit */\n\t\teol = find_next_bit(ldata->read_flags, more, 0);\n\t\tif (eol != more)\n\t\t\tfound = 1;\n\t} else if (eol != size)\n\t\tfound = 1;\n\n\tsize = N_TTY_BUF_SIZE - tail;\n\tn = eol - tail;\n\tif (n > 4096)\n\t\tn += 4096;\n\tn += found;\n\tc = n;\n\n\tif (found && !ldata->push && read_buf(ldata, eol) == __DISABLED_CHAR) {\n\t\tn--;\n\t\teof_push = !n && ldata->read_tail != ldata->line_start;\n\t}\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, size, more);\n\n\tif (n > size) {\n\t\tret = copy_to_user(*b, read_buf_addr(ldata, tail), size);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tret = copy_to_user(*b + size, ldata->read_buf, n - size);\n\t} else\n\t\tret = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n\n\tif (ret)\n\t\treturn -EFAULT;\n\t*b += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_mb__after_clear_bit();\n\tldata->read_tail += c;\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push(tty);\n\t}\n\treturn eof_push ? -EAGAIN : 0;\n}\n",
        "output": "0",
        "index": 39778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tls1_mac(SSL *ssl, unsigned char *md, int send)\n\t{\n\tSSL3_RECORD *rec;\n\tunsigned char *seq;\n\tEVP_MD_CTX *hash;\n\tsize_t md_size, orig_len;\n\tint i;\n\tEVP_MD_CTX hmac, *mac_ctx;\n\tunsigned char header[13];\n\tint stream_mac = (send?(ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM):(ssl->mac_flags&SSL_MAC_FLAG_READ_MAC_STREAM));\n\tint t;\n\n\tif (send)\n\t\t{\n\t\trec= &(ssl->s3->wrec);\n\t\tseq= &(ssl->s3->write_sequence[0]);\n\t\thash=ssl->write_hash;\n\t\t}\n\telse\n\t\t{\n\t\trec= &(ssl->s3->rrec);\n\t\tseq= &(ssl->s3->read_sequence[0]);\n\t\thash=ssl->read_hash;\n\t\t}\n\n\tt=EVP_MD_CTX_size(hash);\n\tOPENSSL_assert(t >= 0);\n\tmd_size=t;\n\n\t/* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */\n\tif (stream_mac) \n\t\t{\n\t\t\tmac_ctx = hash;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEVP_MD_CTX_copy(&hmac,hash);\n\t\t\tmac_ctx = &hmac;\n\t\t}\n\n\tif (ssl->version == DTLS1_VERSION || ssl->version == DTLS1_BAD_VER)\n\t\t{\n\t\tunsigned char dtlsseq[8],*p=dtlsseq;\n\n\t\ts2n(send?ssl->d1->w_epoch:ssl->d1->r_epoch, p);\n\t\tmemcpy (p,&seq[2],6);\n\n\t\tmemcpy(header, dtlsseq, 8);\n\t\t}\n\telse\n\t\tmemcpy(header, seq, 8);\n\n\t/* kludge: tls1_cbc_remove_padding passes padding length in rec->type */\n\torig_len = rec->length+md_size+((unsigned int)rec->type>>8);\n\trec->type &= 0xff;\n\n\theader[8]=rec->type;\n\theader[9]=(unsigned char)(ssl->version>>8);\n\theader[10]=(unsigned char)(ssl->version);\n\theader[11]=(rec->length)>>8;\n\theader[12]=(rec->length)&0xff;\n\n\tif (!send &&\n\t    EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n\t    ssl3_cbc_record_digest_supported(mac_ctx))\n\t\t{\n\t\t/* This is a CBC-encrypted record. We must avoid leaking any\n\t\t * timing-side channel information about how many blocks of\n\t\t * data we are hashing because that gives an attacker a\n\t\t * timing-oracle. */\n\t\tssl3_cbc_digest_record(\n\t\t\tmac_ctx,\n\t\t\tmd, &md_size,\n\t\t\theader, rec->input,\n\t\t\trec->length + md_size, orig_len,\n\t\t\tssl->s3->read_mac_secret,\n\t\t\tssl->s3->read_mac_secret_size,\n\t\t\t0 /* not SSLv3 */);\n\t\t}\n\telse\n\t\t{\n\t\tEVP_DigestSignUpdate(mac_ctx,header,sizeof(header));\n\t\tEVP_DigestSignUpdate(mac_ctx,rec->input,rec->length);\n\t\tt=EVP_DigestSignFinal(mac_ctx,md,&md_size);\n\t\tOPENSSL_assert(t > 0);\n#ifdef OPENSSL_FIPS\n\t\tif (!send && FIPS_mode())\n\t\t\ttls_fips_digest_extra(\n\t    \t\t\t\tssl->enc_read_ctx,\n\t\t\t\t\tmac_ctx, rec->input,\n\t\t\t\t\trec->length, orig_len);\n#endif\n\t\t}\n\t\t\n\tif (!stream_mac)\n\t\tEVP_MD_CTX_cleanup(&hmac);\n#ifdef TLS_DEBUG\nprintf(\"sec=\");\n{unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",mac_sec[z]); printf(\"\\n\"); }\nprintf(\"seq=\");\n{int z; for (z=0; z<8; z++) printf(\"%02X \",seq[z]); printf(\"\\n\"); }\nprintf(\"buf=\");\n{int z; for (z=0; z<5; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }\nprintf(\"rec=\");\n{unsigned int z; for (z=0; z<rec->length; z++) printf(\"%02X \",buf[z]); printf(\"\\n\"); }\n#endif\n\n\tif (ssl->version != DTLS1_VERSION && ssl->version != DTLS1_BAD_VER)\n\t\t{\n\t\tfor (i=7; i>=0; i--)\n\t\t\t{\n\t\t\t++seq[i];\n\t\t\tif (seq[i] != 0) break; \n\t\t\t}\n\t\t}\n\n#ifdef TLS_DEBUG\n{unsigned int z; for (z=0; z<md_size; z++) printf(\"%02X \",md[z]); printf(\"\\n\"); }\n#endif\n\treturn(md_size);\n\t}\n",
        "output": "0",
        "index": 15415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_call(struct verifier_env *env, int func_id)\n{\n\tstruct verifier_state *state = &env->cur_state;\n\tconst struct bpf_func_proto *fn = NULL;\n\tstruct reg_state *regs = state->regs;\n\tstruct bpf_map *map = NULL;\n\tstruct reg_state *reg;\n\tint i, err;\n\n\t/* find function prototype */\n\tif (func_id < 0 || func_id >= __BPF_FUNC_MAX_ID) {\n\t\tverbose(\"invalid func %d\\n\", func_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (env->prog->aux->ops->get_func_proto)\n\t\tfn = env->prog->aux->ops->get_func_proto(func_id);\n\n\tif (!fn) {\n\t\tverbose(\"unknown func %d\\n\", func_id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tif (!env->prog->gpl_compatible && fn->gpl_only) {\n\t\tverbose(\"cannot call GPL only function from proprietary program\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check args */\n\terr = check_func_arg(env, BPF_REG_1, fn->arg1_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_2, fn->arg2_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_3, fn->arg3_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_4, fn->arg4_type, &map);\n\tif (err)\n\t\treturn err;\n\terr = check_func_arg(env, BPF_REG_5, fn->arg5_type, &map);\n\tif (err)\n\t\treturn err;\n\n\t/* reset caller saved regs */\n\tfor (i = 0; i < CALLER_SAVED_REGS; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->type = NOT_INIT;\n\t\treg->imm = 0;\n\t}\n\n\t/* update return register */\n\tif (fn->ret_type == RET_INTEGER) {\n\t\tregs[BPF_REG_0].type = UNKNOWN_VALUE;\n\t} else if (fn->ret_type == RET_VOID) {\n\t\tregs[BPF_REG_0].type = NOT_INIT;\n\t} else if (fn->ret_type == RET_PTR_TO_MAP_VALUE_OR_NULL) {\n\t\tregs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;\n\t\t/* remember map_ptr, so that check_map_access()\n\t\t * can check 'value_size' boundary of memory access\n\t\t * to map element returned from bpf_map_lookup_elem()\n\t\t */\n\t\tif (map == NULL) {\n\t\t\tverbose(\"kernel subsystem misconfigured verifier\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregs[BPF_REG_0].map_ptr = map;\n\t} else {\n\t\tverbose(\"unknown return type %d of func %d\\n\",\n\t\t\tfn->ret_type, func_id);\n\t\treturn -EINVAL;\n\t}\n\n\terr = check_map_func_compatibility(map, func_id);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 53083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "update_info_linux_md_component (Device *device)\n{\n  if (g_strcmp0 (device->priv->id_type, \"linux_raid_member\") == 0)\n    {\n      const gchar *md_comp_level;\n      gint md_comp_num_raid_devices;\n      const gchar *md_comp_uuid;\n      const gchar *md_comp_home_host;\n      const gchar *md_comp_name;\n      const gchar *md_comp_version;\n      gchar *md_name;\n      gchar *s;\n      int md_comp_position;\n\n      md_comp_position = -1;\n\n      device_set_device_is_linux_md_component (device, TRUE);\n\n      /* linux_md_component_holder and linux_md_component_state */\n      if (device->priv->holders_objpath->len == 1)\n        {\n          Device *holder;\n          gchar **state_tokens;\n\n          device_set_linux_md_component_holder (device, device->priv->holders_objpath->pdata[0]);\n          state_tokens = NULL;\n          holder = daemon_local_find_by_object_path (device->priv->daemon, device->priv->holders_objpath->pdata[0]);\n          if (holder != NULL && holder->priv->device_is_linux_md)\n            {\n              gchar *dev_name;\n              gchar *md_dev_path;\n              gchar *state_contents;\n              gchar *slot_contents;\n              gint slot_number;\n              gchar *endp;\n\n              dev_name = g_path_get_basename (device->priv->native_path);\n              md_dev_path = g_strdup_printf (\"%s/md/dev-%s\", holder->priv->native_path, dev_name);\n              state_contents = sysfs_get_string (md_dev_path, \"state\");\n              g_strstrip (state_contents);\n              state_tokens = g_strsplit (state_contents, \",\", 0);\n\n              slot_contents = sysfs_get_string (md_dev_path, \"slot\");\n              g_strstrip (slot_contents);\n              slot_number = strtol (slot_contents, &endp, 0);\n              if (endp != NULL && *endp == '\\0')\n                {\n                  md_comp_position = slot_number;\n                }\n\n              g_free (slot_contents);\n              g_free (state_contents);\n              g_free (md_dev_path);\n              g_free (dev_name);\n            }\n\n          device_set_linux_md_component_state (device, state_tokens);\n          g_strfreev (state_tokens);\n\n        }\n      else\n        {\n          /* no holder, nullify properties */\n          device_set_linux_md_component_holder (device, NULL);\n          device_set_linux_md_component_state (device, NULL);\n        }\n\n      md_comp_level = g_udev_device_get_property (device->priv->d, \"MD_LEVEL\");\n      md_comp_num_raid_devices = g_udev_device_get_property_as_int (device->priv->d, \"MD_DEVICES\");\n      md_comp_uuid = g_udev_device_get_property (device->priv->d, \"MD_UUID\");\n      md_name = g_strdup (g_udev_device_get_property (device->priv->d, \"MD_NAME\"));\n      s = NULL;\n      if (md_name != NULL)\n        s = strstr (md_name, \":\");\n      if (s != NULL)\n        {\n          *s = '\\0';\n          md_comp_home_host = md_name;\n          md_comp_name = s + 1;\n        }\n      else\n        {\n          md_comp_home_host = \"\";\n          md_comp_name = md_name;\n        }\n      md_comp_version = device->priv->id_version;\n\n      device_set_linux_md_component_level (device, md_comp_level);\n      device_set_linux_md_component_position (device, md_comp_position);\n      device_set_linux_md_component_num_raid_devices (device, md_comp_num_raid_devices);\n      device_set_linux_md_component_uuid (device, md_comp_uuid);\n      device_set_linux_md_component_home_host (device, md_comp_home_host);\n      device_set_linux_md_component_name (device, md_comp_name);\n      device_set_linux_md_component_version (device, md_comp_version);\n\n      g_free (md_name);\n    }\n  else\n    {\n      device_set_device_is_linux_md_component (device, FALSE);\n      device_set_linux_md_component_level (device, NULL);\n      device_set_linux_md_component_position (device, -1);\n      device_set_linux_md_component_num_raid_devices (device, 0);\n      device_set_linux_md_component_uuid (device, NULL);\n      device_set_linux_md_component_home_host (device, NULL);\n      device_set_linux_md_component_name (device, NULL);\n      device_set_linux_md_component_version (device, NULL);\n      device_set_linux_md_component_holder (device, NULL);\n      device_set_linux_md_component_state (device, NULL);\n    }\n\n  return TRUE;\n}\n",
        "output": "0",
        "index": 11846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "run_cmd(int fd, ...)\n {\n \tpid_t pid;\n \tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);\n\t\t\treturn -1;\n\t\t}\n \t} else {\n \t\t/* child: external program */\n \t\tlong fl;\n\t\tchar cmd[512];\n \t\t/* unmanage terminal, and reset it to canonical mode */\n \t\tterm_remove(STI);\n \t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n \t\tclose(STO);\n \t\tdup2(fd, STI);\n \t\tdup2(fd, STO);\n\t\t{\n\t\t\t/* build command-line */\n\t\t\tchar *c, *ce;\n\t\t\tconst char *s;\n\t\t\tint n;\n\t\t\tva_list vls;\n\t\t\tstrcpy(cmd, EXEC);\n\t\t\tc = &cmd[sizeof(EXEC)- 1];\n\t\t\tce = cmd + sizeof(cmd) - 1;\n\t\t\tva_start(vls, fd);\n\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n\t\t\t\tn = strlen(s);\n\t\t\t\tif ( c + n + 1 >= ce ) break;\n\t\t\t\tmemcpy(c, s, n); c += n;\n\t\t\t\t*c++ = ' ';\n\t\t\t}\n\t\t\tva_end(vls);\n\t\t\t*c = '\\0';\n \t\t}\n \t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);\n \t\testablish_child_signal_handlers();\n \t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n\t\texit(42);\n \t}\n }\n",
        "output": "1",
        "index": 182022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "date_time_from_opaque(tvbuff_t *tvb, guint32 offset, guint32 data_len)\n{\n\tchar *str;\n\n\tswitch (data_len) {\n\tcase 4: /* YYYY-MM-DD[T00:00:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT00:00:00Z\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3));\n\t\tbreak;\n\tcase 5: /* YYYY-MM-DDThh[:00:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:00:00Z\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 4));\n\t\tbreak;\n\tcase 6: /* YYYY-MM-DDThh:mm[:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:%02x:00Z\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 4),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 5));\n\t\tbreak;\n\tcase 7: /* YYYY-MM-DDThh:mm[:00Z] */\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"%%DateTime: \"\n\t\t\t\t      \"%02x%02x-%02x-%02xT%02x:%02x:%02xZ\",\n\t\t\t\t      tvb_get_guint8(tvb, offset),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 1),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 2),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 3),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 4),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 5),\n\t\t\t\t      tvb_get_guint8(tvb, offset + 6));\n\t\tbreak;\n\tdefault:\n\t\tstr = wmem_strdup_printf(wmem_packet_scope(), \"<Error: invalid binary %%DateTime \"\n\t\t\t\t      \"(%d bytes of opaque data)>\", data_len);\n\t\tbreak;\n\t}\n\n\treturn str;\n}\n",
        "output": "0",
        "index": 51693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParsePI(xmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len = 0;\n    int size = XML_PARSER_BUFFER_SIZE;\n    int cur, l;\n    const xmlChar *target;\n    xmlParserInputState state;\n    int count = 0;\n\n    if ((RAW == '<') && (NXT(1) == '?')) {\n\txmlParserInputPtr input = ctxt->input;\n\tstate = ctxt->instate;\n        ctxt->instate = XML_PARSER_PI;\n\t/*\n\t * this is a Processing Instruction.\n\t */\n\tSKIP(2);\n\tSHRINK;\n\n\t/*\n\t * Parse the target name and check for special support like\n\t * namespace.\n\t */\n        target = xmlParsePITarget(ctxt);\n\tif (target != NULL) {\n\t    if ((RAW == '?') && (NXT(1) == '>')) {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n \t\t    (ctxt->sax->processingInstruction != NULL))\n \t\t    ctxt->sax->processingInstruction(ctxt->userData,\n \t\t                                     target, NULL);\n\t\tctxt->instate = state;\n \t\treturn;\n \t    }\n \t    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n\t    if (buf == NULL) {\n\t\txmlErrMemory(ctxt, NULL);\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    cur = CUR;\n\t    if (!IS_BLANK(cur)) {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t  \"ParsePI: PI %s space expected\\n\", target);\n\t    }\n            SKIP_BLANKS;\n\t    cur = CUR_CHAR(l);\n\t    while (IS_CHAR(cur) && /* checked */\n\t\t   ((cur != '?') || (NXT(1) != '>'))) {\n\t\tif (len + 5 >= size) {\n\t\t    xmlChar *tmp;\n\n\t\t    size *= 2;\n\t\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t\t    if (tmp == NULL) {\n\t\t\txmlErrMemory(ctxt, NULL);\n\t\t\txmlFree(buf);\n\t\t\tctxt->instate = state;\n\t\t\treturn;\n\t\t    }\n\t\t    buf = tmp;\n\t\t}\n\t\tcount++;\n\t\tif (count > 50) {\n\t\t    GROW;\n\t\t    count = 0;\n\t\t}\n\t\tCOPY_BUF(l,buf,len,cur);\n\t\tNEXTL(l);\n\t\tcur = CUR_CHAR(l);\n\t\tif (cur == 0) {\n\t\t    SHRINK;\n\t\t    GROW;\n\t\t    cur = CUR_CHAR(l);\n\t\t}\n\t    }\n\t    buf[len] = 0;\n\t    if (cur != '?') {\n\t\txmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n\t\t      \"ParsePI: PI %s never end ...\\n\", target);\n\t    } else {\n\t\tif (input != ctxt->input) {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t    \"PI declaration doesn't start and stop in the same entity\\n\");\n\t\t}\n\t\tSKIP(2);\n\n#ifdef LIBXML_CATALOG_ENABLED\n\t\tif (((state == XML_PARSER_MISC) ||\n\t             (state == XML_PARSER_START)) &&\n\t\t    (xmlStrEqual(target, XML_CATALOG_PI))) {\n\t\t    xmlCatalogAllow allow = xmlCatalogGetDefaults();\n\t\t    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n\t\t\t(allow == XML_CATA_ALLOW_ALL))\n\t\t\txmlParseCatalogPI(ctxt, buf);\n\t\t}\n#endif\n\n\n\t\t/*\n\t\t * SAX: PI detected.\n\t\t */\n\t\tif ((ctxt->sax) && (!ctxt->disableSAX) &&\n\t\t    (ctxt->sax->processingInstruction != NULL))\n\t\t    ctxt->sax->processingInstruction(ctxt->userData,\n\t\t                                     target, buf);\n\t    }\n\t    xmlFree(buf);\n \t} else {\n \t    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n \t}\n\tctxt->instate = state;\n     }\n }\n",
        "output": "1",
        "index": 183633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline bool LayoutBlockFlow::layoutBlockFlow(bool relayoutChildren, LayoutUnit &pageLogicalHeight, SubtreeLayoutScope& layoutScope)\n{\n    LayoutUnit oldLeft = logicalLeft();\n    bool logicalWidthChanged = updateLogicalWidthAndColumnWidth();\n    relayoutChildren |= logicalWidthChanged;\n\n    rebuildFloatsFromIntruding();\n\n    bool pageLogicalHeightChanged = false;\n    bool hasSpecifiedPageLogicalHeight = false;\n    checkForPaginationLogicalHeightChange(pageLogicalHeight, pageLogicalHeightChanged, hasSpecifiedPageLogicalHeight);\n    if (pageLogicalHeightChanged)\n        relayoutChildren = true;\n\n    LayoutState state(*this, locationOffset(), pageLogicalHeight, pageLogicalHeightChanged, logicalWidthChanged);\n\n    if (!isTableCell()) {\n        initMaxMarginValues();\n        setHasMarginBeforeQuirk(style()->hasMarginBeforeQuirk());\n        setHasMarginAfterQuirk(style()->hasMarginAfterQuirk());\n        setPaginationStrut(0);\n    }\n\n    LayoutUnit beforeEdge = borderBefore() + paddingBefore();\n    LayoutUnit afterEdge = borderAfter() + paddingAfter() + scrollbarLogicalHeight();\n    LayoutUnit previousHeight = logicalHeight();\n    setLogicalHeight(beforeEdge);\n\n    m_paintInvalidationLogicalTop = 0;\n    m_paintInvalidationLogicalBottom = 0;\n    if (!firstChild() && !isAnonymousBlock())\n        setChildrenInline(true);\n\n    TextAutosizer::LayoutScope textAutosizerLayoutScope(this);\n\n    setContainsInlineWithOutlineAndContinuation(false);\n    if (childrenInline())\n        layoutInlineChildren(relayoutChildren, m_paintInvalidationLogicalTop, m_paintInvalidationLogicalBottom, afterEdge);\n    else\n        layoutBlockChildren(relayoutChildren, layoutScope, beforeEdge, afterEdge);\n\n    if (needsRecalcLogicalWidthAfterLayoutChildren()) {\n        clearNeedsRecalcLogicalWidthAfterLayoutChildren();\n        setPreferredLogicalWidthsDirty(MarkOnlyThis);\n        updateLogicalWidthAndColumnWidth();\n    }\n\n    if (lowestFloatLogicalBottom() > (logicalHeight() - afterEdge) && createsNewFormattingContext())\n        setLogicalHeight(lowestFloatLogicalBottom() + afterEdge);\n\n    if (LayoutMultiColumnFlowThread* flowThread = multiColumnFlowThread()) {\n        if (flowThread->recalculateColumnHeights()) {\n            setChildNeedsLayout(MarkOnlyThis);\n            return false;\n        }\n    }\n\n    if (shouldBreakAtLineToAvoidWidow()) {\n        setEverHadLayout();\n        return false;\n    }\n\n    LayoutUnit oldHeight = logicalHeight();\n    LayoutUnit oldClientAfterEdge = clientLogicalBottom();\n\n    updateLogicalHeight();\n    LayoutUnit newHeight = logicalHeight();\n    if (!childrenInline()) {\n        LayoutBlockFlow* lowestBlock = nullptr;\n        bool addedOverhangingFloats = false;\n        for (LayoutObject* child = lastChild(); child; child = child->previousSibling()) {\n            if (child->isLayoutBlockFlow() && !child->isFloatingOrOutOfFlowPositioned()) {\n                LayoutBlockFlow* block = toLayoutBlockFlow(child);\n                lowestBlock = block;\n                if (oldHeight <= newHeight || block->lowestFloatLogicalBottom() + block->logicalTop() <= newHeight)\n                    break;\n                addOverhangingFloats(block, false);\n                addedOverhangingFloats = true;\n            }\n        }\n        if (!addedOverhangingFloats)\n            addLowestFloatFromChildren(lowestBlock);\n    }\n\n    bool heightChanged = (previousHeight != newHeight);\n    if (heightChanged)\n        relayoutChildren = true;\n\n    layoutPositionedObjects(relayoutChildren || isDocumentElement(), oldLeft != logicalLeft() ? ForcedLayoutAfterContainingBlockMoved : DefaultLayout);\n\n    computeOverflow(oldClientAfterEdge);\n\n    m_descendantsWithFloatsMarkedForLayout = false;\n    return true;\n}\n",
        "output": "0",
        "index": 132083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LosslessReduceDepthOK(Image *image,ExceptionInfo *exception)\n{\n    /* Reduce bit depth if it can be reduced losslessly from 16+ to 8.\n     *\n     * This is true if the high byte and the next highest byte of\n     * each sample of the image, the colormap, and the background color\n     * are equal to each other.  We check this by seeing if the samples\n     * are unchanged when we scale them down to 8 and back up to Quantum.\n     *\n     * We don't use the method GetImageDepth() because it doesn't check\n     * background and doesn't handle PseudoClass specially.\n     */\n\n#define QuantumToCharToQuantumEqQuantum(quantum) \\\n ((ScaleCharToQuantum((unsigned char) ScaleQuantumToChar(quantum))) == quantum)\n\n    MagickBooleanType\n      ok_to_reduce=MagickFalse;\n\n    if (image->depth >= 16)\n      {\n\n        const Quantum\n          *p;\n\n        ok_to_reduce=\n           QuantumToCharToQuantumEqQuantum(image->background_color.red) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.green) &&\n           QuantumToCharToQuantumEqQuantum(image->background_color.blue) ?\n           MagickTrue : MagickFalse;\n\n        if (ok_to_reduce != MagickFalse && image->storage_class == PseudoClass)\n          {\n            int indx;\n\n            for (indx=0; indx < (ssize_t) image->colors; indx++)\n              {\n                ok_to_reduce=(\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].red) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].green) &&\n                   QuantumToCharToQuantumEqQuantum(\n                   image->colormap[indx].blue)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                   break;\n              }\n          }\n\n        if ((ok_to_reduce != MagickFalse) &&\n            (image->storage_class != PseudoClass))\n          {\n            ssize_t\n              y;\n\n            register ssize_t\n              x;\n\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n\n              if (p == (const Quantum *) NULL)\n                {\n                  ok_to_reduce = MagickFalse;\n                  break;\n                }\n\n              for (x=(ssize_t) image->columns-1; x >= 0; x--)\n              {\n                ok_to_reduce=\n                   QuantumToCharToQuantumEqQuantum(GetPixelRed(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelGreen(image,p)) &&\n                   QuantumToCharToQuantumEqQuantum(GetPixelBlue(image,p)) ?\n                   MagickTrue : MagickFalse;\n\n                if (ok_to_reduce == MagickFalse)\n                  break;\n\n                p+=GetPixelChannels(image);\n              }\n              if (x >= 0)\n                break;\n            }\n          }\n\n        if (ok_to_reduce != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    OK to reduce PNG bit depth to 8 without loss of info\");\n          }\n        else\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Not OK to reduce PNG bit depth to 8 without losing info\");\n          }\n      }\n\n    return ok_to_reduce;\n}\n",
        "output": "0",
        "index": 63296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err stbl_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n\n\tif (ptr->SampleDescription) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleDescription);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleDescription->size;\n\t}\n\tif (ptr->SampleSize) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleSize);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleSize->size;\n\t}\n\tif (ptr->SampleToChunk) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleToChunk);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleToChunk->size;\n\t}\n\tif (ptr->TimeToSample) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->TimeToSample);\n\t\tif (e) return e;\n\t\tptr->size += ptr->TimeToSample->size;\n\t}\n\tif (ptr->ChunkOffset) {\n\t\te = gf_isom_box_size(ptr->ChunkOffset);\n\t\tif (e) return e;\n\t\tptr->size += ptr->ChunkOffset->size;\n\t}\n\n\tif (ptr->CompositionOffset)\t{\n\t\te = gf_isom_box_size((GF_Box *) ptr->CompositionOffset);\n\t\tif (e) return e;\n\t\tptr->size += ptr->CompositionOffset->size;\n\t}\n\tif (ptr->CompositionToDecode)\t{\n\t\te = gf_isom_box_size((GF_Box *) ptr->CompositionToDecode);\n\t\tif (e) return e;\n\t\tptr->size += ptr->CompositionToDecode->size;\n\t}\n\tif (ptr->DegradationPriority) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->DegradationPriority);\n\t\tif (e) return e;\n\t\tptr->size += ptr->DegradationPriority->size;\n\t}\n\tif (ptr->ShadowSync) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->ShadowSync);\n\t\tif (e) return e;\n\t\tptr->size += ptr->ShadowSync->size;\n\t}\n\tif (ptr->SyncSample) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SyncSample);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SyncSample->size;\n\t}\n\tif (ptr->SampleDep && ptr->SampleDep->sampleCount) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->SampleDep);\n\t\tif (e) return e;\n\t\tptr->size += ptr->SampleDep->size;\n\t}\n\tif (ptr->PaddingBits) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->PaddingBits);\n\t\tif (e) return e;\n\t\tptr->size += ptr->PaddingBits->size;\n\t}\n#if WRITE_SAMPLE_FRAGMENTS\n\tif (ptr->Fragments) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->Fragments);\n\t\tif (e) return e;\n\t\tptr->size += ptr->Fragments->size;\n\t}\n#endif\n\n\tif (ptr->sub_samples) {\n\t\te = gf_isom_box_array_size(s, ptr->sub_samples);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroups) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroups);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sampleGroupsDescription) {\n\t\te = gf_isom_box_array_size(s, ptr->sampleGroupsDescription);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_sizes) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_sizes);\n\t\tif (e) return e;\n\t}\n\tif (ptr->sai_offsets) {\n\t\te = gf_isom_box_array_size(s, ptr->sai_offsets);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n",
        "output": "0",
        "index": 80437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PageInfoUI::GetSecurityDescription(const IdentityInfo& identity_info) const {\n   std::unique_ptr<PageInfoUI::SecurityDescription> security_description(\n       new PageInfoUI::SecurityDescription());\n \n  switch (identity_info.safe_browsing_status) {\n    case PageInfo::SAFE_BROWSING_STATUS_NONE:\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_MALWARE:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_MALWARE_SUMMARY,\n                                       IDS_PAGE_INFO_MALWARE_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING:\n      return CreateSecurityDescription(\n          SecuritySummaryColor::RED, IDS_PAGE_INFO_SOCIAL_ENGINEERING_SUMMARY,\n          IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_SUMMARY,\n                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);\n    case PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE:\n#if defined(FULL_SAFE_BROWSING)\n      return CreateSecurityDescriptionForPasswordReuse(\n          /*is_enterprise_password=*/false);\n#endif\n      NOTREACHED();\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE:\n#if defined(FULL_SAFE_BROWSING)\n      return CreateSecurityDescriptionForPasswordReuse(\n          /*is_enterprise_password=*/true);\n#endif\n      NOTREACHED();\n      break;\n    case PageInfo::SAFE_BROWSING_STATUS_BILLING:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_BILLING_SUMMARY,\n                                       IDS_PAGE_INFO_BILLING_DETAILS);\n  }\n   switch (identity_info.identity_status) {\n     case PageInfo::SITE_IDENTITY_STATUS_INTERNAL_PAGE:\n #if defined(OS_ANDROID)\n      return CreateSecurityDescription(SecuritySummaryColor::GREEN,\n                                       IDS_PAGE_INFO_INTERNAL_PAGE,\n                                       IDS_PAGE_INFO_INTERNAL_PAGE);\n#else\n      NOTREACHED();\n      FALLTHROUGH;\n#endif\n    case PageInfo::SITE_IDENTITY_STATUS_EV_CERT:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_CERT:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_CERT_REVOCATION_UNKNOWN:\n      FALLTHROUGH;\n    case PageInfo::SITE_IDENTITY_STATUS_ADMIN_PROVIDED_CERT:\n      switch (identity_info.connection_status) {\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_ACTIVE_SUBRESOURCE:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_NOT_SECURE_SUMMARY,\n                                           IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_FORM_ACTION:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,\n                                           IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n        case PageInfo::SITE_CONNECTION_STATUS_INSECURE_PASSIVE_SUBRESOURCE:\n          return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,\n                                           IDS_PAGE_INFO_MIXED_CONTENT_DETAILS);\n        default:\n          return CreateSecurityDescription(SecuritySummaryColor::GREEN,\n                                            IDS_PAGE_INFO_SECURE_SUMMARY,\n                                            IDS_PAGE_INFO_SECURE_DETAILS);\n       }\n     case PageInfo::SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM:\n     case PageInfo::SITE_IDENTITY_STATUS_UNKNOWN:\n     case PageInfo::SITE_IDENTITY_STATUS_NO_CERT:\n    default:\n      return CreateSecurityDescription(SecuritySummaryColor::RED,\n                                       IDS_PAGE_INFO_NOT_SECURE_SUMMARY,\n                                       IDS_PAGE_INFO_NOT_SECURE_DETAILS);\n  }\n}\n",
        "output": "1",
        "index": 186408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AutofillDownloadManager::OnURLFetchComplete(\n    const URLFetcher* source,\n    const GURL& url,\n    const net::URLRequestStatus& status,\n    int response_code,\n    const net::ResponseCookies& cookies,\n    const std::string& data) {\n  std::map<URLFetcher *, FormRequestData>::iterator it =\n      url_fetchers_.find(const_cast<URLFetcher*>(source));\n  if (it == url_fetchers_.end()) {\n    return;\n  }\n  std::string type_of_request(\n      it->second.request_type == AutofillDownloadManager::REQUEST_QUERY ?\n          \"query\" : \"upload\");\n  const int kHttpResponseOk = 200;\n  const int kHttpInternalServerError = 500;\n  const int kHttpBadGateway = 502;\n  const int kHttpServiceUnavailable = 503;\n\n  CHECK(it->second.form_signatures.size());\n  if (response_code != kHttpResponseOk) {\n    bool back_off = false;\n    std::string server_header;\n    switch (response_code) {\n      case kHttpBadGateway:\n        if (!source->response_headers()->EnumerateHeader(NULL, \"server\",\n                                                         &server_header) ||\n            StartsWithASCII(server_header.c_str(),\n                            AUTO_FILL_QUERY_SERVER_NAME_START_IN_HEADER,\n                            false) != 0)\n          break;\n      case kHttpInternalServerError:\n      case kHttpServiceUnavailable:\n        back_off = true;\n        break;\n    }\n\n    if (back_off) {\n      base::Time back_off_time(base::Time::Now() + source->backoff_delay());\n      if (it->second.request_type == AutofillDownloadManager::REQUEST_QUERY) {\n        next_query_request_ = back_off_time;\n      } else {\n        next_upload_request_ = back_off_time;\n      }\n    }\n\n    LOG(WARNING) << \"AutofillDownloadManager: \" << type_of_request\n                 << \" request has failed with response \" << response_code;\n    if (observer_) {\n      observer_->OnHeuristicsRequestError(it->second.form_signatures[0],\n                                          it->second.request_type,\n                                          response_code);\n    }\n  } else {\n    VLOG(1) << \"AutofillDownloadManager: \" << type_of_request\n            << \" request has succeeded\";\n    if (it->second.request_type == AutofillDownloadManager::REQUEST_QUERY) {\n      CacheQueryRequest(it->second.form_signatures, data);\n      if (observer_)\n        observer_->OnLoadedAutofillHeuristics(data);\n    } else {\n      double new_positive_upload_rate = 0;\n      double new_negative_upload_rate = 0;\n      AutofillUploadXmlParser parse_handler(&new_positive_upload_rate,\n                                            &new_negative_upload_rate);\n      buzz::XmlParser parser(&parse_handler);\n      parser.Parse(data.data(), data.length(), true);\n      if (parse_handler.succeeded()) {\n        SetPositiveUploadRate(new_positive_upload_rate);\n        SetNegativeUploadRate(new_negative_upload_rate);\n      }\n\n      if (observer_)\n        observer_->OnUploadedAutofillHeuristics(it->second.form_signatures[0]);\n    }\n  }\n  delete it->first;\n  url_fetchers_.erase(it);\n}\n",
        "output": "0",
        "index": 105310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int caif_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct caifsock *cf_sk = NULL;\n\tstatic struct proto prot = {.name = \"PF_CAIF\",\n\t\t.owner = THIS_MODULE,\n\t\t.obj_size = sizeof(struct caifsock),\n\t};\n\n\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\t/*\n\t * The sock->type specifies the socket type to use.\n\t * The CAIF socket is a packet stream in the sense\n\t * that it is packet based. CAIF trusts the reliability\n\t * of the link, no resending is implemented.\n\t */\n\tif (sock->type == SOCK_SEQPACKET)\n\t\tsock->ops = &caif_seqpacket_ops;\n\telse if (sock->type == SOCK_STREAM)\n\t\tsock->ops = &caif_stream_ops;\n\telse\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (protocol < 0 || protocol >= CAIFPROTO_MAX)\n\t\treturn -EPROTONOSUPPORT;\n\t/*\n\t * Set the socket state to unconnected.\t The socket state\n\t * is really not used at all in the net/core or socket.c but the\n\t * initialization makes sure that sock->state is not uninitialized.\n\t */\n\tsk = sk_alloc(net, PF_CAIF, GFP_KERNEL, &prot);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tcf_sk = container_of(sk, struct caifsock, sk);\n\n\t/* Store the protocol */\n\tsk->sk_protocol = (unsigned char) protocol;\n\n\t/* Initialize default priority for well-known cases */\n\tswitch (protocol) {\n\tcase CAIFPROTO_AT:\n\t\tsk->sk_priority = TC_PRIO_CONTROL;\n\t\tbreak;\n\tcase CAIFPROTO_RFM:\n\t\tsk->sk_priority = TC_PRIO_INTERACTIVE_BULK;\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_priority = TC_PRIO_BESTEFFORT;\n\t}\n\n\t/*\n\t * Lock in order to try to stop someone from opening the socket\n\t * too early.\n\t */\n\tlock_sock(&(cf_sk->sk));\n\n\t/* Initialize the nozero default sock structure data. */\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = caif_sock_destructor;\n\n\tmutex_init(&cf_sk->readlock); /* single task reading lock */\n\tcf_sk->layer.ctrlcmd = caif_ctrl_cb;\n\tcf_sk->sk.sk_socket->state = SS_UNCONNECTED;\n\tcf_sk->sk.sk_state = CAIF_DISCONNECTED;\n\n\tset_tx_flow_off(cf_sk);\n\tset_rx_flow_on(cf_sk);\n\n\t/* Set default options on configuration */\n\tcf_sk->conn_req.link_selector = CAIF_LINK_LOW_LATENCY;\n\tcf_sk->conn_req.protocol = protocol;\n\trelease_sock(&cf_sk->sk);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 30667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_xhci_initfn(struct PCIDevice *dev)\n{\n    int i, ret;\n\n    XHCIState *xhci = XHCI(dev);\n\n    dev->config[PCI_CLASS_PROG] = 0x30;    /* xHCI */\n    dev->config[PCI_INTERRUPT_PIN] = 0x01; /* interrupt pin 1 */\n    dev->config[PCI_CACHE_LINE_SIZE] = 0x10;\n    dev->config[0x60] = 0x30; /* release number */\n\n    usb_xhci_init(xhci);\n\n    if (xhci->numintrs > MAXINTRS) {\n        xhci->numintrs = MAXINTRS;\n    }\n    while (xhci->numintrs & (xhci->numintrs - 1)) {   /* ! power of 2 */\n        xhci->numintrs++;\n    }\n    if (xhci->numintrs < 1) {\n        xhci->numintrs = 1;\n    }\n    if (xhci->numslots > MAXSLOTS) {\n        xhci->numslots = MAXSLOTS;\n    }\n    if (xhci->numslots < 1) {\n        xhci->numslots = 1;\n    }\n\n    xhci->mfwrap_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, xhci_mfwrap_timer, xhci);\n\n    memory_region_init(&xhci->mem, OBJECT(xhci), \"xhci\", LEN_REGS);\n    memory_region_init_io(&xhci->mem_cap, OBJECT(xhci), &xhci_cap_ops, xhci,\n                          \"capabilities\", LEN_CAP);\n    memory_region_init_io(&xhci->mem_oper, OBJECT(xhci), &xhci_oper_ops, xhci,\n                          \"operational\", 0x400);\n    memory_region_init_io(&xhci->mem_runtime, OBJECT(xhci), &xhci_runtime_ops, xhci,\n                          \"runtime\", LEN_RUNTIME);\n    memory_region_init_io(&xhci->mem_doorbell, OBJECT(xhci), &xhci_doorbell_ops, xhci,\n                          \"doorbell\", LEN_DOORBELL);\n\n    memory_region_add_subregion(&xhci->mem, 0,            &xhci->mem_cap);\n    memory_region_add_subregion(&xhci->mem, OFF_OPER,     &xhci->mem_oper);\n    memory_region_add_subregion(&xhci->mem, OFF_RUNTIME,  &xhci->mem_runtime);\n    memory_region_add_subregion(&xhci->mem, OFF_DOORBELL, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        uint32_t offset = OFF_OPER + 0x400 + 0x10 * i;\n        port->xhci = xhci;\n        memory_region_init_io(&port->mem, OBJECT(xhci), &xhci_port_ops, port,\n                              port->name, 0x10);\n        memory_region_add_subregion(&xhci->mem, offset, &port->mem);\n    }\n\n    pci_register_bar(dev, 0,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64,\n                     &xhci->mem);\n\n    if (pci_bus_is_express(dev->bus)) {\n        ret = pcie_endpoint_cap_init(dev, 0xa0);\n        assert(ret >= 0);\n    }\n\n    if (xhci_get_flag(xhci, XHCI_FLAG_USE_MSI)) {\n        msi_init(dev, 0x70, xhci->numintrs, true, false);\n    }\n    if (xhci_get_flag(xhci, XHCI_FLAG_USE_MSI_X)) {\n        msix_init(dev, xhci->numintrs,\n                  &xhci->mem, 0, OFF_MSIX_TABLE,\n                  &xhci->mem, 0, OFF_MSIX_PBA,\n                  0x90);\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 10731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "authentic_pin_reset(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct authentic_private_data *prv_data = (struct authentic_private_data *) card->drv_data;\n\tstruct sc_pin_cmd_data pin_cmd, puk_cmd;\n\tstruct sc_apdu apdu;\n\tunsigned reference;\n\tint rv, ii;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"reset PIN (ref:%i,lengths %i/%i)\", data->pin_reference, data->pin1.len, data->pin2.len);\n\n\tmemset(prv_data->pins_sha1[data->pin_reference], 0, sizeof(prv_data->pins_sha1[0]));\n\n\tmemset(&pin_cmd, 0, sizeof(pin_cmd));\n\tpin_cmd.pin_reference = data->pin_reference;\n\tpin_cmd.pin_type = data->pin_type;\n\tpin_cmd.pin1.tries_left = -1;\n\n\trv = authentic_pin_get_policy(card, &pin_cmd);\n\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\tif (pin_cmd.pin1.acls[AUTHENTIC_ACL_NUM_PIN_RESET].method == SC_AC_CHV)   {\n\t\tfor (ii=0;ii<8;ii++)   {\n\t\t\tunsigned char mask = 0x01 << ii;\n\t\t\tif (pin_cmd.pin1.acls[AUTHENTIC_ACL_NUM_PIN_RESET].key_ref & mask)   {\n\t\t\t\tmemset(&puk_cmd, 0, sizeof(puk_cmd));\n\t\t\t\tpuk_cmd.pin_reference = ii + 1;\n\n\t\t\t\trv = authentic_pin_get_policy(card, &puk_cmd);\n\t\t\t\tLOG_TEST_RET(ctx, rv, \"Get 'PIN policy' error\");\n\n\t\t\t\tif (puk_cmd.pin_type == SC_AC_CHV)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ii < 8)   {\n\t\t\tpuk_cmd.pin1.data = data->pin1.data;\n\t\t\tpuk_cmd.pin1.len = data->pin1.len;\n\n\t\t\trv = authentic_pin_verify(card, &puk_cmd);\n\n\t\t\tif (tries_left && rv == SC_ERROR_PIN_CODE_INCORRECT)\n\t\t\t\t*tries_left = puk_cmd.pin1.tries_left;\n\n\t\t\tLOG_TEST_RET(ctx, rv, \"Cannot verify PUK\");\n\t\t}\n\t}\n\n\treference = data->pin_reference;\n\tif (data->pin2.len)   {\n\t\tunsigned char pin_data[SC_MAX_APDU_BUFFER_SIZE];\n\n\t\tmemset(pin_data, pin_cmd.pin1.pad_char, sizeof(pin_data));\n\t\tmemcpy(pin_data, data->pin2.data, data->pin2.len);\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x2C, 0x02, reference);\n\t\tapdu.data = pin_data;\n\t\tapdu.datalen = pin_cmd.pin1.pad_length;\n\t\tapdu.lc = pin_cmd.pin1.pad_length;\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\t}\n\telse if (data->pin2.data) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x2C, 3, reference);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"PIN cmd failed\");\n\t}\n\telse   {\n\t\trv = authentic_chv_set_pinpad(card, reference);\n\t\tLOG_TEST_RET(ctx, rv, \"Failed to set PIN with pin-pad\");\n\t}\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}\n",
        "output": "0",
        "index": 78205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void arcmsr_post_ccb(struct AdapterControlBlock *acb, struct CommandControlBlock *ccb)\n{\n\tuint32_t cdb_phyaddr = ccb->cdb_phyaddr;\n\tstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\n\tatomic_inc(&acb->ccboutstandingcount);\n\tccb->startdone = ARCMSR_CCB_START;\n\tswitch (acb->adapter_type) {\n\tcase ACB_ADAPTER_TYPE_A: {\n\t\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE)\n\t\t\twritel(cdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\n\t\t\t&reg->inbound_queueport);\n\t\telse\n\t\t\twritel(cdb_phyaddr, &reg->inbound_queueport);\n\t\tbreak;\n\t}\n\n\tcase ACB_ADAPTER_TYPE_B: {\n\t\tstruct MessageUnit_B *reg = acb->pmuB;\n\t\tuint32_t ending_index, index = reg->postq_index;\n\n\t\tending_index = ((index + 1) % ARCMSR_MAX_HBB_POSTQUEUE);\n\t\treg->post_qbuffer[ending_index] = 0;\n\t\tif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE) {\n\t\t\treg->post_qbuffer[index] =\n\t\t\t\tcdb_phyaddr | ARCMSR_CCBPOST_FLAG_SGL_BSIZE;\n\t\t} else {\n\t\t\treg->post_qbuffer[index] = cdb_phyaddr;\n\t\t}\n\t\tindex++;\n\t\tindex %= ARCMSR_MAX_HBB_POSTQUEUE;/*if last index number set it to 0 */\n\t\treg->postq_index = index;\n\t\twritel(ARCMSR_DRV2IOP_CDB_POSTED, reg->drv2iop_doorbell);\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_C: {\n\t\tstruct MessageUnit_C __iomem *phbcmu = acb->pmuC;\n\t\tuint32_t ccb_post_stamp, arc_cdb_size;\n\n\t\tarc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\n\t\tccb_post_stamp = (cdb_phyaddr | ((arc_cdb_size - 1) >> 6) | 1);\n\t\tif (acb->cdb_phyaddr_hi32) {\n\t\t\twritel(acb->cdb_phyaddr_hi32, &phbcmu->inbound_queueport_high);\n\t\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t} else {\n\t\t\twritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACB_ADAPTER_TYPE_D: {\n\t\tstruct MessageUnit_D  *pmu = acb->pmuD;\n\t\tu16 index_stripped;\n\t\tu16 postq_index, toggle;\n\t\tunsigned long flags;\n\t\tstruct InBound_SRB *pinbound_srb;\n\n\t\tspin_lock_irqsave(&acb->postq_lock, flags);\n\t\tpostq_index = pmu->postq_index;\n\t\tpinbound_srb = (struct InBound_SRB *)&(pmu->post_qbuffer[postq_index & 0xFF]);\n\t\tpinbound_srb->addressHigh = dma_addr_hi32(cdb_phyaddr);\n\t\tpinbound_srb->addressLow = dma_addr_lo32(cdb_phyaddr);\n\t\tpinbound_srb->length = ccb->arc_cdb_size >> 2;\n\t\tarcmsr_cdb->msgContext = dma_addr_lo32(cdb_phyaddr);\n\t\ttoggle = postq_index & 0x4000;\n\t\tindex_stripped = postq_index + 1;\n\t\tindex_stripped &= (ARCMSR_MAX_ARC1214_POSTQUEUE - 1);\n\t\tpmu->postq_index = index_stripped ? (index_stripped | toggle) :\n\t\t\t(toggle ^ 0x4000);\n\t\twritel(postq_index, pmu->inboundlist_write_pointer);\n\t\tspin_unlock_irqrestore(&acb->postq_lock, flags);\n\t\tbreak;\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 49821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kvm_vcpu *vmx_create_vcpu(struct kvm *kvm, unsigned int id)\n{\n\tint err;\n\tstruct vcpu_vmx *vmx = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);\n\tint cpu;\n\n\tif (!vmx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tallocate_vpid(vmx);\n\n\terr = kvm_vcpu_init(&vmx->vcpu, kvm, id);\n\tif (err)\n\t\tgoto free_vcpu;\n\n\tvmx->guest_msrs = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!vmx->guest_msrs) {\n\t\tgoto uninit_vcpu;\n\t}\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tvmx->loaded_vmcs->vmcs = alloc_vmcs();\n\tif (!vmx->loaded_vmcs->vmcs)\n\t\tgoto free_msrs;\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxon(__pa(per_cpu(vmxarea, raw_smp_processor_id())));\n\tloaded_vmcs_init(vmx->loaded_vmcs);\n\tif (!vmm_exclusive)\n\t\tkvm_cpu_vmxoff();\n\n\tcpu = get_cpu();\n\tvmx_vcpu_load(&vmx->vcpu, cpu);\n\tvmx->vcpu.cpu = cpu;\n\terr = vmx_vcpu_setup(vmx);\n\tvmx_vcpu_put(&vmx->vcpu);\n\tput_cpu();\n\tif (err)\n\t\tgoto free_vmcs;\n\tif (vm_need_virtualize_apic_accesses(kvm)) {\n\t\terr = alloc_apic_access_page(kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept) {\n\t\tif (!kvm->arch.ept_identity_map_addr)\n\t\t\tkvm->arch.ept_identity_map_addr =\n\t\t\t\tVMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\t\terr = -ENOMEM;\n\t\tif (alloc_identity_pagetable(kvm) != 0)\n\t\t\tgoto free_vmcs;\n\t\tif (!init_rmode_identity_map(kvm))\n\t\t\tgoto free_vmcs;\n\t}\n\n\tvmx->nested.current_vmptr = -1ull;\n\tvmx->nested.current_vmcs12 = NULL;\n\n\treturn &vmx->vcpu;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_msrs:\n\tkfree(vmx->guest_msrs);\nuninit_vcpu:\n\tkvm_vcpu_uninit(&vmx->vcpu);\nfree_vcpu:\n\tfree_vpid(vmx);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n\treturn ERR_PTR(err);\n}\n",
        "output": "0",
        "index": 37662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\tint ret;\n\n\tif (clone_flags & CLONE_THREAD) {\n\t\tret = thread_group_cputime_clone_thread(current);\n\t\tif (likely(!ret)) {\n\t\t\tatomic_inc(&current->signal->count);\n\t\t\tatomic_inc(&current->signal->live);\n\t\t}\n\t\treturn ret;\n\t}\n\tsig = kmem_cache_alloc(signal_cachep, GFP_KERNEL);\n\ttsk->signal = sig;\n\tif (!sig)\n\t\treturn -ENOMEM;\n\n\tret = copy_thread_group_keys(tsk);\n\tif (ret < 0) {\n\t\tkmem_cache_free(signal_cachep, sig);\n\t\treturn ret;\n\t}\n\n\tatomic_set(&sig->count, 1);\n\tatomic_set(&sig->live, 1);\n\tinit_waitqueue_head(&sig->wait_chldexit);\n\tsig->flags = 0;\n\tsig->group_exit_code = 0;\n\tsig->group_exit_task = NULL;\n\tsig->group_stop_count = 0;\n\tsig->curr_target = tsk;\n\tinit_sigpending(&sig->shared_pending);\n\tINIT_LIST_HEAD(&sig->posix_timers);\n\n\thrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsig->it_real_incr.tv64 = 0;\n\tsig->real_timer.function = it_real_fn;\n\n\tsig->leader = 0;\t/* session leadership doesn't inherit */\n\tsig->tty_old_pgrp = NULL;\n\tsig->tty = NULL;\n\n\tsig->cutime = sig->cstime = cputime_zero;\n\tsig->gtime = cputime_zero;\n\tsig->cgtime = cputime_zero;\n\tsig->nvcsw = sig->nivcsw = sig->cnvcsw = sig->cnivcsw = 0;\n\tsig->min_flt = sig->maj_flt = sig->cmin_flt = sig->cmaj_flt = 0;\n\tsig->inblock = sig->oublock = sig->cinblock = sig->coublock = 0;\n\ttask_io_accounting_init(&sig->ioac);\n\ttaskstats_tgid_init(sig);\n\n\ttask_lock(current->group_leader);\n\tmemcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n\ttask_unlock(current->group_leader);\n\n\tposix_cpu_timers_init_group(sig);\n\n\tacct_init_pacct(&sig->pacct);\n\n\ttty_audit_fork(sig);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 22158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_zip_add_from_pattern(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *path = NULL;\n\tchar *remove_path = NULL;\n\tchar *add_path = NULL;\n\tsize_t  add_path_len, remove_path_len = 0, path_len = 0;\n\tzend_long remove_all_path = 0;\n\tzend_long flags = 0;\n\tzval *options = NULL;\n\tint found;\n\tzend_string *pattern;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\t/* 1 == glob, 2 == pcre */\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|la\",\n\t\t\t\t\t&pattern, &flags, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|sa\",\n\t\t\t\t\t&pattern, &path, &path_len, &options) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ZSTR_LEN(pattern) == 0) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Empty string as pattern\");\n\t\tRETURN_FALSE;\n\t}\n\tif (options && (php_zip_parse_options(options, &remove_all_path, &remove_path, &remove_path_len,\n\t\t\t&add_path, &add_path_len) < 0)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (remove_path && remove_path_len > 1) {\n\t\tsize_t real_len = strlen(remove_path);\n\t\tif ((real_len > 1) && ((remove_path[real_len - 1] == '/') || (remove_path[real_len - 1] == '\\\\'))) {\n\t\t\tremove_path[real_len - 1] = '\\0';\n\t\t}\n\t}\n\n\tif (type == 1) {\n\t\tfound = php_zip_glob(ZSTR_VAL(pattern), ZSTR_LEN(pattern), flags, return_value);\n\t} else {\n\t\tfound = php_zip_pcre(pattern, path, path_len, return_value);\n\t}\n\n\tif (found > 0) {\n\t\tint i;\n\t\tzval *zval_file;\n\n\t\tfor (i = 0; i < found; i++) {\n\t\t\tchar *file_stripped, *entry_name;\n\t\t\tsize_t entry_name_len, file_stripped_len;\n\t\t\tchar entry_name_buf[MAXPATHLEN];\n\t\t\tzend_string *basename = NULL;\n\n\t\t\tif ((zval_file = zend_hash_index_find(Z_ARRVAL_P(return_value), i)) != NULL) {\n\t\t\t\tif (remove_all_path) {\n\t\t\t\t\tbasename = php_basename(Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file), NULL, 0);\n\t\t\t\t\tfile_stripped = ZSTR_VAL(basename);\n\t\t\t\t\tfile_stripped_len = ZSTR_LEN(basename);\n\t\t\t\t} else if (remove_path && strstr(Z_STRVAL_P(zval_file), remove_path) != NULL) {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file) + remove_path_len + 1;\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file) - remove_path_len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tfile_stripped = Z_STRVAL_P(zval_file);\n\t\t\t\t\tfile_stripped_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\n\t\t\t\tif (add_path) {\n\t\t\t\t\tif ((add_path_len + file_stripped_len) > MAXPATHLEN) {\n\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Entry name too long (max: %d, %pd given)\",\n\t\t\t\t\t\tMAXPATHLEN - 1, (add_path_len + file_stripped_len));\n\t\t\t\t\t\tzval_ptr_dtor(return_value);\n\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(entry_name_buf, MAXPATHLEN, \"%s%s\", add_path, file_stripped);\n\t\t\t\t\tentry_name = entry_name_buf;\n\t\t\t\t\tentry_name_len = strlen(entry_name);\n\t\t\t\t} else {\n\t\t\t\t\tentry_name = Z_STRVAL_P(zval_file);\n\t\t\t\t\tentry_name_len = Z_STRLEN_P(zval_file);\n\t\t\t\t}\n\t\t\t\tif (basename) {\n\t\t\t\t\tzend_string_release(basename);\n\t\t\t\t\tbasename = NULL;\n\t\t\t\t}\n\t\t\t\tif (php_zip_add_file(intern, Z_STRVAL_P(zval_file), Z_STRLEN_P(zval_file),\n\t\t\t\t\tentry_name, entry_name_len, 0, 0) < 0) {\n\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n/* }}} */\n",
        "output": "0",
        "index": 54419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int power_pmu_event_init(struct perf_event *event)\n{\n\tu64 ev;\n\tunsigned long flags;\n\tstruct perf_event *ctrs[MAX_HWEVENTS];\n\tu64 events[MAX_HWEVENTS];\n\tunsigned int cflags[MAX_HWEVENTS];\n\tint n;\n\tint err;\n\tstruct cpu_hw_events *cpuhw;\n\n\tif (!ppmu)\n\t\treturn -ENOENT;\n\n\tswitch (event->attr.type) {\n\tcase PERF_TYPE_HARDWARE:\n\t\tev = event->attr.config;\n\t\tif (ev >= ppmu->n_generic || ppmu->generic_events[ev] == 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tev = ppmu->generic_events[ev];\n\t\tbreak;\n\tcase PERF_TYPE_HW_CACHE:\n\t\terr = hw_perf_cache_event(event->attr.config, &ev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase PERF_TYPE_RAW:\n\t\tev = event->attr.config;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\tevent->hw.config_base = ev;\n\tevent->hw.idx = 0;\n\n\t/*\n\t * If we are not running on a hypervisor, force the\n\t * exclude_hv bit to 0 so that we don't care what\n\t * the user set it to.\n\t */\n\tif (!firmware_has_feature(FW_FEATURE_LPAR))\n\t\tevent->attr.exclude_hv = 0;\n\n\t/*\n\t * If this is a per-task event, then we can use\n\t * PM_RUN_* events interchangeably with their non RUN_*\n\t * equivalents, e.g. PM_RUN_CYC instead of PM_CYC.\n\t * XXX we should check if the task is an idle task.\n\t */\n\tflags = 0;\n\tif (event->attach_state & PERF_ATTACH_TASK)\n\t\tflags |= PPMU_ONLY_COUNT_RUN;\n\n\t/*\n\t * If this machine has limited events, check whether this\n\t * event_id could go on a limited event.\n\t */\n\tif (ppmu->flags & PPMU_LIMITED_PMC5_6) {\n\t\tif (can_go_on_limited_pmc(event, ev, flags)) {\n\t\t\tflags |= PPMU_LIMITED_PMC_OK;\n\t\t} else if (ppmu->limited_pmc_event(ev)) {\n\t\t\t/*\n\t\t\t * The requested event_id is on a limited PMC,\n\t\t\t * but we can't use a limited PMC; see if any\n\t\t\t * alternative goes on a normal PMC.\n\t\t\t */\n\t\t\tev = normal_pmc_alternative(ev, flags);\n\t\t\tif (!ev)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * If this is in a group, check if it can go on with all the\n\t * other hardware events in the group.  We assume the event\n\t * hasn't been linked into its leader's sibling list at this point.\n\t */\n\tn = 0;\n\tif (event->group_leader != event) {\n\t\tn = collect_events(event->group_leader, ppmu->n_counter - 1,\n\t\t\t\t   ctrs, events, cflags);\n\t\tif (n < 0)\n\t\t\treturn -EINVAL;\n\t}\n\tevents[n] = ev;\n\tctrs[n] = event;\n\tcflags[n] = flags;\n\tif (check_excludes(ctrs, cflags, n, 1))\n\t\treturn -EINVAL;\n\n\tcpuhw = &get_cpu_var(cpu_hw_events);\n\terr = power_check_constraints(cpuhw, events, cflags, n + 1);\n\tput_cpu_var(cpu_hw_events);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tevent->hw.config = events[n];\n\tevent->hw.event_base = cflags[n];\n\tevent->hw.last_period = event->hw.sample_period;\n\tlocal64_set(&event->hw.period_left, event->hw.last_period);\n\n\t/*\n\t * See if we need to reserve the PMU.\n\t * If no events are currently in use, then we have to take a\n\t * mutex to ensure that we don't race with another task doing\n\t * reserve_pmc_hardware or release_pmc_hardware.\n\t */\n\terr = 0;\n\tif (!atomic_inc_not_zero(&num_events)) {\n\t\tmutex_lock(&pmc_reserve_mutex);\n\t\tif (atomic_read(&num_events) == 0 &&\n\t\t    reserve_pmc_hardware(perf_event_interrupt))\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\tatomic_inc(&num_events);\n\t\tmutex_unlock(&pmc_reserve_mutex);\n\t}\n\tevent->destroy = hw_perf_event_destroy;\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 22699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,\n                             struct snd_ctl_tlv __user *_tlv,\n                             int op_flag)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_tlv tlv;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int len;\n\tint err = 0;\n\n\tif (copy_from_user(&tlv, _tlv, sizeof(tlv)))\n\t\treturn -EFAULT;\n\tif (tlv.length < sizeof(unsigned int) * 2)\n\t\treturn -EINVAL;\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_numid(card, tlv.numid);\n\tif (kctl == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto __kctl_end;\n\t}\n\tif (kctl->tlv.p == NULL) {\n\t\terr = -ENXIO;\n\t\tgoto __kctl_end;\n\t}\n\tvd = &kctl->vd[tlv.numid - kctl->id.numid];\n\tif ((op_flag == 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) == 0) ||\n\t    (op_flag > 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) == 0) ||\n\t    (op_flag < 0 && (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND) == 0)) {\n\t    \terr = -ENXIO;\n\t    \tgoto __kctl_end;\n\t}\n\tif (vd->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tif (vd->owner != NULL && vd->owner != file) {\n\t\t\terr = -EPERM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\terr = kctl->tlv.c(kctl, op_flag, tlv.length, _tlv->tlv);\n\t\tif (err > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_TLV, &kctl->id);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (op_flag) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tlen = kctl->tlv.p[1] + 2 * sizeof(unsigned int);\n\t\tif (tlv.length < len) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto __kctl_end;\n\t\t}\n\t\tif (copy_to_user(_tlv->tlv, kctl->tlv.p, len))\n\t\t\terr = -EFAULT;\n\t}\n      __kctl_end:\n\tup_read(&card->controls_rwsem);\n\treturn err;\n}\n",
        "output": "0",
        "index": 36501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool MimeUtil::ParseCodecString(const std::string& mime_type_lower_case,\n                                const std::string& codec_id,\n                                Codec* codec,\n                                 bool* ambiguous_codec_string,\n                                 VideoCodecProfile* out_profile,\n                                 uint8_t* out_level,\n                                gfx::ColorSpace::TransferID* out_eotf) const {\n   DCHECK_EQ(base::ToLowerASCII(mime_type_lower_case), mime_type_lower_case);\n   DCHECK(codec);\n   DCHECK(out_profile);\n  DCHECK(out_level);\n\n  *codec = INVALID_CODEC;\n  *ambiguous_codec_string = false;\n   *out_profile = VIDEO_CODEC_PROFILE_UNKNOWN;\n   *out_level = 0;\n \n  *out_eotf = gfx::ColorSpace::TransferID::BT709;\n \n   std::map<std::string, Codec>::const_iterator itr =\n       GetStringToCodecMap().find(codec_id);\n  if (itr != GetStringToCodecMap().end()) {\n    *codec = itr->second;\n\n    return true;\n  }\n\n  if (codec_id == \"avc1\" || codec_id == \"avc3\") {\n    *codec = MimeUtil::H264;\n    *ambiguous_codec_string = true;\n    return true;\n  } else if (codec_id == \"mp4a.40\") {\n    *codec = MimeUtil::MPEG4_AAC;\n    *ambiguous_codec_string = true;\n    return true;\n  }\n\n   if (ParseVp9CodecID(mime_type_lower_case, codec_id, out_profile, out_level,\n                      out_eotf)) {\n     *codec = MimeUtil::VP9;\n     return true;\n   }\n\n  if (ParseAVCCodecId(codec_id, out_profile, out_level)) {\n    *codec = MimeUtil::H264;\n    *ambiguous_codec_string = !IsValidH264Level(*out_level);\n    return true;\n  }\n\n#if BUILDFLAG(ENABLE_HEVC_DEMUXING)\n  if (ParseHEVCCodecId(codec_id, out_profile, out_level)) {\n    *codec = MimeUtil::HEVC;\n    return true;\n  }\n#endif\n\n#if BUILDFLAG(ENABLE_DOLBY_VISION_DEMUXING)\n  if (ParseDolbyVisionCodecId(codec_id, out_profile, out_level)) {\n    *codec = MimeUtil::DOLBY_VISION;\n    return true;\n  }\n#endif\n\n  DVLOG(2) << __func__ << \": Unrecognized codec id \" << codec_id;\n  return false;\n}\n",
        "output": "1",
        "index": 185896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_global_data(data_t * data, data_t *old_global_data)\n{\n\t/* If this is a reload and we are running in a network namespace,\n\t * we may not be able to get local_name, so preserve it */\n\tchar unknown_name[] = \"[unknown]\";\n\n\t/* If we are running in a network namespace, we may not be\n\t * able to get our local name now, so re-use original */\n\tif (old_global_data) {\n\t\tdata->local_name = old_global_data->local_name;\n\t\told_global_data->local_name = NULL;\n\t}\n\n\tif (!data->local_name &&\n\t    (!data->router_id ||\n\t     (data->smtp_server.ss_family &&\n\t      (!data->smtp_helo_name ||\n\t       !data->email_from)))) {\n\t\tdata->local_name = get_local_name();\n\n\t\t/* If for some reason get_local_name() fails, we need to have\n\t\t * some string in local_name, otherwise keepalived can segfault */\n\t\tif (!data->local_name) {\n\t\t\tdata->local_name = MALLOC(sizeof(unknown_name));\n\t\t\tstrcpy(data->local_name, unknown_name);\n\t\t}\n\t}\n\n\tif (!data->router_id)\n\t\tset_default_router_id(data, data->local_name);\n\n\tif (data->smtp_server.ss_family) {\n\t\tif (!data->smtp_connection_to)\n\t\t\tset_default_smtp_connection_timeout(data);\n\n\t\tif (strcmp(data->local_name, unknown_name)) {\n\t\t\tif (!data->email_from)\n\t\t\t\tset_default_email_from(data, data->local_name);\n\n\t\t\tif (!data->smtp_helo_name)\n\t\t\t\tdata->smtp_helo_name = data->local_name;\n\t\t}\n\t}\n\n\t/* Check that there aren't conflicts with the notify FIFOs */\n#ifdef _WITH_VRRP_\n\t/* If the global and vrrp notify FIFOs are the same, then data will be\n\t * duplicated on the FIFO */\n\tif (\n#ifndef _DEBUG_\n\t    prog_type == PROG_TYPE_VRRP &&\n#endif\n\t    data->notify_fifo.name && data->vrrp_notify_fifo.name &&\n\t    !strcmp(data->notify_fifo.name, data->vrrp_notify_fifo.name)) {\n\t\tlog_message(LOG_INFO, \"notify FIFO %s has been specified for global and vrrp FIFO - ignoring vrrp FIFO\", data->vrrp_notify_fifo.name);\n\t\tFREE_PTR(data->vrrp_notify_fifo.name);\n\t\tdata->vrrp_notify_fifo.name = NULL;\n\t\tfree_notify_script(&data->vrrp_notify_fifo.script);\n\t}\n#endif\n#ifdef _WITH_LVS_\n\t/* If the global and LVS notify FIFOs are the same, then data will be\n\t * duplicated on the FIFO */\n#ifndef _DEBUG_\n\tif (prog_type == PROG_TYPE_CHECKER)\n#endif\n\t{\n\t\tif (data->notify_fifo.name && data->lvs_notify_fifo.name &&\n\t\t    !strcmp(data->notify_fifo.name, data->lvs_notify_fifo.name)) {\n\t\t\tlog_message(LOG_INFO, \"notify FIFO %s has been specified for global and LVS FIFO - ignoring LVS FIFO\", data->lvs_notify_fifo.name);\n\t\t\tFREE_PTR(data->lvs_notify_fifo.name);\n\t\t\tdata->lvs_notify_fifo.name = NULL;\n\t\t\tfree_notify_script(&data->lvs_notify_fifo.script);\n\t\t}\n\n#ifdef _WITH_VRRP_\n\t\t/* If LVS and VRRP use the same FIFO, they cannot both have a script for the FIFO.\n\t\t * Use the VRRP script and ignore the LVS script */\n\t\tif (data->lvs_notify_fifo.name && data->vrrp_notify_fifo.name &&\n\t\t    !strcmp(data->lvs_notify_fifo.name, data->vrrp_notify_fifo.name) &&\n\t\t    data->lvs_notify_fifo.script &&\n\t\t    data->vrrp_notify_fifo.script) {\n\t\t\tlog_message(LOG_INFO, \"LVS notify FIFO and vrrp FIFO are the same both with scripts - ignoring LVS FIFO script\");\n\t\t\tfree_notify_script(&data->lvs_notify_fifo.script);\n\t\t}\n#endif\n\t}\n#endif\n}\n",
        "output": "0",
        "index": 75800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutRect PaintLayerScrollableArea::ScrollIntoView(\n    const LayoutRect& absolute_rect,\n    const WebScrollIntoViewParams& params) {\n  LayoutRect local_expose_rect =\n      AbsoluteToLocal(*GetLayoutBox(), absolute_rect);\n  LayoutSize border_origin_to_scroll_origin =\n      LayoutSize(-GetLayoutBox()->BorderLeft(), -GetLayoutBox()->BorderTop()) +\n      LayoutSize(GetScrollOffset());\n  local_expose_rect.Move(border_origin_to_scroll_origin);\n  LayoutRect scroll_snapport_rect = VisibleScrollSnapportRect();\n\n  ScrollOffset target_offset = ScrollAlignment::GetScrollOffsetToExpose(\n      scroll_snapport_rect, local_expose_rect, params.GetScrollAlignmentX(),\n      params.GetScrollAlignmentY(), GetScrollOffset());\n  ScrollOffset new_scroll_offset(\n      ClampScrollOffset(RoundedIntSize(target_offset)));\n\n  ScrollOffset old_scroll_offset = GetScrollOffset();\n  if (params.GetScrollType() == kUserScroll) {\n    if (!UserInputScrollable(kHorizontalScrollbar))\n      new_scroll_offset.SetWidth(old_scroll_offset.Width());\n    if (!UserInputScrollable(kVerticalScrollbar))\n      new_scroll_offset.SetHeight(old_scroll_offset.Height());\n  }\n\n  FloatPoint end_point = ScrollOffsetToPosition(new_scroll_offset);\n  std::unique_ptr<SnapSelectionStrategy> strategy =\n      SnapSelectionStrategy::CreateForEndPosition(gfx::ScrollOffset(end_point),\n                                                  true, true);\n  end_point = GetLayoutBox()\n                  ->GetDocument()\n                  .GetSnapCoordinator()\n                  ->GetSnapPosition(*GetLayoutBox(), *strategy)\n                  .value_or(end_point);\n  new_scroll_offset = ScrollPositionToOffset(end_point);\n\n  if (params.is_for_scroll_sequence) {\n    DCHECK(params.GetScrollType() == kProgrammaticScroll ||\n           params.GetScrollType() == kUserScroll);\n    ScrollBehavior behavior =\n        DetermineScrollBehavior(params.GetScrollBehavior(),\n                                GetLayoutBox()->StyleRef().GetScrollBehavior());\n    GetSmoothScrollSequencer()->QueueAnimation(this, new_scroll_offset,\n                                               behavior);\n  } else {\n    SetScrollOffset(new_scroll_offset, params.GetScrollType(),\n                    kScrollBehaviorInstant);\n  }\n\n  ScrollOffset scroll_offset_difference = new_scroll_offset - old_scroll_offset;\n  local_expose_rect.Move(-LayoutSize(scroll_offset_difference));\n\n  local_expose_rect.Move(-border_origin_to_scroll_origin);\n  scroll_snapport_rect.Move(-border_origin_to_scroll_origin);\n  LayoutRect intersect = Intersection(scroll_snapport_rect, local_expose_rect);\n\n  if (intersect.IsEmpty() && !scroll_snapport_rect.IsEmpty() &&\n      !local_expose_rect.IsEmpty()) {\n    return LocalToAbsolute(*GetLayoutBox(), local_expose_rect);\n  }\n  intersect = LocalToAbsolute(*GetLayoutBox(), intersect);\n  return intersect;\n}\n",
        "output": "0",
        "index": 141481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SECURITY_STATUS ntlm_read_NegotiateMessage(NTLM_CONTEXT* context, PSecBuffer buffer)\n{\n\twStream* s;\n\tsize_t length;\n\tNTLM_NEGOTIATE_MESSAGE* message;\n\tmessage = &context->NEGOTIATE_MESSAGE;\n\tZeroMemory(message, sizeof(NTLM_NEGOTIATE_MESSAGE));\n\ts = Stream_New((BYTE*) buffer->pvBuffer, buffer->cbBuffer);\n\n\tif (!s)\n\t\treturn SEC_E_INTERNAL_ERROR;\n\n\tif (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*) message) < 0)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->MessageType != MESSAGE_TYPE_NEGOTIATE)\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tStream_Read_UINT32(s, message->NegotiateFlags); /* NegotiateFlags (4 bytes) */\n\n\tif (!((message->NegotiateFlags & NTLMSSP_REQUEST_TARGET) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM) &&\n\t      (message->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tcontext->NegotiateFlags = message->NegotiateFlags;\n\n\t/* only set if NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED is set */\n\n\tif (ntlm_read_message_fields(s, &(message->DomainName)) < 0) /* DomainNameFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\t/* only set if NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED is set */\n\n\tif (ntlm_read_message_fields(s, &(message->Workstation)) < 0) /* WorkstationFields (8 bytes) */\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t{\n\t\tif (ntlm_read_version_info(s, &(message->Version)) < 0) /* Version (8 bytes) */\n\t\t{\n\t\t\tStream_Free(s, FALSE);\n\t\t\treturn SEC_E_INVALID_TOKEN;\n\t\t}\n\t}\n\n\tlength = Stream_GetPosition(s);\n\tbuffer->cbBuffer = length;\n\n\tif (!sspi_SecBufferAlloc(&context->NegotiateMessage, length))\n\t{\n\t\tStream_Free(s, FALSE);\n\t\treturn SEC_E_INTERNAL_ERROR;\n\t}\n\n\tCopyMemory(context->NegotiateMessage.pvBuffer, buffer->pvBuffer, buffer->cbBuffer);\n\tcontext->NegotiateMessage.BufferType = buffer->BufferType;\n#ifdef WITH_DEBUG_NTLM\n\tWLog_DBG(TAG, \"NEGOTIATE_MESSAGE (length = %\"PRIu32\")\", context->NegotiateMessage.cbBuffer);\n\twinpr_HexDump(TAG, WLOG_DEBUG, context->NegotiateMessage.pvBuffer,\n\t              context->NegotiateMessage.cbBuffer);\n\tntlm_print_negotiate_flags(message->NegotiateFlags);\n\n\tif (message->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)\n\t\tntlm_print_version_info(&(message->Version));\n\n#endif\n\tcontext->state = NTLM_STATE_CHALLENGE;\n\tStream_Free(s, FALSE);\n\treturn SEC_I_CONTINUE_NEEDED;\n}\n",
        "output": "0",
        "index": 83514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void t1_subset_ascii_part(PDF pdf)\n{\n    int j, *p;\n    char *glyph, **gg, **glyph_names;\n    struct avl_table *gl_tree;\n    struct avl_traverser t;\n    void **aa;\n    t1_getline();\n    while (!t1_prefix(\"/Encoding\")) {\n        t1_scan_param(pdf);\n        t1_putline(pdf);\n        t1_getline();\n    }\n    glyph_names = t1_builtin_enc();\n    fd_cur->builtin_glyph_names = glyph_names;\n    if (is_subsetted(fd_cur->fm)) {\n        if (fd_cur->tx_tree != NULL) {\n            /*tex Take over collected non-reencoded characters from \\TeX. */\n            avl_t_init(&t, fd_cur->tx_tree);\n            for (p = (int *) avl_t_first(&t, fd_cur->tx_tree); p != NULL;\n                 p = (int *) avl_t_next(&t)) {\n                if ((char *) avl_find(fd_cur->gl_tree, glyph_names[*p]) == NULL) {\n                    glyph = xstrdup(glyph_names[*p]);\n                    aa = avl_probe(fd_cur->gl_tree, glyph);\n                    assert(aa != NULL);\n                }\n            }\n        }\n        make_subset_tag(fd_cur);\n        strncpy((char *) pdf->fb->data + t1_fontname_offset, fd_cur->subset_tag,6);\n    }\n    /*tex Now really all glyphs needed from this font are in the |fd_cur->gl_tree|. */\n    if (t1_encoding == ENC_STANDARD)\n        t1_puts(pdf, \"/Encoding StandardEncoding def\\n\");\n    else {\n        t1_puts(pdf,\"/Encoding 256 array\\n0 1 255 {1 index exch /.notdef put} for\\n\");\n        gl_tree = create_t1_glyph_tree(glyph_names);\n        avl_t_init(&t, fd_cur->gl_tree);\n        j = 0;\n        for (glyph = (char *) avl_t_first(&t, fd_cur->gl_tree); glyph != NULL;\n             glyph = (char *) avl_t_next(&t)) {\n            if ((gg = (char **) avl_find(gl_tree, &glyph)) != NULL) {\n                t1_printf(pdf, \"dup %i /%s put\\n\", (int) (gg - glyph_names),*gg);\n                j++;\n            }\n        }\n        destroy_t1_glyph_tree(gl_tree);\n        if (j == 0) {\n            /*tex\n                We didn't mark anything for the Encoding array. We add |{dup 0\n                /.notdef put}| for compatibility with Acrobat 5.0.\n            */\n            t1_puts(pdf, \"dup 0 /.notdef put\\n\");\n        }\n        t1_puts(pdf, \"readonly def\\n\");\n    }\n    do {\n        t1_getline();\n        t1_scan_param(pdf);\n        if (!t1_prefix(\"/UniqueID\")) {\n            /*tex Ignore |/UniqueID| for subsetted fonts. */\n            t1_putline(pdf);\n        }\n    }\n    while (t1_in_eexec == 0);\n}\n",
        "output": "0",
        "index": 76709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "translatePass(const TranslationTableHeader *table, int currentPass, const InString *input,\n\t\tOutString *output, int *posMapping, int *realInlen, int *posIncremented,\n\t\tint *cursorPosition, int *cursorStatus) {\n\tint pos;\n\tint transOpcode;\n\tconst TranslationTableRule *transRule;\n\tint transCharslen;\n\tint passCharDots;\n\tconst widechar *passInstructions;\n\tint passIC; /* Instruction counter */\n\tPassRuleMatch patternMatch;\n\tTranslationTableRule *groupingRule;\n\twidechar groupingOp;\n\tconst InString *origInput = input;\n\tpos = output->length = 0;\n\t*posIncremented = 1;\n\t_lou_resetPassVariables();\n\twhile (pos < input->length) { /* the main multipass translation loop */\n\t\tpassSelectRule(table, pos, currentPass, input, &transOpcode, &transRule,\n\t\t\t\t&transCharslen, &passCharDots, &passInstructions, &passIC, &patternMatch,\n\t\t\t\t&groupingRule, &groupingOp);\n\t\t*posIncremented = 1;\n\t\tswitch (transOpcode) {\n\t\tcase CTO_Context:\n\t\tcase CTO_Pass2:\n\t\tcase CTO_Pass3:\n\t\tcase CTO_Pass4: {\n\t\t\tconst InString *inputBefore = input;\n\t\t\tint posBefore = pos;\n\t\t\tif (appliedRules != NULL && appliedRulesCount < maxAppliedRules)\n\t\t\t\tappliedRules[appliedRulesCount++] = transRule;\n\t\t\tif (!passDoAction(table, &input, output, posMapping, transOpcode, &transRule,\n\t\t\t\t\t\tpassCharDots, passInstructions, passIC, &pos, patternMatch,\n\t\t\t\t\t\tcursorPosition, cursorStatus, groupingRule, groupingOp))\n\t\t\t\tgoto failure;\n\t\t\tif (input->bufferIndex != inputBefore->bufferIndex &&\n\t\t\t\t\tinputBefore->bufferIndex != origInput->bufferIndex)\n\t\t\t\treleaseStringBuffer(inputBefore->bufferIndex);\n\t\t\tif (pos == posBefore) *posIncremented = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase CTO_Always:\n\t\t\tif ((output->length + 1) > output->maxlength) goto failure;\n\t\t\tposMapping[output->length] = pos;\n\t\t\toutput->chars[output->length++] = input->chars[pos++];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto failure;\n\t\t}\n\t}\nfailure:\n\tif (pos < input->length) {\n\t\twhile (checkAttr(input->chars[pos], CTC_Space, 1, table))\n\t\t\tif (++pos == input->length) break;\n\t}\n\t*realInlen = pos;\n\tif (input->bufferIndex != origInput->bufferIndex)\n\t\treleaseStringBuffer(input->bufferIndex);\n\treturn 1;\n}\n",
        "output": "0",
        "index": 76782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fm_mgr_get_resp_error_str\n(\n\tIN\t\tfm_msg_ret_code_t err\n)\n{\n\tswitch(err){\n\t\tcase FM_RET_BAD_RET_LEN:\n\t\t\treturn \"Return data length invalid\";\n\t\tcase FM_RET_OK:\n\t\t\treturn \"Ok\";\n\t\tcase FM_RET_DT_NOT_SUPPORTED:\n\t\t\treturn \"Data type not supported\";\n\t\tcase FM_RET_ACT_NOT_SUPPORTED:\n\t\t\treturn \"Action not supported\";\n\t\tcase FM_RET_INVALID:\n\t\t\treturn \"Invalid\";\n\t\tcase FM_RET_BAD_LEN:\n\t\t\treturn \"Send data length invalid\";\n\t\tcase FM_RET_BUSY:\n\t\t\treturn \"Busy\";\n\t\tcase FM_RET_NOT_FOUND:\n\t\t\treturn \"Record not found\";\n\t\tcase FM_RET_NO_NEXT:\n\t\t\treturn \"No next instance\";\n\t\tcase FM_RET_NOT_MASTER:\n\t\t\treturn \"SM is not master\";\n\t\tcase FM_RET_NOSUCHOBJECT:\n\t\t\treturn \"SNMP Err: No such object\";\n\t\tcase FM_RET_NOSUCHINSTANCE:\n\t\t\treturn \"SNMP Err: No such instance\";\n\t\tcase FM_RET_ENDOFMIBVIEW:\n\t\t\treturn \"SNMP Err: End of view\";\n\t\tcase FM_RET_ERR_NOERROR:\n\t\t\treturn \"SNMP Err: No error\";\n\t\tcase FM_RET_ERR_TOOBIG:\n\t\t\treturn \"SNMP Err: Object too big\";\n\t\tcase FM_RET_ERR_NOSUCHNAME:\n\t\t\treturn \"SNMP Err: no such name\";\n\t\tcase FM_RET_ERR_BADVALUE:\n\t\t\treturn \"SNMP Err: Bad value\";\n\t\tcase FM_RET_ERR_READONLY:\n\t\t\treturn \"SNMP Err: Read only\";\n\t\tcase FM_RET_ERR_GENERR:\n\t\t\treturn \"SNMP Err: General Error\";\n\t\tcase FM_RET_ERR_NOACCESS:\n\t\t\treturn \"SNMP Err: No Access\";\n\t\tcase FM_RET_ERR_WRONGTYPE:\n\t\t\treturn \"SNMP Err: Wrong Type\";\n\t\tcase FM_RET_ERR_WRONGLENGTH:\n\t\t\treturn \"SNMP Err: Wrong length\";\n\t\tcase FM_RET_ERR_WRONGENCODING:\n\t\t\treturn \"SNMP Err: Wrong encoding\";\n\t\tcase FM_RET_ERR_WRONGVALUE:\n\t\t\treturn \"SNMP Err: Wrong Value\";\n\t\tcase FM_RET_ERR_NOCREATION:\n\t\t\treturn \"SNMP Err: No Creation\";\n\t\tcase FM_RET_ERR_INCONSISTENTVALUE:\n\t\t\treturn \"SNMP Err: Inconsistent value\";\n\t\tcase FM_RET_ERR_RESOURCEUNAVAILABLE:\n\t\t\treturn \"SNMP Err: Resource Unavailable\";\n\t\tcase FM_RET_ERR_COMMITFAILED:\n\t\t\treturn \"SNMP Err: Commit failed\";\n\t\tcase FM_RET_ERR_UNDOFAILED:\n\t\t\treturn \"SNMP Err: Undo failed\";\n\t\tcase FM_RET_ERR_AUTHORIZATIONERROR:\n\t\t\treturn \"SNMP Err: Authorization error\";\n\t\tcase FM_RET_ERR_NOTWRITABLE:\n\t\t\treturn \"SNMP Err: Not Writable\";\n\t\tcase FM_RET_TIMEOUT:\n\t\t\treturn \"SNMP Err: Timeout\";\n\t\tcase FM_RET_UNKNOWN_DT:\n\t\t\treturn \"Unknown Datatype\";\n\t\tcase FM_RET_END_OF_TABLE:\n\t\t\treturn \"End of Table\";\n\t\tcase FM_RET_INTERNAL_ERR:\n\t\t\treturn \"Internal Error\";\n\t\tcase FM_RET_CONX_CLOSED:\n\t\t\treturn \"Connection Closed\";\n\n\t}\n\n\treturn \"Unknown code\";\n}\n",
        "output": "0",
        "index": 96245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_run_iocb(struct kiocb *req, unsigned opcode,\n\t\t\t    char __user *buf, bool compat)\n{\n\tstruct file *file = req->ki_filp;\n\tssize_t ret;\n\tunsigned long nr_segs;\n\tint rw;\n\tfmode_t mode;\n\taio_rw_op *rw_op;\n\trw_iter_op *iter_op;\n\tstruct iovec inline_vec, *iovec = &inline_vec;\n\tstruct iov_iter iter;\n\n\tswitch (opcode) {\n\tcase IOCB_CMD_PREAD:\n\tcase IOCB_CMD_PREADV:\n\t\tmode\t= FMODE_READ;\n\t\trw\t= READ;\n\t\trw_op\t= file->f_op->aio_read;\n\t\titer_op\t= file->f_op->read_iter;\n\t\tgoto rw_common;\n\n\tcase IOCB_CMD_PWRITE:\n\tcase IOCB_CMD_PWRITEV:\n\t\tmode\t= FMODE_WRITE;\n\t\trw\t= WRITE;\n\t\trw_op\t= file->f_op->aio_write;\n\t\titer_op\t= file->f_op->write_iter;\n\t\tgoto rw_common;\nrw_common:\n\t\tif (unlikely(!(file->f_mode & mode)))\n\t\t\treturn -EBADF;\n\n\t\tif (!rw_op && !iter_op)\n\t\t\treturn -EINVAL;\n\n\t\tret = (opcode == IOCB_CMD_PREADV ||\n\t\t       opcode == IOCB_CMD_PWRITEV)\n\t\t\t? aio_setup_vectored_rw(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t&iovec, compat)\n\t\t\t: aio_setup_single_vector(req, rw, buf, &nr_segs,\n\t\t\t\t\t\t  iovec);\n\t\tif (!ret)\n\t\t\tret = rw_verify_area(rw, file, &req->ki_pos, req->ki_nbytes);\n\t\tif (ret < 0) {\n\t\t\tif (iovec != &inline_vec)\n\t\t\t\tkfree(iovec);\n\t\t\treturn ret;\n\t\t}\n\n\t\treq->ki_nbytes = ret;\n\n\t\t/* XXX: move/kill - rw_verify_area()? */\n\t\t/* This matches the pread()/pwrite() logic */\n\t\tif (req->ki_pos < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_start_write(file);\n\n\t\tif (iter_op) {\n\t\t\tiov_iter_init(&iter, rw, iovec, nr_segs, req->ki_nbytes);\n\t\t\tret = iter_op(req, &iter);\n\t\t} else {\n\t\t\tret = rw_op(req, iovec, nr_segs, req->ki_pos);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tfile_end_write(file);\n\t\tbreak;\n\n\tcase IOCB_CMD_FDSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 1);\n\t\tbreak;\n\n\tcase IOCB_CMD_FSYNC:\n\t\tif (!file->f_op->aio_fsync)\n\t\t\treturn -EINVAL;\n\n\t\tret = file->f_op->aio_fsync(req, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"EINVAL: no operation provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iovec != &inline_vec)\n\t\tkfree(iovec);\n\n\tif (ret != -EIOCBQUEUED) {\n\t\t/*\n\t\t * There's no easy way to restart the syscall since other AIO's\n\t\t * may be already running. Just fail this IO with EINTR.\n\t\t */\n\t\tif (unlikely(ret == -ERESTARTSYS || ret == -ERESTARTNOINTR ||\n\t\t\t     ret == -ERESTARTNOHAND ||\n\t\t\t     ret == -ERESTART_RESTARTBLOCK))\n\t\t\tret = -EINTR;\n\t\taio_complete(req, ret, 0);\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 39597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encrypt_nss(\n\tstruct crypto_instance *instance,\n\tconst unsigned char *buf_in,\n\tconst size_t buf_in_len,\n\tunsigned char *buf_out,\n\tsize_t *buf_out_len)\n{\n\tPK11Context*\tcrypt_context = NULL;\n\tSECItem\t\tcrypt_param;\n\tSECItem\t\t*nss_sec_param = NULL;\n\tint\t\ttmp1_outlen = 0;\n\tunsigned int\ttmp2_outlen = 0;\n\tunsigned char\t*salt = buf_out;\n\tunsigned char\t*data = buf_out + SALT_SIZE;\n\tint\t\terr = -1;\n\n\tif (!cipher_to_nss[instance->crypto_cipher_type]) {\n\t\tmemcpy(buf_out, buf_in, buf_in_len);\n\t\t*buf_out_len = buf_in_len;\n\t\treturn 0;\n\t}\n\n\tif (PK11_GenerateRandom (salt, SALT_SIZE) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t\"Failure to generate a random number %d\",\n\t\t\tPR_GetError());\n\t\tgoto out;\n\t}\n\n\tcrypt_param.type = siBuffer;\n\tcrypt_param.data = salt;\n\tcrypt_param.len = SALT_SIZE;\n\n\tnss_sec_param = PK11_ParamFromIV (cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t  &crypt_param);\n\tif (nss_sec_param == NULL) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"Failure to set up PKCS11 param (err %d)\",\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Create cipher context for encryption\n\t */\n\tcrypt_context = PK11_CreateContextBySymKey (cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t\t\t\t    CKA_ENCRYPT,\n\t\t\t\t\t\t    instance->nss_sym_key,\n\t\t\t\t\t\t    nss_sec_param);\n\tif (!crypt_context) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CreateContext failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_CipherOp(crypt_context, data,\n\t\t\t  &tmp1_outlen,\n\t\t\t  FRAME_SIZE_MAX - instance->crypto_header_size,\n\t\t\t  (unsigned char *)buf_in, buf_in_len) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_CipherOp failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\t}\n\n\tif (PK11_DigestFinal(crypt_context, data + tmp1_outlen,\n\t\t\t     &tmp2_outlen, FRAME_SIZE_MAX - tmp1_outlen) != SECSuccess) {\n\t\tlog_printf(instance->log_level_security,\n\t\t\t   \"PK11_DigestFinal failed (encrypt) crypt_type=%d (err %d)\",\n\t\t\t   (int)cipher_to_nss[instance->crypto_cipher_type],\n\t\t\t   PR_GetError());\n\t\tgoto out;\n\n\t}\n\n\t*buf_out_len = tmp1_outlen + tmp2_outlen + SALT_SIZE;\n\n\terr = 0;\n\nout:\n\tif (crypt_context) {\n\t\tPK11_DestroyContext(crypt_context, PR_TRUE);\n\t}\n\tif (nss_sec_param) {\n\t\tSECITEM_FreeItem(nss_sec_param, PR_TRUE);\n\t}\n\treturn err;\n}\n",
        "output": "0",
        "index": 41062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n{\n     int i;\n     VncDisplay *vd = ds->opaque;\n     struct VncSurface *s = &vd->guest;\n \n     h += y;\n \n       two 16-pixel blocks but we only mark the first as dirty\n    */\n    w += (x % 16);\n    x -= (x % 16);\n     w += (x % 16);\n     x -= (x % 16);\n \n    x = MIN(x, s->ds->width);\n    y = MIN(y, s->ds->height);\n    w = MIN(x + w, s->ds->width) - x;\n    h = MIN(h, s->ds->height);\n \n     for (; y < h; y++)\n         for (i = 0; i < w; i += 16)\n\nvoid vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                            int32_t encoding)\n{\n    vnc_write_u16(vs, x);\n    vnc_write_u16(vs, y);\n    vnc_write_u16(vs, w);\n    vnc_write_u16(vs, h);\n\n    vnc_write_s32(vs, encoding);\n}\n\nvoid buffer_reserve(Buffer *buffer, size_t len)\n{\n    if ((buffer->capacity - buffer->offset) < len) {\n        buffer->capacity += (len + 1024);\n        buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);\n        if (buffer->buffer == NULL) {\n            fprintf(stderr, \"vnc: out of memory\\n\");\n            exit(1);\n        }\n    }\n}\n\nint buffer_empty(Buffer *buffer)\n{\n    return buffer->offset == 0;\n}\n\nuint8_t *buffer_end(Buffer *buffer)\n{\n    return buffer->buffer + buffer->offset;\n}\n\nvoid buffer_reset(Buffer *buffer)\n{\n        buffer->offset = 0;\n}\n\nvoid buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}\n\nvoid buffer_append(Buffer *buffer, const void *data, size_t len)\n{\n    memcpy(buffer->buffer + buffer->offset, data, len);\n    buffer->offset += len;\n}\n\nstatic void vnc_desktop_resize(VncState *vs)\n{\n    DisplayState *ds = vs->ds;\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n        return;\n    }\n    if (vs->client_width == ds_get_width(ds) &&\n        vs->client_height == ds_get_height(ds)) {\n        return;\n    }\n    vs->client_width = ds_get_width(ds);\n    vs->client_height = ds_get_height(ds);\n    vnc_lock_output(vs);\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n    vnc_write_u8(vs, 0);\n    vnc_write_u16(vs, 1); /* number of rects */\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n                           VNC_ENCODING_DESKTOPRESIZE);\n    vnc_unlock_output(vs);\n    vnc_flush(vs);\n}\n\nstatic void vnc_abort_display_jobs(VncDisplay *vd)\n{\n    VncState *vs;\n\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = true;\n        vnc_unlock_output(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_jobs_join(vs);\n    }\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        vnc_lock_output(vs);\n        vs->abort = false;\n        vnc_unlock_output(vs);\n    }\n}\n     }\n",
        "output": "1",
        "index": 178642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n\n\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n\n    toktype2 = load_16_be(ptr);\n\n    ptr += 2;\n    bodysize -= 2;\n\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n\n    return ret;\n}\n",
        "output": "0",
        "index": 36790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ipv6_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tint val;\n\tbool connected = false;\n\t__be16 orig_port = 0;\n\tstruct socket *socket = server->ssocket;\n\n\tif (socket == NULL) {\n\t\trc = sock_create_kern(PF_INET6, SOCK_STREAM,\n\t\t\t\t      IPPROTO_TCP, &socket);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating ipv6 socket\", rc);\n\t\t\tsocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"ipv6 Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tcifs_reclassify_socket6(socket);\n\t}\n\n\t/* user overrode default port */\n\tif (server->addr.sockAddr6.sin6_port) {\n\t\trc = socket->ops->connect(socket,\n\t\t\t\t(struct sockaddr *) &server->addr.sockAddr6,\n\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\tif (!connected) {\n\t\t/* save original port so we can retry user specified port\n\t\t\tlater if fall back ports fail this time  */\n\n\t\torig_port = server->addr.sockAddr6.sin6_port;\n\t\t/* do not retry on the same port we just failed on */\n\t\tif (server->addr.sockAddr6.sin6_port != htons(CIFS_PORT)) {\n\t\t\tserver->addr.sockAddr6.sin6_port = htons(CIFS_PORT);\n\t\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t&server->addr.sockAddr6,\n\t\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\t\tif (rc >= 0)\n\t\t\t\tconnected = true;\n\t\t}\n\t}\n\tif (!connected) {\n\t\tserver->addr.sockAddr6.sin6_port = htons(RFC1001_PORT);\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t&server->addr.sockAddr6,\n\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\t/* give up here - unless we want to retry on different\n\t\tprotocol families some day */\n\tif (!connected) {\n\t\tif (orig_port)\n\t\t\tserver->addr.sockAddr6.sin6_port = orig_port;\n\t\tcFYI(1, \"Error %d connecting to server via ipv6\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\tif (server->tcp_nodelay) {\n\t\tval = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\tserver->ssocket = socket;\n\n\treturn rc;\n}\n",
        "output": "0",
        "index": 35154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8InjectedScriptHost::subtypeCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    if (info.Length() < 1)\n        return;\n\n    v8::Isolate* isolate = info.GetIsolate();\n    v8::Local<v8::Value> value = info[0];\n    if (value->IsObject()) {\n        v8::Local<v8::Value> internalType = v8InternalValueTypeFrom(isolate->GetCurrentContext(), v8::Local<v8::Object>::Cast(value));\n        if (internalType->IsString()) {\n            info.GetReturnValue().Set(internalType);\n            return;\n        }\n    }\n    if (value->IsArray() || value->IsArgumentsObject()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"array\"));\n        return;\n    }\n    if (value->IsTypedArray()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"typedarray\"));\n        return;\n    }\n    if (value->IsDate()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"date\"));\n        return;\n    }\n    if (value->IsRegExp()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"regexp\"));\n        return;\n    }\n    if (value->IsMap() || value->IsWeakMap()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"map\"));\n        return;\n    }\n    if (value->IsSet() || value->IsWeakSet()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"set\"));\n        return;\n    }\n    if (value->IsMapIterator() || value->IsSetIterator()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"iterator\"));\n        return;\n    }\n    if (value->IsGeneratorObject()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"generator\"));\n        return;\n    }\n    if (value->IsNativeError()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"error\"));\n        return;\n    }\n    if (value->IsProxy()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"proxy\"));\n        return;\n    }\n    if (value->IsPromise()) {\n        info.GetReturnValue().Set(toV8StringInternalized(isolate, \"promise\"));\n        return;\n    }\n    String16 subtype = unwrapInspector(info)->client()->valueSubtype(value);\n    if (!subtype.isEmpty()) {\n        info.GetReturnValue().Set(toV8String(isolate, subtype));\n        return;\n    }\n}\n",
        "output": "0",
        "index": 141768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::MaybeRestoreContext(TimerBase*) {\n  DCHECK(isContextLost());\n\n  if (!restore_allowed_)\n    return;\n\n  if (canvas()) {\n    LocalFrame* frame = canvas()->GetDocument().GetFrame();\n    if (!frame)\n      return;\n    if (frame->Client()->ShouldBlockWebGL())\n      return;\n\n    Settings* settings = frame->GetSettings();\n    if (settings && ((context_type_ == Platform::kWebGL1ContextType &&\n                      !settings->GetWebGL1Enabled()) ||\n                     ((context_type_ == Platform::kWebGL2ContextType ||\n                       context_type_ == Platform::kWebGL2ComputeContextType) &&\n                      !settings->GetWebGL2Enabled()))) {\n      return;\n    }\n  }\n\n  DCHECK(!GetDrawingBuffer());\n\n  auto* execution_context = Host()->GetTopExecutionContext();\n  Platform::ContextAttributes attributes = ToPlatformContextAttributes(\n      CreationAttributes(), context_type_,\n      SupportOwnOffscreenSurface(execution_context));\n  Platform::GraphicsInfo gl_info;\n  std::unique_ptr<WebGraphicsContext3DProvider> context_provider;\n  bool using_gpu_compositing;\n  const auto& url = Host()->GetExecutionContextUrl();\n\n  if (IsMainThread()) {\n    using_gpu_compositing = !Platform::Current()->IsGpuCompositingDisabled();\n    context_provider =\n        Platform::Current()->CreateOffscreenGraphicsContext3DProvider(\n            attributes, url, &gl_info);\n  } else {\n    context_provider = CreateContextProviderOnWorkerThread(\n        attributes, &gl_info, &using_gpu_compositing, url);\n  }\n  scoped_refptr<DrawingBuffer> buffer;\n  if (context_provider && context_provider->BindToCurrentThread()) {\n    buffer =\n        CreateDrawingBuffer(std::move(context_provider), using_gpu_compositing);\n  }\n  if (!buffer) {\n    if (context_lost_mode_ == kRealLostContext) {\n      restore_timer_.StartOneShot(kDurationBetweenRestoreAttempts, FROM_HERE);\n    } else {\n      SynthesizeGLError(GL_INVALID_OPERATION, \"\", \"error restoring context\");\n    }\n    return;\n  }\n\n  drawing_buffer_ = std::move(buffer);\n  GetDrawingBuffer()->Bind(GL_FRAMEBUFFER);\n  lost_context_errors_.clear();\n  context_lost_mode_ = kNotLostContext;\n  auto_recovery_method_ = kManual;\n  restore_allowed_ = false;\n  RemoveFromEvictedList(this);\n\n  SetupFlags();\n  InitializeNewContext();\n  MarkContextChanged(kCanvasContextChanged);\n  WebGLContextEvent* event =\n      WebGLContextEvent::Create(event_type_names::kWebglcontextrestored, \"\");\n  Host()->HostDispatchEvent(event);\n}\n",
        "output": "0",
        "index": 154967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_sunday_quick_search_or_bmh_skip_table(regex_t* reg, int case_expand,\n                                          UChar* s, UChar* end,\n                                          UChar skip[], int* roffset)\n{\n  int i, j, k, len, offset;\n  int n, clen;\n  UChar* p;\n  OnigEncoding enc;\n  OnigCaseFoldCodeItem items[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];\n  UChar buf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  enc = reg->enc;\n  offset = ENC_GET_SKIP_OFFSET(enc);\n  if (offset == ENC_SKIP_OFFSET_1_OR_0) {\n    UChar* p = s;\n    while (1) {\n      len = enclen(enc, p);\n      if (p + len >= end) {\n        if (len == 1) offset = 1;\n        else          offset = 0;\n        break;\n      }\n      p += len;\n    }\n  }\n\n  len = (int )(end - s);\n  if (len + offset >= UCHAR_MAX)\n    return ONIGERR_PARSER_BUG;\n\n  *roffset = offset;\n\n  for (i = 0; i < CHAR_MAP_SIZE; i++) {\n    skip[i] = (UChar )(len + offset);\n  }\n\n  for (p = s; p < end; ) {\n    int z;\n\n    clen = enclen(enc, p);\n    if (p + clen > end) clen = (int )(end - p);\n\n    len = (int )(end - p);\n    for (j = 0; j < clen; j++) {\n      z = len - j + (offset - 1);\n      if (z <= 0) break;\n      skip[p[j]] = z;\n    }\n\n    if (case_expand != 0) {\n      n = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(enc, reg->case_fold_flag,\n                                             p, end, items);\n      for (k = 0; k < n; k++) {\n        ONIGENC_CODE_TO_MBC(enc, items[k].code[0], buf);\n        for (j = 0; j < clen; j++) {\n          z = len - j + (offset - 1);\n          if (z <= 0) break;\n          if (skip[buf[j]] > z)\n            skip[buf[j]] = z;\n        }\n      }\n    }\n\n    p += clen;\n  }\n\n  return 0;\n}\n",
        "output": "0",
        "index": 89228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "copy_files (CopyMoveJob  *job,\n            const char   *dest_fs_id,\n            SourceInfo   *source_info,\n            TransferInfo *transfer_info)\n{\n    CommonJob *common;\n    GList *l;\n    GFile *src;\n    gboolean same_fs;\n    int i;\n    GdkPoint *point;\n    gboolean skipped_file;\n    gboolean unique_names;\n    GFile *dest;\n    GFile *source_dir;\n    char *dest_fs_type;\n    GFileInfo *inf;\n    gboolean readonly_source_fs;\n\n    dest_fs_type = NULL;\n    readonly_source_fs = FALSE;\n\n    common = &job->common;\n\n    report_copy_progress (job, source_info, transfer_info);\n\n    /* Query the source dir, not the file because if it's a symlink we'll follow it */\n    source_dir = g_file_get_parent ((GFile *) job->files->data);\n    if (source_dir)\n    {\n        inf = g_file_query_filesystem_info (source_dir, \"filesystem::readonly\", NULL, NULL);\n        if (inf != NULL)\n        {\n            readonly_source_fs = g_file_info_get_attribute_boolean (inf, \"filesystem::readonly\");\n            g_object_unref (inf);\n        }\n        g_object_unref (source_dir);\n    }\n\n    unique_names = (job->destination == NULL);\n    i = 0;\n    for (l = job->files;\n         l != NULL && !job_aborted (common);\n         l = l->next)\n    {\n        src = l->data;\n\n        if (i < job->n_icon_positions)\n        {\n            point = &job->icon_positions[i];\n        }\n        else\n        {\n            point = NULL;\n        }\n\n\n        same_fs = FALSE;\n        if (dest_fs_id)\n        {\n            same_fs = has_fs_id (src, dest_fs_id);\n        }\n\n        if (job->destination)\n        {\n            dest = g_object_ref (job->destination);\n        }\n        else\n        {\n            dest = g_file_get_parent (src);\n        }\n        if (dest)\n        {\n            skipped_file = FALSE;\n            copy_move_file (job, src, dest,\n                            same_fs, unique_names,\n                            &dest_fs_type,\n                            source_info, transfer_info,\n                            job->debuting_files,\n                            point, FALSE, &skipped_file,\n                            readonly_source_fs);\n            g_object_unref (dest);\n\n            if (skipped_file)\n            {\n                transfer_add_file_to_count (src, common, transfer_info);\n                report_copy_progress (job, source_info, transfer_info);\n            }\n        }\n        i++;\n    }\n\n    g_free (dest_fs_type);\n}\n",
        "output": "0",
        "index": 61023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int trashacl(struct protstream *pin, struct protstream *pout,\n                    char *mailbox)\n{\n    int i=0, j=0;\n    char tagbuf[128];\n    int c;              /* getword() returns an int */\n    struct buf cmd, tmp, user;\n    int r = 0;\n\n    memset(&cmd, 0, sizeof(struct buf));\n    memset(&tmp, 0, sizeof(struct buf));\n    memset(&user, 0, sizeof(struct buf));\n\n    prot_printf(pout, \"ACL0 GETACL {\" SIZE_T_FMT \"+}\\r\\n%s\\r\\n\",\n                strlen(mailbox), mailbox);\n\n    while(1) {\n        c = prot_getc(pin);\n        if (c != '*') {\n            prot_ungetc(c, pin);\n            r = getresult(pin, \"ACL0\");\n            break;\n        }\n\n        c = prot_getc(pin);  /* skip SP */\n        c = getword(pin, &cmd);\n        if (c == EOF) {\n            r = IMAP_SERVER_UNAVAILABLE;\n            break;\n        }\n\n        if (!strncmp(cmd.s, \"ACL\", 3)) {\n            while(c != '\\n') {\n                /* An ACL response, we should send a DELETEACL command */\n                c = getastring(pin, pout, &tmp);\n                if (c == EOF) {\n                    r = IMAP_SERVER_UNAVAILABLE;\n                    goto cleanup;\n                }\n\n                if(c == '\\r') {\n                    c = prot_getc(pin);\n                    if(c != '\\n') {\n                        r = IMAP_SERVER_UNAVAILABLE;\n                        goto cleanup;\n                    }\n                }\n                if(c == '\\n') break;  /* end of * ACL */\n\n                c = getastring(pin, pout, &user);\n                if (c == EOF) {\n                    r = IMAP_SERVER_UNAVAILABLE;\n                    goto cleanup;\n                }\n\n                snprintf(tagbuf, sizeof(tagbuf), \"ACL%d\", ++i);\n\n                prot_printf(pout, \"%s DELETEACL {\" SIZE_T_FMT \"+}\\r\\n%s\"\n                            \" {\" SIZE_T_FMT \"+}\\r\\n%s\\r\\n\",\n                            tagbuf, strlen(mailbox), mailbox,\n                            strlen(user.s), user.s);\n                if(c == '\\r') {\n                    c = prot_getc(pin);\n                    if(c != '\\n') {\n                        r = IMAP_SERVER_UNAVAILABLE;\n                        goto cleanup;\n                    }\n                }\n                /* if the next character is \\n, we'll exit the loop */\n            }\n        }\n        else {\n            /* skip this line, we don't really care */\n            eatline(pin, c);\n        }\n    }\n\n    cleanup:\n\n    /* Now cleanup after all the DELETEACL commands */\n    if(!r) {\n        while(j < i) {\n            snprintf(tagbuf, sizeof(tagbuf), \"ACL%d\", ++j);\n            r = getresult(pin, tagbuf);\n            if (r) break;\n        }\n    }\n\n    if(r) eatline(pin, c);\n\n    buf_free(&user);\n    buf_free(&tmp);\n    buf_free(&cmd);\n\n    return r;\n}\n",
        "output": "0",
        "index": 95266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::OpenURL(std::unique_ptr<blink::WebNavigationInfo> info,\n                              bool is_history_navigation_in_new_child) {\n  DCHECK(!info->url_request.RequestorOrigin().IsNull());\n\n  WebNavigationPolicy policy = info->navigation_policy;\n  FrameHostMsg_OpenURL_Params params;\n  params.url = info->url_request.Url();\n  params.initiator_origin = info->url_request.RequestorOrigin();\n  params.uses_post = IsHttpPost(info->url_request);\n  params.resource_request_body =\n      GetRequestBodyForWebURLRequest(info->url_request);\n  params.extra_headers = GetWebURLRequestHeadersAsString(info->url_request);\n  params.referrer =\n      RenderViewImpl::GetReferrerFromRequest(frame_, info->url_request);\n  params.disposition = RenderViewImpl::NavigationPolicyToDisposition(policy);\n  params.triggering_event_info = info->triggering_event_info;\n  params.blob_url_token =\n      CloneBlobURLToken(info->blob_url_token.get()).PassHandle().release();\n  params.should_replace_current_entry =\n      info->frame_load_type == WebFrameLoadType::kReplaceCurrentItem &&\n      render_view_->history_list_length_;\n  params.user_gesture = info->has_transient_user_activation;\n  if (GetContentClient()->renderer()->AllowPopup())\n    params.user_gesture = true;\n\n  if (is_main_frame_ || policy == blink::kWebNavigationPolicyNewBackgroundTab ||\n      policy == blink::kWebNavigationPolicyNewForegroundTab ||\n      policy == blink::kWebNavigationPolicyNewWindow ||\n      policy == blink::kWebNavigationPolicyNewPopup) {\n    WebUserGestureIndicator::ConsumeUserGesture(frame_);\n  }\n\n  if (is_history_navigation_in_new_child)\n    params.is_history_navigation_in_new_child = true;\n\n  params.href_translate = info->href_translate.Latin1();\n\n  bool current_frame_has_download_sandbox_flag =\n      !frame_->IsAllowedToDownloadWithoutUserActivation();\n  bool has_download_sandbox_flag =\n      info->initiator_frame_has_download_sandbox_flag ||\n      current_frame_has_download_sandbox_flag;\n  bool from_ad = info->initiator_frame_is_ad || frame_->IsAdSubframe();\n\n  MaybeSetDownloadFramePolicy(\n      info->is_opener_navigation, info->url_request,\n      frame_->GetSecurityOrigin(), has_download_sandbox_flag,\n      info->blocking_downloads_in_sandbox_without_user_activation_enabled,\n      from_ad, &params.download_policy);\n\n  Send(new FrameHostMsg_OpenURL(routing_id_, params));\n}\n",
        "output": "0",
        "index": 152465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType ClampImage(Image *image,ExceptionInfo *exception)\n{\n#define ClampImageTag  \"Clamp/Image\"\n\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      register PixelInfo\n        *magick_restrict q;\n\n      q=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        q->red=(double) ClampPixel(q->red);\n        q->green=(double) ClampPixel(q->green);\n        q->blue=(double) ClampPixel(q->blue);\n        q->alpha=(double) ClampPixel(q->alpha);\n        q++;\n      }\n      return(SyncImage(image,exception));\n    }\n  /*\n    Clamp image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[i]=ClampPixel((MagickRealType) q[i]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,ClampImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n",
        "output": "0",
        "index": 89047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)\n{\n\tstruct file *eventfp, *filep = NULL;\n\tstruct eventfd_ctx *ctx = NULL;\n\tu64 p;\n\tlong r;\n\tint i, fd;\n\n\t/* If you are not the owner, you can become one */\n\tif (ioctl == VHOST_SET_OWNER) {\n\t\tr = vhost_dev_set_owner(d);\n\t\tgoto done;\n\t}\n\n\t/* You must be the owner to do anything else */\n\tr = vhost_dev_check_owner(d);\n\tif (r)\n\t\tgoto done;\n\n\tswitch (ioctl) {\n\tcase VHOST_SET_MEM_TABLE:\n\t\tr = vhost_set_memory(d, argp);\n\t\tbreak;\n\tcase VHOST_SET_LOG_BASE:\n\t\tif (copy_from_user(&p, argp, sizeof p)) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif ((u64)(unsigned long)p != p) {\n\t\t\tr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfor (i = 0; i < d->nvqs; ++i) {\n\t\t\tstruct vhost_virtqueue *vq;\n\t\t\tvoid __user *base = (void __user *)(unsigned long)p;\n\t\t\tvq = d->vqs[i];\n\t\t\tmutex_lock(&vq->mutex);\n\t\t\t/* If ring is inactive, will check when it's enabled. */\n\t\t\tif (vq->private_data && !vq_log_access_ok(vq, base))\n\t\t\t\tr = -EFAULT;\n\t\t\telse\n\t\t\t\tvq->log_base = base;\n\t\t\tmutex_unlock(&vq->mutex);\n\t\t}\n\t\tbreak;\n\tcase VHOST_SET_LOG_FD:\n\t\tr = get_user(fd, (int __user *)argp);\n\t\tif (r < 0)\n\t\t\tbreak;\n\t\teventfp = fd == -1 ? NULL : eventfd_fget(fd);\n\t\tif (IS_ERR(eventfp)) {\n\t\t\tr = PTR_ERR(eventfp);\n\t\t\tbreak;\n \t\t}\n \t\tif (eventfp != d->log_file) {\n \t\t\tfilep = d->log_file;\n \t\t\tctx = d->log_ctx;\n \t\t\td->log_ctx = eventfp ?\n \t\t\t\teventfd_ctx_fileget(eventfp) : NULL;\n\t\t} else\n\t\t\tfilep = eventfp;\n\t\tfor (i = 0; i < d->nvqs; ++i) {\n\t\t\tmutex_lock(&d->vqs[i]->mutex);\n\t\t\td->vqs[i]->log_ctx = d->log_ctx;\n\t\t\tmutex_unlock(&d->vqs[i]->mutex);\n\t\t}\n\t\tif (ctx)\n\t\t\teventfd_ctx_put(ctx);\n\t\tif (filep)\n\t\t\tfput(filep);\n\t\tbreak;\n\tdefault:\n\t\tr = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\ndone:\n\treturn r;\n}\n",
        "output": "1",
        "index": 179763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_ata_task_done(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct task_status_struct *stat = &task->task_status;\n\tstruct ata_task_resp *resp = (struct ata_task_resp *)stat->buf;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tenum ata_completion_errors ac;\n\tunsigned long flags;\n\tstruct ata_link *link;\n\tstruct ata_port *ap;\n\n\tspin_lock_irqsave(&dev->done_lock, flags);\n\tif (test_bit(SAS_HA_FROZEN, &sas_ha->state))\n\t\ttask = NULL;\n\telse if (qc && qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\tspin_unlock_irqrestore(&dev->done_lock, flags);\n\n\t/* check if libsas-eh got to the task before us */\n\tif (unlikely(!task))\n\t\treturn;\n\n\tif (!qc)\n\t\tgoto qc_already_gone;\n\n\tap = qc->ap;\n\tlink = &ap->link;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t/* check if we lost the race with libata/sas_ata_post_internal() */\n\tif (unlikely(ap->pflags & ATA_PFLAG_FROZEN)) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tif (qc->scsicmd)\n\t\t\tgoto qc_already_gone;\n\t\telse {\n\t\t\t/* if eh is not involved and the port is frozen then the\n\t\t\t * ata internal abort process has taken responsibility\n\t\t\t * for this sas_task\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat->stat == SAS_PROTO_RESPONSE || stat->stat == SAM_STAT_GOOD ||\n\t    ((stat->stat == SAM_STAT_CHECK_CONDITION &&\n\t      dev->sata_dev.class == ATA_DEV_ATAPI))) {\n\t\tmemcpy(dev->sata_dev.fis, resp->ending_fis, ATA_RESP_FIS_SIZE);\n\n\t\tif (!link->sactive) {\n\t\t\tqc->err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t} else {\n\t\t\tlink->eh_info.err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t\tif (unlikely(link->eh_info.err_mask))\n\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t}\n\t} else {\n\t\tac = sas_to_ata_err(stat);\n\t\tif (ac) {\n\t\t\tSAS_DPRINTK(\"%s: SAS error %x\\n\", __func__,\n\t\t\t\t    stat->stat);\n\t\t\t/* We saw a SAS error. Send a vague error. */\n\t\t\tif (!link->sactive) {\n\t\t\t\tqc->err_mask = ac;\n\t\t\t} else {\n\t\t\t\tlink->eh_info.err_mask |= AC_ERR_DEV;\n\t\t\t\tqc->flags |= ATA_QCFLAG_FAILED;\n\t\t\t}\n\n\t\t\tdev->sata_dev.fis[3] = 0x04; /* status err */\n\t\t\tdev->sata_dev.fis[2] = ATA_ERR;\n\t\t}\n\t}\n\n\tqc->lldd_task = NULL;\n\tata_qc_complete(qc);\n\tspin_unlock_irqrestore(ap->lock, flags);\n\nqc_already_gone:\n\tsas_free_task(task);\n}\n",
        "output": "0",
        "index": 85456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool MoveTabFunction::RunImpl() {\n  int tab_id;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(0, &tab_id));\n  DictionaryValue* update_props;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &update_props));\n\n  int new_index;\n  EXTENSION_FUNCTION_VALIDATE(update_props->GetInteger(\n      keys::kIndexKey, &new_index));\n  EXTENSION_FUNCTION_VALIDATE(new_index >= 0);\n\n  Browser* source_browser = NULL;\n  TabStripModel* source_tab_strip = NULL;\n  TabContents* contents = NULL;\n  int tab_index = -1;\n  if (!GetTabById(tab_id, profile(), include_incognito(),\n                  &source_browser, &source_tab_strip, &contents,\n                  &tab_index, &error_))\n    return false;\n\n  if (source_browser->type() != Browser::TYPE_NORMAL) {\n    error_ = keys::kCanOnlyMoveTabsWithinNormalWindowsError;\n    return false;\n  }\n\n  if (update_props->HasKey(keys::kWindowIdKey)) {\n    Browser* target_browser;\n    int window_id;\n    EXTENSION_FUNCTION_VALIDATE(update_props->GetInteger(\n        keys::kWindowIdKey, &window_id));\n    target_browser = GetBrowserInProfileWithId(profile(), window_id,\n                                               include_incognito(), &error_);\n    if (!target_browser)\n      return false;\n\n    if (target_browser->type() != Browser::TYPE_NORMAL) {\n      error_ = keys::kCanOnlyMoveTabsWithinNormalWindowsError;\n      return false;\n    }\n\n    if (ExtensionTabUtil::GetWindowId(target_browser) !=\n        ExtensionTabUtil::GetWindowId(source_browser)) {\n      TabStripModel* target_tab_strip = target_browser->tabstrip_model();\n      contents = source_tab_strip->DetachTabContentsAt(tab_index);\n      if (!contents) {\n        error_ = ExtensionErrorUtils::FormatErrorMessage(\n            keys::kTabNotFoundError, IntToString(tab_id));\n        return false;\n      }\n\n      if (new_index > target_tab_strip->count())\n        new_index = target_tab_strip->count();\n\n      target_tab_strip->InsertTabContentsAt(new_index, contents,\n          false, true);\n\n      if (has_callback())\n        result_.reset(ExtensionTabUtil::CreateTabValue(contents,\n            target_tab_strip, new_index));\n\n      return true;\n    }\n  }\n\n  if (new_index >= source_tab_strip->count())\n    new_index = source_tab_strip->count() - 1;\n\n  if (new_index != tab_index)\n    source_tab_strip->MoveTabContentsAt(tab_index, new_index, false);\n\n  if (has_callback())\n    result_.reset(ExtensionTabUtil::CreateTabValue(contents, source_tab_strip,\n        new_index));\n  return true;\n}\n",
        "output": "0",
        "index": 98581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int empty_dir(struct inode *inode)\n{\n\tunsigned int offset;\n\tstruct buffer_head *bh;\n\tstruct ext4_dir_entry_2 *de, *de1;\n\tstruct super_block *sb;\n\tint err = 0;\n\n\tsb = inode->i_sb;\n\tif (inode->i_size < EXT4_DIR_REC_LEN(1) + EXT4_DIR_REC_LEN(2) ||\n\t    !(bh = ext4_bread(NULL, inode, 0, 0, &err))) {\n\t\tif (err)\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\"error %d reading directory lblock 0\", err);\n\t\telse\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"bad directory (dir #%lu) - no data block\",\n\t\t\t\t     inode->i_ino);\n\t\treturn 1;\n\t}\n\tif (!buffer_verified(bh) &&\n\t    !ext4_dirent_csum_verify(inode,\n\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\tEXT4_ERROR_INODE(inode, \"checksum error reading directory \"\n\t\t\t\t \"lblock 0\");\n\t\treturn -EIO;\n\t}\n\tset_buffer_verified(bh);\n\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\tde1 = ext4_next_entry(de, sb->s_blocksize);\n\tif (le32_to_cpu(de->inode) != inode->i_ino ||\n\t\t\t!le32_to_cpu(de1->inode) ||\n\t\t\tstrcmp(\".\", de->name) ||\n\t\t\tstrcmp(\"..\", de1->name)) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"bad directory (dir #%lu) - no `.' or `..'\",\n\t\t\t     inode->i_ino);\n\t\tbrelse(bh);\n\t\treturn 1;\n\t}\n\toffset = ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize) +\n\t\t ext4_rec_len_from_disk(de1->rec_len, sb->s_blocksize);\n\tde = ext4_next_entry(de1, sb->s_blocksize);\n\twhile (offset < inode->i_size) {\n\t\tif (!bh ||\n\t\t    (void *) de >= (void *) (bh->b_data+sb->s_blocksize)) {\n\t\t\tunsigned int lblock;\n\t\t\terr = 0;\n\t\t\tbrelse(bh);\n\t\t\tlblock = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\t\tbh = ext4_bread(NULL, inode, lblock, 0, &err);\n\t\t\tif (!bh) {\n\t\t\t\tif (err)\n\t\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t\"error %d reading directory \"\n\t\t\t\t\t\t\"lblock %u\", err, lblock);\n\t\t\t\toffset += sb->s_blocksize;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!buffer_verified(bh) &&\n\t\t\t    !ext4_dirent_csum_verify(inode,\n\t\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\t\tEXT4_ERROR_INODE(inode, \"checksum error \"\n\t\t\t\t\t\t \"reading directory lblock 0\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tset_buffer_verified(bh);\n\t\t\tde = (struct ext4_dir_entry_2 *) bh->b_data;\n\t\t}\n\t\tif (ext4_check_dir_entry(inode, NULL, de, bh, offset)) {\n\t\t\tde = (struct ext4_dir_entry_2 *)(bh->b_data +\n\t\t\t\t\t\t\t sb->s_blocksize);\n\t\t\toffset = (offset | (sb->s_blocksize - 1)) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tbrelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\toffset += ext4_rec_len_from_disk(de->rec_len, sb->s_blocksize);\n\t\tde = ext4_next_entry(de, sb->s_blocksize);\n\t}\n\tbrelse(bh);\n\treturn 1;\n}\n",
        "output": "0",
        "index": 42060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int opfcmov(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tchar* fcmov = op->mnemonic + strlen(\"fcmov\");\n\tswitch (op->operands_count) {\n\tcase 2:\n\t\tif ( op->operands[0].type & OT_FPUREG & ~OT_REGALL && op->operands[0].reg == 0 &&\n\t\t     op->operands[1].type & OT_FPUREG & ~OT_REGALL ) {\n\t\t\tif ( !strcmp( fcmov, \"b\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"e\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"be\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xd0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"u\" ) ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0xd8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nb\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xc0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"ne\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xc8 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nbe\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xd0 | op->operands[1].reg;\n\t\t\t} else if ( !strcmp( fcmov, \"nu\" ) ) {\n\t\t\t\tdata[l++] = 0xdb;\n\t\t\t\tdata[l++] = 0xd8 | op->operands[1].reg;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n",
        "output": "0",
        "index": 75389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,\n\t\t     gfp_t gfp_mask)\n{\n\tint i;\n\tu8 *data;\n\tint size = nhead + skb_end_offset(skb) + ntail;\n\tlong off;\n\n\tBUG_ON(nhead < 0);\n\n\tif (skb_shared(skb))\n\t\tBUG();\n\n\tsize = SKB_DATA_ALIGN(size);\n\n\tif (skb_pfmemalloc(skb))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\tdata = kmalloc_reserve(size + SKB_DATA_ALIGN(sizeof(struct skb_shared_info)),\n\t\t\t       gfp_mask, NUMA_NO_NODE, NULL);\n\tif (!data)\n\t\tgoto nodata;\n\tsize = SKB_WITH_OVERHEAD(ksize(data));\n\n\t/* Copy only real data... and, alas, header. This should be\n\t * optimized for the cases when header is void.\n\t */\n\tmemcpy(data + nhead, skb->head, skb_tail_pointer(skb) - skb->head);\n\n\tmemcpy((struct skb_shared_info *)(data + size),\n\t       skb_shinfo(skb),\n\t       offsetof(struct skb_shared_info, frags[skb_shinfo(skb)->nr_frags]));\n\n\t/*\n\t * if shinfo is shared we must drop the old head gracefully, but if it\n\t * is not we can just drop the old head and let the existing refcount\n\t * be since all we did is relocate the values\n\t */\n\tif (skb_cloned(skb)) {\n\t\t/* copy this zero copy skb frags */\n\t\tif (skb_orphan_frags(skb, gfp_mask))\n\t\t\tgoto nofrags;\n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++)\n\t\t\tskb_frag_ref(skb, i);\n\n\t\tif (skb_has_frag_list(skb))\n\t\t\tskb_clone_fraglist(skb);\n\n\t\tskb_release_data(skb);\n\t} else {\n\t\tskb_free_head(skb);\n\t}\n\toff = (data + nhead) - skb->head;\n\n\tskb->head     = data;\n\tskb->head_frag = 0;\n\tskb->data    += off;\n#ifdef NET_SKBUFF_DATA_USES_OFFSET\n\tskb->end      = size;\n\toff           = nhead;\n#else\n\tskb->end      = skb->head + size;\n#endif\n\tskb->tail\t      += off;\n\tskb_headers_offset_update(skb, nhead);\n\tskb->cloned   = 0;\n\tskb->hdr_len  = 0;\n\tskb->nohdr    = 0;\n\tatomic_set(&skb_shinfo(skb)->dataref, 1);\n\treturn 0;\n\nnofrags:\n\tkfree(data);\nnodata:\n\treturn -ENOMEM;\n}\n",
        "output": "0",
        "index": 39868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int sh_num, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tchar interp[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tinterp[0] = '\\0';\n  \tfor ( ; num; num--) {\n\t\tint doread;\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < \n\t\t    CAST(ssize_t, xph_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tdoread = 1;\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment %#lx\",\n\t\t\t\t    CAST(unsigned long, align)) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tdoread = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdoread = 0;\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (doread) {\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else\n\t\t\tlen = 0;\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = dodynamic(ms, nbuf, offset,\n\t\t\t\t    CAST(size_t, bufsize), clazz, swap);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tmemcpy(interp, nbuf, bufsize);\n\t\t\t} else\n\t\t\t\tstrlcpy(interp, \"*empty*\", sizeof(interp));\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    CAST(size_t, bufsize), clazz, swap, align,\n\t\t\t\t    flags, notecount, fd, 0, 0, 0);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 83126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)\n{\n\tint err = 0, handled = 0;\n\tstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\n\tconst struct config_field_entry *cfg_entry;\n\tconst struct config_field *field;\n\tu32 tmp_val;\n\tint req_start, req_end, field_start, field_end;\n\n\tif (unlikely(verbose_request))\n\t\tprintk(KERN_DEBUG\n\t\t       DRV_NAME \": %s: write request %d bytes at 0x%x = %x\\n\",\n\t\t       pci_name(dev), size, offset, value);\n\n\tif (!valid_request(offset, size))\n\t\treturn XEN_PCI_ERR_invalid_offset;\n\n\tlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\n\t\tfield = cfg_entry->field;\n\n\t\treq_start = offset;\n\t\treq_end = offset + size;\n\t\tfield_start = OFFSET(cfg_entry);\n\t\tfield_end = OFFSET(cfg_entry) + field->size;\n\n\t\tif ((req_start >= field_start && req_start < field_end)\n\t\t    || (req_end > field_start && req_end <= field_end)) {\n\t\t\ttmp_val = 0;\n\n\t\t\terr = xen_pcibk_config_read(dev, field_start,\n\t\t\t\t\t\t  field->size, &tmp_val);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\ttmp_val = merge_value(tmp_val, value, get_mask(size),\n\t\t\t\t\t      req_start - field_start);\n\n\t\t\terr = conf_space_write(dev, cfg_entry, field_start,\n\t\t\t\t\t       tmp_val);\n\n\t\t\t/* handled is set true here, but not every byte\n\t\t\t * may have been written! Properly detecting if\n\t\t\t * every byte is handled is unnecessary as the\n\t\t\t * flag is used to detect devices that need\n\t\t\t * special helpers to work correctly.\n\t\t\t */\n\t\t\thandled = 1;\n\t\t}\n\t}\n\n\tif (!handled && !err) {\n\t\t/* By default, anything not specificially handled above is\n\t\t * read-only. The permissive flag changes this behavior so\n\t\t * that anything not specifically handled above is writable.\n\t\t * This means that some fields may still be read-only because\n\t\t * they have entries in the config_field list that intercept\n\t\t * the write and do nothing. */\n\t\tif (dev_data->permissive || permissive) {\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\terr = pci_write_config_byte(dev, offset,\n\t\t\t\t\t\t\t    (u8) value);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\terr = pci_write_config_word(dev, offset,\n\t\t\t\t\t\t\t    (u16) value);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\terr = pci_write_config_dword(dev, offset,\n\t\t\t\t\t\t\t     (u32) value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!dev_data->warned_on_write) {\n\t\t\tdev_data->warned_on_write = 1;\n\t\t\tdev_warn(&dev->dev, \"Driver tried to write to a \"\n\t\t\t\t \"read-only configuration space field at offset\"\n\t\t\t\t \" 0x%x, size %d. This may be harmless, but if \"\n\t\t\t\t \"you have problems with your device:\\n\"\n\t\t\t\t \"1) see permissive attribute in sysfs\\n\"\n\t\t\t\t \"2) report problems to the xen-devel \"\n\t\t\t\t \"mailing list along with details of your \"\n\t\t\t\t \"device obtained from lspci.\\n\", offset, size);\n\t\t}\n\t}\n\n\treturn xen_pcibios_err_to_errno(err);\n}\n",
        "output": "0",
        "index": 43957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void WriteDDSInfo(Image *image, const size_t pixelFormat,\n  const size_t compression, const size_t mipmaps)\n{\n  char\n    software[MaxTextExtent];\n\n  register ssize_t\n    i;\n\n  unsigned int\n    format,\n    caps,\n    flags;\n\n  flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |\n    DDSD_PIXELFORMAT | DDSD_LINEARSIZE);\n  caps=(unsigned int) DDSCAPS_TEXTURE;\n  format=(unsigned int) pixelFormat;\n\n  if (mipmaps > 0)\n    {\n      flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;\n      caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);\n    }\n\n  if (format != DDPF_FOURCC && image->matte)\n    format=format | DDPF_ALPHAPIXELS;\n\n  (void) WriteBlob(image,4,(unsigned char *) \"DDS \");\n  (void) WriteBlobLSBLong(image,124);\n  (void) WriteBlobLSBLong(image,flags);\n  (void) WriteBlobLSBLong(image,image->rows);\n  (void) WriteBlobLSBLong(image,image->columns);\n\n  if (compression == FOURCC_DXT1)\n    (void) WriteBlobLSBLong(image,\n             (unsigned int) (Max(1,(image->columns+3)/4) * 8));\n  else\n    (void) WriteBlobLSBLong(image,\n             (unsigned int) (Max(1,(image->columns+3)/4) * 16));\n\n  (void) WriteBlobLSBLong(image,0x00);\n  (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);\n  (void) ResetMagickMemory(software,0,sizeof(software));\n  (void) strcpy(software,\"IMAGEMAGICK\");\n  (void) WriteBlob(image,44,(unsigned char *) software);\n\n  (void) WriteBlobLSBLong(image,32);\n  (void) WriteBlobLSBLong(image,format);\n\n  if (pixelFormat == DDPF_FOURCC)\n    {\n      (void) WriteBlobLSBLong(image,(unsigned int) compression);\n      for(i=0;i < 5;i++) // bitcount / masks\n        (void) WriteBlobLSBLong(image,0x00);\n    }\n  else\n    {\n      (void) WriteBlobLSBLong(image,0x00);\n      if (image->matte)\n        {\n          (void) WriteBlobLSBLong(image,32);\n          (void) WriteBlobLSBLong(image,0xff0000);\n          (void) WriteBlobLSBLong(image,0xff00);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0xff000000);\n        }\n      else\n        {\n          (void) WriteBlobLSBLong(image,24);\n          (void) WriteBlobLSBLong(image,0xff);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n          (void) WriteBlobLSBLong(image,0x00);\n        }\n    }\n  \n  (void) WriteBlobLSBLong(image,caps);\n  for(i=0;i < 4;i++) // ddscaps2 + reserved region\n    (void) WriteBlobLSBLong(image,0x00);\n}\n",
        "output": "0",
        "index": 71493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "shapeObj *FLTGetShape(FilterEncodingNode *psFilterNode, double *pdfDistance,\n                      int *pnUnit)\n{\n  char **tokens = NULL;\n  int nTokens = 0;\n  FilterEncodingNode *psNode = psFilterNode;\n  char *szUnitStr = NULL;\n  char *szUnit = NULL;\n\n  if (psNode) {\n    if (psNode->eType == FILTER_NODE_TYPE_SPATIAL && psNode->psRightNode)\n      psNode = psNode->psRightNode;\n\n    if (FLTIsGeometryFilterNodeType(psNode->eType)) {\n\n      if (psNode->pszValue && pdfDistance) {\n        /*\n        sytnax expected is \"distance;unit\" or just \"distance\"\n        if unit is there syntax is \"URI#unit\" (eg http://..../#m)\n        or just \"unit\"\n        */\n        tokens = msStringSplit(psNode->pszValue,';', &nTokens);\n        if (tokens && nTokens >= 1) {\n          *pdfDistance = atof(tokens[0]);\n\n          if (nTokens == 2 && pnUnit) {\n            szUnitStr = msStrdup(tokens[1]);\n            msFreeCharArray(tokens, nTokens);\n            nTokens = 0;\n            tokens = msStringSplit(szUnitStr,'#', &nTokens);\n            msFree(szUnitStr);\n            if (tokens && nTokens >= 1) {\n              if (nTokens ==1)\n                szUnit = tokens[0];\n              else\n                szUnit = tokens[1];\n\n              if (strcasecmp(szUnit,\"m\") == 0 ||\n                  strcasecmp(szUnit,\"meters\") == 0 )\n                *pnUnit = MS_METERS;\n              else if (strcasecmp(szUnit,\"km\") == 0 ||\n                       strcasecmp(szUnit,\"kilometers\") == 0)\n                *pnUnit = MS_KILOMETERS;\n              else if (strcasecmp(szUnit,\"NM\") == 0 ||\n                       strcasecmp(szUnit,\"nauticalmiles\") == 0)\n                *pnUnit = MS_NAUTICALMILES;\n              else if (strcasecmp(szUnit,\"mi\") == 0 ||\n                       strcasecmp(szUnit,\"miles\") == 0)\n                *pnUnit = MS_MILES;\n              else if (strcasecmp(szUnit,\"in\") == 0 ||\n                       strcasecmp(szUnit,\"inches\") == 0)\n                *pnUnit = MS_INCHES;\n              else if (strcasecmp(szUnit,\"ft\") == 0 ||\n                       strcasecmp(szUnit,\"feet\") == 0)\n                *pnUnit = MS_FEET;\n              else if (strcasecmp(szUnit,\"deg\") == 0 ||\n                       strcasecmp(szUnit,\"dd\") == 0)\n                *pnUnit = MS_DD;\n              else if (strcasecmp(szUnit,\"px\") == 0)\n                *pnUnit = MS_PIXELS;\n\n            }\n          }\n        } \n        msFreeCharArray(tokens, nTokens);\n      }\n\n      return (shapeObj *)psNode->pOther;\n    }\n  }\n  return NULL;\n}\n",
        "output": "0",
        "index": 68991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int piv_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint enumtag;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (priv->selected_obj < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\n\tenumtag = piv_objects[priv->selected_obj].enumtag;\n\n\tif (priv->rwb_state == 1)  /* trying to write at end */\n\t\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\n\tif (priv->rwb_state == -1) {\n\n\t\t/* if  cached, remove old entry */\n\t\tif (priv->obj_cache[enumtag].flags & PIV_OBJ_CACHE_VALID) {\n\t\t\tpriv->obj_cache[enumtag].flags = 0;\n\t\t\tif (priv->obj_cache[enumtag].obj_data) {\n\t\t\t\tfree(priv->obj_cache[enumtag].obj_data);\n\t\t\t\tpriv->obj_cache[enumtag].obj_data = NULL;\n\t\t\t\tpriv->obj_cache[enumtag].obj_len = 0;\n\t\t\t}\n\t\t\tif (priv->obj_cache[enumtag].internal_obj_data) {\n\t\t\t\tfree(priv->obj_cache[enumtag].internal_obj_data);\n\t\t\t\tpriv->obj_cache[enumtag].internal_obj_data = NULL;\n\t\t\t\tpriv->obj_cache[enumtag].internal_obj_len = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (idx != 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NO_CARD_SUPPORT);\n\n\t\tpriv->w_buf_len = flags>>8;\n\t\tif (priv->w_buf_len == 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\n\t\tpriv->w_buf = malloc(priv->w_buf_len);\n\t\tpriv-> rwb_state = 0;\n\t}\n\n\t/* on each pass make sure we have w_buf */\n\tif (priv->w_buf == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tif (idx + count > priv->w_buf_len)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OBJECT_NOT_VALID);\n\n\tmemcpy(priv->w_buf + idx, buf, count); /* copy one chunk */\n\n\t/* if this was not the last chunk, return to get rest */\n\tif (idx + count < priv->w_buf_len)\n\t\tLOG_FUNC_RETURN(card->ctx, count);\n\n\tpriv-> rwb_state = 1; /* at end of object */\n\n\tswitch (flags & 0x0f) {\n\t\tcase 1:\n\t\t\tr = piv_write_certificate(card, priv->w_buf, priv->w_buf_len, flags & 0x10);\n\t\t\tbreak;\n\t\tcase 2: /* pubkey to be added to cache, it should have 0x53 and 0x99 tags. */\n\t\t/* TODO: -DEE this is not fully implemented and not used */\n\t\t\tr = priv->w_buf_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr = piv_put_data(card, enumtag, priv->w_buf, priv->w_buf_len);\n\t\t\tbreak;\n\t}\n\t/* if it worked, will cache it */\n\tif (r >= 0 && priv->w_buf) {\n\t\tpriv->obj_cache[enumtag].flags |= PIV_OBJ_CACHE_VALID;\n\t\tpriv->obj_cache[enumtag].obj_data = priv->w_buf;\n\t\tpriv->obj_cache[enumtag].obj_len = priv->w_buf_len;\n\t} else {\n\t\tif (priv->w_buf)\n\t\t\tfree(priv->w_buf);\n\t}\n\tpriv->w_buf = NULL;\n\tpriv->w_buf_len = 0;\n\tLOG_FUNC_RETURN(card->ctx, (r < 0)? r : (int)count);\n}\n",
        "output": "0",
        "index": 78658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntRect PopupContainer::layoutAndCalculateWidgetRect(int targetControlHeight, const IntPoint& popupInitialCoordinate)\n{\n    m_listBox->setMaxHeight(kMaxHeight);\n    m_listBox->setMaxWidth(std::numeric_limits<int>::max());\n\n    int rtlOffset = layoutAndGetRTLOffset();\n    bool isRTL = this->isRTL();\n    int rightOffset = isRTL ? rtlOffset : 0;\n\n     IntSize targetSize(m_listBox->width() + kBorderSize * 2,\n                        m_listBox->height() + kBorderSize * 2);\n \n    IntRect widgetRect;\n     ChromeClientChromium* chromeClient = chromeClientChromium();\n     if (chromeClient) {\n         FloatRect screen = screenAvailableRect(m_frameView.get());\n        widgetRect = chromeClient->rootViewToScreen(IntRect(popupInitialCoordinate.x() + rightOffset, popupInitialCoordinate.y(), targetSize.width(), targetSize.height()));\n \n         FloatRect windowRect = chromeClient->windowRect();\n        if (windowRect.x() >= screen.x() && windowRect.maxX() <= screen.maxX() && (widgetRect.x() < screen.x() || widgetRect.maxX() > screen.maxX())) {\n            IntRect inverseWidgetRect = chromeClient->rootViewToScreen(IntRect(popupInitialCoordinate.x() + (isRTL ? 0 : rtlOffset), popupInitialCoordinate.y(), targetSize.width(), targetSize.height()));\n             IntRect enclosingScreen = enclosingIntRect(screen);\n            unsigned originalCutoff = max(enclosingScreen.x() - widgetRect.x(), 0) + max(widgetRect.maxX() - enclosingScreen.maxX(), 0);\n            unsigned inverseCutoff = max(enclosingScreen.x() - inverseWidgetRect.x(), 0) + max(inverseWidgetRect.maxX() - enclosingScreen.maxX(), 0);\n \n             if (inverseCutoff < originalCutoff)\n                widgetRect = inverseWidgetRect;\n            if (widgetRect.x() < screen.x()) {\n                unsigned widgetRight = widgetRect.maxX();\n                widgetRect.setWidth(widgetRect.maxX() - screen.x());\n                widgetRect.setX(widgetRight - widgetRect.width());\n                listBox()->setMaxWidthAndLayout(max(widgetRect.width() - kBorderSize * 2, 0));\n            } else if (widgetRect.maxX() > screen.maxX()) {\n                widgetRect.setWidth(screen.maxX() - widgetRect.x());\n                listBox()->setMaxWidthAndLayout(max(widgetRect.width() - kBorderSize * 2, 0));\n             }\n         }\n \n        if (widgetRect.maxY() > static_cast<int>(screen.maxY())) {\n            if (widgetRect.y() - widgetRect.height() - targetControlHeight > 0) {\n                widgetRect.move(0, -(widgetRect.height() + targetControlHeight));\n             } else {\n                int spaceAbove = widgetRect.y() - targetControlHeight;\n                int spaceBelow = screen.maxY() - widgetRect.y();\n                 if (spaceAbove > spaceBelow)\n                     m_listBox->setMaxHeight(spaceAbove);\n                 else\n                    m_listBox->setMaxHeight(spaceBelow);\n                layoutAndGetRTLOffset();\n                 IntRect frameInScreen = chromeClient->rootViewToScreen(frameRect());\n                widgetRect.setY(frameInScreen.y());\n                widgetRect.setHeight(frameInScreen.height());\n                 if (spaceAbove > spaceBelow)\n                    widgetRect.move(0, -(widgetRect.height() + targetControlHeight));\n             }\n         }\n     }\n    return widgetRect;\n }\n",
        "output": "1",
        "index": 184718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,\n    const char* module)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n    if (!_TIFFFillStriles( tif ))\n        return ((tmsize_t)(-1));\n        \n\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\tif (!isMapped(tif)) {\n\t\ttmsize_t cc;\n\n\t\tif (!SeekOK(tif, td->td_stripoffset[strip])) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Seek error at scanline %lu, strip %lu\",\n\t\t\t    (unsigned long) tif->tif_row, (unsigned long) strip);\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\tcc = TIFFReadFile(tif, buf, size);\n\t\tif (cc != size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\"Read error at scanline %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned __int64) cc,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\"Read error at scanline %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long long) cc,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t} else {\n\t\ttmsize_t ma,mb;\n\t\ttmsize_t n;\n\t\tma=(tmsize_t)td->td_stripoffset[strip];\n\t\tmb=ma+size;\n\t\tif ((td->td_stripoffset[strip] > (uint64)TIFF_TMSIZE_T_MAX)||(ma>tif->tif_size))\n\t\t\tn=0;\n\t\telse if ((mb<ma)||(mb<size)||(mb>tif->tif_size))\n\t\t\tn=tif->tif_size-ma;\n\t\telse\n\t\t\tn=size;\n\t\tif (n!=size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at scanline %lu, strip %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) strip,\n\t\t\t\t     (unsigned __int64) n,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at scanline %lu, strip %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) strip,\n\t\t\t\t     (unsigned long long) n,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\t_TIFFmemcpy(buf, tif->tif_base + ma,\n\t\t\t    size);\n\t}\n\treturn (size);\n}\n",
        "output": "0",
        "index": 70337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Image *ReadJNGImage(const ImageInfo *image_info,\n                ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  char\n    magic_number[MagickPathExtent];\n\n  size_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n     image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter ReadJNGImage()\");\n  image=AcquireImage(image_info,exception);\n  mng_info=(MngInfo *) NULL;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  if (LocaleCompare(image_info->magick,\"JNG\") != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /* Verify JNG signature.  */\n\n  count=(size_t) ReadBlob(image,8,(unsigned char *) magic_number);\n\n  if (count < 8 || memcmp(magic_number,\"\\213JNG\\r\\n\\032\\n\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*\n     Verify that file size large enough to contain a JNG datastream.\n  */\n  if (GetBlobSize(image) < 147)\n    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n\n  /* Allocate a MngInfo structure.  */\n\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(*mng_info));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* Initialize members of the MngInfo structure.  */\n\n  (void) ResetMagickMemory(mng_info,0,sizeof(MngInfo));\n\n  mng_info->image=image;\n  image=ReadOneJNGImage(mng_info,image_info,exception);\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (image == (Image *) NULL)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n\n  if (image->columns == 0 || image->rows == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadJNGImage() with error\");\n\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadJNGImage()\");\n\n  return(image);\n}\n",
        "output": "0",
        "index": 63302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi,\n\t\t\t\t\t\tstruct snd_usb_midi_endpoint_info *endpoint)\n{\n\tstruct snd_usb_midi_endpoint_info ep_info;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *hostif;\n\tstruct usb_interface_descriptor *intfd;\n\tstruct usb_endpoint_descriptor *epd;\n\tint cable, err;\n\n\tintf = umidi->iface;\n\tif (!intf)\n\t\treturn -ENOENT;\n\thostif = intf->altsetting;\n\tintfd = get_iface_desc(hostif);\n\t/*\n\t * The various MidiSport devices have more or less random endpoint\n\t * numbers, so we have to identify the endpoints by their index in\n\t * the descriptor array, like the driver for that other OS does.\n\t *\n\t * There is one interrupt input endpoint for all input ports, one\n\t * bulk output endpoint for even-numbered ports, and one for odd-\n\t * numbered ports.  Both bulk output endpoints have corresponding\n\t * input bulk endpoints (at indices 1 and 3) which aren't used.\n\t */\n\tif (intfd->bNumEndpoints < (endpoint->out_cables > 0x0001 ? 5 : 3)) {\n\t\tdev_dbg(&umidi->dev->dev, \"not enough endpoints\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tepd = get_endpoint(hostif, 0);\n\tif (!usb_endpoint_dir_in(epd) || !usb_endpoint_xfer_int(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[0] isn't interrupt\\n\");\n\t\treturn -ENXIO;\n\t}\n\tepd = get_endpoint(hostif, 2);\n\tif (!usb_endpoint_dir_out(epd) || !usb_endpoint_xfer_bulk(epd)) {\n\t\tdev_dbg(&umidi->dev->dev, \"endpoint[2] isn't bulk output\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (endpoint->out_cables > 0x0001) {\n\t\tepd = get_endpoint(hostif, 4);\n\t\tif (!usb_endpoint_dir_out(epd) ||\n\t\t    !usb_endpoint_xfer_bulk(epd)) {\n\t\t\tdev_dbg(&umidi->dev->dev,\n\t\t\t\t\"endpoint[4] isn't bulk output\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tep_info.out_ep = get_endpoint(hostif, 2)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.out_interval = 0;\n\tep_info.out_cables = endpoint->out_cables & 0x5555;\n\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t      &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tep_info.in_ep = get_endpoint(hostif, 0)->bEndpointAddress &\n\t\tUSB_ENDPOINT_NUMBER_MASK;\n\tep_info.in_interval = get_endpoint(hostif, 0)->bInterval;\n\tep_info.in_cables = endpoint->in_cables;\n\terr = snd_usbmidi_in_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t     &umidi->endpoints[0]);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (endpoint->out_cables > 0x0001) {\n\t\tep_info.out_ep = get_endpoint(hostif, 4)->bEndpointAddress &\n\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\tep_info.out_cables = endpoint->out_cables & 0xaaaa;\n\t\terr = snd_usbmidi_out_endpoint_create(umidi, &ep_info,\n\t\t\t\t\t\t      &umidi->endpoints[1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (cable = 0; cable < 0x10; ++cable) {\n\t\tif (endpoint->out_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_OUTPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[cable & 1].out->ports[cable].substream);\n\t\tif (endpoint->in_cables & (1 << cable))\n\t\t\tsnd_usbmidi_init_substream(umidi,\n\t\t\t\t\t\t   SNDRV_RAWMIDI_STREAM_INPUT,\n\t\t\t\t\t\t   cable,\n\t\t\t\t\t\t   &umidi->endpoints[0].in->ports[cable].substream);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 54758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, interface);\n\n\tif (!iface) {\n\t\tdev_err(&dev->dev, \"%u:%d : does not exist\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t/*\n\t * Android with both accessory and audio interfaces enabled gets the\n\t * interface numbers wrong.\n\t */\n\tif ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||\n\t     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&\n\t    interface == 0 &&\n\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {\n\t\tinterface = 2;\n\t\tiface = usb_ifnum_to_if(dev, interface);\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\talts = &iface->altsetting[0];\n\t\taltsd = get_iface_desc(alts);\n\t}\n\n\tif (usb_interface_claimed(iface)) {\n\t\tdev_dbg(&dev->dev, \"%d:%d: skipping, already claimed\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||\n\t     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {\n\t\tint err = __snd_usbmidi_create(chip->card, iface,\n\t\t\t\t\t     &chip->midi_list, NULL,\n\t\t\t\t\t     chip->usb_id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d: cannot create sequencer device\\n\",\n\t\t\t\tctrlif, interface);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\n\t\treturn 0;\n\t}\n\n\tif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\n\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"%u:%d: skipping non-supported interface %d\\n\",\n\t\t\tctrlif, interface, altsd->bInterfaceClass);\n\t\t/* skip non-supported classes */\n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_usb_get_speed(dev) == USB_SPEED_LOW) {\n\t\tdev_err(&dev->dev, \"low speed audio streaming not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (! snd_usb_parse_audio_interface(chip, interface)) {\n\t\tusb_set_interface(dev, interface, 0); /* reset the current interface */\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 59930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 CropPicture(u8 *pOutImage, u8 *pInImage,\n    u32 picWidth, u32 picHeight, CropParams *pCropParams)\n{\n\n    u32 i, j;\n    u32 outWidth, outHeight;\n    u8 *pOut, *pIn;\n\n if (pOutImage == NULL || pInImage == NULL || pCropParams == NULL ||\n !picWidth || !picHeight)\n {\n /* just to prevent lint warning, returning non-zero will result in\n         * return without freeing the memory */\n        free(pOutImage);\n return(1);\n }\n\n if ( ((pCropParams->cropLeftOffset + pCropParams->cropOutWidth) >\n           picWidth ) ||\n ((pCropParams->cropTopOffset + pCropParams->cropOutHeight) >\n           picHeight ) )\n {\n /* just to prevent lint warning, returning non-zero will result in\n         * return without freeing the memory */\n        free(pOutImage);\n return(1);\n }\n\n    outWidth = pCropParams->cropOutWidth;\n    outHeight = pCropParams->cropOutHeight;\n\n /* Calculate starting pointer for luma */\n    pIn = pInImage + pCropParams->cropTopOffset*picWidth +\n        pCropParams->cropLeftOffset;\n    pOut = pOutImage;\n\n /* Copy luma pixel values */\n for (i = outHeight; i; i--)\n {\n for (j = outWidth; j; j--)\n {\n *pOut++ = *pIn++;\n }\n        pIn += picWidth - outWidth;\n }\n\n    outWidth >>= 1;\n    outHeight >>= 1;\n\n /* Calculate starting pointer for cb */\n    pIn = pInImage + picWidth*picHeight +\n        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;\n\n /* Copy cb pixel values */\n for (i = outHeight; i; i--)\n {\n for (j = outWidth; j; j--)\n {\n *pOut++ = *pIn++;\n }\n        pIn += picWidth/2 - outWidth;\n }\n\n /* Calculate starting pointer for cr */\n    pIn = pInImage + 5*picWidth*picHeight/4 +\n        pCropParams->cropTopOffset*picWidth/4 + pCropParams->cropLeftOffset/2;\n\n /* Copy cr pixel values */\n for (i = outHeight; i; i--)\n {\n for (j = outWidth; j; j--)\n {\n *pOut++ = *pIn++;\n }\n        pIn += picWidth/2 - outWidth;\n }\n\n return (0);\n}\n",
        "output": "0",
        "index": 174040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::HandleGetActiveUniformsiv(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  if (!feature_info_->IsWebGL2OrES3Context())\n    return error::kUnknownCommand;\n  const volatile gles2::cmds::GetActiveUniformsiv& c =\n      *static_cast<const volatile gles2::cmds::GetActiveUniformsiv*>(cmd_data);\n  GLuint program_id = c.program;\n  GLenum pname = static_cast<GLenum>(c.pname);\n  Bucket* bucket = GetBucket(c.indices_bucket_id);\n  if (!bucket) {\n    return error::kInvalidArguments;\n  }\n  if (!validators_->uniform_parameter.IsValid(pname)) {\n    LOCAL_SET_GL_ERROR_INVALID_ENUM(\"glGetActiveUniformsiv\", pname, \"pname\");\n    return error::kNoError;\n  }\n  GLsizei count = static_cast<GLsizei>(bucket->size() / sizeof(GLuint));\n  const GLuint* indices = bucket->GetDataAs<const GLuint*>(0, bucket->size());\n  typedef cmds::GetActiveUniformsiv::Result Result;\n  uint32_t checked_size = 0;\n  if (!Result::ComputeSize(count).AssignIfValid(&checked_size)) {\n    return error::kOutOfBounds;\n  }\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.params_shm_id, c.params_shm_offset, checked_size);\n  GLint* params = result ? result->GetData() : nullptr;\n  if (params == nullptr) {\n    return error::kOutOfBounds;\n  }\n  if (result->size != 0) {\n    return error::kInvalidArguments;\n  }\n  Program* program = GetProgramInfoNotShader(\n      program_id, \"glGetActiveUniformsiv\");\n  if (!program) {\n    return error::kNoError;\n  }\n  GLint activeUniforms = 0;\n  program->GetProgramiv(GL_ACTIVE_UNIFORMS, &activeUniforms);\n  for (int i = 0; i < count; i++) {\n    if (indices[i] >= static_cast<GLuint>(activeUniforms)) {\n      LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,\n          \"glGetActiveUniformsiv\", \"index >= active uniforms\");\n      return error::kNoError;\n    }\n  }\n  GLuint service_id = program->service_id();\n  GLint link_status = GL_FALSE;\n  api()->glGetProgramivFn(service_id, GL_LINK_STATUS, &link_status);\n  if (link_status != GL_TRUE) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_OPERATION,\n        \"glGetActiveUniformsiv\", \"program not linked\");\n    return error::kNoError;\n  }\n  api()->glGetActiveUniformsivFn(service_id, count, indices, pname, params);\n  result->SetNumResults(count);\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 154227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MPEG4Extractor::parseSegmentIndex(off64_t offset, size_t size) {\n  ALOGV(\"MPEG4Extractor::parseSegmentIndex\");\n\n if (size < 12) {\n return -EINVAL;\n }\n\n uint32_t flags;\n if (!mDataSource->getUInt32(offset, &flags)) {\n return ERROR_MALFORMED;\n }\n\n uint32_t version = flags >> 24;\n    flags &= 0xffffff;\n\n    ALOGV(\"sidx version %d\", version);\n\n uint32_t referenceId;\n if (!mDataSource->getUInt32(offset + 4, &referenceId)) {\n return ERROR_MALFORMED;\n }\n\n uint32_t timeScale;\n if (!mDataSource->getUInt32(offset + 8, &timeScale)) {\n return ERROR_MALFORMED;\n }\n    ALOGV(\"sidx refid/timescale: %d/%d\", referenceId, timeScale);\n\n uint64_t earliestPresentationTime;\n uint64_t firstOffset;\n\n    offset += 12;\n    size -= 12;\n\n if (version == 0) {\n if (size < 8) {\n return -EINVAL;\n }\n uint32_t tmp;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        earliestPresentationTime = tmp;\n if (!mDataSource->getUInt32(offset + 4, &tmp)) {\n return ERROR_MALFORMED;\n }\n        firstOffset = tmp;\n        offset += 8;\n        size -= 8;\n } else {\n if (size < 16) {\n return -EINVAL;\n }\n if (!mDataSource->getUInt64(offset, &earliestPresentationTime)) {\n return ERROR_MALFORMED;\n }\n if (!mDataSource->getUInt64(offset + 8, &firstOffset)) {\n return ERROR_MALFORMED;\n }\n        offset += 16;\n        size -= 16;\n }\n    ALOGV(\"sidx pres/off: %\" PRIu64 \"/%\" PRIu64, earliestPresentationTime, firstOffset);\n\n if (size < 4) {\n return -EINVAL;\n }\n\n uint16_t referenceCount;\n if (!mDataSource->getUInt16(offset + 2, &referenceCount)) {\n return ERROR_MALFORMED;\n }\n    offset += 4;\n    size -= 4;\n    ALOGV(\"refcount: %d\", referenceCount);\n\n if (size < referenceCount * 12) {\n return -EINVAL;\n }\n\n uint64_t total_duration = 0;\n for (unsigned int i = 0; i < referenceCount; i++) {\n uint32_t d1, d2, d3;\n\n if (!mDataSource->getUInt32(offset, &d1) || // size\n !mDataSource->getUInt32(offset + 4, &d2) || // duration\n !mDataSource->getUInt32(offset + 8, &d3)) { // flags\n return ERROR_MALFORMED;\n }\n\n if (d1 & 0x80000000) {\n            ALOGW(\"sub-sidx boxes not supported yet\");\n }\n bool sap = d3 & 0x80000000;\n uint32_t saptype = (d3 >> 28) & 7;\n if (!sap || (saptype != 1 && saptype != 2)) {\n            ALOGW(\"not a stream access point, or unsupported type: %08x\", d3);\n }\n        total_duration += d2;\n        offset += 12;\n        ALOGV(\" item %d, %08x %08x %08x\", i, d1, d2, d3);\n SidxEntry se;\n        se.mSize = d1 & 0x7fffffff;\n        se.mDurationUs = 1000000LL * d2 / timeScale;\n        mSidxEntries.add(se);\n }\n\n uint64_t sidxDuration = total_duration * 1000000 / timeScale;\n\n int64_t metaDuration;\n if (!mLastTrack->meta->findInt64(kKeyDuration, &metaDuration) || metaDuration == 0) {\n        mLastTrack->meta->setInt64(kKeyDuration, sidxDuration);\n }\n return OK;\n}\n",
        "output": "0",
        "index": 170373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int sh_num, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tconst char *interp = \"\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment %#lx\",\n\t\t\t\t    (unsigned long)align) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tinterp = (const char *)nbuf;\n\t\t\t} else\n\t\t\t\tinterp = \"*empty*\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    (size_t)bufsize, clazz, swap, align,\n\t\t\t\t    flags, notecount, fd, 0, 0, 0);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> toV8Object(const WebGLGetInfo& info, v8::Isolate* isolate)\n{\n    switch (info.getType()) {\n    case WebGLGetInfo::kTypeBool:\n        return v8::Boolean::New(info.getBool());\n    case WebGLGetInfo::kTypeBoolArray: {\n        const Vector<bool>& value = info.getBoolArray();\n        v8::Local<v8::Array> array = v8::Array::New(value.size());\n        for (size_t ii = 0; ii < value.size(); ++ii)\n            array->Set(v8::Integer::New(ii), v8::Boolean::New(value[ii]));\n        return array;\n    }\n    case WebGLGetInfo::kTypeFloat:\n        return v8::Number::New(info.getFloat());\n    case WebGLGetInfo::kTypeInt:\n        return v8::Integer::New(info.getInt());\n    case WebGLGetInfo::kTypeNull:\n        return v8::Null();\n    case WebGLGetInfo::kTypeString:\n        return v8::String::New(fromWebCoreString(info.getString()), info.getString().length());\n    case WebGLGetInfo::kTypeUnsignedInt:\n        return v8::Integer::NewFromUnsigned(info.getUnsignedInt());\n    case WebGLGetInfo::kTypeWebGLBuffer:\n        return toV8(info.getWebGLBuffer(), isolate);\n    case WebGLGetInfo::kTypeWebGLFloatArray:\n        return toV8(info.getWebGLFloatArray(), isolate);\n    case WebGLGetInfo::kTypeWebGLFramebuffer:\n        return toV8(info.getWebGLFramebuffer(), isolate);\n    case WebGLGetInfo::kTypeWebGLIntArray:\n        return toV8(info.getWebGLIntArray(), isolate);\n    case WebGLGetInfo::kTypeWebGLProgram:\n        return toV8(info.getWebGLProgram(), isolate);\n    case WebGLGetInfo::kTypeWebGLRenderbuffer:\n        return toV8(info.getWebGLRenderbuffer(), isolate);\n    case WebGLGetInfo::kTypeWebGLTexture:\n        return toV8(info.getWebGLTexture(), isolate);\n    case WebGLGetInfo::kTypeWebGLUnsignedByteArray:\n        return toV8(info.getWebGLUnsignedByteArray(), isolate);\n    case WebGLGetInfo::kTypeWebGLUnsignedIntArray:\n        return toV8(info.getWebGLUnsignedIntArray(), isolate);\n    case WebGLGetInfo::kTypeWebGLVertexArrayObjectOES:\n        return toV8(info.getWebGLVertexArrayObjectOES(), isolate);\n    default:\n        notImplemented();\n        return v8::Undefined();\n    }\n}\n",
        "output": "0",
        "index": 118037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int piv_select_file(sc_card_t *card, const sc_path_t *in_path,\n\tsc_file_t **file_out)\n{\n\tpiv_private_data_t * priv = PIV_DATA(card);\n\tint r;\n\tint i;\n\tconst u8 *path;\n\tint pathlen;\n\tsc_file_t *file = NULL;\n\tu8 * rbuf = NULL;\n\tsize_t rbuflen = 0;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tpath = in_path->value;\n\tpathlen = in_path->len;\n\n\t/* only support single EF in current application */\n\t/*\n\t * PIV emulates files, and only does so because sc_pkcs15_* uses\n\t * select_file and read_binary. The emulation adds path emulated structures\n\t * so piv_select_file will find it.\n\t * there is no dir. Only direct access to emulated files\n\t * thus opensc-tool and opensc-explorer can not read the emulated files\n\t */\n\n\tif (memcmp(path, \"\\x3F\\x00\", 2) == 0) {\n\t\tif (pathlen > 2) {\n\t\t\tpath += 2;\n\t\t\tpathlen -= 2;\n\t\t}\n\t}\n\n\ti = piv_find_obj_by_containerid(card, path);\n\n\tif (i < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_NOT_FOUND);\n\n\t/*\n\t * pkcs15 will use a 2 byte path or a 4 byte path\n\t * with cece added to path to request only the cert from the cert obj\n\t * PIV \"Container ID\" is used as the path, and are two bytes long\n\t */\n\tpriv->return_only_cert = (pathlen == 4 && path[2] == 0xce && path[3] == 0xce);\n\n\tpriv->selected_obj = i;\n\tpriv->rwb_state = -1;\n\n\t/* make it look like the file was found. */\n\t/* We don't want to read it now  unless we need the length */\n\n\tif (file_out) {\n\t\t/* we need to read it now, to get length into cache */\n\t\tr = piv_get_cached_data(card, i, &rbuf, &rbuflen);\n\n\t\tif (r < 0)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_NOT_FOUND);\n\n\t\t/* get the cert or the pub key out and into the cache too */\n\t\tif (priv->return_only_cert || piv_objects[i].flags & PIV_OBJECT_TYPE_PUBKEY) {\n\t\t\tr = piv_cache_internal_data(card, i);\n\t\t\tif (r < 0)\n\t\t\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t\t}\n\n\t\tfile = sc_file_new();\n\t\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\t\tfile->path = *in_path;\n\t\t/* this could be like the FCI */\n\t\tfile->type =  SC_FILE_TYPE_DF;\n\t\tfile->shareable = 0;\n\t\tfile->ef_structure = 0;\n\t\tif (priv->return_only_cert)\n\t\t\tfile->size = priv->obj_cache[i].internal_obj_len;\n\t\telse\n\t\t\tfile->size = priv->obj_cache[i].obj_len;\n\n\t\tfile->id = (piv_objects[i].containerid[0]<<8) + piv_objects[i].containerid[1];\n\n\t\t*file_out = file;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n\n}\n",
        "output": "0",
        "index": 78655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lexer_process_char_literal (parser_context_t *context_p, /**< context */\n                            const uint8_t *char_p, /**< characters */\n                            size_t length, /**< length of string */\n                            uint8_t literal_type, /**< final literal type */\n                            bool has_escape) /**< has escape sequences */\n{\n  parser_list_iterator_t literal_iterator;\n  lexer_literal_t *literal_p;\n  uint32_t literal_index = 0;\n\n  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL\n                || literal_type == LEXER_STRING_LITERAL);\n\n  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);\n  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);\n\n  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);\n\n  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)\n  {\n    if (literal_p->type == literal_type\n        && literal_p->prop.length == length\n        && memcmp (literal_p->u.char_p, char_p, length) == 0)\n    {\n      context_p->lit_object.literal_p = literal_p;\n      context_p->lit_object.index = (uint16_t) literal_index;\n      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);\n      return;\n    }\n\n    literal_index++;\n  }\n\n  JERRY_ASSERT (literal_index == context_p->literal_count);\n\n  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n  {\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n \n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;\n  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;\n\n  if (has_escape)\n  {\n    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);\n    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);\n  }\n  else\n  {\n    literal_p->u.char_p = char_p;\n  }\n\n  context_p->lit_object.literal_p = literal_p;\n  context_p->lit_object.index = (uint16_t) literal_index;\n  context_p->literal_count++;\n} /* lexer_process_char_literal */\n",
        "output": "1",
        "index": 181277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)\n{\n    EAS_I32 *pMixBuffer;\n const EAS_I8 *pLoopEnd;\n const EAS_I8 *pCurrentPhaseInt;\n    EAS_I32 numSamples;\n    EAS_I32 gain;\n    EAS_I32 gainIncrement;\n    EAS_I32 currentPhaseFrac;\n    EAS_I32 phaseInc;\n    EAS_I32 tmp0;\n    EAS_I32 tmp1;\n    EAS_I32 tmp2;\n    EAS_I8 *pLoopStart;\n\n\n     numSamples = pWTIntFrame->numSamples;\n     if (numSamples <= 0) {\n         ALOGE(\"b/26366256\");\n         return;\n     }\n     pMixBuffer = pWTIntFrame->pMixBuffer;\n\n /* calculate gain increment */\n    gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);\n if (gainIncrement < 0)\n        gainIncrement++;\n    gain = pWTIntFrame->prevGain << 16;\n\n    pCurrentPhaseInt = pWTVoice->pPhaseAccum;\n    currentPhaseFrac = pWTVoice->phaseFrac;\n    phaseInc = pWTIntFrame->phaseIncrement;\n\n    pLoopStart = pWTVoice->pLoopStart;\n    pLoopEnd = pWTVoice->pLoopEnd + 1;\n\nInterpolationLoop:\n    tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);\n if (tmp0 >= 0)\n        pCurrentPhaseInt = pLoopStart + tmp0;\n\n    tmp0 = *pCurrentPhaseInt;\n    tmp1 = *(pCurrentPhaseInt + 1);\n\n    tmp2 = phaseInc + currentPhaseFrac;\n\n    tmp1 = tmp1 - tmp0;\n    tmp1 = tmp1 * currentPhaseFrac;\n\n    tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);\n\n    pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);\n    currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;\n\n    gain += gainIncrement;\n    tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n\n    tmp0 = *pMixBuffer;\n    tmp2 = tmp1 * tmp2;\n    tmp2 = (tmp2 >> 9);\n    tmp0 = tmp2 + tmp0;\n *pMixBuffer++ = tmp0;\n\n    numSamples--;\n if (numSamples > 0)\n goto InterpolationLoop;\n\n    pWTVoice->pPhaseAccum = pCurrentPhaseInt;\n    pWTVoice->phaseFrac = currentPhaseFrac;\n /*lint -e{702} <avoid divide>*/\n    pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);\n}\n",
        "output": "1",
        "index": 188624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_read_format_cpio_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct cpio *cpio;\n\tconst void *h;\n\tstruct archive_string_conv *sconv;\n\tsize_t namelength;\n\tsize_t name_pad;\n\tint r;\n\n\tcpio = (struct cpio *)(a->format->data);\n\tsconv = cpio->opt_sconv;\n\tif (sconv == NULL) {\n\t\tif (!cpio->init_default_conversion) {\n\t\t\tcpio->sconv_default =\n\t\t\t    archive_string_default_conversion_for_read(\n\t\t\t      &(a->archive));\n\t\t\tcpio->init_default_conversion = 1;\n\t\t}\n\t\tsconv = cpio->sconv_default;\n\t}\n\t\n\tr = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));\n\n\tif (r < ARCHIVE_WARN)\n\t\treturn (r);\n\n\t/* Read name from buffer. */\n\th = __archive_read_ahead(a, namelength + name_pad, NULL);\n\tif (h == NULL)\n\t    return (ARCHIVE_FATAL);\n\tif (archive_entry_copy_pathname_l(entry,\n\t    (const char *)h, namelength, sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname can't be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tcpio->entry_offset = 0;\n\n\t__archive_read_consume(a, namelength + name_pad);\n \n \t/* If this is a symlink, read the link contents. */\n \tif (archive_entry_filetype(entry) == AE_IFLNK) {\n \t\th = __archive_read_ahead(a,\n \t\t\t(size_t)cpio->entry_bytes_remaining, NULL);\n \t\tif (h == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (archive_entry_copy_symlink_l(entry, (const char *)h,\n\t\t    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Linkname can't be converted from %s to \"\n\t\t\t    \"current locale.\",\n\t\t\t    archive_string_conversion_charset_name(sconv));\n\t\t\tr = ARCHIVE_WARN;\n\t\t}\n\t\t__archive_read_consume(a, cpio->entry_bytes_remaining);\n\t\tcpio->entry_bytes_remaining = 0;\n\t}\n\n\t/* XXX TODO: If the full mode is 0160200, then this is a Solaris\n\t * ACL description for the following entry.  Read this body\n\t * and parse it as a Solaris-style ACL, then read the next\n\t * header.  XXX */\n\n\t/* Compare name to \"TRAILER!!!\" to test for end-of-archive. */\n\tif (namelength == 11 && strcmp((const char *)h, \"TRAILER!!!\") == 0) {\n\t\t/* TODO: Store file location of start of block. */\n\t\tarchive_clear_error(&a->archive);\n\t\treturn (ARCHIVE_EOF);\n\t}\n\n\t/* Detect and record hardlinks to previously-extracted entries. */\n\tif (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\treturn (r);\n}\n",
        "output": "1",
        "index": 180400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mwifiex_set_mgmt_beacon_data_ies(struct mwifiex_private *priv,\n\t\t\t\t\t    struct cfg80211_beacon_data *data)\n{\n\tstruct mwifiex_ie *beacon_ie = NULL, *pr_ie = NULL, *ar_ie = NULL;\n\tu16 beacon_idx = MWIFIEX_AUTO_IDX_MASK, pr_idx = MWIFIEX_AUTO_IDX_MASK;\n\tu16 ar_idx = MWIFIEX_AUTO_IDX_MASK;\n\tint ret = 0;\n\n\tif (data->beacon_ies && data->beacon_ies_len) {\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->beacon_ies, data->beacon_ies_len,\n\t\t\t\t     &beacon_ie, MGMT_MASK_BEACON,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->proberesp_ies && data->proberesp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP, WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->proberesp_ies,\n\t\t\t\t     data->proberesp_ies_len, &pr_ie,\n\t\t\t\t     MGMT_MASK_PROBE_RESP,\n\t\t\t\t     WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (data->assocresp_ies && data->assocresp_ies_len) {\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP,\n\t\t\t\t     WLAN_OUI_MICROSOFT,\n\t\t\t\t     WLAN_OUI_TYPE_MICROSOFT_WPS);\n\t\tmwifiex_update_vs_ie(data->assocresp_ies,\n\t\t\t\t     data->assocresp_ies_len, &ar_ie,\n\t\t\t\t     MGMT_MASK_ASSOC_RESP |\n\t\t\t\t     MGMT_MASK_REASSOC_RESP, WLAN_OUI_WFA,\n\t\t\t\t     WLAN_OUI_TYPE_WFA_P2P);\n\t}\n\n\tif (beacon_ie || pr_ie || ar_ie) {\n\t\tret = mwifiex_update_uap_custom_ie(priv, beacon_ie,\n\t\t\t\t\t\t   &beacon_idx, pr_ie,\n\t\t\t\t\t\t   &pr_idx, ar_ie, &ar_idx);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tpriv->beacon_idx = beacon_idx;\n\tpriv->proberesp_idx = pr_idx;\n\tpriv->assocresp_idx = ar_idx;\n\ndone:\n\tkfree(beacon_ie);\n\tkfree(pr_ie);\n\tkfree(ar_ie);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 88606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void skel(const char *homedir, uid_t u, gid_t g) {\n\tchar *fname;\n\tif (arg_zsh) {\n\t\tif (asprintf(&fname, \"%s/.zshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.zshrc\", &s) == 0) {\n\t\t\tif (is_link(\"/etc/skel/.zshrc\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid /etc/skel/.zshrc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (copy_file(\"/etc/skel/.zshrc\", fname) == 0) {\n\t\t\t\tif (chown(fname, u, g) == -1)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tfs_logger(\"clone /etc/skel/.zshrc\");\n\t\t\t}\n \t\t}\n\t\telse { // \n\t\t\tFILE *fp = fopen(fname, \"w\");\n\t\t\tif (fp) {\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t\tif (chown(fname, u, g) == -1)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tfs_logger2(\"touch\", fname);\n\t\t\t}\n \t\t}\n \t\tfree(fname);\n \t}\n\telse if (arg_csh) {\n\t\tif (asprintf(&fname, \"%s/.cshrc\", homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tstruct stat s;\n \t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.cshrc\", &s) == 0) {\n\t\t\tif (is_link(\"/etc/skel/.cshrc\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid /etc/skel/.cshrc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (copy_file(\"/etc/skel/.cshrc\", fname) == 0) {\n\t\t\t\tif (chown(fname, u, g) == -1)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tfs_logger(\"clone /etc/skel/.cshrc\");\n\t\t\t}\n \t\t}\n\t\telse { // \n\t\t\t/* coverity[toctou] */\n\t\t\tFILE *fp = fopen(fname, \"w\");\n\t\t\tif (fp) {\n\t\t\t\tfprintf(fp, \"\\n\");\n\t\t\t\tfclose(fp);\n\t\t\t\tif (chown(fname, u, g) == -1)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tif (chmod(fname, S_IRUSR | S_IWUSR) < 0)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tfs_logger2(\"touch\", fname);\n\t\t\t}\n \t\t}\n \t\tfree(fname);\n \t}\n\telse {\n\t\tif (asprintf(&fname, \"%s/.bashrc\", homedir) == -1)\n \t\t\terrExit(\"asprintf\");\n \t\tstruct stat s;\n\t\tif (stat(fname, &s) == 0)\n \t\t\treturn;\n \t\tif (stat(\"/etc/skel/.bashrc\", &s) == 0) {\n\t\t\tif (is_link(\"/etc/skel/.bashrc\")) {\n\t\t\t\tfprintf(stderr, \"Error: invalid /etc/skel/.bashrc file\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (copy_file(\"/etc/skel/.bashrc\", fname) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chown(fname, u, g) == -1)\n\t\t\t\t\terrExit(\"chown\");\n\t\t\t\tfs_logger(\"clone /etc/skel/.bashrc\");\n\t\t\t}\n \t\t}\n \t\tfree(fname);\n \t}\n}\n",
        "output": "1",
        "index": 183270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n   config_rec *c = NULL;\n  const char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c != NULL) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir != NULL) {\n    const char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = pstrdup(p, dir);\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n           path[pathlen-1] = '\\0';\n         }\n \n        pr_fs_clear_cache2(path);\n        res = pr_fsio_lstat(path, &st);\n         if (res < 0) {\n          xerrno = errno;\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n          errno = xerrno;\n          return -1;\n        }\n \n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n           errno = EPERM;\n           return -1;\n         }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      pr_fs_clear_cache2(dir);\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}\n",
        "output": "1",
        "index": 181450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rdpdr_process(STREAM s)\n{\n\tuint32 handle;\n \tuint16 vmin;\n \tuint16 component;\n \tuint16 pakid;\n \n \tlogger(Protocol, Debug, \"rdpdr_process()\");\n \t/* hexdump(s->p, s->end - s->p); */\n\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n \t\t\t\t/* DR_CORE_SERVER_ANNOUNCE_REQ */\n \t\t\t\tin_uint8s(s, 2);\t/* skip versionMajor */\n \t\t\t\tin_uint16_le(s, vmin);\t/* VersionMinor */\n \t\t\t\tin_uint32_le(s, g_client_id);\t/* ClientID */\n \n \t\t\t\t/* The RDP client is responsibility to provide a random client id\n \t\t\t\t   if server version is < 12 */\n \t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t/* IP address (use 127.0.0.1) 0x815ed39d */\n\t\t\t\tg_epoch++;\n\n#if WITH_SCARD\n\t\t\t\t/*\n\t\t\t\t * We need to release all SCARD contexts to end all\n\t\t\t\t * current transactions and pending calls\n\t\t\t\t */\n\t\t\t\tscard_release_all_contexts();\n\n\t\t\t\t/*\n\t\t\t\t * According to [MS-RDPEFS] 3.2.5.1.2:\n\t\t\t\t *\n\t\t\t\t * If this packet appears after a sequence of other packets,\n\t\t\t\t * it is a signal that the server has reconnected to a new session\n\t\t\t\t * and the whole sequence has been reset. The client MUST treat\n\t\t\t\t * this packet as the beginning of a new sequence.\n\t\t\t\t * The client MUST also cancel all outstanding requests and release\n\t\t\t\t * previous references to all devices.\n\t\t\t\t *\n\t\t\t\t * If any problem arises in the future, please, pay attention to the\n\t\t\t\t * \"If this packet appears after a sequence of other packets\" part\n\t\t\t\t *\n\t\t\t\t */\n\n#endif\n\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}\n",
        "output": "1",
        "index": 182977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_bin_load_io_at_offset_as_sz(RBin *bin, int fd, ut64 baseaddr,\n\t\tut64 loadaddr, int xtr_idx, ut64 offset, const char *name, ut64 sz) {\n\tRIOBind *iob = &(bin->iob);\n\tRIO *io = iob? iob->io: NULL;\n\tRListIter *it;\n\tut8 *buf_bytes = NULL;\n\tRBinXtrPlugin *xtr;\n\tut64 file_sz = UT64_MAX;\n\tRBinFile *binfile = NULL;\n\tint tfd = -1;\n\n\tif (!io || (fd < 0) || (st64)sz < 0) {\n\t\treturn false;\n\t}\n\tbool is_debugger = iob->fd_is_dbg (io, fd);\n\tconst char *fname = iob->fd_get_name (io, fd);\n\tif (loadaddr == UT64_MAX) {\n\t\tloadaddr = 0;\n\t}\n\tfile_sz = iob->fd_size (io, fd);\n\tif (is_debugger && file_sz == UT64_MAX) {\n\t\ttfd = iob->fd_open (io, fname, R_IO_READ, 0644);\n\t\tif (tfd >= 1) {\n\t\t\tfile_sz = iob->fd_size (io, tfd);\n\t\t}\n\t}\n\tif (!sz) {\n\t\tsz = file_sz;\n\t}\n\n\tbin->file = fname;\n\tsz = R_MIN (file_sz, sz);\n\tif (!r_list_length (bin->binfiles)) {\n\t\tif (is_debugger) {\n\t\t\tif (tfd >= 0) {\n\t\t\t\tbuf_bytes = calloc (1, sz + 1);\n\t\t\t\tiob->fd_read_at (io, tfd, 0, buf_bytes, sz);\n\t\t\t}\n\t\t}\n\t}\n\tif (!buf_bytes) {\n\t\tbuf_bytes = calloc (1, sz + 1);\n\t\tif (!buf_bytes) {\n\t\t\treturn false;\n\t\t}\n\t\tut64 seekaddr = is_debugger? baseaddr: loadaddr;\n\t\tif (!iob->fd_read_at (io, fd, seekaddr, buf_bytes, sz)) {\n\t\t\tsz = 0LL;\n\t\t}\n\t}\n\n\tif (!name && (st64)sz > 0) {\n\t\tr_list_foreach (bin->binxtrs, it, xtr) {\n\t\t\tif (xtr && xtr->check_bytes (buf_bytes, sz)) {\n\t\t\t\tif (xtr && (xtr->extract_from_bytes || xtr->extractall_from_bytes)) {\n\t\t\t\t\tif (is_debugger && sz != file_sz) {\n\t\t\t\t\t\tR_FREE (buf_bytes);\n\t\t\t\t\t\tif (tfd < 0) {\n\t\t\t\t\t\t\ttfd = iob->fd_open (io, fname, R_IO_READ, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsz = iob->fd_size (io, tfd);\n\t\t\t\t\t\tif (sz != UT64_MAX) {\n\t\t\t\t\t\t\tbuf_bytes = calloc (1, sz + 1);\n\t\t\t\t\t\t\tif (buf_bytes) {\n\t\t\t\t\t\t\t\t(void) iob->fd_read_at (io, tfd, 0, buf_bytes, sz);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttfd = -1;\t// marking it closed\n\t\t\t\t\t} else if (sz != file_sz) {\n\t\t\t\t\t\t(void) iob->read_at (io, 0LL, buf_bytes, sz);\n\t\t\t\t\t}\n\t\t\t\t\tbinfile = r_bin_file_xtr_load_bytes (bin, xtr,\n\t\t\t\t\t\tfname, buf_bytes, sz, file_sz,\n\t\t\t\t\t\tbaseaddr, loadaddr, xtr_idx,\n\t\t\t\t\t\tfd, bin->rawstr);\n\t\t\t\t}\n\t\t\t\txtr = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!binfile) {\n\t\tbool steal_ptr = true; // transfer buf_bytes ownership to binfile\n\t\tbinfile = r_bin_file_new_from_bytes (\n\t\t\tbin, fname, buf_bytes, sz, file_sz, bin->rawstr,\n\t\t\tbaseaddr, loadaddr, fd, name, NULL, offset, steal_ptr);\n\t}\n\treturn binfile? r_bin_file_set_cur_binfile (bin, binfile): false;\n}\n",
        "output": "0",
        "index": 60186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tcp_v6_md5_do_add(struct sock *sk, const struct in6_addr *peer,\n\t\t\t     char *newkey, u8 newkeylen)\n{\n\t/* Add key to the list */\n\tstruct tcp_md5sig_key *key;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp6_md5sig_key *keys;\n\n\tkey = tcp_v6_md5_do_lookup(sk, peer);\n\tif (key) {\n\t\t/* modify existing entry - just update that one */\n\t\tkfree(key->key);\n\t\tkey->key = newkey;\n\t\tkey->keylen = newkeylen;\n\t} else {\n\t\t/* reallocate new list if current one is full. */\n\t\tif (!tp->md5sig_info) {\n\t\t\ttp->md5sig_info = kzalloc(sizeof(*tp->md5sig_info), GFP_ATOMIC);\n\t\t\tif (!tp->md5sig_info) {\n\t\t\t\tkfree(newkey);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsk_nocaps_add(sk, NETIF_F_GSO_MASK);\n\t\t}\n\t\tif (tcp_alloc_md5sig_pool(sk) == NULL) {\n\t\t\tkfree(newkey);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (tp->md5sig_info->alloced6 == tp->md5sig_info->entries6) {\n\t\t\tkeys = kmalloc((sizeof (tp->md5sig_info->keys6[0]) *\n\t\t\t\t       (tp->md5sig_info->entries6 + 1)), GFP_ATOMIC);\n\n\t\t\tif (!keys) {\n\t\t\t\ttcp_free_md5sig_pool();\n\t\t\t\tkfree(newkey);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tif (tp->md5sig_info->entries6)\n\t\t\t\tmemmove(keys, tp->md5sig_info->keys6,\n\t\t\t\t\t(sizeof (tp->md5sig_info->keys6[0]) *\n\t\t\t\t\t tp->md5sig_info->entries6));\n\n\t\t\tkfree(tp->md5sig_info->keys6);\n\t\t\ttp->md5sig_info->keys6 = keys;\n\t\t\ttp->md5sig_info->alloced6++;\n\t\t}\n\n\t\tipv6_addr_copy(&tp->md5sig_info->keys6[tp->md5sig_info->entries6].addr,\n\t\t\t       peer);\n\t\ttp->md5sig_info->keys6[tp->md5sig_info->entries6].base.key = newkey;\n\t\ttp->md5sig_info->keys6[tp->md5sig_info->entries6].base.keylen = newkeylen;\n\n\t\ttp->md5sig_info->entries6++;\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 19139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)\n{\n\tstruct sk_buff **pp = NULL;\n\tstruct packet_offload *ptype;\n\t__be16 type = skb->protocol;\n\tstruct list_head *head = &offload_base;\n\tint same_flow;\n\tenum gro_result ret;\n\tint grow;\n\n\tif (!(skb->dev->features & NETIF_F_GRO))\n\t\tgoto normal;\n\n\tif (skb_is_gso(skb) || skb_has_frag_list(skb) || skb->csum_bad)\n\t\tgoto normal;\n\n\tgro_list_prepare(napi, skb);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, head, list) {\n\t\tif (ptype->type != type || !ptype->callbacks.gro_receive)\n\t\t\tcontinue;\n\n\t\tskb_set_network_header(skb, skb_gro_offset(skb));\n\t\tskb_reset_mac_len(skb);\n \t\tNAPI_GRO_CB(skb)->same_flow = 0;\n \t\tNAPI_GRO_CB(skb)->flush = 0;\n \t\tNAPI_GRO_CB(skb)->free = 0;\n\t\tNAPI_GRO_CB(skb)->udp_mark = 0;\n \t\tNAPI_GRO_CB(skb)->gro_remcsum_start = 0;\n \n \t\t/* Setup for GRO checksum validation */\n\t\tswitch (skb->ip_summed) {\n\t\tcase CHECKSUM_COMPLETE:\n\t\t\tNAPI_GRO_CB(skb)->csum = skb->csum;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 1;\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = 0;\n\t\t\tbreak;\n\t\tcase CHECKSUM_UNNECESSARY:\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = skb->csum_level + 1;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = 0;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 0;\n\t\t}\n\n\t\tpp = ptype->callbacks.gro_receive(&napi->gro_list, skb);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (&ptype->list == head)\n\t\tgoto normal;\n\n\tsame_flow = NAPI_GRO_CB(skb)->same_flow;\n\tret = NAPI_GRO_CB(skb)->free ? GRO_MERGED_FREE : GRO_MERGED;\n\n\tif (pp) {\n\t\tstruct sk_buff *nskb = *pp;\n\n\t\t*pp = nskb->next;\n\t\tnskb->next = NULL;\n\t\tnapi_gro_complete(nskb);\n\t\tnapi->gro_count--;\n\t}\n\n\tif (same_flow)\n\t\tgoto ok;\n\n\tif (NAPI_GRO_CB(skb)->flush)\n\t\tgoto normal;\n\n\tif (unlikely(napi->gro_count >= MAX_GRO_SKBS)) {\n\t\tstruct sk_buff *nskb = napi->gro_list;\n\n\t\t/* locate the end of the list to select the 'oldest' flow */\n\t\twhile (nskb->next) {\n\t\t\tpp = &nskb->next;\n\t\t\tnskb = *pp;\n\t\t}\n\t\t*pp = NULL;\n\t\tnskb->next = NULL;\n\t\tnapi_gro_complete(nskb);\n\t} else {\n\t\tnapi->gro_count++;\n\t}\n\tNAPI_GRO_CB(skb)->count = 1;\n\tNAPI_GRO_CB(skb)->age = jiffies;\n\tNAPI_GRO_CB(skb)->last = skb;\n\tskb_shinfo(skb)->gso_size = skb_gro_len(skb);\n\tskb->next = napi->gro_list;\n\tnapi->gro_list = skb;\n\tret = GRO_HELD;\n\npull:\n\tgrow = skb_gro_offset(skb) - skb_headlen(skb);\n\tif (grow > 0)\n\t\tgro_pull_from_frag0(skb, grow);\nok:\n\treturn ret;\n\nnormal:\n\tret = GRO_NORMAL;\n\tgoto pull;\n}\n",
        "output": "1",
        "index": 180077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _rpc_prolog(slurm_msg_t *msg)\n{\n\tint rc = SLURM_SUCCESS;\n\tprolog_launch_msg_t *req = (prolog_launch_msg_t *)msg->data;\n\tjob_env_t job_env;\n\tbool     first_job_run;\n\tuid_t    req_uid;\n\n\tif (req == NULL)\n\t\treturn;\n\n\treq_uid = g_slurm_auth_get_uid(msg->auth_cred, conf->auth_info);\n\tif (!_slurm_authorized_user(req_uid)) {\n\t\terror(\"REQUEST_LAUNCH_PROLOG request from uid %u\",\n\t\t      (unsigned int) req_uid);\n\t\treturn;\n\t}\n\n\tif (slurm_send_rc_msg(msg, rc) < 0) {\n\t\terror(\"Error starting prolog: %m\");\n\t}\n\tif (rc) {\n\t\tint term_sig, exit_status;\n\t\tif (WIFSIGNALED(rc)) {\n\t\t\texit_status = 0;\n\t\t\tterm_sig    = WTERMSIG(rc);\n\t\t} else {\n\t\t\texit_status = WEXITSTATUS(rc);\n\t\t\tterm_sig    = 0;\n\t\t}\n\t\terror(\"[job %u] prolog start failed status=%d:%d\",\n\t\t      req->job_id, exit_status, term_sig);\n\t\trc = ESLURMD_PROLOG_FAILED;\n\t}\n\n\tslurm_mutex_lock(&prolog_mutex);\n\tfirst_job_run = !slurm_cred_jobid_cached(conf->vctx, req->job_id);\n\tif (first_job_run) {\n\t\tif (slurmctld_conf.prolog_flags & PROLOG_FLAG_CONTAIN)\n\t\t\t_make_prolog_mem_container(msg);\n\n\t\tif (container_g_create(req->job_id))\n\t\t\terror(\"container_g_create(%u): %m\", req->job_id);\n\n\t\tslurm_cred_insert_jobid(conf->vctx, req->job_id);\n\t\t_add_job_running_prolog(req->job_id);\n\t\tslurm_mutex_unlock(&prolog_mutex);\n\n\t\tmemset(&job_env, 0, sizeof(job_env_t));\n\n\t\tjob_env.jobid = req->job_id;\n\t\tjob_env.step_id = 0;\t/* not available */\n\t\tjob_env.node_list = req->nodes;\n\t\tjob_env.partition = req->partition;\n\t\tjob_env.spank_job_env = req->spank_job_env;\n\t\tjob_env.spank_job_env_size = req->spank_job_env_size;\n\t\tjob_env.uid = req->uid;\n\t\tjob_env.user_name = req->user_name;\n#if defined(HAVE_BG)\n\t\tselect_g_select_jobinfo_get(req->select_jobinfo,\n\t\t\t\t\t    SELECT_JOBDATA_BLOCK_ID,\n\t\t\t\t\t    &job_env.resv_id);\n#elif defined(HAVE_ALPS_CRAY)\n\t\tjob_env.resv_id = select_g_select_jobinfo_xstrdup(\n\t\t\treq->select_jobinfo, SELECT_PRINT_RESV_ID);\n#endif\n\t\trc = _run_prolog(&job_env, req->cred);\n\n\t\tif (rc) {\n\t\t\tint term_sig, exit_status;\n\t\t\tif (WIFSIGNALED(rc)) {\n\t\t\t\texit_status = 0;\n\t\t\t\tterm_sig    = WTERMSIG(rc);\n\t\t\t} else {\n\t\t\t\texit_status = WEXITSTATUS(rc);\n\t\t\t\tterm_sig    = 0;\n\t\t\t}\n\t\t\terror(\"[job %u] prolog failed status=%d:%d\",\n\t\t\t      req->job_id, exit_status, term_sig);\n\t\t\trc = ESLURMD_PROLOG_FAILED;\n\t\t}\n\t} else\n\t\tslurm_mutex_unlock(&prolog_mutex);\n\n\tif (!(slurmctld_conf.prolog_flags & PROLOG_FLAG_NOHOLD))\n\t\t_notify_slurmctld_prolog_fini(req->job_id, rc);\n\n\tif (rc == SLURM_SUCCESS) {\n\t\tif (slurmctld_conf.prolog_flags & PROLOG_FLAG_CONTAIN)\n\t\t\t_spawn_prolog_stepd(msg);\n\t} else {\n\t\t_launch_job_fail(req->job_id, rc);\n\t\t/*\n\t\t *  If job prolog failed or we could not reply,\n\t\t *  initiate message to slurmctld with current state\n\t\t */\n\t\tif ((rc == ESLURMD_PROLOG_FAILED) ||\n\t\t    (rc == SLURM_COMMUNICATIONS_SEND_ERROR) ||\n\t\t    (rc == ESLURMD_SETUP_ENVIRONMENT_ERROR))\n\t\t\tsend_registration_msg(rc, false);\n\t}\n}\n",
        "output": "0",
        "index": 72122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_krb5_parse_moduli(krb5_context context, const char *file,\n\t\t   struct krb5_dh_moduli ***moduli)\n{\n    /* name bits P G Q */\n    krb5_error_code ret;\n    struct krb5_dh_moduli **m = NULL, **m2;\n    char buf[4096];\n    FILE *f;\n    int lineno = 0, n = 0;\n\n    *moduli = NULL;\n\n    m = calloc(1, sizeof(m[0]) * 3);\n    if (m == NULL)\n\treturn krb5_enomem(context);\n\n    strlcpy(buf, default_moduli_rfc3526_MODP_group14, sizeof(buf));\n    ret = _krb5_parse_moduli_line(context, \"builtin\", 1, buf,  &m[0]);\n    if (ret) {\n\t_krb5_free_moduli(m);\n\treturn ret;\n    }\n    n++;\n\n    strlcpy(buf, default_moduli_RFC2412_MODP_group2, sizeof(buf));\n    ret = _krb5_parse_moduli_line(context, \"builtin\", 1, buf,  &m[1]);\n    if (ret) {\n\t_krb5_free_moduli(m);\n\treturn ret;\n    }\n    n++;\n\n\n    if (file == NULL)\n\tfile = MODULI_FILE;\n\n#ifdef KRB5_USE_PATH_TOKENS\n    {\n        char * exp_file;\n\n\tif (_krb5_expand_path_tokens(context, file, 1, &exp_file) == 0) {\n            f = fopen(exp_file, \"r\");\n            krb5_xfree(exp_file);\n        } else {\n            f = NULL;\n        }\n    }\n#else\n    f = fopen(file, \"r\");\n#endif\n\n    if (f == NULL) {\n\t*moduli = m;\n\treturn 0;\n    }\n    rk_cloexec_file(f);\n\n    while(fgets(buf, sizeof(buf), f) != NULL) {\n\tstruct krb5_dh_moduli *element;\n\n\tbuf[strcspn(buf, \"\\n\")] = '\\0';\n\tlineno++;\n\n\tm2 = realloc(m, (n + 2) * sizeof(m[0]));\n\tif (m2 == NULL) {\n\t    _krb5_free_moduli(m);\n\t    return krb5_enomem(context);\n\t}\n\tm = m2;\n\n\tm[n] = NULL;\n\n\tret = _krb5_parse_moduli_line(context, file, lineno, buf,  &element);\n\tif (ret) {\n\t    _krb5_free_moduli(m);\n\t    return ret;\n\t}\n\tif (element == NULL)\n\t    continue;\n\n\tm[n] = element;\n\tm[n + 1] = NULL;\n\tn++;\n    }\n    *moduli = m;\n    return 0;\n}\n",
        "output": "0",
        "index": 89950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmx_handle_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\ttrace_kvm_exit(exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.\n\t */\n\tif (enable_pml)\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu) && nested_vmx_exit_reflected(vcpu, exit_reason))\n\t\treturn nested_vmx_reflect_vmexit(vcpu, exit_reason);\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_PML_FULL &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.ndata++;\n\t\t\tvcpu->run->internal.data[3] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (exit_reason < kvm_vmx_max_exit_handlers\n\t    && kvm_vmx_exit_handlers[exit_reason])\n\t\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\telse {\n\t\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\",\n\t\t\t\texit_reason);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n}\n",
        "output": "0",
        "index": 63043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool  Type_LUTB2A_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    int inputChan, outputChan;\n    cmsStage *A = NULL, *B = NULL, *M = NULL;\n    cmsStage *Matrix = NULL;\n    cmsStage *CLUT = NULL;\n    cmsUInt32Number offsetB = 0, offsetMat = 0, offsetM = 0, offsetC = 0, offsetA = 0;\n    cmsUInt32Number BaseOffset, DirectoryPos, CurrentPos;\n\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    if (!cmsPipelineCheckAndRetreiveStages(Lut, 1, cmsSigCurveSetElemType, &B))\n        if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType, &B, &Matrix, &M))\n            if (!cmsPipelineCheckAndRetreiveStages(Lut, 3, cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &CLUT, &A))\n                if (!cmsPipelineCheckAndRetreiveStages(Lut, 5, cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType,\n                    cmsSigCLutElemType, cmsSigCurveSetElemType, &B, &Matrix, &M, &CLUT, &A)) {\n                        cmsSignalError(self->ContextID, cmsERROR_NOT_SUITABLE, \"LUT is not suitable to be saved as LutBToA\");\n                        return FALSE;\n                }\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) inputChan)) return FALSE;\n    if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) outputChan)) return FALSE;\n    if (!_cmsWriteUInt16Number(io, 0)) return FALSE;\n\n    DirectoryPos = io ->Tell(io);\n\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n\n    if (A != NULL) {\n\n        offsetA = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, A)) return FALSE;\n    }\n\n    if (CLUT != NULL) {\n        offsetC = io ->Tell(io) - BaseOffset;\n        if (!WriteCLUT(self, io, Lut ->SaveAs8Bits ? 1 : 2, CLUT)) return FALSE;\n\n    }\n    if (M != NULL) {\n\n        offsetM = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, M)) return FALSE;\n    }\n\n    if (Matrix != NULL) {\n        offsetMat = io ->Tell(io) - BaseOffset;\n        if (!WriteMatrix(self, io, Matrix)) return FALSE;\n    }\n\n    if (B != NULL) {\n\n        offsetB = io ->Tell(io) - BaseOffset;\n        if (!WriteSetOfCurves(self, io, cmsSigParametricCurveType, B)) return FALSE;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) return FALSE;\n\n    if (!_cmsWriteUInt32Number(io, offsetB)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetMat)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetM)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetC)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, offsetA)) return FALSE;\n\n    if (!io ->Seek(io, CurrentPos)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n",
        "output": "0",
        "index": 71010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WindowTreeHostManager::UpdateMouseLocationAfterDisplayChange() {\n\n  gfx::Point point_in_screen =\n      display::Screen::GetScreen()->GetCursorScreenPoint();\n  gfx::Point target_location_in_native;\n  int64_t closest_distance_squared = -1;\n  DisplayManager* display_manager = GetDisplayManager();\n\n  aura::Window* dst_root_window = nullptr;\n  for (size_t i = 0; i < display_manager->GetNumDisplays(); ++i) {\n    const display::Display& display = display_manager->GetDisplayAt(i);\n    const DisplayInfo display_info =\n        display_manager->GetDisplayInfo(display.id());\n    aura::Window* root_window = GetRootWindowForDisplayId(display.id());\n    if (display_info.bounds_in_native().Contains(\n            cursor_location_in_native_coords_for_restore_)) {\n      dst_root_window = root_window;\n      target_location_in_native = cursor_location_in_native_coords_for_restore_;\n      break;\n    }\n    gfx::Point center = display.bounds().CenterPoint();\n\n    int64_t distance_squared = (center - point_in_screen).LengthSquared();\n    if (closest_distance_squared < 0 ||\n        closest_distance_squared > distance_squared) {\n      aura::Window* root_window = GetRootWindowForDisplayId(display.id());\n      ::wm::ConvertPointFromScreen(root_window, &center);\n      root_window->GetHost()->ConvertPointToNativeScreen(&center);\n      dst_root_window = root_window;\n      target_location_in_native = center;\n      closest_distance_squared = distance_squared;\n    }\n  }\n\n  gfx::Point target_location_in_root = target_location_in_native;\n  dst_root_window->GetHost()->ConvertPointFromNativeScreen(\n      &target_location_in_root);\n\n#if defined(USE_OZONE)\n  gfx::Point target_location_in_screen = target_location_in_root;\n  ::wm::ConvertPointToScreen(dst_root_window, &target_location_in_screen);\n  const display::Display& target_display =\n      display_manager->FindDisplayContainingPoint(target_location_in_screen);\n  if (!target_display.is_valid())\n    return;\n  int64_t target_display_id = target_display.id();\n\n  if (target_location_in_native !=\n          cursor_location_in_native_coords_for_restore_ ||\n      target_display_id != cursor_display_id_for_restore_) {\n    dst_root_window->MoveCursorTo(target_location_in_root);\n  } else if (target_location_in_screen !=\n             cursor_location_in_screen_coords_for_restore_) {\n    Shell::GetInstance()->cursor_manager()->SetDisplay(target_display);\n\n    dst_root_window->GetHost()->dispatcher()->OnCursorMovedToRootLocation(\n        target_location_in_root);\n  }\n#else\n  dst_root_window->MoveCursorTo(target_location_in_root);\n#endif\n}\n",
        "output": "0",
        "index": 133379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n                                                       String scriptClassName,\n                                                       const char* source,\n                                                       size_t size) {\n  v8::Isolate* isolate = scriptState->isolate();\n  v8::TryCatch block(isolate);\n  String sourceString(source, size);\n  String fileName = scriptClassName + \".js\";\n \n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n  v8::Local<v8::Value> privateScriptController =\n      global->Get(context, v8String(isolate, \"privateScriptController\"))\n          .ToLocalChecked();\n  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n                 privateScriptController->IsObject());\n  if (privateScriptController->IsObject()) {\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =\n        privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))\n            .ToLocalChecked();\n    if (importFunctionValue->IsUndefined()) {\n      v8::Local<v8::Function> function;\n      if (!v8::FunctionTemplate::New(isolate, importFunction)\n               ->GetFunction(context)\n               .ToLocal(&function) ||\n          !v8CallBoolean(privateScriptControllerObject->Set(\n              context, v8String(isolate, \"import\"), function))) {\n        dumpV8Message(context, block.Message());\n        LOG(FATAL)\n            << \"Private script error: Setting import function failed. (Class \"\n               \"name = \"\n            << scriptClassName.utf8().data() << \")\";\n      }\n    }\n  }\n\n  v8::Local<v8::Script> script;\n  if (!v8Call(V8ScriptRunner::compileScript(\n                  v8String(isolate, sourceString), fileName, String(),\n                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,\n                  nullptr, NotSharableCrossOrigin),\n              script, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n\n  v8::Local<v8::Value> result;\n  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),\n              result, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  return result;\n}\n",
        "output": "1",
        "index": 186418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n\tint status = 1;\n\tuint32 imagew = TIFFRasterScanlineSize(in);\n\tuint32 tilew = TIFFTileRowSize(in);\n\tint iskew  = imagew - tilew*spp;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\tuint16 bps = 0, bytes_per_sample;\n\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps == 0 )\n        {\n            TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\");\n            status = 0;\n            goto done;\n        }\n\tassert( bps % 8 == 0 );\n\tbytes_per_sample = bps/8;\n\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\ttsample_t s;\n\n\t\t\tfor (s = 0; s < spp; s++) {\n\t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0\n\t\t\t\t    && !ignore) {\n\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t    \"Error, can't read tile at %lu %lu, \"\n\t\t\t\t\t    \"sample %lu\",\n\t\t\t\t\t    (unsigned long) col,\n\t\t\t\t\t    (unsigned long) row,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t\t * visible portion and skewing factors.\n\t\t\t\t */\n\t\t\t\tif (colb + tilew*spp > imagew) {\n\t\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\t\tint oskew = tilew*spp - width;\n\t\t\t\t\tcpSeparateBufToContigBuf(\n\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\n\t\t\t\t\t    tilebuf, nrow,\n\t\t\t\t\t    width/(spp*bytes_per_sample),\n\t\t\t\t\t    oskew + iskew,\n\t\t\t\t\t    oskew/spp, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\t} else\n\t\t\t\t\tcpSeparateBufToContigBuf(\n\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\n\t\t\t\t\t    tilebuf, nrow, tw,\n\t\t\t\t\t    iskew, 0, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t}\n\t\t\tcolb += tilew*spp;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}\n",
        "output": "0",
        "index": 71384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutUnit RenderBox::computePercentageLogicalHeight(const Length& height) const\n{\n    LayoutUnit availableHeight = -1;\n\n    bool skippedAutoHeightContainingBlock = false;\n    RenderBlock* cb = containingBlock();\n    const RenderBox* containingBlockChild = this;\n    LayoutUnit rootMarginBorderPaddingHeight = 0;\n    while (!cb->isRenderView() && skipContainingBlockForPercentHeightCalculation(cb)) {\n        if (cb->isBody() || cb->isDocumentElement())\n            rootMarginBorderPaddingHeight += cb->marginBefore() + cb->marginAfter() + cb->borderAndPaddingLogicalHeight();\n        skippedAutoHeightContainingBlock = true;\n        containingBlockChild = cb;\n        cb = cb->containingBlock();\n    }\n    cb->addPercentHeightDescendant(const_cast<RenderBox*>(this));\n\n    RenderStyle* cbstyle = cb->style();\n\n    bool isOutOfFlowPositionedWithSpecifiedHeight = cb->isOutOfFlowPositioned() && (!cbstyle->logicalHeight().isAuto() || (!cbstyle->logicalTop().isAuto() && !cbstyle->logicalBottom().isAuto()));\n\n    bool includeBorderPadding = isTable();\n\n    if (isHorizontalWritingMode() != cb->isHorizontalWritingMode())\n        availableHeight = containingBlockChild->containingBlockLogicalWidthForContent();\n    else if (hasOverrideContainingBlockLogicalHeight())\n        availableHeight = overrideContainingBlockContentLogicalHeight();\n    else if (cb->isTableCell()) {\n        if (!skippedAutoHeightContainingBlock) {\n            if (!cb->hasOverrideHeight()) {\n                RenderTableCell* cell = toRenderTableCell(cb);\n                if (scrollsOverflowY() && (!cell->style()->logicalHeight().isAuto() || !cell->table()->style()->logicalHeight().isAuto()))\n                    return 0;\n                return -1;\n            }\n            availableHeight = cb->overrideLogicalContentHeight();\n            includeBorderPadding = true;\n        }\n    } else if (cbstyle->logicalHeight().isFixed()) {\n        LayoutUnit contentBoxHeight = cb->adjustContentBoxLogicalHeightForBoxSizing(cbstyle->logicalHeight().value());\n        availableHeight = max<LayoutUnit>(0, cb->constrainContentBoxLogicalHeightByMinMax(contentBoxHeight - cb->scrollbarLogicalHeight(), -1));\n    } else if (cbstyle->logicalHeight().isPercent() && !isOutOfFlowPositionedWithSpecifiedHeight) {\n        LayoutUnit heightWithScrollbar = cb->computePercentageLogicalHeight(cbstyle->logicalHeight());\n        if (heightWithScrollbar != -1) {\n            LayoutUnit contentBoxHeightWithScrollbar = cb->adjustContentBoxLogicalHeightForBoxSizing(heightWithScrollbar);\n            LayoutUnit contentBoxHeight = cb->constrainContentBoxLogicalHeightByMinMax(contentBoxHeightWithScrollbar - cb->scrollbarLogicalHeight(), -1);\n            availableHeight = max<LayoutUnit>(0, contentBoxHeight);\n        }\n    } else if (isOutOfFlowPositionedWithSpecifiedHeight) {\n        LogicalExtentComputedValues computedValues;\n        cb->computeLogicalHeight(cb->logicalHeight(), 0, computedValues);\n        availableHeight = computedValues.m_extent - cb->borderAndPaddingLogicalHeight() - cb->scrollbarLogicalHeight();\n    } else if (cb->isRenderView())\n        availableHeight = viewLogicalHeightForPercentages();\n\n    if (availableHeight == -1)\n        return availableHeight;\n\n    availableHeight -= rootMarginBorderPaddingHeight;\n\n    LayoutUnit result = valueForLength(height, availableHeight);\n    if (includeBorderPadding) {\n        result -= borderAndPaddingLogicalHeight();\n        return max<LayoutUnit>(0, result);\n    }\n    return result;\n}\n",
        "output": "0",
        "index": 124840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size + 8 <= atom.size && !url_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0)\n                return err;\n            if (c->found_moov && c->found_mdat &&\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n                    c->next_root_atom = start_pos + a.size;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    return 0;\n}\n",
        "output": "0",
        "index": 54515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static time_t asn1_time_to_time_t(ASN1_UTCTIME * timestr TSRMLS_DC) /* {{{ */\n{\n/*\n\tThis is how the time string is formatted:\n\n   snprintf(p, sizeof(p), \"%02d%02d%02d%02d%02d%02dZ\",ts->tm_year%100,\n      ts->tm_mon+1,ts->tm_mday,ts->tm_hour,ts->tm_min,ts->tm_sec);\n*/\n\n\ttime_t ret;\n\tstruct tm thetime;\n\tchar * strbuf;\n\tchar * thestr;\n\tlong gmadjust = 0;\n\n\tif (timestr->length < 13) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"extension author too lazy to parse %s correctly\", timestr->data);\n\t\treturn (time_t)-1;\n\t}\n\n\tstrbuf = estrdup((char *)timestr->data);\n\n\tmemset(&thetime, 0, sizeof(thetime));\n\n\t/* we work backwards so that we can use atoi more easily */\n\n\tthestr = strbuf + timestr->length - 3;\n\n\tthetime.tm_sec = atoi(thestr);\n\t*thestr = '\\0';\n\tthestr -= 2;\n\tthetime.tm_min = atoi(thestr);\n\t*thestr = '\\0';\n\tthestr -= 2;\n\tthetime.tm_hour = atoi(thestr);\n\t*thestr = '\\0';\n\tthestr -= 2;\n\tthetime.tm_mday = atoi(thestr);\n\t*thestr = '\\0';\n\tthestr -= 2;\n\tthetime.tm_mon = atoi(thestr)-1;\n\t*thestr = '\\0';\n\tthestr -= 2;\n\tthetime.tm_year = atoi(thestr);\n\n\tif (thetime.tm_year < 68) {\n\t\tthetime.tm_year += 100;\n\t}\n\n\tthetime.tm_isdst = -1;\n\tret = mktime(&thetime);\n\n#if HAVE_TM_GMTOFF\n\tgmadjust = thetime.tm_gmtoff;\n#else\n\t/*\n\t** If correcting for daylight savings time, we set the adjustment to\n\t** the value of timezone - 3600 seconds. Otherwise, we need to overcorrect and\n\t** set the adjustment to the main timezone + 3600 seconds.\n\t*/\n\tgmadjust = -(thetime.tm_isdst ? (long)timezone - 3600 : (long)timezone + 3600);\n#endif\n\tret += gmadjust;\n\n\tefree(strbuf);\n\n\treturn ret;\n}\n/* }}} */\n",
        "output": "0",
        "index": 2022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int apply_filter_to_req_line(struct stream *s, struct channel *req, struct hdr_exp *exp)\n{\n\tchar *cur_ptr, *cur_end;\n\tint done;\n\tstruct http_txn *txn = s->txn;\n\tint delta;\n\n\tif (unlikely(txn->flags & (TX_CLDENY | TX_CLTARPIT)))\n\t\treturn 1;\n\telse if (unlikely(txn->flags & TX_CLALLOW) &&\n\t\t (exp->action == ACT_ALLOW ||\n\t\t  exp->action == ACT_DENY ||\n\t\t  exp->action == ACT_TARPIT))\n\t\treturn 0;\n\telse if (exp->action == ACT_REMOVE)\n\t\treturn 0;\n\n\tdone = 0;\n\n\tcur_ptr = req->buf->p;\n\tcur_end = cur_ptr + txn->req.sl.rq.l;\n\n\t/* Now we have the request line between cur_ptr and cur_end */\n\n\tif (regex_exec_match2(exp->preg, cur_ptr, cur_end-cur_ptr, MAX_MATCH, pmatch, 0)) {\n\t\tswitch (exp->action) {\n\t\tcase ACT_ALLOW:\n\t\t\ttxn->flags |= TX_CLALLOW;\n\t\t\tdone = 1;\n\t\t\tbreak;\n\n\t\tcase ACT_DENY:\n\t\t\ttxn->flags |= TX_CLDENY;\n\t\t\tdone = 1;\n\t\t\tbreak;\n\n\t\tcase ACT_TARPIT:\n\t\t\ttxn->flags |= TX_CLTARPIT;\n\t\t\tdone = 1;\n\t\t\tbreak;\n\n\t\tcase ACT_REPLACE:\n\t\t\ttrash.len = exp_replace(trash.str, trash.size, cur_ptr, exp->replace, pmatch);\n\t\t\tif (trash.len < 0)\n\t\t\t\treturn -1;\n\n\t\t\tdelta = buffer_replace2(req->buf, cur_ptr, cur_end, trash.str, trash.len);\n\t\t\t/* FIXME: if the user adds a newline in the replacement, the\n\t\t\t * index will not be recalculated for now, and the new line\n\t\t\t * will not be counted as a new header.\n\t\t\t */\n\n\t\t\thttp_msg_move_end(&txn->req, delta);\n\t\t\tcur_end += delta;\n\t\t\tcur_end = (char *)http_parse_reqline(&txn->req,\n\t\t\t\t\t\t\t     HTTP_MSG_RQMETH,\n\t\t\t\t\t\t\t     cur_ptr, cur_end + 1,\n\t\t\t\t\t\t\t     NULL, NULL);\n\t\t\tif (unlikely(!cur_end))\n\t\t\t\treturn -1;\n\n\t\t\t/* we have a full request and we know that we have either a CR\n\t\t\t * or an LF at <ptr>.\n\t\t\t */\n\t\t\ttxn->meth = find_http_meth(cur_ptr, txn->req.sl.rq.m_l);\n\t\t\thdr_idx_set_start(&txn->hdr_idx, txn->req.sl.rq.l, *cur_end == '\\r');\n\t\t\t/* there is no point trying this regex on headers */\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn done;\n}\n",
        "output": "0",
        "index": 6785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_rename(struct fuse* fuse, struct fuse_handler* handler,\n const struct fuse_in_header* hdr, const struct fuse_rename_in* req,\n const char* old_name, const char* new_name)\n{\n struct node* old_parent_node;\n struct node* new_parent_node;\n struct node* child_node;\n char old_parent_path[PATH_MAX];\n char new_parent_path[PATH_MAX];\n char old_child_path[PATH_MAX];\n char new_child_path[PATH_MAX];\n const char* new_actual_name;\n int res;\n\n    pthread_mutex_lock(&fuse->global->lock);\n    old_parent_node = lookup_node_and_path_by_id_locked(fuse, hdr->nodeid,\n            old_parent_path, sizeof(old_parent_path));\n    new_parent_node = lookup_node_and_path_by_id_locked(fuse, req->newdir,\n            new_parent_path, sizeof(new_parent_path));\n    TRACE(\"[%d] RENAME %s->%s @ %\"PRIx64\" (%s) -> %\"PRIx64\" (%s)\\n\", handler->token,\n            old_name, new_name,\n            hdr->nodeid, old_parent_node ? old_parent_node->name : \"?\",\n            req->newdir, new_parent_node ? new_parent_node->name : \"?\");\n if (!old_parent_node || !new_parent_node) {\n        res = -ENOENT;\n goto lookup_error;\n }\n if (!check_caller_access_to_name(fuse, hdr, old_parent_node, old_name, W_OK)) {\n        res = -EACCES;\n goto lookup_error;\n }\n if (!check_caller_access_to_name(fuse, hdr, new_parent_node, new_name, W_OK)) {\n        res = -EACCES;\n goto lookup_error;\n }\n    child_node = lookup_child_by_name_locked(old_parent_node, old_name);\n if (!child_node || get_node_path_locked(child_node,\n            old_child_path, sizeof(old_child_path)) < 0) {\n        res = -ENOENT;\n goto lookup_error;\n }\n    acquire_node_locked(child_node);\n    pthread_mutex_unlock(&fuse->global->lock);\n\n /* Special case for renaming a file where destination is same path\n     * differing only by case.  In this case we don't want to look for a case\n     * insensitive match.  This allows commands like \"mv foo FOO\" to work as expected.\n     */\n int search = old_parent_node != new_parent_node\n || strcasecmp(old_name, new_name);\n if (!(new_actual_name = find_file_within(new_parent_path, new_name,\n            new_child_path, sizeof(new_child_path), search))) {\n        res = -ENOENT;\n goto io_error;\n }\n\n    TRACE(\"[%d] RENAME %s->%s\\n\", handler->token, old_child_path, new_child_path);\n    res = rename(old_child_path, new_child_path);\n if (res < 0) {\n        res = -errno;\n goto io_error;\n }\n\n    pthread_mutex_lock(&fuse->global->lock);\n    res = rename_node_locked(child_node, new_name, new_actual_name);\n if (!res) {\n        remove_node_from_parent_locked(child_node);\n        derive_permissions_locked(fuse, new_parent_node, child_node);\n        derive_permissions_recursive_locked(fuse, child_node);\n        add_node_to_parent_locked(child_node, new_parent_node);\n }\n goto done;\n\nio_error:\n    pthread_mutex_lock(&fuse->global->lock);\ndone:\n    release_node_locked(child_node);\nlookup_error:\n    pthread_mutex_unlock(&fuse->global->lock);\n return res;\n}\n",
        "output": "0",
        "index": 173751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent-1);\n  \n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickString(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}\n",
        "output": "0",
        "index": 59735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void CreateEntry(const AddEntriesMessage::TestEntryInfo& entry) {\n    const base::FilePath path =\n        base::FilePath::FromUTF8Unsafe(entry.target_path);\n    const std::string target_name = path.BaseName().AsUTF8Unsafe();\n\n    drive::FileError error = drive::FILE_ERROR_OK;\n    std::unique_ptr<drive::ResourceEntry> parent_entry(\n        new drive::ResourceEntry);\n\n    if (!entry.team_drive_name.empty()) {\n      integration_service_->file_system()->GetResourceEntry(\n          drive::util::GetDriveTeamDrivesRootPath()\n              .Append(entry.team_drive_name)\n              .Append(path)\n              .DirName(),\n          google_apis::test_util::CreateCopyResultCallback(&error,\n                                                           &parent_entry));\n    } else {\n      integration_service_->file_system()->GetResourceEntry(\n          drive::util::GetDriveMyDriveRootPath().Append(path).DirName(),\n          google_apis::test_util::CreateCopyResultCallback(&error,\n                                                           &parent_entry));\n    }\n    content::RunAllTasksUntilIdle();\n    ASSERT_EQ(drive::FILE_ERROR_OK, error);\n    ASSERT_TRUE(parent_entry);\n\n    google_apis::FileResourceCapabilities file_capabilities;\n    file_capabilities.set_can_copy(entry.capabilities.can_copy);\n    file_capabilities.set_can_delete(entry.capabilities.can_delete);\n    file_capabilities.set_can_rename(entry.capabilities.can_rename);\n    file_capabilities.set_can_add_children(entry.capabilities.can_add_children);\n    file_capabilities.set_can_share(entry.capabilities.can_share);\n\n    google_apis::TeamDriveCapabilities team_drive_capabilities;\n    team_drive_capabilities.set_can_copy(entry.capabilities.can_copy);\n    team_drive_capabilities.set_can_delete_team_drive(\n        entry.capabilities.can_delete);\n    team_drive_capabilities.set_can_rename_team_drive(\n        entry.capabilities.can_rename);\n    team_drive_capabilities.set_can_add_children(\n        entry.capabilities.can_add_children);\n    team_drive_capabilities.set_can_share(entry.capabilities.can_share);\n\n    switch (entry.type) {\n      case AddEntriesMessage::FILE:\n        CreateFile(entry.source_file_name, parent_entry->resource_id(),\n                   target_name, entry.mime_type,\n                   entry.shared_option == AddEntriesMessage::SHARED ||\n                       entry.shared_option == AddEntriesMessage::SHARED_WITH_ME,\n                   entry.last_modified_time, file_capabilities);\n        break;\n      case AddEntriesMessage::DIRECTORY:\n        CreateDirectory(\n            parent_entry->resource_id(), target_name, entry.last_modified_time,\n            entry.shared_option == AddEntriesMessage::SHARED ||\n                entry.shared_option == AddEntriesMessage::SHARED_WITH_ME,\n            file_capabilities);\n        break;\n      case AddEntriesMessage::TEAM_DRIVE:\n        CreateTeamDrive(entry.team_drive_name, team_drive_capabilities);\n        break;\n      case AddEntriesMessage::COMPUTER:\n        NOTREACHED() << \"Can't create a computer in a drive test volume: \"\n                     << entry.computer_name;\n    }\n\n    CheckForUpdates();\n    content::RunAllTasksUntilIdle();\n  }\n",
        "output": "0",
        "index": 142150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_auxv_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz __attribute__((__unused__)),\n    uint32_t descsz __attribute__((__unused__)),\n    size_t noff __attribute__((__unused__)), size_t doff,\n    int *flags, size_t size __attribute__((__unused__)), int clazz,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n#ifdef ELFCORE\n\tAux32Info auxv32;\n\tAux64Info auxv64;\n\tsize_t elsize = xauxv_sizeof;\n\tconst char *tag;\n\tint is_string;\n\tsize_t nval;\n\n\tif ((*flags & (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE)) !=\n\t    (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE))\n\t\treturn 0;\n\n\tswitch (*flags & FLAGS_CORE_STYLE) {\n\tcase OS_STYLE_SVR4:\n\t\tif (type != NT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#ifdef notyet\n\tcase OS_STYLE_NETBSD:\n\t\tif (type != NT_NETBSD_CORE_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase OS_STYLE_FREEBSD:\n\t\tif (type != NT_FREEBSD_PROCSTAT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t*flags |= FLAGS_DID_AUXV;\n\n\tnval = 0;\n\tfor (size_t off = 0; off + elsize <= descsz; off += elsize) {\n\t\tmemcpy(xauxv_addr, &nbuf[doff + off], xauxv_sizeof);\n\t\t/* Limit processing to 50 vector entries to prevent DoS */\n\t\tif (nval++ >= 50) {\n\t\t\tfile_error(ms, 0, \"Too many ELF Auxv elements\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tswitch(xauxv_type) {\n\t\tcase AT_LINUX_EXECFN:\n\t\t\tis_string = 1;\n\t\t\ttag = \"execfn\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_PLATFORM:\n\t\t\tis_string = 1;\n\t\t\ttag = \"platform\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_UID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_GID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real gid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EUID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EGID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective gid\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tis_string = 0;\n\t\t\ttag = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tag == NULL)\n\t\t\tcontinue;\n\n\t\tif (is_string) {\n\t\t\tchar buf[256];\n\t\t\tssize_t buflen;\n\t\t\tbuflen = get_string_on_virtaddr(ms, swap, clazz, fd,\n\t\t\t    ph_off, ph_num, fsize, xauxv_val, buf, sizeof(buf));\n\n\t\t\tif (buflen == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (file_printf(ms, \", %s: '%s'\", tag, buf) == -1)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (file_printf(ms, \", %s: %d\", tag, (int) xauxv_val)\n\t\t\t    == -1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n",
        "output": "0",
        "index": 83117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "report_broken_symbolic_link (GtkWindow    *parent_window,\n                             NautilusFile *file)\n{\n    char *target_path;\n    char *display_name;\n    char *prompt;\n    char *detail;\n    GtkDialog *dialog;\n    GList file_as_list;\n    int response;\n    gboolean can_trash;\n\n    g_assert (nautilus_file_is_broken_symbolic_link (file));\n\n    display_name = nautilus_file_get_display_name (file);\n    can_trash = nautilus_file_can_trash (file) && !nautilus_file_is_in_trash (file);\n\n    if (can_trash)\n    {\n        prompt = g_strdup_printf (_(\"The link \u201c%s\u201d is broken. Move it to Trash?\"), display_name);\n    }\n    else\n    {\n        prompt = g_strdup_printf (_(\"The link \u201c%s\u201d is broken.\"), display_name);\n    }\n    g_free (display_name);\n\n    target_path = nautilus_file_get_symbolic_link_target_path (file);\n    if (target_path == NULL)\n    {\n        detail = g_strdup (_(\"This link cannot be used because it has no target.\"));\n    }\n    else\n    {\n        detail = g_strdup_printf (_(\"This link cannot be used because its target \"\n                                    \"\u201c%s\u201d doesn\u2019t exist.\"), target_path);\n    }\n\n    if (!can_trash)\n    {\n        eel_run_simple_dialog (GTK_WIDGET (parent_window), FALSE, GTK_MESSAGE_WARNING,\n                               prompt, detail, _(\"_Cancel\"), NULL);\n        goto out;\n    }\n\n    dialog = eel_show_yes_no_dialog (prompt, detail, _(\"Mo_ve to Trash\"), _(\"_Cancel\"),\n                                     parent_window);\n\n    gtk_dialog_set_default_response (dialog, GTK_RESPONSE_CANCEL);\n\n    /* Make this modal to avoid problems with reffing the view & file\n     * to keep them around in case the view changes, which would then\n     * cause the old view not to be destroyed, which would cause its\n     * merged Bonobo items not to be un-merged. Maybe we need to unmerge\n     * explicitly when disconnecting views instead of relying on the\n     * unmerge in Destroy. But since BonoboUIHandler is probably going\n     * to change wildly, I don't want to mess with this now.\n     */\n\n    response = gtk_dialog_run (dialog);\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n\n    if (response == GTK_RESPONSE_YES)\n    {\n        file_as_list.data = file;\n        file_as_list.next = NULL;\n        file_as_list.prev = NULL;\n        trash_or_delete_files (parent_window, &file_as_list, TRUE);\n    }\n\nout:\n    g_free (prompt);\n    g_free (target_path);\n    g_free (detail);\n}\n",
        "output": "0",
        "index": 61215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChildThread::Init() {\n  g_lazy_tls.Pointer()->Set(this);\n  on_channel_error_called_ = false;\n  message_loop_ = base::MessageLoop::current();\n#ifdef IPC_MESSAGE_LOG_ENABLED\n  IPC::Logging::GetInstance();\n#endif\n  channel_.reset(\n      new IPC::SyncChannel(channel_name_,\n                           IPC::Channel::MODE_CLIENT,\n                           this,\n                           ChildProcess::current()->io_message_loop_proxy(),\n                           true,\n                           ChildProcess::current()->GetShutDownEvent()));\n#ifdef IPC_MESSAGE_LOG_ENABLED\n  if (!in_browser_process_)\n    IPC::Logging::GetInstance()->SetIPCSender(this);\n#endif\n\n  mojo_application_.reset(new MojoApplication(this));\n\n  sync_message_filter_ =\n      new IPC::SyncMessageFilter(ChildProcess::current()->GetShutDownEvent());\n  thread_safe_sender_ = new ThreadSafeSender(\n      base::MessageLoopProxy::current().get(), sync_message_filter_.get());\n\n  resource_dispatcher_.reset(new ResourceDispatcher(this));\n  socket_stream_dispatcher_.reset(new SocketStreamDispatcher());\n  websocket_dispatcher_.reset(new WebSocketDispatcher);\n  file_system_dispatcher_.reset(new FileSystemDispatcher());\n\n  histogram_message_filter_ = new ChildHistogramMessageFilter();\n  resource_message_filter_ =\n      new ChildResourceMessageFilter(resource_dispatcher());\n\n  service_worker_message_filter_ =\n      new ServiceWorkerMessageFilter(thread_safe_sender_.get());\n  service_worker_dispatcher_.reset(\n      new ServiceWorkerDispatcher(thread_safe_sender_.get()));\n\n  quota_message_filter_ =\n      new QuotaMessageFilter(thread_safe_sender_.get());\n  quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender_.get(),\n                                              quota_message_filter_.get()));\n\n  channel_->AddFilter(histogram_message_filter_.get());\n  channel_->AddFilter(sync_message_filter_.get());\n  channel_->AddFilter(new tracing::ChildTraceMessageFilter(\n      ChildProcess::current()->io_message_loop_proxy()));\n  channel_->AddFilter(resource_message_filter_.get());\n  channel_->AddFilter(quota_message_filter_->GetFilter());\n  channel_->AddFilter(service_worker_message_filter_->GetFilter());\n\n  if (!base::PowerMonitor::Get()) {\n    scoped_ptr<PowerMonitorBroadcastSource> power_monitor_source(\n      new PowerMonitorBroadcastSource());\n    channel_->AddFilter(power_monitor_source->GetMessageFilter());\n\n    power_monitor_.reset(new base::PowerMonitor(\n        power_monitor_source.PassAs<base::PowerMonitorSource>()));\n  }\n\n#if defined(OS_POSIX)\n  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kProcessType))\n    channel_->AddFilter(new SuicideOnChannelErrorFilter());\n#endif\n\n  base::MessageLoop::current()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&ChildThread::EnsureConnected,\n                 channel_connected_factory_.GetWeakPtr()),\n      base::TimeDelta::FromSeconds(kConnectionTimeoutS));\n\n#if defined(OS_ANDROID)\n  {\n    base::AutoLock lock(g_lazy_child_thread_lock.Get());\n    g_child_thread = this;\n  }\n  g_lazy_child_thread_cv.Get().Signal();\n#endif\n\n#if defined(TCMALLOC_TRACE_MEMORY_SUPPORTED)\n  trace_memory_controller_.reset(new base::debug::TraceMemoryController(\n      message_loop_->message_loop_proxy(),\n      ::HeapProfilerWithPseudoStackStart,\n      ::HeapProfilerStop,\n      ::GetHeapProfile));\n#endif\n\n  shared_bitmap_manager_.reset(\n      new ChildSharedBitmapManager(thread_safe_sender()));\n}\n",
        "output": "0",
        "index": 129767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DocumentLoader::InstallNewDocument(\n    const KURL& url,\n    Document* owner_document,\n    WebGlobalObjectReusePolicy global_object_reuse_policy,\n    const AtomicString& mime_type,\n    const AtomicString& encoding,\n    InstallNewDocumentReason reason,\n    ParserSynchronizationPolicy parsing_policy,\n    const KURL& overriding_url) {\n  DCHECK(!frame_->GetDocument() || !frame_->GetDocument()->IsActive());\n  DCHECK_EQ(frame_->Tree().ChildCount(), 0u);\n  if (GetFrameLoader().StateMachine()->IsDisplayingInitialEmptyDocument()) {\n    GetFrameLoader().StateMachine()->AdvanceTo(\n        FrameLoaderStateMachine::kCommittedFirstRealLoad);\n   }\n \n   const SecurityOrigin* previous_security_origin = nullptr;\n  if (frame_->GetDocument())\n     previous_security_origin = frame_->GetDocument()->GetSecurityOrigin();\n \n  if (global_object_reuse_policy != WebGlobalObjectReusePolicy::kUseExisting)\n    frame_->SetDOMWindow(LocalDOMWindow::Create(*frame_));\n\n  if (reason == InstallNewDocumentReason::kNavigation)\n    WillCommitNavigation();\n\n  Document* document = frame_->DomWindow()->InstallNewDocument(\n      mime_type,\n      DocumentInit::Create()\n           .WithDocumentLoader(this)\n           .WithURL(url)\n           .WithOwnerDocument(owner_document)\n          .WithNewRegistrationContext(),\n       false);\n \n  if (frame_->IsMainFrame())\n    frame_->ClearActivation();\n\n  if (frame_->HasReceivedUserGestureBeforeNavigation() !=\n      had_sticky_activation_) {\n    frame_->SetDocumentHasReceivedUserGestureBeforeNavigation(\n        had_sticky_activation_);\n    GetLocalFrameClient().SetHasReceivedUserGestureBeforeNavigation(\n        had_sticky_activation_);\n  }\n\n  if (ShouldClearWindowName(*frame_, previous_security_origin, *document)) {\n    frame_->Tree().ExperimentalSetNulledName();\n  }\n \n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n  DidInstallNewDocument(document);\n \n  if (reason == InstallNewDocumentReason::kNavigation)\n    DidCommitNavigation(global_object_reuse_policy);\n\n  if (GetFrameLoader().StateMachine()->CommittedFirstRealDocumentLoad()) {\n    if (document->GetSettings()\n            ->GetForceTouchEventFeatureDetectionForInspector()) {\n      OriginTrialContext::FromOrCreate(document)->AddFeature(\n          \"ForceTouchEventFeatureDetectionForInspector\");\n    }\n    OriginTrialContext::AddTokensFromHeader(\n        document, response_.HttpHeaderField(HTTPNames::Origin_Trial));\n  }\n  bool stale_while_revalidate_enabled =\n      OriginTrials::StaleWhileRevalidateEnabled(document);\n  fetcher_->SetStaleWhileRevalidateEnabled(stale_while_revalidate_enabled);\n\n  if (stale_while_revalidate_enabled &&\n      !RuntimeEnabledFeatures::StaleWhileRevalidateEnabledByRuntimeFlag())\n    UseCounter::Count(frame_, WebFeature::kStaleWhileRevalidateEnabled);\n\n  parser_ = document->OpenForNavigation(parsing_policy, mime_type, encoding);\n\n  ScriptableDocumentParser* scriptable_parser =\n      parser_->AsScriptableDocumentParser();\n  if (scriptable_parser && GetResource()) {\n    scriptable_parser->SetInlineScriptCacheHandler(\n        ToRawResource(GetResource())->InlineScriptCacheHandler());\n  }\n\n  document->ApplyFeaturePolicyFromHeader(\n      response_.HttpHeaderField(HTTPNames::Feature_Policy));\n\n  GetFrameLoader().DispatchDidClearDocumentOfWindowObject();\n}\n",
        "output": "1",
        "index": 186595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_MINIT_FUNCTION(date)\n{\n\tREGISTER_INI_ENTRIES();\n\tdate_register_classes(TSRMLS_C);\n/*\n * RFC4287, Section 3.3: http://www.ietf.org/rfc/rfc4287.txt\n *   A Date construct is an element whose content MUST conform to the\n *   \"date-time\" production in [RFC3339].  In addition, an uppercase \"T\"\n *   character MUST be used to separate date and time, and an uppercase\n *   \"Z\" character MUST be present in the absence of a numeric time zone offset.\n */\n\tREGISTER_STRING_CONSTANT(\"DATE_ATOM\",    DATE_FORMAT_RFC3339, CONST_CS | CONST_PERSISTENT);\n/*\n * Preliminary specification: http://wp.netscape.com/newsref/std/cookie_spec.html\n *   \"This is based on RFC 822, RFC 850,  RFC 1036, and  RFC 1123,\n *   with the variations that the only legal time zone is GMT\n *   and the separators between the elements of the date must be dashes.\"\n */\n\tREGISTER_STRING_CONSTANT(\"DATE_COOKIE\",  DATE_FORMAT_COOKIE,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_ISO8601\", DATE_FORMAT_ISO8601, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC822\",  DATE_FORMAT_RFC822,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC850\",  DATE_FORMAT_RFC850,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC1036\", DATE_FORMAT_RFC1036, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC1123\", DATE_FORMAT_RFC1123, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC2822\", DATE_FORMAT_RFC2822, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_STRING_CONSTANT(\"DATE_RFC3339\", DATE_FORMAT_RFC3339, CONST_CS | CONST_PERSISTENT);\n/*\n * RSS 2.0 Specification: http://blogs.law.harvard.edu/tech/rss\n *   \"All date-times in RSS conform to the Date and Time Specification of RFC 822,\n *   with the exception that the year may be expressed with two characters or four characters (four preferred)\"\n */\n\tREGISTER_STRING_CONSTANT(\"DATE_RSS\",     DATE_FORMAT_RFC1123, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_W3C\",     DATE_FORMAT_RFC3339, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"SUNFUNCS_RET_TIMESTAMP\", SUNFUNCS_RET_TIMESTAMP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SUNFUNCS_RET_STRING\", SUNFUNCS_RET_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SUNFUNCS_RET_DOUBLE\", SUNFUNCS_RET_DOUBLE, CONST_CS | CONST_PERSISTENT);\n\n\tphp_date_global_timezone_db = NULL;\n\tphp_date_global_timezone_db_enabled = 0;\n\tDATEG(last_errors) = NULL;\n\treturn SUCCESS;\n}\n",
        "output": "0",
        "index": 6295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::pair<String, String> InputType::ValidationMessage(\n    const InputTypeView& input_type_view) const {\n  const String value = GetElement().value();\n\n  if (input_type_view.HasBadInput())\n    return std::make_pair(BadInputText(), g_empty_string);\n\n  if (ValueMissing(value))\n    return std::make_pair(ValueMissingText(), g_empty_string);\n\n  if (TypeMismatch())\n    return std::make_pair(TypeMismatchText(), g_empty_string);\n\n  if (PatternMismatch(value)) {\n    return std::make_pair(\n        GetLocale().QueryString(WebLocalizedString::kValidationPatternMismatch),\n        GetElement().FastGetAttribute(titleAttr).GetString());\n  }\n\n  if (GetElement().TooLong()) {\n    return std::make_pair(GetLocale().ValidationMessageTooLongText(\n                              value.length(), GetElement().maxLength()),\n                          g_empty_string);\n  }\n\n  if (GetElement().TooShort()) {\n    return std::make_pair(GetLocale().ValidationMessageTooShortText(\n                              value.length(), GetElement().minLength()),\n                          g_empty_string);\n  }\n\n  if (!IsSteppable())\n    return std::make_pair(g_empty_string, g_empty_string);\n\n  const Decimal numeric_value = ParseToNumberOrNaN(value);\n  if (!numeric_value.IsFinite())\n    return std::make_pair(g_empty_string, g_empty_string);\n\n  StepRange step_range(CreateStepRange(kRejectAny));\n\n  if (numeric_value < step_range.Minimum())\n    return std::make_pair(RangeUnderflowText(step_range.Minimum()),\n                          g_empty_string);\n\n  if (numeric_value > step_range.Maximum())\n    return std::make_pair(RangeOverflowText(step_range.Maximum()),\n                          g_empty_string);\n\n  if (step_range.StepMismatch(numeric_value)) {\n    DCHECK(step_range.HasStep());\n    Decimal candidate1 = step_range.ClampValue(numeric_value);\n    String localized_candidate1 = LocalizeValue(Serialize(candidate1));\n    Decimal candidate2 = candidate1 < numeric_value\n                             ? candidate1 + step_range.Step()\n                             : candidate1 - step_range.Step();\n    if (!candidate2.IsFinite() || candidate2 < step_range.Minimum() ||\n        candidate2 > step_range.Maximum()) {\n      return std::make_pair(\n          GetLocale().QueryString(\n              WebLocalizedString::kValidationStepMismatchCloseToLimit,\n              localized_candidate1),\n          g_empty_string);\n    }\n    String localized_candidate2 = LocalizeValue(Serialize(candidate2));\n    if (candidate1 < candidate2) {\n      return std::make_pair(\n          GetLocale().QueryString(WebLocalizedString::kValidationStepMismatch,\n                                  localized_candidate1, localized_candidate2),\n          g_empty_string);\n    }\n    return std::make_pair(\n        GetLocale().QueryString(WebLocalizedString::kValidationStepMismatch,\n                                localized_candidate2, localized_candidate1),\n        g_empty_string);\n  }\n\n  return std::make_pair(g_empty_string, g_empty_string);\n}\n",
        "output": "0",
        "index": 137128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebContentsImpl::~WebContentsImpl() {\n  CHECK(!is_being_destroyed_);\n\n  is_being_destroyed_ = true;\n\n  CHECK(!is_notifying_observers_);\n\n  rwh_input_event_router_.reset();\n\n  for (auto& entry : binding_sets_)\n    entry.second->CloseAllBindings();\n\n  WebContentsImpl* outermost = GetOutermostWebContents();\n  if (this != outermost && ContainsOrIsFocusedWebContents()) {\n    outermost->SetAsFocusedWebContentsIfNecessary();\n  }\n\n  for (FrameTreeNode* node : frame_tree_.Nodes()) {\n    node->render_manager()->ClearRFHsPendingShutdown();\n    node->render_manager()->ClearWebUIInstances();\n  }\n\n  for (RenderWidgetHostImpl* widget : created_widgets_)\n    widget->DetachDelegate();\n  created_widgets_.clear();\n\n  if (dialog_manager_) {\n    dialog_manager_->CancelDialogs(this, /*reset_state=*/true);\n  }\n\n  if (color_chooser_info_.get())\n    color_chooser_info_->chooser->End();\n\n  NotifyDisconnected();\n\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_DESTROYED,\n      Source<WebContents>(this),\n      NotificationService::NoDetails());\n\n  frame_tree_.root()->ResetForNewProcess();\n  GetRenderManager()->ResetProxyHosts();\n\n  RenderFrameHostManager* root = GetRenderManager();\n\n  if (root->pending_frame_host()) {\n    root->pending_frame_host()->SetRenderFrameCreated(false);\n    root->pending_frame_host()->SetNavigationHandle(\n        std::unique_ptr<NavigationHandleImpl>());\n  }\n  root->current_frame_host()->SetRenderFrameCreated(false);\n  root->current_frame_host()->SetNavigationHandle(\n      std::unique_ptr<NavigationHandleImpl>());\n\n  if (IsBrowserSideNavigationEnabled()) {\n    frame_tree_.root()->ResetNavigationRequest(true, true);\n    if (root->speculative_frame_host()) {\n      root->speculative_frame_host()->SetRenderFrameCreated(false);\n      root->speculative_frame_host()->SetNavigationHandle(\n          std::unique_ptr<NavigationHandleImpl>());\n    }\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  pepper_playback_observer_.reset();\n#endif  // defined(ENABLED_PLUGINS)\n\n  for (auto& observer : observers_)\n    observer.FrameDeleted(root->current_frame_host());\n\n  if (root->pending_render_view_host()) {\n    for (auto& observer : observers_)\n      observer.RenderViewDeleted(root->pending_render_view_host());\n  }\n\n  for (auto& observer : observers_)\n    observer.RenderViewDeleted(root->current_host());\n\n  for (auto& observer : observers_)\n    observer.WebContentsDestroyed();\n\n  for (auto& observer : observers_)\n    observer.ResetWebContents();\n\n  SetDelegate(NULL);\n}\n",
        "output": "0",
        "index": 148602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int comedi_alloc_subdevice_minor(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tunsigned long flags;\n\tstruct comedi_device_file_info *info;\n\tstruct device *csdev;\n\tunsigned i;\n\tint retval;\n\n\tinfo = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);\n\tif (info == NULL)\n\t\treturn -ENOMEM;\n\tinfo->device = dev;\n\tinfo->read_subdevice = s;\n\tinfo->write_subdevice = s;\n\tspin_lock_irqsave(&comedi_file_info_table_lock, flags);\n\tfor (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {\n\t\tif (comedi_file_info_table[i] == NULL) {\n\t\t\tcomedi_file_info_table[i] = info;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&comedi_file_info_table_lock, flags);\n\tif (i == COMEDI_NUM_MINORS) {\n\t\tkfree(info);\n\t\tprintk(KERN_ERR\n\t\t       \"comedi: error: \"\n\t\t       \"ran out of minor numbers for board device files.\\n\");\n\t\treturn -EBUSY;\n\t}\n\ts->minor = i;\n\tcsdev = COMEDI_DEVICE_CREATE(comedi_class, dev->class_dev,\n\t\t\t\t     MKDEV(COMEDI_MAJOR, i), NULL, NULL,\n\t\t\t\t     \"comedi%i_subd%i\", dev->minor,\n\t\t\t\t     (int)(s - dev->subdevices));\n\tif (!IS_ERR(csdev))\n\t\ts->class_dev = csdev;\n\tdev_set_drvdata(csdev, info);\n\tretval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);\n\tif (retval) {\n\t\tprintk(KERN_ERR\n\t\t       \"comedi: \"\n\t\t       \"failed to create sysfs attribute file \\\"%s\\\".\\n\",\n\t\t       dev_attr_max_read_buffer_kb.attr.name);\n\t\tcomedi_free_subdevice_minor(s);\n\t\treturn retval;\n\t}\n\tretval = device_create_file(csdev, &dev_attr_read_buffer_kb);\n\tif (retval) {\n\t\tprintk(KERN_ERR\n\t\t       \"comedi: \"\n\t\t       \"failed to create sysfs attribute file \\\"%s\\\".\\n\",\n\t\t       dev_attr_read_buffer_kb.attr.name);\n\t\tcomedi_free_subdevice_minor(s);\n\t\treturn retval;\n\t}\n\tretval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);\n\tif (retval) {\n\t\tprintk(KERN_ERR\n\t\t       \"comedi: \"\n\t\t       \"failed to create sysfs attribute file \\\"%s\\\".\\n\",\n\t\t       dev_attr_max_write_buffer_kb.attr.name);\n\t\tcomedi_free_subdevice_minor(s);\n\t\treturn retval;\n\t}\n\tretval = device_create_file(csdev, &dev_attr_write_buffer_kb);\n\tif (retval) {\n\t\tprintk(KERN_ERR\n\t\t       \"comedi: \"\n\t\t       \"failed to create sysfs attribute file \\\"%s\\\".\\n\",\n\t\t       dev_attr_write_buffer_kb.attr.name);\n\t\tcomedi_free_subdevice_minor(s);\n\t\treturn retval;\n\t}\n\treturn i;\n}\n",
        "output": "0",
        "index": 41271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int limit_list(struct rev_info *revs)\n{\n\tint slop = SLOP;\n\tunsigned long date = ~0ul;\n\tstruct commit_list *list = revs->commits;\n\tstruct commit_list *newlist = NULL;\n\tstruct commit_list **p = &newlist;\n\tstruct commit_list *bottom = NULL;\n\tstruct commit *interesting_cache = NULL;\n\n\tif (revs->ancestry_path) {\n\t\tbottom = collect_bottom_commits(list);\n\t\tif (!bottom)\n\t\t\tdie(\"--ancestry-path given but there are no bottom commits\");\n\t}\n\n\twhile (list) {\n\t\tstruct commit_list *entry = list;\n\t\tstruct commit *commit = list->item;\n\t\tstruct object *obj = &commit->object;\n\t\tshow_early_output_fn_t show;\n\n\t\tlist = list->next;\n\t\tfree(entry);\n\n\t\tif (commit == interesting_cache)\n\t\t\tinteresting_cache = NULL;\n\n\t\tif (revs->max_age != -1 && (commit->date < revs->max_age))\n\t\t\tobj->flags |= UNINTERESTING;\n\t\tif (add_parents_to_list(revs, commit, &list, NULL) < 0)\n\t\t\treturn -1;\n\t\tif (obj->flags & UNINTERESTING) {\n\t\t\tmark_parents_uninteresting(commit);\n\t\t\tif (revs->show_all)\n\t\t\t\tp = &commit_list_insert(commit, p)->next;\n\t\t\tslop = still_interesting(list, date, slop, &interesting_cache);\n\t\t\tif (slop)\n\t\t\t\tcontinue;\n\t\t\t/* If showing all, add the whole pending list to the end */\n\t\t\tif (revs->show_all)\n\t\t\t\t*p = list;\n\t\t\tbreak;\n\t\t}\n\t\tif (revs->min_age != -1 && (commit->date > revs->min_age))\n\t\t\tcontinue;\n\t\tdate = commit->date;\n\t\tp = &commit_list_insert(commit, p)->next;\n\n\t\tshow = show_early_output;\n\t\tif (!show)\n\t\t\tcontinue;\n\n\t\tshow(revs, newlist);\n\t\tshow_early_output = NULL;\n\t}\n\tif (revs->cherry_pick || revs->cherry_mark)\n\t\tcherry_pick_list(newlist, revs);\n\n\tif (revs->left_only || revs->right_only)\n\t\tlimit_left_right(newlist, revs);\n\n\tif (bottom) {\n\t\tlimit_to_ancestry(bottom, newlist);\n\t\tfree_commit_list(bottom);\n\t}\n\n\t/*\n\t * Check if any commits have become TREESAME by some of their parents\n\t * becoming UNINTERESTING.\n\t */\n\tif (limiting_can_increase_treesame(revs))\n\t\tfor (list = newlist; list; list = list->next) {\n\t\t\tstruct commit *c = list->item;\n\t\t\tif (c->object.flags & (UNINTERESTING | TREESAME))\n\t\t\t\tcontinue;\n\t\t\tupdate_treesame(revs, c);\n\t\t}\n\n\trevs->commits = newlist;\n\treturn 0;\n}\n",
        "output": "0",
        "index": 55165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vapic_write(void *opaque, hwaddr addr, uint64_t data,\n                        unsigned int size)\n{\n    VAPICROMState *s = opaque;\n    X86CPU *cpu;\n    CPUX86State *env;\n    hwaddr rom_paddr;\n\n    if (!current_cpu) {\n        return;\n    }\n\n    cpu_synchronize_state(current_cpu);\n    cpu = X86_CPU(current_cpu);\n    env = &cpu->env;\n\n    /*\n     * The VAPIC supports two PIO-based hypercalls, both via port 0x7E.\n     *  o 16-bit write access:\n     *    Reports the option ROM initialization to the hypervisor. Written\n     *    value is the offset of the state structure in the ROM.\n     *  o 8-bit write access:\n     *    Reactivates the VAPIC after a guest hibernation, i.e. after the\n     *    option ROM content has been re-initialized by a guest power cycle.\n     *  o 32-bit write access:\n     *    Poll for pending IRQs, considering the current VAPIC state.\n     */\n    switch (size) {\n    case 2:\n        if (s->state == VAPIC_INACTIVE) {\n            rom_paddr = (env->segs[R_CS].base + env->eip) & ROM_BLOCK_MASK;\n            s->rom_state_paddr = rom_paddr + data;\n\n            s->state = VAPIC_STANDBY;\n        }\n        if (vapic_prepare(s) < 0) {\n            s->state = VAPIC_INACTIVE;\n            s->rom_state_paddr = 0;\n            break;\n        }\n        break;\n    case 1:\n        if (kvm_enabled()) {\n            /*\n             * Disable triggering instruction in ROM by writing a NOP.\n             *\n             * We cannot do this in TCG mode as the reported IP is not\n             * accurate.\n             */\n            pause_all_vcpus();\n            patch_byte(cpu, env->eip - 2, 0x66);\n            patch_byte(cpu, env->eip - 1, 0x90);\n            resume_all_vcpus();\n        }\n\n        if (s->state == VAPIC_ACTIVE) {\n            break;\n        }\n        if (update_rom_mapping(s, env, env->eip) < 0) {\n            break;\n        }\n        if (find_real_tpr_addr(s, env) < 0) {\n            break;\n        }\n        vapic_enable(s, cpu);\n        break;\n    default:\n    case 4:\n        if (!kvm_irqchip_in_kernel()) {\n            apic_poll_irq(cpu->apic_state);\n        }\n        break;\n    }\n}\n",
        "output": "0",
        "index": 11272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ssl3_cbc_copy_mac(unsigned char *out,\n                       const SSL3_RECORD *rec, unsigned md_size)\n{\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n    unsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE];\n    unsigned char *rotated_mac;\n#else\n    unsigned char rotated_mac[EVP_MAX_MD_SIZE];\n#endif\n\n    /*\n     * mac_end is the index of |rec->data| just after the end of the MAC.\n     */\n    unsigned mac_end = rec->length;\n    unsigned mac_start = mac_end - md_size;\n    /*\n     * scan_start contains the number of bytes that we can ignore because the\n     * MAC's position can only vary by 255 bytes.\n     */\n    unsigned scan_start = 0;\n    unsigned i, j;\n    unsigned div_spoiler;\n    unsigned rotate_offset;\n\n    OPENSSL_assert(rec->orig_len >= md_size);\n    OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n    rotated_mac = rotated_mac_buf + ((0 - (size_t)rotated_mac_buf) & 63);\n#endif\n\n    /* This information is public so it's safe to branch based on it. */\n    if (rec->orig_len > md_size + 255 + 1)\n        scan_start = rec->orig_len - (md_size + 255 + 1);\n    /*\n     * div_spoiler contains a multiple of md_size that is used to cause the\n     * modulo operation to be constant time. Without this, the time varies\n     * based on the amount of padding when running on Intel chips at least.\n     * The aim of right-shifting md_size is so that the compiler doesn't\n     * figure out that it can remove div_spoiler as that would require it to\n     * prove that md_size is always even, which I hope is beyond it.\n     */\n    div_spoiler = md_size >> 1;\n    div_spoiler <<= (sizeof(div_spoiler) - 1) * 8;\n    rotate_offset = (div_spoiler + mac_start - scan_start) % md_size;\n\n    memset(rotated_mac, 0, md_size);\n    for (i = scan_start, j = 0; i < rec->orig_len; i++) {\n        unsigned char mac_started = constant_time_ge_8(i, mac_start);\n        unsigned char mac_ended = constant_time_ge_8(i, mac_end);\n        unsigned char b = rec->data[i];\n        rotated_mac[j++] |= b & mac_started & ~mac_ended;\n        j &= constant_time_lt(j, md_size);\n    }\n\n    /* Now rotate the MAC */\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n    j = 0;\n    for (i = 0; i < md_size; i++) {\n        /* in case cache-line is 32 bytes, touch second line */\n        ((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32];\n        out[j++] = rotated_mac[rotate_offset++];\n        rotate_offset &= constant_time_lt(rotate_offset, md_size);\n    }\n#else\n    memset(out, 0, md_size);\n    rotate_offset = md_size - rotate_offset;\n    rotate_offset &= constant_time_lt(rotate_offset, md_size);\n    for (i = 0; i < md_size; i++) {\n        for (j = 0; j < md_size; j++)\n            out[j] |= rotated_mac[i] & constant_time_eq_8(j, rotate_offset);\n        rotate_offset++;\n        rotate_offset &= constant_time_lt(rotate_offset, md_size);\n    }\n #endif\n }\n",
        "output": "0",
        "index": 12695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct request_queue *blk_mq_init_allocated_queue(struct blk_mq_tag_set *set,\n\t\t\t\t\t\t  struct request_queue *q)\n{\n\tstruct blk_mq_hw_ctx **hctxs;\n\tstruct blk_mq_ctx __percpu *ctx;\n\tunsigned int *map;\n\tint i;\n\n\tctx = alloc_percpu(struct blk_mq_ctx);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thctxs = kmalloc_node(set->nr_hw_queues * sizeof(*hctxs), GFP_KERNEL,\n\t\t\tset->numa_node);\n\n\tif (!hctxs)\n\t\tgoto err_percpu;\n\n\tmap = blk_mq_make_queue_map(set);\n\tif (!map)\n\t\tgoto err_map;\n\n\tfor (i = 0; i < set->nr_hw_queues; i++) {\n\t\tint node = blk_mq_hw_queue_to_node(map, i);\n\n\t\thctxs[i] = kzalloc_node(sizeof(struct blk_mq_hw_ctx),\n\t\t\t\t\tGFP_KERNEL, node);\n\t\tif (!hctxs[i])\n\t\t\tgoto err_hctxs;\n\n\t\tif (!zalloc_cpumask_var_node(&hctxs[i]->cpumask, GFP_KERNEL,\n\t\t\t\t\t\tnode))\n\t\t\tgoto err_hctxs;\n\n\t\tatomic_set(&hctxs[i]->nr_active, 0);\n\t\thctxs[i]->numa_node = node;\n\t\thctxs[i]->queue_num = i;\n\t}\n\n\t/*\n\t * Init percpu_ref in atomic mode so that it's faster to shutdown.\n\t * See blk_register_queue() for details.\n\t */\n\tif (percpu_ref_init(&q->mq_usage_counter, blk_mq_usage_counter_release,\n\t\t\t    PERCPU_REF_INIT_ATOMIC, GFP_KERNEL))\n\t\tgoto err_hctxs;\n\n\tsetup_timer(&q->timeout, blk_mq_rq_timer, (unsigned long) q);\n\tblk_queue_rq_timeout(q, set->timeout ? set->timeout : 30 * HZ);\n\n\tq->nr_queues = nr_cpu_ids;\n\tq->nr_hw_queues = set->nr_hw_queues;\n\tq->mq_map = map;\n\n\tq->queue_ctx = ctx;\n\tq->queue_hw_ctx = hctxs;\n\n\tq->mq_ops = set->ops;\n\tq->queue_flags |= QUEUE_FLAG_MQ_DEFAULT;\n\n\tif (!(set->flags & BLK_MQ_F_SG_MERGE))\n\t\tq->queue_flags |= 1 << QUEUE_FLAG_NO_SG_MERGE;\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tINIT_WORK(&q->requeue_work, blk_mq_requeue_work);\n\tINIT_LIST_HEAD(&q->requeue_list);\n\tspin_lock_init(&q->requeue_lock);\n\n\tif (q->nr_hw_queues > 1)\n\t\tblk_queue_make_request(q, blk_mq_make_request);\n\telse\n\t\tblk_queue_make_request(q, blk_sq_make_request);\n\n\t/*\n\t * Do this after blk_queue_make_request() overrides it...\n\t */\n\tq->nr_requests = set->queue_depth;\n\n\tif (set->ops->complete)\n\t\tblk_queue_softirq_done(q, set->ops->complete);\n\n\tblk_mq_init_cpu_queues(q, set->nr_hw_queues);\n\n\tif (blk_mq_init_hw_queues(q, set))\n\t\tgoto err_hctxs;\n\n\tmutex_lock(&all_q_mutex);\n\tlist_add_tail(&q->all_q_node, &all_q_list);\n\tmutex_unlock(&all_q_mutex);\n\n\tblk_mq_add_queue_tag_set(set, q);\n\n\tblk_mq_map_swqueue(q);\n\n\treturn q;\n\nerr_hctxs:\n\tkfree(map);\n\tfor (i = 0; i < set->nr_hw_queues; i++) {\n\t\tif (!hctxs[i])\n\t\t\tbreak;\n\t\tfree_cpumask_var(hctxs[i]->cpumask);\n\t\tkfree(hctxs[i]);\n\t}\nerr_map:\n\tkfree(hctxs);\nerr_percpu:\n\tfree_percpu(ctx);\n\treturn ERR_PTR(-ENOMEM);\n}\n",
        "output": "0",
        "index": 86712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long sys_swapcontext(struct ucontext __user *old_ctx,\n\t\t     struct ucontext __user *new_ctx,\n\t\t     int ctx_size, int r6, int r7, int r8, struct pt_regs *regs)\n{\n\tunsigned char tmp;\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(VERIFY_WRITE, old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(VERIFY_READ, new_ctx, ctx_size)\n\t    || __get_user(tmp, (u8 __user *) new_ctx)\n\t    || __get_user(tmp, (u8 __user *) new_ctx + ctx_size - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 56489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int register_netdevice(struct net_device *dev)\n{\n\tint ret;\n\tstruct net *net = dev_net(dev);\n\n\tBUG_ON(dev_boot_phase);\n\tASSERT_RTNL();\n\n\tmight_sleep();\n\n\t/* When net_device's are persistent, this will be fatal. */\n\tBUG_ON(dev->reg_state != NETREG_UNINITIALIZED);\n\tBUG_ON(!net);\n\n\tspin_lock_init(&dev->addr_list_lock);\n\tnetdev_set_addr_lockdep_class(dev);\n\n\tdev->iflink = -1;\n\n\t/* Init, if this function is available */\n\tif (dev->netdev_ops->ndo_init) {\n\t\tret = dev->netdev_ops->ndo_init(dev);\n\t\tif (ret) {\n\t\t\tif (ret > 0)\n\t\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = dev_get_valid_name(dev, dev->name, 0);\n\tif (ret)\n\t\tgoto err_uninit;\n\n\tdev->ifindex = dev_new_index(net);\n\tif (dev->iflink == -1)\n\t\tdev->iflink = dev->ifindex;\n\n\t/* Fix illegal checksum combinations */\n\tif ((dev->features & NETIF_F_HW_CSUM) &&\n\t    (dev->features & (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))) {\n\t\tprintk(KERN_NOTICE \"%s: mixed HW and IP checksum settings.\\n\",\n\t\t       dev->name);\n\t\tdev->features &= ~(NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM);\n\t}\n\n\tif ((dev->features & NETIF_F_NO_CSUM) &&\n\t    (dev->features & (NETIF_F_HW_CSUM|NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))) {\n\t\tprintk(KERN_NOTICE \"%s: mixed no checksumming and other settings.\\n\",\n\t\t       dev->name);\n\t\tdev->features &= ~(NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM|NETIF_F_HW_CSUM);\n\t}\n\n\tdev->features = netdev_fix_features(dev->features, dev->name);\n\n\t/* Enable software GSO if SG is supported. */\n\tif (dev->features & NETIF_F_SG)\n\t\tdev->features |= NETIF_F_GSO;\n\n\t/* Enable GRO and NETIF_F_HIGHDMA for vlans by default,\n\t * vlan_dev_init() will do the dev->features check, so these features\n\t * are enabled only if supported by underlying device.\n\t */\n\tdev->vlan_features |= (NETIF_F_GRO | NETIF_F_HIGHDMA);\n\n\tret = call_netdevice_notifiers(NETDEV_POST_INIT, dev);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\tgoto err_uninit;\n\n\tret = netdev_register_kobject(dev);\n\tif (ret)\n\t\tgoto err_uninit;\n\tdev->reg_state = NETREG_REGISTERED;\n\n\t/*\n\t *\tDefault initial state at registry is that the\n\t *\tdevice is present.\n\t */\n\n\tset_bit(__LINK_STATE_PRESENT, &dev->state);\n\n\tdev_init_scheduler(dev);\n\tdev_hold(dev);\n\tlist_netdevice(dev);\n\n\t/* Notify protocols, that a new device appeared. */\n\tret = call_netdevice_notifiers(NETDEV_REGISTER, dev);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\trollback_registered(dev);\n\t\tdev->reg_state = NETREG_UNREGISTERED;\n\t}\n\t/*\n\t *\tPrevent userspace races by waiting until the network\n\t *\tdevice is fully setup before sending notifications.\n\t */\n\tif (!dev->rtnl_link_ops ||\n\t    dev->rtnl_link_state == RTNL_LINK_INITIALIZED)\n\t\trtmsg_ifinfo(RTM_NEWLINK, dev, ~0U);\n\nout:\n\treturn ret;\n\nerr_uninit:\n\tif (dev->netdev_ops->ndo_uninit)\n\t\tdev->netdev_ops->ndo_uninit(dev);\n\tgoto out;\n}\n",
        "output": "0",
        "index": 35296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hns_rcb_get_strings(int stringset, u8 *data, int index)\n{\n\tchar *buff = (char *)data;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_rcb_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_ppe_tx_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_ppe_drop_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_fbd_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_bytes\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_err_cnt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_io_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_sw_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_seg_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_restart_queue\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"tx_ring%d_tx_busy\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_rcb_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_ppe_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_ppe_drop_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_fbd_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_pkt_num\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_bytes\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_err_cnt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_io_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_sw_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_seg_pkt\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_reuse_pg\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_len_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_non_vld_desc_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_bd_num_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_l2_err\", index);\n\tbuff = buff + ETH_GSTRING_LEN;\n\tsnprintf(buff, ETH_GSTRING_LEN, \"rx_ring%d_l3l4csum_err\", index);\n}\n",
        "output": "0",
        "index": 85605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DOMWindow* CreateWindow(const String& url_string,\n                        const AtomicString& frame_name,\n                        const String& window_features_string,\n                        LocalDOMWindow& calling_window,\n                        LocalFrame& first_frame,\n                        LocalFrame& opener_frame,\n                        ExceptionState& exception_state) {\n  LocalFrame* active_frame = calling_window.GetFrame();\n  DCHECK(active_frame);\n\n  KURL completed_url = url_string.IsEmpty()\n                           ? KURL(kParsedURLString, g_empty_string)\n                           : first_frame.GetDocument()->CompleteURL(url_string);\n  if (!completed_url.IsEmpty() && !completed_url.IsValid()) {\n    UseCounter::Count(active_frame, WebFeature::kWindowOpenWithInvalidURL);\n    exception_state.ThrowDOMException(\n        kSyntaxError, \"Unable to open a window with invalid URL '\" +\n                          completed_url.GetString() + \"'.\\n\");\n     return nullptr;\n   }\n \n   WebWindowFeatures window_features =\n       GetWindowFeaturesFromString(window_features_string);\n \n  FrameLoadRequest frame_request(calling_window.document(),\n                                 ResourceRequest(completed_url), frame_name);\n  frame_request.SetShouldSetOpener(window_features.noopener ? kNeverSetOpener\n                                                            : kMaybeSetOpener);\n  frame_request.GetResourceRequest().SetFrameType(\n      WebURLRequest::kFrameTypeAuxiliary);\n  frame_request.GetResourceRequest().SetRequestorOrigin(\n      SecurityOrigin::Create(active_frame->GetDocument()->Url()));\n\n  frame_request.GetResourceRequest().SetHTTPReferrer(\n      SecurityPolicy::GenerateReferrer(\n          active_frame->GetDocument()->GetReferrerPolicy(), completed_url,\n          active_frame->GetDocument()->OutgoingReferrer()));\n\n  bool has_user_gesture = UserGestureIndicator::ProcessingUserGesture();\n\n  bool created;\n  Frame* new_frame = CreateWindowHelper(\n      opener_frame, *active_frame, opener_frame, frame_request, window_features,\n      kNavigationPolicyIgnore, created);\n  if (!new_frame)\n    return nullptr;\n  if (new_frame->DomWindow()->IsInsecureScriptAccess(calling_window,\n                                                     completed_url))\n    return window_features.noopener ? nullptr : new_frame->DomWindow();\n\n  if (created) {\n    FrameLoadRequest request(calling_window.document(),\n                             ResourceRequest(completed_url));\n    request.GetResourceRequest().SetHasUserGesture(has_user_gesture);\n    new_frame->Navigate(request);\n  } else if (!url_string.IsEmpty()) {\n    new_frame->Navigate(*calling_window.document(), completed_url, false,\n                        has_user_gesture ? UserGestureStatus::kActive\n                                         : UserGestureStatus::kNone);\n  }\n  return window_features.noopener ? nullptr : new_frame->DomWindow();\n}\n",
        "output": "1",
        "index": 186930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)\n{\n\tstruct snd_timer_instance *ti, *ts, *tmp;\n\tunsigned long resolution, ticks;\n\tstruct list_head *p, *ack_list_head;\n\tunsigned long flags;\n\tint use_tasklet = 0;\n\n\tif (timer == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&timer->lock, flags);\n\n\t/* remember the current resolution */\n\tif (timer->hw.c_resolution)\n\t\tresolution = timer->hw.c_resolution(timer);\n\telse\n\t\tresolution = timer->hw.resolution;\n\n\t/* loop for all active instances\n\t * Here we cannot use list_for_each_entry because the active_list of a\n\t * processed instance is relinked to done_list_head before the callback\n\t * is called.\n\t */\n\tlist_for_each_entry_safe(ti, tmp, &timer->active_list_head,\n\t\t\t\t active_list) {\n\t\tif (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))\n\t\t\tcontinue;\n\t\tti->pticks += ticks_left;\n\t\tti->resolution = resolution;\n\t\tif (ti->cticks < ticks_left)\n\t\t\tti->cticks = 0;\n\t\telse\n\t\t\tti->cticks -= ticks_left;\n\t\tif (ti->cticks) /* not expired */\n\t\t\tcontinue;\n\t\tif (ti->flags & SNDRV_TIMER_IFLG_AUTO) {\n\t\t\tti->cticks = ti->ticks;\n \t\t} else {\n \t\t\tti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n \t\t\tif (--timer->running)\n\t\t\t\tlist_del(&ti->active_list);\n \t\t}\n \t\tif ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||\n \t\t    (ti->flags & SNDRV_TIMER_IFLG_FAST))\n\t\t\tack_list_head = &timer->ack_list_head;\n\t\telse\n\t\t\tack_list_head = &timer->sack_list_head;\n\t\tif (list_empty(&ti->ack_list))\n\t\t\tlist_add_tail(&ti->ack_list, ack_list_head);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list) {\n\t\t\tts->pticks = ti->pticks;\n\t\t\tts->resolution = resolution;\n\t\t\tif (list_empty(&ts->ack_list))\n\t\t\t\tlist_add_tail(&ts->ack_list, ack_list_head);\n\t\t}\n\t}\n\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED)\n\t\tsnd_timer_reschedule(timer, timer->sticks);\n\tif (timer->running) {\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_STOP) {\n\t\t\ttimer->hw.stop(timer);\n\t\t\ttimer->flags |= SNDRV_TIMER_FLG_CHANGE;\n\t\t}\n\t\tif (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||\n\t\t    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {\n\t\t\t/* restart timer */\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\ttimer->hw.start(timer);\n\t\t}\n\t} else {\n\t\ttimer->hw.stop(timer);\n\t}\n\n\t/* now process all fast callbacks */\n\twhile (!list_empty(&timer->ack_list_head)) {\n\t\tp = timer->ack_list_head.next;\t\t/* get first item */\n\t\tti = list_entry(p, struct snd_timer_instance, ack_list);\n\n\t\t/* remove from ack_list and make empty */\n\t\tlist_del_init(p);\n\n\t\tticks = ti->pticks;\n\t\tti->pticks = 0;\n\n\t\tti->flags |= SNDRV_TIMER_IFLG_CALLBACK;\n\t\tspin_unlock(&timer->lock);\n\t\tif (ti->callback)\n\t\t\tti->callback(ti, resolution, ticks);\n\t\tspin_lock(&timer->lock);\n\t\tti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;\n\t}\n\n\t/* do we have any slow callbacks? */\n\tuse_tasklet = !list_empty(&timer->sack_list_head);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n\n\tif (use_tasklet)\n\t\ttasklet_schedule(&timer->task_queue);\n}\n",
        "output": "1",
        "index": 180580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Plugin::StartProxiedExecution(NaClSrpcChannel* srpc_channel,\n                                   ErrorInfo* error_info) {\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (srpc_channel=%p)\\n\",\n                 static_cast<void*>(srpc_channel)));\n\n  HistogramStartupTimeMedium(\n      \"NaCl.Perf.StartupTime.NaClOverhead\",\n      static_cast<float>(NaClGetTimeOfDayMicroseconds() - init_time_)\n          / NACL_MICROS_PER_MILLI);\n\n  NaClSrpcService* client_service = srpc_channel->client;\n  if (NaClSrpcServiceMethodIndex(client_service,\n                                 \"PPP_InitializeModule:ihs:i\") ==\n      kNaClSrpcInvalidMethodIndex) {\n    error_info->SetReport(\n        ERROR_START_PROXY_CHECK_PPP,\n        \"could not find PPP_InitializeModule() - toolchain version mismatch?\");\n    PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (%s)\\n\",\n                   error_info->message().c_str()));\n    return false;\n  }\n  nacl::scoped_ptr<BrowserPpp> ppapi_proxy(new BrowserPpp(srpc_channel, this));\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (ppapi_proxy=%p)\\n\",\n                 static_cast<void*>(ppapi_proxy.get())));\n  if (ppapi_proxy.get() == NULL) {\n    error_info->SetReport(ERROR_START_PROXY_ALLOC,\n                          \"could not allocate proxy memory.\");\n    return false;\n  }\n  pp::Module* module = pp::Module::Get();\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (module=%p)\\n\",\n                 static_cast<void*>(module)));\n  CHECK(module != NULL);  // We could not have gotten past init stage otherwise.\n  int32_t pp_error =\n      ppapi_proxy->InitializeModule(module->pp_module(),\n                                    module->get_browser_interface());\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (pp_error=%\"\n                 NACL_PRId32\")\\n\", pp_error));\n  if (pp_error != PP_OK) {\n    error_info->SetReport(ERROR_START_PROXY_MODULE,\n                          \"could not initialize module.\");\n    return false;\n  }\n  const PPP_Instance* instance_interface =\n      ppapi_proxy->ppp_instance_interface();\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (ppp_instance=%p)\\n\",\n                 static_cast<const void*>(instance_interface)));\n  CHECK(instance_interface != NULL);  // Verified on module initialization.\n  PP_Bool did_create = instance_interface->DidCreate(\n      pp_instance(),\n      argc(),\n      const_cast<const char**>(argn()),\n      const_cast<const char**>(argv()));\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (did_create=%d)\\n\",\n                 did_create));\n  if (did_create == PP_FALSE) {\n    error_info->SetReport(ERROR_START_PROXY_INSTANCE,\n                          \"could not create instance.\");\n    return false;\n  }\n\n  ppapi_proxy_ = ppapi_proxy.release();\n\n  find_adapter_.reset(new FindAdapter(this));\n  mouse_lock_adapter_.reset(new MouseLockAdapter(this));\n  printing_adapter_.reset(new PrintingAdapter(this));\n  selection_adapter_.reset(new SelectionAdapter(this));\n  widget_client_adapter_.reset(new WidgetClientAdapter(this));\n  zoom_adapter_.reset(new ZoomAdapter(this));\n\n  if (!view_to_replay_.is_null()) {\n    DidChangeView(view_to_replay_);\n    view_to_replay_ = pp::View();\n  }\n  if (!document_load_to_replay_.is_null()) {\n    HandleDocumentLoad(document_load_to_replay_);\n    document_load_to_replay_ = pp::URLLoader();\n  }\n  bool is_valid_proxy = BrowserPpp::is_valid(ppapi_proxy_);\n  PLUGIN_PRINTF((\"Plugin::StartProxiedExecution (is_valid_proxy=%d)\\n\",\n                 is_valid_proxy));\n  if (!is_valid_proxy) {\n    error_info->SetReport(ERROR_START_PROXY_CRASH,\n                          \"instance crashed after creation.\");\n  }\n  return is_valid_proxy;\n}\n",
        "output": "0",
        "index": 110348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}\n",
        "output": "0",
        "index": 85821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    UserCloudPolicyManagerFactoryChromeOS::CreateManagerForProfile(\n        Profile* profile,\n        bool force_immediate_load,\n        scoped_refptr<base::SequencedTaskRunner> background_task_runner) {\n  const CommandLine* command_line = CommandLine::ForCurrentProcess();\n  if (chromeos::ProfileHelper::IsSigninProfile(profile))\n    return scoped_ptr<UserCloudPolicyManagerChromeOS>();\n\n  chromeos::User* user =\n      chromeos::ProfileHelper::Get()->GetUserByProfile(profile);\n  CHECK(user);\n\n   const std::string& username = user->email();\n   if (user->GetType() != user_manager::USER_TYPE_REGULAR ||\n       BrowserPolicyConnector::IsNonEnterpriseUser(username)) {\n    return scoped_ptr<UserCloudPolicyManagerChromeOS>();\n  }\n\n   policy::BrowserPolicyConnectorChromeOS* connector =\n       g_browser_process->platform_part()->browser_policy_connector_chromeos();\n   UserAffiliation affiliation = connector->GetUserAffiliation(username);\n  const bool is_managed_user = affiliation == USER_AFFILIATION_MANAGED;\n   const bool is_browser_restart =\n       command_line->HasSwitch(chromeos::switches::kLoginUser);\n  const bool wait_for_initial_policy = is_managed_user && !is_browser_restart;\n \n   DeviceManagementService* device_management_service =\n       connector->device_management_service();\n  if (wait_for_initial_policy)\n    device_management_service->ScheduleInitialization(0);\n\n  base::FilePath profile_dir = profile->GetPath();\n  const base::FilePath legacy_dir = profile_dir.Append(kDeviceManagementDir);\n  const base::FilePath policy_cache_file = legacy_dir.Append(kPolicy);\n  const base::FilePath token_cache_file = legacy_dir.Append(kToken);\n  const base::FilePath component_policy_cache_dir =\n      profile_dir.Append(kPolicy).Append(kComponentsDir);\n  const base::FilePath external_data_dir =\n        profile_dir.Append(kPolicy).Append(kPolicyExternalDataDir);\n  base::FilePath policy_key_dir;\n  CHECK(PathService::Get(chromeos::DIR_USER_POLICY_KEYS, &policy_key_dir));\n\n  scoped_ptr<UserCloudPolicyStoreChromeOS> store(\n      new UserCloudPolicyStoreChromeOS(\n          chromeos::DBusThreadManager::Get()->GetCryptohomeClient(),\n          chromeos::DBusThreadManager::Get()->GetSessionManagerClient(),\n          background_task_runner,\n          username, policy_key_dir, token_cache_file, policy_cache_file));\n\n  scoped_refptr<base::SequencedTaskRunner> backend_task_runner =\n      content::BrowserThread::GetBlockingPool()->GetSequencedTaskRunner(\n          content::BrowserThread::GetBlockingPool()->GetSequenceToken());\n  scoped_refptr<base::SequencedTaskRunner> io_task_runner =\n      content::BrowserThread::GetMessageLoopProxyForThread(\n          content::BrowserThread::IO);\n  scoped_ptr<CloudExternalDataManager> external_data_manager(\n      new UserCloudExternalDataManager(base::Bind(&GetChromePolicyDetails),\n                                       backend_task_runner,\n                                       io_task_runner,\n                                       external_data_dir,\n                                       store.get()));\n  if (force_immediate_load)\n    store->LoadImmediately();\n\n  scoped_refptr<base::SequencedTaskRunner> file_task_runner =\n      content::BrowserThread::GetMessageLoopProxyForThread(\n          content::BrowserThread::FILE);\n\n  scoped_ptr<UserCloudPolicyManagerChromeOS> manager(\n      new UserCloudPolicyManagerChromeOS(\n          store.PassAs<CloudPolicyStore>(),\n           external_data_manager.Pass(),\n           component_policy_cache_dir,\n           wait_for_initial_policy,\n          base::TimeDelta::FromSeconds(kInitialPolicyFetchTimeoutSeconds),\n           base::MessageLoopProxy::current(),\n           file_task_runner,\n           io_task_runner));\n\n  bool wildcard_match = false;\n  if (connector->IsEnterpriseManaged() &&\n      chromeos::LoginUtils::IsWhitelisted(username, &wildcard_match) &&\n      wildcard_match &&\n      !connector->IsNonEnterpriseUser(username)) {\n    manager->EnableWildcardLoginCheck(username);\n  }\n\n  manager->Init(\n      SchemaRegistryServiceFactory::GetForContext(profile)->registry());\n  manager->Connect(g_browser_process->local_state(),\n                   device_management_service,\n                   g_browser_process->system_request_context(),\n                   affiliation);\n\n  DCHECK(managers_.find(profile) == managers_.end());\n  managers_[profile] = manager.get();\n  return manager.Pass();\n}\n",
        "output": "1",
        "index": 184842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qcow2_check_metadata_overlap(BlockDriverState *bs, int ign, int64_t offset,\n                                 int64_t size)\n{\n    BDRVQcowState *s = bs->opaque;\n    int chk = s->overlap_check & ~ign;\n    int i, j;\n\n    if (!size) {\n        return 0;\n    }\n\n    if (chk & QCOW2_OL_MAIN_HEADER) {\n        if (offset < s->cluster_size) {\n            return QCOW2_OL_MAIN_HEADER;\n        }\n    }\n\n    /* align range to test to cluster boundaries */\n    size = align_offset(offset_into_cluster(s, offset) + size, s->cluster_size);\n    offset = start_of_cluster(s, offset);\n\n    if ((chk & QCOW2_OL_ACTIVE_L1) && s->l1_size) {\n        if (overlaps_with(s->l1_table_offset, s->l1_size * sizeof(uint64_t))) {\n            return QCOW2_OL_ACTIVE_L1;\n        }\n    }\n\n    if ((chk & QCOW2_OL_REFCOUNT_TABLE) && s->refcount_table_size) {\n        if (overlaps_with(s->refcount_table_offset,\n            s->refcount_table_size * sizeof(uint64_t))) {\n            return QCOW2_OL_REFCOUNT_TABLE;\n        }\n    }\n\n    if ((chk & QCOW2_OL_SNAPSHOT_TABLE) && s->snapshots_size) {\n        if (overlaps_with(s->snapshots_offset, s->snapshots_size)) {\n            return QCOW2_OL_SNAPSHOT_TABLE;\n        }\n    }\n\n    if ((chk & QCOW2_OL_INACTIVE_L1) && s->snapshots) {\n        for (i = 0; i < s->nb_snapshots; i++) {\n            if (s->snapshots[i].l1_size &&\n                overlaps_with(s->snapshots[i].l1_table_offset,\n                s->snapshots[i].l1_size * sizeof(uint64_t))) {\n                return QCOW2_OL_INACTIVE_L1;\n            }\n        }\n    }\n\n    if ((chk & QCOW2_OL_ACTIVE_L2) && s->l1_table) {\n        for (i = 0; i < s->l1_size; i++) {\n            if ((s->l1_table[i] & L1E_OFFSET_MASK) &&\n                overlaps_with(s->l1_table[i] & L1E_OFFSET_MASK,\n                s->cluster_size)) {\n                return QCOW2_OL_ACTIVE_L2;\n            }\n        }\n    }\n\n    if ((chk & QCOW2_OL_REFCOUNT_BLOCK) && s->refcount_table) {\n        for (i = 0; i < s->refcount_table_size; i++) {\n            if ((s->refcount_table[i] & REFT_OFFSET_MASK) &&\n                overlaps_with(s->refcount_table[i] & REFT_OFFSET_MASK,\n                s->cluster_size)) {\n                return QCOW2_OL_REFCOUNT_BLOCK;\n            }\n        }\n    }\n\n    if ((chk & QCOW2_OL_INACTIVE_L2) && s->snapshots) {\n        for (i = 0; i < s->nb_snapshots; i++) {\n            uint64_t l1_ofs = s->snapshots[i].l1_table_offset;\n            uint32_t l1_sz  = s->snapshots[i].l1_size;\n            uint64_t l1_sz2 = l1_sz * sizeof(uint64_t);\n            uint64_t *l1 = g_malloc(l1_sz2);\n            int ret;\n\n            ret = bdrv_pread(bs->file, l1_ofs, l1, l1_sz2);\n            if (ret < 0) {\n                g_free(l1);\n                return ret;\n            }\n\n            for (j = 0; j < l1_sz; j++) {\n                uint64_t l2_ofs = be64_to_cpu(l1[j]) & L1E_OFFSET_MASK;\n                if (l2_ofs && overlaps_with(l2_ofs, s->cluster_size)) {\n                    g_free(l1);\n                    return QCOW2_OL_INACTIVE_L2;\n                }\n            }\n\n            g_free(l1);\n        }\n    }\n\n    return 0;\n}\n",
        "output": "0",
        "index": 16809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *virtqueue_pop(VirtQueue *vq, size_t sz)\n{\n    unsigned int i, head, max;\n    hwaddr desc_pa = vq->vring.desc;\n    VirtIODevice *vdev = vq->vdev;\n    VirtQueueElement *elem;\n    unsigned out_num, in_num;\n    hwaddr addr[VIRTQUEUE_MAX_SIZE];\n    struct iovec iov[VIRTQUEUE_MAX_SIZE];\n    VRingDesc desc;\n\n    if (virtio_queue_empty(vq)) {\n        return NULL;\n    }\n    /* Needed after virtio_queue_empty(), see comment in\n     * virtqueue_num_heads(). */\n    smp_rmb();\n\n    /* When we start there are none of either input nor output. */\n    out_num = in_num = 0;\n\n    max = vq->vring.num;\n\n    i = head = virtqueue_get_head(vq, vq->last_avail_idx++);\n    if (virtio_vdev_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX)) {\n        vring_set_avail_event(vq, vq->last_avail_idx);\n    }\n\n    vring_desc_read(vdev, &desc, desc_pa, i);\n    if (desc.flags & VRING_DESC_F_INDIRECT) {\n        if (desc.len % sizeof(VRingDesc)) {\n            error_report(\"Invalid size for indirect buffer table\");\n            exit(1);\n        }\n\n        /* loop over the indirect descriptor table */\n        max = desc.len / sizeof(VRingDesc);\n        desc_pa = desc.addr;\n        i = 0;\n        vring_desc_read(vdev, &desc, desc_pa, i);\n    }\n\n    /* Collect all the descriptors */\n    do {\n        if (desc.flags & VRING_DESC_F_WRITE) {\n            virtqueue_map_desc(&in_num, addr + out_num, iov + out_num,\n                               VIRTQUEUE_MAX_SIZE - out_num, true, desc.addr, desc.len);\n        } else {\n            if (in_num) {\n                error_report(\"Incorrect order for descriptors\");\n                exit(1);\n            }\n            virtqueue_map_desc(&out_num, addr, iov,\n                               VIRTQUEUE_MAX_SIZE, false, desc.addr, desc.len);\n        }\n\n        /* If we've got too many, that implies a descriptor loop. */\n        if ((in_num + out_num) > max) {\n            error_report(\"Looped descriptor\");\n            exit(1);\n        }\n    } while ((i = virtqueue_read_next_desc(vdev, &desc, desc_pa, max)) != max);\n\n    /* Now copy what we have collected and mapped */\n    elem = virtqueue_alloc_element(sz, out_num, in_num);\n    elem->index = head;\n    for (i = 0; i < out_num; i++) {\n        elem->out_addr[i] = addr[i];\n        elem->out_sg[i] = iov[i];\n    }\n    for (i = 0; i < in_num; i++) {\n        elem->in_addr[i] = addr[out_num + i];\n        elem->in_sg[i] = iov[out_num + i];\n    }\n\n    vq->inuse++;\n\n    trace_virtqueue_pop(vq, elem, elem->in_num, elem->out_num);\n    return elem;\n}\n",
        "output": "0",
        "index": 9260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vrend_create_sampler_view(struct vrend_context *ctx,\n                              uint32_t handle,\n                              uint32_t res_handle, uint32_t format,\n                              uint32_t val0, uint32_t val1, uint32_t swizzle_packed)\n{\n   struct vrend_sampler_view *view;\n   struct vrend_resource *res;\n   int ret_handle;\n   res = vrend_renderer_ctx_res_lookup(ctx, res_handle);\n   if (!res) {\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, res_handle);\n      return EINVAL;\n   }\n\n   view = CALLOC_STRUCT(vrend_sampler_view);\n   if (!view)\n      return ENOMEM;\n\n   pipe_reference_init(&view->reference, 1);\n   view->format = format;\n   view->val0 = val0;\n   view->val1 = val1;\n   view->swizzle_r = swizzle_packed & 0x7;\n   view->swizzle_g = (swizzle_packed >> 3) & 0x7;\n   view->swizzle_b = (swizzle_packed >> 6) & 0x7;\n   view->swizzle_a = (swizzle_packed >> 9) & 0x7;\n   view->cur_base = -1;\n   view->cur_max = 10000;\n\n   vrend_resource_reference(&view->texture, res);\n\n   view->srgb_decode = GL_DECODE_EXT;\n   if (view->format != view->texture->base.format) {\n      if (util_format_is_srgb(view->texture->base.format) &&\n          !util_format_is_srgb(view->format))\n         view->srgb_decode = GL_SKIP_DECODE_EXT;\n   }\n\n   view->gl_swizzle_a = to_gl_swizzle(view->swizzle_a);\n   view->gl_swizzle_r = to_gl_swizzle(view->swizzle_r);\n   view->gl_swizzle_g = to_gl_swizzle(view->swizzle_g);\n   view->gl_swizzle_b = to_gl_swizzle(view->swizzle_b);\n\n   if (!(util_format_has_alpha(format) || util_format_is_depth_or_stencil(format))) {\n       if (view->gl_swizzle_a == GL_ALPHA)\n           view->gl_swizzle_a = GL_ONE;\n       if (view->gl_swizzle_r == GL_ALPHA)\n           view->gl_swizzle_r = GL_ONE;\n       if (view->gl_swizzle_g == GL_ALPHA)\n           view->gl_swizzle_g = GL_ONE;\n       if (view->gl_swizzle_b == GL_ALPHA)\n           view->gl_swizzle_b = GL_ONE;\n   }\n\n   if (tex_conv_table[format].flags & VREND_BIND_NEED_SWIZZLE) {\n      view->gl_swizzle_r = to_gl_swizzle(tex_conv_table[format].swizzle[0]);\n      view->gl_swizzle_g = to_gl_swizzle(tex_conv_table[format].swizzle[1]);\n      view->gl_swizzle_b = to_gl_swizzle(tex_conv_table[format].swizzle[2]);\n      view->gl_swizzle_a = to_gl_swizzle(tex_conv_table[format].swizzle[3]);\n   }\n   ret_handle = vrend_renderer_object_insert(ctx, view, sizeof(*view), handle, VIRGL_OBJECT_SAMPLER_VIEW);\n   if (ret_handle == 0) {\n      FREE(view);\n      return ENOMEM;\n   }\n   return 0;\n}\n",
        "output": "0",
        "index": 8832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UWORD32 ih264d_correct_level_idc(UWORD32 u4_level_idc, UWORD32 u4_total_mbs)\n{\n    UWORD32 u4_max_mbs_allowed;\n\n switch(u4_level_idc)\n {\n case H264_LEVEL_1_0:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_10;\n break;\n case H264_LEVEL_1_1:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_11;\n break;\n case H264_LEVEL_1_2:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_12;\n break;\n case H264_LEVEL_1_3:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_13;\n break;\n case H264_LEVEL_2_0:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_20;\n break;\n case H264_LEVEL_2_1:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_21;\n break;\n case H264_LEVEL_2_2:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_22;\n break;\n case H264_LEVEL_3_0:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_30;\n break;\n case H264_LEVEL_3_1:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_31;\n break;\n case H264_LEVEL_3_2:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_32;\n break;\n case H264_LEVEL_4_0:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_40;\n break;\n case H264_LEVEL_4_1:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_41;\n break;\n case H264_LEVEL_4_2:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_42;\n break;\n case H264_LEVEL_5_0:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_50;\n break;\n case H264_LEVEL_5_1:\n default:\n            u4_max_mbs_allowed = MAX_MBS_LEVEL_51;\n break;\n\n }\n\n /*correct of the level is incorrect*/\n if(u4_total_mbs > u4_max_mbs_allowed)\n {\n if(u4_total_mbs > MAX_MBS_LEVEL_50)\n            u4_level_idc = H264_LEVEL_5_1;\n else if(u4_total_mbs > MAX_MBS_LEVEL_42)\n            u4_level_idc = H264_LEVEL_5_0;\n else if(u4_total_mbs > MAX_MBS_LEVEL_41)\n            u4_level_idc = H264_LEVEL_4_2;\n else if(u4_total_mbs > MAX_MBS_LEVEL_40)\n            u4_level_idc = H264_LEVEL_4_1;\n else if(u4_total_mbs > MAX_MBS_LEVEL_32)\n            u4_level_idc = H264_LEVEL_4_0;\n else if(u4_total_mbs > MAX_MBS_LEVEL_31)\n            u4_level_idc = H264_LEVEL_3_2;\n else if(u4_total_mbs > MAX_MBS_LEVEL_30)\n            u4_level_idc = H264_LEVEL_3_1;\n else if(u4_total_mbs > MAX_MBS_LEVEL_21)\n            u4_level_idc = H264_LEVEL_3_0;\n else if(u4_total_mbs > MAX_MBS_LEVEL_20)\n            u4_level_idc = H264_LEVEL_2_1;\n else if(u4_total_mbs > MAX_MBS_LEVEL_10)\n            u4_level_idc = H264_LEVEL_2_0;\n }\n\n return (u4_level_idc);\n\n}\n",
        "output": "0",
        "index": 172725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TEE_Result umap_add_region(struct vm_info *vmi, struct vm_region *reg)\n{\n\tstruct vm_region *r;\n\tstruct vm_region *prev_r;\n\tvaddr_t va_range_base;\n\tsize_t va_range_size;\n\tvaddr_t va;\n\n\tcore_mmu_get_user_va_range(&va_range_base, &va_range_size);\n\n\t/* Check alignment, it has to be at least SMALL_PAGE based */\n\tif ((reg->va | reg->size) & SMALL_PAGE_MASK)\n\t\treturn TEE_ERROR_ACCESS_CONFLICT;\n\n\t/* Check that the mobj is defined for the entire range */\n\tif ((reg->offset + reg->size) >\n\t     ROUNDUP(reg->mobj->size, SMALL_PAGE_SIZE))\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tprev_r = NULL;\n\tTAILQ_FOREACH(r, &vmi->regions, link) {\n\t\tif (TAILQ_FIRST(&vmi->regions) == r) {\n\t\t\tva = select_va_in_range(va_range_base, 0,\n\t\t\t\t\t\tr->va, r->attr, reg);\n\t\t\tif (va) {\n\t\t\t\treg->va = va;\n\t\t\t\tTAILQ_INSERT_HEAD(&vmi->regions, reg, link);\n\t\t\t\treturn TEE_SUCCESS;\n\t\t\t}\n\t\t} else {\n\t\t\tva = select_va_in_range(prev_r->va + prev_r->size,\n\t\t\t\t\t\tprev_r->attr, r->va, r->attr,\n\t\t\t\t\t\treg);\n\t\t\tif (va) {\n\t\t\t\treg->va = va;\n\t\t\t\tTAILQ_INSERT_BEFORE(r, reg, link);\n\t\t\t\treturn TEE_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tprev_r = r;\n\t}\n\n\tr = TAILQ_LAST(&vmi->regions, vm_region_head);\n\tif (r) {\n\t\tva = select_va_in_range(r->va + r->size, r->attr,\n\t\t\t\t\tva_range_base + va_range_size, 0, reg);\n\t\tif (va) {\n\t\t\treg->va = va;\n\t\t\tTAILQ_INSERT_TAIL(&vmi->regions, reg, link);\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t} else {\n\t\tva = select_va_in_range(va_range_base, 0,\n\t\t\t\t\tva_range_base + va_range_size, 0, reg);\n\t\tif (va) {\n\t\t\treg->va = va;\n\t\t\tTAILQ_INSERT_HEAD(&vmi->regions, reg, link);\n\t\t\treturn TEE_SUCCESS;\n\t\t}\n\t}\n\n\treturn TEE_ERROR_ACCESS_CONFLICT;\n}\n",
        "output": "0",
        "index": 86984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sdp_snd_service_search_req(tCONN_CB* p_ccb, uint8_t cont_len,\n uint8_t* p_cont) {\n uint8_t *p, *p_start, *p_param_len;\n  BT_HDR* p_cmd = (BT_HDR*)osi_malloc(SDP_DATA_BUF_SIZE);\n uint16_t param_len;\n\n /* Prepare the buffer for sending the packet to L2CAP */\n  p_cmd->offset = L2CAP_MIN_OFFSET;\n  p = p_start = (uint8_t*)(p_cmd + 1) + L2CAP_MIN_OFFSET;\n\n /* Build a service search request packet */\n  UINT8_TO_BE_STREAM(p, SDP_PDU_SERVICE_SEARCH_REQ);\n  UINT16_TO_BE_STREAM(p, p_ccb->transaction_id);\n  p_ccb->transaction_id++;\n\n /* Skip the length, we need to add it at the end */\n  p_param_len = p;\n  p += 2;\n\n/* Build the UID sequence. */\n#if (SDP_BROWSE_PLUS == TRUE)\n  p = sdpu_build_uuid_seq(p, 1,\n &p_ccb->p_db->uuid_filters[p_ccb->cur_uuid_idx]);\n#else\n  p = sdpu_build_uuid_seq(p, p_ccb->p_db->num_uuid_filters,\n                          p_ccb->p_db->uuid_filters);\n#endif\n\n /* Set max service record count */\n  UINT16_TO_BE_STREAM(p, sdp_cb.max_recs_per_search);\n\n /* Set continuation state */\n  UINT8_TO_BE_STREAM(p, cont_len);\n\n /* if this is not the first request */\n if (cont_len && p_cont) {\n    memcpy(p, p_cont, cont_len);\n    p += cont_len;\n }\n\n /* Go back and put the parameter length into the buffer */\n  param_len = (uint16_t)(p - p_param_len - 2);\n  UINT16_TO_BE_STREAM(p_param_len, param_len);\n\n  p_ccb->disc_state = SDP_DISC_WAIT_HANDLES;\n\n /* Set the length of the SDP data in the buffer */\n  p_cmd->len = (uint16_t)(p - p_start);\n\n#if (SDP_DEBUG_RAW == TRUE)\n  SDP_TRACE_WARNING(\"sdp_snd_service_search_req cont_len :%d disc_state:%d\",\n                    cont_len, p_ccb->disc_state);\n#endif\n\n  L2CA_DataWrite(p_ccb->connection_id, p_cmd);\n\n /* Start inactivity timer */\n  alarm_set_on_mloop(p_ccb->sdp_conn_timer, SDP_INACT_TIMEOUT_MS,\n                     sdp_conn_timer_timeout, p_ccb);\n}\n",
        "output": "0",
        "index": 176078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType GetMultilineTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics)\n{\n  char\n    **textlist;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (*draw_info->text == '\\0')\n    return(MagickFalse);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->text=DestroyString(annotate_info->text);\n  /*\n    Convert newlines to multiple lines of text.\n  */\n  textlist=StringToList(draw_info->text);\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  (void) memset(&extent,0,sizeof(extent));\n  /*\n    Find the widest of the text lines.\n  */\n  annotate_info->text=textlist[0];\n  status=GetTypeMetrics(image,annotate_info,&extent);\n  *metrics=extent;\n  for (i=1; textlist[i] != (char *) NULL; i++)\n  {\n    annotate_info->text=textlist[i];\n    status=GetTypeMetrics(image,annotate_info,&extent);\n    if (extent.width > metrics->width)\n      *metrics=extent;\n  }\n  metrics->height=(double) (i*(size_t) (metrics->ascent-metrics->descent+0.5)+\n    (i-1)*draw_info->interline_spacing);\n  /*\n    Relinquish resources.\n  */\n  annotate_info->text=(char *) NULL;\n  annotate_info=DestroyDrawInfo(annotate_info);\n  for (i=0; textlist[i] != (char *) NULL; i++)\n    textlist[i]=DestroyString(textlist[i]);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n",
        "output": "0",
        "index": 88872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,\n\t\t\tunsigned int _der_len, unsigned char **str,\n\t\t\tunsigned int *str_len, unsigned int *ber_len)\n{\n  int tag_len, len_len;\n  const unsigned char *p;\n  int der_len = _der_len;\n  uint8_t *total = NULL;\n  unsigned total_size = 0;\n  unsigned char class;\n  unsigned long tag;\n  unsigned char *out = NULL;\n  unsigned out_len;\n  long ret;\n\n  if (ber_len) *ber_len = 0;\n\n  if (der == NULL || der_len == 0)\n    {\n      warn();\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  if (ETYPE_OK (etype) == 0)\n    {\n      warn();\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  /* doesn't handle constructed classes */\n  if (ETYPE_CLASS (etype) != ASN1_CLASS_UNIVERSAL)\n    {\n      warn();\n      return ASN1_VALUE_NOT_VALID;\n    }\n\n  p = der;\n  ret = asn1_get_tag_der (p, der_len, &class, &tag_len, &tag);\n  if (ret != ASN1_SUCCESS)\n    {\n      warn();\n      return ret;\n    }\n\n  if (ber_len) *ber_len += tag_len;\n\n  if (tag != ETYPE_TAG (etype))\n    {\n      warn();\n      return ASN1_DER_ERROR;\n    }\n\n  p += tag_len;\n  der_len -= tag_len;\n  if (der_len <= 0)\n    return ASN1_DER_ERROR;\n\n  if (class == ASN1_CLASS_STRUCTURED && ETYPE_IS_STRING(etype))\n    {\n\n      len_len = 1;\n      if (p[0] != 0x80)\n        {\n          warn();\n          return ASN1_DER_ERROR;\n        }\n\n      p += len_len;\n      der_len -= len_len;\n      if (der_len <= 0)\n        return ASN1_DER_ERROR;\n\n      if (ber_len) *ber_len += len_len;\n\n      /* decode the available octet strings */\n      do\n        {\n          unsigned tmp_len;\n\n          ret = asn1_decode_simple_ber(etype, p, der_len, &out, &out_len, &tmp_len);\n          if (ret != ASN1_SUCCESS)\n            {\n              free(total);\n              return ret;\n            }\n          p += tmp_len;\n          der_len -= tmp_len;\n          if (ber_len) *ber_len += tmp_len;\n\n          if (der_len < 2) /* we need the EOC */\n            {\n              free(total);\n              return ASN1_DER_ERROR;\n            }\n\n\t  if (out_len > 0)\n\t    {\n              ret = append(&total, &total_size, out, out_len);\n              free(out);\n              if (ret != ASN1_SUCCESS)\n                {\n                  free(total);\n                  return ret;\n                }\n\t    }\n\n\t  if (p[0] == 0 && p[1] == 0) /* EOC */\n\t    {\n              if (ber_len) *ber_len += 2;\n  \t      break;\n  \t    }\n        }\n      while(1);\n    }\n  else if (class == ETYPE_CLASS(etype))\n    {\n      if (ber_len)\n        {\n          ret = asn1_get_length_der (p, der_len, &len_len);\n          if (ret < 0)\n            {\n              warn();\n              return ASN1_DER_ERROR;\n            }\n          *ber_len += ret + len_len;\n        }\n\n      /* non-string values are decoded as DER */\n      ret = asn1_decode_simple_der(etype, der, _der_len, (const unsigned char**)&out, &out_len);\n      if (ret != ASN1_SUCCESS)\n        return ret;\n\n      ret = append(&total, &total_size, out, out_len);\n      if (ret != ASN1_SUCCESS)\n        return ret;\n    }\n  else\n    return ASN1_DER_ERROR;\n\n  *str = total;\n  *str_len = total_size;\n\n  return ASN1_SUCCESS;\n}\n",
        "output": "0",
        "index": 11280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_reload(Cache* cache)\n{\n    GSList* l;\n    char buf[38];\n    int i;\n    GFile* gf;\n\n    int new_n_files;\n    char **new_files = NULL;\n\n    /* DEBUG(\"Re-generation of cache is needed!\"); */\n    /* DEBUG(\"call menu-cache-gen to re-generate the cache\"); */\n    memcpy( buf, \"REL:\", 4 );\n    memcpy( buf + 4, cache->md5, 32 );\n    buf[36] = '\\n';\n    buf[37] = '\\0';\n\n    if( ! regenerate_cache( cache->menu_name, cache->lang_name, cache->cache_file,\n                            cache->env, &new_n_files, &new_files ) )\n    {\n        DEBUG(\"regeneration of cache failed.\");\n        return;\n    }\n\n    /* cancel old file monitors */\n    g_strfreev(cache->files);\n    for( i = 0; i < cache->n_files; ++i )\n    {\n        g_file_monitor_cancel( cache->mons[i] );\n        g_signal_handlers_disconnect_by_func( cache->mons[i], on_file_changed, cache );\n        g_object_unref( cache->mons[i] );\n    }\n/*\n    g_file_monitor_cancel(cache->cache_mon);\n    g_object_unref(cache->cache_mon);\n*/\n\n    cache->n_files = new_n_files;\n    cache->files = new_files;\n\n    cache->mons = g_realloc( cache->mons, sizeof(GFileMonitor*)*(cache->n_files+1) );\n    /* create required file monitors */\n    for( i = 0; i < cache->n_files; ++i )\n    {\n        gf = g_file_new_for_path( cache->files[i] + 1 );\n        if( cache->files[i][0] == 'D' )\n            cache->mons[i] = g_file_monitor_directory( gf, 0, NULL, NULL );\n        else\n            cache->mons[i] = g_file_monitor_file( gf, 0, NULL, NULL );\n        g_signal_connect(cache->mons[i], \"changed\",\n                         G_CALLBACK(on_file_changed), cache);\n        g_object_unref(gf);\n    }\n/*\n    gf = g_file_new_for_path( cache_file );\n    cache->cache_mon = g_file_monitor_file( gf, 0, NULL, NULL );\n    g_signal_connect( cache->cache_mon, \"changed\", on_file_changed, cache);\n    g_object_unref(gf);\n*/\n\n    /* notify the clients that reload is needed. */\n    for( l = cache->clients; l; )\n    {\n        ClientIO *channel_io = (ClientIO *)l->data;\n        GIOChannel* ch = channel_io->channel;\n        l = l->next; /* do it beforehand, as client may be removed below */\n        if(write(g_io_channel_unix_get_fd(ch), buf, 37) < 37)\n        {\n            on_client_closed(channel_io);\n        }\n    }\n    cache->need_reload = FALSE;\n}\n",
        "output": "0",
        "index": 6467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {\n\tint error;\n\tchar addrbuf[128];\n\tstatic const int error_codes[] = {\n\t\tDNS_ERR_FORMAT, DNS_ERR_SERVERFAILED, DNS_ERR_NOTEXIST,\n\t\tDNS_ERR_NOTIMPL, DNS_ERR_REFUSED\n\t};\n\n\tASSERT_LOCKED(req->base);\n\tASSERT_VALID_REQUEST(req);\n\n\tif (flags & 0x020f || !reply || !reply->have_answer) {\n\t\t/* there was an error */\n\t\tif (flags & 0x0200) {\n\t\t\terror = DNS_ERR_TRUNCATED;\n\t\t} else if (flags & 0x000f) {\n\t\t\tu16 error_code = (flags & 0x000f) - 1;\n\t\t\tif (error_code > 4) {\n\t\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t\t} else {\n\t\t\t\terror = error_codes[error_code];\n\t\t\t}\n\t\t} else if (reply && !reply->have_answer) {\n\t\t\terror = DNS_ERR_NODATA;\n\t\t} else {\n\t\t\terror = DNS_ERR_UNKNOWN;\n\t\t}\n\n\t\tswitch (error) {\n\t\tcase DNS_ERR_NOTIMPL:\n\t\tcase DNS_ERR_REFUSED:\n\t\t\t/* we regard these errors as marking a bad nameserver */\n\t\t\tif (req->reissue_count < req->base->global_max_reissues) {\n\t\t\t\tchar msg[64];\n\t\t\t\tevutil_snprintf(msg, sizeof(msg), \"Bad response %d (%s)\",\n\t\t\t\t\t error, evdns_err_to_string(error));\n\t\t\t\tnameserver_failed(req->ns, msg);\n\t\t\t\tif (!request_reissue(req)) return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DNS_ERR_SERVERFAILED:\n\t\t\t/* rcode 2 (servfailed) sometimes means \"we\n\t\t\t * are broken\" and sometimes (with some binds)\n\t\t\t * means \"that request was very confusing.\"\n\t\t\t * Treat this as a timeout, not a failure.\n\t\t\t */\n\t\t\tlog(EVDNS_LOG_DEBUG, \"Got a SERVERFAILED from nameserver\"\n\t\t\t\t\"at %s; will allow the request to time out.\",\n\t\t\t    evutil_format_sockaddr_port_(\n\t\t\t\t    (struct sockaddr *)&req->ns->address,\n\t\t\t\t    addrbuf, sizeof(addrbuf)));\n\t\t\t/* Call the timeout function */\n\t\t\tevdns_request_timeout_callback(0, 0, req);\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* we got a good reply from the nameserver: it is up. */\n\t\t\tif (req->handle == req->ns->probe_request) {\n\t\t\t\t/* Avoid double-free */\n\t\t\t\treq->ns->probe_request = NULL;\n\t\t\t}\n\n\t\t\tnameserver_up(req->ns);\n\t\t}\n\n\t\tif (req->handle->search_state &&\n\t\t    req->request_type != TYPE_PTR) {\n\t\t\t/* if we have a list of domains to search in,\n\t\t\t * try the next one */\n\t\t\tif (!search_try_next(req->handle)) {\n\t\t\t\t/* a new request was issued so this\n\t\t\t\t * request is finished and */\n\t\t\t\t/* the user callback will be made when\n\t\t\t\t * that request (or a */\n\t\t\t\t/* child of it) finishes. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/* all else failed. Pass the failure up */\n\t\treply_schedule_callback(req, ttl, error, NULL);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t} else {\n\t\t/* all ok, tell the user */\n\t\treply_schedule_callback(req, ttl, 0, reply);\n\t\tif (req->handle == req->ns->probe_request)\n\t\t\treq->ns->probe_request = NULL; /* Avoid double-free */\n\t\tnameserver_up(req->ns);\n\t\trequest_finished(req, &REQ_HEAD(req->base, req->trans_id), 1);\n\t}\n}\n",
        "output": "0",
        "index": 70672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "output": "1",
        "index": 180772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool supportsInvalidation(CSSSelector::PseudoType type)\n{\n    switch (type) {\n    case CSSSelector::PseudoEmpty:\n    case CSSSelector::PseudoFirstChild:\n    case CSSSelector::PseudoFirstOfType:\n    case CSSSelector::PseudoLastChild:\n    case CSSSelector::PseudoLastOfType:\n    case CSSSelector::PseudoOnlyChild:\n    case CSSSelector::PseudoOnlyOfType:\n    case CSSSelector::PseudoNthChild:\n    case CSSSelector::PseudoNthOfType:\n    case CSSSelector::PseudoNthLastChild:\n    case CSSSelector::PseudoNthLastOfType:\n    case CSSSelector::PseudoLink:\n    case CSSSelector::PseudoVisited:\n    case CSSSelector::PseudoAny:\n    case CSSSelector::PseudoAnyLink:\n    case CSSSelector::PseudoAutofill:\n    case CSSSelector::PseudoHover:\n    case CSSSelector::PseudoDrag:\n    case CSSSelector::PseudoFocus:\n    case CSSSelector::PseudoActive:\n    case CSSSelector::PseudoChecked:\n    case CSSSelector::PseudoEnabled:\n    case CSSSelector::PseudoFullPageMedia:\n    case CSSSelector::PseudoDefault:\n    case CSSSelector::PseudoDisabled:\n    case CSSSelector::PseudoOptional:\n    case CSSSelector::PseudoPlaceholderShown:\n    case CSSSelector::PseudoRequired:\n    case CSSSelector::PseudoReadOnly:\n    case CSSSelector::PseudoReadWrite:\n    case CSSSelector::PseudoValid:\n    case CSSSelector::PseudoInvalid:\n    case CSSSelector::PseudoIndeterminate:\n    case CSSSelector::PseudoTarget:\n    case CSSSelector::PseudoBefore:\n    case CSSSelector::PseudoAfter:\n    case CSSSelector::PseudoBackdrop:\n    case CSSSelector::PseudoLang:\n    case CSSSelector::PseudoNot:\n    case CSSSelector::PseudoResizer:\n    case CSSSelector::PseudoRoot:\n    case CSSSelector::PseudoScope:\n    case CSSSelector::PseudoScrollbar:\n    case CSSSelector::PseudoScrollbarButton:\n    case CSSSelector::PseudoScrollbarCorner:\n    case CSSSelector::PseudoScrollbarThumb:\n    case CSSSelector::PseudoScrollbarTrack:\n    case CSSSelector::PseudoScrollbarTrackPiece:\n    case CSSSelector::PseudoWindowInactive:\n    case CSSSelector::PseudoSelection:\n    case CSSSelector::PseudoCornerPresent:\n    case CSSSelector::PseudoDecrement:\n    case CSSSelector::PseudoIncrement:\n    case CSSSelector::PseudoHorizontal:\n    case CSSSelector::PseudoVertical:\n    case CSSSelector::PseudoStart:\n    case CSSSelector::PseudoEnd:\n    case CSSSelector::PseudoDoubleButton:\n    case CSSSelector::PseudoSingleButton:\n    case CSSSelector::PseudoNoButton:\n    case CSSSelector::PseudoFullScreen:\n    case CSSSelector::PseudoFullScreenAncestor:\n    case CSSSelector::PseudoInRange:\n    case CSSSelector::PseudoOutOfRange:\n    case CSSSelector::PseudoWebKitCustomElement:\n    case CSSSelector::PseudoCue:\n    case CSSSelector::PseudoFutureCue:\n    case CSSSelector::PseudoPastCue:\n    case CSSSelector::PseudoUnresolved:\n    case CSSSelector::PseudoContent:\n    case CSSSelector::PseudoHost:\n    case CSSSelector::PseudoShadow:\n    case CSSSelector::PseudoSpatialNavigationFocus:\n    case CSSSelector::PseudoListBox:\n        return true;\n    case CSSSelector::PseudoUnknown:\n    case CSSSelector::PseudoLeftPage:\n    case CSSSelector::PseudoRightPage:\n    case CSSSelector::PseudoFirstPage:\n        ASSERT_NOT_REACHED();\n        return false;\n    default:\n        ASSERT_NOT_REACHED();\n        return false;\n    }\n}\n",
        "output": "0",
        "index": 130335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DelegatedFrameHost::CopyFromCompositingSurfaceHasResultForVideo(\n    base::WeakPtr<DelegatedFrameHost> dfh,\n    scoped_refptr<OwnedMailbox> subscriber_texture,\n    scoped_refptr<media::VideoFrame> video_frame,\n    const base::Callback<void(bool)>& callback,\n    scoped_ptr<cc::CopyOutputResult> result) {\n  base::ScopedClosureRunner scoped_callback_runner(base::Bind(callback, false));\n  base::ScopedClosureRunner scoped_return_subscriber_texture(\n      base::Bind(&ReturnSubscriberTexture, dfh, subscriber_texture, 0));\n\n  if (!dfh)\n    return;\n  if (result->IsEmpty())\n    return;\n  if (result->size().IsEmpty())\n    return;\n\n  gfx::Rect region_in_frame =\n      media::ComputeLetterboxRegion(gfx::Rect(video_frame->coded_size()),\n                                    result->size());\n  region_in_frame = gfx::Rect(region_in_frame.x() & ~1,\n                              region_in_frame.y() & ~1,\n                              region_in_frame.width() & ~1,\n                              region_in_frame.height() & ~1);\n  if (region_in_frame.IsEmpty())\n    return;\n\n  if (!result->HasTexture()) {\n    DCHECK(result->HasBitmap());\n    scoped_ptr<SkBitmap> bitmap = result->TakeBitmap();\n    SkBitmap scaled_bitmap;\n    if (result->size().width() != region_in_frame.width() ||\n        result->size().height() != region_in_frame.height()) {\n      skia::ImageOperations::ResizeMethod method =\n          skia::ImageOperations::RESIZE_GOOD;\n      scaled_bitmap = skia::ImageOperations::Resize(*bitmap.get(), method,\n                                                    region_in_frame.width(),\n                                                    region_in_frame.height());\n    } else {\n      scaled_bitmap = *bitmap.get();\n    }\n\n    {\n      SkAutoLockPixels scaled_bitmap_locker(scaled_bitmap);\n\n      media::CopyRGBToVideoFrame(\n          reinterpret_cast<uint8*>(scaled_bitmap.getPixels()),\n          scaled_bitmap.rowBytes(),\n          region_in_frame,\n          video_frame.get());\n    }\n    ignore_result(scoped_callback_runner.Release());\n    callback.Run(true);\n    return;\n  }\n\n  ImageTransportFactory* factory = ImageTransportFactory::GetInstance();\n  GLHelper* gl_helper = factory->GetGLHelper();\n  if (!gl_helper)\n    return;\n  if (subscriber_texture.get() && !subscriber_texture->texture_id())\n    return;\n\n  cc::TextureMailbox texture_mailbox;\n  scoped_ptr<cc::SingleReleaseCallback> release_callback;\n  result->TakeTexture(&texture_mailbox, &release_callback);\n  DCHECK(texture_mailbox.IsTexture());\n\n  gfx::Rect result_rect(result->size());\n\n  content::ReadbackYUVInterface* yuv_readback_pipeline =\n      dfh->yuv_readback_pipeline_.get();\n  if (yuv_readback_pipeline == NULL ||\n      yuv_readback_pipeline->scaler()->SrcSize() != result_rect.size() ||\n      yuv_readback_pipeline->scaler()->SrcSubrect() != result_rect ||\n      yuv_readback_pipeline->scaler()->DstSize() != region_in_frame.size()) {\n    GLHelper::ScalerQuality quality = GLHelper::SCALER_QUALITY_FAST;\n    std::string quality_switch = switches::kTabCaptureDownscaleQuality;\n    if (result_rect.size().width() < region_in_frame.size().width() &&\n        result_rect.size().height() < region_in_frame.size().height())\n      quality_switch = switches::kTabCaptureUpscaleQuality;\n\n    std::string switch_value =\n        CommandLine::ForCurrentProcess()->GetSwitchValueASCII(quality_switch);\n    if (switch_value == \"fast\")\n      quality = GLHelper::SCALER_QUALITY_FAST;\n    else if (switch_value == \"good\")\n      quality = GLHelper::SCALER_QUALITY_GOOD;\n    else if (switch_value == \"best\")\n      quality = GLHelper::SCALER_QUALITY_BEST;\n\n    dfh->yuv_readback_pipeline_.reset(\n        gl_helper->CreateReadbackPipelineYUV(quality,\n                                             result_rect.size(),\n                                             result_rect,\n                                             video_frame->coded_size(),\n                                             region_in_frame,\n                                             true,\n                                             true));\n    yuv_readback_pipeline = dfh->yuv_readback_pipeline_.get();\n  }\n\n  ignore_result(scoped_callback_runner.Release());\n  ignore_result(scoped_return_subscriber_texture.Release());\n  base::Callback<void(bool result)> finished_callback = base::Bind(\n      &DelegatedFrameHost::CopyFromCompositingSurfaceFinishedForVideo,\n      dfh->AsWeakPtr(),\n      callback,\n      subscriber_texture,\n      base::Passed(&release_callback));\n  yuv_readback_pipeline->ReadbackYUV(texture_mailbox.mailbox(),\n                                     texture_mailbox.sync_point(),\n                                     video_frame.get(),\n                                     finished_callback);\n}\n",
        "output": "0",
        "index": 119977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kioctx *ioctx_alloc(unsigned nr_events)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx;\n\tint err = -ENOMEM;\n\n\t/*\n\t * We keep track of the number of available ringbuffer slots, to prevent\n\t * overflow (reqs_available), and we also use percpu counters for this.\n\t *\n\t * So since up to half the slots might be on other cpu's percpu counters\n\t * and unavailable, double nr_events so userspace sees what they\n\t * expected: additionally, we move req_batch slots to/from percpu\n\t * counters at a time, so make sure that isn't 0:\n\t */\n\tnr_events = max(nr_events, num_possible_cpus() * 4);\n\tnr_events *= 2;\n\n\t/* Prevent overflows */\n\tif ((nr_events > (0x10000000U / sizeof(struct io_event))) ||\n\t    (nr_events > (0x10000000U / sizeof(struct kiocb)))) {\n\t\tpr_debug(\"ENOMEM: nr_events too high\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_events || (unsigned long)nr_events > (aio_max_nr * 2UL))\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_reqs = nr_events;\n\n\tif (percpu_ref_init(&ctx->users, free_ioctx_users))\n\t\tgoto err;\n\n\tif (percpu_ref_init(&ctx->reqs, free_ioctx_reqs))\n\t\tgoto err;\n\n\tspin_lock_init(&ctx->ctx_lock);\n\tspin_lock_init(&ctx->completion_lock);\n\tmutex_init(&ctx->ring_lock);\n\tinit_waitqueue_head(&ctx->wait);\n\n\tINIT_LIST_HEAD(&ctx->active_reqs);\n\n\tctx->cpu = alloc_percpu(struct kioctx_cpu);\n\tif (!ctx->cpu)\n\t\tgoto err;\n\n\tif (aio_setup_ring(ctx) < 0)\n\t\tgoto err;\n\n\tatomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n\tctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);\n\tif (ctx->req_batch < 1)\n\t\tctx->req_batch = 1;\n\n\t/* limit the number of system wide aios */\n\tspin_lock(&aio_nr_lock);\n\tif (aio_nr + nr_events > (aio_max_nr * 2UL) ||\n\t    aio_nr + nr_events < aio_nr) {\n\t\tspin_unlock(&aio_nr_lock);\n\t\terr = -EAGAIN;\n\t\tgoto err;\n\t}\n\taio_nr += ctx->max_reqs;\n\tspin_unlock(&aio_nr_lock);\n\n\tpercpu_ref_get(&ctx->users); /* io_setup() will drop this ref */\n\n\terr = ioctx_add_table(ctx, mm);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\tpr_debug(\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\",\n\t\t ctx, ctx->user_id, mm, ctx->nr_events);\n\treturn ctx;\n\n err_cleanup:\n \taio_nr_sub(ctx->max_reqs);\n err:\n\taio_free_ring(ctx);\n \tfree_percpu(ctx->cpu);\n \tfree_percpu(ctx->reqs.pcpu_count);\n \tfree_percpu(ctx->users.pcpu_count);\n\tkmem_cache_free(kioctx_cachep, ctx);\n\tpr_debug(\"error allocating ioctx %d\\n\", err);\n\treturn ERR_PTR(err);\n}\n",
        "output": "1",
        "index": 179640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfn_t hva_to_pfn(struct kvm *kvm, unsigned long addr, bool atomic,\n\t\t\tbool *async, bool write_fault, bool *writable)\n{\n\tstruct page *page[1];\n\tint npages = 0;\n\tpfn_t pfn;\n\n\t/* we can do it either atomically or asynchronously, not both */\n\tBUG_ON(atomic && async);\n\n\tBUG_ON(!write_fault && !writable);\n\n\tif (writable)\n\t\t*writable = true;\n\n\tif (atomic || async)\n\t\tnpages = __get_user_pages_fast(addr, 1, 1, page);\n\n\tif (unlikely(npages != 1) && !atomic) {\n\t\tmight_sleep();\n\n\t\tif (writable)\n\t\t\t*writable = write_fault;\n\n\t\tif (async) {\n\t\t\tdown_read(&current->mm->mmap_sem);\n\t\t\tnpages = get_user_page_nowait(current, current->mm,\n\t\t\t\t\t\t     addr, write_fault, page);\n\t\t\tup_read(&current->mm->mmap_sem);\n\t\t} else\n\t\t\tnpages = get_user_pages_fast(addr, 1, write_fault,\n\t\t\t\t\t\t     page);\n\n\t\t/* map read fault as writable if possible */\n\t\tif (unlikely(!write_fault) && npages == 1) {\n\t\t\tstruct page *wpage[1];\n\n\t\t\tnpages = __get_user_pages_fast(addr, 1, 1, wpage);\n\t\t\tif (npages == 1) {\n\t\t\t\t*writable = true;\n\t\t\t\tput_page(page[0]);\n\t\t\t\tpage[0] = wpage[0];\n\t\t\t}\n\t\t\tnpages = 1;\n\t\t}\n\t}\n\n\tif (unlikely(npages != 1)) {\n\t\tstruct vm_area_struct *vma;\n\n\t\tif (atomic)\n\t\t\treturn get_fault_pfn();\n\n\t\tdown_read(&current->mm->mmap_sem);\n\t\tif (npages == -EHWPOISON ||\n\t\t\t(!async && check_user_page_hwpoison(addr))) {\n\t\t\tup_read(&current->mm->mmap_sem);\n\t\t\tget_page(hwpoison_page);\n\t\t\treturn page_to_pfn(hwpoison_page);\n\t\t}\n\n\t\tvma = find_vma_intersection(current->mm, addr, addr+1);\n\n\t\tif (vma == NULL)\n\t\t\tpfn = get_fault_pfn();\n\t\telse if ((vma->vm_flags & VM_PFNMAP)) {\n\t\t\tpfn = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\t\tvma->vm_pgoff;\n\t\t\tBUG_ON(!kvm_is_mmio_pfn(pfn));\n\t\t} else {\n\t\t\tif (async && (vma->vm_flags & VM_WRITE))\n\t\t\t\t*async = true;\n\t\t\tpfn = get_fault_pfn();\n\t\t}\n\t\tup_read(&current->mm->mmap_sem);\n\t} else\n\t\tpfn = page_to_pfn(page[0]);\n\n\treturn pfn;\n}\n",
        "output": "0",
        "index": 20323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PassRefPtr<CSSValueList> getBorderRadiusShorthandValue(const RenderStyle* style, RenderView* renderView)\n{\n    RefPtr<CSSValueList> list = CSSValueList::createSlashSeparated();\n    bool showHorizontalBottomLeft = style->borderTopRightRadius().width() != style->borderBottomLeftRadius().width();\n    bool showHorizontalBottomRight = style->borderBottomRightRadius().width() != style->borderTopLeftRadius().width();\n    bool showHorizontalTopRight = style->borderTopRightRadius().width() != style->borderTopLeftRadius().width();\n\n    bool showVerticalBottomLeft = style->borderTopRightRadius().height() != style->borderBottomLeftRadius().height();\n    bool showVerticalBottomRight = (style->borderBottomRightRadius().height() != style->borderTopLeftRadius().height()) || showVerticalBottomLeft;\n    bool showVerticalTopRight = (style->borderTopRightRadius().height() != style->borderTopLeftRadius().height()) || showVerticalBottomRight;\n    bool showVerticalTopLeft = (style->borderTopLeftRadius().width() != style->borderTopLeftRadius().height());\n\n    RefPtr<CSSValueList> topLeftRadius = getBorderRadiusCornerValues(style->borderTopLeftRadius(), style, renderView);\n    RefPtr<CSSValueList> topRightRadius = getBorderRadiusCornerValues(style->borderTopRightRadius(), style, renderView);\n    RefPtr<CSSValueList> bottomRightRadius = getBorderRadiusCornerValues(style->borderBottomRightRadius(), style, renderView);\n    RefPtr<CSSValueList> bottomLeftRadius = getBorderRadiusCornerValues(style->borderBottomLeftRadius(), style, renderView);\n\n    RefPtr<CSSValueList> horizontalRadii = CSSValueList::createSpaceSeparated();\n    horizontalRadii->append(topLeftRadius->item(0));\n    if (showHorizontalTopRight)\n        horizontalRadii->append(topRightRadius->item(0));\n    if (showHorizontalBottomRight)\n        horizontalRadii->append(bottomRightRadius->item(0));\n    if (showHorizontalBottomLeft)\n        horizontalRadii->append(bottomLeftRadius->item(0));\n\n    list->append(horizontalRadii);\n\n    if (showVerticalTopLeft) {\n        RefPtr<CSSValueList> verticalRadii = CSSValueList::createSpaceSeparated();\n        verticalRadii->append(topLeftRadius->item(1));\n        if (showVerticalTopRight)\n            verticalRadii->append(topRightRadius->item(1));\n        if (showVerticalBottomRight)\n            verticalRadii->append(bottomRightRadius->item(1));\n        if (showVerticalBottomLeft)\n            verticalRadii->append(bottomLeftRadius->item(1));\n        list->append(verticalRadii);\n    }\n    return list.release();\n}\n",
        "output": "0",
        "index": 104348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_huge_pmd_wp_page_fallback(struct mm_struct *mm,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tunsigned long address,\n\t\t\t\t\tpmd_t *pmd, pmd_t orig_pmd,\n\t\t\t\t\tstruct page *page,\n\t\t\t\t\tunsigned long haddr)\n{\n\tpgtable_t pgtable;\n\tpmd_t _pmd;\n\tint ret = 0, i;\n\tstruct page **pages;\n\n\tpages = kmalloc(sizeof(struct page *) * HPAGE_PMD_NR,\n\t\t\tGFP_KERNEL);\n\tif (unlikely(!pages)) {\n\t\tret |= VM_FAULT_OOM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tpages[i] = alloc_page_vma_node(GFP_HIGHUSER_MOVABLE |\n\t\t\t\t\t       __GFP_OTHER_NODE,\n\t\t\t\t\t       vma, address, page_to_nid(page));\n\t\tif (unlikely(!pages[i] ||\n\t\t\t     mem_cgroup_newpage_charge(pages[i], mm,\n\t\t\t\t\t\t       GFP_KERNEL))) {\n\t\t\tif (pages[i])\n\t\t\t\tput_page(pages[i]);\n\t\t\tmem_cgroup_uncharge_start();\n\t\t\twhile (--i >= 0) {\n\t\t\t\tmem_cgroup_uncharge_page(pages[i]);\n\t\t\t\tput_page(pages[i]);\n\t\t\t}\n\t\t\tmem_cgroup_uncharge_end();\n\t\t\tkfree(pages);\n\t\t\tret |= VM_FAULT_OOM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tcopy_user_highpage(pages[i], page + i,\n\t\t\t\t   haddr + PAGE_SHIFT*i, vma);\n\t\t__SetPageUptodate(pages[i]);\n\t\tcond_resched();\n\t}\n\n\tspin_lock(&mm->page_table_lock);\n\tif (unlikely(!pmd_same(*pmd, orig_pmd)))\n\t\tgoto out_free_pages;\n\tVM_BUG_ON(!PageHead(page));\n\n\tpmdp_clear_flush_notify(vma, haddr, pmd);\n\t/* leave pmd empty until pte is filled */\n\n\tpgtable = get_pmd_huge_pte(mm);\n\tpmd_populate(mm, &_pmd, pgtable);\n\n\tfor (i = 0; i < HPAGE_PMD_NR; i++, haddr += PAGE_SIZE) {\n\t\tpte_t *pte, entry;\n\t\tentry = mk_pte(pages[i], vma->vm_page_prot);\n\t\tentry = maybe_mkwrite(pte_mkdirty(entry), vma);\n\t\tpage_add_new_anon_rmap(pages[i], vma, haddr);\n\t\tpte = pte_offset_map(&_pmd, haddr);\n\t\tVM_BUG_ON(!pte_none(*pte));\n\t\tset_pte_at(mm, haddr, pte, entry);\n\t\tpte_unmap(pte);\n\t}\n\tkfree(pages);\n\n\tmm->nr_ptes++;\n\tsmp_wmb(); /* make pte visible before pmd */\n\tpmd_populate(mm, pmd, pgtable);\n\tpage_remove_rmap(page);\n\tspin_unlock(&mm->page_table_lock);\n\n\tret |= VM_FAULT_WRITE;\n\tput_page(page);\n\nout:\n\treturn ret;\n\nout_free_pages:\n\tspin_unlock(&mm->page_table_lock);\n\tmem_cgroup_uncharge_start();\n\tfor (i = 0; i < HPAGE_PMD_NR; i++) {\n\t\tmem_cgroup_uncharge_page(pages[i]);\n\t\tput_page(pages[i]);\n\t}\n\tmem_cgroup_uncharge_end();\n\tkfree(pages);\n\tgoto out;\n}\n",
        "output": "0",
        "index": 35093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool  ComputeAbsoluteIntent(cmsFloat64Number AdaptationState,\n                               const cmsCIEXYZ* WhitePointIn,\n                               const cmsMAT3* ChromaticAdaptationMatrixIn,\n                               const cmsCIEXYZ* WhitePointOut,\n                               const cmsMAT3* ChromaticAdaptationMatrixOut,\n                               cmsMAT3* m)\n{\n    cmsMAT3 Scale, m1, m2, m3, m4;\n\n    if (AdaptationState == 1.0) {\n\n        _cmsVEC3init(&m->v[0], WhitePointIn->X / WhitePointOut->X, 0, 0);\n        _cmsVEC3init(&m->v[1], 0, WhitePointIn->Y / WhitePointOut->Y, 0);\n        _cmsVEC3init(&m->v[2], 0, 0, WhitePointIn->Z / WhitePointOut->Z);\n\n    }\n    else  {\n\n        _cmsVEC3init(&Scale.v[0], WhitePointIn->X / WhitePointOut->X, 0, 0);\n        _cmsVEC3init(&Scale.v[1], 0,  WhitePointIn->Y / WhitePointOut->Y, 0);\n        _cmsVEC3init(&Scale.v[2], 0, 0,  WhitePointIn->Z / WhitePointOut->Z);\n\n\n        if (AdaptationState == 0.0) {\n\n            m1 = *ChromaticAdaptationMatrixOut;\n            _cmsMAT3per(&m2, &m1, &Scale);\n\n            _cmsMAT3per(m, &m2, ChromaticAdaptationMatrixOut);\n\n            m3 = *ChromaticAdaptationMatrixIn;\n            if (!_cmsMAT3inverse(&m3, &m4)) return FALSE;\n            _cmsMAT3per(m, &m2, &m4);\n\n        } else {\n\n            cmsMAT3 MixedCHAD;\n            cmsFloat64Number TempSrc, TempDest, Temp;\n\n            m1 = *ChromaticAdaptationMatrixIn;\n            if (!_cmsMAT3inverse(&m1, &m2)) return FALSE;\n            _cmsMAT3per(&m3, &m2, &Scale);\n\n            TempSrc  = CHAD2Temp(ChromaticAdaptationMatrixIn);\n            TempDest = CHAD2Temp(ChromaticAdaptationMatrixOut);\n\n            if (TempSrc < 0.0 || TempDest < 0.0) return FALSE; // Something went wrong\n\n            if (_cmsMAT3isIdentity(&Scale) && fabs(TempSrc - TempDest) < 0.01) {\n\n                _cmsMAT3identity(m);\n                return TRUE;\n            }\n\n            Temp = (1.0 - AdaptationState) * TempDest + AdaptationState * TempSrc;\n\n            Temp2CHAD(&MixedCHAD, Temp);\n\n            _cmsMAT3per(m, &m3, &MixedCHAD);\n        }\n\n    }\n    return TRUE;\n\n}\n",
        "output": "0",
        "index": 58424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void openpic_gbl_write(void *opaque, hwaddr addr, uint64_t val,\n                              unsigned len)\n{\n    OpenPICState *opp = opaque;\n    IRQDest *dst;\n    int idx;\n\n    DPRINTF(\"%s: addr %#\" HWADDR_PRIx \" <= %08\" PRIx64 \"\\n\",\n            __func__, addr, val);\n    if (addr & 0xF) {\n        return;\n    }\n    switch (addr) {\n    case 0x00: /* Block Revision Register1 (BRR1) is Readonly */\n        break;\n    case 0x40:\n    case 0x50:\n    case 0x60:\n    case 0x70:\n    case 0x80:\n    case 0x90:\n    case 0xA0:\n    case 0xB0:\n        openpic_cpu_write_internal(opp, addr, val, get_current_cpu());\n        break;\n    case 0x1000: /* FRR */\n        break;\n    case 0x1020: /* GCR */\n        openpic_gcr_write(opp, val);\n        break;\n    case 0x1080: /* VIR */\n        break;\n    case 0x1090: /* PIR */\n        for (idx = 0; idx < opp->nb_cpus; idx++) {\n            if ((val & (1 << idx)) && !(opp->pir & (1 << idx))) {\n                DPRINTF(\"Raise OpenPIC RESET output for CPU %d\\n\", idx);\n                dst = &opp->dst[idx];\n                qemu_irq_raise(dst->irqs[OPENPIC_OUTPUT_RESET]);\n            } else if (!(val & (1 << idx)) && (opp->pir & (1 << idx))) {\n                DPRINTF(\"Lower OpenPIC RESET output for CPU %d\\n\", idx);\n                dst = &opp->dst[idx];\n                qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_RESET]);\n            }\n        }\n        opp->pir = val;\n        break;\n    case 0x10A0: /* IPI_IVPR */\n    case 0x10B0:\n    case 0x10C0:\n    case 0x10D0:\n        {\n            int idx;\n            idx = (addr - 0x10A0) >> 4;\n            write_IRQreg_ivpr(opp, opp->irq_ipi0 + idx, val);\n        }\n        break;\n    case 0x10E0: /* SPVE */\n        opp->spve = val & opp->vector_mask;\n        break;\n    default:\n        break;\n    }\n}\n",
        "output": "0",
        "index": 15682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::didFailProvisionalLoad(blink::WebLocalFrame* frame,\n                                             const blink::WebURLError& error) {\n  DCHECK(!frame_ || frame_ == frame);\n  WebDataSource* ds = frame->provisionalDataSource();\n  DCHECK(ds);\n\n  const WebURLRequest& failed_request = ds->request();\n\n  FOR_EACH_OBSERVER(RenderViewObserver, render_view_->observers(),\n                    DidFailProvisionalLoad(frame, error));\n  FOR_EACH_OBSERVER(RenderFrameObserver, observers_,\n                    DidFailProvisionalLoad(error));\n\n  bool show_repost_interstitial =\n      (error.reason == net::ERR_CACHE_MISS &&\n       EqualsASCII(failed_request.httpMethod(), \"POST\"));\n\n  FrameHostMsg_DidFailProvisionalLoadWithError_Params params;\n  params.frame_unique_name = frame->uniqueName();\n  params.error_code = error.reason;\n  GetContentClient()->renderer()->GetNavigationErrorStrings(\n      render_view_.get(),\n      frame,\n      failed_request,\n      error,\n      NULL,\n      &params.error_description);\n  params.url = error.unreachableURL;\n  params.showing_repost_interstitial = show_repost_interstitial;\n  Send(new FrameHostMsg_DidFailProvisionalLoadWithError(\n      routing_id_, params));\n\n  if (error.reason == net::ERR_ABORTED)\n    return;\n\n  if (error.reason == net::ERR_BLOCKED_BY_CLIENT &&\n      render_view_->renderer_preferences_.disable_client_blocked_error_page) {\n    return;\n  }\n\n  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(this,\n          error.unreachableURL)) {\n    return;\n  }\n\n  if (RenderThreadImpl::current() &&\n      RenderThreadImpl::current()->layout_test_mode()) {\n    return;\n  }\n\n  frame->enableViewSourceMode(false);\n\n  DocumentState* document_state = DocumentState::FromDataSource(ds);\n  NavigationState* navigation_state = document_state->navigation_state();\n\n  bool replace =\n      navigation_state->pending_page_id() != -1 ||\n      PageTransitionCoreTypeIs(navigation_state->transition_type(),\n                               PAGE_TRANSITION_AUTO_SUBFRAME);\n\n  if (!navigation_state->is_content_initiated()) {\n    render_view_->pending_navigation_params_.reset(\n        new FrameMsg_Navigate_Params);\n    render_view_->pending_navigation_params_->page_id =\n        navigation_state->pending_page_id();\n    render_view_->pending_navigation_params_->pending_history_list_offset =\n        navigation_state->pending_history_list_offset();\n    render_view_->pending_navigation_params_->should_clear_history_list =\n        navigation_state->history_list_was_cleared();\n    render_view_->pending_navigation_params_->transition =\n        navigation_state->transition_type();\n    render_view_->pending_navigation_params_->request_time =\n        document_state->request_time();\n    render_view_->pending_navigation_params_->should_replace_current_entry =\n        replace;\n  }\n\n  LoadNavigationErrorPage(failed_request, error, replace);\n}\n",
        "output": "0",
        "index": 118503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tstatic const struct qstr anon = QSTR_INIT(\"/\", 1);\n\t\tname = &anon;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t\tif (IS_ENABLED(CONFIG_DCACHE_WORD_ACCESS))\n\t\t\tkasan_unpoison_shadow(dname,\n\t\t\t\tround_up(name->len + 1,\tsizeof(unsigned long)));\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_wmb();\n\tdentry->d_name.name = dname;\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}\n",
        "output": "0",
        "index": 67263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_MINIT_FUNCTION(spl_array)\n{\n\tREGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);\n\tmemcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\n\tspl_handler_ArrayObject.clone_obj = spl_array_object_clone;\n\tspl_handler_ArrayObject.read_dimension = spl_array_read_dimension;\n\tspl_handler_ArrayObject.write_dimension = spl_array_write_dimension;\n\tspl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;\n\tspl_handler_ArrayObject.has_dimension = spl_array_has_dimension;\n\tspl_handler_ArrayObject.count_elements = spl_array_object_count_elements;\n \n \tspl_handler_ArrayObject.get_properties = spl_array_get_properties;\n \tspl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;\n \tspl_handler_ArrayObject.read_property = spl_array_read_property;\n \tspl_handler_ArrayObject.write_property = spl_array_write_property;\n \tspl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;\n\tspl_handler_ArrayObject.has_property = spl_array_has_property;\n\tspl_handler_ArrayObject.unset_property = spl_array_unset_property;\n\n\tspl_handler_ArrayObject.compare_objects = spl_array_compare_objects;\n\n\tREGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);\n\tREGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);\n\tmemcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));\n\tspl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);\n\tspl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"STD_PROP_LIST\",    SPL_ARRAY_STD_PROP_LIST);\n\tREGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, \"ARRAY_AS_PROPS\",   SPL_ARRAY_ARRAY_AS_PROPS);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, \"CHILD_ARRAYS_ONLY\", SPL_ARRAY_CHILD_ARRAYS_ONLY);\n\n\treturn SUCCESS;\n}\n",
        "output": "1",
        "index": 180197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b = NULL;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey = NULL;\n\tsize_t keylen, ivlen, maclen;\n\tint r;\n\n\tif ((newkey = calloc(1, sizeof(*newkey))) == NULL) {\n\t\tr = SSH_ERR_ALLOC_FAIL;\n\t\tgoto out;\n\t}\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n#ifdef DEBUG_PK\n\tsshbuf_dump(b, stderr);\n#endif\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\n\tif ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||\n\t    (r = sshbuf_get(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||\n\t    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||\n\t    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = mac_setup(mac, mac->name)) != 0)\n\t\t\tgoto out;\n\t\tif ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)\n\t\t\tgoto out;\n\t\tif (maclen > mac->key_len) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tmac->key_len = maclen;\n\t}\n\tif ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||\n\t    (r = sshbuf_get_u32(b, (u_int *)&comp->enabled)) != 0 ||\n\t    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)\n\t\tgoto out;\n\tif (enc->name == NULL ||\n\t    cipher_by_name(enc->name) != enc->cipher) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tif (sshbuf_len(b) != 0) {\n\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\tgoto out;\n\t}\n\tenc->key_len = keylen;\n\tenc->iv_len = ivlen;\n\tssh->kex->newkeys[mode] = newkey;\n\tnewkey = NULL;\n\tr = 0;\n out:\n\tif (newkey != NULL)\n\t\tfree(newkey);\n\tif (b != NULL)\n\t\tsshbuf_free(b);\n\treturn r;\n}\n",
        "output": "0",
        "index": 12946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t u1, u0;\n  mp_size_t n;\n\n  n = 2*p->size;\n  u1 = rp[--n];\n  u0 = rp[n-1];\n\n  /* This is not particularly fast, but should work well with assembly implementation. */\n  for (; n >= p->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, cy;\n\n      /* <q2, q1, q0> = v * u1 + <u1,u0>, with v = 2^32 - 1:\n\n\t   +---+---+\n\t   | u1| u0|\n\t   +---+---+\n\t       |-u1|\n\t     +-+-+-+\n\t     | u1|\n       +---+-+-+-+-+\n       | q2| q1| q0|\n       +---+---+---+\n      */\n      q1 = u1 - (u1 > u0);\n      q0 = u0 - u1;\n      t = u1 << 32;\n      q0 += t;\n      t = (u1 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n\n      /* Compute candidate remainder */\n      u1 = u0 + (q1 << 32) - q1;\n      t = -(mp_limb_t) (u1 > q0);\n      u1 -= t & 0xffffffff;\n      q1 += t;\n      q2 += t + (q1 < t);\n\n      assert (q2 < 2);\n\n      /* We multiply by two low limbs of p, 2^96 - 1, so we could use\n\t shifts rather than mul. */\n      /*\n\t n-1 n-2 n-3 n-4\n        +---+---+---+---+\n        | u1| u0| u low |\n        +---+---+---+---+\n          - | q1(2^96-1)|\n            +-------+---+\n            |q2(2^.)|\n            +-------+\n\n\t We multiply by two low limbs of p, 2^96 - 1, so we could use\n\t shifts rather than mul.\n      */\n      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n      t += (-q2) & 0xffffffff;\n}\n\nstatic void\n      u0 -= t;\n      t = (u1 < cy);\n      u1 -= cy;\n      u1 += cnd_add_n (t, rp + n - 4, p->m, 3);\n\n      cy = cnd_add_n (t, rp + n - 4, p->m, 2);\n      u0 += cy;\n      u1 += (u0 < cy);\n      u1 -= (-t) & 0xffffffff;\n    }\n",
        "output": "0",
        "index": 14320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void red_peer_handle_incoming(RedsStream *stream, IncomingHandler *handler)\n{\n    int bytes_read;\n    uint8_t *parsed;\n    size_t parsed_size;\n    message_destructor_t parsed_free;\n    uint16_t msg_type;\n    uint32_t msg_size;\n\n    /* XXX: This needs further investigation as to the underlying cause, it happened\n     * after spicec disconnect (but not with spice-gtk) repeatedly. */\n    if (!stream) {\n        return;\n    }\n\n    for (;;) {\n        int ret_handle;\n        if (handler->header_pos < handler->header.header_size) {\n            bytes_read = red_peer_receive(stream,\n                                          handler->header.data + handler->header_pos,\n                                          handler->header.header_size - handler->header_pos);\n            if (bytes_read == -1) {\n                handler->cb->on_error(handler->opaque);\n                return;\n            }\n            handler->header_pos += bytes_read;\n\n            if (handler->header_pos != handler->header.header_size) {\n                return;\n            }\n        }\n\n        msg_size = handler->header.get_msg_size(&handler->header);\n        msg_type = handler->header.get_msg_type(&handler->header);\n        if (handler->msg_pos < msg_size) {\n            if (!handler->msg) {\n                handler->msg = handler->cb->alloc_msg_buf(handler->opaque, msg_type, msg_size);\n                if (handler->msg == NULL) {\n                    spice_printerr(\"ERROR: channel refused to allocate buffer.\");\n                    handler->cb->on_error(handler->opaque);\n                    return;\n                }\n            }\n\n            bytes_read = red_peer_receive(stream,\n                                          handler->msg + handler->msg_pos,\n                                          msg_size - handler->msg_pos);\n            if (bytes_read == -1) {\n                handler->cb->release_msg_buf(handler->opaque, msg_type, msg_size, handler->msg);\n                handler->cb->on_error(handler->opaque);\n                return;\n            }\n            handler->msg_pos += bytes_read;\n            if (handler->msg_pos != msg_size) {\n                return;\n            }\n        }\n\n        if (handler->cb->parser) {\n            parsed = handler->cb->parser(handler->msg,\n                handler->msg + msg_size, msg_type,\n                SPICE_VERSION_MINOR, &parsed_size, &parsed_free);\n            if (parsed == NULL) {\n                spice_printerr(\"failed to parse message type %d\", msg_type);\n                handler->cb->release_msg_buf(handler->opaque, msg_type, msg_size, handler->msg);\n                handler->cb->on_error(handler->opaque);\n                return;\n            }\n            ret_handle = handler->cb->handle_parsed(handler->opaque, parsed_size,\n                                                    msg_type, parsed);\n            parsed_free(parsed);\n        } else {\n            ret_handle = handler->cb->handle_message(handler->opaque, msg_type, msg_size,\n                                                     handler->msg);\n        }\n        handler->msg_pos = 0;\n        handler->cb->release_msg_buf(handler->opaque, msg_type, msg_size, handler->msg);\n        handler->msg = NULL;\n        handler->header_pos = 0;\n\n        if (!ret_handle) {\n            handler->cb->on_error(handler->opaque);\n            return;\n        }\n    }\n}\n",
        "output": "0",
        "index": 2197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "main(const int argc, const char * const * const argv)\n{\n /* For each file on the command line test it with a range of transforms */\n int option_end, ilog = 0;\n struct display d;\n\n   validate_T();\n   display_init(&d);\n\n for (option_end=1; option_end<argc; ++option_end)\n {\n const char *name = argv[option_end];\n\n if (strcmp(name, \"--verbose\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | VERBOSE;\n\n else if (strcmp(name, \"--warnings\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | WARNINGS;\n\n else if (strcmp(name, \"--errors\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | ERRORS;\n\n else if (strcmp(name, \"--quiet\") == 0)\n         d.options = (d.options & ~LEVEL_MASK) | QUIET;\n\n else if (strcmp(name, \"--exhaustive\") == 0)\n         d.options |= EXHAUSTIVE;\n\n else if (strcmp(name, \"--fast\") == 0)\n         d.options &= ~EXHAUSTIVE;\n\n else if (strcmp(name, \"--strict\") == 0)\n         d.options |= STRICT;\n\n else if (strcmp(name, \"--relaxed\") == 0)\n         d.options &= ~STRICT;\n\n else if (strcmp(name, \"--log\") == 0)\n {\n         ilog = option_end; /* prevent display */\n         d.options |= LOG;\n }\n\n else if (strcmp(name, \"--nolog\") == 0)\n         d.options &= ~LOG;\n\n else if (strcmp(name, \"--continue\") == 0)\n         d.options |= CONTINUE;\n\n else if (strcmp(name, \"--stop\") == 0)\n         d.options &= ~CONTINUE;\n\n else if (strcmp(name, \"--skip-bugs\") == 0)\n         d.options |= SKIP_BUGS;\n\n else if (strcmp(name, \"--test-all\") == 0)\n         d.options &= ~SKIP_BUGS;\n\n else if (strcmp(name, \"--log-skipped\") == 0)\n         d.options |= LOG_SKIPPED;\n\n else if (strcmp(name, \"--nolog-skipped\") == 0)\n         d.options &= ~LOG_SKIPPED;\n\n else if (strcmp(name, \"--find-bad-combos\") == 0)\n         d.options |= FIND_BAD_COMBOS;\n\n\n       else if (strcmp(name, \"--nofind-bad-combos\") == 0)\n          d.options &= ~FIND_BAD_COMBOS;\n \n       else if (name[0] == '-' && name[1] == '-')\n       {\n          fprintf(stderr, \"pngimage: %s: unknown option\\n\", name);\n return 99;\n }\n\n else\n break; /* Not an option */\n }\n\n {\n int i;\n int errors = 0;\n\n for (i=option_end; i<argc; ++i)\n {\n {\n int ret = do_test(&d, argv[i]);\n\n if (ret > QUIET) /* abort on user or internal error */\n return 99;\n }\n\n /* Here on any return, including failures, except user/internal issues\n          */\n {\n const int pass = (d.options & STRICT) ?\n               RESULT_STRICT(d.results) : RESULT_RELAXED(d.results);\n\n if (!pass)\n ++errors;\n\n if (d.options & LOG)\n {\n int j;\n\n               printf(\"%s: pngimage \", pass ? \"PASS\" : \"FAIL\");\n\n for (j=1; j<option_end; ++j) if (j != ilog)\n                  printf(\"%s \", argv[j]);\n\n               printf(\"%s\\n\", d.filename);\n }\n }\n\n\n          display_clean(&d);\n       }\n \n       return errors != 0;\n    }\n }\n",
        "output": "1",
        "index": 187611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NuPlayer::GenericSource::onMessageReceived(const sp<AMessage> &msg) {\n switch (msg->what()) {\n case kWhatPrepareAsync:\n {\n          onPrepareAsync();\n break;\n }\n case kWhatFetchSubtitleData:\n {\n          fetchTextData(kWhatSendSubtitleData, MEDIA_TRACK_TYPE_SUBTITLE,\n                  mFetchSubtitleDataGeneration, mSubtitleTrack.mPackets, msg);\n break;\n }\n\n case kWhatFetchTimedTextData:\n {\n          fetchTextData(kWhatSendTimedTextData, MEDIA_TRACK_TYPE_TIMEDTEXT,\n                  mFetchTimedTextDataGeneration, mTimedTextTrack.mPackets, msg);\n break;\n }\n\n case kWhatSendSubtitleData:\n {\n          sendTextData(kWhatSubtitleData, MEDIA_TRACK_TYPE_SUBTITLE,\n                  mFetchSubtitleDataGeneration, mSubtitleTrack.mPackets, msg);\n break;\n }\n\n case kWhatSendTimedTextData:\n {\n          sendTextData(kWhatTimedTextData, MEDIA_TRACK_TYPE_TIMEDTEXT,\n                  mFetchTimedTextDataGeneration, mTimedTextTrack.mPackets, msg);\n break;\n }\n\n case kWhatChangeAVSource:\n {\n int32_t trackIndex;\n          CHECK(msg->findInt32(\"trackIndex\", &trackIndex));\n const sp<MediaSource> source = mSources.itemAt(trackIndex);\n\n Track* track;\n const char *mime;\n          media_track_type trackType, counterpartType;\n          sp<MetaData> meta = source->getFormat();\n          meta->findCString(kKeyMIMEType, &mime);\n if (!strncasecmp(mime, \"audio/\", 6)) {\n              track = &mAudioTrack;\n              trackType = MEDIA_TRACK_TYPE_AUDIO;\n              counterpartType = MEDIA_TRACK_TYPE_VIDEO;;\n } else {\n              CHECK(!strncasecmp(mime, \"video/\", 6));\n              track = &mVideoTrack;\n              trackType = MEDIA_TRACK_TYPE_VIDEO;\n              counterpartType = MEDIA_TRACK_TYPE_AUDIO;;\n }\n\n\n if (track->mSource != NULL) {\n              track->mSource->stop();\n }\n          track->mSource = source;\n          track->mSource->start();\n          track->mIndex = trackIndex;\n\n status_t avail;\n if (!track->mPackets->hasBufferAvailable(&avail)) {\n              TRESPASS();\n break;\n }\n\n int64_t timeUs, actualTimeUs;\n const bool formatChange = true;\n          sp<AMessage> latestMeta = track->mPackets->getLatestEnqueuedMeta();\n          CHECK(latestMeta != NULL && latestMeta->findInt64(\"timeUs\", &timeUs));\n          readBuffer(trackType, timeUs, &actualTimeUs, formatChange);\n          readBuffer(counterpartType, -1, NULL, formatChange);\n          ALOGV(\"timeUs %lld actualTimeUs %lld\", timeUs, actualTimeUs);\n\n break;\n }\n case kWhatPollBuffering:\n {\n int32_t generation;\n          CHECK(msg->findInt32(\"generation\", &generation));\n if (generation == mPollBufferingGeneration) {\n              onPollBuffering();\n }\n break;\n }\n\n case kWhatGetFormat:\n {\n          onGetFormatMeta(msg);\n break;\n }\n\n case kWhatGetSelectedTrack:\n {\n          onGetSelectedTrack(msg);\n break;\n }\n\n case kWhatSelectTrack:\n {\n          onSelectTrack(msg);\n break;\n }\n\n case kWhatSeek:\n {\n          onSeek(msg);\n break;\n }\n\n case kWhatReadBuffer:\n {\n          onReadBuffer(msg);\n break;\n }\n\n case kWhatStopWidevine:\n {\n          mStopRead = true;\n if (mVideoTrack.mSource != NULL) {\n              mVideoTrack.mPackets->clear();\n }\n          sp<AMessage> response = new AMessage;\n uint32_t replyID;\n          CHECK(msg->senderAwaitsResponse(&replyID));\n          response->postReply(replyID);\n break;\n }\n default:\n Source::onMessageReceived(msg);\n break;\n }\n}\n",
        "output": "0",
        "index": 175163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xps_load_sfnt_name(xps_font_t *font, char *namep)\n{\n    byte *namedata;\n    int offset, length;\n    /*int format;*/\n    int count, stringoffset;\n    int found;\n    int i, k;\n\n    found = 0;\n    strcpy(namep, \"Unknown\");\n\n    offset = xps_find_sfnt_table(font, \"name\", &length);\n    if (offset < 0 || length < 6)\n    {\n        gs_warn(\"cannot find name table\");\n         return;\n     }\n \n     namedata = font->data + offset;\n \n     /*format = u16(namedata + 0);*/\n     count = u16(namedata + 2);\n     stringoffset = u16(namedata + 4);\n \n     if (length < 6 + (count * 12))\n     {\n         gs_warn(\"name table too short\");\n        {\n            if (pid == 1 && eid == 0 && langid == 0) /* mac roman, english */\n            {\n                if (found < 3)\n                {\n                    memcpy(namep, namedata + stringoffset + offset, length);\n                    namep[length] = 0;\n                    found = 3;\n                }\n            }\n\n            if (pid == 3 && eid == 1 && langid == 0x409) /* windows unicode ucs-2, US */\n            {\n                if (found < 2)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 2;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u16(s + k * 2);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 2;\n                }\n            }\n\n            if (pid == 3 && eid == 10 && langid == 0x409) /* windows unicode ucs-4, US */\n            {\n                if (found < 1)\n                {\n                    unsigned char *s = namedata + stringoffset + offset;\n                    int n = length / 4;\n                    for (k = 0; k < n; k ++)\n                    {\n                        int c = u32(s + k * 4);\n                        namep[k] = isprint(c) ? c : '?';\n                    }\n                    namep[k] = 0;\n                    found = 1;\n                }\n            }\n        }\n    }\n}\n",
        "output": "1",
        "index": 177959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Riemersma(Image *image,CacheView *image_view,CubeInfo *cube_info,\n  const size_t level,const unsigned int direction)\n{\n  if (level == 1)\n    switch (direction)\n    {\n      case WestGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity);\n        break;\n      }\n      case EastGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity);\n        break;\n      }\n      case NorthGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity);\n        break;\n      }\n      case SouthGravity:\n      {\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity);\n        break;\n      }\n      default:\n        break;\n    }\n  else\n    switch (direction)\n    {\n      case WestGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity);\n        break;\n      }\n      case EastGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity);\n        break;\n      }\n      case NorthGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,WestGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,EastGravity);\n        Riemersma(image,image_view,cube_info,level-1,NorthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity);\n        Riemersma(image,image_view,cube_info,level-1,EastGravity);\n        break;\n      }\n      case SouthGravity:\n      {\n        Riemersma(image,image_view,cube_info,level-1,EastGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,NorthGravity);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,WestGravity);\n        Riemersma(image,image_view,cube_info,level-1,SouthGravity);\n        (void) RiemersmaDither(image,image_view,cube_info,SouthGravity);\n        Riemersma(image,image_view,cube_info,level-1,WestGravity);\n        break;\n      }\n      default:\n        break;\n    }\n}\n",
        "output": "0",
        "index": 62728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n  ExceptionInfo *exception)\n{\n  DDSColors\n    colors;\n\n  ssize_t\n    j,\n    y;\n\n  MagickSizeType\n    alpha_bits;\n\n  PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  unsigned char\n    a0,\n    a1;\n\n  size_t\n    alpha,\n    bits,\n    code,\n    alpha_code;\n\n  unsigned short\n    c0,\n    c1;\n\n  for (y = 0; y < (ssize_t) dds_info->height; y += 4)\n  {\n     for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n     {\n       /* Get 4x4 patch of pixels to write on */\n      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),\n                         Min(4, dds_info->height - y),exception);\n \n       if (q == (PixelPacket *) NULL)\n         return MagickFalse;\n\n      /* Read alpha values (8 bytes) */\n      a0 = (unsigned char) ReadBlobByte(image);\n      a1 = (unsigned char) ReadBlobByte(image);\n\n      alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);\n      alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);\n\n      /* Read 8 bytes of data from the image */\n      c0 = ReadBlobLSBShort(image);\n      c1 = ReadBlobLSBShort(image);\n      bits = ReadBlobLSBLong(image);\n\n      CalculateColors(c0, c1, &colors, MagickTrue);\n\n      /* Write the pixels */\n      for (j = 0; j < 4; j++)\n      {\n        for (i = 0; i < 4; i++)\n        {\n          if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)\n            {\n              code = (bits >> ((4*j+i)*2)) & 0x3;\n              SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));\n              SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));\n              SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));\n              /* Extract alpha value */\n              alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;\n              if (alpha_code == 0)\n                alpha = a0;\n              else if (alpha_code == 1)\n                alpha = a1;\n              else if (a0 > a1)\n                alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;\n              else if (alpha_code == 6)\n                alpha = 0;\n              else if (alpha_code == 7)\n                alpha = 255;\n              else\n                alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                alpha));\n              q++;\n            }\n        }\n      }\n\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        return MagickFalse;\n     }\n   }\n \n  SkipDXTMipmaps(image, dds_info, 16);\n  return MagickTrue;\n }\n",
        "output": "1",
        "index": 182073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n\n  register const unsigned char\n    *p;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  size_t\n    packet_size;\n\n  unsigned short\n    nibble;\n\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    switch (type)\n    {\n      case -1:\n      {\n        SetPixelAlpha(image,pixel,q);\n        break;\n      }\n      case -2:\n      case 0:\n      {\n        SetPixelRed(image,pixel,q);\n        if (channels == 1 || type == -2)\n          SetPixelGray(image,pixel,q);\n        if (image->storage_class == PseudoClass)\n          {\n            if (packet_size == 1)\n              SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n            else\n              SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n              ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n            if (image->depth == 1)\n              {\n                ssize_t\n                  bit,\n                  number_bits;\n  \n                number_bits=image->columns-x;\n                if (number_bits > 8)\n                  number_bits=8;\n                for (bit=0; bit < number_bits; bit++)\n                {\n                  SetPixelIndex(image,(((unsigned char) pixel) &\n                    (0x01 << (7-bit))) != 0 ? 0 : 255,q);\n                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n                    ConstrainColormapIndex(image,GetPixelIndex(image,q),\n                      exception),q);\n                  q+=GetPixelChannels(image);\n                  x++;\n                }\n                x--;\n                continue;\n              }\n          }\n        break;\n      }\n      case 1:\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelAlpha(image,pixel,q);\n        else\n          SetPixelGreen(image,pixel,q);\n        break;\n      }\n      case 2:\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelAlpha(image,pixel,q);\n        else\n          SetPixelBlue(image,pixel,q);\n        break;\n      }\n      case 3:\n      {\n        if (image->colorspace == CMYKColorspace)\n          SetPixelBlack(image,pixel,q);\n        else\n          if (image->alpha_trait != UndefinedPixelTrait)\n            SetPixelAlpha(image,pixel,q);\n        break;\n      }\n      case 4:\n      {\n        if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n            (channels > 3))\n          break;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n        break;\n      }\n      default:\n        break;\n    }\n    q+=GetPixelChannels(image);\n  }\n  return(SyncAuthenticPixels(image,exception));\n}\n",
        "output": "0",
        "index": 96182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NormalPageArena::sweepAndCompact() {\n  ThreadHeap& heap = getThreadState()->heap();\n  if (!heap.compaction()->isCompactingArena(arenaIndex()))\n    return;\n\n  if (!m_firstUnsweptPage) {\n    heap.compaction()->finishedArenaCompaction(this, 0, 0);\n    return;\n  }\n\n  NormalPage::CompactionContext context;\n  context.m_compactedPages = &m_firstPage;\n\n  while (m_firstUnsweptPage) {\n    BasePage* page = m_firstUnsweptPage;\n    if (page->isEmpty()) {\n      page->unlink(&m_firstUnsweptPage);\n      page->removeFromHeap();\n      continue;\n    }\n    DCHECK(!page->isLargeObjectPage());\n    NormalPage* normalPage = static_cast<NormalPage*>(page);\n    normalPage->unlink(&m_firstUnsweptPage);\n    normalPage->markAsSwept();\n    if (!context.m_currentPage)\n      context.m_currentPage = normalPage;\n    else\n      normalPage->link(&context.m_availablePages);\n    normalPage->sweepAndCompact(context);\n  }\n\n  size_t freedSize = 0;\n  size_t freedPageCount = 0;\n\n  DCHECK(context.m_currentPage);\n  size_t allocationPoint = context.m_allocationPoint;\n  if (!allocationPoint) {\n    context.m_currentPage->link(&context.m_availablePages);\n  } else {\n    NormalPage* currentPage = context.m_currentPage;\n    currentPage->link(&m_firstPage);\n    if (allocationPoint != currentPage->payloadSize()) {\n      freedSize = currentPage->payloadSize() - allocationPoint;\n      Address payload = currentPage->payload();\n      SET_MEMORY_INACCESSIBLE(payload + allocationPoint, freedSize);\n      currentPage->arenaForNormalPage()->addToFreeList(\n          payload + allocationPoint, freedSize);\n    }\n  }\n\n  BasePage* availablePages = context.m_availablePages;\n  while (availablePages) {\n    size_t pageSize = availablePages->size();\n#if DEBUG_HEAP_COMPACTION\n    if (!freedPageCount)\n      LOG_HEAP_COMPACTION(\"Releasing:\");\n    LOG_HEAP_COMPACTION(\" [%p, %p]\", availablePages, availablePages + pageSize);\n#endif\n    freedSize += pageSize;\n    freedPageCount++;\n    BasePage* nextPage;\n    availablePages->unlink(&nextPage);\n#if !(DCHECK_IS_ON() || defined(LEAK_SANITIZER) || \\\n      defined(ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER))\n    DCHECK(!availablePages->isLargeObjectPage());\n    NormalPage* unusedPage = reinterpret_cast<NormalPage*>(availablePages);\n    memset(unusedPage->payload(), 0, unusedPage->payloadSize());\n#endif\n    availablePages->removeFromHeap();\n    availablePages = static_cast<NormalPage*>(nextPage);\n  }\n  if (freedPageCount)\n    LOG_HEAP_COMPACTION(\"\\n\");\n  heap.compaction()->finishedArenaCompaction(this, freedPageCount, freedSize);\n}\n",
        "output": "0",
        "index": 160401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinode_lock(inode);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_SIZE - (inode->i_size & (PAGE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t */\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset) {\n\t\tret = ext4_update_disksize_before_punch(inode, offset, length);\n\t\tif (ret)\n\t\t\tgoto out_dio;\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tinode_unlock(inode);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 67536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n \trqst.rq_nvec = 1;\n \n \trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n \trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n \n \tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n \t\t\t\t    io_parms->tcon->tid, ses->Suid,\n \t\t\t\t    io_parms->offset, io_parms->length);\n \n \t*nbytes = le32_to_cpu(rsp->DataLength);\n \tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n \t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}\n",
        "output": "1",
        "index": 182697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bin_pe_resources(RCore *r, int mode) {\n\tSdb *sdb = NULL;\n\tint index = 0;\n\tconst char *pe_path = \"bin/cur/info/pe_resource\";\n\tif (!(sdb = sdb_ns_path (r->sdb, pe_path, 0))) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, \"resources\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs resources\\n\");\n\t} else if (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"[\");\n\t}\n\twhile (true) {\n\t\tconst char *timestrKey = sdb_fmt (\"resource.%d.timestr\", index);\n\t\tconst char *vaddrKey = sdb_fmt (\"resource.%d.vaddr\", index);\n\t\tconst char *sizeKey  = sdb_fmt (\"resource.%d.size\", index);\n\t\tconst char *typeKey  = sdb_fmt (\"resource.%d.type\", index);\n\t\tconst char *languageKey = sdb_fmt (\"resource.%d.language\", index);\n\t\tconst char *nameKey = sdb_fmt (\"resource.%d.name\", index);\n\t\tchar *timestr = sdb_get (sdb, timestrKey, 0);\n\t\tif (!timestr) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 vaddr = sdb_num_get (sdb, vaddrKey, 0);\n\t\tint size = (int)sdb_num_get (sdb, sizeKey, 0);\n\t\tint name = (int)sdb_num_get (sdb, nameKey, 0);\n\t\tchar *type = sdb_get (sdb, typeKey, 0);\n\t\tchar *lang = sdb_get (sdb, languageKey, 0);\n\n\t\tif (IS_MODE_SET (mode)) {\n\t\t\tconst char *name = sdb_fmt (\"resource.%d\", index);\n\t\t\tr_flag_set (r->flags, name, vaddr, size);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"f resource.%d %d 0x%08\"PFMT32x\"\\n\", index, size, vaddr);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tr_cons_printf(\"%s{\\\"name\\\":%d,\\\"index\\\":%d, \\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\", \\\"size\\\":%d, \\\"lang\\\":\\\"%s\\\"}\",\n\t\t\t\t\tindex? \",\": \"\", name, index, type, vaddr, size, lang);\n\t\t} else {\n\t\t\tchar *humanSize = r_num_units (NULL, size);\n\t\t\tr_cons_printf (\"Resource %d\\n\", index);\n\t\t\tr_cons_printf (\"  name: %d\\n\", name);\n\t\t\tr_cons_printf (\"  timestamp: %s\\n\", timestr);\n\t\t\tr_cons_printf (\"  vaddr: 0x%08\"PFMT64x\"\\n\", vaddr);\n\t\t\tif (humanSize) {\n\t\t\t\tr_cons_printf (\"  size: %s\\n\", humanSize);\n\t\t\t}\n\t\t\tr_cons_printf (\"  type: %s\\n\", type);\n\t\t\tr_cons_printf (\"  language: %s\\n\", lang);\n\t\t\tfree (humanSize);\n\t\t}\n\n\t\tR_FREE (timestr);\n\t\tR_FREE (type);\n\t\tR_FREE (lang)\n\n\t\tindex++;\n\t}\n\tif (IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"]\");\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"fs *\");\n\t}\n}\n",
        "output": "0",
        "index": 82964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ccid3_hc_tx_send_packet(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tktime_t now = ktime_get_real();\n\ts64 delay;\n\n\t/*\n\t * This function is called only for Data and DataAck packets. Sending\n\t * zero-sized Data(Ack)s is theoretically possible, but for congestion\n\t * control this case is pathological - ignore it.\n\t */\n\tif (unlikely(skb->len == 0))\n\t\treturn -EBADMSG;\n\n\tif (hc->tx_state == TFRC_SSTATE_NO_SENT) {\n\t\tsk_reset_timer(sk, &hc->tx_no_feedback_timer, (jiffies +\n\t\t\t       usecs_to_jiffies(TFRC_INITIAL_TIMEOUT)));\n\t\thc->tx_last_win_count\t= 0;\n\t\thc->tx_t_last_win_count = now;\n\n\t\t/* Set t_0 for initial packet */\n\t\thc->tx_t_nom = now;\n\n\t\thc->tx_s = skb->len;\n\n\t\t/*\n\t\t * Use initial RTT sample when available: recommended by erratum\n\t\t * to RFC 4342. This implements the initialisation procedure of\n\t\t * draft rfc3448bis, section 4.2. Remember, X is scaled by 2^6.\n\t\t */\n\t\tif (dp->dccps_syn_rtt) {\n\t\t\tccid3_pr_debug(\"SYN RTT = %uus\\n\", dp->dccps_syn_rtt);\n\t\t\thc->tx_rtt  = dp->dccps_syn_rtt;\n\t\t\thc->tx_x    = rfc3390_initial_rate(sk);\n\t\t\thc->tx_t_ld = now;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Sender does not have RTT sample:\n\t\t\t * - set fallback RTT (RFC 4340, 3.4) since a RTT value\n\t\t\t *   is needed in several parts (e.g.  window counter);\n\t\t\t * - set sending rate X_pps = 1pps as per RFC 3448, 4.2.\n\t\t\t */\n\t\t\thc->tx_rtt = DCCP_FALLBACK_RTT;\n\t\t\thc->tx_x   = hc->tx_s;\n\t\t\thc->tx_x <<= 6;\n\t\t}\n\t\tccid3_update_send_interval(hc);\n\n\t\tccid3_hc_tx_set_state(sk, TFRC_SSTATE_NO_FBACK);\n\n\t} else {\n\t\tdelay = ktime_us_delta(hc->tx_t_nom, now);\n\t\tccid3_pr_debug(\"delay=%ld\\n\", (long)delay);\n\t\t/*\n\t\t *\tScheduling of packet transmissions (RFC 5348, 8.3)\n\t\t *\n\t\t * if (t_now > t_nom - delta)\n\t\t *       // send the packet now\n\t\t * else\n\t\t *       // send the packet in (t_nom - t_now) milliseconds.\n\t\t */\n\t\tif (delay >= TFRC_T_DELTA)\n\t\t\treturn (u32)delay / USEC_PER_MSEC;\n\n\t\tccid3_hc_tx_update_win_count(hc, now);\n\t}\n\n\t/* prepare to send now (add options etc.) */\n\tdp->dccps_hc_tx_insert_options = 1;\n\tDCCP_SKB_CB(skb)->dccpd_ccval  = hc->tx_last_win_count;\n\n\t/* set the nominal send time for the next following packet */\n\thc->tx_t_nom = ktime_add_us(hc->tx_t_nom, hc->tx_t_ipi);\n\treturn CCID_PACKET_SEND_AT_ONCE;\n}\n",
        "output": "0",
        "index": 34163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParseElementDecl(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    int ret = -1;\n    xmlElementContentPtr content  = NULL;\n\n    /* GROW; done in the caller */\n    if (CMP9(CUR_PTR, '<', '!', 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {\n\txmlParserInputPtr input = ctxt->input;\n\n\tSKIP(9);\n\tif (!IS_BLANK_CH(CUR)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t           \"Space required after 'ELEMENT'\\n\");\n\t}\n        SKIP_BLANKS;\n        name = xmlParseName(ctxt);\n\tif (name == NULL) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t\t\t   \"xmlParseElementDecl: no name for Element\\n\");\n\t    return(-1);\n\t}\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\tif (!IS_BLANK_CH(CUR)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t   \"Space required after the element name\\n\");\n\t}\n        SKIP_BLANKS;\n\tif (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {\n\t    SKIP(5);\n\t    /*\n\t     * Element must always be empty.\n\t     */\n\t    ret = XML_ELEMENT_TYPE_EMPTY;\n\t} else if ((RAW == 'A') && (NXT(1) == 'N') &&\n\t           (NXT(2) == 'Y')) {\n\t    SKIP(3);\n\t    /*\n\t     * Element is a generic container.\n\t     */\n\t    ret = XML_ELEMENT_TYPE_ANY;\n\t} else if (RAW == '(') {\n\t    ret = xmlParseElementContentDecl(ctxt, name, &content);\n\t} else {\n\t    /*\n\t     * [ WFC: PEs in Internal Subset ] error handling.\n\t     */\n\t    if ((RAW == '%') && (ctxt->external == 0) &&\n\t        (ctxt->inputNr == 1)) {\n\t\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,\n\t  \"PEReference: forbidden within markup decl in internal subset\\n\");\n\t    } else {\n\t\txmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n\t\t      \"xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\\n\");\n            }\n\t    return(-1);\n\t}\n\n\tSKIP_BLANKS;\n\t/*\n\t * Pop-up of finished entities.\n\t */\n\twhile ((RAW == 0) && (ctxt->inputNr > 1))\n\t    xmlPopInput(ctxt);\n\tSKIP_BLANKS;\n\n\tif (RAW != '>') {\n\t    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n\t    if (content != NULL) {\n\t\txmlFreeDocElementContent(ctxt->myDoc, content);\n\t    }\n\t} else {\n\t    if (input != ctxt->input) {\n\t\txmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n    \"Element declaration doesn't start and stop in the same entity\\n\");\n\t    }\n\t\t\n\t    NEXT;\n\t    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n\t\t(ctxt->sax->elementDecl != NULL)) {\n\t\tif (content != NULL)\n\t\t    content->parent = NULL;\n\t        ctxt->sax->elementDecl(ctxt->userData, name, ret,\n\t\t                       content);\n\t\tif ((content != NULL) && (content->parent == NULL)) {\n\t\t    /*\n\t\t     * this is a trick: if xmlAddElementDecl is called,\n\t\t     * instead of copying the full tree it is plugged directly\n\t\t     * if called from the parser. Avoid duplicating the \n\t\t     * interfaces or change the API/ABI\n\t\t     */\n\t\t    xmlFreeDocElementContent(ctxt->myDoc, content);\n\t\t}\n\t    } else if (content != NULL) {\n\t\txmlFreeDocElementContent(ctxt->myDoc, content);\n\t    }\n\t}\n    }\n    return(ret);\n}\n",
        "output": "0",
        "index": 100720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,\n                        AVFrame *ref, const Mv *mv, int x_off, int y_off,\n                        int block_w, int block_h, int luma_weight, int luma_offset)\n{\n    HEVCLocalContext *lc = s->HEVClc;\n    uint8_t *src         = ref->data[0];\n    ptrdiff_t srcstride  = ref->linesize[0];\n    int pic_width        = s->ps.sps->width;\n    int pic_height       = s->ps.sps->height;\n    int mx               = mv->x & 3;\n    int my               = mv->y & 3;\n    int weight_flag      = (s->sh.slice_type == HEVC_SLICE_P && s->ps.pps->weighted_pred_flag) ||\n                           (s->sh.slice_type == HEVC_SLICE_B && s->ps.pps->weighted_bipred_flag);\n    int idx              = ff_hevc_pel_weight[block_w];\n\n    x_off += mv->x >> 2;\n    y_off += mv->y >> 2;\n    src   += y_off * srcstride + (x_off * (1 << s->ps.sps->pixel_shift));\n\n    if (x_off < QPEL_EXTRA_BEFORE || y_off < QPEL_EXTRA_AFTER ||\n        x_off >= pic_width - block_w - QPEL_EXTRA_AFTER ||\n        y_off >= pic_height - block_h - QPEL_EXTRA_AFTER) {\n        const ptrdiff_t edge_emu_stride = EDGE_EMU_BUFFER_STRIDE << s->ps.sps->pixel_shift;\n        int offset     = QPEL_EXTRA_BEFORE * srcstride       + (QPEL_EXTRA_BEFORE << s->ps.sps->pixel_shift);\n        int buf_offset = QPEL_EXTRA_BEFORE * edge_emu_stride + (QPEL_EXTRA_BEFORE << s->ps.sps->pixel_shift);\n\n        s->vdsp.emulated_edge_mc(lc->edge_emu_buffer, src - offset,\n                                 edge_emu_stride, srcstride,\n                                 block_w + QPEL_EXTRA,\n                                 block_h + QPEL_EXTRA,\n                                 x_off - QPEL_EXTRA_BEFORE, y_off - QPEL_EXTRA_BEFORE,\n                                 pic_width, pic_height);\n        src = lc->edge_emu_buffer + buf_offset;\n        srcstride = edge_emu_stride;\n    }\n\n    if (!weight_flag)\n        s->hevcdsp.put_hevc_qpel_uni[idx][!!my][!!mx](dst, dststride, src, srcstride,\n                                                      block_h, mx, my, block_w);\n    else\n        s->hevcdsp.put_hevc_qpel_uni_w[idx][!!my][!!mx](dst, dststride, src, srcstride,\n                                                        block_h, s->sh.luma_log2_weight_denom,\n                                                        luma_weight, luma_offset, mx, my, block_w);\n}\n",
        "output": "0",
        "index": 90783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int h2c_frt_handle_headers(struct h2c *h2c, struct h2s *h2s)\n{\n\tint error;\n\n\tif (!h2c->dfl) {\n\t\terror = H2_ERR_PROTOCOL_ERROR; // empty headers frame!\n\t\tgoto strm_err;\n\t}\n\n\tif (!h2c->dbuf->size)\n\t\treturn 0; // empty buffer\n\n\tif (h2c->dbuf->i < h2c->dfl && h2c->dbuf->i < h2c->dbuf->size)\n\t\treturn 0; // incomplete frame\n\n\t/* now either the frame is complete or the buffer is complete */\n\tif (h2s->st != H2_SS_IDLE) {\n\t\t/* FIXME: stream already exists, this is only allowed for\n\t\t * trailers (not supported for now).\n\t\t */\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\telse if (h2c->dsi <= h2c->max_id || !(h2c->dsi & 1)) {\n\t\t/* RFC7540#5.1.1 stream id > prev ones, and must be odd here */\n\t\terror = H2_ERR_PROTOCOL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\th2s = h2c_stream_new(h2c, h2c->dsi);\n\tif (!h2s) {\n\t\terror = H2_ERR_INTERNAL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\th2s->st = H2_SS_OPEN;\n\tif (h2c->dff & H2_F_HEADERS_END_STREAM) {\n\t\th2s->st = H2_SS_HREM;\n\t\th2s->flags |= H2_SF_ES_RCVD;\n\t}\n\n\t/* call the upper layers to process the frame, then let the upper layer\n\t * notify the stream about any change.\n\t */\n\th2s->cs->data_cb->recv(h2s->cs);\n\n\tif (h2s->cs->data_cb->wake(h2s->cs) < 0) {\n\t\t/* FIXME: cs has already been destroyed, but we have to kill h2s. */\n\t\terror = H2_ERR_INTERNAL_ERROR;\n\t\tgoto conn_err;\n\t}\n\n\tif (h2c->st0 >= H2_CS_ERROR)\n\t\treturn 0;\n\n\tif (h2s->st >= H2_SS_ERROR) {\n\t\t/* stream error : send RST_STREAM */\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\telse {\n\t\t/* update the max stream ID if the request is being processed */\n\t\tif (h2s->id > h2c->max_id)\n\t\t\th2c->max_id = h2s->id;\n\t}\n\n\treturn 1;\n\n conn_err:\n\th2c_error(h2c, error);\n\treturn 0;\n\n strm_err:\n\tif (h2s) {\n\t\th2s_error(h2s, error);\n\t\th2c->st0 = H2_CS_FRAME_E;\n\t}\n\telse\n\t\th2c_error(h2c, error);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 7793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID,\n                       const xmlChar *SystemID) {\n    xmlDetectSAX2(ctxt);\n    GROW;\n\n    if ((ctxt->encoding == NULL) &&\n        (ctxt->input->end - ctxt->input->cur >= 4)) {\n        xmlChar start[4];\n\txmlCharEncoding enc;\n\n\tstart[0] = RAW;\n\tstart[1] = NXT(1);\n\tstart[2] = NXT(2);\n\tstart[3] = NXT(3);\n\tenc = xmlDetectCharEncoding(start, 4);\n\tif (enc != XML_CHAR_ENCODING_NONE)\n\t    xmlSwitchEncoding(ctxt, enc);\n    }\n\n    if (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) {\n\txmlParseTextDecl(ctxt);\n\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t    /*\n\t     * The XML REC instructs us to stop parsing right here\n\t     */\n\t    xmlHaltParser(ctxt);\n\t    return;\n\t}\n    }\n    if (ctxt->myDoc == NULL) {\n        ctxt->myDoc = xmlNewDoc(BAD_CAST \"1.0\");\n\tif (ctxt->myDoc == NULL) {\n\t    xmlErrMemory(ctxt, \"New Doc failed\");\n\t    return;\n\t}\n\tctxt->myDoc->properties = XML_DOC_INTERNAL;\n    }\n    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->intSubset == NULL))\n        xmlCreateIntSubset(ctxt->myDoc, NULL, ExternalID, SystemID);\n\n    ctxt->instate = XML_PARSER_DTD;\n    ctxt->external = 1;\n    SKIP_BLANKS;\n    while (((RAW == '<') && (NXT(1) == '?')) ||\n           ((RAW == '<') && (NXT(1) == '!')) ||\n\t   (RAW == '%')) {\n\tconst xmlChar *check = CUR_PTR;\n\tunsigned int cons = ctxt->input->consumed;\n\n\tGROW;\n        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t    xmlParseConditionalSections(ctxt);\n\t} else\n\t    xmlParseMarkupDecl(ctxt);\n        SKIP_BLANKS;\n\n\tif ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n\t    xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n\t    break;\n\t}\n    }\n\n    if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n    }\n\n}\n",
        "output": "0",
        "index": 59493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n\t\t/* Expect four bytes of prefix, and N*9 bytes of touch data. */\n \t\tif (size < 4 || ((size - 4) % 9) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 4) / 9;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\n\t\tclicks = data[1];\n\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;\n\t\t */\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n\t\t/* Expect six bytes of prefix, and N*8 bytes of touch data. */\n \t\tif (size < 6 || ((size - 6) % 8) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 6) / 8;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\n\t\t/* When emulating three-button mode, it is important\n\t\t * to have the current touch information before\n\t\t * generating a click event.\n\t\t */\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;\n\t\t */\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\t/* Sometimes the trackpad sends two touch reports in one\n\t\t * packet.\n\t\t */\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */\n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\n\tinput_sync(input);\n\treturn 1;\n}\n",
        "output": "1",
        "index": 179551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct crypto_instance *crypto_authenc_alloc(struct rtattr **tb)\n{\n\tstruct crypto_attr_type *algt;\n\tstruct crypto_instance *inst;\n\tstruct hash_alg_common *auth;\n\tstruct crypto_alg *auth_base;\n\tstruct crypto_alg *enc;\n\tstruct authenc_instance_ctx *ctx;\n\tconst char *enc_name;\n\tint err;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn ERR_CAST(algt);\n\n\tif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tauth = ahash_attr_alg(tb[1], CRYPTO_ALG_TYPE_HASH,\n\t\t\t       CRYPTO_ALG_TYPE_AHASH_MASK);\n\tif (IS_ERR(auth))\n\t\treturn ERR_CAST(auth);\n\n\tauth_base = &auth->base;\n\n\tenc_name = crypto_attr_alg_name(tb[2]);\n\terr = PTR_ERR(enc_name);\n\tif (IS_ERR(enc_name))\n\t\tgoto out_put_auth;\n\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!inst)\n\t\tgoto out_put_auth;\n\n\tctx = crypto_instance_ctx(inst);\n\n\terr = crypto_init_ahash_spawn(&ctx->auth, auth, inst);\n\tif (err)\n\t\tgoto err_free_inst;\n\n\tcrypto_set_skcipher_spawn(&ctx->enc, inst);\n\terr = crypto_grab_skcipher(&ctx->enc, enc_name, 0,\n\t\t\t\t   crypto_requires_sync(algt->type,\n\t\t\t\t\t\t\talgt->mask));\n\tif (err)\n\t\tgoto err_drop_auth;\n\n\tenc = crypto_skcipher_spawn_alg(&ctx->enc);\n\n\terr = -ENAMETOOLONG;\n\tif (snprintf(inst->alg.cra_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"authenc(%s,%s)\", auth_base->cra_name, enc->cra_name) >=\n\t    CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_drop_enc;\n\n\tif (snprintf(inst->alg.cra_driver_name, CRYPTO_MAX_ALG_NAME,\n\t\t     \"authenc(%s,%s)\", auth_base->cra_driver_name,\n\t\t     enc->cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\n\t\tgoto err_drop_enc;\n\n\tinst->alg.cra_flags = CRYPTO_ALG_TYPE_AEAD;\n\tinst->alg.cra_flags |= enc->cra_flags & CRYPTO_ALG_ASYNC;\n\tinst->alg.cra_priority = enc->cra_priority *\n\t\t\t\t 10 + auth_base->cra_priority;\n\tinst->alg.cra_blocksize = enc->cra_blocksize;\n\tinst->alg.cra_alignmask = auth_base->cra_alignmask | enc->cra_alignmask;\n\tinst->alg.cra_type = &crypto_aead_type;\n\n\tinst->alg.cra_aead.ivsize = enc->cra_ablkcipher.ivsize;\n\tinst->alg.cra_aead.maxauthsize = auth->digestsize;\n\n\tinst->alg.cra_ctxsize = sizeof(struct crypto_authenc_ctx);\n\n\tinst->alg.cra_init = crypto_authenc_init_tfm;\n\tinst->alg.cra_exit = crypto_authenc_exit_tfm;\n\n\tinst->alg.cra_aead.setkey = crypto_authenc_setkey;\n\tinst->alg.cra_aead.encrypt = crypto_authenc_encrypt;\n\tinst->alg.cra_aead.decrypt = crypto_authenc_decrypt;\n\tinst->alg.cra_aead.givencrypt = crypto_authenc_givencrypt;\n\nout:\n\tcrypto_mod_put(auth_base);\n\treturn inst;\n\nerr_drop_enc:\n\tcrypto_drop_skcipher(&ctx->enc);\nerr_drop_auth:\n\tcrypto_drop_ahash(&ctx->auth);\nerr_free_inst:\n\tkfree(inst);\nout_put_auth:\n\tinst = ERR_PTR(err);\n\tgoto out;\n}\n",
        "output": "0",
        "index": 45519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long kvm_arch_vm_ioctl(struct file *filp,\n\t\tunsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_MEMORY_REGION: {\n\t\tstruct kvm_memory_region kvm_mem;\n\t\tstruct kvm_userspace_memory_region kvm_userspace_mem;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm_mem, argp, sizeof kvm_mem))\n\t\t\tgoto out;\n\t\tkvm_userspace_mem.slot = kvm_mem.slot;\n\t\tkvm_userspace_mem.flags = kvm_mem.flags;\n\t\tkvm_userspace_mem.guest_phys_addr =\n\t\t\t\t\tkvm_mem.guest_phys_addr;\n\t\tkvm_userspace_mem.memory_size = kvm_mem.memory_size;\n\t\tr = kvm_vm_ioctl_set_memory_region(kvm,\n\t\t\t\t\t&kvm_userspace_mem, 0);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tbreak;\n\t\t}\n\tcase KVM_CREATE_IRQCHIP:\n\t\tr = -EFAULT;\n\t\tr = kvm_ioapic_init(kvm);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase KVM_IRQ_LINE_STATUS:\n\tcase KVM_IRQ_LINE: {\n\t\tstruct kvm_irq_level irq_event;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq_event, argp, sizeof irq_event))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (irqchip_in_kernel(kvm)) {\n\t\t\t__s32 status;\n\t\t\tstatus = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t    irq_event.irq, irq_event.level);\n\t\t\tif (ioctl == KVM_IRQ_LINE_STATUS) {\n\t\t\t\tr = -EFAULT;\n\t\t\t\tirq_event.status = status;\n\t\t\t\tif (copy_to_user(argp, &irq_event,\n\t\t\t\t\t\t\tsizeof irq_event))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tr = 0;\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip chip;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&chip, argp, sizeof chip))\n\t\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, &chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &chip, sizeof chip))\n\t\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip chip;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&chip, argp, sizeof chip))\n\t\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!irqchip_in_kernel(kvm))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, &chip);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\t;\n\t}\nout:\n\treturn r;\n}\n",
        "output": "0",
        "index": 20614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long FS_ReadFileDir(const char *qpath, void *searchPath, qboolean unpure, void **buffer)\n{\n\tfileHandle_t h;\n\tsearchpath_t\t*search;\n\tbyte*           buf;\n\tqboolean isConfig;\n\tlong len;\n\n\tif ( !fs_searchpaths ) {\n\t\tCom_Error( ERR_FATAL, \"Filesystem call made without initialization\" );\n\t}\n\n\tif ( !qpath || !qpath[0] ) {\n\t\tCom_Error( ERR_FATAL, \"FS_ReadFile with empty name\" );\n\t}\n\n\tbuf = NULL; // quiet compiler warning\n\n\tif ( strstr( qpath, \".cfg\" ) ) {\n\t\tisConfig = qtrue;\n\t\tif ( com_journal && com_journal->integer == 2 ) {\n\t\t\tint r;\n\n\t\t\tCom_DPrintf( \"Loading %s from journal file.\\n\", qpath );\n\t\t\tr = FS_Read( &len, sizeof( len ), com_journalDataFile );\n\t\t\tif ( r != sizeof( len ) ) {\n\t\t\t\tif ( buffer != NULL ) {\n\t\t\t\t\t*buffer = NULL;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( !len ) {\n\t\t\t\tif ( buffer == NULL ) {\n\t\t\t\t\treturn 1;           // hack for old journal files\n\t\t\t\t}\n\t\t\t\t*buffer = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( buffer == NULL ) {\n\t\t\t\treturn len;\n\t\t\t}\n\n\t\t\tbuf = Hunk_AllocateTempMemory( len + 1 );\n\t\t\t*buffer = buf;\n\n\t\t\tr = FS_Read( buf, len, com_journalDataFile );\n\t\t\tif ( r != len ) {\n\t\t\t\tCom_Error( ERR_FATAL, \"Read from journalDataFile failed\" );\n\t\t\t}\n\n\t\t\tfs_loadCount++;\n\t\t\tfs_loadStack++;\n\n\t\t\tbuf[len] = 0;\n\n\t\t\treturn len;\n\t\t}\n\t} else {\n\t\tisConfig = qfalse;\n\t}\n\n\tsearch = searchPath;\n\n\tif(search == NULL)\n\t{\n\t\tlen = FS_FOpenFileRead(qpath, &h, qfalse);\n\t}\n\telse\n\t{\n\t\tlen = FS_FOpenFileReadDir(qpath, search, &h, qfalse, unpure);\n\t}\n\n\tif ( h == 0 ) {\n\t\tif ( buffer ) {\n\t\t\t*buffer = NULL;\n\t\t}\n\t\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\t\tCom_DPrintf( \"Writing zero for %s to journal file.\\n\", qpath );\n\t\t\tlen = 0;\n\t\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\t\tFS_Flush( com_journalDataFile );\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ( !buffer ) {\n\t\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\t\tCom_DPrintf( \"Writing len for %s to journal file.\\n\", qpath );\n\t\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\t\tFS_Flush( com_journalDataFile );\n\t\t}\n\t\tFS_FCloseFile( h );\n\t\treturn len;\n\t}\n\n\tfs_loadCount++;\n\tfs_loadStack++;\n\n\tbuf = Hunk_AllocateTempMemory( len + 1 );\n\t*buffer = buf;\n\n\tFS_Read( buf, len, h );\n\n\tbuf[len] = 0;\n\tFS_FCloseFile( h );\n\n\tif ( isConfig && com_journal && com_journal->integer == 1 ) {\n\t\tCom_DPrintf( \"Writing %s to journal file.\\n\", qpath );\n\t\tFS_Write( &len, sizeof( len ), com_journalDataFile );\n\t\tFS_Write( buf, len, com_journalDataFile );\n\t\tFS_Flush( com_journalDataFile );\n\t}\n\treturn len;\n}\n",
        "output": "0",
        "index": 95924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int64_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time);\n    c->time_scale = avio_rb32(pb); /* time scale */\n    if (c->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mvhd time scale %d, defaulting to 1\\n\", c->time_scale);\n        c->time_scale = 1;\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    if (c->time_scale > 0 && !c->trex_data)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    /* movie display matrix, store it in main context and use it later on */\n    for (i = 0; i < 3; i++) {\n        c->movie_display_matrix[i][0] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][1] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][2] = avio_rb32(pb); //  2.30 fixed point\n    }\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n\n    return 0;\n}\n",
        "output": "0",
        "index": 61449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  tt_cmap2_validate( FT_Byte*      table,\n                     FT_Validator  valid )\n  {\n    FT_Byte*  p;\n    FT_UInt   length;\n\n    FT_UInt   n, max_subs;\n    FT_Byte*  keys;        /* keys table     */\n    FT_Byte*  subs;        /* sub-headers    */\n    FT_Byte*  glyph_ids;   /* glyph ID array */\n\n\n    if ( table + 2 + 2 > valid->limit )\n      FT_INVALID_TOO_SHORT;\n\n    p      = table + 2;           /* skip format */\n    length = TT_NEXT_USHORT( p );\n\n    if ( table + length > valid->limit || length < 6 + 512 )\n      FT_INVALID_TOO_SHORT;\n\n    keys = table + 6;\n\n    /* parse keys to compute sub-headers count */\n    p        = keys;\n    max_subs = 0;\n    for ( n = 0; n < 256; n++ )\n    {\n      FT_UInt  idx = TT_NEXT_USHORT( p );\n\n\n      /* value must be multiple of 8 */\n      if ( valid->level >= FT_VALIDATE_PARANOID && ( idx & 7 ) != 0 )\n        FT_INVALID_DATA;\n\n      idx >>= 3;\n\n      if ( idx > max_subs )\n        max_subs = idx;\n    }\n\n    FT_ASSERT( p == table + 518 );\n\n    subs      = p;\n    glyph_ids = subs + (max_subs + 1) * 8;\n    if ( glyph_ids > valid->limit )\n      FT_INVALID_TOO_SHORT;\n\n    /* parse sub-headers */\n    for ( n = 0; n <= max_subs; n++ )\n    {\n      FT_UInt  first_code, code_count, offset;\n      FT_Int   delta;\n\n\n      first_code = TT_NEXT_USHORT( p );\n      code_count = TT_NEXT_USHORT( p );\n      delta      = TT_NEXT_SHORT( p );\n      offset     = TT_NEXT_USHORT( p );\n\n      /* many Dynalab fonts have empty sub-headers */\n      if ( code_count == 0 )\n        continue;\n\n      /* check range within 0..255 */\n      if ( valid->level >= FT_VALIDATE_PARANOID )\n      {\n        if ( first_code >= 256 || first_code + code_count > 256 )\n          FT_INVALID_DATA;\n      }\n\n      /* check offset */\n      if ( offset != 0 )\n      {\n        FT_Byte*  ids;\n\n\n        ids = p - 2 + offset;\n        if ( ids < glyph_ids || ids + code_count*2 > table + length )\n          FT_INVALID_OFFSET;\n\n        /* check glyph IDs */\n        if ( valid->level >= FT_VALIDATE_TIGHT )\n        {\n          FT_Byte*  limit = p + code_count * 2;\n          FT_UInt   idx;\n\n\n          for ( ; p < limit; )\n          {\n            idx = TT_NEXT_USHORT( p );\n            if ( idx != 0 )\n            {\n              idx = ( idx + delta ) & 0xFFFFU;\n              if ( idx >= TT_VALID_GLYPH_COUNT( valid ) )\n                FT_INVALID_GLYPH_ID;\n            }\n          }\n        }\n      }\n    }\n\n    return FT_Err_Ok;\n  }\n",
        "output": "0",
        "index": 6973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tLIST_HEAD(firing);\n\tstruct k_itimer *timer, *next;\n\n\tBUG_ON(!irqs_disabled());\n\n#define UNEXPIRED(clock) \\\n\t\t(cputime_eq(tsk->it_##clock##_expires, cputime_zero) || \\\n\t\t cputime_lt(clock##_ticks(tsk), tsk->it_##clock##_expires))\n\n\tif (UNEXPIRED(prof) && UNEXPIRED(virt) &&\n\t    (tsk->it_sched_expires == 0 ||\n\t     tsk->se.sum_exec_runtime < tsk->it_sched_expires))\n\t\treturn;\n\n#undef\tUNEXPIRED\n\n\t/*\n\t * Double-check with locks held.\n\t */\n\tread_lock(&tasklist_lock);\n\tif (likely(tsk->signal != NULL)) {\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/*\n\t\t * Here we take off tsk->cpu_timers[N] and tsk->signal->cpu_timers[N]\n\t\t * all the timers that are firing, and put them on the firing list.\n\t\t */\n\t\tcheck_thread_timers(tsk, &firing);\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\t/*\n\t\t * We must release these locks before taking any timer's lock.\n\t\t * There is a potential race with timer deletion here, as the\n\t\t * siglock now protects our private firing list.  We have set\n\t\t * the firing flag in each timer, so that a deletion attempt\n\t\t * that gets the timer lock before we do will give it up and\n\t\t * spin until we've taken care of that timer below.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * noone will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint firing;\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tfiring = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(firing >= 0)) {\n\t\t\tcpu_timer_fire(timer);\n\t\t}\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}\n",
        "output": "0",
        "index": 24696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(int) gdTransformAffineCopy(gdImagePtr dst,\n\t\t  int dst_x, int dst_y,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_region,\n\t\t  const double affine[6])\n{\n\tint c1x,c1y,c2x,c2y;\n\tint backclip = 0;\n\tint backup_clipx1, backup_clipy1, backup_clipx2, backup_clipy2;\n\tregister int x, y, src_offset_x, src_offset_y;\n\tdouble inv[6];\n\tint *dst_p;\n\tgdPointF pt, src_pt;\n\tgdRect bbox;\n\tint end_x, end_y;\n\tgdInterpolationMethod interpolation_id_bak = GD_DEFAULT;\n\n\t/* These methods use special implementations */\n\tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n\t\tinterpolation_id_bak = src->interpolation_id;\n\t\t\n\t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n\t}\n\n\n\tgdImageClipRectangle(src, src_region);\n\n\tif (src_region->x > 0 || src_region->y > 0\n\t\t|| src_region->width < gdImageSX(src)\n\t\t|| src_region->height < gdImageSY(src)) {\n\t\tbackclip = 1;\n\n\t\tgdImageGetClip(src, &backup_clipx1, &backup_clipy1,\n\t\t&backup_clipx2, &backup_clipy2);\n\n\t\tgdImageSetClip(src, src_region->x, src_region->y,\n\t\t\tsrc_region->x + src_region->width - 1,\n\t\t\tsrc_region->y + src_region->height - 1);\n\t}\n\n\tif (!gdTransformAffineBoundingBox(src_region, affine, &bbox)) {\n\t\tif (backclip) {\n\t\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\t\tbackup_clipx2, backup_clipy2);\n\t\t}\n\t\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\t\treturn GD_FALSE;\n\t}\n\n\tgdImageGetClip(dst, &c1x, &c1y, &c2x, &c2y);\n\n\tend_x = bbox.width  + abs(bbox.x);\n\tend_y = bbox.height + abs(bbox.y);\n\n\t/* Get inverse affine to let us work with destination -> source */\n\tgdAffineInvert(inv, affine);\n\n\tsrc_offset_x =  src_region->x;\n\tsrc_offset_y =  src_region->y;\n\n\tif (dst->alphaBlendingFlag) {\n\t\tfor (y = bbox.y; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5;\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\t\t\t\tgdImageSetPixel(dst, dst_x + x, dst_y + y, getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, 0));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (y = 0; y <= end_y; y++) {\n\t\t\tpt.y = y + 0.5 + bbox.y;\n\t\t\tif ((dst_y + y) < 0 || ((dst_y + y) > gdImageSY(dst) -1)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdst_p = dst->tpixels[dst_y + y] + dst_x;\n\n\t\t\tfor (x = 0; x <= end_x; x++) {\n\t\t\t\tpt.x = x + 0.5 + bbox.x;\n\t\t\t\tgdAffineApplyToPointF(&src_pt, &pt, inv);\n\n\t\t\t\tif ((dst_x + x) < 0 || (dst_x + x) > (gdImageSX(dst) - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*(dst_p++) = getPixelInterpolated(src, src_offset_x + src_pt.x, src_offset_y + src_pt.y, -1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Restore clip if required */\n\tif (backclip) {\n\t\tgdImageSetClip(src, backup_clipx1, backup_clipy1,\n\t\t\t\tbackup_clipx2, backup_clipy2);\n\t}\n\n\tgdImageSetInterpolationMethod(src, interpolation_id_bak);\n\treturn GD_TRUE;\n}\n",
        "output": "0",
        "index": 70924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tls1_setup_key_block(SSL *s)\n{\n    unsigned char *p;\n    const EVP_CIPHER *c;\n    const EVP_MD *hash;\n    int num;\n    SSL_COMP *comp;\n    int mac_type = NID_undef, mac_secret_size = 0;\n    int ret = 0;\n\n     if (s->s3->tmp.key_block_length != 0)\n         return (1);\n \n    if (!ssl_cipher_get_evp\n        (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,\n         SSL_USE_ETM(s))) {\n         SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\n         return (0);\n     }\n\n    s->s3->tmp.new_sym_enc = c;\n    s->s3->tmp.new_hash = hash;\n    s->s3->tmp.new_mac_pkey_type = mac_type;\n    s->s3->tmp.new_mac_secret_size = mac_secret_size;\n    num = EVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c);\n    num *= 2;\n\n    ssl3_cleanup_key_block(s);\n\n    if ((p = OPENSSL_malloc(num)) == NULL) {\n        SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    s->s3->tmp.key_block_length = num;\n    s->s3->tmp.key_block = p;\n\n#ifdef SSL_DEBUG\n    printf(\"client random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->client_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"server random\\n\");\n    {\n        int z;\n        for (z = 0; z < SSL3_RANDOM_SIZE; z++)\n            printf(\"%02X%c\", s->s3->server_random[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n    printf(\"master key\\n\");\n    {\n        int z;\n        for (z = 0; z < s->session->master_key_length; z++)\n            printf(\"%02X%c\", s->session->master_key[z],\n                   ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n    if (!tls1_generate_key_block(s, p, num))\n        goto err;\n#ifdef SSL_DEBUG\n    printf(\"\\nkey block\\n\");\n    {\n        int z;\n        for (z = 0; z < num; z++)\n            printf(\"%02X%c\", p[z], ((z + 1) % 16) ? ' ' : '\\n');\n    }\n#endif\n\n    if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)\n        && s->method->version <= TLS1_VERSION) {\n        /*\n         * enable vulnerability countermeasure for CBC ciphers with known-IV\n         * problem (http://www.openssl.org/~bodo/tls-cbc.txt)\n         */\n        s->s3->need_empty_fragments = 1;\n\n        if (s->session->cipher != NULL) {\n            if (s->session->cipher->algorithm_enc == SSL_eNULL)\n                s->s3->need_empty_fragments = 0;\n\n#ifndef OPENSSL_NO_RC4\n            if (s->session->cipher->algorithm_enc == SSL_RC4)\n                s->s3->need_empty_fragments = 0;\n#endif\n        }\n    }\n\n    ret = 1;\n err:\n    return (ret);\n}\n",
        "output": "1",
        "index": 181598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_remove(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_defer_ops\tdfops;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\terror;\n\n\tXFS_STATS_INC(mp, xs_attr_remove);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.firstblock = &firstblock;\n\targs.dfops = &dfops;\n\n\t/*\n\t * we have no control over the attribute names that userspace passes us\n\t * to remove, so we have to allow the name lookup prior to attribute\n\t * removal to fail.\n\t */\n\targs.op_flags = XFS_DA_OP_OKNOENT;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\terror = xfs_trans_alloc(mp, &M_RES(mp)->tr_attrrm,\n\t\t\tXFS_ATTRRM_SPACE_RES(mp), 0,\n\t\t\t(flags & ATTR_ROOT) ? XFS_TRANS_RESERVE : 0,\n\t\t\t&args.trans);\n\tif (error)\n\t\treturn error;\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\t/*\n\t * No need to make quota reservations here. We expect to release some\n\t * blocks not allocate in the common case.\n\t */\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\tif (!xfs_inode_hasattr(dp)) {\n\t\terror = -ENOATTR;\n\t} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\n\t\tASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\n\t\terror = xfs_attr_shortform_remove(&args);\n\t} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\n\t\terror = xfs_attr_leaf_removename(&args);\n\t} else {\n\t\terror = xfs_attr_node_removename(&args);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans)\n\t\txfs_trans_cancel(args.trans);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}\n",
        "output": "0",
        "index": 76325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_mms_asf_header_parser(MMSContext *mms)\n{\n    uint8_t *p = mms->asf_header;\n    uint8_t *end;\n    int flags, stream_id;\n    mms->stream_num = 0;\n\n    if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||\n        memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"Corrupt stream (invalid ASF header, size=%d)\\n\",\n               mms->asf_header_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    end = mms->asf_header + mms->asf_header_size;\n\n    p += sizeof(ff_asf_guid) + 14;\n    while(end - p >= sizeof(ff_asf_guid) + 8) {\n        uint64_t chunksize;\n        if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {\n            chunksize = 50; // see Reference [2] section 5.1\n        } else {\n            chunksize = AV_RL64(p + sizeof(ff_asf_guid));\n        }\n        if (!chunksize || chunksize > end - p) {\n            av_log(NULL, AV_LOG_ERROR,\n                   \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n                   chunksize);\n            return AVERROR_INVALIDDATA;\n        }\n        if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n            /* read packet size */\n            if (end - p > sizeof(ff_asf_guid) * 2 + 68) {\n                mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);\n                if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (too large pkt_len %d)\\n\",\n                           mms->asf_packet_len);\n                    return AVERROR_INVALIDDATA;\n                 }\n             }\n         } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n            stream_id = flags & 0x7F;\n            if (mms->stream_num < MMS_MAX_STREAMS &&\n                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n                mms->streams = av_fast_realloc(mms->streams,\n                                   &mms->nb_streams_allocated,\n                                   (mms->stream_num + 1) * sizeof(MMSStream));\n                if (!mms->streams)\n                    return AVERROR(ENOMEM);\n                mms->streams[mms->stream_num].id = stream_id;\n                mms->stream_num++;\n            } else {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Corrupt stream (too many A/V streams)\\n\");\n                return AVERROR_INVALIDDATA;\n             }\n         } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n             if (end - p >= 88) {\n                int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);\n                uint64_t skip_bytes = 88;\n                while (stream_count--) {\n                    if (end - p < skip_bytes + 4) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next stream name length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);\n                }\n                while (ext_len_count--) {\n                    if (end - p < skip_bytes + 22) {\n                        av_log(NULL, AV_LOG_ERROR,\n                               \"Corrupt stream (next extension system info length is not in the buffer)\\n\");\n                        return AVERROR_INVALIDDATA;\n                    }\n                    skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);\n                }\n                if (end - p < skip_bytes) {\n                    av_log(NULL, AV_LOG_ERROR,\n                           \"Corrupt stream (the last extension system info length is invalid)\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                if (chunksize - skip_bytes > 24)\n                    chunksize = skip_bytes;\n             }\n         } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n             chunksize = 46; // see references [2] section 3.4. This should be set 46.\n         }\n         p += chunksize;\n     }\n\n    return 0;\n}\n",
        "output": "1",
        "index": 182099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t PSDPackbitsEncodeImage(Image *image,const size_t length,\n  const unsigned char *pixels,unsigned char *compact_pixels,\n  ExceptionInfo *exception)\n{\n  int\n    count;\n\n  register ssize_t\n    i,\n    j;\n\n  register unsigned char\n    *q;\n\n  unsigned char\n    *packbits;\n\n  /*\n    Compress pixels with Packbits encoding.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  assert(compact_pixels != (unsigned char *) NULL);\n  packbits=(unsigned char *) AcquireQuantumMemory(128UL,sizeof(*packbits));\n  if (packbits == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  q=compact_pixels;\n  for (i=(ssize_t) length; i != 0; )\n  {\n    switch (i)\n    {\n      case 1:\n      {\n        i--;\n        *q++=(unsigned char) 0;\n        *q++=(*pixels);\n        break;\n      }\n      case 2:\n      {\n        i-=2;\n        *q++=(unsigned char) 1;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        break;\n      }\n      case 3:\n      {\n        i-=3;\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            *q++=(unsigned char) ((256-3)+1);\n            *q++=(*pixels);\n            break;\n          }\n        *q++=(unsigned char) 2;\n        *q++=(*pixels);\n        *q++=pixels[1];\n        *q++=pixels[2];\n        break;\n      }\n      default:\n      {\n        if ((*pixels == *(pixels+1)) && (*(pixels+1) == *(pixels+2)))\n          {\n            /*\n              Packed run.\n            */\n            count=3;\n            while (((ssize_t) count < i) && (*pixels == *(pixels+count)))\n            {\n              count++;\n              if (count >= 127)\n                break;\n            }\n            i-=count;\n            *q++=(unsigned char) ((256-count)+1);\n            *q++=(*pixels);\n            pixels+=count;\n            break;\n          }\n        /*\n          Literal run.\n        */\n        count=0;\n        while ((*(pixels+count) != *(pixels+count+1)) ||\n               (*(pixels+count+1) != *(pixels+count+2)))\n        {\n          packbits[count+1]=pixels[count];\n          count++;\n          if (((ssize_t) count >= (i-3)) || (count >= 127))\n            break;\n        }\n        i-=count;\n        *packbits=(unsigned char) (count-1);\n        for (j=0; j <= (ssize_t) count; j++)\n          *q++=packbits[j];\n        pixels+=count;\n        break;\n      }\n    }\n  }\n  *q++=(unsigned char) 128;  /* EOD marker */\n  packbits=(unsigned char *) RelinquishMagickMemory(packbits);\n  return((size_t) (q-compact_pixels));\n}\n",
        "output": "0",
        "index": 69045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rm_read_index(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    unsigned int size, n_pkts, str_id, next_off, n, pos, pts;\n    AVStream *st;\n\n    do {\n        if (avio_rl32(pb) != MKTAG('I','N','D','X'))\n            return -1;\n        size     = avio_rb32(pb);\n        if (size < 20)\n            return -1;\n        avio_skip(pb, 2);\n        n_pkts   = avio_rb32(pb);\n        str_id   = avio_rb16(pb);\n        next_off = avio_rb32(pb);\n        for (n = 0; n < s->nb_streams; n++)\n            if (s->streams[n]->id == str_id) {\n                st = s->streams[n];\n                break;\n            }\n        if (n == s->nb_streams) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Invalid stream index %d for index at pos %\"PRId64\"\\n\",\n                   str_id, avio_tell(pb));\n            goto skip;\n        } else if ((avio_size(pb) - avio_tell(pb)) / 14 < n_pkts) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Nr. of packets in packet index for stream index %d \"\n                   \"exceeds filesize (%\"PRId64\" at %\"PRId64\" = %\"PRId64\")\\n\",\n                   str_id, avio_size(pb), avio_tell(pb),\n                   (avio_size(pb) - avio_tell(pb)) / 14);\n            goto skip;\n        }\n\n        for (n = 0; n < n_pkts; n++) {\n            avio_skip(pb, 2);\n            pts = avio_rb32(pb);\n            pos = avio_rb32(pb);\n            avio_skip(pb, 4); /* packet no. */\n\n            av_add_index_entry(st, pos, pts, 0, 0, AVINDEX_KEYFRAME);\n        }\n\nskip:\n        if (next_off && avio_tell(pb) < next_off &&\n            avio_seek(pb, next_off, SEEK_SET) < 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Non-linear index detected, not supported\\n\");\n            return -1;\n        }\n    } while (next_off);\n\n    return 0;\n}\n",
        "output": "0",
        "index": 61861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderProcessHostImpl::Init() {\n  if (channel_.get())\n    return true;\n\n  CommandLine::StringType renderer_prefix;\n#if defined(OS_POSIX)\n  const CommandLine& browser_command_line = *CommandLine::ForCurrentProcess();\n  renderer_prefix =\n      browser_command_line.GetSwitchValueNative(switches::kRendererCmdPrefix);\n#endif  // defined(OS_POSIX)\n\n#if defined(OS_LINUX)\n  int flags = renderer_prefix.empty() ? ChildProcessHost::CHILD_ALLOW_SELF :\n                                        ChildProcessHost::CHILD_NORMAL;\n#else\n  int flags = ChildProcessHost::CHILD_NORMAL;\n#endif\n\n  FilePath renderer_path = ChildProcessHost::GetChildPath(flags);\n  if (renderer_path.empty())\n    return false;\n\n  const std::string channel_id =\n      IPC::Channel::GenerateVerifiedChannelID(std::string());\n  channel_.reset(\n#if defined(OS_ANDROID)\n      browser_command_line.HasSwitch(switches::kEnableWebViewSynchronousAPIs) ?\n          new IPC::SyncChannel(\n              channel_id, IPC::Channel::MODE_SERVER, this,\n              BrowserThread::GetMessageLoopProxyForThread(BrowserThread::IO),\n              true, &dummy_shutdown_event_) :\n#endif\n      new IPC::ChannelProxy(\n          channel_id, IPC::Channel::MODE_SERVER, this,\n          BrowserThread::GetMessageLoopProxyForThread(BrowserThread::IO)));\n\n  GetContentClient()->browser()->RenderProcessHostCreated(this);\n\n  CreateMessageFilters();\n\n  if (run_renderer_in_process()) {\n    in_process_renderer_.reset(new RendererMainThread(channel_id));\n\n    base::Thread::Options options;\n#if !defined(TOOLKIT_GTK) && !defined(OS_ANDROID)\n    options.message_loop_type = MessageLoop::TYPE_UI;\n#else\n    options.message_loop_type = MessageLoop::TYPE_DEFAULT;\n#endif\n    in_process_renderer_->StartWithOptions(options);\n\n    OnProcessLaunched();  // Fake a callback that the process is ready.\n  } else {\n    CommandLine* cmd_line = new CommandLine(renderer_path);\n    if (!renderer_prefix.empty())\n      cmd_line->PrependWrapper(renderer_prefix);\n    AppendRendererCommandLine(cmd_line);\n    cmd_line->AppendSwitchASCII(switches::kProcessChannelID, channel_id);\n\n    child_process_launcher_.reset(new ChildProcessLauncher(\n#if defined(OS_WIN)\n        FilePath(),\n#elif defined(OS_POSIX)\n        renderer_prefix.empty(),\n        base::EnvironmentVector(),\n        channel_->TakeClientFileDescriptor(),\n#endif\n        cmd_line,\n        GetID(),\n        this));\n\n    fast_shutdown_started_ = false;\n  }\n\n  is_initialized_ = true;\n  return true;\n}\n",
        "output": "0",
        "index": 122886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (global_trace.trace_flags & TRACE_ITER_SYM_MASK);\n\tstruct trace_buffer *buf = iter->trace_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"preemption\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"# %s latency trace v1.1.5 on %s\\n\",\n\t\t   name, UTS_RELEASE);\n\tseq_puts(m, \"# -----------------------------------\"\n\t\t \"---------------------------------\\n\");\n\tseq_printf(m, \"# latency: %lu us, #%lu/%lu, CPU#%d |\"\n\t\t   \" (M:%s VP:%d, KP:%d, SP:%d HP:%d\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(CONFIG_PREEMPT_NONE)\n\t\t   \"server\",\n#elif defined(CONFIG_PREEMPT_VOLUNTARY)\n\t\t   \"desktop\",\n#elif defined(CONFIG_PREEMPT)\n\t\t   \"preempt\",\n#else\n\t\t   \"unknown\",\n#endif\n\t\t   /* These are reserved for later use */\n\t\t   0, 0, 0, 0);\n#ifdef CONFIG_SMP\n\tseq_printf(m, \" #P:%d)\\n\", num_online_cpus());\n#else\n\tseq_puts(m, \")\\n\");\n#endif\n\tseq_puts(m, \"#    -----------------\\n\");\n\tseq_printf(m, \"#    | task: %.16s-%d \"\n\t\t   \"(uid:%d nice:%ld policy:%ld rt_prio:%ld)\\n\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"#    -----------------\\n\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"#  => started at: \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#  => ended at:   \");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"\\n#\\n\");\n\t}\n\n\tseq_puts(m, \"#\\n\");\n}\n",
        "output": "0",
        "index": 81314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sas_configure_present(struct domain_device *dev, int phy_id,\n\t\t\t\t u8 *sas_addr, int *index, int *present)\n{\n\tint i, res = 0;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tu8 *rri_req;\n\tu8 *rri_resp;\n\n\t*present = 0;\n\t*index = 0;\n\n\trri_req = alloc_smp_req(RRI_REQ_SIZE);\n\tif (!rri_req)\n\t\treturn -ENOMEM;\n\n\trri_resp = alloc_smp_resp(RRI_RESP_SIZE);\n\tif (!rri_resp) {\n\t\tkfree(rri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trri_req[1] = SMP_REPORT_ROUTE_INFO;\n\trri_req[9] = phy_id;\n\n\tfor (i = 0; i < ex->max_route_indexes ; i++) {\n\t\t*(__be16 *)(rri_req+6) = cpu_to_be16(i);\n\t\tres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\n\t\t\t\t       RRI_RESP_SIZE);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tres = rri_resp[2];\n\t\tif (res == SMP_RESP_NO_INDEX) {\n\t\t\tSAS_DPRINTK(\"overflow of indexes: dev %016llx \"\n\t\t\t\t    \"phy 0x%x index 0x%x\\n\",\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i);\n\t\t\tgoto out;\n\t\t} else if (res != SMP_RESP_FUNC_ACC) {\n\t\t\tSAS_DPRINTK(\"%s: dev %016llx phy 0x%x index 0x%x \"\n\t\t\t\t    \"result 0x%x\\n\", __func__,\n\t\t\t\t    SAS_ADDR(dev->sas_addr), phy_id, i, res);\n\t\t\tgoto out;\n\t\t}\n\t\tif (SAS_ADDR(sas_addr) != 0) {\n\t\t\tif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\n\t\t\t\t*index = i;\n\t\t\t\tif ((rri_resp[12] & 0x80) == 0x80)\n\t\t\t\t\t*present = 0;\n\t\t\t\telse\n\t\t\t\t\t*present = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (SAS_ADDR(rri_resp+16) == 0) {\n\t\t\t\t*index = i;\n\t\t\t\t*present = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (SAS_ADDR(rri_resp+16) == 0 &&\n\t\t\t   phy->last_da_index < i) {\n\t\t\tphy->last_da_index = i;\n\t\t\t*index = i;\n\t\t\t*present = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tres = -1;\nout:\n\tkfree(rri_req);\n\tkfree(rri_resp);\n\treturn res;\n}\n",
        "output": "0",
        "index": 83932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_qtdemux_clip_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,\n    GstBuffer * buf)\n{\n  gint64 start, stop, cstart, cstop, diff;\n  GstClockTime timestamp = GST_CLOCK_TIME_NONE, duration = GST_CLOCK_TIME_NONE;\n  guint8 *data;\n  guint size;\n  gint num_rate, denom_rate;\n  gint frame_size;\n  gboolean clip_data;\n\n  data = GST_BUFFER_DATA (buf);\n  size = GST_BUFFER_SIZE (buf);\n\n  /* depending on the type, setup the clip parameters */\n  if (stream->subtype == FOURCC_soun) {\n    frame_size = stream->bytes_per_frame;\n    num_rate = GST_SECOND;\n    denom_rate = (gint) stream->rate;\n    clip_data = TRUE;\n  } else if (stream->subtype == FOURCC_vide) {\n    frame_size = size;\n    num_rate = stream->fps_n;\n    denom_rate = stream->fps_d;\n    clip_data = FALSE;\n  } else\n    goto wrong_type;\n\n  /* we can only clip if we have a valid timestamp */\n  timestamp = GST_BUFFER_TIMESTAMP (buf);\n  if (!GST_CLOCK_TIME_IS_VALID (timestamp))\n    goto no_timestamp;\n\n  if (GST_BUFFER_DURATION_IS_VALID (buf)) {\n    duration = GST_BUFFER_DURATION (buf);\n  } else {\n    duration =\n        gst_util_uint64_scale_int (size / frame_size, num_rate, denom_rate);\n  }\n\n  start = timestamp;\n  stop = start + duration;\n\n  if (!gst_segment_clip (&stream->segment, GST_FORMAT_TIME,\n          start, stop, &cstart, &cstop))\n    goto clipped;\n\n  /* see if some clipping happened */\n  diff = cstart - start;\n  if (diff > 0) {\n    timestamp = cstart;\n    duration -= diff;\n\n    if (clip_data) {\n      /* bring clipped time to samples and to bytes */\n      diff = gst_util_uint64_scale_int (diff, denom_rate, num_rate);\n      diff *= frame_size;\n\n      GST_DEBUG_OBJECT (qtdemux, \"clipping start to %\" GST_TIME_FORMAT \" %\"\n          G_GUINT64_FORMAT \" bytes\", GST_TIME_ARGS (cstart), diff);\n\n      data += diff;\n      size -= diff;\n    }\n  }\n  diff = stop - cstop;\n  if (diff > 0) {\n    duration -= diff;\n\n    if (clip_data) {\n      /* bring clipped time to samples and then to bytes */\n      diff = gst_util_uint64_scale_int (diff, denom_rate, num_rate);\n      diff *= frame_size;\n\n      GST_DEBUG_OBJECT (qtdemux, \"clipping stop to %\" GST_TIME_FORMAT \" %\"\n          G_GUINT64_FORMAT \" bytes\", GST_TIME_ARGS (cstop), diff);\n\n      size -= diff;\n    }\n  }\n\n  GST_BUFFER_TIMESTAMP (buf) = timestamp;\n  GST_BUFFER_DURATION (buf) = duration;\n  GST_BUFFER_SIZE (buf) = size;\n  GST_BUFFER_DATA (buf) = data;\n\n  return buf;\n\n  /* dropped buffer */\nwrong_type:\n  {\n    GST_DEBUG_OBJECT (qtdemux, \"unknown stream type\");\n    return buf;\n  }\nno_timestamp:\n  {\n    GST_DEBUG_OBJECT (qtdemux, \"no timestamp on buffer\");\n    return buf;\n  }\nclipped:\n  {\n    GST_DEBUG_OBJECT (qtdemux, \"clipped buffer\");\n    gst_buffer_unref (buf);\n    return NULL;\n  }\n}\n",
        "output": "0",
        "index": 4934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void getlistargs(char *tag, struct listargs *listargs)\n{\n    static struct buf reference, buf;\n    int c;\n\n    /* Check for and parse LIST-EXTENDED selection options */\n    c = prot_getc(imapd_in);\n    if (c == '(') {\n        listargs->cmd = LIST_CMD_EXTENDED;\n        c = getlistselopts(tag, listargs);\n        if (c == EOF) {\n            eatline(imapd_in, c);\n            return;\n        }\n    }\n    else\n        prot_ungetc(c, imapd_in);\n\n    if (!strcmpsafe(imapd_magicplus, \"+\")) listargs->sel |= LIST_SEL_SUBSCRIBED;\n    else if (!strcasecmpsafe(imapd_magicplus, \"+dav\")) listargs->sel |= LIST_SEL_DAV;\n\n    /* Read in reference name */\n    c = getastring(imapd_in, imapd_out, &reference);\n    if (c == EOF && !*reference.s) {\n        prot_printf(imapd_out,\n                    \"%s BAD Missing required argument to List: reference name\\r\\n\",\n                    tag);\n        eatline(imapd_in, c);\n        return;\n    }\n    listargs->ref = reference.s;\n\n    if (c != ' ') {\n        prot_printf(imapd_out,\n                    \"%s BAD Missing required argument to List: mailbox pattern\\r\\n\", tag);\n        eatline(imapd_in, c);\n        return;\n    }\n\n    /* Read in mailbox pattern(s) */\n    c = prot_getc(imapd_in);\n    if (c == '(') {\n        listargs->cmd = LIST_CMD_EXTENDED;\n        for (;;) {\n            c = getastring(imapd_in, imapd_out, &buf);\n            if (*buf.s)\n                strarray_append(&listargs->pat, buf.s);\n            if (c != ' ') break;\n        }\n        if (c != ')') {\n            prot_printf(imapd_out,\n                        \"%s BAD Invalid syntax in List command\\r\\n\", tag);\n            eatline(imapd_in, c);\n            goto freeargs;\n        }\n        c = prot_getc(imapd_in);\n    }\n    else {\n        prot_ungetc(c, imapd_in);\n        c = getastring(imapd_in, imapd_out, &buf);\n        if (c == EOF) {\n            prot_printf(imapd_out,\n                        \"%s BAD Missing required argument to List: mailbox pattern\\r\\n\",\n                        tag);\n            eatline(imapd_in, c);\n            goto freeargs;\n        }\n        strarray_append(&listargs->pat, buf.s);\n    }\n\n    /* Check for and parse LIST-EXTENDED return options */\n    if (c == ' ') {\n        listargs->cmd = LIST_CMD_EXTENDED;\n        c = getlistretopts(tag, listargs);\n        if (c == EOF) {\n            eatline(imapd_in, c);\n            goto freeargs;\n        }\n    }\n\n    /* check for CRLF */\n    if (c == '\\r') c = prot_getc(imapd_in);\n    if (c != '\\n') {\n        prot_printf(imapd_out,\n                    \"%s BAD Unexpected extra arguments to List\\r\\n\", tag);\n        eatline(imapd_in, c);\n        goto freeargs;\n    }\n\n#ifdef USE_AUTOCREATE\n    autocreate_inbox();\n#endif // USE_AUTOCREATE\n\n    return;\n\n  freeargs:\n    strarray_fini(&listargs->pat);\n    strarray_fini(&listargs->metaitems);\n    return;\n}\n",
        "output": "0",
        "index": 95210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool V4L2JpegEncodeAccelerator::EncodedInstance::RequestInputBuffers() {\n  DCHECK(parent_->encoder_task_runner_->BelongsToCurrentThread());\n  struct v4l2_format format;\n  memset(&format, 0, sizeof(format));\n  format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n  format.fmt.pix_mp.pixelformat = input_buffer_pixelformat_;\n  IOCTL_OR_ERROR_RETURN_FALSE(VIDIOC_G_FMT, &format);\n\n  struct v4l2_requestbuffers reqbufs;\n  memset(&reqbufs, 0, sizeof(reqbufs));\n  reqbufs.count = kBufferCount;\n  reqbufs.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n  reqbufs.memory = V4L2_MEMORY_MMAP;\n  IOCTL_OR_ERROR_RETURN_FALSE(VIDIOC_REQBUFS, &reqbufs);\n\n  DCHECK(input_buffer_map_.empty());\n  input_buffer_map_.resize(reqbufs.count);\n\n  for (size_t i = 0; i < input_buffer_map_.size(); ++i) {\n    free_input_buffers_.push_back(i);\n\n    struct v4l2_buffer buffer;\n    struct v4l2_plane planes[kMaxI420Plane];\n    memset(&buffer, 0, sizeof(buffer));\n    memset(planes, 0, sizeof(planes));\n    buffer.index = i;\n    buffer.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n    buffer.memory = V4L2_MEMORY_MMAP;\n    buffer.m.planes = planes;\n    buffer.length = base::size(planes);\n    IOCTL_OR_ERROR_RETURN_FALSE(VIDIOC_QUERYBUF, &buffer);\n\n    if (input_buffer_num_planes_ != buffer.length) {\n      return false;\n    }\n    for (size_t j = 0; j < buffer.length; ++j) {\n      if (base::checked_cast<int64_t>(planes[j].length) <\n          VideoFrame::PlaneSize(\n              PIXEL_FORMAT_I420, j,\n              gfx::Size(format.fmt.pix_mp.width, format.fmt.pix_mp.height))\n              .GetArea()) {\n        return false;\n      }\n      void* address =\n          device_->Mmap(NULL, planes[j].length, PROT_READ | PROT_WRITE,\n                        MAP_SHARED, planes[j].m.mem_offset);\n      if (address == MAP_FAILED) {\n        VPLOGF(1) << \"mmap() failed\";\n        return false;\n      }\n      input_buffer_map_[i].address[j] = address;\n      input_buffer_map_[i].length[j] = planes[j].length;\n    }\n  }\n\n  return true;\n}\n",
        "output": "0",
        "index": 148734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int send_reply(struct svcxprt_rdma *rdma,\n\t\t      struct svc_rqst *rqstp,\n\t\t      struct page *page,\n\t\t      struct rpcrdma_msg *rdma_resp,\n\t\t      struct svc_rdma_req_map *vec,\n\t\t      int byte_count,\n\t\t      u32 inv_rkey)\n {\n \tstruct svc_rdma_op_ctxt *ctxt;\n\tstruct ib_send_wr send_wr;\n\tu32 xdr_off;\n\tint sge_no;\n\tint sge_bytes;\n\tint page_no;\n\tint pages;\n\tint ret = -EIO;\n\t/* Prepare the context */\n \tctxt = svc_rdma_get_context(rdma);\n\tctxt->direction = DMA_TO_DEVICE;\n\tctxt->pages[0] = page;\n\tctxt->count = 1;\n \n\t/* Prepare the SGE for the RPCRDMA Header */\n\tctxt->sge[0].lkey = rdma->sc_pd->local_dma_lkey;\n\tctxt->sge[0].length =\n\t    svc_rdma_xdr_get_reply_hdr_len((__be32 *)rdma_resp);\n\tctxt->sge[0].addr =\n\t    ib_dma_map_page(rdma->sc_cm_id->device, page, 0,\n\t\t\t    ctxt->sge[0].length, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(rdma->sc_cm_id->device, ctxt->sge[0].addr))\n \t\tgoto err;\n\tsvc_rdma_count_mappings(rdma, ctxt);\n\tctxt->direction = DMA_TO_DEVICE;\n \n\t/* Map the payload indicated by 'byte_count' */\n\txdr_off = 0;\n\tfor (sge_no = 1; byte_count && sge_no < vec->count; sge_no++) {\n\t\tsge_bytes = min_t(size_t, vec->sge[sge_no].iov_len, byte_count);\n\t\tbyte_count -= sge_bytes;\n\t\tctxt->sge[sge_no].addr =\n\t\t\tdma_map_xdr(rdma, &rqstp->rq_res, xdr_off,\n\t\t\t\t    sge_bytes, DMA_TO_DEVICE);\n\t\txdr_off += sge_bytes;\n\t\tif (ib_dma_mapping_error(rdma->sc_cm_id->device,\n\t\t\t\t\t ctxt->sge[sge_no].addr))\n \t\t\tgoto err;\n\t\tsvc_rdma_count_mappings(rdma, ctxt);\n\t\tctxt->sge[sge_no].lkey = rdma->sc_pd->local_dma_lkey;\n\t\tctxt->sge[sge_no].length = sge_bytes;\n \t}\n\tif (byte_count != 0) {\n\t\tpr_err(\"svcrdma: Could not map %d bytes\\n\", byte_count);\n \t\tgoto err;\n\t}\n \n\t/* Save all respages in the ctxt and remove them from the\n\t * respages array. They are our pages until the I/O\n\t * completes.\n \t */\n\tpages = rqstp->rq_next_page - rqstp->rq_respages;\n\tfor (page_no = 0; page_no < pages; page_no++) {\n\t\tctxt->pages[page_no+1] = rqstp->rq_respages[page_no];\n\t\tctxt->count++;\n\t\trqstp->rq_respages[page_no] = NULL;\n\t}\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n \n\tif (sge_no > rdma->sc_max_sge) {\n\t\tpr_err(\"svcrdma: Too many sges (%d)\\n\", sge_no);\n \t\tgoto err;\n\t}\n\tmemset(&send_wr, 0, sizeof send_wr);\n\tctxt->cqe.done = svc_rdma_wc_send;\n\tsend_wr.wr_cqe = &ctxt->cqe;\n\tsend_wr.sg_list = ctxt->sge;\n\tsend_wr.num_sge = sge_no;\n\tif (inv_rkey) {\n\t\tsend_wr.opcode = IB_WR_SEND_WITH_INV;\n\t\tsend_wr.ex.invalidate_rkey = inv_rkey;\n\t} else\n\t\tsend_wr.opcode = IB_WR_SEND;\n\tsend_wr.send_flags =  IB_SEND_SIGNALED;\n \n\tret = svc_rdma_send(rdma, &send_wr);\n \tif (ret)\n \t\tgoto err;\n \n \treturn 0;\n \n err:\n \tsvc_rdma_unmap_dma(ctxt);\n \tsvc_rdma_put_context(ctxt, 1);\n \treturn ret;\n}\n",
        "output": "1",
        "index": 181339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INT_PTR CALLBACK NotificationCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tLRESULT loc;\n\tint i;\n\tstatic LRESULT disabled[9] = { HTLEFT, HTRIGHT, HTTOP, HTBOTTOM, HTSIZE,\n\t\tHTTOPLEFT, HTTOPRIGHT, HTBOTTOMLEFT, HTBOTTOMRIGHT };\n\tstatic HBRUSH background_brush, separator_brush;\n\tNONCLIENTMETRICS ncm;\n\tHFONT hDlgFont;\n\n\tswitch (message) {\n\tcase WM_INITDIALOG:\n\t\tif (nWindowsVersion >= WINDOWS_VISTA) {\t// of course, this stuff doesn't work on XP!\n\t\t\tncm.cbSize = sizeof(ncm);\n\t\t\t#if defined(_MSC_VER) && (_MSC_VER >= 1500) && (_WIN32_WINNT >= _WIN32_WINNT_VISTA)\n\t\t\tncm.cbSize -= sizeof(ncm.iPaddedBorderWidth);\n\t\t\t#endif\n\t\t\tSystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0);\n\t\t\thDlgFont = CreateFontIndirect(&(ncm.lfMessageFont));\n\t\t\tSendMessage(hDlg, WM_SETFONT, (WPARAM)hDlgFont, MAKELPARAM(TRUE, 0));\n\t\t\tSendMessage(GetDlgItem(hDlg, IDC_NOTIFICATION_TEXT), WM_SETFONT, (WPARAM)hDlgFont, MAKELPARAM(TRUE, 0));\n\t\t\tSendMessage(GetDlgItem(hDlg, IDC_MORE_INFO), WM_SETFONT, (WPARAM)hDlgFont, MAKELPARAM(TRUE, 0));\n\t\t\tSendMessage(GetDlgItem(hDlg, IDYES), WM_SETFONT, (WPARAM)hDlgFont, MAKELPARAM(TRUE, 0));\n\t\t\tSendMessage(GetDlgItem(hDlg, IDNO), WM_SETFONT, (WPARAM)hDlgFont, MAKELPARAM(TRUE, 0));\n\t\t}\n\n\t\tapply_localization(IDD_NOTIFICATION, hDlg);\n\t\tbackground_brush = CreateSolidBrush(GetSysColor(COLOR_WINDOW));\n\t\tseparator_brush = CreateSolidBrush(GetSysColor(COLOR_3DLIGHT));\n\t\tSetTitleBarIcon(hDlg);\n\t\tCenterDialog(hDlg);\n\t\tif (Static_SetIcon(GetDlgItem(hDlg, IDC_NOTIFICATION_ICON), hMessageIcon) == 0) {\n\t\t\tuprintf(\"Could not set dialog icon\\n\");\n\t\t}\n\t\tif (szMessageTitle != NULL) {\n\t\t\tSetWindowTextU(hDlg, szMessageTitle);\n\t\t}\n\t\tif (!notification_is_question) {\n\t\t\tSetWindowTextU(GetDlgItem(hDlg, IDNO), lmprintf(MSG_006));\n\t\t} else {\n\t\t\tShowWindow(GetDlgItem(hDlg, IDYES), SW_SHOW);\n\t\t}\n\t\tif ((notification_more_info != NULL) && (notification_more_info->callback != NULL)) {\n\t\t\tShowWindow(GetDlgItem(hDlg, IDC_MORE_INFO), SW_SHOW);\n\t\t}\n\t\tif (szMessageText != NULL) {\n\t\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_NOTIFICATION_TEXT), szMessageText);\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\tcase WM_CTLCOLORSTATIC:\n\t\tSetBkMode((HDC)wParam, TRANSPARENT);\n\t\tif ((HWND)lParam == GetDlgItem(hDlg, IDC_NOTIFICATION_LINE)) {\n\t\t\treturn (INT_PTR)separator_brush;\n\t\t}\n\t\treturn (INT_PTR)background_brush;\n\tcase WM_NCHITTEST:\n\t\tloc = DefWindowProc(hDlg, message, wParam, lParam);\n\t\tfor(i = 0; i < 9; i++) {\n\t\t\tif (loc == disabled[i]) {\n\t\t\t\treturn (INT_PTR)TRUE;\n\t\t\t}\n\t\t}\n\t\treturn (INT_PTR)FALSE;\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam)) {\n\t\tcase IDOK:\n\t\tcase IDCANCEL:\n\t\tcase IDYES:\n\t\tcase IDNO:\n\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase IDC_MORE_INFO:\n\t\t\tif (notification_more_info != NULL)\n\t\t\t\tMyDialogBox(hMainInstance, notification_more_info->id, hDlg, notification_more_info->callback);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (INT_PTR)FALSE;\n}\n",
        "output": "0",
        "index": 62199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rad_demangle_mppe_key(struct rad_handle *h, const void *mangled, size_t mlen, u_char *demangled, size_t *len)\n{\n\tchar R[LEN_AUTH];    /* variable names as per rfc2548 */\n\tconst char *S;\n\tu_char b[16];\n\tconst u_char *A, *C;\n\tMD5_CTX Context;\n\tint Slen, i, Clen, Ppos;\n\tu_char *P;\n\n\tif (mlen % 16 != SALT_LEN) {\n\t\tgenerr(h, \"Cannot interpret mangled data of length %ld\", (u_long)mlen);\n\t\treturn -1;\n\t}\n\n\t/* We need the RADIUS Request-Authenticator */\n\tif (rad_request_authenticator(h, R, sizeof R) != LEN_AUTH) {\n\t\tgenerr(h, \"Cannot obtain the RADIUS request authenticator\");\n\t\treturn -1;\n\t}\n\n\tA = (const u_char *)mangled;      /* Salt comes first */\n\tC = (const u_char *)mangled + SALT_LEN;  /* Then the ciphertext */\n\tClen = mlen - SALT_LEN;\n\tS = rad_server_secret(h);    /* We need the RADIUS secret */\n\tSlen = strlen(S);\n\tP = alloca(Clen);        /* We derive our plaintext */\n\n\tMD5Init(&Context);\n\tMD5Update(&Context, S, Slen);\n\tMD5Update(&Context, R, LEN_AUTH);\n\tMD5Update(&Context, A, SALT_LEN);\n\tMD5Final(b, &Context);\n\tPpos = 0;\n\n\twhile (Clen) {\n\t\tClen -= 16;\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t    P[Ppos++] = C[i] ^ b[i];\n\n\t\tif (Clen) {\n\t\t\tMD5Init(&Context);\n\t\t\tMD5Update(&Context, S, Slen);\n\t\t\tMD5Update(&Context, C, 16);\n\t\t\tMD5Final(b, &Context);\n\t\t}\n                \n\t\tC += 16;\n\t}\n\n\t/*\n\t* The resulting plain text consists of a one-byte length, the text and\n\t* maybe some padding.\n\t*/\n\t*len = *P;\n\tif (*len > mlen - 1) {\n\t\tgenerr(h, \"Mangled data seems to be garbage %d %d\", *len, mlen-1);        \n\t\treturn -1;\n\t}\n\n\tif (*len > MPPE_KEY_LEN) {\n\t\tgenerr(h, \"Key to long (%d) for me max. %d\", *len, MPPE_KEY_LEN);        \n\t\treturn -1;\n\t}\n\n\tmemcpy(demangled, P + 1, *len);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 31537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    x,\n    y,\n    i;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    RunCount;\n\n  ssize_t\n    ldblk;\n\n  x=0;\n  y=0;\n\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    8*sizeof(*BImgBuff));\n  if(BImgBuff==NULL) return(-2);\n\n  while(y<(ssize_t) image->rows)\n    {\n      int\n        c;\n\n      c=ReadBlobByte(image);\n      if (c == EOF)\n        break;\n      bbuf=(unsigned char) c;\n      RunCount=bbuf & 0x7F;\n      if(bbuf & 0x80)\n        {\n          if(RunCount)  /* repeat next byte runcount * */\n            {\n              bbuf=ReadBlobByte(image);\n              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);\n            }\n          else {  /* read next byte as RunCount; repeat 0xFF runcount* */\n            c=ReadBlobByte(image);\n            if (c < 0)\n              break;\n            RunCount=(unsigned char) c;\n            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);\n          }\n        }\n      else {\n        if(RunCount)   /* next runcount byte are readed directly */\n          {\n            for(i=0;i < (int) RunCount;i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte(bbuf);\n              }\n          }\n        else {  /* repeat previous line runcount* */\n          c=ReadBlobByte(image);\n          if (c < 0)\n            break;\n          RunCount=(unsigned char) c;\n          if(x) {    /* attempt to duplicate row from x position: */\n            /* I do not know what to do here */\n            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n            return(-3);\n          }\n          for(i=0;i < (int) RunCount;i++)\n            {\n              x=0;\n              y++;    /* Here I need to duplicate previous row RUNCOUNT* */\n              if(y<2) continue;\n              if(y>(ssize_t) image->rows)\n                {\n                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                  return(-4);\n                }\n              InsertRow(image,BImgBuff,y-1,bpp,exception);\n            }\n        }\n      }\n      if (EOFBlob(image) != MagickFalse)\n        break;\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(y <(ssize_t) image->rows ? -5 : 0);\n}\n",
        "output": "0",
        "index": 59742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4 =\n\t\t(cr4_read_shadow() & X86_CR4_MCE) |\n\t\t(cr4 & ~X86_CR4_MCE) |\n\t\t(to_vmx(vcpu)->rmode.vm86_active ?\n\t\t KVM_RMODE_VM_CR4_ALWAYS_ON : KVM_PMODE_VM_CR4_ALWAYS_ON);\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (to_vmx(vcpu)->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\tif (enable_ept) {\n\t\tif (!is_paging(vcpu)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t}\n\t}\n\n\tif (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 48137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Image *ReadUYVYImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    y;\n\n  unsigned char\n    u,\n    v,\n    y1,\n    y2;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  if ((image->columns % 2) != 0)\n    image->columns++;\n  (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  if (DiscardBlobBytes(image,image->offset) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  image->depth=8;\n  if (image_info->ping != MagickFalse)\n    {\n       (void) CloseBlob(image);\n       return(GetFirstImageInList(image));\n     }\n   /*\n     Accumulate UYVY, then unpack into two pixels.\n   */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) (image->columns >> 1); x++)\n    {\n      u=(unsigned char) ReadBlobByte(image);\n      y1=(unsigned char) ReadBlobByte(image);\n      v=(unsigned char) ReadBlobByte(image);\n      y2=(unsigned char) ReadBlobByte(image);\n      SetPixelRed(q,ScaleCharToQuantum(y1));\n      SetPixelGreen(q,ScaleCharToQuantum(u));\n      SetPixelBlue(q,ScaleCharToQuantum(v));\n      q++;\n      SetPixelRed(q,ScaleCharToQuantum(y2));\n      SetPixelGreen(q,ScaleCharToQuantum(u));\n      SetPixelBlue(q,ScaleCharToQuantum(v));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  SetImageColorspace(image,YCbCrColorspace);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "output": "1",
        "index": 181787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sparc_pmu_event_init(struct perf_event *event)\n{\n\tstruct perf_event_attr *attr = &event->attr;\n\tstruct perf_event *evts[MAX_HWEVENTS];\n\tstruct hw_perf_event *hwc = &event->hw;\n\tunsigned long events[MAX_HWEVENTS];\n\tint current_idx_dmy[MAX_HWEVENTS];\n\tconst struct perf_event_map *pmap;\n\tint n;\n\n\tif (atomic_read(&nmi_active) < 0)\n\t\treturn -ENODEV;\n\n\tswitch (attr->type) {\n\tcase PERF_TYPE_HARDWARE:\n\t\tif (attr->config >= sparc_pmu->max_events)\n\t\t\treturn -EINVAL;\n\t\tpmap = sparc_pmu->event_map(attr->config);\n\t\tbreak;\n\n\tcase PERF_TYPE_HW_CACHE:\n\t\tpmap = sparc_map_cache_event(attr->config);\n\t\tif (IS_ERR(pmap))\n\t\t\treturn PTR_ERR(pmap);\n\t\tbreak;\n\n\tcase PERF_TYPE_RAW:\n\t\tpmap = NULL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOENT;\n\n\t}\n\n\tif (pmap) {\n\t\thwc->event_base = perf_event_encode(pmap);\n\t} else {\n\t\t/*\n\t\t * User gives us \"(encoding << 16) | pic_mask\" for\n\t\t * PERF_TYPE_RAW events.\n\t\t */\n\t\thwc->event_base = attr->config;\n\t}\n\n\t/* We save the enable bits in the config_base.  */\n\thwc->config_base = sparc_pmu->irq_bit;\n\tif (!attr->exclude_user)\n\t\thwc->config_base |= PCR_UTRACE;\n\tif (!attr->exclude_kernel)\n\t\thwc->config_base |= PCR_STRACE;\n\tif (!attr->exclude_hv)\n\t\thwc->config_base |= sparc_pmu->hv_bit;\n\n\tn = 0;\n\tif (event->group_leader != event) {\n\t\tn = collect_events(event->group_leader,\n\t\t\t\t   MAX_HWEVENTS - 1,\n\t\t\t\t   evts, events, current_idx_dmy);\n\t\tif (n < 0)\n\t\t\treturn -EINVAL;\n\t}\n\tevents[n] = hwc->event_base;\n\tevts[n] = event;\n\n\tif (check_excludes(evts, n, 1))\n\t\treturn -EINVAL;\n\n\tif (sparc_check_constraints(evts, events, n + 1))\n\t\treturn -EINVAL;\n\n\thwc->idx = PIC_NO_INDEX;\n\n\t/* Try to do all error checking before this point, as unwinding\n\t * state after grabbing the PMC is difficult.\n\t */\n\tperf_event_grab_pmc();\n\tevent->destroy = hw_perf_event_destroy;\n\n\tif (!hwc->sample_period) {\n\t\thwc->sample_period = MAX_PERIOD;\n\t\thwc->last_period = hwc->sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 25669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_get_new_session_ticket(SSL *s)\n\t{\n\tint ok,al,ret=0, ticklen;\n\tlong n;\n\tconst unsigned char *p;\n\tunsigned char *d;\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_CR_SESSION_TICKET_A,\n\t\tSSL3_ST_CR_SESSION_TICKET_B,\n\t\t-1,\n\t\t16384,\n\t\t&ok);\n\n\tif (!ok)\n\t\treturn((int)n);\n\n\tif (s->s3->tmp.message_type == SSL3_MT_FINISHED)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\treturn(1);\n\t\t}\n\tif (s->s3->tmp.message_type != SSL3_MT_NEWSESSION_TICKET)\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_BAD_MESSAGE_TYPE);\n\t\tgoto f_err;\n\t\t}\n\tif (n < 6)\n\t\t{\n\t\t/* need at least ticket_lifetime_hint + ticket length */\n\t\tal = SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);\n\t\tgoto f_err;\n\t\t}\n\n\tp=d=(unsigned char *)s->init_msg;\n\tn2l(p, s->session->tlsext_tick_lifetime_hint);\n\tn2s(p, ticklen);\n\t/* ticket_lifetime_hint + ticket_length + ticket */\n\tif (ticklen + 6 != n)\n\t\t{\n\t\tal = SSL_AD_DECODE_ERROR;\n\t\tSSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,SSL_R_LENGTH_MISMATCH);\n\t\tgoto f_err;\n\t\t}\n\tif (s->session->tlsext_tick)\n\t\t{\n\t\tOPENSSL_free(s->session->tlsext_tick);\n\t\ts->session->tlsext_ticklen = 0;\n\t\t}\n\ts->session->tlsext_tick = OPENSSL_malloc(ticklen);\n\tif (!s->session->tlsext_tick)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tmemcpy(s->session->tlsext_tick, p, ticklen);\n\ts->session->tlsext_ticklen = ticklen;\n\t/* There are two ways to detect a resumed ticket sesion.\n\t * One is to set an appropriate session ID and then the server\n\t * must return a match in ServerHello. This allows the normal\n\t * client session ID matching to work and we know much \n\t * earlier that the ticket has been accepted.\n\t * \n\t * The other way is to set zero length session ID when the\n\t * ticket is presented and rely on the handshake to determine\n\t * session resumption.\n\t *\n\t * We choose the former approach because this fits in with\n\t * assumptions elsewhere in OpenSSL. The session ID is set\n\t * to the SHA256 (or SHA1 is SHA256 is disabled) hash of the\n\t * ticket.\n\t */ \n\tEVP_Digest(p, ticklen,\n\t\t\ts->session->session_id, &s->session->session_id_length,\n#ifndef OPENSSL_NO_SHA256\n\t\t\t\t\t\t\tEVP_sha256(), NULL);\n#else\n\t\t\t\t\t\t\tEVP_sha1(), NULL);\n#endif\n\tret=1;\n\treturn(ret);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}\n",
        "output": "0",
        "index": 10757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "png_decompress_chunk(png_structp png_ptr, int comp_type,\n    png_size_t chunklength,\n    png_size_t prefix_size, png_size_t *newlength)\n{\n   /* The caller should guarantee this */\n   if (prefix_size > chunklength)\n   {\n      /* The recovery is to delete the chunk. */\n      png_warning(png_ptr, \"invalid chunklength\");\n      prefix_size = 0; /* To delete everything */\n   }\n\n   else if (comp_type == PNG_COMPRESSION_TYPE_BASE)\n   {\n      png_size_t expanded_size = png_inflate(png_ptr,\n                (png_bytep)(png_ptr->chunkdata + prefix_size),\n                chunklength - prefix_size,\n                0/*output*/, 0/*output size*/);\n\n      /* Now check the limits on this chunk - if the limit fails the\n       * compressed data will be removed, the prefix will remain.\n       */\n      if (prefix_size >= (~(png_size_t)0) - 1 ||\n         expanded_size >= (~(png_size_t)0) - 1 - prefix_size\n#ifdef PNG_USER_CHUNK_MALLOC_MAX\n         || ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&\n          prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)\n#endif\n          )\n         png_warning(png_ptr, \"Exceeded size limit while expanding chunk\");\n\n      /* If the size is zero either there was an error and a message\n       * has already been output (warning) or the size really is zero\n       * and we have nothing to do - the code will exit through the\n       * error case below.\n       */\n      else if (expanded_size > 0)\n      {\n         /* Success (maybe) - really uncompress the chunk. */\n         png_size_t new_size = 0;\n\n         png_charp text = png_malloc_warn(png_ptr,\n             prefix_size + expanded_size + 1);\n\n         if (text != NULL)\n         {\n            png_memcpy(text, png_ptr->chunkdata, prefix_size);\n            new_size = png_inflate(png_ptr,\n                (png_bytep)(png_ptr->chunkdata + prefix_size),\n                chunklength - prefix_size,\n                (png_bytep)(text + prefix_size), expanded_size);\n            text[prefix_size + expanded_size] = 0; /* just in case */\n\n            if (new_size == expanded_size)\n            {\n               png_free(png_ptr, png_ptr->chunkdata);\n               png_ptr->chunkdata = text;\n               *newlength = prefix_size + expanded_size;\n               return; /* The success return! */\n            }\n\n            png_warning(png_ptr, \"png_inflate logic error\");\n            png_free(png_ptr, text);\n         }\n         else\n          png_warning(png_ptr, \"Not enough memory to decompress chunk.\");\n      }\n   }\n\n   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */\n   {\n#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)\n      char umsg[50];\n\n      png_snprintf(umsg, sizeof umsg, \"Unknown zTXt compression type %d\",\n          comp_type);\n      png_warning(png_ptr, umsg);\n#else\n      png_warning(png_ptr, \"Unknown zTXt compression type\");\n#endif\n\n      /* The recovery is to simply drop the data. */\n   }\n\n   /* Generic error return - leave the prefix, delete the compressed\n    * data, reallocate the chunkdata to remove the potentially large\n    * amount of compressed data.\n    */\n   {\n      png_charp text = png_malloc_warn(png_ptr, prefix_size + 1);\n      if (text != NULL)\n      {\n         if (prefix_size > 0)\n            png_memcpy(text, png_ptr->chunkdata, prefix_size);\n         png_free(png_ptr, png_ptr->chunkdata);\n         png_ptr->chunkdata = text;\n\n         /* This is an extra zero in the 'uncompressed' part. */\n         *(png_ptr->chunkdata + prefix_size) = 0x00;\n      }\n      /* Ignore a malloc error here - it is safe. */\n   }\n\n   *newlength = prefix_size;\n}\n",
        "output": "0",
        "index": 144064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,\n\t\tbool modify, bool restore)\n{\n\tconst struct usb_endpoint_descriptor *desc = dep->endpoint.desc;\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\tu32\t\t\treg;\n\tint\t\t\tret;\n\n\tif (!(dep->flags & DWC3_EP_ENABLED)) {\n\t\tret = dwc3_gadget_start_config(dwc, dep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = dwc3_gadget_set_ep_config(dwc, dep, modify, restore);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(dep->flags & DWC3_EP_ENABLED)) {\n\t\tstruct dwc3_trb\t*trb_st_hw;\n\t\tstruct dwc3_trb\t*trb_link;\n\n\t\tdep->type = usb_endpoint_type(desc);\n\t\tdep->flags |= DWC3_EP_ENABLED;\n\t\tdep->flags &= ~DWC3_EP_END_TRANSFER_PENDING;\n\n\t\treg = dwc3_readl(dwc->regs, DWC3_DALEPENA);\n\t\treg |= DWC3_DALEPENA_EP(dep->number);\n\t\tdwc3_writel(dwc->regs, DWC3_DALEPENA, reg);\n\n\t\tinit_waitqueue_head(&dep->wait_end_transfer);\n\n\t\tif (usb_endpoint_xfer_control(desc))\n\t\t\tgoto out;\n\n\t\t/* Initialize the TRB ring */\n\t\tdep->trb_dequeue = 0;\n\t\tdep->trb_enqueue = 0;\n\t\tmemset(dep->trb_pool, 0,\n\t\t       sizeof(struct dwc3_trb) * DWC3_TRB_NUM);\n\n\t\t/* Link TRB. The HWO bit is never reset */\n\t\ttrb_st_hw = &dep->trb_pool[0];\n\n\t\ttrb_link = &dep->trb_pool[DWC3_TRB_NUM - 1];\n\t\ttrb_link->bpl = lower_32_bits(dwc3_trb_dma_offset(dep, trb_st_hw));\n\t\ttrb_link->bph = upper_32_bits(dwc3_trb_dma_offset(dep, trb_st_hw));\n\t\ttrb_link->ctrl |= DWC3_TRBCTL_LINK_TRB;\n\t\ttrb_link->ctrl |= DWC3_TRB_CTRL_HWO;\n\t}\n\n\t/*\n\t * Issue StartTransfer here with no-op TRB so we can always rely on No\n\t * Response Update Transfer command.\n\t */\n\tif (usb_endpoint_xfer_bulk(desc)) {\n\t\tstruct dwc3_gadget_ep_cmd_params params;\n\t\tstruct dwc3_trb\t*trb;\n\t\tdma_addr_t trb_dma;\n\t\tu32 cmd;\n\n\t\tmemset(&params, 0, sizeof(params));\n\t\ttrb = &dep->trb_pool[0];\n\t\ttrb_dma = dwc3_trb_dma_offset(dep, trb);\n\n\t\tparams.param0 = upper_32_bits(trb_dma);\n\t\tparams.param1 = lower_32_bits(trb_dma);\n\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\n\t\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdep->flags |= DWC3_EP_BUSY;\n\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\n\nout:\n\ttrace_dwc3_gadget_ep_enable(dep);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 88629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_machine_constraints(struct regulator_dev *rdev,\n\tconst struct regulation_constraints *constraints)\n{\n\tint ret = 0;\n\tconst struct regulator_ops *ops = rdev->desc->ops;\n\n\tif (constraints)\n\t\trdev->constraints = kmemdup(constraints, sizeof(*constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\telse\n\t\trdev->constraints = kzalloc(sizeof(*constraints),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!rdev->constraints)\n\t\treturn -ENOMEM;\n\n\tret = machine_constraints_voltage(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = machine_constraints_current(rdev, rdev->constraints);\n\tif (ret != 0)\n\t\tgoto out;\n\n\t/* do we need to setup our suspend state */\n\tif (rdev->constraints->initial_state) {\n\t\tret = suspend_prepare(rdev, rdev->constraints->initial_state);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set suspend state\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rdev->constraints->initial_mode) {\n\t\tif (!ops->set_mode) {\n\t\t\trdev_err(rdev, \"no set_mode operation\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ops->set_mode(rdev, rdev->constraints->initial_mode);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set initial mode: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If the constraints say the regulator should be on at this point\n\t * and we have control then make sure it is enabled.\n\t */\n\tif (rdev->constraints->always_on || rdev->constraints->boot_on) {\n\t\tret = _regulator_do_enable(rdev);\n\t\tif (ret < 0 && ret != -EINVAL) {\n\t\t\trdev_err(rdev, \"failed to enable\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)\n\t\t&& ops->set_ramp_delay) {\n\t\tret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);\n\t\tif (ret < 0) {\n\t\t\trdev_err(rdev, \"failed to set ramp_delay\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tprint_constraints(rdev);\n\treturn 0;\nout:\n\tkfree(rdev->constraints);\n\trdev->constraints = NULL;\n\treturn ret;\n}\n",
        "output": "0",
        "index": 74563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tstruct fib_result res = {};\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be32 dst = 0;\n\t__be32 src = 0;\n\tu32 iif;\n\tint err;\n\tint mark;\n\tstruct sk_buff *skb;\n\tu32 table_id = RT_TABLE_MAIN;\n\tkuid_t uid;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,\n\t\t\t  extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtm = nlmsg_data(nlh);\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\t/* Reserve room for dummy headers, this skb can pass\n\t   through good chunk of routing engine.\n\t */\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tdst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\tiif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;\n\tmark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;\n\tif (tb[RTA_UID])\n\t\tuid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tuid = (iif ? INVALID_UID : current_uid());\n\n\t/* Bugfix: need to give ip_route_input enough of an IP header to\n\t * not gag.\n\t */\n\tip_hdr(skb)->protocol = IPPROTO_UDP;\n\tip_hdr(skb)->saddr = src;\n\tip_hdr(skb)->daddr = dst;\n\n\tskb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst;\n\tfl4.saddr = src;\n\tfl4.flowi4_tos = rtm->rtm_tos;\n\tfl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = uid;\n\n\trcu_read_lock();\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout_free;\n\t\t}\n\n\t\tskb->protocol\t= htons(ETH_P_IP);\n\t\tskb->dev\t= dev;\n\t\tskb->mark\t= mark;\n\t\terr = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,\n\t\t\t\t\t dev, &res);\n\n\t\trt = skb_rtable(skb);\n\t\tif (err == 0 && rt->dst.error)\n\t\t\terr = -rt->dst.error;\n\t} else {\n\t\trt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);\n\t\terr = 0;\n\t\tif (IS_ERR(rt))\n\t\t\terr = PTR_ERR(rt);\n\t\telse\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t}\n\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\telse\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n \tif (err < 0)\n \t\tgoto errout_free;\n \n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\tgoto errout;\n}\n",
        "output": "1",
        "index": 180978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bond_set_mac_address(struct net_device *bond_dev, void *addr)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct sockaddr *sa = addr, tmp_sa;\n\tstruct slave *slave, *stop_at;\n\tint res = 0;\n\tint i;\n\n\tif (bond->params.mode == BOND_MODE_ALB)\n\t\treturn bond_alb_set_mac_address(bond_dev, addr);\n\n\n\tpr_debug(\"bond=%p, name=%s\\n\",\n\t\t bond, bond_dev ? bond_dev->name : \"None\");\n\n\t/*\n\t * If fail_over_mac is set to active, do nothing and return\n\t * success.  Returning an error causes ifenslave to fail.\n\t */\n\tif (bond->params.fail_over_mac == BOND_FOM_ACTIVE)\n\t\treturn 0;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Can't hold bond->lock with bh disabled here since\n\t * some base drivers panic. On the other hand we can't\n\t * hold bond->lock without bh disabled because we'll\n\t * deadlock. The only solution is to rely on the fact\n\t * that we're under rtnl_lock here, and the slaves\n\t * list won't change. This doesn't solve the problem\n\t * of setting the slave's hw address while it is\n\t * transmitting, but the assumption is that the base\n\t * driver can handle that.\n\t *\n\t * TODO: figure out a way to safely iterate the slaves\n\t * list, but without holding a lock around the actual\n\t * call to the base driver.\n\t */\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tconst struct net_device_ops *slave_ops = slave->dev->netdev_ops;\n\t\tpr_debug(\"slave %p %s\\n\", slave, slave->dev->name);\n\n\t\tif (slave_ops->ndo_set_mac_address == NULL) {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tpr_debug(\"EOPNOTSUPP %s\\n\", slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tres = dev_set_mac_address(slave->dev, addr);\n\t\tif (res) {\n\t\t\t/* TODO: consider downing the slave\n\t\t\t * and retry ?\n\t\t\t * User should expect communications\n\t\t\t * breakage anyway until ARP finish\n\t\t\t * updating, so...\n\t\t\t */\n\t\t\tpr_debug(\"err %d %s\\n\", res, slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/* success */\n\tmemcpy(bond_dev->dev_addr, sa->sa_data, bond_dev->addr_len);\n\treturn 0;\n\nunwind:\n\tmemcpy(tmp_sa.sa_data, bond_dev->dev_addr, bond_dev->addr_len);\n\ttmp_sa.sa_family = bond_dev->type;\n\n\t/* unwind from head to the slave that failed */\n\tstop_at = slave;\n\tbond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {\n\t\tint tmp_res;\n\n\t\ttmp_res = dev_set_mac_address(slave->dev, &tmp_sa);\n\t\tif (tmp_res) {\n\t\t\tpr_debug(\"unwind err %d dev %s\\n\",\n\t\t\t\t tmp_res, slave->dev->name);\n\t\t}\n\t}\n\n\treturn res;\n}\n",
        "output": "0",
        "index": 23750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::MaybeRestoreContext(TimerBase*) {\n  DCHECK(isContextLost());\n\n  if (!restore_allowed_)\n    return;\n\n  if (canvas()) {\n    LocalFrame* frame = canvas()->GetDocument().GetFrame();\n    if (!frame)\n      return;\n    if (frame->Client()->ShouldBlockWebGL())\n      return;\n\n    Settings* settings = frame->GetSettings();\n    if (settings && ((version_ == 1 && !settings->GetWebGL1Enabled()) ||\n                     (version_ == 2 && !settings->GetWebGL2Enabled()))) {\n      return;\n    }\n  }\n\n  DCHECK(!GetDrawingBuffer());\n\n  auto* execution_context = Host()->GetTopExecutionContext();\n  Platform::ContextAttributes attributes = ToPlatformContextAttributes(\n      CreationAttributes(), Version(),\n      SupportOwnOffscreenSurface(execution_context));\n  Platform::GraphicsInfo gl_info;\n  std::unique_ptr<WebGraphicsContext3DProvider> context_provider;\n  bool using_gpu_compositing;\n  const auto& url = Host()->GetExecutionContextUrl();\n\n  if (IsMainThread()) {\n    using_gpu_compositing = !Platform::Current()->IsGpuCompositingDisabled();\n    context_provider =\n        Platform::Current()->CreateOffscreenGraphicsContext3DProvider(\n            attributes, url, &gl_info);\n  } else {\n    context_provider = CreateContextProviderOnWorkerThread(\n        attributes, &gl_info, &using_gpu_compositing, url);\n  }\n  scoped_refptr<DrawingBuffer> buffer;\n  if (context_provider && context_provider->BindToCurrentThread()) {\n    buffer =\n        CreateDrawingBuffer(std::move(context_provider), using_gpu_compositing);\n  }\n  if (!buffer) {\n    if (context_lost_mode_ == kRealLostContext) {\n      restore_timer_.StartOneShot(kSecondsBetweenRestoreAttempts, FROM_HERE);\n    } else {\n      SynthesizeGLError(GL_INVALID_OPERATION, \"\", \"error restoring context\");\n    }\n    return;\n  }\n\n  drawing_buffer_ = std::move(buffer);\n  GetDrawingBuffer()->Bind(GL_FRAMEBUFFER);\n  lost_context_errors_.clear();\n  context_lost_mode_ = kNotLostContext;\n  auto_recovery_method_ = kManual;\n  restore_allowed_ = false;\n  RemoveFromEvictedList(this);\n\n  SetupFlags();\n  InitializeNewContext();\n  MarkContextChanged(kCanvasContextChanged);\n  WebGLContextEvent* event =\n      WebGLContextEvent::Create(EventTypeNames::webglcontextrestored, \"\");\n  Host()->HostDispatchEvent(event);\n}\n",
        "output": "0",
        "index": 166645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asf_read_ext_stream_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st    = NULL;\n    ff_asf_guid guid;\n    uint16_t nb_st_name, nb_pay_exts, st_num, lang_idx;\n    int i, ret;\n    uint32_t bitrate;\n    uint64_t start_time, end_time, time_per_frame;\n    uint64_t size = avio_rl64(pb);\n\n    start_time = avio_rl64(pb);\n    end_time   = avio_rl64(pb);\n    bitrate    = avio_rl32(pb);\n    avio_skip(pb, 28); // skip some unused values\n    st_num     = avio_rl16(pb);\n    st_num    &= ASF_STREAM_NUM;\n    lang_idx   = avio_rl16(pb); // Stream Language ID Index\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (st_num == asf->asf_st[i]->stream_index) {\n            st                       = s->streams[asf->asf_st[i]->index];\n            asf->asf_st[i]->lang_idx = lang_idx;\n            break;\n        }\n    }\n    time_per_frame = avio_rl64(pb); // average time per frame\n    if (st) {\n        st->start_time           = start_time;\n        st->duration             = end_time - start_time;\n        st->codecpar->bit_rate   = bitrate;\n        st->avg_frame_rate.num   = 10000000;\n        st->avg_frame_rate.den   = time_per_frame;\n    }\n    nb_st_name = avio_rl16(pb);\n    nb_pay_exts   = avio_rl16(pb);\n    for (i = 0; i < nb_st_name; i++) {\n        uint16_t len;\n\n        avio_rl16(pb); // Language ID Index\n        len = avio_rl16(pb);\n        avio_skip(pb, len);\n    }\n\n    for (i = 0; i < nb_pay_exts; i++) {\n        uint32_t len;\n        avio_skip(pb, 16); // Extension System ID\n        avio_skip(pb, 2);  // Extension Data Size\n        len = avio_rl32(pb);\n        avio_skip(pb, len);\n    }\n\n    if ((ret = ff_get_guid(pb, &guid)) < 0) {\n        align_position(pb, asf->offset, size);\n\n        return 0;\n    }\n\n    g = find_guid(guid);\n    if (g && !(strcmp(g->name, \"Stream Properties\"))) {\n        if ((ret = g->read_object(s, g)) < 0)\n            return ret;\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n",
        "output": "0",
        "index": 74868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "move_to_root(cmap_splay *tree, unsigned int x)\n{\n\tif (x == EMPTY)\n\t\treturn;\n\tdo\n\t{\n\t\tunsigned int z, zp;\n\t\tunsigned int y = tree[x].parent;\n\t\tif (y == EMPTY)\n\t\t\tbreak;\n\t\tz = tree[y].parent;\n\t\tif (z == EMPTY)\n\t\t{\n\t\t\t/* Case 3 */\n\t\t\ttree[x].parent = EMPTY;\n\t\t\ttree[y].parent = x;\n\t\t\tif (tree[y].left == x)\n\t\t\t{\n\t\t\t\t/* Case 3 */\n\t\t\t\ttree[y].left = tree[x].right;\n\t\t\t\tif (tree[y].left != EMPTY)\n\t\t\t\t\ttree[tree[y].left].parent = y;\n\t\t\t\ttree[x].right = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Case 3 - reflected */\n\t\t\t\tassert(tree[y].right == x);\n\t\t\t\ttree[y].right = tree[x].left;\n\t\t\t\tif (tree[y].right != EMPTY)\n\t\t\t\t\ttree[tree[y].right].parent = y;\n\t\t\t\ttree[x].left = y;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tzp = tree[z].parent;\n\t\ttree[x].parent = zp;\n\t\tif (zp != EMPTY) {\n\t\t\tif (tree[zp].left == z)\n\t\t\t\ttree[zp].left = x;\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(tree[zp].right == z);\n\t\t\t\ttree[zp].right = x;\n\t\t\t}\n\t\t}\n\t\ttree[y].parent = x;\n\t\tif (tree[y].left == x)\n\t\t{\n\t\t\ttree[y].left = tree[x].right;\n\t\t\tif (tree[y].left != EMPTY)\n\t\t\t\ttree[tree[y].left].parent = y;\n\t\t\ttree[x].right = y;\n\t\t\tif (tree[z].left == y)\n\t\t\t{\n\t\t\t\t/* Case 1 */\n\t\t\t\ttree[z].parent = y;\n\t\t\t\ttree[z].left = tree[y].right;\n\t\t\t\tif (tree[z].left != EMPTY)\n\t\t\t\t\ttree[tree[z].left].parent = z;\n\t\t\t\ttree[y].right = z;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Case 2 - reflected */\n\t\t\t\tassert(tree[z].right == y);\n\t\t\t\ttree[z].parent = x;\n\t\t\t\ttree[z].right = tree[x].left;\n\t\t\t\tif (tree[z].right != EMPTY)\n\t\t\t\t\ttree[tree[z].right].parent = z;\n\t\t\t\ttree[x].left = z;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(tree[y].right == x);\n\t\t\ttree[y].right = tree[x].left;\n\t\t\tif (tree[y].right != EMPTY)\n\t\t\t\ttree[tree[y].right].parent = y;\n\t\t\ttree[x].left = y;\n\t\t\tif (tree[z].left == y)\n\t\t\t{\n\t\t\t\t/* Case 2 */\n\t\t\t\ttree[z].parent = x;\n\t\t\t\ttree[z].left = tree[x].right;\n\t\t\t\tif (tree[z].left != EMPTY)\n\t\t\t\t\ttree[tree[z].left].parent = z;\n\t\t\t\ttree[x].right = z;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Case 1 - reflected */\n\t\t\t\tassert(tree[z].right == y);\n\t\t\t\ttree[z].parent = y;\n\t\t\t\ttree[z].right = tree[y].left;\n\t\t\t\tif (tree[z].right != EMPTY)\n\t\t\t\t\ttree[tree[z].right].parent = z;\n\t\t\t\ttree[y].left = z;\n\t\t\t}\n\t\t}\n\t} while (1);\n}\n",
        "output": "0",
        "index": 439
    }
]