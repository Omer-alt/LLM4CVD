[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::updateHoverActiveState(const HitTestRequest& request, Element* innerElement, const PlatformMouseEvent* event)\n{\n    ASSERT(!request.readOnly());\n\n    Element* innerElementInDocument = innerElement;\n    while (innerElementInDocument && innerElementInDocument->document() != this) {\n        innerElementInDocument->document().updateHoverActiveState(request, innerElementInDocument, event);\n        innerElementInDocument = innerElementInDocument->document().ownerElement();\n    }\n\n    Element* oldActiveElement = activeElement();\n    if (oldActiveElement && !request.active()) {\n        for (RenderObject* curr = oldActiveElement->renderer(); curr; curr = curr->parent()) {\n            if (curr->node()) {\n                ASSERT(!curr->node()->isTextNode());\n                curr->node()->setActive(false);\n                m_userActionElements.setInActiveChain(curr->node(), false);\n            }\n        }\n        setActiveElement(0);\n    } else {\n        Element* newActiveElement = innerElementInDocument;\n        if (!oldActiveElement && newActiveElement && request.active() && !request.touchMove()) {\n            for (RenderObject* curr = newActiveElement->renderer(); curr; curr = curr->parent()) {\n                if (curr->node() && !curr->isText())\n                    m_userActionElements.setInActiveChain(curr->node(), true);\n            }\n\n            setActiveElement(newActiveElement);\n        }\n    }\n    bool allowActiveChanges = !oldActiveElement && activeElement();\n\n    bool mustBeInActiveChain = request.active() && request.move();\n\n    RefPtr<Node> oldHoverNode = hoverNode();\n\n    if (request.touchRelease())\n        innerElementInDocument = 0;\n\n    Node* newHoverNode = innerElementInDocument;\n    while (newHoverNode && !newHoverNode->renderer())\n        newHoverNode = newHoverNode->parentOrShadowHostNode();\n\n    setHoverNode(newHoverNode);\n\n    RenderObject* oldHoverObj = oldHoverNode ? oldHoverNode->renderer() : 0;\n    RenderObject* newHoverObj = newHoverNode ? newHoverNode->renderer() : 0;\n\n    RenderObject* ancestor = nearestCommonHoverAncestor(oldHoverObj, newHoverObj);\n\n    Vector<RefPtr<Node>, 32> nodesToRemoveFromChain;\n    Vector<RefPtr<Node>, 32> nodesToAddToChain;\n\n    if (oldHoverObj != newHoverObj) {\n        if (oldHoverNode && !oldHoverObj) {\n            for (Node* node = oldHoverNode.get(); node; node = node->parentNode()) {\n                if (!mustBeInActiveChain || (node->isElementNode() && toElement(node)->inActiveChain()))\n                    nodesToRemoveFromChain.append(node);\n            }\n\n        }\n\n        for (RenderObject* curr = oldHoverObj; curr && curr != ancestor; curr = curr->hoverAncestor()) {\n            if (curr->node() && !curr->isText() && (!mustBeInActiveChain || curr->node()->inActiveChain()))\n                nodesToRemoveFromChain.append(curr->node());\n        }\n    }\n\n    for (RenderObject* curr = newHoverObj; curr; curr = curr->hoverAncestor()) {\n        if (curr->node() && !curr->isText() && (!mustBeInActiveChain || curr->node()->inActiveChain()))\n            nodesToAddToChain.append(curr->node());\n    }\n\n    bool ancestorHasCapturingMouseleaveListener = false;\n    if (event && newHoverNode != oldHoverNode.get()) {\n        for (Node* node = oldHoverNode.get(); node; node = node->parentOrShadowHostNode()) {\n            if (node->hasCapturingEventListeners(EventTypeNames::mouseleave)) {\n                ancestorHasCapturingMouseleaveListener = true;\n                break;\n            }\n        }\n    }\n\n    size_t removeCount = nodesToRemoveFromChain.size();\n    for (size_t i = 0; i < removeCount; ++i) {\n        nodesToRemoveFromChain[i]->setHovered(false);\n        if (event && (ancestorHasCapturingMouseleaveListener || nodesToRemoveFromChain[i]->hasEventListeners(EventTypeNames::mouseleave)))\n            nodesToRemoveFromChain[i]->dispatchMouseEvent(*event, EventTypeNames::mouseleave, 0, newHoverNode);\n    }\n\n    bool ancestorHasCapturingMouseenterListener = false;\n    if (event && newHoverNode != oldHoverNode.get()) {\n        for (Node* node = newHoverNode; node; node = node->parentOrShadowHostNode()) {\n            if (node->hasCapturingEventListeners(EventTypeNames::mouseenter)) {\n                ancestorHasCapturingMouseenterListener = true;\n                break;\n            }\n        }\n    }\n\n    bool sawCommonAncestor = false;\n    size_t addCount = nodesToAddToChain.size();\n    for (size_t i = 0; i < addCount; ++i) {\n        if (ancestor && nodesToAddToChain[i] == ancestor->node())\n            sawCommonAncestor = true;\n        if (allowActiveChanges)\n            nodesToAddToChain[i]->setActive(true);\n        if (!sawCommonAncestor) {\n            nodesToAddToChain[i]->setHovered(true);\n            if (event && (ancestorHasCapturingMouseenterListener || nodesToAddToChain[i]->hasEventListeners(EventTypeNames::mouseenter)))\n                nodesToAddToChain[i]->dispatchMouseEvent(*event, EventTypeNames::mouseenter, 0, oldHoverNode.get());\n        }\n    }\n\n    updateStyleIfNeeded();\n}\n",
        "output": "0",
        "index": 109859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Bool gf_sys_get_rti_os(u32 refresh_time_ms, GF_SystemRTInfo *rti, u32 flags)\n{\n\tu32 entry_time;\n\tu64 process_u_k_time;\n\tu32 u_k_time, idle_time;\n#if 0\n\tchar szProc[100];\n#endif\n\tchar line[2048];\n\tFILE *f;\n\n\tassert(sys_init);\n\n\tentry_time = gf_sys_clock();\n\tif (last_update_time && (entry_time - last_update_time < refresh_time_ms)) {\n\t\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\t\treturn 0;\n\t}\n\n\tu_k_time = idle_time = 0;\n\tf = gf_fopen(\"/proc/stat\", \"r\");\n\tif (f) {\n\t\tu32 k_time, nice_time, u_time;\n\t\tif (fgets(line, 128, f) != NULL) {\n\t\t\tif (sscanf(line, \"cpu  %u %u %u %u\\n\", &u_time, &k_time, &nice_time, &idle_time) == 4) {\n\t\t\t\tu_k_time = u_time + k_time + nice_time;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t}\n\n\tprocess_u_k_time = 0;\n\tthe_rti.process_memory = 0;\n\n\t/*FIXME? under LinuxThreads this will only fetch stats for the calling thread, we would have to enumerate /proc to get\n\tthe complete CPU usage of all therads of the process...*/\n#if 0\n\tsprintf(szProc, \"/proc/%d/stat\", the_rti.pid);\n\tf = gf_fopen(szProc, \"r\");\n\tif (f) {\n\t\tfflush(f);\n\t\tif (fgets(line, 2048, f) != NULL) {\n\t\t\tchar state;\n\t\t\tchar *start;\n\t\t\tlong cutime, cstime, priority, nice, itrealvalue, rss;\n\t\t\tint exit_signal, processor;\n\t\t\tunsigned long flags, minflt, cminflt, majflt, cmajflt, utime, stime,starttime, vsize, rlim, startcode, endcode, startstack, kstkesp, kstkeip, signal, blocked, sigignore, sigcatch, wchan, nswap, cnswap, rem;\n\t\t\tint ppid, pgrp ,session, tty_nr, tty_pgrp, res;\n\t\t\tstart = strchr(line, ')');\n\t\t\tif (start) start += 2;\n\t\t\telse {\n\t\t\t\tstart = strchr(line, ' ');\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tres = sscanf(start,\"%c %d %d %d %d %d %lu %lu %lu %lu \\\n%lu %lu %lu %ld %ld %ld %ld %ld %ld %lu \\\n%lu %ld %lu %lu %lu %lu %lu %lu %lu %lu \\\n%lu %lu %lu %lu %lu %d %d\",\n\t\t\t             &state, &ppid, &pgrp, &session, &tty_nr, &tty_pgrp, &flags, &minflt, &cminflt, &majflt,\n\t\t\t             &cmajflt, &utime, &stime, &cutime, &cstime, &priority, &nice, &itrealvalue, &rem, &starttime,\n\t\t\t             &vsize, &rss, &rlim, &startcode, &endcode, &startstack, &kstkesp, &kstkeip, &signal, &blocked,\n\t\t\t             &sigignore, &sigcatch, &wchan, &nswap, &cnswap, &exit_signal, &processor);\n\n\t\t\tif (res) process_u_k_time = (u64) (cutime + cstime);\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] PROC %s parse error\\n\", szProc));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] error reading pid/stat\\n\\n\", szProc));\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open %s\\n\", szProc));\n\t}\n\tsprintf(szProc, \"/proc/%d/status\", the_rti.pid);\n\tf = gf_fopen(szProc, \"r\");\n\tif (f) {\n\t\twhile (fgets(line, 1024, f) != NULL) {\n\t\t\tif (!strnicmp(line, \"VmSize:\", 7)) {\n\t\t\t\tsscanf(line, \"VmSize: %\"LLD\" kB\",  &the_rti.process_memory);\n\t\t\t\tthe_rti.process_memory *= 1024;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open %s\\n\", szProc));\n\t}\n#endif\n\n\n#ifndef GPAC_IPHONE\n\tthe_rti.physical_memory = the_rti.physical_memory_avail = 0;\n\tf = gf_fopen(\"/proc/meminfo\", \"r\");\n\tif (f) {\n\t\twhile (fgets(line, 1024, f) != NULL) {\n\t\t\tif (!strnicmp(line, \"MemTotal:\", 9)) {\n\t\t\t\tsscanf(line, \"MemTotal: \"LLU\" kB\",  &the_rti.physical_memory);\n\t\t\t\tthe_rti.physical_memory *= 1024;\n\t\t\t} else if (!strnicmp(line, \"MemFree:\", 8)) {\n\t\t\t\tsscanf(line, \"MemFree: \"LLU\" kB\",  &the_rti.physical_memory_avail);\n\t\t\t\tthe_rti.physical_memory_avail *= 1024;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[RTI] cannot open /proc/meminfo\\n\"));\n\t}\n#endif\n\n\n\tthe_rti.sampling_instant = last_update_time;\n\n\tif (last_update_time) {\n\t\tthe_rti.sampling_period_duration = (entry_time - last_update_time);\n\t\tthe_rti.process_cpu_time_diff = (u32) (process_u_k_time - last_process_k_u_time) * 10;\n\n\t\t/*oops, we have no choice but to assume 100% cpu usage during this period*/\n\t\tif (!u_k_time) {\n\t\t\tthe_rti.total_cpu_time_diff = the_rti.sampling_period_duration;\n\t\t\tu_k_time = (u32) (last_cpu_u_k_time + the_rti.sampling_period_duration);\n\t\t\tthe_rti.cpu_idle_time = 0;\n\t\t\tthe_rti.total_cpu_usage = 100;\n\t\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\t\t\tthe_rti.process_cpu_usage = (u32) ( 100 *  the_rti.process_cpu_time_diff / the_rti.sampling_period_duration);\n\t\t} else {\n\t\t\tu64 samp_sys_time;\n\t\t\t/*move to ms (/proc/stat gives times in 100 ms unit*/\n\t\t\tthe_rti.total_cpu_time_diff = (u32) (u_k_time - last_cpu_u_k_time)*10;\n\n\t\t\t/*we're not that accurate....*/\n\t\t\tif (the_rti.total_cpu_time_diff > the_rti.sampling_period_duration)\n\t\t\t\tthe_rti.sampling_period_duration = the_rti.total_cpu_time_diff;\n\n\n\t\t\tif (!idle_time) idle_time = (the_rti.sampling_period_duration - the_rti.total_cpu_time_diff)/10;\n\t\t\tsamp_sys_time = u_k_time - last_cpu_u_k_time;\n\t\t\tthe_rti.cpu_idle_time = (u32) (idle_time - last_cpu_idle_time);\n\t\t\tthe_rti.total_cpu_usage = (u32) ( 100 * samp_sys_time / (the_rti.cpu_idle_time + samp_sys_time ) );\n\t\t\t/*move to ms (/proc/stat gives times in 100 ms unit*/\n\t\t\tthe_rti.cpu_idle_time *= 10;\n\t\t\tif (!the_rti.process_cpu_time_diff) the_rti.process_cpu_time_diff = the_rti.total_cpu_time_diff;\n\t\t\tthe_rti.process_cpu_usage = (u32) ( 100 *  the_rti.process_cpu_time_diff / (the_rti.cpu_idle_time + 10*samp_sys_time ) );\n\t\t}\n\t} else {\n\t\tmem_at_startup = the_rti.physical_memory_avail;\n\t}\n\tthe_rti.process_memory = mem_at_startup - the_rti.physical_memory_avail;\n#ifdef GPAC_MEMORY_TRACKING\n\tthe_rti.gpac_memory = gpac_allocated_memory;\n#endif\n\n\tlast_process_k_u_time = process_u_k_time;\n\tlast_cpu_idle_time = idle_time;\n\tlast_cpu_u_k_time = u_k_time;\n\tlast_update_time = entry_time;\n\tmemcpy(rti, &the_rti, sizeof(GF_SystemRTInfo));\n\treturn 1;\n}\n",
        "output": "0",
        "index": 90845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n\t{\n\tint al,i,j,ret;\n\tunsigned int n;\n\tSSL3_RECORD *rr;\n\tvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\n\n\tif (s->s3->rbuf.buf == NULL) /* Not initialized yet */\n\t\tif (!ssl3_setup_buffers(s))\n\t\t\treturn(-1);\n\n\tif ((type && (type != SSL3_RT_APPLICATION_DATA) && \n\t\t(type != SSL3_RT_HANDSHAKE)) ||\n\t    (peek && (type != SSL3_RT_APPLICATION_DATA)))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\t/* check whether there's a handshake message (client hello?) waiting */\n\tif ( (ret = have_handshake_fragment(s, type, buf, len, peek)))\n\t\treturn ret;\n\n\t/* Now s->d1->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Continue handshake if it had to be interrupted to read\n\t * app data with SCTP.\n\t */\n\tif ((!s->in_handshake && SSL_in_init(s)) ||\n\t    (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&\n\t     s->s3->in_read_app_data != 2))\n#else\n\tif (!s->in_handshake && SSL_in_init(s))\n#endif\n\t\t{\n\t\t/* type == SSL3_RT_APPLICATION_DATA */\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\n\nstart:\n\ts->rwstate=SSL_NOTHING;\n\n\t/*-\n\t * s->s3->rrec.type\t    - is the type of record\n\t * s->s3->rrec.data,    - data\n\t * s->s3->rrec.off,     - offset into 'data' for next read\n\t * s->s3->rrec.length,  - number of bytes. \n\t */\n\trr = &(s->s3->rrec);\n\n\t/* We are not handshaking and have no data yet,\n\t * so process data buffered during the last handshake\n\t * in advance, if any.\n\t */\n\tif (s->state == SSL_ST_OK && rr->length == 0)\n\t\t{\n\t\tpitem *item;\n\t\titem = pqueue_pop(s->d1->buffered_app_data.q);\n\t\tif (item)\n\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* Restore bio_dgram_sctp_rcvinfo struct */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)))\n\t\t\t\t{\n\t\t\t\tDTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *) item->data;\n\t\t\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t\t\t\t}\n#endif\n\n\t\t\tdtls1_copy_record(s, item);\n\n\t\t\tOPENSSL_free(item->data);\n\t\t\tpitem_free(item);\n\t\t\t}\n\t\t}\n\n\t/* Check for timeout */\n\tif (dtls1_handle_timeout(s) > 0)\n\t\tgoto start;\n\n\t/* get new packet if necessary */\n\tif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\n\t\t{\n\t\tret=dtls1_get_record(s);\n\t\tif (ret <= 0) \n\t\t\t{\n\t\t\tret = dtls1_read_failed(s, ret);\n\t\t\t/* anything other than a timeout is an error */\n\t\t\tif (ret <= 0)  \n\t\t\t\treturn(ret);\n\t\t\telse\n\t\t\t\tgoto start;\n\t\t\t}\n\t\t}\n\n\tif (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE)\n\t\t{\n\t\trr->length = 0;\n\t\tgoto start;\n\t\t}\n\n\t/* we now have a packet which can be read and processed */\n\n\tif (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n\t                               * reset by ssl3_get_finished */\n\t\t&& (rr->type != SSL3_RT_HANDSHAKE))\n\t\t{\n\t\t/* We now have application data between CCS and Finished.\n\t\t * Most likely the packets were reordered on their way, so\n\t\t * buffer the application data for later processing rather\n\t\t * than dropping the connection.\n\t\t */\n\t\tdtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num);\n\t\trr->length = 0;\n\t\tgoto start;\n\t\t}\n\n\t/* If the other end has shut down, throw anything we read away\n\t * (even in 'peek' mode) */\n\tif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\n\t\t{\n\t\trr->length=0;\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n\n\n\tif (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */\n\t\t{\n\t\t/* make sure that we are not getting application data when we\n\t\t * are doing a handshake for the first time */\n\t\tif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n\t\t\t(s->enc_read_ctx == NULL))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (len <= 0) return(len);\n\n\t\tif ((unsigned int)len > rr->length)\n\t\t\tn = rr->length;\n\t\telse\n\t\t\tn = (unsigned int)len;\n\n\t\tmemcpy(buf,&(rr->data[rr->off]),n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\trr->length-=n;\n\t\t\trr->off+=n;\n\t\t\tif (rr->length == 0)\n\t\t\t\t{\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->off=0;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef OPENSSL_NO_SCTP\n\t\t\t/* We were about to renegotiate but had to read\n\t\t\t * belated application data first, so retry.\n\t\t\t */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t    rr->type == SSL3_RT_APPLICATION_DATA &&\n\t\t\t    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK))\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t}\n\n\t\t\t/* We might had to delay a close_notify alert because\n\t\t\t * of reordered app data. If there was an alert and there\n\t\t\t * is no message to read anymore, finally set shutdown.\n\t\t\t */\n\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t    s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\n\t\t\t\t{\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n#endif\t\t\t\n\t\treturn(n);\n\t\t}\n\n\n\t/* If we get here, then type != rr->type; if we have a handshake\n\t * message, then it was unexpected (Hello Request or Client Hello). */\n\n\t/* In case of record types for which we have 'fragment' storage,\n\t * fill that so that we can process the data at a fixed place.\n\t */\n\t\t{\n\t\tunsigned int k, dest_maxlen = 0;\n\t\tunsigned char *dest = NULL;\n\t\tunsigned int *dest_len = NULL;\n\n\t\tif (rr->type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->d1->handshake_fragment;\n\t\t\tdest = s->d1->handshake_fragment;\n\t\t\tdest_len = &s->d1->handshake_fragment_len;\n\t\t\t}\n\t\telse if (rr->type == SSL3_RT_ALERT)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof(s->d1->alert_fragment);\n\t\t\tdest = s->d1->alert_fragment;\n\t\t\tdest_len = &s->d1->alert_fragment_len;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (rr->type == TLS1_RT_HEARTBEAT)\n\t\t\t{\n\t\t\tdtls1_process_heartbeat(s);\n\n\t\t\t/* Exit and notify application to read again */\n\t\t\trr->length = 0;\n\t\t\ts->rwstate=SSL_READING;\n\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\treturn(-1);\n\t\t\t}\n#endif\n\t\t/* else it's a CCS message, or application data or wrong */\n\t\telse if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t\t{\n\t\t\t/* Application data while renegotiating\n\t\t\t * is allowed. Try again reading.\n\t\t\t */\n\t\t\tif (rr->type == SSL3_RT_APPLICATION_DATA)\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\ts->s3->in_read_app_data=2;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\n\t\t\t/* Not certain if this is the right error handling */\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (dest_maxlen > 0)\n\t\t\t{\n            /* XDTLS:  In a pathalogical case, the Client Hello\n             *  may be fragmented--don't always expect dest_maxlen bytes */\n\t\t\tif ( rr->length < dest_maxlen)\n\t\t\t\t{\n#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE\n\t\t\t\t/*\n\t\t\t\t * for normal alerts rr->length is 2, while\n\t\t\t\t * dest_maxlen is 7 if we were to handle this\n\t\t\t\t * non-existing alert...\n\t\t\t\t */\n\t\t\t\tFIX ME\n#endif\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->length = 0;\n\t\t\t\tgoto start;\n\t\t\t\t}\n\n\t\t\t/* now move 'n' bytes: */\n\t\t\tfor ( k = 0; k < dest_maxlen; k++)\n\t\t\t\t{\n\t\t\t\tdest[k] = rr->data[rr->off++];\n\t\t\t\trr->length--;\n\t\t\t\t}\n\t\t\t*dest_len = dest_maxlen;\n\t\t\t}\n\t\t}\n\n\t/* s->d1->handshake_fragment_len == 12  iff  rr->type == SSL3_RT_HANDSHAKE;\n\t * s->d1->alert_fragment_len == 7      iff  rr->type == SSL3_RT_ALERT.\n\t * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) */\n\n\t/* If we are a client, check for an incoming 'Hello Request': */\n\tif ((!s->server) &&\n\t\t(s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&\n\t\t(s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL))\n\t\t{\n\t\ts->d1->handshake_fragment_len = 0;\n\n\t\tif ((s->d1->handshake_fragment[1] != 0) ||\n\t\t\t(s->d1->handshake_fragment[2] != 0) ||\n\t\t\t(s->d1->handshake_fragment[3] != 0))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t/* no need to check sequence number on HELLO REQUEST messages */\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, \n\t\t\t\ts->d1->handshake_fragment, 4, s, s->msg_callback_arg);\n\n\t\tif (SSL_is_init_finished(s) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n\t\t\t!s->s3->renegotiate)\n\t\t\t{\n\t\t\ts->d1->handshake_read_seq++;\n\t\t\ts->new_session = 1;\n\t\t\tssl3_renegotiate(s);\n\t\t\tif (ssl3_renegotiate_check(s))\n\t\t\t\t{\n\t\t\t\ti=s->handshake_func(s);\n\t\t\t\tif (i < 0) return(i);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\t\t\treturn(-1);\n\t\t\t\t\t}\n\n\t\t\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t\t\t{\n\t\t\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t\t\t{\n\t\t\t\t\t\tBIO *bio;\n\t\t\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/* we either finished a handshake or ignored the request,\n\t\t * now try again to obtain the (application) data we were asked for */\n\t\tgoto start;\n\t\t}\n\n\tif (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH)\n\t\t{\n\t\tint alert_level = s->d1->alert_fragment[0];\n\t\tint alert_descr = s->d1->alert_fragment[1];\n\n\t\ts->d1->alert_fragment_len = 0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, \n\t\t\t\ts->d1->alert_fragment, 2, s, s->msg_callback_arg);\n\n\t\tif (s->info_callback != NULL)\n\t\t\tcb=s->info_callback;\n\t\telse if (s->ctx->info_callback != NULL)\n\t\t\tcb=s->ctx->info_callback;\n\n\t\tif (cb != NULL)\n\t\t\t{\n\t\t\tj = (alert_level << 8) | alert_descr;\n\t\t\tcb(s, SSL_CB_READ_ALERT, j);\n\t\t\t}\n\n\t\tif (alert_level == 1) /* warning */\n\t\t\t{\n\t\t\ts->s3->warn_alert = alert_descr;\n\t\t\tif (alert_descr == SSL_AD_CLOSE_NOTIFY)\n\t\t\t\t{\n#ifndef OPENSSL_NO_SCTP\n\t\t\t\t/* With SCTP and streams the socket may deliver app data\n\t\t\t\t * after a close_notify alert. We have to check this\n\t\t\t\t * first so that nothing gets discarded.\n\t\t\t\t */\n\t\t\t\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t\t\t\t\tBIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))\n\t\t\t\t\t{\n\t\t\t\t\ts->d1->shutdown_received = 1;\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n#endif\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n#if 0\n            /* XXX: this is a possible improvement in the future */\n\t\t\t/* now check if it's a missing record */\n\t\t\tif (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)\n\t\t\t\t{\n\t\t\t\tunsigned short seq;\n\t\t\t\tunsigned int frag_off;\n\t\t\t\tunsigned char *p = &(s->d1->alert_fragment[2]);\n\n\t\t\t\tn2s(p, seq);\n\t\t\t\tn2l3(p, frag_off);\n\n\t\t\t\tdtls1_retransmit_message(s,\n\t\t\t\t\t\t\t\t\t\t dtls1_get_queue_priority(frag->msg_header.seq, 0),\n\t\t\t\t\t\t\t\t\t\t frag_off, &found);\n\t\t\t\tif ( ! found  && SSL_in_init(s))\n\t\t\t\t\t{\n\t\t\t\t\t/* fprintf( stderr,\"in init = %d\\n\", SSL_in_init(s)); */\n\t\t\t\t\t/* requested a message not yet sent, \n\t\t\t\t\t   send an alert ourselves */\n\t\t\t\t\tssl3_send_alert(s,SSL3_AL_WARNING,\n\t\t\t\t\t\tDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\telse if (alert_level == 2) /* fatal */\n\t\t\t{\n\t\t\tchar tmp[16];\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->s3->fatal_alert = alert_descr;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\n\t\t\tERR_add_error_data(2,\"SSL alert number \",tmp);\n\t\t\ts->shutdown|=SSL_RECEIVED_SHUTDOWN;\n\t\t\tSSL_CTX_remove_session(s->ctx,s->session);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tgoto start;\n\t\t}\n\n\tif (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\trr->length=0;\n\t\treturn(0);\n\t\t}\n\n\tif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t{\n\t\tstruct ccs_header_st ccs_hdr;\n\t\tunsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH;\n\n\t\tdtls1_get_ccs_header(rr->data, &ccs_hdr);\n\n\t\tif (s->version == DTLS1_BAD_VER)\n\t\t\tccs_hdr_len = 3;\n\n\t\t/* 'Change Cipher Spec' is just a single byte, so we know\n\t\t * exactly what the record payload has to look like */\n\t\t/* XDTLS: check that epoch is consistent */\n\t\tif (\t(rr->length != ccs_hdr_len) || \n\t\t\t(rr->off != 0) || (rr->data[0] != SSL3_MT_CCS))\n\t\t\t{\n\t\t\ti=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\trr->length=0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, \n\t\t\t\trr->data, 1, s, s->msg_callback_arg);\n\n\t\t/* We can't process a CCS now, because previous handshake\n\t\t * messages are still missing, so just drop it.\n\t\t */\n\t\tif (!s->d1->change_cipher_spec_ok)\n\t\t\t{\n\t\t\tgoto start;\n\t\t\t}\n\n\t\ts->d1->change_cipher_spec_ok = 0;\n\n\t\ts->s3->change_cipher_spec=1;\n\t\tif (!ssl3_do_change_cipher_spec(s))\n\t\t\tgoto err;\n\n\t\t/* do this whenever CCS is processed */\n\t\tdtls1_reset_seq_numbers(s, SSL3_CC_READ);\n\n\t\tif (s->version == DTLS1_BAD_VER)\n\t\t\ts->d1->handshake_read_seq++;\n\n#ifndef OPENSSL_NO_SCTP\n\t\t/* Remember that a CCS has been received,\n\t\t * so that an old key of SCTP-Auth can be\n\t\t * deleted when a CCS is sent. Will be ignored\n\t\t * if no SCTP is used\n\t\t */\n\t\tBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);\n#endif\n\n\t\tgoto start;\n\t\t}\n\n\t/* Unexpected handshake message (Client Hello, or protocol violation) */\n\tif ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) && \n\t\t!s->in_handshake)\n\t\t{\n\t\tstruct hm_header_st msg_hdr;\n\t\t\n\t\t/* this may just be a stale retransmit */\n\t\tdtls1_get_message_header(rr->data, &msg_hdr);\n\t\tif( rr->epoch != s->d1->r_epoch)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n\n\t\t/* If we are server, we may have a repeated FINISHED of the\n\t\t * client here, then retransmit our CCS and FINISHED.\n\t\t */\n\t\tif (msg_hdr.type == SSL3_MT_FINISHED)\n\t\t\t{\n\t\t\tif (dtls1_check_timeout_num(s) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tdtls1_retransmit_buffered_messages(s);\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n\n\t\tif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\n\t\t\t{\n#if 0 /* worked only because C operator preferences are not as expected (and\n       * because this is not really needed for clients except for detecting\n       * protocol violations): */\n\t\t\ts->state=SSL_ST_BEFORE|(s->server)\n\t\t\t\t?SSL_ST_ACCEPT\n\t\t\t\t:SSL_ST_CONNECT;\n#else\n\t\t\ts->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\n\t\t\ts->renegotiate=1;\n\t\t\ts->new_session=1;\n\t\t\t}\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\n\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t{\n\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tgoto start;\n\t\t}\n\n\tswitch (rr->type)\n\t\t{\n\tdefault:\n#ifndef OPENSSL_NO_TLS\n\t\t/* TLS just ignores unknown message types */\n\t\tif (s->version == TLS1_VERSION)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n#endif\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\tgoto f_err;\n\tcase SSL3_RT_CHANGE_CIPHER_SPEC:\n\tcase SSL3_RT_ALERT:\n\tcase SSL3_RT_HANDSHAKE:\n\t\t/* we already handled all of these, with the possible exception\n\t\t * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that\n\t\t * should not happen when type != rr->type */\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,ERR_R_INTERNAL_ERROR);\n\t\tgoto f_err;\n\tcase SSL3_RT_APPLICATION_DATA:\n\t\t/* At this point, we were expecting handshake data,\n\t\t * but have application data.  If the library was\n\t\t * running inside ssl3_read() (i.e. in_read_app_data\n\t\t * is set) and it makes sense to read application data\n\t\t * at this point (session renegotiation not yet started),\n\t\t * we will indulge it.\n\t\t */\n\t\tif (s->s3->in_read_app_data &&\n\t\t\t(s->s3->total_renegotiations != 0) &&\n\t\t\t((\n\t\t\t\t(s->state & SSL_ST_CONNECT) &&\n\t\t\t\t(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n\t\t\t\t(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n\t\t\t\t) || (\n\t\t\t\t\t(s->state & SSL_ST_ACCEPT) &&\n\t\t\t\t\t(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n\t\t\t\t\t(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t{\n\t\t\ts->s3->in_read_app_data=2;\n\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\t/* not reached */\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}\n",
        "output": "0",
        "index": 46482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\tstruct block_cursor cursor;\n\tint status;\n\tstruct enhanced_packet_block *epbp;\n\tstruct simple_packet_block *spbp;\n\tstruct packet_block *pbp;\n\tbpf_u_int32 interface_id = 0xFFFFFFFF;\n\tstruct interface_description_block *idbp;\n\tstruct section_header_block *shbp;\n\tFILE *fp = p->rfile;\n\tuint64_t t, sec, frac;\n\n\t/*\n\t * Look for an Enhanced Packet Block, a Simple Packet Block,\n\t * or a Packet Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the block type and length; those are common\n\t\t * to all blocks.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, p->errbuf);\n\t\tif (status == 0)\n\t\t\treturn (1);\t/* EOF */\n\t\tif (status == -1)\n\t\t\treturn (-1);\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_EPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * EPB.\n\t\t\t */\n\t\t\tepbp = get_from_block_data(&cursor, sizeof(*epbp),\n\t\t\t    p->errbuf);\n\t\t\tif (epbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPLONG(epbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(epbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(epbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(epbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = epbp->interface_id;\n\t\t\t\thdr->caplen = epbp->caplen;\n\t\t\t\thdr->len = epbp->len;\n\t\t\t\tt = ((uint64_t)epbp->timestamp_high) << 32 |\n\t\t\t\t    epbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_SPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * SPB.\n\t\t\t */\n\t\t\tspbp = get_from_block_data(&cursor, sizeof(*spbp),\n\t\t\t    p->errbuf);\n\t\t\tif (spbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * SPB packets are assumed to have arrived on\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tinterface_id = 0;\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\thdr->len = SWAPLONG(spbp->len);\n\t\t\t} else\n\t\t\t\thdr->len = spbp->len;\n\n\t\t\t/*\n\t\t\t * The SPB doesn't give the captured length;\n\t\t\t * it's the minimum of the snapshot length\n\t\t\t * and the packet length.\n\t\t\t */\n\t\t\thdr->caplen = hdr->len;\n\t\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot)\n\t\t\t\thdr->caplen = p->snapshot;\n\t\t\tt = 0;\t/* no time stamps */\n\t\t\tgoto found;\n\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * PB.\n\t\t\t */\n\t\t\tpbp = get_from_block_data(&cursor, sizeof(*pbp),\n\t\t\t    p->errbuf);\n\t\t\tif (pbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPSHORT(pbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(pbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(pbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(pbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = pbp->interface_id;\n\t\t\t\thdr->caplen = pbp->caplen;\n\t\t\t\thdr->len = pbp->len;\n\t\t\t\tt = ((uint64_t)pbp->timestamp_high) << 32 |\n\t\t\t\t    pbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Interface Description Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    p->errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the link-layer type or snapshot length\n\t\t\t * differ from the ones for the first IDB we\n\t\t\t * saw, quit.\n\t\t\t *\n\t\t\t * XXX - just discard packets from those\n\t\t\t * interfaces?\n\t\t\t */\n\t\t\tif (p->linktype != idbp->linktype) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a type %u different from the type of the first interface\",\n\t\t\t\t    idbp->linktype);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check against the *adjusted* value of this IDB's\n\t\t\t * snapshot length.\n\t\t\t */\n\t\t\tif ((bpf_u_int32)p->snapshot !=\n\t\t\t    pcap_adjust_snapshot(p->linktype, idbp->snaplen)) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a snapshot length %u different from the type of the first interface\",\n\t\t\t\t    idbp->snaplen);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, p->errbuf))\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\n\t\tcase BT_SHB:\n\t\t\t/*\n\t\t\t * Section Header Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tshbp = get_from_block_data(&cursor, sizeof(*shbp),\n\t\t\t    p->errbuf);\n\t\t\tif (shbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Assume the byte order of this section is\n\t\t\t * the same as that of the previous section.\n\t\t\t * We'll check for that later.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tshbp->byte_order_magic =\n\t\t\t\t    SWAPLONG(shbp->byte_order_magic);\n\t\t\t\tshbp->major_version =\n\t\t\t\t    SWAPSHORT(shbp->major_version);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the byte order doesn't change;\n\t\t\t * pcap_is_swapped() shouldn't change its\n\t\t\t * return value in the middle of reading a capture.\n\t\t\t */\n\t\t\tswitch (shbp->byte_order_magic) {\n\n\t\t\tcase BYTE_ORDER_MAGIC:\n\t\t\t\t/*\n\t\t\t\t * OK.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase SWAPLONG(BYTE_ORDER_MAGIC):\n\t\t\t\t/*\n\t\t\t\t * Byte order changes.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has sections with different byte orders\");\n\t\t\t\treturn (-1);\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Not a valid SHB.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has a section with a bad byte order magic field\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the major version is the version\n\t\t\t * we handle.\n\t\t\t */\n\t\t\tif (shbp->major_version != PCAP_NG_VERSION_MAJOR) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"unknown pcapng savefile major version number %u\",\n\t\t\t\t    shbp->major_version);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Reset the interface count; this section should\n\t\t\t * have its own set of IDBs.  If any of them\n\t\t\t * don't have the same interface type, snapshot\n\t\t\t * length, or resolution as the first interface\n\t\t\t * we saw, we'll fail.  (And if we don't see\n\t\t\t * any IDBs, we'll fail when we see a packet\n\t\t\t * block.)\n\t\t\t */\n\t\t\tps->ifcount = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a packet block, IDB, or SHB; ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\nfound:\n\t/*\n\t * Is the interface ID an interface we know?\n\t */\n\tif (interface_id >= ps->ifcount) {\n\t\t/*\n\t\t * Yes.  Fail.\n\t\t */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"a packet arrived on interface %u, but there's no Interface Description Block for that interface\",\n\t\t    interface_id);\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Convert the time stamp to seconds and fractions of a second,\n\t * with the fractions being in units of the file-supplied resolution.\n\t */\n\tsec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;\n\tfrac = t % ps->ifaces[interface_id].tsresol;\n\n\t/*\n\t * Convert the fractions from units of the file-supplied resolution\n\t * to units of the user-requested resolution.\n\t */\n\tswitch (ps->ifaces[interface_id].scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * The interface resolution is what the user wants,\n\t\t * so we're done.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP_DEC:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is greater than the file-supplied\n\t\t * resolution, so the quotient in question is an integer.\n\t\t * We've calculated that quotient already, so we just\n\t\t * multiply by it.\n\t\t */\n\t\tfrac *= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\tcase SCALE_UP_BIN:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, so, in order to do this\n\t\t * entirely with integer arithmetic, we multiply by the\n\t\t * user-requested resolution and divide by the file-\n\t\t * supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\n\tcase SCALE_DOWN_DEC:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is less than the file-supplied\n\t\t * resolution, so the quotient in question isn't an\n\t\t * integer, but its reciprocal is, and we can just divide\n\t\t * by the reciprocal of the quotient.  We've calculated\n\t\t * the reciprocal of that quotient already, so we must\n\t\t * divide by it.\n\t\t */\n\t\tfrac /= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\n\tcase SCALE_DOWN_BIN:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; convert the fractional part to units of the\n\t\t * resolution the user requested by multiplying by the\n\t\t * quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.  We do that by multiplying\n\t\t * by the user-requested resolution and dividing by the\n\t\t * file-supplied resolution, as the quotient might not\n\t\t * fit in an integer.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, and neither is its\n\t\t * reciprocal, so, in order to do this entirely with\n\t\t * integer arithmetic, we multiply by the user-requested\n\t\t * resolution and divide by the file-supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\t}\n#ifdef _WIN32\n\t/*\n\t * tv_sec and tv_used in the Windows struct timeval are both\n\t * longs.\n\t */\n\thdr->ts.tv_sec = (long)sec;\n\thdr->ts.tv_usec = (long)frac;\n#else\n\t/*\n\t * tv_sec in the UN*X struct timeval is a time_t; tv_usec is\n\t * suseconds_t in UN*Xes that work the way the current Single\n\t * UNIX Standard specify - but not all older UN*Xes necessarily\n\t * support that type, so just cast to int.\n\t */\n\thdr->ts.tv_sec = (time_t)sec;\n\thdr->ts.tv_usec = (int)frac;\n#endif\n\n\t/*\n\t * Get a pointer to the packet data.\n\t */\n\t*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);\n\tif (*data == NULL)\n\t\treturn (-1);\n\n\tif (p->swapped)\n\t\tswap_pseudo_headers(p->linktype, hdr, *data);\n\n\treturn (0);\n}\n",
        "output": "0",
        "index": 88402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int AppLayerProtoDetectTest10(void)\n{\n    AppLayerProtoDetectUnittestCtxBackup();\n    AppLayerProtoDetectSetup();\n\n    uint8_t l7data[] = {\n        0x05, 0x00, 0x0b, 0x03, 0x10, 0x00, 0x00, 0x00,\n        0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0xd0, 0x16, 0xd0, 0x16, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,\n        0xb8, 0x4a, 0x9f, 0x4d, 0x1c, 0x7d, 0xcf, 0x11,\n        0x86, 0x1e, 0x00, 0x20, 0xaf, 0x6e, 0x7c, 0x57,\n        0x00, 0x00, 0x00, 0x00, 0x04, 0x5d, 0x88, 0x8a,\n        0xeb, 0x1c, 0xc9, 0x11, 0x9f, 0xe8, 0x08, 0x00,\n        0x2b, 0x10, 0x48, 0x60, 0x02, 0x00, 0x00, 0x00\n    };\n    const char *buf;\n    int r = 0;\n    Flow f;\n    AppProto pm_results[ALPROTO_MAX];\n    AppLayerProtoDetectThreadCtx *alpd_tctx;\n\n    memset(&f, 0x00, sizeof(f));\n    f.protomap = FlowGetProtoMapping(IPPROTO_TCP);\n\n    memset(pm_results, 0, sizeof(pm_results));\n\n    buf = \"|05 00|\";\n    AppLayerProtoDetectPMRegisterPatternCS(IPPROTO_TCP, ALPROTO_DCERPC, buf, 4, 0, STREAM_TOCLIENT);\n\n    AppLayerProtoDetectPrepareState();\n    /* AppLayerProtoDetectGetCtxThread() should be called post AppLayerProtoDetectPrepareState(), since\n     * it sets internal structures which depends on the above function. */\n    alpd_tctx = AppLayerProtoDetectGetCtxThread();\n\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].max_pat_id != 0) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].max_pat_id != 0\\n\");\n        goto end;\n    }\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].max_pat_id != 1) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].max_pat_id != 2\\n\");\n        goto end;\n    }\n\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].map != NULL) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].map != NULL\\n\");\n        goto end;\n    }\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map == NULL) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map != NULL\\n\");\n        goto end;\n    }\n\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map[0]->alproto != ALPROTO_DCERPC) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map[0].alproto != ALPROTO_DCERPC\\n\");\n        goto end;\n    }\n\n    uint32_t cnt = AppLayerProtoDetectPMGetProto(alpd_tctx,\n                                                 &f,\n                                                 l7data, sizeof(l7data),\n                                                 STREAM_TOCLIENT,\n                                                 IPPROTO_TCP,\n                                                 pm_results);\n    if (cnt != 1 && pm_results[0] != ALPROTO_DCERPC) {\n        printf(\"cnt != 1 && pm_results[0] != AlPROTO_DCERPC\\n\");\n        goto end;\n    }\n\n    r = 1;\n\n end:\n    if (alpd_tctx != NULL)\n        AppLayerProtoDetectDestroyCtxThread(alpd_tctx);\n    AppLayerProtoDetectDeSetup();\n    AppLayerProtoDetectUnittestCtxRestore();\n    return r;\n}\n",
        "output": "0",
        "index": 96521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOLEAN btif_hl_proc_sdp_query_cfm(tBTA_HL *p_data){\n btif_hl_app_cb_t *p_acb;\n btif_hl_mcl_cb_t *p_mcb;\n    tBTA_HL_SDP                     *p_sdp;\n    tBTA_HL_CCH_OPEN_PARAM          open_param;\n    UINT8                           app_idx, mcl_idx, sdp_idx = 0;\n    UINT8                           num_recs, i, num_mdeps, j;\n btif_hl_cch_op_t                old_cch_oper;\n    BOOLEAN                         status =FALSE;\n btif_hl_pending_chan_cb_t *p_pcb;\n\n    BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);\n\n    p_sdp = p_data->sdp_query_cfm.p_sdp;\n    num_recs = p_sdp->num_recs;\n\n    BTIF_TRACE_DEBUG(\"num of SDP records=%d\",num_recs);\n for (i=0; i<num_recs; i++)\n {\n        BTIF_TRACE_DEBUG(\"rec_idx=%d ctrl_psm=0x%x data_psm=0x%x\",\n (i+1),p_sdp->sdp_rec[i].ctrl_psm, p_sdp->sdp_rec[i].data_psm);\n        BTIF_TRACE_DEBUG(\"MCAP supported procedures=0x%x\",p_sdp->sdp_rec[i].mcap_sup_proc);\n        num_mdeps = p_sdp->sdp_rec[i].num_mdeps;\n        BTIF_TRACE_DEBUG(\"num of mdeps =%d\",num_mdeps);\n for (j=0; j< num_mdeps; j++)\n {\n            BTIF_TRACE_DEBUG(\"mdep_idx=%d mdep_id=0x%x data_type=0x%x mdep_role=0x%x\",\n (j+1),\n                              p_sdp->sdp_rec[i].mdep_cfg[j].mdep_id,\n                              p_sdp->sdp_rec[i].mdep_cfg[j].data_type,\n                              p_sdp->sdp_rec[i].mdep_cfg[j].mdep_role );\n }\n }\n\n if (btif_hl_find_app_idx_using_app_id(p_data->sdp_query_cfm.app_id, &app_idx))\n {\n            p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);\n\n if (btif_hl_find_mcl_idx(app_idx, p_data->sdp_query_cfm.bd_addr, &mcl_idx))\n {\n                p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);\n if (p_mcb->cch_oper != BTIF_HL_CCH_OP_NONE)\n {\n                    memcpy(&p_mcb->sdp, p_sdp, sizeof(tBTA_HL_SDP));\n                    old_cch_oper = p_mcb->cch_oper;\n                    p_mcb->cch_oper = BTIF_HL_CCH_OP_NONE;\n\n switch (old_cch_oper)\n {\n case BTIF_HL_CCH_OP_MDEP_FILTERING:\n                            status = btif_hl_find_sdp_idx_using_mdep_filter(app_idx,\n                                                                    mcl_idx, &sdp_idx);\n break;\n default:\n break;\n }\n\n if (status)\n {\n                        p_mcb->sdp_idx       = sdp_idx;\n                        p_mcb->valid_sdp_idx = TRUE;\n                        p_mcb->ctrl_psm      = p_mcb->sdp.sdp_rec[sdp_idx].ctrl_psm;\n\n switch (old_cch_oper)\n {\n case BTIF_HL_CCH_OP_MDEP_FILTERING:\n                                p_pcb = BTIF_HL_GET_PCB_PTR(app_idx, mcl_idx);\n if (p_pcb->in_use)\n {\n if (!p_pcb->abort_pending)\n {\n switch (p_pcb->op)\n {\n case BTIF_HL_PEND_DCH_OP_OPEN:\n                                                btif_hl_send_setup_connecting_cb(app_idx, mcl_idx);\n break;\n case BTIF_HL_PEND_DCH_OP_DELETE_MDL:\n default:\n break;\n }\n                                        open_param.ctrl_psm = p_mcb->ctrl_psm;\n                                        bdcpy(open_param.bd_addr, p_mcb->bd_addr);\n                                        open_param.sec_mask =\n (BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT);\n                                        BTA_HlCchOpen(p_acb->app_id,p_acb->app_handle, &open_param);\n }\n else\n {\n                                        BTIF_TRACE_DEBUG(\"channel abort pending\");\n }\n }\n break;\n\n case BTIF_HL_CCH_OP_DCH_OPEN:\n                                status = btif_hl_proc_pending_op(app_idx,mcl_idx);\n break;\n\n default:\n                                BTIF_TRACE_ERROR(\"Invalid CCH oper %d\", old_cch_oper);\n break;\n }\n }\n else\n {\n                        BTIF_TRACE_ERROR(\"Can not find SDP idx discard CCH Open request\");\n }\n }\n }\n }\n return status;\n}\n",
        "output": "0",
        "index": 171910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vmci_transport_recv_connecting_server(struct sock *listener,\n\t\t\t\t      struct sock *pending,\n\t\t\t\t      struct vmci_transport_packet *pkt)\n{\n\tstruct vsock_sock *vpending;\n\tstruct vmci_handle handle;\n\tstruct vmci_qp *qpair;\n\tbool is_local;\n\tu32 flags;\n\tu32 detach_sub_id;\n\tint err;\n\tint skerr;\n\n\tvpending = vsock_sk(pending);\n\tdetach_sub_id = VMCI_INVALID_ID;\n\n\tswitch (pkt->type) {\n\tcase VMCI_TRANSPORT_PACKET_TYPE_OFFER:\n\t\tif (vmci_handle_is_invalid(pkt->u.handle)) {\n\t\t\tvmci_transport_send_reset(pending, pkt);\n\t\t\tskerr = EPROTO;\n\t\t\terr = -EINVAL;\n\t\t\tgoto destroy;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* Close and cleanup the connection. */\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\tskerr = EPROTO;\n\t\terr = pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST ? 0 : -EINVAL;\n\t\tgoto destroy;\n\t}\n\n\t/* In order to complete the connection we need to attach to the offered\n\t * queue pair and send an attach notification.  We also subscribe to the\n\t * detach event so we know when our peer goes away, and we do that\n\t * before attaching so we don't miss an event.  If all this succeeds,\n\t * we update our state and wakeup anything waiting in accept() for a\n\t * connection.\n\t */\n\n\t/* We don't care about attach since we ensure the other side has\n\t * attached by specifying the ATTACH_ONLY flag below.\n\t */\n\terr = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,\n\t\t\t\t   vmci_transport_peer_detach_cb,\n\t\t\t\t   pending, &detach_sub_id);\n\tif (err < VMCI_SUCCESS) {\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tskerr = -err;\n\t\tgoto destroy;\n\t}\n\n\tvmci_trans(vpending)->detach_sub_id = detach_sub_id;\n\n\t/* Now attach to the queue pair the client created. */\n\thandle = pkt->u.handle;\n\n\t/* vpending->local_addr always has a context id so we do not need to\n\t * worry about VMADDR_CID_ANY in this case.\n\t */\n\tis_local =\n\t    vpending->remote_addr.svm_cid == vpending->local_addr.svm_cid;\n\tflags = VMCI_QPFLAG_ATTACH_ONLY;\n\tflags |= is_local ? VMCI_QPFLAG_LOCAL : 0;\n\n\terr = vmci_transport_queue_pair_alloc(\n\t\t\t\t\t&qpair,\n\t\t\t\t\t&handle,\n\t\t\t\t\tvmci_trans(vpending)->produce_size,\n\t\t\t\t\tvmci_trans(vpending)->consume_size,\n\t\t\t\t\tpkt->dg.src.context,\n\t\t\t\t\tflags,\n\t\t\t\t\tvmci_transport_is_trusted(\n\t\t\t\t\t\tvpending,\n\t\t\t\t\t\tvpending->remote_addr.svm_cid));\n\tif (err < 0) {\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\tskerr = -err;\n\t\tgoto destroy;\n\t}\n\n\tvmci_trans(vpending)->qp_handle = handle;\n\tvmci_trans(vpending)->qpair = qpair;\n\n\t/* When we send the attach message, we must be ready to handle incoming\n\t * control messages on the newly connected socket. So we move the\n\t * pending socket to the connected state before sending the attach\n\t * message. Otherwise, an incoming packet triggered by the attach being\n\t * received by the peer may be processed concurrently with what happens\n\t * below after sending the attach message, and that incoming packet\n\t * will find the listening socket instead of the (currently) pending\n\t * socket. Note that enqueueing the socket increments the reference\n\t * count, so even if a reset comes before the connection is accepted,\n\t * the socket will be valid until it is removed from the queue.\n\t *\n\t * If we fail sending the attach below, we remove the socket from the\n\t * connected list and move the socket to SS_UNCONNECTED before\n\t * releasing the lock, so a pending slow path processing of an incoming\n\t * packet will not see the socket in the connected state in that case.\n\t */\n\tpending->sk_state = SS_CONNECTED;\n\n\tvsock_insert_connected(vpending);\n\n\t/* Notify our peer of our attach. */\n\terr = vmci_transport_send_attach(pending, handle);\n\tif (err < 0) {\n\t\tvsock_remove_connected(vpending);\n\t\tpr_err(\"Could not send attach\\n\");\n\t\tvmci_transport_send_reset(pending, pkt);\n\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\tskerr = -err;\n\t\tgoto destroy;\n\t}\n\n\t/* We have a connection. Move the now connected socket from the\n\t * listener's pending list to the accept queue so callers of accept()\n\t * can find it.\n\t */\n\tvsock_remove_pending(listener, pending);\n\tvsock_enqueue_accept(listener, pending);\n\n\t/* Callers of accept() will be be waiting on the listening socket, not\n\t * the pending socket.\n\t */\n\tlistener->sk_state_change(listener);\n\n\treturn 0;\n\ndestroy:\n\tpending->sk_err = skerr;\n\tpending->sk_state = SS_UNCONNECTED;\n\t/* As long as we drop our reference, all necessary cleanup will handle\n\t * when the cleanup function drops its reference and our destruct\n\t * implementation is called.  Note that since the listen handler will\n\t * remove pending from the pending list upon our failure, the cleanup\n\t * function won't drop the additional reference, which is why we do it\n\t * here.\n\t */\n\tsock_put(pending);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 30408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static QuantizationTable *GetQuantizationTable(const char *filename,\n  const char *slot,ExceptionInfo *exception)\n{\n  char\n    *p,\n    *xml;\n\n  const char\n    *attribute,\n    *content;\n\n  double\n    value;\n\n  register ssize_t\n    i;\n\n  QuantizationTable\n    *table;\n\n  size_t\n    length;\n\n  ssize_t\n    j;\n\n  XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\n\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading quantization tables \\\"%s\\\" ...\",filename);\n  table=(QuantizationTable *) NULL;\n  xml=FileToString(filename,~0UL,exception);\n  if (xml == (char *) NULL)\n    return(table);\n  quantization_tables=NewXMLTree(xml,exception);\n  if (quantization_tables == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  for (table_iterator=GetXMLTreeChild(quantization_tables,\"table\");\n       table_iterator != (XMLTreeInfo *) NULL;\n       table_iterator=GetNextXMLTreeTag(table_iterator))\n  {\n    attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n    attribute=GetXMLTreeAttribute(table_iterator,\"alias\");\n    if ((attribute != (char *) NULL) && (LocaleCompare(slot,attribute) == 0))\n      break;\n  }\n  if (table_iterator == (XMLTreeInfo *) NULL)\n    {\n      xml=DestroyString(xml);\n      return(table);\n    }\n  description=GetXMLTreeChild(table_iterator,\"description\");\n  if (description == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<description>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  levels=GetXMLTreeChild(table_iterator,\"levels\");\n  if (levels == (XMLTreeInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingElement\", \"<levels>, slot \\\"%s\\\"\", slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\n  if (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  table->slot=(char *) NULL;\n  table->description=(char *) NULL;\n  table->levels=(unsigned int *) NULL;\n  attribute=GetXMLTreeAttribute(table_iterator,\"slot\");\n  if (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);\n  content=GetXMLTreeContent(description);\n  if (content != (char *) NULL)\n    table->description=ConstantString(content);\n  attribute=GetXMLTreeAttribute(levels,\"width\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels width>, slot \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->width=StringToUnsignedLong(attribute);\n  if (table->width == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n       \"XmlInvalidAttribute\", \"<levels width>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"height\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->height=StringToUnsignedLong(attribute);\n  if (table->height == 0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels height>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  attribute=GetXMLTreeAttribute(levels,\"divisor\");\n  if (attribute == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingAttribute\", \"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);\n  if (table->divisor == 0.0)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidAttribute\", \"<levels divisor>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  content=GetXMLTreeContent(levels);\n  if (content == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlMissingContent\", \"<levels>, table \\\"%s\\\"\",slot);\n      quantization_tables=DestroyXMLTree(quantization_tables);\n      table=DestroyQuantizationTable(table);\n      xml=DestroyString(xml);\n      return(table);\n    }\n  length=(size_t) table->width*table->height;\n  if (length < 64)\n    length=64;\n  table->levels=(unsigned int *) AcquireQuantumMemory(length,\n    sizeof(*table->levels));\n  if (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");\n  for (i=0; i < (ssize_t) (table->width*table->height); i++)\n  {\n    table->levels[i]=(unsigned int) (InterpretLocaleValue(content,&p)/\n      table->divisor+0.5);\n    while (isspace((int) ((unsigned char) *p)) != 0)\n      p++;\n    if (*p == ',')\n      p++;\n    content=p;\n  }\n  value=InterpretLocaleValue(content,&p);\n  (void) value;\n  if (p != content)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n        \"XmlInvalidContent\", \"<level> too many values, table \\\"%s\\\"\",slot);\n     quantization_tables=DestroyXMLTree(quantization_tables);\n     table=DestroyQuantizationTable(table);\n     xml=DestroyString(xml);\n     return(table);\n   }\n  for (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];\n  quantization_tables=DestroyXMLTree(quantization_tables);\n  xml=DestroyString(xml);\n  return(table);\n}\n",
        "output": "0",
        "index": 71584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImportTIFF_GPSCoordinate ( const TIFF_Manager & tiff, const TIFF_Manager::TagInfo & posInfo,\n\t\t\t\t\t\t   SXMPMeta * xmp, const char * xmpNS, const char * xmpProp )\n{\n\ttry {\t// Don't let errors with one stop the others. Tolerate ill-formed values where reasonable.\n\n\t\tconst bool nativeEndian = tiff.IsNativeEndian();\n\t\t\n\t\tif ( (posInfo.type != kTIFF_RationalType) || (posInfo.count == 0) ) return;\n\n\t\tXMP_Uns16 refID = posInfo.id - 1;\t// ! The GPS refs and coordinates are all tag n and n+1.\n\t\tTIFF_Manager::TagInfo refInfo;\n\t\tbool found = tiff.GetTag ( kTIFF_GPSInfoIFD, refID, &refInfo );\n\t\tif ( (! found) || (refInfo.count == 0) ) return;\n\t\tchar ref = *((char*)refInfo.dataPtr);\n\t\tif ( (ref != 'N') && (ref != 'S') && (ref != 'E') && (ref != 'W') ) return;\n\n\t\tXMP_Uns32 * binPtr = (XMP_Uns32*)posInfo.dataPtr;\n\t\tXMP_Uns32 degNum = 0, degDenom = 1;\t// Defaults for missing parts.\n\t\tXMP_Uns32 minNum = 0, minDenom = 1;\n\t\tXMP_Uns32 secNum = 0, secDenom = 1;\n\t\tif ( ! nativeEndian ) {\n\t\t\tdegDenom = Flip4 ( degDenom );\t// So they can be flipped again below.\n\t\t\tminDenom = Flip4 ( minDenom );\n\t\t\tsecDenom = Flip4 ( secDenom );\n\t\t}\n\t\t\n\t\tdegNum   = GetUns32AsIs ( &binPtr[0] );\n\t\tdegDenom = GetUns32AsIs ( &binPtr[1] );\n\n\t\tif ( posInfo.count >= 2 ) {\n\t\t\tminNum   = GetUns32AsIs ( &binPtr[2] );\n\t\t\tminDenom = GetUns32AsIs ( &binPtr[3] );\n\t\t\tif ( posInfo.count >= 3 ) {\n\t\t\t\tsecNum   = GetUns32AsIs ( &binPtr[4] );\n\t\t\t\tsecDenom = GetUns32AsIs ( &binPtr[5] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif ( ! nativeEndian ) {\n\t\t\tdegNum = Flip4 ( degNum );\n\t\t\tdegDenom = Flip4 ( degDenom );\n\t\t\tminNum = Flip4 ( minNum );\n\t\t\tminDenom = Flip4 ( minDenom );\n\t\t\tsecNum = Flip4 ( secNum );\n\t\t\tsecDenom = Flip4 ( secDenom );\n\t\t}\n\n\n\t\tchar buffer[40];\n\n\t\tif ( (degDenom == 1) && (minDenom == 1) && (secDenom == 1) ) {\n\n\t\t\tsnprintf ( buffer, sizeof(buffer), \"%lu,%lu,%lu%c\", (unsigned long)degNum, (unsigned long)minNum, (unsigned long)secNum, ref );\t// AUDIT: Using sizeof(buffer) is safe.\n\n\t\t} else if ( (degDenom == 0 && degNum != 0) || (minDenom == 0 && minNum != 0) || (secDenom == 0 && secNum != 0) ) { \n\n\t\t\treturn; // Do not continue with import\n\n\t\t} else {\n\n\t\t\tXMP_Uns32 maxDenom = degDenom;\n\t\t\tif ( minDenom > maxDenom ) maxDenom = minDenom;\n\t\t\tif ( secDenom > maxDenom ) maxDenom = secDenom;\n\n\t\t\tint fracDigits = 1;\n\t\t\twhile ( maxDenom > 10 ) { ++fracDigits; maxDenom = maxDenom/10; }\n\n\n\t\t\tdouble degrees, minutes;\n\n\t\t\tif ( degDenom == 0 && degNum == 0 ) {\n\t\t\t\tdegrees = 0;\n\t\t\t} else {\n\t\t\t\tdegrees = (double)( (XMP_Uns32)((double)degNum / (double)degDenom) );\t// Just the integral number of degrees.\n\t\t\t}\n\n\t\t\tif ( minDenom == 0 && minNum == 0 ) {\n\t\t\t\tminutes = 0;\n\t\t\t} else {\n\t\t\t\tdouble temp = 0;\n\t\t\t\tif( degrees != 0 ) temp = ((double)degNum / (double)degDenom) - degrees;\n\n\t\t\t\tminutes = (temp * 60.0) + ((double)minNum / (double)minDenom);\n\t\t\t}\n\n\t\t\tif ( secDenom != 0 && secNum != 0 ) {\n\t\t\t\tminutes += ((double)secNum / (double)secDenom) / 60.0;\n\t\t\t}\n\n\t\t\tsnprintf ( buffer, sizeof(buffer), \"%.0f,%.*f%c\", degrees, fracDigits, minutes, ref );\t// AUDIT: Using sizeof(buffer) is safe.\n\n\t\t}\n\n\t\txmp->SetProperty ( xmpNS, xmpProp, buffer );\n\n\t} catch ( ... ) {\n\t}\n\n}\t// ImportTIFF_GPSCoordinate\n",
        "output": "0",
        "index": 15987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PrintPreviewDataSource::Init() {\n  AddLocalizedString(\"title\", IDS_PRINT_PREVIEW_TITLE);\n  AddLocalizedString(\"loading\", IDS_PRINT_PREVIEW_LOADING);\n  AddLocalizedString(\"noPlugin\", IDS_PRINT_PREVIEW_NO_PLUGIN);\n  AddLocalizedString(\"launchNativeDialog\", IDS_PRINT_PREVIEW_NATIVE_DIALOG);\n  AddLocalizedString(\"previewFailed\", IDS_PRINT_PREVIEW_FAILED);\n  AddLocalizedString(\"invalidPrinterSettings\",\n                     IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS);\n  AddLocalizedString(\"printButton\", IDS_PRINT_PREVIEW_PRINT_BUTTON);\n  AddLocalizedString(\"saveButton\", IDS_PRINT_PREVIEW_SAVE_BUTTON);\n  AddLocalizedString(\"cancelButton\", IDS_PRINT_PREVIEW_CANCEL_BUTTON);\n  AddLocalizedString(\"printing\", IDS_PRINT_PREVIEW_PRINTING);\n  AddLocalizedString(\"printingToPDFInProgress\",\n                     IDS_PRINT_PREVIEW_PRINTING_TO_PDF_IN_PROGRESS);\n#if defined(OS_MACOSX)\n  AddLocalizedString(\"openingPDFInPreview\",\n                     IDS_PRINT_PREVIEW_OPENING_PDF_IN_PREVIEW);\n#endif\n  AddLocalizedString(\"destinationLabel\", IDS_PRINT_PREVIEW_DESTINATION_LABEL);\n  AddLocalizedString(\"copiesLabel\", IDS_PRINT_PREVIEW_COPIES_LABEL);\n  AddLocalizedString(\"examplePageRangeText\",\n                     IDS_PRINT_PREVIEW_EXAMPLE_PAGE_RANGE_TEXT);\n  AddLocalizedString(\"layoutLabel\", IDS_PRINT_PREVIEW_LAYOUT_LABEL);\n  AddLocalizedString(\"optionAllPages\", IDS_PRINT_PREVIEW_OPTION_ALL_PAGES);\n  AddLocalizedString(\"optionBw\", IDS_PRINT_PREVIEW_OPTION_BW);\n  AddLocalizedString(\"optionCollate\", IDS_PRINT_PREVIEW_OPTION_COLLATE);\n  AddLocalizedString(\"optionColor\", IDS_PRINT_PREVIEW_OPTION_COLOR);\n  AddLocalizedString(\"optionLandscape\", IDS_PRINT_PREVIEW_OPTION_LANDSCAPE);\n  AddLocalizedString(\"optionPortrait\", IDS_PRINT_PREVIEW_OPTION_PORTRAIT);\n  AddLocalizedString(\"optionTwoSided\", IDS_PRINT_PREVIEW_OPTION_TWO_SIDED);\n  AddLocalizedString(\"pagesLabel\", IDS_PRINT_PREVIEW_PAGES_LABEL);\n  AddLocalizedString(\"pageRangeTextBox\", IDS_PRINT_PREVIEW_PAGE_RANGE_TEXT);\n  AddLocalizedString(\"pageRangeRadio\", IDS_PRINT_PREVIEW_PAGE_RANGE_RADIO);\n  AddLocalizedString(\"printToPDF\", IDS_PRINT_PREVIEW_PRINT_TO_PDF);\n  AddLocalizedString(\"printPreviewTitleFormat\", IDS_PRINT_PREVIEW_TITLE_FORMAT);\n  AddLocalizedString(\"printPreviewSummaryFormatShort\",\n                     IDS_PRINT_PREVIEW_SUMMARY_FORMAT_SHORT);\n  AddLocalizedString(\"printPreviewSummaryFormatLong\",\n                     IDS_PRINT_PREVIEW_SUMMARY_FORMAT_LONG);\n  AddLocalizedString(\"printPreviewSheetsLabelSingular\",\n                     IDS_PRINT_PREVIEW_SHEETS_LABEL_SINGULAR);\n  AddLocalizedString(\"printPreviewSheetsLabelPlural\",\n                     IDS_PRINT_PREVIEW_SHEETS_LABEL_PLURAL);\n  AddLocalizedString(\"printPreviewPageLabelSingular\",\n                     IDS_PRINT_PREVIEW_PAGE_LABEL_SINGULAR);\n  AddLocalizedString(\"printPreviewPageLabelPlural\",\n                     IDS_PRINT_PREVIEW_PAGE_LABEL_PLURAL);\n  const string16 shortcut_text(UTF8ToUTF16(kAdvancedPrintShortcut));\n#if defined(OS_CHROMEOS)\n  AddString(\"cloudPrintDialogOption\", l10n_util::GetStringFUTF16(\n      IDS_PRINT_PREVIEW_CLOUD_DIALOG_OPTION,\n      l10n_util::GetStringUTF16(IDS_GOOGLE_CLOUD_PRINT),\n      shortcut_text));\n  AddLocalizedString(\"printWithCloudPrint\",\n                     IDS_PRINT_PREVIEW_MORE_PRINTERS);\n#else\n  AddString(\"systemDialogOption\", l10n_util::GetStringFUTF16(\n      IDS_PRINT_PREVIEW_SYSTEM_DIALOG_OPTION,\n      shortcut_text));\n  AddString(\"printWithCloudPrint\", l10n_util::GetStringFUTF16(\n      IDS_PRINT_PREVIEW_PRINT_WITH_CLOUD_PRINT,\n      l10n_util::GetStringUTF16(IDS_GOOGLE_CLOUD_PRINT)));\n#endif\n#if defined(OS_MACOSX)\n  AddLocalizedString(\"openPdfInPreviewOption\",\n                     IDS_PRINT_PREVIEW_OPEN_PDF_IN_PREVIEW_APP);\n#endif\n  AddString(\"printWithCloudPrintWait\", l10n_util::GetStringFUTF16(\n      IDS_PRINT_PREVIEW_PRINT_WITH_CLOUD_PRINT_WAIT,\n      l10n_util::GetStringUTF16(IDS_GOOGLE_CLOUD_PRINT)));\n  AddLocalizedString(\"pageRangeInstruction\",\n                     IDS_PRINT_PREVIEW_PAGE_RANGE_INSTRUCTION);\n  AddLocalizedString(\"copiesInstruction\", IDS_PRINT_PREVIEW_COPIES_INSTRUCTION);\n  AddLocalizedString(\"signIn\", IDS_PRINT_PREVIEW_SIGN_IN);\n  AddLocalizedString(\"managePrinters\", IDS_PRINT_PREVIEW_MANAGE_PRINTERS);\n  AddLocalizedString(\"incrementTitle\", IDS_PRINT_PREVIEW_INCREMENT_TITLE);\n  AddLocalizedString(\"decrementTitle\", IDS_PRINT_PREVIEW_DECREMENT_TITLE);\n  AddLocalizedString(\"printPagesLabel\", IDS_PRINT_PREVIEW_PRINT_PAGES_LABEL);\n   AddLocalizedString(\"optionsLabel\", IDS_PRINT_PREVIEW_OPTIONS_LABEL);\n   AddLocalizedString(\"optionHeaderFooter\",\n                      IDS_PRINT_PREVIEW_OPTION_HEADER_FOOTER);\n   AddLocalizedString(\"marginsLabel\", IDS_PRINT_PREVIEW_MARGINS_LABEL);\n   AddLocalizedString(\"defaultMargins\", IDS_PRINT_PREVIEW_DEFAULT_MARGINS);\n   AddLocalizedString(\"noMargins\", IDS_PRINT_PREVIEW_NO_MARGINS);\n  AddLocalizedString(\"customMargins\", IDS_PRINT_PREVIEW_CUSTOM_MARGINS);\n  AddLocalizedString(\"minimumMargins\", IDS_PRINT_PREVIEW_MINIMUM_MARGINS);\n  AddLocalizedString(\"top\", IDS_PRINT_PREVIEW_TOP_MARGIN_LABEL);\n  AddLocalizedString(\"bottom\", IDS_PRINT_PREVIEW_BOTTOM_MARGIN_LABEL);\n  AddLocalizedString(\"left\", IDS_PRINT_PREVIEW_LEFT_MARGIN_LABEL);\n  AddLocalizedString(\"right\", IDS_PRINT_PREVIEW_RIGHT_MARGIN_LABEL);\n\n  set_json_path(\"strings.js\");\n  add_resource_path(\"print_preview.js\", IDR_PRINT_PREVIEW_JS);\n  set_default_resource(IDR_PRINT_PREVIEW_HTML);\n}\n",
        "output": "1",
        "index": 184498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType WriteMATImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  ssize_t y;\n  unsigned z;\n  const PixelPacket *p;\n\n  unsigned int status;\n  int logging;\n  size_t DataSize;\n  char padding;\n  char MATLAB_HDR[0x80];\n  time_t current_time;\n  struct tm local_time;\n  unsigned char *pixels;\n  int is_gray;\n\n  MagickOffsetType\n    scene;\n\n  QuantumInfo\n    *quantum_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"enter MAT\");\n  (void) logging;\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  image->depth=8;\n\n  current_time=time((time_t *) NULL);\n#if defined(MAGICKCORE_HAVE_LOCALTIME_R)\n  (void) localtime_r(&current_time,&local_time);\n#else\n  (void) memcpy(&local_time,localtime(&current_time),sizeof(local_time));\n#endif\n  (void) memset(MATLAB_HDR,' ',MagickMin(sizeof(MATLAB_HDR),124));\n  FormatLocaleString(MATLAB_HDR,sizeof(MATLAB_HDR),\n    \"MATLAB 5.0 MAT-file, Platform: %s, Created on: %s %s %2d %2d:%2d:%2d %d\",\n    OsDesc,DayOfWTab[local_time.tm_wday],MonthsTab[local_time.tm_mon],\n    local_time.tm_mday,local_time.tm_hour,local_time.tm_min,\n    local_time.tm_sec,local_time.tm_year+1900);\n  MATLAB_HDR[0x7C]=0;\n  MATLAB_HDR[0x7D]=1;\n  MATLAB_HDR[0x7E]='I';\n  MATLAB_HDR[0x7F]='M';\n  (void) WriteBlob(image,sizeof(MATLAB_HDR),(unsigned char *) MATLAB_HDR);\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    is_gray = SetImageGray(image,&image->exception);\n    z = is_gray ? 0 : 3;\n\n    /*\n      Store MAT header.\n    */\n    DataSize = image->rows /*Y*/ * image->columns /*X*/;\n    if(!is_gray) DataSize *= 3 /*Z*/;\n    padding=((unsigned char)(DataSize-1) & 0x7) ^ 0x7;\n\n    (void) WriteBlobLSBLong(image, miMATRIX);\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize+padding+(is_gray ? 48 : 56));\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x88 */\n    (void) WriteBlobLSBLong(image, 0x8); /* 0x8C */\n    (void) WriteBlobLSBLong(image, 0x6); /* 0x90 */\n    (void) WriteBlobLSBLong(image, 0);\n    (void) WriteBlobLSBLong(image, 0x5); /* 0x98 */\n    (void) WriteBlobLSBLong(image, is_gray ? 0x8 : 0xC); /* 0x9C - DimFlag */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->rows);    /* x: 0xA0 */\n    (void) WriteBlobLSBLong(image, (unsigned int) image->columns); /* y: 0xA4 */\n    if(!is_gray)\n    {\n      (void) WriteBlobLSBLong(image, 3); /* z: 0xA8 */\n      (void) WriteBlobLSBLong(image, 0);\n    }\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB0 */\n    (void) WriteBlobLSBShort(image, 1);  /* 0xB2 */\n    (void) WriteBlobLSBLong(image, 'M'); /* 0xB4 */\n    (void) WriteBlobLSBLong(image, 0x2); /* 0xB8 */\n    (void) WriteBlobLSBLong(image, (unsigned int) DataSize); /* 0xBC */\n\n    /*\n      Store image data.\n    */\n    exception=(&image->exception);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=GetQuantumPixels(quantum_info);\n    do\n    {\n      for (y=0; y < (ssize_t)image->columns; y++)\n      {\n        p=GetVirtualPixels(image,y,0,1,image->rows,&image->exception);\n        if (p == (const PixelPacket *) NULL)\n          break;\n        (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n          z2qtype[z],pixels,exception);\n        (void) WriteBlob(image,image->rows,pixels);\n      }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n    } while(z-- >= 2);\n    while(padding-->0) (void) WriteBlobByte(image,0);\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "output": "0",
        "index": 62099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CSoundFile::TonePortamento(ModChannel *pChn, uint32 param) const\n{\n\tpChn->dwFlags.set(CHN_PORTAMENTO);\n\n\tif((!m_SongFlags[SONG_ITCOMPATGXX] && m_playBehaviour[kITPortaMemoryShare]) || GetType() == MOD_TYPE_PLM)\n\t{\n\t\tif(param == 0) param = pChn->nOldPortaUp;\n\t\tpChn->nOldPortaUp = pChn->nOldPortaDown = static_cast<uint8>(param);\n\t}\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\tconst int32 old_PortamentoTickSlide = (m_PlayState.m_nTickCount != 0) ? pChn->m_PortamentoTickSlide : 0;\n\n\t\tif(param)\n\t\t\tpChn->nPortamentoSlide = param;\n\t\telse\n\t\t\tif(pChn->nPortamentoSlide == 0)\n\t\t\t\treturn;\n\n\n\t\tif((pChn->nPortamentoDest > 0 && pChn->nPortamentoSlide < 0) ||\n\t\t\t(pChn->nPortamentoDest < 0 && pChn->nPortamentoSlide > 0))\n\t\t\tpChn->nPortamentoSlide = -pChn->nPortamentoSlide;\n\n\t\tpChn->m_PortamentoTickSlide = static_cast<int32>((m_PlayState.m_nTickCount + 1.0) * pChn->nPortamentoSlide / m_PlayState.m_nMusicSpeed);\n\n\t\tif(pChn->dwFlags[CHN_GLISSANDO])\n\t\t{\n\t\t\tpChn->m_PortamentoTickSlide *= pChn->pModInstrument->pTuning->GetFineStepCount() + 1;\n\t\t}\n\n\t\tconst int32 slide = pChn->m_PortamentoTickSlide - old_PortamentoTickSlide;\n\n\t\tif(mpt::abs(pChn->nPortamentoDest) <= mpt::abs(slide))\n\t\t{\n\t\t\tif(pChn->nPortamentoDest != 0)\n\t\t\t{\n\t\t\t\tpChn->m_PortamentoFineSteps += pChn->nPortamentoDest;\n\t\t\t\tpChn->nPortamentoDest = 0;\n\t\t\t\tpChn->m_CalculateFreq = true;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->m_PortamentoFineSteps += slide;\n\t\t\tpChn->nPortamentoDest -= slide;\n\t\t\tpChn->m_CalculateFreq = true;\n\t\t}\n\n\t\treturn;\n\t} //End candidate MPT behavior.\n\n\tbool doPorta = !pChn->isFirstTick || (GetType() & (MOD_TYPE_DBM | MOD_TYPE_669)) || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]);\n\tif(GetType() == MOD_TYPE_PLM && param >= 0xF0)\n\t{\n\t\tparam -= 0xF0;\n\t\tdoPorta = pChn->isFirstTick;\n\t}\n\n\tif(param)\n\t{\n\t\tif(GetType() == MOD_TYPE_669)\n\t\t{\n\t\t\tparam *= 10;\n\t\t}\n\t\tpChn->nPortamentoSlide = param * 4;\n\t}\n\n\tif(pChn->nPeriod && pChn->nPortamentoDest && doPorta)\n\t{\n\t\tif (pChn->nPeriod < pChn->nPortamentoDest)\n\t\t{\n\t\t\tint32 delta = pChn->nPortamentoSlide;\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tuint32 n = pChn->nPortamentoSlide / 4;\n\t\t\t\tif (n > 255) n = 255;\n\t\t\t\tdelta = Util::muldivr(pChn->nPeriod, LinearSlideUpTable[n], 65536) - pChn->nPeriod;\n\t\t\t\tif (delta < 1) delta = 1;\n\t\t\t}\n\t\t\tpChn->nPeriod += delta;\n\t\t\tif (pChn->nPeriod > pChn->nPortamentoDest) pChn->nPeriod = pChn->nPortamentoDest;\n\t\t} else\n\t\tif (pChn->nPeriod > pChn->nPortamentoDest)\n\t\t{\n\t\t\tint32 delta = -pChn->nPortamentoSlide;\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tuint32 n = pChn->nPortamentoSlide / 4;\n\t\t\t\tif (n > 255) n = 255;\n\t\t\t\tdelta = Util::muldivr(pChn->nPeriod, LinearSlideDownTable[n], 65536) - pChn->nPeriod;\n\t\t\t\tif (delta > -1) delta = -1;\n\t\t\t}\n\t\t\tpChn->nPeriod += delta;\n\t\t\tif (pChn->nPeriod < pChn->nPortamentoDest) pChn->nPeriod = pChn->nPortamentoDest;\n\t\t}\n\t}\n\n\tif(pChn->nPeriod == pChn->nPortamentoDest && (m_playBehaviour[kITPortaTargetReached] || GetType() == MOD_TYPE_MOD))\n\t\tpChn->nPortamentoDest = 0;\n\n}\n",
        "output": "0",
        "index": 83340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static jpc_enc_rlvl_t *rlvl_create(jpc_enc_rlvl_t *rlvl, jpc_enc_cp_t *cp,\n  jpc_enc_tcmpt_t *tcmpt, jpc_tsfb_band_t *bandinfos)\n{\n\tuint_fast16_t rlvlno;\n\tuint_fast32_t tlprctlx;\n\tuint_fast32_t tlprctly;\n\tuint_fast32_t brprcbrx;\n\tuint_fast32_t brprcbry;\n\tuint_fast16_t bandno;\n\tjpc_enc_band_t *band;\n\n\t/* Deduce the resolution level. */\n\trlvlno = rlvl - tcmpt->rlvls;\n\n\t/* Initialize members required for error recovery. */\n\trlvl->bands = 0;\n\trlvl->tcmpt = tcmpt;\n\n\t/* Compute the coordinates of the top-left and bottom-right\n\t  corners of the tile-component at this resolution. */\n\trlvl->tlx = JPC_CEILDIVPOW2(jas_seq2d_xstart(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->tly = JPC_CEILDIVPOW2(jas_seq2d_ystart(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->brx = JPC_CEILDIVPOW2(jas_seq2d_xend(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\trlvl->bry = JPC_CEILDIVPOW2(jas_seq2d_yend(tcmpt->data), tcmpt->numrlvls -\n\t  1 - rlvlno);\n\n\tif (rlvl->tlx >= rlvl->brx || rlvl->tly >= rlvl->bry) {\n\t\trlvl->numhprcs = 0;\n\t\trlvl->numvprcs = 0;\n\t\trlvl->numprcs = 0;\n\t\treturn rlvl;\n\t}\n\n\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\trlvl->prcwidthexpn = cp->tccp.prcwidthexpns[rlvlno];\n\trlvl->prcheightexpn = cp->tccp.prcheightexpns[rlvlno];\n\tif (!rlvlno) {\n\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t} else {\n\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t}\n\trlvl->cblkwidthexpn = JAS_MIN(cp->tccp.cblkwidthexpn, rlvl->cbgwidthexpn);\n\trlvl->cblkheightexpn = JAS_MIN(cp->tccp.cblkheightexpn, rlvl->cbgheightexpn);\n\n\t/* Compute the number of precincts. */\n\ttlprctlx = JPC_FLOORTOMULTPOW2(rlvl->tlx, rlvl->prcwidthexpn);\n\ttlprctly = JPC_FLOORTOMULTPOW2(rlvl->tly, rlvl->prcheightexpn);\n\tbrprcbrx = JPC_CEILTOMULTPOW2(rlvl->brx, rlvl->prcwidthexpn);\n\tbrprcbry = JPC_CEILTOMULTPOW2(rlvl->bry, rlvl->prcheightexpn);\n\trlvl->numhprcs = JPC_FLOORDIVPOW2(brprcbrx - tlprctlx, rlvl->prcwidthexpn);\n\trlvl->numvprcs = JPC_FLOORDIVPOW2(brprcbry - tlprctly, rlvl->prcheightexpn);\n\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands, sizeof(jpc_enc_band_t)))) {\n\t\tgoto error;\n\t}\n\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t  ++bandno, ++band) {\n\t\tband->prcs = 0;\n\t\tband->data = 0;\n\t\tband->rlvl = rlvl;\n\t}\n\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t  ++bandno, ++band) {\n\t\tif (!band_create(band, cp, rlvl, bandinfos)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn rlvl;\nerror:\n\n\trlvl_destroy(rlvl);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 72930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *magick_restrict clone_info,CacheInfo *magick_restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination) \\\n  num_threads(((source)->type == DiskCache) || \\\n    ((destination)->type == DiskCache) || (((source)->rows) < \\\n    (16*GetMagickResourceLimit(ThreadResource))) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    optimize,\n    status;\n\n  NexusInfo\n    **magick_restrict cache_nexus,\n    **magick_restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  length=cache_info->number_channels*sizeof(*cache_info->channel_map);\n  if ((cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->number_channels == clone_info->number_channels) &&\n      (memcmp(cache_info->channel_map,clone_info->channel_map,length) == 0) &&\n      (cache_info->metacontent_extent == clone_info->metacontent_extent))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      if (((cache_info->type == MemoryCache) ||\n           (cache_info->type == MapCache)) &&\n          ((clone_info->type == MemoryCache) ||\n           (clone_info->type == MapCache)))\n        {\n          (void) memcpy(clone_info->pixels,cache_info->pixels,\n            cache_info->columns*cache_info->number_channels*cache_info->rows*\n            sizeof(*cache_info->pixels));\n          if ((cache_info->metacontent_extent != 0) &&\n              (clone_info->metacontent_extent != 0))\n            (void) memcpy(clone_info->metacontent,cache_info->metacontent,\n              cache_info->columns*cache_info->rows*\n              clone_info->metacontent_extent*sizeof(unsigned char));\n          return(MagickTrue);\n        }\n      if ((cache_info->type == DiskCache) && (clone_info->type == DiskCache))\n        return(ClonePixelCacheOnDisk(cache_info,clone_info));\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=cache_info->number_channels*sizeof(*cache_info->channel_map);\n  optimize=(cache_info->number_channels == clone_info->number_channels) &&\n    (memcmp(cache_info->channel_map,clone_info->channel_map,length) == 0) ?\n    MagickTrue : MagickFalse;\n  length=(size_t) MagickMin(cache_info->columns*cache_info->number_channels,\n    clone_info->columns*clone_info->number_channels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    Quantum\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    if (y >= (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n      cache_nexus[id],exception);\n    if (pixels == (Quantum *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,\n      clone_nexus[id],exception);\n    if (pixels == (Quantum *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    if (optimize != MagickFalse)\n      (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length*\n        sizeof(Quantum));\n    else\n      {\n        register const Quantum\n          *magick_restrict p;\n\n        register Quantum\n          *magick_restrict q;\n\n        /*\n          Mismatched pixel channel map.\n        */\n        p=cache_nexus[id]->pixels;\n        q=clone_nexus[id]->pixels;\n        for (x=0; x < (ssize_t) cache_info->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (x == (ssize_t) clone_info->columns)\n            break;\n          for (i=0; i < (ssize_t) clone_info->number_channels; i++)\n          {\n            PixelChannel\n              channel;\n\n            PixelTrait\n              traits;\n\n            channel=clone_info->channel_map[i].channel;\n            traits=cache_info->channel_map[channel].traits;\n            if (traits != UndefinedPixelTrait)\n              *q=*(p+cache_info->channel_map[channel].offset);\n            q++;\n          }\n          p+=cache_info->number_channels;\n        }\n      }\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->metacontent_extent != 0) &&\n      (clone_info->metacontent_extent != 0))\n    {\n      /*\n        Clone metacontent.\n      */\n      length=(size_t) MagickMin(cache_info->metacontent_extent,\n        clone_info->metacontent_extent);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        Quantum\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y >= (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n          cache_nexus[id],exception);\n        if (pixels == (Quantum *) NULL)\n          continue;\n        status=ReadPixelCacheMetacontent(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,\n          clone_nexus[id],exception);\n        if (pixels == (Quantum *) NULL)\n          continue;\n        if ((clone_nexus[id]->metacontent != (void *) NULL) &&\n            (cache_nexus[id]->metacontent != (void *) NULL))\n          (void) memcpy(clone_nexus[id]->metacontent,\n            cache_nexus[id]->metacontent,length*sizeof(unsigned char));\n        status=WritePixelCacheMetacontent(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MagickPathExtent];\n\n      (void) FormatLocaleString(message,MagickPathExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}\n",
        "output": "0",
        "index": 94767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_jpeg2000_init_component(Jpeg2000Component *comp,\n                               Jpeg2000CodingStyle *codsty,\n                               Jpeg2000QuantStyle *qntsty,\n                               int cbps, int dx, int dy,\n                               AVCodecContext *avctx)\n{\n    uint8_t log2_band_prec_width, log2_band_prec_height;\n    int reslevelno, bandno, gbandno = 0, ret, i, j;\n    uint32_t csize;\n\n    if (codsty->nreslevels2decode <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"nreslevels2decode %d invalid or uninitialized\\n\", codsty->nreslevels2decode);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,\n                                   codsty->nreslevels2decode - 1,\n                                   codsty->transform))\n        return ret;\n    csize = (comp->coord[0][1] - comp->coord[0][0]) *\n            (comp->coord[1][1] - comp->coord[1][0]);\n\n    if (codsty->transform == FF_DWT97) {\n        comp->i_data = NULL;\n        comp->f_data = av_malloc_array(csize, sizeof(*comp->f_data));\n        if (!comp->f_data)\n            return AVERROR(ENOMEM);\n    } else {\n        comp->f_data = NULL;\n        comp->i_data = av_malloc_array(csize, sizeof(*comp->i_data));\n        if (!comp->i_data)\n            return AVERROR(ENOMEM);\n    }\n    comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));\n    if (!comp->reslevel)\n        return AVERROR(ENOMEM);\n    /* LOOP on resolution levels */\n    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n        int declvl = codsty->nreslevels - reslevelno;    // N_L -r see  ISO/IEC 15444-1:2002 B.5\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        /* Compute borders for each resolution level.\n         * Computation of trx_0, trx_1, try_0 and try_1.\n         * see ISO/IEC 15444-1:2002 eq. B.5 and B-14 */\n        for (i = 0; i < 2; i++)\n            for (j = 0; j < 2; j++)\n                reslevel->coord[i][j] =\n                    ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);\n        reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];\n        reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];\n\n        /* Number of bands for each resolution level */\n        if (reslevelno == 0)\n            reslevel->nbands = 1;\n        else\n            reslevel->nbands = 3;\n\n        /* Number of precincts wich span the tile for resolution level reslevelno\n         * see B.6 in ISO/IEC 15444-1:2002 eq. B-16\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -| - (trx_0 / 2 ^ log2_prec_width)\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| - (try_0 / 2 ^ log2_prec_width)\n         * for Dcinema profiles in JPEG 2000\n         * num_precincts_x = |- trx_1 / 2 ^ log2_prec_width) -|\n         * num_precincts_y = |- try_1 / 2 ^ log2_prec_width) -| */\n        if (reslevel->coord[0][1] == reslevel->coord[0][0])\n            reslevel->num_precincts_x = 0;\n        else\n            reslevel->num_precincts_x =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],\n                                        reslevel->log2_prec_width) -\n                (reslevel->coord[0][0] >> reslevel->log2_prec_width);\n\n        if (reslevel->coord[1][1] == reslevel->coord[1][0])\n            reslevel->num_precincts_y = 0;\n        else\n            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                         reslevel->log2_prec_height) -\n                 (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n \n        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));\n         if (!reslevel->band)\n             return AVERROR(ENOMEM);\n \n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            int cblkno, precno;\n            int nb_precincts;\n\n            /* TODO: Implementation of quantization step not finished,\n             * see ISO/IEC 15444-1:2002 E.1 and A.6.4. */\n            switch (qntsty->quantsty) {\n                uint8_t gain;\n                int numbps;\n            case JPEG2000_QSTY_NONE:\n                /* TODO: to verify. No quantization in this case */\n                band->f_stepsize = 1;\n                break;\n            case JPEG2000_QSTY_SI:\n                /*TODO: Compute formula to implement. */\n                numbps = cbps +\n                         lut_gain[codsty->transform == FF_DWT53][bandno + (reslevelno > 0)];\n                band->f_stepsize = SHL(2048 + qntsty->mant[gbandno],\n                                       2 + numbps - qntsty->expn[gbandno]);\n                break;\n            case JPEG2000_QSTY_SE:\n                /* Exponent quantization step.\n                 * Formula:\n                 * delta_b = 2 ^ (R_b - expn_b) * (1 + (mant_b / 2 ^ 11))\n                 * R_b = R_I + log2 (gain_b )\n                 * see ISO/IEC 15444-1:2002 E.1.1 eqn. E-3 and E-4 */\n                /* TODO/WARN: value of log2 (gain_b ) not taken into account\n                 * but it works (compared to OpenJPEG). Why?\n                 * Further investigation needed. */\n                gain            = cbps;\n                band->f_stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);\n                band->f_stepsize *= qntsty->mant[gbandno] / 2048.0 + 1.0;\n                break;\n            default:\n                band->f_stepsize = 0;\n                av_log(avctx, AV_LOG_ERROR, \"Unknown quantization format\\n\");\n                break;\n            }\n            /* FIXME: In openjepg code stespize = stepsize * 0.5. Why?\n             * If not set output of entropic decoder is not correct. */\n            if (!av_codec_is_encoder(avctx->codec))\n                band->f_stepsize *= 0.5;\n\n            band->i_stepsize = band->f_stepsize * (1 << 15);\n\n            /* computation of tbx_0, tbx_1, tby_0, tby_1\n             * see ISO/IEC 15444-1:2002 B.5 eq. B-15 and tbl B.1\n             * codeblock width and height is computed for\n             * DCI JPEG 2000 codeblock_width = codeblock_width = 32 = 2 ^ 5 */\n            if (reslevelno == 0) {\n                /* for reslevelno = 0, only one band, x0_b = y0_b = 0 */\n                for (i = 0; i < 2; i++)\n                    for (j = 0; j < 2; j++)\n                        band->coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0],\n                                                    declvl - 1);\n                log2_band_prec_width  = reslevel->log2_prec_width;\n                log2_band_prec_height = reslevel->log2_prec_height;\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,\n                                               reslevel->log2_prec_width);\n                band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,\n                                               reslevel->log2_prec_height);\n            } else {\n                /* 3 bands x0_b = 1 y0_b = 0; x0_b = 0 y0_b = 1; x0_b = y0_b = 1 */\n                /* x0_b and y0_b are computed with ((bandno + 1 >> i) & 1) */\n                for (i = 0; i < 2; i++)\n                    for (j = 0; j < 2; j++)\n                        /* Formula example for tbx_0 = ceildiv((tcx_0 - 2 ^ (declvl - 1) * x0_b) / declvl) */\n                        band->coord[i][j] =\n                            ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0] -\n                                                    (((bandno + 1 >> i) & 1) << declvl - 1),\n                                                    declvl);\n                /* TODO: Manage case of 3 band offsets here or\n                 * in coding/decoding function? */\n\n                /* see ISO/IEC 15444-1:2002 eq. B-17 and eq. B-15 */\n                band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,\n                                               reslevel->log2_prec_width - 1);\n                band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,\n                                               reslevel->log2_prec_height - 1);\n\n                log2_band_prec_width  = reslevel->log2_prec_width  - 1;\n                log2_band_prec_height = reslevel->log2_prec_height - 1;\n            }\n\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n             for (j = 0; j < 2; j++)\n                 band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n \n            band->prec = av_malloc_array(reslevel->num_precincts_x *\n                                          (uint64_t)reslevel->num_precincts_y,\n                                          sizeof(*band->prec));\n             if (!band->prec)\n                return AVERROR(ENOMEM);\n\n            nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;\n\n            for (precno = 0; precno < nb_precincts; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n\n                /* TODO: Explain formula for JPEG200 DCINEMA. */\n                /* TODO: Verify with previous count of codeblocks per band */\n\n                /* Compute P_x0 */\n                prec->coord[0][0] = (precno % reslevel->num_precincts_x) *\n                                    (1 << log2_band_prec_width);\n                prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);\n\n                /* Compute P_y0 */\n                prec->coord[1][0] = (precno / reslevel->num_precincts_x) *\n                                    (1 << log2_band_prec_height);\n                prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);\n\n                /* Compute P_x1 */\n                prec->coord[0][1] = prec->coord[0][0] +\n                                    (1 << log2_band_prec_width);\n                prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);\n\n                /* Compute P_y1 */\n                prec->coord[1][1] = prec->coord[1][0] +\n                                    (1 << log2_band_prec_height);\n                prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);\n\n                prec->nb_codeblocks_width =\n                    ff_jpeg2000_ceildivpow2(prec->coord[0][1] -\n                                            prec->coord[0][0],\n                                            band->log2_cblk_width);\n                prec->nb_codeblocks_height =\n                    ff_jpeg2000_ceildivpow2(prec->coord[1][1] -\n                                            prec->coord[1][0],\n                                            band->log2_cblk_height);\n\n                /* Tag trees initialization */\n                prec->cblkincl =\n                    ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,\n                                              prec->nb_codeblocks_height);\n                if (!prec->cblkincl)\n                    return AVERROR(ENOMEM);\n\n                prec->zerobits =\n                    ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,\n                                              prec->nb_codeblocks_height);\n                if (!prec->zerobits)\n                    return AVERROR(ENOMEM);\n\n                prec->cblk = av_mallocz_array(prec->nb_codeblocks_width *\n                                              (uint64_t)prec->nb_codeblocks_height,\n                                              sizeof(*prec->cblk));\n                if (!prec->cblk)\n                    return AVERROR(ENOMEM);\n                for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n                    Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n                    uint16_t Cx0, Cy0;\n\n                    /* Compute coordinates of codeblocks */\n                    /* Compute Cx0*/\n                    Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;\n                    Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);\n                    cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);\n\n                    /* Compute Cy0*/\n                    Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;\n                    Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);\n                    cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);\n\n                    /* Compute Cx1 */\n                    cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),\n                                              prec->coord[0][1]);\n\n                    /* Compute Cy1 */\n                    cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),\n                                              prec->coord[1][1]);\n                    /* Update code-blocks coordinates according sub-band position */\n                    if ((bandno + !!reslevelno) & 1) {\n                        cblk->coord[0][0] += comp->reslevel[reslevelno-1].coord[0][1] -\n                                             comp->reslevel[reslevelno-1].coord[0][0];\n                        cblk->coord[0][1] += comp->reslevel[reslevelno-1].coord[0][1] -\n                                             comp->reslevel[reslevelno-1].coord[0][0];\n                    }\n                    if ((bandno + !!reslevelno) & 2) {\n                        cblk->coord[1][0] += comp->reslevel[reslevelno-1].coord[1][1] -\n                                             comp->reslevel[reslevelno-1].coord[1][0];\n                        cblk->coord[1][1] += comp->reslevel[reslevelno-1].coord[1][1] -\n                                             comp->reslevel[reslevelno-1].coord[1][0];\n                    }\n\n                    cblk->zero      = 0;\n                    cblk->lblock    = 3;\n                    cblk->length    = 0;\n                    cblk->lengthinc = 0;\n                    cblk->npasses   = 0;\n                }\n            }\n        }\n    }\n    return 0;\n}\n",
        "output": "1",
        "index": 179094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col)\n{\n\t/* keep them as 32bits */\n\tlong x, y, inc, frac;\n\tlong dx, dy,tmp;\n\tint w, wid, wstart; \n\tint thick = im->thick; \n\n\tif (!im->trueColor) {\n\t\t/* TBB: don't crash when the image is of the wrong type */\n\t\tgdImageLine(im, x1, y1, x2, y2, col);\n\t\treturn;\n\t}\n\n\t/* TBB: use the clipping rectangle */\n\tif (clip_1d (&x1, &y1, &x2, &y2, im->cx1, im->cx2) == 0)\n\t\treturn;\n\tif (clip_1d (&y1, &x1, &y2, &x2, im->cy1, im->cy2) == 0)\n\t\treturn;\n\n\tdx = x2 - x1;\n\tdy = y2 - y1;\n\n\tif (dx == 0 && dy == 0) {\n\t\t/* TBB: allow setting points */\n\t\tgdImageSetAAPixelColor(im, x1, y1, col, 0xFF);\n\t\treturn;\n\t} else {\n\t\tdouble ag;\n\t\t/* Cast the long to an int to avoid compiler warnings about truncation.\n\t\t * This isn't a problem as computed dy/dx values came from ints above. */\n\t\tag = fabs(abs((int)dy) < abs((int)dx) ? cos(atan2(dy, dx)) : sin(atan2(dy, dx)));\n\t\tif (ag != 0) {\n\t\t\twid = thick / ag;\n\t\t} else {\n\t\t\twid = 1;\n\t\t}\n\t\tif (wid == 0) {\n\t\t\twid = 1;\n\t\t}\n\t}\n\n\t/* Axis aligned lines */\n\tif (dx == 0) {\n\t\tgdImageVLine(im, x1, y1, y2, col);\n\t\treturn;\n\t} else if (dy == 0) {\n\t\tgdImageHLine(im, y1, x1, x2, col);\n\t\treturn;\n\t}\n\n\tif (abs((int)dx) > abs((int)dy)) {\n\t\tif (dx < 0) {\n\t\t\ttmp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = tmp;\n\t\t\ttmp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = tmp;\n\t\t\tdx = x2 - x1;\n\t\t\tdy = y2 - y1;\n\t\t}\n\t\ty = y1;\n\t\tinc = (dy * 65536) / dx;\n\t\tfrac = 0;\n\t\t/* TBB: set the last pixel for consistency (<=) */\n\t\tfor (x = x1 ; x <= x2 ; x++) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t    gdImageSetAAPixelColor(im, x , w , col , (frac >> 8) & 0xFF);\n\t\t\t    gdImageSetAAPixelColor(im, x , w + 1 , col, (~frac >> 8) & 0xFF);\n\t\t\t}\n\t\t\tfrac += inc;\n\t\t\tif (frac >= 65536) {\n\t\t\t\tfrac -= 65536;\n\t\t\t\ty++;\n\t\t\t} else if (frac < 0) {\n\t\t\t\tfrac += 65536;\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (dy < 0) {\n\t\t\ttmp = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = tmp;\n\t\t\ttmp = y1;\n\t\t\ty1 = y2;\n\t\t\ty2 = tmp;\n\t\t\tdx = x2 - x1;\n\t\t\tdy = y2 - y1;\n\t\t}\n\t\tx = x1;\n\t\tinc = (dx * 65536) / dy;\n\t\tfrac = 0;\n\t\t/* TBB: set the last pixel for consistency (<=) */\n\t\tfor (y = y1 ; y <= y2 ; y++) {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++) {\n\t\t\t    gdImageSetAAPixelColor(im, w , y  , col, (frac >> 8) & 0xFF);\n\t\t\t    gdImageSetAAPixelColor(im, w + 1, y, col, (~frac >> 8) & 0xFF);\n\t\t\t}\n\t\t\tfrac += inc;\n\t\t\tif (frac >= 65536) {\n\t\t\t\tfrac -= 65536;\n\t\t\t\tx++;\n\t\t\t} else if (frac < 0) {\n\t\t\t\tfrac += 65536;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "output": "0",
        "index": 96150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlBuildURI(const xmlChar *URI, const xmlChar *base) {\n    xmlChar *val = NULL;\n int ret, len, indx, cur, out;\n    xmlURIPtr ref = NULL;\n    xmlURIPtr bas = NULL;\n    xmlURIPtr res = NULL;\n\n /*\n     * 1) The URI reference is parsed into the potential four components and\n     *    fragment identifier, as described in Section 4.3.\n     *\n     *    NOTE that a completely empty URI is treated by modern browsers\n     *    as a reference to \".\" rather than as a synonym for the current\n     *    URI.  Should we do that here?\n     */\n if (URI == NULL)\n\tret = -1;\n else {\n if (*URI) {\n\t    ref = xmlCreateURI();\n if (ref == NULL)\n goto done;\n\t    ret = xmlParseURIReference(ref, (const char *) URI);\n }\n else\n\t    ret = 0;\n }\n if (ret != 0)\n goto done;\n if ((ref != NULL) && (ref->scheme != NULL)) {\n /*\n\t * The URI is absolute don't modify.\n\t */\n\tval = xmlStrdup(URI);\n goto done;\n }\n if (base == NULL)\n\tret = -1;\n else {\n\tbas = xmlCreateURI();\n if (bas == NULL)\n goto done;\n\tret = xmlParseURIReference(bas, (const char *) base);\n }\n if (ret != 0) {\n if (ref)\n\t    val = xmlSaveUri(ref);\n goto done;\n }\n if (ref == NULL) {\n /*\n\t * the base fragment must be ignored\n\t */\n if (bas->fragment != NULL) {\n\t    xmlFree(bas->fragment);\n\t    bas->fragment = NULL;\n }\n\tval = xmlSaveUri(bas);\n goto done;\n }\n\n /*\n     * 2) If the path component is empty and the scheme, authority, and\n     *    query components are undefined, then it is a reference to the\n     *    current document and we are done.  Otherwise, the reference URI's\n     *    query and fragment components are defined as found (or not found)\n     *    within the URI reference and not inherited from the base URI.\n     *\n     *    NOTE that in modern browsers, the parsing differs from the above\n     *    in the following aspect:  the query component is allowed to be\n     *    defined while still treating this as a reference to the current\n     *    document.\n     */\n    res = xmlCreateURI();\n if (res == NULL)\n goto done;\n if ((ref->scheme == NULL) && (ref->path == NULL) &&\n ((ref->authority == NULL) && (ref->server == NULL))) {\n if (bas->scheme != NULL)\n\t    res->scheme = xmlMemStrdup(bas->scheme);\n if (bas->authority != NULL)\n\t    res->authority = xmlMemStrdup(bas->authority);\n else if (bas->server != NULL) {\n\t    res->server = xmlMemStrdup(bas->server);\n if (bas->user != NULL)\n\t\tres->user = xmlMemStrdup(bas->user);\n\t    res->port = bas->port;\n }\n if (bas->path != NULL)\n\t    res->path = xmlMemStrdup(bas->path);\n if (ref->query_raw != NULL)\n\t    res->query_raw = xmlMemStrdup (ref->query_raw);\n else if (ref->query != NULL)\n\t    res->query = xmlMemStrdup(ref->query);\n else if (bas->query_raw != NULL)\n\t    res->query_raw = xmlMemStrdup(bas->query_raw);\n else if (bas->query != NULL)\n\t    res->query = xmlMemStrdup(bas->query);\n if (ref->fragment != NULL)\n\t    res->fragment = xmlMemStrdup(ref->fragment);\n goto step_7;\n }\n\n /*\n     * 3) If the scheme component is defined, indicating that the reference\n     *    starts with a scheme name, then the reference is interpreted as an\n     *    absolute URI and we are done.  Otherwise, the reference URI's\n     *    scheme is inherited from the base URI's scheme component.\n     */\n if (ref->scheme != NULL) {\n\tval = xmlSaveUri(ref);\n goto done;\n }\n if (bas->scheme != NULL)\n\tres->scheme = xmlMemStrdup(bas->scheme);\n\n if (ref->query_raw != NULL)\n\tres->query_raw = xmlMemStrdup(ref->query_raw);\n else if (ref->query != NULL)\n\tres->query = xmlMemStrdup(ref->query);\n if (ref->fragment != NULL)\n\tres->fragment = xmlMemStrdup(ref->fragment);\n\n /*\n     * 4) If the authority component is defined, then the reference is a\n     *    network-path and we skip to step 7.  Otherwise, the reference\n     *    URI's authority is inherited from the base URI's authority\n     *    component, which will also be undefined if the URI scheme does not\n     *    use an authority component.\n     */\n if ((ref->authority != NULL) || (ref->server != NULL)) {\n if (ref->authority != NULL)\n\t    res->authority = xmlMemStrdup(ref->authority);\n else {\n\t    res->server = xmlMemStrdup(ref->server);\n if (ref->user != NULL)\n\t\tres->user = xmlMemStrdup(ref->user);\n            res->port = ref->port;\n }\n if (ref->path != NULL)\n\t    res->path = xmlMemStrdup(ref->path);\n goto step_7;\n }\n if (bas->authority != NULL)\n\tres->authority = xmlMemStrdup(bas->authority);\n else if (bas->server != NULL) {\n\tres->server = xmlMemStrdup(bas->server);\n if (bas->user != NULL)\n\t    res->user = xmlMemStrdup(bas->user);\n\tres->port = bas->port;\n }\n\n /*\n     * 5) If the path component begins with a slash character (\"/\"), then\n     *    the reference is an absolute-path and we skip to step 7.\n     */\n if ((ref->path != NULL) && (ref->path[0] == '/')) {\n\tres->path = xmlMemStrdup(ref->path);\n goto step_7;\n }\n\n\n /*\n     * 6) If this step is reached, then we are resolving a relative-path\n     *    reference.  The relative path needs to be merged with the base\n     *    URI's path.  Although there are many ways to do this, we will\n     *    describe a simple method using a separate string buffer.\n     *\n     * Allocate a buffer large enough for the result string.\n     */\n    len = 2; /* extra / and 0 */\n if (ref->path != NULL)\n\tlen += strlen(ref->path);\n if (bas->path != NULL)\n\tlen += strlen(bas->path);\n    res->path = (char *) xmlMallocAtomic(len);\n if (res->path == NULL) {\n        xmlURIErrMemory(\"resolving URI against base\\n\");\n goto done;\n }\n    res->path[0] = 0;\n\n /*\n     * a) All but the last segment of the base URI's path component is\n     *    copied to the buffer.  In other words, any characters after the\n     *    last (right-most) slash character, if any, are excluded.\n     */\n    cur = 0;\n    out = 0;\n if (bas->path != NULL) {\n while (bas->path[cur] != 0) {\n while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))\n\t\tcur++;\n if (bas->path[cur] == 0)\n break;\n\n\t    cur++;\n while (out < cur) {\n\t\tres->path[out] = bas->path[out];\n\t\tout++;\n }\n }\n }\n    res->path[out] = 0;\n\n /*\n     * b) The reference's path component is appended to the buffer\n     *    string.\n     */\n if (ref->path != NULL && ref->path[0] != 0) {\n\tindx = 0;\n /*\n\t * Ensure the path includes a '/'\n\t */\n if ((out == 0) && (bas->server != NULL))\n\t    res->path[out++] = '/';\n while (ref->path[indx] != 0) {\n\t    res->path[out++] = ref->path[indx++];\n }\n }\n    res->path[out] = 0;\n\n /*\n     * Steps c) to h) are really path normalization steps\n     */\n    xmlNormalizeURIPath(res->path);\n\nstep_7:\n\n /*\n     * 7) The resulting URI components, including any inherited from the\n     *    base URI, are recombined to give the absolute form of the URI\n     *    reference.\n     */\n    val = xmlSaveUri(res);\n\ndone:\n if (ref != NULL)\n\txmlFreeURI(ref);\n if (bas != NULL)\n\txmlFreeURI(bas);\n if (res != NULL)\n\txmlFreeURI(res);\n return(val);\n}\n",
        "output": "0",
        "index": 176509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int avi_read_header(AVFormatContext *s)\n{\n    AVIContext *avi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    unsigned int tag, tag1, handler;\n    int codec_type, stream_index, frame_period;\n    unsigned int size;\n    int i;\n    AVStream *st;\n    AVIStream *ast      = NULL;\n    int avih_width      = 0, avih_height = 0;\n    int amv_file_format = 0;\n    uint64_t list_end   = 0;\n    int64_t pos;\n    int ret;\n    AVDictionaryEntry *dict_entry;\n\n    avi->stream_index = -1;\n\n    ret = get_riff(s, pb);\n    if (ret < 0)\n        return ret;\n\n    av_log(avi, AV_LOG_DEBUG, \"use odml:%d\\n\", avi->use_odml);\n\n    avi->io_fsize = avi->fsize = avio_size(pb);\n    if (avi->fsize <= 0 || avi->fsize < avi->riff_end)\n        avi->fsize = avi->riff_end == 8 ? INT64_MAX : avi->riff_end;\n\n    /* first list tag */\n    stream_index = -1;\n    codec_type   = -1;\n    frame_period = 0;\n    for (;;) {\n        if (avio_feof(pb))\n            goto fail;\n        tag  = avio_rl32(pb);\n        size = avio_rl32(pb);\n\n        print_tag(\"tag\", tag, size);\n\n        switch (tag) {\n        case MKTAG('L', 'I', 'S', 'T'):\n            list_end = avio_tell(pb) + size;\n            /* Ignored, except at start of video packets. */\n            tag1 = avio_rl32(pb);\n\n            print_tag(\"list\", tag1, 0);\n\n            if (tag1 == MKTAG('m', 'o', 'v', 'i')) {\n                avi->movi_list = avio_tell(pb) - 4;\n                if (size)\n                    avi->movi_end = avi->movi_list + size + (size & 1);\n                else\n                    avi->movi_end = avi->fsize;\n                av_log(NULL, AV_LOG_TRACE, \"movi end=%\"PRIx64\"\\n\", avi->movi_end);\n                goto end_of_header;\n            } else if (tag1 == MKTAG('I', 'N', 'F', 'O'))\n                ff_read_riff_info(s, size - 4);\n            else if (tag1 == MKTAG('n', 'c', 'd', 't'))\n                avi_read_nikon(s, list_end);\n\n            break;\n        case MKTAG('I', 'D', 'I', 'T'):\n        {\n            unsigned char date[64] = { 0 };\n            size += (size & 1);\n            size -= avio_read(pb, date, FFMIN(size, sizeof(date) - 1));\n            avio_skip(pb, size);\n            avi_metadata_creation_time(&s->metadata, date);\n            break;\n        }\n        case MKTAG('d', 'm', 'l', 'h'):\n            avi->is_odml = 1;\n            avio_skip(pb, size + (size & 1));\n            break;\n        case MKTAG('a', 'm', 'v', 'h'):\n            amv_file_format = 1;\n        case MKTAG('a', 'v', 'i', 'h'):\n            /* AVI header */\n            /* using frame_period is bad idea */\n            frame_period = avio_rl32(pb);\n            avio_rl32(pb); /* max. bytes per second */\n            avio_rl32(pb);\n            avi->non_interleaved |= avio_rl32(pb) & AVIF_MUSTUSEINDEX;\n\n            avio_skip(pb, 2 * 4);\n            avio_rl32(pb);\n            avio_rl32(pb);\n            avih_width  = avio_rl32(pb);\n            avih_height = avio_rl32(pb);\n\n            avio_skip(pb, size - 10 * 4);\n            break;\n        case MKTAG('s', 't', 'r', 'h'):\n            /* stream header */\n\n            tag1    = avio_rl32(pb);\n            handler = avio_rl32(pb); /* codec tag */\n\n            if (tag1 == MKTAG('p', 'a', 'd', 's')) {\n                avio_skip(pb, size - 8);\n                break;\n            } else {\n                stream_index++;\n                st = avformat_new_stream(s, NULL);\n                if (!st)\n                    goto fail;\n\n                st->id = stream_index;\n                ast    = av_mallocz(sizeof(AVIStream));\n                if (!ast)\n                    goto fail;\n                st->priv_data = ast;\n            }\n            if (amv_file_format)\n                tag1 = stream_index ? MKTAG('a', 'u', 'd', 's')\n                                    : MKTAG('v', 'i', 'd', 's');\n\n            print_tag(\"strh\", tag1, -1);\n\n            if (tag1 == MKTAG('i', 'a', 'v', 's') ||\n                tag1 == MKTAG('i', 'v', 'a', 's')) {\n                int64_t dv_dur;\n\n                /* After some consideration -- I don't think we\n                 * have to support anything but DV in type1 AVIs. */\n                if (s->nb_streams != 1)\n                    goto fail;\n\n                if (handler != MKTAG('d', 'v', 's', 'd') &&\n                    handler != MKTAG('d', 'v', 'h', 'd') &&\n                    handler != MKTAG('d', 'v', 's', 'l'))\n                    goto fail;\n\n                ast = s->streams[0]->priv_data;\n                av_freep(&s->streams[0]->codecpar->extradata);\n                av_freep(&s->streams[0]->codecpar);\n#if FF_API_LAVF_AVCTX\nFF_DISABLE_DEPRECATION_WARNINGS\n                av_freep(&s->streams[0]->codec);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n                if (s->streams[0]->info)\n                    av_freep(&s->streams[0]->info->duration_error);\n                av_freep(&s->streams[0]->info);\n                if (s->streams[0]->internal)\n                    av_freep(&s->streams[0]->internal->avctx);\n                av_freep(&s->streams[0]->internal);\n                av_freep(&s->streams[0]);\n                s->nb_streams = 0;\n                if (CONFIG_DV_DEMUXER) {\n                    avi->dv_demux = avpriv_dv_init_demux(s);\n                    if (!avi->dv_demux)\n                        goto fail;\n                } else\n                    goto fail;\n                s->streams[0]->priv_data = ast;\n                avio_skip(pb, 3 * 4);\n                ast->scale = avio_rl32(pb);\n                ast->rate  = avio_rl32(pb);\n                avio_skip(pb, 4);  /* start time */\n\n                dv_dur = avio_rl32(pb);\n                if (ast->scale > 0 && ast->rate > 0 && dv_dur > 0) {\n                    dv_dur     *= AV_TIME_BASE;\n                    s->duration = av_rescale(dv_dur, ast->scale, ast->rate);\n                }\n                /* else, leave duration alone; timing estimation in utils.c\n                 * will make a guess based on bitrate. */\n\n                stream_index = s->nb_streams - 1;\n                avio_skip(pb, size - 9 * 4);\n                break;\n            }\n\n            av_assert0(stream_index < s->nb_streams);\n            ast->handler = handler;\n\n            avio_rl32(pb); /* flags */\n            avio_rl16(pb); /* priority */\n            avio_rl16(pb); /* language */\n            avio_rl32(pb); /* initial frame */\n            ast->scale = avio_rl32(pb);\n            ast->rate  = avio_rl32(pb);\n            if (!(ast->scale && ast->rate)) {\n                av_log(s, AV_LOG_WARNING,\n                       \"scale/rate is %\"PRIu32\"/%\"PRIu32\" which is invalid. \"\n                       \"(This file has been generated by broken software.)\\n\",\n                       ast->scale,\n                       ast->rate);\n                if (frame_period) {\n                    ast->rate  = 1000000;\n                    ast->scale = frame_period;\n                } else {\n                    ast->rate  = 25;\n                    ast->scale = 1;\n                }\n            }\n            avpriv_set_pts_info(st, 64, ast->scale, ast->rate);\n\n            ast->cum_len  = avio_rl32(pb); /* start */\n            st->nb_frames = avio_rl32(pb);\n\n            st->start_time = 0;\n            avio_rl32(pb); /* buffer size */\n            avio_rl32(pb); /* quality */\n            if (ast->cum_len*ast->scale/ast->rate > 3600) {\n                av_log(s, AV_LOG_ERROR, \"crazy start time, iam scared, giving up\\n\");\n                ast->cum_len = 0;\n            }\n            ast->sample_size = avio_rl32(pb);\n            ast->cum_len    *= FFMAX(1, ast->sample_size);\n            av_log(s, AV_LOG_TRACE, \"%\"PRIu32\" %\"PRIu32\" %d\\n\",\n                    ast->rate, ast->scale, ast->sample_size);\n\n            switch (tag1) {\n            case MKTAG('v', 'i', 'd', 's'):\n                codec_type = AVMEDIA_TYPE_VIDEO;\n\n                ast->sample_size = 0;\n                st->avg_frame_rate = av_inv_q(st->time_base);\n                break;\n            case MKTAG('a', 'u', 'd', 's'):\n                codec_type = AVMEDIA_TYPE_AUDIO;\n                break;\n            case MKTAG('t', 'x', 't', 's'):\n                codec_type = AVMEDIA_TYPE_SUBTITLE;\n                break;\n            case MKTAG('d', 'a', 't', 's'):\n                codec_type = AVMEDIA_TYPE_DATA;\n                break;\n            default:\n                av_log(s, AV_LOG_INFO, \"unknown stream type %X\\n\", tag1);\n            }\n\n            if (ast->sample_size < 0) {\n                if (s->error_recognition & AV_EF_EXPLODE) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"Invalid sample_size %d at stream %d\\n\",\n                           ast->sample_size,\n                           stream_index);\n                    goto fail;\n                }\n                av_log(s, AV_LOG_WARNING,\n                       \"Invalid sample_size %d at stream %d \"\n                       \"setting it to 0\\n\",\n                       ast->sample_size,\n                       stream_index);\n                ast->sample_size = 0;\n            }\n\n            if (ast->sample_size == 0) {\n                st->duration = st->nb_frames;\n                if (st->duration > 0 && avi->io_fsize > 0 && avi->riff_end > avi->io_fsize) {\n                    av_log(s, AV_LOG_DEBUG, \"File is truncated adjusting duration\\n\");\n                    st->duration = av_rescale(st->duration, avi->io_fsize, avi->riff_end);\n                }\n            }\n            ast->frame_offset = ast->cum_len;\n            avio_skip(pb, size - 12 * 4);\n            break;\n        case MKTAG('s', 't', 'r', 'f'):\n            /* stream header */\n            if (!size && (codec_type == AVMEDIA_TYPE_AUDIO ||\n                          codec_type == AVMEDIA_TYPE_VIDEO))\n                break;\n            if (stream_index >= (unsigned)s->nb_streams || avi->dv_demux) {\n                avio_skip(pb, size);\n            } else {\n                uint64_t cur_pos = avio_tell(pb);\n                unsigned esize;\n                if (cur_pos < list_end)\n                    size = FFMIN(size, list_end - cur_pos);\n                st = s->streams[stream_index];\n                if (st->codecpar->codec_type != AVMEDIA_TYPE_UNKNOWN) {\n                    avio_skip(pb, size);\n                    break;\n                }\n                switch (codec_type) {\n                case AVMEDIA_TYPE_VIDEO:\n                    if (amv_file_format) {\n                        st->codecpar->width      = avih_width;\n                        st->codecpar->height     = avih_height;\n                        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n                        st->codecpar->codec_id   = AV_CODEC_ID_AMV;\n                        avio_skip(pb, size);\n                        break;\n                    }\n                    tag1 = ff_get_bmp_header(pb, st, &esize);\n\n                    if (tag1 == MKTAG('D', 'X', 'S', 'B') ||\n                        tag1 == MKTAG('D', 'X', 'S', 'A')) {\n                        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n                        st->codecpar->codec_tag  = tag1;\n                        st->codecpar->codec_id   = AV_CODEC_ID_XSUB;\n                        break;\n                    }\n\n                    if (size > 10 * 4 && size < (1 << 30) && size < avi->fsize) {\n                        if (esize == size-1 && (esize&1)) {\n                            st->codecpar->extradata_size = esize - 10 * 4;\n                        } else\n                            st->codecpar->extradata_size =  size - 10 * 4;\n                        if (st->codecpar->extradata) {\n                            av_log(s, AV_LOG_WARNING, \"New extradata in strf chunk, freeing previous one.\\n\");\n                            av_freep(&st->codecpar->extradata);\n                        }\n                        if (ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)\n                            return AVERROR(ENOMEM);\n                    }\n\n                    if (st->codecpar->extradata_size & 1)\n                        avio_r8(pb);\n\n                    /* Extract palette from extradata if bpp <= 8.\n                     * This code assumes that extradata contains only palette.\n                     * This is true for all paletted codecs implemented in\n                     * FFmpeg. */\n                    if (st->codecpar->extradata_size &&\n                        (st->codecpar->bits_per_coded_sample <= 8)) {\n                        int pal_size = (1 << st->codecpar->bits_per_coded_sample) << 2;\n                        const uint8_t *pal_src;\n\n                        pal_size = FFMIN(pal_size, st->codecpar->extradata_size);\n                        pal_src  = st->codecpar->extradata +\n                                   st->codecpar->extradata_size - pal_size;\n                        /* Exclude the \"BottomUp\" field from the palette */\n                        if (pal_src - st->codecpar->extradata >= 9 &&\n                            !memcmp(st->codecpar->extradata + st->codecpar->extradata_size - 9, \"BottomUp\", 9))\n                            pal_src -= 9;\n                        for (i = 0; i < pal_size / 4; i++)\n                            ast->pal[i] = 0xFFU<<24 | AV_RL32(pal_src + 4 * i);\n                        ast->has_pal = 1;\n                    }\n\n                    print_tag(\"video\", tag1, 0);\n\n                    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n                    st->codecpar->codec_tag  = tag1;\n                    st->codecpar->codec_id   = ff_codec_get_id(ff_codec_bmp_tags,\n                                                            tag1);\n                    /* If codec is not found yet, try with the mov tags. */\n                    if (!st->codecpar->codec_id) {\n                        st->codecpar->codec_id =\n                            ff_codec_get_id(ff_codec_movvideo_tags, tag1);\n                        if (st->codecpar->codec_id)\n                           av_log(s, AV_LOG_WARNING,\n                                  \"mov tag found in avi (fourcc %s)\\n\",\n                                  av_fourcc2str(tag1));\n                    }\n                    /* This is needed to get the pict type which is necessary\n                     * for generating correct pts. */\n                    st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n                    if (st->codecpar->codec_id == AV_CODEC_ID_MPEG4 &&\n                        ast->handler == MKTAG('X', 'V', 'I', 'D'))\n                        st->codecpar->codec_tag = MKTAG('X', 'V', 'I', 'D');\n\n                    if (st->codecpar->codec_tag == MKTAG('V', 'S', 'S', 'H'))\n                        st->need_parsing = AVSTREAM_PARSE_FULL;\n                    if (st->codecpar->codec_id == AV_CODEC_ID_RV40)\n                        st->need_parsing = AVSTREAM_PARSE_NONE;\n\n                    if (st->codecpar->codec_tag == 0 && st->codecpar->height > 0 &&\n                        st->codecpar->extradata_size < 1U << 30) {\n                        st->codecpar->extradata_size += 9;\n                        if ((ret = av_reallocp(&st->codecpar->extradata,\n                                               st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {\n                            st->codecpar->extradata_size = 0;\n                            return ret;\n                        } else\n                            memcpy(st->codecpar->extradata + st->codecpar->extradata_size - 9,\n                                   \"BottomUp\", 9);\n                    }\n                    st->codecpar->height = FFABS(st->codecpar->height);\n\n                    break;\n                case AVMEDIA_TYPE_AUDIO:\n                    ret = ff_get_wav_header(s, pb, st->codecpar, size, 0);\n                    if (ret < 0)\n                        return ret;\n                    ast->dshow_block_align = st->codecpar->block_align;\n                    if (ast->sample_size && st->codecpar->block_align &&\n                        ast->sample_size != st->codecpar->block_align) {\n                        av_log(s,\n                               AV_LOG_WARNING,\n                               \"sample size (%d) != block align (%d)\\n\",\n                               ast->sample_size,\n                               st->codecpar->block_align);\n                        ast->sample_size = st->codecpar->block_align;\n                    }\n                    /* 2-aligned\n                     * (fix for Stargate SG-1 - 3x18 - Shades of Grey.avi) */\n                    if (size & 1)\n                        avio_skip(pb, 1);\n                    /* Force parsing as several audio frames can be in\n                     * one packet and timestamps refer to packet start. */\n                    st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n                    /* ADTS header is in extradata, AAC without header must be\n                     * stored as exact frames. Parser not needed and it will\n                     * fail. */\n                    if (st->codecpar->codec_id == AV_CODEC_ID_AAC &&\n                        st->codecpar->extradata_size)\n                        st->need_parsing = AVSTREAM_PARSE_NONE;\n                    if (st->codecpar->codec_id == AV_CODEC_ID_FLAC)\n                        st->need_parsing = AVSTREAM_PARSE_NONE;\n                    /* AVI files with Xan DPCM audio (wrongly) declare PCM\n                     * audio in the header but have Axan as stream_code_tag. */\n                    if (ast->handler == AV_RL32(\"Axan\")) {\n                        st->codecpar->codec_id  = AV_CODEC_ID_XAN_DPCM;\n                        st->codecpar->codec_tag = 0;\n                        ast->dshow_block_align = 0;\n                    }\n                    if (amv_file_format) {\n                        st->codecpar->codec_id    = AV_CODEC_ID_ADPCM_IMA_AMV;\n                        ast->dshow_block_align = 0;\n                    }\n                    if ((st->codecpar->codec_id == AV_CODEC_ID_AAC  ||\n                         st->codecpar->codec_id == AV_CODEC_ID_FLAC ||\n                         st->codecpar->codec_id == AV_CODEC_ID_MP2 ) && ast->dshow_block_align <= 4 && ast->dshow_block_align) {\n                        av_log(s, AV_LOG_DEBUG, \"overriding invalid dshow_block_align of %d\\n\", ast->dshow_block_align);\n                        ast->dshow_block_align = 0;\n                    }\n                    if (st->codecpar->codec_id == AV_CODEC_ID_AAC && ast->dshow_block_align == 1024 && ast->sample_size == 1024 ||\n                       st->codecpar->codec_id == AV_CODEC_ID_AAC && ast->dshow_block_align == 4096 && ast->sample_size == 4096 ||\n                       st->codecpar->codec_id == AV_CODEC_ID_MP3 && ast->dshow_block_align == 1152 && ast->sample_size == 1152) {\n                        av_log(s, AV_LOG_DEBUG, \"overriding sample_size\\n\");\n                        ast->sample_size = 0;\n                    }\n                    break;\n                case AVMEDIA_TYPE_SUBTITLE:\n                    st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n                    st->request_probe= 1;\n                    avio_skip(pb, size);\n                    break;\n                default:\n                    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n                    st->codecpar->codec_id   = AV_CODEC_ID_NONE;\n                    st->codecpar->codec_tag  = 0;\n                    avio_skip(pb, size);\n                    break;\n                }\n            }\n            break;\n        case MKTAG('s', 't', 'r', 'd'):\n            if (stream_index >= (unsigned)s->nb_streams\n                || s->streams[stream_index]->codecpar->extradata_size\n                || s->streams[stream_index]->codecpar->codec_tag == MKTAG('H','2','6','4')) {\n                avio_skip(pb, size);\n            } else {\n                uint64_t cur_pos = avio_tell(pb);\n                if (cur_pos < list_end)\n                    size = FFMIN(size, list_end - cur_pos);\n                st = s->streams[stream_index];\n\n                if (size<(1<<30)) {\n                    if (st->codecpar->extradata) {\n                        av_log(s, AV_LOG_WARNING, \"New extradata in strd chunk, freeing previous one.\\n\");\n                        av_freep(&st->codecpar->extradata);\n                    }\n                    if (ff_get_extradata(s, st->codecpar, pb, size) < 0)\n                        return AVERROR(ENOMEM);\n                }\n\n                if (st->codecpar->extradata_size & 1) //FIXME check if the encoder really did this correctly\n                    avio_r8(pb);\n\n                ret = avi_extract_stream_metadata(s, st);\n                if (ret < 0) {\n                    av_log(s, AV_LOG_WARNING, \"could not decoding EXIF data in stream header.\\n\");\n                }\n            }\n            break;\n        case MKTAG('i', 'n', 'd', 'x'):\n            pos = avio_tell(pb);\n            if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !(s->flags & AVFMT_FLAG_IGNIDX) &&\n                avi->use_odml &&\n                read_odml_index(s, 0) < 0 &&\n                (s->error_recognition & AV_EF_EXPLODE))\n                goto fail;\n            avio_seek(pb, pos + size, SEEK_SET);\n            break;\n        case MKTAG('v', 'p', 'r', 'p'):\n            if (stream_index < (unsigned)s->nb_streams && size > 9 * 4) {\n                AVRational active, active_aspect;\n\n                st = s->streams[stream_index];\n                avio_rl32(pb);\n                avio_rl32(pb);\n                avio_rl32(pb);\n                avio_rl32(pb);\n                avio_rl32(pb);\n\n                active_aspect.den = avio_rl16(pb);\n                active_aspect.num = avio_rl16(pb);\n                active.num        = avio_rl32(pb);\n                active.den        = avio_rl32(pb);\n                avio_rl32(pb); // nbFieldsPerFrame\n\n                if (active_aspect.num && active_aspect.den &&\n                    active.num && active.den) {\n                    st->sample_aspect_ratio = av_div_q(active_aspect, active);\n                    av_log(s, AV_LOG_TRACE, \"vprp %d/%d %d/%d\\n\",\n                            active_aspect.num, active_aspect.den,\n                            active.num, active.den);\n                }\n                size -= 9 * 4;\n            }\n            avio_skip(pb, size);\n            break;\n        case MKTAG('s', 't', 'r', 'n'):\n            if (s->nb_streams) {\n                ret = avi_read_tag(s, s->streams[s->nb_streams - 1], tag, size);\n                if (ret < 0)\n                    return ret;\n                break;\n            }\n        default:\n            if (size > 1000000) {\n                av_log(s, AV_LOG_ERROR,\n                       \"Something went wrong during header parsing, \"\n                       \"tag %s has size %u, \"\n                       \"I will ignore it and try to continue anyway.\\n\",\n                       av_fourcc2str(tag), size);\n                if (s->error_recognition & AV_EF_EXPLODE)\n                    goto fail;\n                avi->movi_list = avio_tell(pb) - 4;\n                avi->movi_end  = avi->fsize;\n                goto end_of_header;\n            }\n        /* Do not fail for very large idx1 tags */\n        case MKTAG('i', 'd', 'x', '1'):\n            /* skip tag */\n            size += (size & 1);\n            avio_skip(pb, size);\n            break;\n        }\n    }\n\nend_of_header:\n    /* check stream number */\n    if (stream_index != s->nb_streams - 1) {\n\nfail:\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!avi->index_loaded && (pb->seekable & AVIO_SEEKABLE_NORMAL))\n        avi_load_index(s);\n    calculate_bitrate(s);\n    avi->index_loaded    |= 1;\n\n    if ((ret = guess_ni_flag(s)) < 0)\n        return ret;\n\n    avi->non_interleaved |= ret | (s->flags & AVFMT_FLAG_SORT_DTS);\n\n    dict_entry = av_dict_get(s->metadata, \"ISFT\", NULL, 0);\n    if (dict_entry && !strcmp(dict_entry->value, \"PotEncoder\"))\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (   st->codecpar->codec_id == AV_CODEC_ID_MPEG1VIDEO\n                || st->codecpar->codec_id == AV_CODEC_ID_MPEG2VIDEO)\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        if (st->nb_index_entries)\n            break;\n    }\n    if (avi->dv_demux)\n        avi->non_interleaved = 0;\n    if (i == s->nb_streams && avi->non_interleaved) {\n        av_log(s, AV_LOG_WARNING,\n               \"Non-interleaved AVI without index, switching to interleaved\\n\");\n        avi->non_interleaved = 0;\n    }\n\n    if (avi->non_interleaved) {\n        av_log(s, AV_LOG_INFO, \"non-interleaved AVI\\n\");\n        clean_index(s);\n    }\n\n    ff_metadata_conv_ctx(s, NULL, avi_metadata_conv);\n    ff_metadata_conv_ctx(s, NULL, ff_riff_info_conv);\n\n    return 0;\n}\n",
        "output": "0",
        "index": 64069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTiffCtx(gdIOCtx *infile)\n{\n\tTIFF *tif;\n\ttiff_handle *th;\n\n\tuint16 bps, spp, photometric;\n\tuint16 orientation;\n\tint width, height;\n\tuint16 extra, *extra_types;\n\tuint16 planar;\n\tchar\thas_alpha, is_bw, is_gray;\n\tchar\tforce_rgba = FALSE;\n\tchar\tsave_transparent;\n\tint\t\timage_type;\n\tint   ret;\n\tfloat res_float;\n\n\tgdImagePtr im = NULL;\n\n\tth = new_tiff_handle(infile);\n\tif (!th) {\n\t\treturn NULL;\n\t}\n\n\ttif = TIFFClientOpen(\"\", \"rb\", th, tiff_readproc,\n\t                     tiff_writeproc,\n\t                     tiff_seekproc,\n\t                     tiff_closeproc,\n\t                     tiff_sizeproc,\n\t                     tiff_mapproc,\n\t                     tiff_unmapproc);\n\n\tif (!tif) {\n\t\tgd_error(\"Cannot open TIFF image\");\n\t\tgdFree(th);\n\t\treturn NULL;\n\t}\n\n\tif (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tgd_error(\"TIFF error, Cannot read image width\");\n\t\tgoto error;\n\t}\n\n\tif (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tgd_error(\"TIFF error, Cannot read image width\");\n\t\tgoto error;\n\t}\n\n\tTIFFGetFieldDefaulted (tif, TIFFTAG_BITSPERSAMPLE, &bps);\n\n\t/* Unsupported bps, force to RGBA */\n\tif (1/*bps > 8 && bps != 16*/) {\n\t\tforce_rgba = TRUE;\n\t}\n\n\tTIFFGetFieldDefaulted (tif, TIFFTAG_SAMPLESPERPIXEL, &spp);\n\n\tif (!TIFFGetField (tif, TIFFTAG_EXTRASAMPLES, &extra, &extra_types)) {\n\t\textra = 0;\n\t}\n\n\tif (!TIFFGetField (tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n\t\tuint16 compression;\n\t\tif (TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression) &&\n\t\t        (compression == COMPRESSION_CCITTFAX3 ||\n\t\t         compression == COMPRESSION_CCITTFAX4 ||\n\t\t         compression == COMPRESSION_CCITTRLE ||\n\t\t         compression == COMPRESSION_CCITTRLEW)) {\n\t\t\tgd_error(\"Could not get photometric. \"\n\t\t\t        \"Image is CCITT compressed, assuming min-is-white\");\n\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t} else {\n\t\t\tgd_error(\"Could not get photometric. \"\n\t\t\t        \"Assuming min-is-black\");\n\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t}\n\t}\n\tsave_transparent = FALSE;\n\n\t/* test if the extrasample represents an associated alpha channel... */\n\tif (extra > 0 && (extra_types[0] == EXTRASAMPLE_ASSOCALPHA)) {\n\t\thas_alpha = TRUE;\n\t\tsave_transparent = FALSE;\n\t\t--extra;\n\t} else if (extra > 0 && (extra_types[0] == EXTRASAMPLE_UNASSALPHA)) {\n\t\thas_alpha = TRUE;\n\t\tsave_transparent = TRUE;\n\t\t--extra;\n\t} else if (extra > 0 && (extra_types[0] == EXTRASAMPLE_UNSPECIFIED)) {\n\t\t/* assuming unassociated alpha if unspecified */\n\t\tgd_error(\"alpha channel type not defined, assuming alpha is not premultiplied\");\n\t\thas_alpha = TRUE;\n\t\tsave_transparent = TRUE;\n\t\t--extra;\n\t} else {\n\t\thas_alpha = FALSE;\n\t}\n\n\tif (photometric == PHOTOMETRIC_RGB && spp > 3 + extra) {\n\t\thas_alpha = TRUE;\n\t\textra = spp - 4;\n\t} else if (photometric != PHOTOMETRIC_RGB && spp > 1 + extra) {\n\t\thas_alpha = TRUE;\n\t\textra = spp - 2;\n\t}\n\n\tis_bw = FALSE;\n\tis_gray = FALSE;\n\n\tswitch (photometric) {\n\tcase PHOTOMETRIC_MINISBLACK:\n\tcase PHOTOMETRIC_MINISWHITE:\n\t\tif (!has_alpha && bps == 1 && spp == 1) {\n\t\t\timage_type = GD_INDEXED;\n\t\t\tis_bw = TRUE;\n\t\t} else {\n\t\t\timage_type = GD_GRAY;\n\t\t}\n\t\tbreak;\n\n\tcase PHOTOMETRIC_RGB:\n\t\timage_type = GD_RGB;\n\t\tbreak;\n\n\tcase PHOTOMETRIC_PALETTE:\n\t\timage_type = GD_INDEXED;\n\t\tbreak;\n\n\tdefault:\n\t\tforce_rgba = TRUE;\n\t\tbreak;\n\t}\n\n\tif (!TIFFGetField (tif, TIFFTAG_PLANARCONFIG, &planar)) {\n\t\tplanar = PLANARCONFIG_CONTIG;\n\t}\n\n\t/* Force rgba if image plans are not contiguous */\n\tif (force_rgba || planar != PLANARCONFIG_CONTIG) {\n\t\timage_type = GD_RGB;\n\t}\n\n\tif (!force_rgba &&\n\t        (image_type == GD_PALETTE || image_type == GD_INDEXED || image_type == GD_GRAY)) {\n\t\tim = gdImageCreate(width, height);\n\t\tif (!im) goto error;\n\t\treadTiffColorMap(im, tif, is_bw, photometric);\n\t} else {\n\t\tim = gdImageCreateTrueColor(width, height);\n\t\tif (!im) goto error;\n\t}\n\n#ifdef DEBUG\n\tprintf(\"force rgba: %i\\n\", force_rgba);\n\tprintf(\"has_alpha: %i\\n\", has_alpha);\n\tprintf(\"save trans: %i\\n\", save_transparent);\n\tprintf(\"is_bw: %i\\n\", is_bw);\n\tprintf(\"is_gray: %i\\n\", is_gray);\n\tprintf(\"type: %i\\n\", image_type);\n#else\n\t(void)is_gray;\n\t(void)save_transparent;\n#endif\n\n\tif (force_rgba) {\n\t\tret = createFromTiffRgba(tif, im);\n\t} else if (TIFFIsTiled(tif)) {\n\t\tret = createFromTiffTiles(tif, im, bps, photometric, has_alpha, is_bw, extra);\n\t} else {\n\t\tret = createFromTiffLines(tif, im, bps, photometric, has_alpha, is_bw, extra);\n\t}\n\n\tif (!ret) {\n\t\tgdImageDestroy(im);\n\t\tim = NULL;\n\t\tgoto error;\n\t}\n\n\tif (TIFFGetField(tif, TIFFTAG_XRESOLUTION, &res_float)) { \n\t\tim->res_x = (unsigned int)res_float;  //truncate\n\t}\n\tif (TIFFGetField(tif, TIFFTAG_YRESOLUTION, &res_float)) { \n\t\tim->res_y = (unsigned int)res_float;  //truncate\n\t}\n\n\tif (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {\n\t\tswitch (orientation) {\n\t\tcase ORIENTATION_TOPLEFT:\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgd_error(\"Orientation %d not handled yet!\", orientation);\n\t\t\tbreak;\n\t\t}\n\t}\nerror:\n\tTIFFClose(tif);\n\tgdFree(th);\n\treturn im;\n}\n",
        "output": "0",
        "index": 73721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_decode_flow_stats_reply(struct ofputil_flow_stats *fs,\n                                struct ofpbuf *msg,\n                                bool flow_age_extension,\n                                struct ofpbuf *ofpacts)\n{\n    const struct ofp_header *oh;\n    size_t instructions_len;\n    enum ofperr error;\n    enum ofpraw raw;\n\n    error = (msg->header ? ofpraw_decode(&raw, msg->header)\n             : ofpraw_pull(&raw, msg));\n    if (error) {\n        return error;\n    }\n    oh = msg->header;\n\n    if (!msg->size) {\n        return EOF;\n    } else if (raw == OFPRAW_OFPST11_FLOW_REPLY\n               || raw == OFPRAW_OFPST13_FLOW_REPLY) {\n        const struct ofp11_flow_stats *ofs;\n        size_t length;\n        uint16_t padded_match_len;\n\n        ofs = ofpbuf_try_pull(msg, sizeof *ofs);\n        if (!ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(ofs->length);\n        if (length < sizeof *ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply claims invalid \"\n                         \"length %\"PRIuSIZE, length);\n            return EINVAL;\n        }\n\n        if (ofputil_pull_ofp11_match(msg, NULL, NULL, &fs->match,\n                                     &padded_match_len)) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply bad match\");\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *ofs - padded_match_len;\n\n        fs->priority = ntohs(ofs->priority);\n        fs->table_id = ofs->table_id;\n        fs->duration_sec = ntohl(ofs->duration_sec);\n        fs->duration_nsec = ntohl(ofs->duration_nsec);\n        fs->idle_timeout = ntohs(ofs->idle_timeout);\n        fs->hard_timeout = ntohs(ofs->hard_timeout);\n        if (oh->version >= OFP14_VERSION) {\n            fs->importance = ntohs(ofs->importance);\n        } else {\n            fs->importance = 0;\n        }\n        if (raw == OFPRAW_OFPST13_FLOW_REPLY) {\n            error = ofputil_decode_flow_mod_flags(ofs->flags, -1, oh->version,\n                                                  &fs->flags);\n            if (error) {\n                return error;\n            }\n        } else {\n            fs->flags = 0;\n        }\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        fs->cookie = ofs->cookie;\n        fs->packet_count = ntohll(ofs->packet_count);\n        fs->byte_count = ntohll(ofs->byte_count);\n    } else if (raw == OFPRAW_OFPST10_FLOW_REPLY) {\n        const struct ofp10_flow_stats *ofs;\n        size_t length;\n\n        ofs = ofpbuf_try_pull(msg, sizeof *ofs);\n        if (!ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(ofs->length);\n        if (length < sizeof *ofs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply claims invalid \"\n                         \"length %\"PRIuSIZE, length);\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *ofs;\n\n        fs->cookie = get_32aligned_be64(&ofs->cookie);\n        ofputil_match_from_ofp10_match(&ofs->match, &fs->match);\n        fs->priority = ntohs(ofs->priority);\n        fs->table_id = ofs->table_id;\n        fs->duration_sec = ntohl(ofs->duration_sec);\n        fs->duration_nsec = ntohl(ofs->duration_nsec);\n        fs->idle_timeout = ntohs(ofs->idle_timeout);\n        fs->hard_timeout = ntohs(ofs->hard_timeout);\n        fs->importance = 0;\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        fs->packet_count = ntohll(get_32aligned_be64(&ofs->packet_count));\n        fs->byte_count = ntohll(get_32aligned_be64(&ofs->byte_count));\n        fs->flags = 0;\n    } else if (raw == OFPRAW_NXST_FLOW_REPLY) {\n        const struct nx_flow_stats *nfs;\n        size_t match_len, length;\n\n        nfs = ofpbuf_try_pull(msg, sizeof *nfs);\n        if (!nfs) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW reply has %\"PRIu32\" leftover \"\n                         \"bytes at end\", msg->size);\n            return EINVAL;\n        }\n\n        length = ntohs(nfs->length);\n        match_len = ntohs(nfs->match_len);\n        if (length < sizeof *nfs + ROUND_UP(match_len, 8)) {\n            VLOG_WARN_RL(&bad_ofmsg_rl, \"NXST_FLOW reply with match_len=%\"PRIuSIZE\" \"\n                         \"claims invalid length %\"PRIuSIZE, match_len, length);\n            return EINVAL;\n        }\n        if (nx_pull_match(msg, match_len, &fs->match, NULL, NULL, NULL,\n                          NULL)) {\n            return EINVAL;\n        }\n        instructions_len = length - sizeof *nfs - ROUND_UP(match_len, 8);\n\n        fs->cookie = nfs->cookie;\n        fs->table_id = nfs->table_id;\n        fs->duration_sec = ntohl(nfs->duration_sec);\n        fs->duration_nsec = ntohl(nfs->duration_nsec);\n        fs->priority = ntohs(nfs->priority);\n        fs->idle_timeout = ntohs(nfs->idle_timeout);\n        fs->hard_timeout = ntohs(nfs->hard_timeout);\n        fs->importance = 0;\n        fs->idle_age = -1;\n        fs->hard_age = -1;\n        if (flow_age_extension) {\n            if (nfs->idle_age) {\n                fs->idle_age = ntohs(nfs->idle_age) - 1;\n            }\n            if (nfs->hard_age) {\n                fs->hard_age = ntohs(nfs->hard_age) - 1;\n            }\n        }\n        fs->packet_count = ntohll(nfs->packet_count);\n        fs->byte_count = ntohll(nfs->byte_count);\n        fs->flags = 0;\n    } else {\n        OVS_NOT_REACHED();\n    }\n\n    if (ofpacts_pull_openflow_instructions(msg, instructions_len, oh->version,\n                                           NULL, NULL, ofpacts)) {\n        VLOG_WARN_RL(&bad_ofmsg_rl, \"OFPST_FLOW reply bad instructions\");\n        return EINVAL;\n    }\n    fs->ofpacts = ofpacts->data;\n    fs->ofpacts_len = ofpacts->size;\n\n    return 0;\n}\n",
        "output": "0",
        "index": 77499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int checkTreePage(\n  IntegrityCk *pCheck,  /* Context for the sanity check */\n  int iPage,            /* Page number of the page to check */\n  i64 *piMinKey,        /* Write minimum integer primary key here */\n  i64 maxKey            /* Error if integer primary key greater than this */\n){\n  MemPage *pPage = 0;      /* The page being analyzed */\n  int i;                   /* Loop counter */\n  int rc;                  /* Result code from subroutine call */\n  int depth = -1, d2;      /* Depth of a subtree */\n  int pgno;                /* Page number */\n  int nFrag;               /* Number of fragmented bytes on the page */\n  int hdr;                 /* Offset to the page header */\n  int cellStart;           /* Offset to the start of the cell pointer array */\n  int nCell;               /* Number of cells */\n  int doCoverageCheck = 1; /* True if cell coverage checking should be done */\n  int keyCanBeEqual = 1;   /* True if IPK can be equal to maxKey\n                           ** False if IPK must be strictly less than maxKey */\n  u8 *data;                /* Page content */\n  u8 *pCell;               /* Cell content */\n  u8 *pCellIdx;            /* Next element of the cell pointer array */\n  BtShared *pBt;           /* The BtShared object that owns pPage */\n  u32 pc;                  /* Address of a cell */\n  u32 usableSize;          /* Usable size of the page */\n  u32 contentOffset;       /* Offset to the start of the cell content area */\n  u32 *heap = 0;           /* Min-heap used for checking cell coverage */\n  u32 x, prev = 0;         /* Next and previous entry on the min-heap */\n  const char *saved_zPfx = pCheck->zPfx;\n  int saved_v1 = pCheck->v1;\n  int saved_v2 = pCheck->v2;\n  u8 savedIsInit = 0;\n\n  /* Check that the page exists\n  */\n  pBt = pCheck->pBt;\n  usableSize = pBt->usableSize;\n  if( iPage==0 ) return 0;\n  if( checkRef(pCheck, iPage) ) return 0;\n  pCheck->zPfx = \"Page %d: \";\n  pCheck->v1 = iPage;\n  if( (rc = btreeGetPage(pBt, (Pgno)iPage, &pPage, 0))!=0 ){\n    checkAppendMsg(pCheck,\n       \"unable to get the page. error code=%d\", rc);\n    goto end_of_check;\n  }\n\n  /* Clear MemPage.isInit to make sure the corruption detection code in\n  ** btreeInitPage() is executed.  */\n  savedIsInit = pPage->isInit;\n  pPage->isInit = 0;\n  if( (rc = btreeInitPage(pPage))!=0 ){\n    assert( rc==SQLITE_CORRUPT );  /* The only possible error from InitPage */\n    checkAppendMsg(pCheck,\n                   \"btreeInitPage() returns error code %d\", rc);\n    goto end_of_check;\n  }\n  data = pPage->aData;\n  hdr = pPage->hdrOffset;\n\n  /* Set up for cell analysis */\n  pCheck->zPfx = \"On tree page %d cell %d: \";\n  contentOffset = get2byteNotZero(&data[hdr+5]);\n  assert( contentOffset<=usableSize );  /* Enforced by btreeInitPage() */\n\n  /* EVIDENCE-OF: R-37002-32774 The two-byte integer at offset 3 gives the\n  ** number of cells on the page. */\n  nCell = get2byte(&data[hdr+3]);\n  assert( pPage->nCell==nCell );\n\n  /* EVIDENCE-OF: R-23882-45353 The cell pointer array of a b-tree page\n  ** immediately follows the b-tree page header. */\n  cellStart = hdr + 12 - 4*pPage->leaf;\n  assert( pPage->aCellIdx==&data[cellStart] );\n  pCellIdx = &data[cellStart + 2*(nCell-1)];\n\n  if( !pPage->leaf ){\n    /* Analyze the right-child page of internal pages */\n    pgno = get4byte(&data[hdr+8]);\n#ifndef SQLITE_OMIT_AUTOVACUUM\n    if( pBt->autoVacuum ){\n      pCheck->zPfx = \"On page %d at right child: \";\n      checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);\n    }\n#endif\n    depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n    keyCanBeEqual = 0;\n  }else{\n    /* For leaf pages, the coverage check will occur in the same loop\n    ** as the other cell checks, so initialize the heap.  */\n    heap = pCheck->heap;\n    heap[0] = 0;\n  }\n\n  /* EVIDENCE-OF: R-02776-14802 The cell pointer array consists of K 2-byte\n  ** integer offsets to the cell contents. */\n  for(i=nCell-1; i>=0 && pCheck->mxErr; i--){\n    CellInfo info;\n\n    /* Check cell size */\n    pCheck->v2 = i;\n    assert( pCellIdx==&data[cellStart + i*2] );\n    pc = get2byteAligned(pCellIdx);\n    pCellIdx -= 2;\n    if( pc<contentOffset || pc>usableSize-4 ){\n      checkAppendMsg(pCheck, \"Offset %d out of range %d..%d\",\n                             pc, contentOffset, usableSize-4);\n      doCoverageCheck = 0;\n      continue;\n    }\n    pCell = &data[pc];\n    pPage->xParseCell(pPage, pCell, &info);\n    if( pc+info.nSize>usableSize ){\n      checkAppendMsg(pCheck, \"Extends off end of page\");\n      doCoverageCheck = 0;\n      continue;\n    }\n\n    /* Check for integer primary key out of range */\n    if( pPage->intKey ){\n      if( keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey) ){\n        checkAppendMsg(pCheck, \"Rowid %lld out of order\", info.nKey);\n      }\n      maxKey = info.nKey;\n      keyCanBeEqual = 0;     /* Only the first key on the page may ==maxKey */\n    }\n\n    /* Check the content overflow list */\n    if( info.nPayload>info.nLocal ){\n      u32 nPage;       /* Number of pages on the overflow chain */\n      Pgno pgnoOvfl;   /* First page of the overflow chain */\n      assert( pc + info.nSize - 4 <= usableSize );\n      nPage = (info.nPayload - info.nLocal + usableSize - 5)/(usableSize - 4);\n      pgnoOvfl = get4byte(&pCell[info.nSize - 4]);\n#ifndef SQLITE_OMIT_AUTOVACUUM\n      if( pBt->autoVacuum ){\n        checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, iPage);\n      }\n#endif\n      checkList(pCheck, 0, pgnoOvfl, nPage);\n    }\n\n    if( !pPage->leaf ){\n      /* Check sanity of left child page for internal pages */\n      pgno = get4byte(pCell);\n#ifndef SQLITE_OMIT_AUTOVACUUM\n      if( pBt->autoVacuum ){\n        checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);\n      }\n#endif\n      d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);\n      keyCanBeEqual = 0;\n      if( d2!=depth ){\n        checkAppendMsg(pCheck, \"Child page depth differs\");\n        depth = d2;\n      }\n    }else{\n      /* Populate the coverage-checking heap for leaf pages */\n      btreeHeapInsert(heap, (pc<<16)|(pc+info.nSize-1));\n    }\n  }\n  *piMinKey = maxKey;\n\n  /* Check for complete coverage of the page\n  */\n  pCheck->zPfx = 0;\n  if( doCoverageCheck && pCheck->mxErr>0 ){\n    /* For leaf pages, the min-heap has already been initialized and the\n    ** cells have already been inserted.  But for internal pages, that has\n    ** not yet been done, so do it now */\n    if( !pPage->leaf ){\n      heap = pCheck->heap;\n      heap[0] = 0;\n      for(i=nCell-1; i>=0; i--){\n        u32 size;\n        pc = get2byteAligned(&data[cellStart+i*2]);\n        size = pPage->xCellSize(pPage, &data[pc]);\n        btreeHeapInsert(heap, (pc<<16)|(pc+size-1));\n      }\n    }\n    /* Add the freeblocks to the min-heap\n    **\n    ** EVIDENCE-OF: R-20690-50594 The second field of the b-tree page header\n    ** is the offset of the first freeblock, or zero if there are no\n    ** freeblocks on the page.\n    */\n    i = get2byte(&data[hdr+1]);\n    while( i>0 ){\n      int size, j;\n      assert( (u32)i<=usableSize-4 );     /* Enforced by btreeInitPage() */\n      size = get2byte(&data[i+2]);\n      assert( (u32)(i+size)<=usableSize );  /* Enforced by btreeInitPage() */\n      btreeHeapInsert(heap, (((u32)i)<<16)|(i+size-1));\n      /* EVIDENCE-OF: R-58208-19414 The first 2 bytes of a freeblock are a\n      ** big-endian integer which is the offset in the b-tree page of the next\n      ** freeblock in the chain, or zero if the freeblock is the last on the\n      ** chain. */\n      j = get2byte(&data[i]);\n      /* EVIDENCE-OF: R-06866-39125 Freeblocks are always connected in order of\n      ** increasing offset. */\n      assert( j==0 || j>i+size );  /* Enforced by btreeInitPage() */\n      assert( (u32)j<=usableSize-4 );   /* Enforced by btreeInitPage() */\n      i = j;\n    }\n    /* Analyze the min-heap looking for overlap between cells and/or\n    ** freeblocks, and counting the number of untracked bytes in nFrag.\n    **\n    ** Each min-heap entry is of the form:    (start_address<<16)|end_address.\n    ** There is an implied first entry the covers the page header, the cell\n    ** pointer index, and the gap between the cell pointer index and the start\n    ** of cell content.\n    **\n    ** The loop below pulls entries from the min-heap in order and compares\n    ** the start_address against the previous end_address.  If there is an\n    ** overlap, that means bytes are used multiple times.  If there is a gap,\n    ** that gap is added to the fragmentation count.\n    */\n    nFrag = 0;\n    prev = contentOffset - 1;   /* Implied first min-heap entry */\n    while( btreeHeapPull(heap,&x) ){\n      if( (prev&0xffff)>=(x>>16) ){\n        checkAppendMsg(pCheck,\n          \"Multiple uses for byte %u of page %d\", x>>16, iPage);\n        break;\n      }else{\n        nFrag += (x>>16) - (prev&0xffff) - 1;\n        prev = x;\n      }\n    }\n    nFrag += usableSize - (prev&0xffff) - 1;\n    /* EVIDENCE-OF: R-43263-13491 The total number of bytes in all fragments\n    ** is stored in the fifth field of the b-tree page header.\n    ** EVIDENCE-OF: R-07161-27322 The one-byte integer at offset 7 gives the\n    ** number of fragmented free bytes within the cell content area.\n    */\n    if( heap[0]==0 && nFrag!=data[hdr+7] ){\n      checkAppendMsg(pCheck,\n          \"Fragmentation of %d bytes reported as %d on page %d\",\n          nFrag, data[hdr+7], iPage);\n    }\n  }\n\nend_of_check:\n  if( !doCoverageCheck ) pPage->isInit = savedIsInit;\n  releasePage(pPage);\n  pCheck->zPfx = saved_zPfx;\n  pCheck->v1 = saved_v1;\n  pCheck->v2 = saved_v2;\n  return depth+1;\n}\n",
        "output": "0",
        "index": 164526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n",
        "output": "0",
        "index": 48265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IHEVCD_ERROR_T ihevcd_parse_coding_quadtree(codec_t *ps_codec,\n                                            WORD32 x0,\n                                            WORD32 y0,\n                                            WORD32 log2_cb_size,\n                                            WORD32 ct_depth)\n{\n    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;\n sps_t *ps_sps;\n pps_t *ps_pps;\n    WORD32 split_cu_flag;\n    WORD32 x1, y1;\n    WORD32 cu_pos_x;\n    WORD32 cu_pos_y;\n bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;\n cab_ctxt_t *ps_cabac = &ps_codec->s_parse.s_cabac;\n    WORD32 cb_size = 1 << log2_cb_size;\n    ps_sps = ps_codec->s_parse.ps_sps;\n    ps_pps = ps_codec->s_parse.ps_pps;\n\n /* Compute CU position with respect to current CTB in (8x8) units */\n    cu_pos_x = (x0 - (ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size)) >> 3;\n    cu_pos_y = (y0 - (ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size)) >> 3;\n\n    ps_codec->s_parse.s_cu.i4_pos_x = cu_pos_x;\n    ps_codec->s_parse.s_cu.i4_pos_y = cu_pos_y;\n\n    ps_codec->s_parse.s_cu.i4_log2_cb_size = log2_cb_size;\n\n    ps_codec->s_parse.i4_ct_depth = ct_depth;\n {\n        UWORD32 *pu4_ct_depth_top = ps_codec->s_parse.pu4_ct_depth_top;\n        UWORD32 u4_ct_depth_left = ps_codec->s_parse.u4_ct_depth_left;\n        UWORD32 u4_ct_depth_top = 0;\n        UWORD32 u4_mask;\n        UWORD32 u4_top_mask, u4_left_mask;\n        WORD32  ctxt_idx;\n        UWORD32 u4_min_cu_x = x0 / 8;\n        UWORD32 u4_min_cu_y = y0 / 8;\n\n        pu4_ct_depth_top += (u4_min_cu_x / 16);\n\n\n\n\n if(((x0 + (1 << log2_cb_size)) <= ps_sps->i2_pic_width_in_luma_samples) &&\n ((y0 + (1 << log2_cb_size)) <= ps_sps->i2_pic_height_in_luma_samples) &&\n (log2_cb_size > ps_sps->i1_log2_min_coding_block_size))\n {\n\n            ctxt_idx = IHEVC_CAB_SPLIT_CU_FLAG;\n /* Split cu context increment is decided based on left and top Coding tree\n             * depth which is stored at frame level\n             */\n /* Check if the CTB is in first row in the current slice or tile */\n if((0 != cu_pos_y) ||\n ((0 != ps_codec->s_parse.i4_ctb_slice_y) &&\n (0 != ps_codec->s_parse.i4_ctb_tile_y)))\n {\n                u4_ct_depth_top = *pu4_ct_depth_top;\n                u4_ct_depth_top >>= ((u4_min_cu_x % 16) * 2);\n                u4_ct_depth_top &= 3;\n\n if((WORD32)u4_ct_depth_top > ct_depth)\n                    ctxt_idx++;\n }\n\n /* Check if the CTB is in first column in the current slice or tile */\n /*****************************************************************/\n /* If cu_pos_x is non-zero then left is available                */\n /* If cu_pos_x is zero then ensure both the following are true   */\n /*    Current CTB is not the first CTB in a tile row             */\n /*    Current CTB is not the first CTB in a slice                */\n /*****************************************************************/\n if((0 != cu_pos_x) ||\n (((0 != ps_codec->s_parse.i4_ctb_slice_x) || (0 != ps_codec->s_parse.i4_ctb_slice_y)) &&\n (0 != ps_codec->s_parse.i4_ctb_tile_x)))\n {\n                u4_ct_depth_left >>= ((u4_min_cu_y % 16) * 2);\n                u4_ct_depth_left &= 3;\n if((WORD32)u4_ct_depth_left > ct_depth)\n                    ctxt_idx++;\n }\n            TRACE_CABAC_CTXT(\"split_cu_flag\", ps_cabac->u4_range, ctxt_idx);\n            split_cu_flag = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx);\n            AEV_TRACE(\"split_cu_flag\", split_cu_flag, ps_cabac->u4_range);\n }\n else\n {\n if(log2_cb_size > ps_sps->i1_log2_min_coding_block_size)\n                split_cu_flag = 1;\n else\n                split_cu_flag = 0;\n }\n\n if(0 == split_cu_flag)\n {\n /* Update top ct_depth */\n            u4_ct_depth_top = *pu4_ct_depth_top;\n /* Since Max cb_size is 64, maximum of 8 bits will be set or reset */\n /* Also since Coding block will be within 64x64 grid, only 8bits within a WORD32\n             * need to be updated. These 8 bits will not cross 8 bit boundaries\n             */\n            u4_mask = DUP_LSB_11(cb_size / 8);\n\n            u4_top_mask = u4_mask << ((u4_min_cu_x % 16) * 2);\n            u4_ct_depth_top &= ~u4_top_mask;\n\n if(ct_depth)\n {\n                u4_top_mask = gau4_ct_depth_mask[ct_depth] & u4_mask;\n\n                u4_top_mask = u4_top_mask << ((u4_min_cu_x % 16) * 2);\n                u4_ct_depth_top |= u4_top_mask;\n }\n\n *pu4_ct_depth_top = u4_ct_depth_top;\n\n /* Update left ct_depth */\n            u4_ct_depth_left = ps_codec->s_parse.u4_ct_depth_left;\n\n            u4_left_mask = u4_mask << ((u4_min_cu_y % 16) * 2);\n\n            u4_ct_depth_left &= ~u4_left_mask;\n if(ct_depth)\n {\n                u4_left_mask = gau4_ct_depth_mask[ct_depth] & u4_mask;\n\n                u4_left_mask = u4_left_mask << ((u4_min_cu_y % 16) * 2);\n                u4_ct_depth_left |= u4_left_mask;\n }\n\n            ps_codec->s_parse.u4_ct_depth_left = u4_ct_depth_left;\n }\n }\n if((ps_pps->i1_cu_qp_delta_enabled_flag) &&\n (log2_cb_size >= ps_pps->i1_log2_min_cu_qp_delta_size))\n {\n        ps_codec->s_parse.i4_is_cu_qp_delta_coded = 0;\n        ps_codec->s_parse.i4_cu_qp_delta = 0;\n }\n if(split_cu_flag)\n {\n        x1 = x0 + ((1 << log2_cb_size) >> 1);\n        y1 = y0 + ((1 << log2_cb_size) >> 1);\n\n        ret = ihevcd_parse_coding_quadtree(ps_codec, x0, y0, log2_cb_size - 1, ct_depth + 1);\n        RETURN_IF((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret, ret);\n\n /* At frame boundaries coding quadtree nodes are sent only if they fall within the frame */\n if(x1 < ps_sps->i2_pic_width_in_luma_samples)\n {\n            ret = ihevcd_parse_coding_quadtree(ps_codec, x1, y0, log2_cb_size - 1, ct_depth + 1);\n            RETURN_IF((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret, ret);\n }\n\n if(y1 < ps_sps->i2_pic_height_in_luma_samples)\n {\n            ret = ihevcd_parse_coding_quadtree(ps_codec, x0, y1, log2_cb_size - 1, ct_depth + 1);\n            RETURN_IF((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret, ret);\n }\n\n if((x1 < ps_sps->i2_pic_width_in_luma_samples) &&\n (y1 < ps_sps->i2_pic_height_in_luma_samples))\n {\n            ret = ihevcd_parse_coding_quadtree(ps_codec, x1, y1, log2_cb_size - 1, ct_depth + 1);\n            RETURN_IF((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret, ret);\n }\n }\n else\n {\n /* Set current group QP if current CU is aligned with the group */\n {\n            WORD32 cu_pos_x = ps_codec->s_parse.s_cu.i4_pos_x << 3;\n            WORD32 cu_pos_y = ps_codec->s_parse.s_cu.i4_pos_y << 3;\n\n            WORD32 qpg_x = (cu_pos_x - (cu_pos_x & ((1 << ps_pps->i1_log2_min_cu_qp_delta_size) - 1)));\n            WORD32 qpg_y = (cu_pos_y - (cu_pos_y & ((1 << ps_pps->i1_log2_min_cu_qp_delta_size) - 1)));\n\n if((cu_pos_x == qpg_x) &&\n (cu_pos_y == qpg_y))\n {\n                ps_codec->s_parse.u4_qpg = ps_codec->s_parse.u4_qp;\n\n                ps_codec->s_parse.s_cu.i4_cu_qp_delta = 0;\n\n }\n }\n\n        ret = ihevcd_parse_coding_unit(ps_codec, x0, y0, log2_cb_size);\n        RETURN_IF((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret, ret);\n\n if(ps_pps->i1_cu_qp_delta_enabled_flag)\n {\n            WORD32 qp_pred, qp_left, qp_top;\n            WORD32 cu_pos_x;\n            WORD32 cu_pos_y;\n            WORD32 qpg_x;\n            WORD32 qpg_y;\n            WORD32 i, j;\n            WORD32 qp;\n            WORD32 cur_cu_offset;\n tu_t *ps_tu = ps_codec->s_parse.ps_tu;\n            WORD32 cb_size = 1 << ps_codec->s_parse.s_cu.i4_log2_cb_size;\n\n            cu_pos_x = ps_codec->s_parse.s_cu.i4_pos_x << 3;\n            cu_pos_y = ps_codec->s_parse.s_cu.i4_pos_y << 3;\n\n            qpg_x = (cu_pos_x - (cu_pos_x & ((1 << ps_pps->i1_log2_min_cu_qp_delta_size) - 1))) >> 3;\n            qpg_y = (cu_pos_y - (cu_pos_y & ((1 << ps_pps->i1_log2_min_cu_qp_delta_size) - 1))) >> 3;\n\n /*previous coded Qp*/\n            qp_left = ps_codec->s_parse.u4_qpg;\n            qp_top = ps_codec->s_parse.u4_qpg;\n\n if(qpg_x > 0)\n {\n                qp_left = ps_codec->s_parse.ai1_8x8_cu_qp[qpg_x - 1 + (qpg_y * 8)];\n }\n if(qpg_y > 0)\n {\n                qp_top = ps_codec->s_parse.ai1_8x8_cu_qp[qpg_x + ((qpg_y - 1) * 8)];\n }\n\n            qp_pred = (qp_left + qp_top + 1) >> 1;\n /* Since qp_pred + ps_codec->s_parse.s_cu.i4_cu_qp_delta can be negative,\n            52 is added before taking modulo 52 */\n            qp = (qp_pred + ps_codec->s_parse.s_cu.i4_cu_qp_delta + 52) % 52;\n\n            cur_cu_offset = (cu_pos_x >> 3) + cu_pos_y;\n for(i = 0; i < (cb_size >> 3); i++)\n {\n for(j = 0; j < (cb_size >> 3); j++)\n {\n                    ps_codec->s_parse.ai1_8x8_cu_qp[cur_cu_offset + (i * 8) + j] = qp;\n }\n }\n\n            ps_codec->s_parse.u4_qp = qp;\n            ps_codec->s_parse.s_cu.i4_qp = qp;\n\n\n /* When change in QP is signaled, update the QP in TUs that are already parsed in the CU */\n {\n tu_t *ps_tu_tmp;\n                ps_tu_tmp = ps_tu - ps_codec->s_parse.s_cu.i4_tu_cnt;\n                ps_tu->b7_qp = ps_codec->s_parse.u4_qp;\n while(ps_tu_tmp != ps_tu)\n {\n                    ps_tu_tmp->b7_qp = ps_codec->s_parse.u4_qp;\n\n                    ps_tu_tmp++;\n }\n }\n if(ps_codec->s_parse.s_cu.i4_cu_qp_delta)\n {\n                WORD32 ctb_indx;\n                ctb_indx = ps_codec->s_parse.i4_ctb_x + ps_sps->i2_pic_wd_in_ctb * ps_codec->s_parse.i4_ctb_y;\n                ps_codec->s_parse.s_bs_ctxt.pu1_pic_qp_const_in_ctb[ctb_indx >> 3] &= (~(1 << (ctb_indx & 7)));\n }\n\n }\n\n }\n\n\n\n\n return ret;\n}\n",
        "output": "0",
        "index": 176504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int XfrmController::addVirtualTunnelInterface(const std::string& deviceName,\n const std::string& localAddress,\n const std::string& remoteAddress, int32_t ikey,\n int32_t okey, bool isUpdate) {\n    ALOGD(\"XfrmController::%s, line=%d\", __FUNCTION__, __LINE__);\n    ALOGD(\"deviceName=%s\", deviceName.c_str());\n    ALOGD(\"localAddress=%s\", localAddress.c_str());\n    ALOGD(\"remoteAddress=%s\", remoteAddress.c_str());\n    ALOGD(\"ikey=%0.8x\", ikey);\n    ALOGD(\"okey=%0.8x\", okey);\n    ALOGD(\"isUpdate=%d\", isUpdate);\n\n if (deviceName.empty() || localAddress.empty() || remoteAddress.empty()) {\n return EINVAL;\n }\n\n const char* INFO_KIND_VTI6 = \"vti6\";\n const char* INFO_KIND_VTI = \"vti\";\n uint8_t PADDING_BUFFER[] = {0, 0, 0, 0};\n\n uint8_t remAddr[sizeof(in6_addr)];\n\n StatusOr<uint16_t> statusOrRemoteFam = convertStringAddress(remoteAddress, remAddr);\n if (!isOk(statusOrRemoteFam)) {\n return statusOrRemoteFam.status().code();\n }\n\n uint8_t locAddr[sizeof(in6_addr)];\n StatusOr<uint16_t> statusOrLocalFam = convertStringAddress(localAddress, locAddr);\n if (!isOk(statusOrLocalFam)) {\n return statusOrLocalFam.status().code();\n }\n\n if (statusOrLocalFam.value() != statusOrRemoteFam.value()) {\n return EINVAL;\n }\n\n uint16_t family = statusOrLocalFam.value();\n\n    ifinfomsg ifInfoMsg{};\n\n    nlattr iflaIfName;\n char iflaIfNameStrValue[deviceName.length() + 1];\n size_t iflaIfNameLength =\n        strlcpy(iflaIfNameStrValue, deviceName.c_str(), sizeof(iflaIfNameStrValue));\n size_t iflaIfNamePad = fillNlAttr(IFLA_IFNAME, iflaIfNameLength, &iflaIfName);\n\n const std::string infoKindValue = (family == AF_INET6) ? INFO_KIND_VTI6 : INFO_KIND_VTI;\n    nlattr iflaIfInfoKind;\n char infoKindValueStrValue[infoKindValue.length() + 1];\n size_t iflaIfInfoKindLength =\n        strlcpy(infoKindValueStrValue, infoKindValue.c_str(), sizeof(infoKindValueStrValue));\n size_t iflaIfInfoKindPad = fillNlAttr(IFLA_INFO_KIND, iflaIfInfoKindLength, &iflaIfInfoKind);\n\n    nlattr iflaVtiLocal;\n uint8_t binaryLocalAddress[sizeof(in6_addr)];\n size_t iflaVtiLocalPad =\n        fillNlAttrIpAddress(IFLA_VTI_LOCAL, family, localAddress, &iflaVtiLocal,\n                            netdutils::makeSlice(binaryLocalAddress));\n\n    nlattr iflaVtiRemote;\n uint8_t binaryRemoteAddress[sizeof(in6_addr)];\n size_t iflaVtiRemotePad =\n        fillNlAttrIpAddress(IFLA_VTI_REMOTE, family, remoteAddress, &iflaVtiRemote,\n                            netdutils::makeSlice(binaryRemoteAddress));\n\n    nlattr iflaVtiIKey;\n uint32_t iKeyValue;\n size_t iflaVtiIKeyPad = fillNlAttrU32(IFLA_VTI_IKEY, ikey, &iflaVtiIKey, &iKeyValue);\n\n    nlattr iflaVtiOKey;\n uint32_t oKeyValue;\n size_t iflaVtiOKeyPad = fillNlAttrU32(IFLA_VTI_OKEY, okey, &iflaVtiOKey, &oKeyValue);\n\n int iflaInfoDataPayloadLength = iflaVtiLocal.nla_len + iflaVtiLocalPad + iflaVtiRemote.nla_len +\n                                    iflaVtiRemotePad + iflaVtiIKey.nla_len + iflaVtiIKeyPad +\n                                    iflaVtiOKey.nla_len + iflaVtiOKeyPad;\n\n    nlattr iflaInfoData;\n size_t iflaInfoDataPad = fillNlAttr(IFLA_INFO_DATA, iflaInfoDataPayloadLength, &iflaInfoData);\n\n    nlattr iflaLinkInfo;\n size_t iflaLinkInfoPad = fillNlAttr(IFLA_LINKINFO,\n                                        iflaInfoData.nla_len + iflaInfoDataPad +\n                                            iflaIfInfoKind.nla_len + iflaIfInfoKindPad,\n &iflaLinkInfo);\n\n    iovec iov[] = {\n {NULL, 0},\n {&ifInfoMsg, sizeof(ifInfoMsg)},\n\n {&iflaIfName, sizeof(iflaIfName)},\n {iflaIfNameStrValue, iflaIfNameLength},\n {&PADDING_BUFFER, iflaIfNamePad},\n\n {&iflaLinkInfo, sizeof(iflaLinkInfo)},\n\n {&iflaIfInfoKind, sizeof(iflaIfInfoKind)},\n {infoKindValueStrValue, iflaIfInfoKindLength},\n {&PADDING_BUFFER, iflaIfInfoKindPad},\n\n {&iflaInfoData, sizeof(iflaInfoData)},\n\n {&iflaVtiLocal, sizeof(iflaVtiLocal)},\n {&binaryLocalAddress, (family == AF_INET) ? sizeof(in_addr) : sizeof(in6_addr)},\n {&PADDING_BUFFER, iflaVtiLocalPad},\n\n {&iflaVtiRemote, sizeof(iflaVtiRemote)},\n {&binaryRemoteAddress, (family == AF_INET) ? sizeof(in_addr) : sizeof(in6_addr)},\n {&PADDING_BUFFER, iflaVtiRemotePad},\n\n {&iflaVtiIKey, sizeof(iflaVtiIKey)},\n {&iKeyValue, sizeof(iKeyValue)},\n {&PADDING_BUFFER, iflaVtiIKeyPad},\n\n {&iflaVtiOKey, sizeof(iflaVtiOKey)},\n {&oKeyValue, sizeof(oKeyValue)},\n {&PADDING_BUFFER, iflaVtiOKeyPad},\n\n {&PADDING_BUFFER, iflaInfoDataPad},\n\n {&PADDING_BUFFER, iflaLinkInfoPad},\n };\n\n uint16_t action = RTM_NEWLINK;\n uint16_t flags = NLM_F_REQUEST | NLM_F_ACK;\n\n if (!isUpdate) {\n        flags |= NLM_F_EXCL | NLM_F_CREATE;\n }\n\n int ret = -1 * sendNetlinkRequest(action, flags, iov, ARRAY_SIZE(iov), nullptr);\n if (ret) {\n        ALOGE(\"Error in %s virtual tunnel interface. Error Code: %d\",\n              isUpdate ? \"updating\" : \"adding\", ret);\n }\n return ret;\n}\n",
        "output": "0",
        "index": 175855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_read_format_iso9660_read_header(struct archive_read *a,\n    struct archive_entry *entry)\n{\n\tstruct iso9660 *iso9660;\n\tstruct file_info *file;\n\tint r, rd_r = ARCHIVE_OK;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\tif (!a->archive.archive_format) {\n\t\ta->archive.archive_format = ARCHIVE_FORMAT_ISO9660;\n\t\ta->archive.archive_format_name = \"ISO9660\";\n\t}\n\n\tif (iso9660->current_position == 0) {\n\t\tr = choose_volume(a, iso9660);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfile = NULL;/* Eliminate a warning. */\n\t/* Get the next entry that appears after the current offset. */\n\tr = next_entry_seek(a, iso9660, &file);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\tif (iso9660->seenJoliet) {\n\t\t/*\n\t\t * Convert UTF-16BE of a filename to local locale MBS\n\t\t * and store the result into a filename field.\n\t\t */\n\t\tif (iso9660->sconv_utf16be == NULL) {\n\t\t\tiso9660->sconv_utf16be =\n\t\t\t    archive_string_conversion_from_charset(\n\t\t\t\t&(a->archive), \"UTF-16BE\", 1);\n\t\t\tif (iso9660->sconv_utf16be == NULL)\n\t\t\t\t/* Coundn't allocate memory */\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\tiso9660->utf16be_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\tiso9660->utf16be_previous_path = malloc(UTF16_NAME_MAX);\n\t\t\tif (iso9660->utf16be_previous_path == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\n\t\tiso9660->utf16be_path_len = 0;\n\t\tif (build_pathname_utf16be(iso9660->utf16be_path,\n\t\t    UTF16_NAME_MAX, &(iso9660->utf16be_path_len), file) != 0) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\tr = archive_entry_copy_pathname_l(entry,\n\t\t    (const char *)iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len,\n\t\t    iso9660->sconv_utf16be);\n\t\tif (r != 0) {\n\t\t\tif (errno == ENOMEM) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"No memory for Pathname\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname cannot be converted \"\n\t\t\t    \"from %s to current locale.\",\n\t\t\t    archive_string_conversion_charset_name(\n\t\t\t      iso9660->sconv_utf16be));\n\n\t\t\trd_r = ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tconst char *path = build_pathname(&iso9660->pathname, file, 0);\n\t\tif (path == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Pathname is too long\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t} else {\n\t\t\tarchive_string_empty(&iso9660->pathname);\n\t\t\tarchive_entry_set_pathname(entry, path);\n\t\t}\n\t}\n\n\tiso9660->entry_bytes_remaining = file->size;\n\t/* Offset for sparse-file-aware clients. */\n\tiso9660->entry_sparse_offset = 0;\n\n\tif (file->offset + file->size > iso9660->volume_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"File is beyond end-of-media: %s\",\n\t\t    archive_entry_pathname(entry));\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* Set up the entry structure with information about this entry. */\n\tarchive_entry_set_mode(entry, file->mode);\n\tarchive_entry_set_uid(entry, file->uid);\n\tarchive_entry_set_gid(entry, file->gid);\n\tarchive_entry_set_nlink(entry, file->nlinks);\n\tif (file->birthtime_is_set)\n\t\tarchive_entry_set_birthtime(entry, file->birthtime, 0);\n\telse\n\t\tarchive_entry_unset_birthtime(entry);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\t/* N.B.: Rock Ridge supports 64-bit device numbers. */\n\tarchive_entry_set_rdev(entry, (dev_t)file->rdev);\n\tarchive_entry_set_size(entry, iso9660->entry_bytes_remaining);\n\tif (file->symlink.s != NULL)\n\t\tarchive_entry_copy_symlink(entry, file->symlink.s);\n\n\t/* Note: If the input isn't seekable, we can't rewind to\n\t * return the same body again, so if the next entry refers to\n\t * the same data, we have to return it as a hardlink to the\n\t * original entry. */\n\tif (file->number != -1 &&\n\t    file->number == iso9660->previous_number) {\n\t\tif (iso9660->seenJoliet) {\n\t\t\tr = archive_entry_copy_hardlink_l(entry,\n\t\t\t    (const char *)iso9660->utf16be_previous_path,\n\t\t\t    iso9660->utf16be_previous_path_len,\n\t\t\t    iso9660->sconv_utf16be);\n\t\t\tif (r != 0) {\n\t\t\t\tif (errno == ENOMEM) {\n\t\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t\t    \"No memory for Linkname\");\n\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Linkname cannot be converted \"\n\t\t\t\t    \"from %s to current locale.\",\n\t\t\t\t    archive_string_conversion_charset_name(\n\t\t\t\t      iso9660->sconv_utf16be));\n\t\t\t\trd_r = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n\t\t\tarchive_entry_set_hardlink(entry,\n\t\t\t    iso9660->previous_pathname.s);\n\t\tarchive_entry_unset_size(entry);\n\t\tiso9660->entry_bytes_remaining = 0;\n\t\treturn (rd_r);\n\t}\n\n\tif ((file->mode & AE_IFMT) != AE_IFDIR &&\n\t    file->offset < iso9660->current_position) {\n\t\tint64_t r64;\n\n\t\tr64 = __archive_read_seek(a, file->offset, SEEK_SET);\n\t\tif (r64 != (int64_t)file->offset) {\n\t\t\t/* We can't seek backwards to extract it, so issue\n\t\t\t * a warning.  Note that this can only happen if\n\t\t\t * this entry was added to the heap after we passed\n\t\t\t * this offset, that is, only if the directory\n\t\t\t * mentioning this entry is later than the body of\n\t\t\t * the entry. Such layouts are very unusual; most\n\t\t\t * ISO9660 writers lay out and record all directory\n\t\t\t * information first, then store all file bodies. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Ignoring out-of-order file @%jx (%s) %jd < %jd\",\n\t\t\t    (intmax_t)file->number,\n\t\t\t    iso9660->pathname.s,\n\t\t\t    (intmax_t)file->offset,\n\t\t\t    (intmax_t)iso9660->current_position);\n\t\t\tiso9660->entry_bytes_remaining = 0;\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tiso9660->current_position = (uint64_t)r64;\n\t}\n\n\t/* Initialize zisofs variables. */\n\tiso9660->entry_zisofs.pz = file->pz;\n\tif (file->pz) {\n#ifdef HAVE_ZLIB_H\n\t\tstruct zisofs  *zisofs;\n\n\t\tzisofs = &iso9660->entry_zisofs;\n\t\tzisofs->initialized = 0;\n\t\tzisofs->pz_log2_bs = file->pz_log2_bs;\n\t\tzisofs->pz_uncompressed_size = file->pz_uncompressed_size;\n\t\tzisofs->pz_offset = 0;\n\t\tzisofs->header_avail = 0;\n\t\tzisofs->header_passed = 0;\n\t\tzisofs->block_pointers_avail = 0;\n#endif\n\t\tarchive_entry_set_size(entry, file->pz_uncompressed_size);\n\t}\n\n\tiso9660->previous_number = file->number;\n\tif (iso9660->seenJoliet) {\n\t\tmemcpy(iso9660->utf16be_previous_path, iso9660->utf16be_path,\n\t\t    iso9660->utf16be_path_len);\n\t\tiso9660->utf16be_previous_path_len = iso9660->utf16be_path_len;\n\t} else\n\t\tarchive_strcpy(\n\t\t    &iso9660->previous_pathname, iso9660->pathname.s);\n\n\t/* Reset entry_bytes_remaining if the file is multi extent. */\n\tiso9660->entry_content = file->contents.first;\n\tif (iso9660->entry_content != NULL)\n\t\tiso9660->entry_bytes_remaining = iso9660->entry_content->size;\n\n\tif (archive_entry_filetype(entry) == AE_IFDIR) {\n\t\t/* Overwrite nlinks by proper link number which is\n\t\t * calculated from number of sub directories. */\n\t\tarchive_entry_set_nlink(entry, 2 + file->subdirs);\n\t\t/* Directory data has been read completely. */\n\t\tiso9660->entry_bytes_remaining = 0;\n\t}\n\n\tif (rd_r != ARCHIVE_OK)\n\t\treturn (rd_r);\n\treturn (ARCHIVE_OK);\n}\n",
        "output": "0",
        "index": 51189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderFrameHostManager::DetermineSiteInstanceForURL(\n    const GURL& dest_url,\n    SiteInstance* source_instance,\n    SiteInstance* current_instance,\n    SiteInstance* dest_instance,\n    ui::PageTransition transition,\n    bool dest_is_restore,\n    bool dest_is_view_source_mode,\n    bool force_browsing_instance_swap,\n    bool was_server_redirect) {\n  SiteInstanceImpl* current_instance_impl =\n      static_cast<SiteInstanceImpl*>(current_instance);\n  NavigationControllerImpl& controller =\n      delegate_->GetControllerForRenderManager();\n  BrowserContext* browser_context = controller.GetBrowserContext();\n\n  if (dest_instance) {\n    if (force_browsing_instance_swap) {\n      CHECK(!dest_instance->IsRelatedSiteInstance(\n                render_frame_host_->GetSiteInstance()));\n    }\n    return SiteInstanceDescriptor(dest_instance);\n  }\n\n  if (force_browsing_instance_swap)\n    return SiteInstanceDescriptor(browser_context, dest_url,\n                                  SiteInstanceRelation::UNRELATED);\n\n  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kProcessPerSite) &&\n      ui::PageTransitionCoreTypeIs(transition, ui::PAGE_TRANSITION_GENERATED)) {\n    return SiteInstanceDescriptor(current_instance_impl);\n  }\n\n  if (!frame_tree_node_->IsMainFrame()) {\n    SiteInstance* parent_site_instance =\n        frame_tree_node_->parent()->current_frame_host()->GetSiteInstance();\n    if (GetContentClient()->browser()->ShouldStayInParentProcessForNTP(\n            dest_url, parent_site_instance)) {\n      return SiteInstanceDescriptor(parent_site_instance);\n    }\n  }\n\n  if (!current_instance_impl->HasSite()) {\n    bool use_process_per_site =\n        RenderProcessHost::ShouldUseProcessPerSite(browser_context, dest_url) &&\n        RenderProcessHostImpl::GetProcessHostForSite(browser_context, dest_url);\n    if (current_instance_impl->HasRelatedSiteInstance(dest_url) ||\n        use_process_per_site) {\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::RELATED);\n    }\n\n    if (current_instance_impl->HasWrongProcessForURL(dest_url))\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::RELATED);\n\n    if (dest_is_view_source_mode)\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::UNRELATED);\n\n    if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(\n            browser_context, dest_url)) {\n      return SiteInstanceDescriptor(browser_context, dest_url,\n                                    SiteInstanceRelation::UNRELATED);\n    }\n\n    if (dest_is_restore && SiteInstanceImpl::ShouldAssignSiteForURL(dest_url))\n      current_instance_impl->SetSite(dest_url);\n\n    return SiteInstanceDescriptor(current_instance_impl);\n  }\n\n\n  NavigationEntry* current_entry = controller.GetLastCommittedEntry();\n  if (delegate_->GetInterstitialForRenderManager()) {\n    current_entry = controller.GetEntryAtOffset(-1);\n  }\n\n  if (current_entry &&\n      current_entry->IsViewSourceMode() != dest_is_view_source_mode &&\n      !IsRendererDebugURL(dest_url)) {\n    return SiteInstanceDescriptor(browser_context, dest_url,\n                                  SiteInstanceRelation::UNRELATED);\n  }\n\n  GURL about_blank(url::kAboutBlankURL);\n  GURL about_srcdoc(content::kAboutSrcDocURL);\n  bool dest_is_data_or_about = dest_url == about_srcdoc ||\n                               dest_url == about_blank ||\n                               dest_url.scheme() == url::kDataScheme;\n  if (source_instance && dest_is_data_or_about && !was_server_redirect)\n    return SiteInstanceDescriptor(source_instance);\n\n  if (IsCurrentlySameSite(render_frame_host_.get(), dest_url))\n    return SiteInstanceDescriptor(render_frame_host_->GetSiteInstance());\n\n  if (!frame_tree_node_->IsMainFrame()) {\n    RenderFrameHostImpl* main_frame =\n        frame_tree_node_->frame_tree()->root()->current_frame_host();\n    if (IsCurrentlySameSite(main_frame, dest_url))\n      return SiteInstanceDescriptor(main_frame->GetSiteInstance());\n    RenderFrameHostImpl* parent =\n        frame_tree_node_->parent()->current_frame_host();\n    if (IsCurrentlySameSite(parent, dest_url))\n      return SiteInstanceDescriptor(parent->GetSiteInstance());\n  }\n  if (frame_tree_node_->opener()) {\n    RenderFrameHostImpl* opener_frame =\n        frame_tree_node_->opener()->current_frame_host();\n    if (IsCurrentlySameSite(opener_frame, dest_url))\n      return SiteInstanceDescriptor(opener_frame->GetSiteInstance());\n  }\n\n  if (!frame_tree_node_->IsMainFrame() &&\n      SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&\n      !SiteInstanceImpl::DoesSiteRequireDedicatedProcess(browser_context,\n                                                         dest_url)) {\n    if (GetContentClient()\n            ->browser()\n            ->ShouldFrameShareParentSiteInstanceDespiteTopDocumentIsolation(\n                dest_url, current_instance)) {\n      return SiteInstanceDescriptor(render_frame_host_->GetSiteInstance());\n    }\n\n    return SiteInstanceDescriptor(\n        browser_context, dest_url,\n        SiteInstanceRelation::RELATED_DEFAULT_SUBFRAME);\n  }\n\n  if (!frame_tree_node_->IsMainFrame()) {\n    RenderFrameHostImpl* parent =\n        frame_tree_node_->parent()->current_frame_host();\n    bool dest_url_requires_dedicated_process =\n        SiteInstanceImpl::DoesSiteRequireDedicatedProcess(browser_context,\n                                                          dest_url);\n    if (!parent->GetSiteInstance()->RequiresDedicatedProcess() &&\n        !dest_url_requires_dedicated_process) {\n      return SiteInstanceDescriptor(parent->GetSiteInstance());\n    }\n  }\n\n  return SiteInstanceDescriptor(browser_context, dest_url,\n                                SiteInstanceRelation::RELATED);\n}\n",
        "output": "0",
        "index": 159634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"BoundingBox:\"\n#define BeginDocument  \"BeginDocument:\"\n#define BeginXMPPacket  \"<?xpacket begin=\"\n#define EndXMPPacket  \"<?xpacket end=\"\n#define ICCProfile \"BeginICCProfile:\"\n#define CMYKCustomColor  \"CMYKCustomColor:\"\n#define CMYKProcessColor  \"CMYKProcessColor:\"\n#define DocumentMedia  \"DocumentMedia:\"\n#define DocumentCustomColors  \"DocumentCustomColors:\"\n#define DocumentProcessColors  \"DocumentProcessColors:\"\n#define EndDocument  \"EndDocument:\"\n#define HiResBoundingBox  \"HiResBoundingBox:\"\n#define ImageData  \"ImageData:\"\n#define PageBoundingBox  \"PageBoundingBox:\"\n#define LanguageLevel  \"LanguageLevel:\"\n#define PageMedia  \"PageMedia:\"\n#define Pages  \"Pages:\"\n#define PhotoshopProfile  \"BeginPhotoshop:\"\n#define PostscriptLevel  \"!PS-\"\n#define RenderPostscriptText  \"  Rendering Postscript...  \"\n#define SpotColor  \"+ \"\n\n  char\n    command[MaxTextExtent],\n    *density,\n    filename[MaxTextExtent],\n    geometry[MaxTextExtent],\n    input_filename[MaxTextExtent],\n    message[MaxTextExtent],\n    *options,\n    postscript_filename[MaxTextExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *postscript_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    file;\n\n  MagickBooleanType\n    cmyk,\n    fitPage,\n    skip,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PointInfo\n    delta,\n    resolution;\n\n  RectangleInfo\n    page;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  SegmentInfo\n    bounds,\n    hires_bounds;\n\n  short int\n    hex_digits[256];\n\n  size_t\n    length,\n    priority;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned long\n    columns,\n    extent,\n    language_level,\n    pages,\n    rows,\n    scene,\n    spotcolor;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Initialize hex values.\n  */\n  (void) ResetMagickMemory(hex_digits,0,sizeof(hex_digits));\n  hex_digits[(int) '0']=0;\n  hex_digits[(int) '1']=1;\n  hex_digits[(int) '2']=2;\n  hex_digits[(int) '3']=3;\n  hex_digits[(int) '4']=4;\n  hex_digits[(int) '5']=5;\n  hex_digits[(int) '6']=6;\n  hex_digits[(int) '7']=7;\n  hex_digits[(int) '8']=8;\n  hex_digits[(int) '9']=9;\n  hex_digits[(int) 'a']=10;\n  hex_digits[(int) 'b']=11;\n  hex_digits[(int) 'c']=12;\n  hex_digits[(int) 'd']=13;\n  hex_digits[(int) 'e']=14;\n  hex_digits[(int) 'f']=15;\n  hex_digits[(int) 'A']=10;\n  hex_digits[(int) 'B']=11;\n  hex_digits[(int) 'C']=12;\n  hex_digits[(int) 'D']=13;\n  hex_digits[(int) 'E']=14;\n  hex_digits[(int) 'F']=15;\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  resolution.x=image->x_resolution;\n  resolution.y=image->y_resolution;\n  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);\n  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);\n  /*\n    Determine page geometry from the Postscript bounding box.\n  */\n  (void) ResetMagickMemory(&bounds,0,sizeof(bounds));\n  (void) ResetMagickMemory(command,0,sizeof(command));\n  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;\n  (void) ResetMagickMemory(&hires_bounds,0,sizeof(hires_bounds));\n  priority=0;\n  columns=0;\n  rows=0;\n  extent=0;\n  spotcolor=0;\n  language_level=1;\n  skip=MagickFalse;\n  pages=(~0UL);\n  p=command;\n  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))\n  {\n    /*\n      Note document structuring comments.\n    */\n    *p++=(char) c;\n    if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n        ((size_t) (p-command) < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n      Skip %%BeginDocument thru %%EndDocument.\n    */\n    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)\n      skip=MagickTrue;\n    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)\n      skip=MagickFalse;\n    if (skip != MagickFalse)\n      continue;\n    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)\n      {\n        (void) SetImageProperty(image,\"ps:Level\",command+4);\n        if (GlobExpression(command,\"*EPSF-*\",MagickTrue) != MagickFalse)\n          pages=1;\n      }\n    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)\n      (void) sscanf(command,LanguageLevel \" %lu\",&language_level);\n    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)\n      (void) sscanf(command,Pages \" %lu\",&pages);\n    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)\n      (void) sscanf(command,ImageData \" %lu %lu\",&columns,&rows);\n    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)\n      {\n        unsigned char\n          *datum;\n\n        /*\n          Read ICC profile.\n        */\n        profile=AcquireStringInfo(MaxTextExtent);\n        datum=GetStringInfoDatum(profile);\n        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)\n        {\n          if (i >= (ssize_t) GetStringInfoLength(profile))\n            {\n              SetStringInfoLength(profile,(size_t) i << 1);\n              datum=GetStringInfoDatum(profile);\n            }\n          datum[i]=(unsigned char) c;\n        }\n        SetStringInfoLength(profile,(size_t) i+1);\n        (void) SetImageProfile(image,\"icc\",profile);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)\n      {\n        unsigned char\n          *p;\n\n        /*\n          Read Photoshop profile.\n        */\n        count=(ssize_t) sscanf(command,PhotoshopProfile \" %lu\",&extent);\n         if (count != 1)\n           continue;\n         length=extent;\n         profile=BlobToStringInfo((const void *) NULL,length);\n         if (profile != (StringInfo *) NULL)\n           {\n            p=GetStringInfoDatum(profile);\n            for (i=0; i < (ssize_t) length; i++)\n              *p++=(unsigned char) ProfileInteger(image,hex_digits);\n            (void) SetImageProfile(image,\"8bim\",profile);\n            profile=DestroyStringInfo(profile);\n          }\n        continue;\n      }\n    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)\n      {\n        register size_t\n          i;\n\n        /*\n          Read XMP profile.\n        */\n        p=command;\n        profile=StringToStringInfo(command);\n        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)\n        {\n          SetStringInfoLength(profile,i+1);\n          c=ReadBlobByte(image);\n          GetStringInfoDatum(profile)[i]=(unsigned char) c;\n          *p++=(char) c;\n          if ((strchr(\"\\n\\r%\",c) == (char *) NULL) &&\n              ((size_t) (p-command) < (MaxTextExtent-1)))\n            continue;\n          *p='\\0';\n          p=command;\n          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)\n            break;\n        }\n        SetStringInfoLength(profile,i);\n        (void) SetImageProfile(image,\"xmp\",profile);\n        profile=DestroyStringInfo(profile);\n        continue;\n      }\n    /*\n      Is this a CMYK document?\n    */\n    length=strlen(DocumentProcessColors);\n    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)\n      {\n        if ((GlobExpression(command,\"*Cyan*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Magenta*\",MagickTrue) != MagickFalse) ||\n            (GlobExpression(command,\"*Yellow*\",MagickTrue) != MagickFalse))\n          cmyk=MagickTrue;\n      }\n    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)\n      cmyk=MagickTrue;\n    length=strlen(DocumentCustomColors);\n    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||\n        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||\n        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))\n      {\n        char\n          property[MaxTextExtent],\n          *value;\n\n        register char\n          *p;\n\n        /*\n          Note spot names.\n        */\n        (void) FormatLocaleString(property,MaxTextExtent,\"ps:SpotColor-%.20g\",\n          (double) (spotcolor++));\n        for (p=command; *p != '\\0'; p++)\n          if (isspace((int) (unsigned char) *p) != 0)\n            break;\n        value=AcquireString(p);\n        (void) SubstituteString(&value,\"(\",\"\");\n        (void) SubstituteString(&value,\")\",\"\");\n        (void) StripString(value);\n        (void) SetImageProperty(image,property,value);\n        value=DestroyString(value);\n        continue;\n      }\n    if (image_info->page != (char *) NULL)\n      continue;\n    /*\n      Note region defined by bounding box.\n    */\n    count=0;\n    i=0;\n    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,BoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=2;\n      }\n    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,DocumentMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,HiResBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=3;\n      }\n    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageBoundingBox \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)\n      {\n        count=(ssize_t) sscanf(command,PageMedia \" %lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        i=1;\n      }\n    if ((count != 4) || (i < (ssize_t) priority))\n      continue;\n    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||\n        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))\n      if (i == (ssize_t) priority)\n        continue;\n    hires_bounds=bounds;\n    priority=i;\n  }\n  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&\n      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))\n    {\n      /*\n        Set Postscript render geometry.\n      */\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%gx%g%+.15g%+.15g\",\n        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,\n        hires_bounds.x1,hires_bounds.y1);\n      (void) SetImageProperty(image,\"ps:HiResBoundingBox\",geometry);\n      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*\n        resolution.x/delta.x)-0.5);\n      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*\n        resolution.y/delta.y)-0.5);\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"eps:fit-page\");\n  if (option != (char *) NULL)\n  {\n    char\n      *geometry;\n\n    MagickStatusType\n      flags;\n\n    geometry=GetPageGeometry(option);\n    flags=ParseMetaGeometry(geometry,&page.x,&page.y,&page.width,&page.height);\n    if (flags == NoValue)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n          \"InvalidGeometry\",\"`%s'\",option);\n        image=DestroyImage(image);\n        return((Image *) NULL);\n      }\n    page.width=(size_t) ceil((double) (page.width*image->x_resolution/delta.x)\n      -0.5);\n    page.height=(size_t) ceil((double) (page.height*image->y_resolution/\n      delta.y) -0.5);\n    geometry=DestroyString(geometry);\n    fitPage=MagickTrue;\n  }\n  (void) CloseBlob(image);\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      ThrowFileException(&image->exception,FileOpenError,\"UnableToOpenFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CopyMagickString(command,\"/setpagedevice {pop} bind 1 index where {\"\n    \"dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\\n\"\n    \"<</UseCIEColor true>>setpagedevice\\n\",MaxTextExtent);\n  count=write(file,command,(unsigned int) strlen(command));\n  if (image_info->page == (char *) NULL)\n    {\n      char\n        translate_geometry[MaxTextExtent];\n\n      (void) FormatLocaleString(translate_geometry,MaxTextExtent,\n        \"%g %g translate\\n\",-hires_bounds.x1,-hires_bounds.y1);\n      count=write(file,translate_geometry,(unsigned int)\n        strlen(translate_geometry));\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n    if (cmyk != MagickFalse)\n      delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n    else\n      delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"%gx%g\",resolution.x,\n    resolution.y);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g \",(double)\n    page.width,(double) page.height);\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MaxTextExtent];\n\n      (void) FormatLocaleString(pages,MaxTextExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g \",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MaxTextExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  if (*image_info->magick == 'E')\n    {\n      option=GetImageOption(image_info,\"eps:use-cropbox\");\n      if ((option == (const char *) NULL) ||\n          (IsStringTrue(option) != MagickFalse))\n        (void) ConcatenateMagickString(options,\"-dEPSCrop \",MaxTextExtent);\n      if (fitPage != MagickFalse)\n        (void) ConcatenateMagickString(options,\"-dEPSFitPage \",MaxTextExtent);\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MaxTextExtent);\n  (void) FormatLocaleString(command,MaxTextExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);\n  (void) InterpretImageFilename(image_info,image,filename,1,\n    read_info->filename);\n  if ((status == MagickFalse) ||\n      (IsPostscriptRendered(read_info->filename) == MagickFalse))\n    {\n      (void) ConcatenateMagickString(command,\" -c showpage\",MaxTextExtent);\n      status=InvokePostscriptDelegate(read_info->verbose,command,message,\n        exception);\n    }\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  postscript_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename);\n      if (IsPostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      read_info->blob=NULL;\n      read_info->length=0;\n      next=ReadImage(read_info,exception);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      if (next == (Image *) NULL)\n        break;\n      AppendImageToList(&postscript_image,next);\n    }\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (postscript_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PostscriptDelegateFailed\",\"`%s'\",message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(postscript_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          postscript_image=DestroyImageList(postscript_image);\n          postscript_image=cmyk_image;\n        }\n    }\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      register ssize_t\n        i;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&postscript_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(postscript_image->filename,filename,MaxTextExtent);\n    (void) CopyMagickString(postscript_image->magick,image->magick,\n      MaxTextExtent);\n    if (columns != 0)\n      postscript_image->magick_columns=columns;\n    if (rows != 0)\n      postscript_image->magick_rows=rows;\n    postscript_image->page=page;\n    (void) CloneImageProfiles(postscript_image,image);\n    (void) CloneImageProperties(postscript_image,image);\n    next=SyncNextImageInList(postscript_image);\n    if (next != (Image *) NULL)\n      postscript_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImageList(image);\n  scene=0;\n  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(postscript_image));\n}\n",
        "output": "1",
        "index": 180934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\n                size_t num, const EC_POINT *points[], const BIGNUM *scalars[],\n                BN_CTX *ctx)\n{\n    BN_CTX *new_ctx = NULL;\n    const EC_POINT *generator = NULL;\n    EC_POINT *tmp = NULL;\n    size_t totalnum;\n    size_t blocksize = 0, numblocks = 0; /* for wNAF splitting */\n    size_t pre_points_per_block = 0;\n    size_t i, j;\n    int k;\n    int r_is_inverted = 0;\n    int r_is_at_infinity = 1;\n    size_t *wsize = NULL;       /* individual window sizes */\n    signed char **wNAF = NULL;  /* individual wNAFs */\n    size_t *wNAF_len = NULL;\n    size_t max_len = 0;\n    size_t num_val;\n    EC_POINT **val = NULL;      /* precomputation */\n    EC_POINT **v;\n    EC_POINT ***val_sub = NULL; /* pointers to sub-arrays of 'val' or\n                                 * 'pre_comp->points' */\n    const EC_PRE_COMP *pre_comp = NULL;\n    int num_scalar = 0;         /* flag: will be set to 1 if 'scalar' must be\n                                 * treated like other scalars, i.e.\n                                 * precomputation is not available */\n    int ret = 0;\n\n    if (!ec_point_is_compat(r, group)) {\n        ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\n        return 0;\n    }\n\n    if ((scalar == NULL) && (num == 0)) {\n        return EC_POINT_set_to_infinity(group, r);\n    }\n\n    if (!BN_is_zero(group->order) && !BN_is_zero(group->cofactor)) {\n        /*-\n         * Handle the common cases where the scalar is secret, enforcing a constant\n         * time scalar multiplication algorithm.\n         */\n        if ((scalar != NULL) && (num == 0)) {\n            /*-\n             * In this case we want to compute scalar * GeneratorPoint: this\n             * codepath is reached most prominently by (ephemeral) key generation\n             * of EC cryptosystems (i.e. ECDSA keygen and sign setup, ECDH\n             * keygen/first half), where the scalar is always secret. This is why\n             * we ignore if BN_FLG_CONSTTIME is actually set and we always call the\n             * constant time version.\n             */\n            return ec_mul_consttime(group, r, scalar, NULL, ctx);\n        }\n        if ((scalar == NULL) && (num == 1)) {\n            /*-\n             * In this case we want to compute scalar * GenericPoint: this codepath\n             * is reached most prominently by the second half of ECDH, where the\n             * secret scalar is multiplied by the peer's public point. To protect\n             * the secret scalar, we ignore if BN_FLG_CONSTTIME is actually set and\n             * we always call the constant time version.\n             */\n            return ec_mul_consttime(group, r, scalars[0], points[0], ctx);\n        }\n    }\n\n    for (i = 0; i < num; i++) {\n        if (!ec_point_is_compat(points[i], group)) {\n            ECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\n            return 0;\n        }\n    }\n\n    if (ctx == NULL) {\n        ctx = new_ctx = BN_CTX_new();\n        if (ctx == NULL)\n            goto err;\n    }\n\n    if (scalar != NULL) {\n        generator = EC_GROUP_get0_generator(group);\n        if (generator == NULL) {\n            ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);\n            goto err;\n        }\n\n        /* look if we can use precomputed multiples of generator */\n\n        pre_comp = group->pre_comp.ec;\n        if (pre_comp && pre_comp->numblocks\n            && (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) ==\n                0)) {\n            blocksize = pre_comp->blocksize;\n\n            /*\n             * determine maximum number of blocks that wNAF splitting may\n             * yield (NB: maximum wNAF length is bit length plus one)\n             */\n            numblocks = (BN_num_bits(scalar) / blocksize) + 1;\n\n            /*\n             * we cannot use more blocks than we have precomputation for\n             */\n            if (numblocks > pre_comp->numblocks)\n                numblocks = pre_comp->numblocks;\n\n            pre_points_per_block = (size_t)1 << (pre_comp->w - 1);\n\n            /* check that pre_comp looks sane */\n            if (pre_comp->num != (pre_comp->numblocks * pre_points_per_block)) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        } else {\n            /* can't use precomputation */\n            pre_comp = NULL;\n            numblocks = 1;\n            num_scalar = 1;     /* treat 'scalar' like 'num'-th element of\n                                 * 'scalars' */\n        }\n    }\n\n    totalnum = num + numblocks;\n\n    wsize = OPENSSL_malloc(totalnum * sizeof(wsize[0]));\n    wNAF_len = OPENSSL_malloc(totalnum * sizeof(wNAF_len[0]));\n    /* include space for pivot */\n    wNAF = OPENSSL_malloc((totalnum + 1) * sizeof(wNAF[0]));\n    val_sub = OPENSSL_malloc(totalnum * sizeof(val_sub[0]));\n\n    /* Ensure wNAF is initialised in case we end up going to err */\n    if (wNAF != NULL)\n        wNAF[0] = NULL;         /* preliminary pivot */\n\n    if (wsize == NULL || wNAF_len == NULL || wNAF == NULL || val_sub == NULL) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    /*\n     * num_val will be the total number of temporarily precomputed points\n     */\n    num_val = 0;\n\n    for (i = 0; i < num + num_scalar; i++) {\n        size_t bits;\n\n        bits = i < num ? BN_num_bits(scalars[i]) : BN_num_bits(scalar);\n        wsize[i] = EC_window_bits_for_scalar_size(bits);\n        num_val += (size_t)1 << (wsize[i] - 1);\n        wNAF[i + 1] = NULL;     /* make sure we always have a pivot */\n        wNAF[i] =\n            bn_compute_wNAF((i < num ? scalars[i] : scalar), wsize[i],\n                            &wNAF_len[i]);\n        if (wNAF[i] == NULL)\n            goto err;\n        if (wNAF_len[i] > max_len)\n            max_len = wNAF_len[i];\n    }\n\n    if (numblocks) {\n        /* we go here iff scalar != NULL */\n\n        if (pre_comp == NULL) {\n            if (num_scalar != 1) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            /* we have already generated a wNAF for 'scalar' */\n        } else {\n            signed char *tmp_wNAF = NULL;\n            size_t tmp_len = 0;\n\n            if (num_scalar != 0) {\n                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            /*\n             * use the window size for which we have precomputation\n             */\n            wsize[num] = pre_comp->w;\n            tmp_wNAF = bn_compute_wNAF(scalar, wsize[num], &tmp_len);\n            if (!tmp_wNAF)\n                goto err;\n\n            if (tmp_len <= max_len) {\n                /*\n                 * One of the other wNAFs is at least as long as the wNAF\n                 * belonging to the generator, so wNAF splitting will not buy\n                 * us anything.\n                 */\n\n                numblocks = 1;\n                totalnum = num + 1; /* don't use wNAF splitting */\n                wNAF[num] = tmp_wNAF;\n                wNAF[num + 1] = NULL;\n                wNAF_len[num] = tmp_len;\n                /*\n                 * pre_comp->points starts with the points that we need here:\n                 */\n                val_sub[num] = pre_comp->points;\n            } else {\n                /*\n                 * don't include tmp_wNAF directly into wNAF array - use wNAF\n                 * splitting and include the blocks\n                 */\n\n                signed char *pp;\n                EC_POINT **tmp_points;\n\n                if (tmp_len < numblocks * blocksize) {\n                    /*\n                     * possibly we can do with fewer blocks than estimated\n                     */\n                    numblocks = (tmp_len + blocksize - 1) / blocksize;\n                    if (numblocks > pre_comp->numblocks) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    totalnum = num + numblocks;\n                }\n\n                /* split wNAF in 'numblocks' parts */\n                pp = tmp_wNAF;\n                tmp_points = pre_comp->points;\n\n                for (i = num; i < totalnum; i++) {\n                    if (i < totalnum - 1) {\n                        wNAF_len[i] = blocksize;\n                        if (tmp_len < blocksize) {\n                            ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                            OPENSSL_free(tmp_wNAF);\n                            goto err;\n                        }\n                        tmp_len -= blocksize;\n                    } else\n                        /*\n                         * last block gets whatever is left (this could be\n                         * more or less than 'blocksize'!)\n                         */\n                        wNAF_len[i] = tmp_len;\n\n                    wNAF[i + 1] = NULL;\n                    wNAF[i] = OPENSSL_malloc(wNAF_len[i]);\n                    if (wNAF[i] == NULL) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    memcpy(wNAF[i], pp, wNAF_len[i]);\n                    if (wNAF_len[i] > max_len)\n                        max_len = wNAF_len[i];\n\n                    if (*tmp_points == NULL) {\n                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n                        OPENSSL_free(tmp_wNAF);\n                        goto err;\n                    }\n                    val_sub[i] = tmp_points;\n                    tmp_points += pre_points_per_block;\n                    pp += blocksize;\n                }\n                OPENSSL_free(tmp_wNAF);\n            }\n        }\n    }\n\n    /*\n     * All points we precompute now go into a single array 'val'.\n     * 'val_sub[i]' is a pointer to the subarray for the i-th point, or to a\n     * subarray of 'pre_comp->points' if we already have precomputation.\n     */\n    val = OPENSSL_malloc((num_val + 1) * sizeof(val[0]));\n    if (val == NULL) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    val[num_val] = NULL;        /* pivot element */\n\n    /* allocate points for precomputation */\n    v = val;\n    for (i = 0; i < num + num_scalar; i++) {\n        val_sub[i] = v;\n        for (j = 0; j < ((size_t)1 << (wsize[i] - 1)); j++) {\n            *v = EC_POINT_new(group);\n            if (*v == NULL)\n                goto err;\n            v++;\n        }\n    }\n    if (!(v == val + num_val)) {\n        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if ((tmp = EC_POINT_new(group)) == NULL)\n        goto err;\n\n    /*-\n     * prepare precomputed values:\n     *    val_sub[i][0] :=     points[i]\n     *    val_sub[i][1] := 3 * points[i]\n     *    val_sub[i][2] := 5 * points[i]\n     *    ...\n     */\n    for (i = 0; i < num + num_scalar; i++) {\n        if (i < num) {\n            if (!EC_POINT_copy(val_sub[i][0], points[i]))\n                goto err;\n        } else {\n            if (!EC_POINT_copy(val_sub[i][0], generator))\n                goto err;\n        }\n\n        if (wsize[i] > 1) {\n            if (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx))\n                goto err;\n            for (j = 1; j < ((size_t)1 << (wsize[i] - 1)); j++) {\n                if (!EC_POINT_add\n                    (group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx))\n                    goto err;\n            }\n        }\n    }\n\n    if (!EC_POINTs_make_affine(group, num_val, val, ctx))\n        goto err;\n\n    r_is_at_infinity = 1;\n\n    for (k = max_len - 1; k >= 0; k--) {\n        if (!r_is_at_infinity) {\n            if (!EC_POINT_dbl(group, r, r, ctx))\n                goto err;\n        }\n\n        for (i = 0; i < totalnum; i++) {\n            if (wNAF_len[i] > (size_t)k) {\n                int digit = wNAF[i][k];\n                int is_neg;\n\n                if (digit) {\n                    is_neg = digit < 0;\n\n                    if (is_neg)\n                        digit = -digit;\n\n                    if (is_neg != r_is_inverted) {\n                        if (!r_is_at_infinity) {\n                            if (!EC_POINT_invert(group, r, ctx))\n                                goto err;\n                        }\n                        r_is_inverted = !r_is_inverted;\n                    }\n\n                    /* digit > 0 */\n\n                    if (r_is_at_infinity) {\n                        if (!EC_POINT_copy(r, val_sub[i][digit >> 1]))\n                            goto err;\n                        r_is_at_infinity = 0;\n                    } else {\n                        if (!EC_POINT_add\n                            (group, r, r, val_sub[i][digit >> 1], ctx))\n                            goto err;\n                    }\n                }\n            }\n        }\n    }\n\n    if (r_is_at_infinity) {\n        if (!EC_POINT_set_to_infinity(group, r))\n            goto err;\n    } else {\n        if (r_is_inverted)\n            if (!EC_POINT_invert(group, r, ctx))\n                goto err;\n    }\n\n    ret = 1;\n\n err:\n    BN_CTX_free(new_ctx);\n    EC_POINT_free(tmp);\n    OPENSSL_free(wsize);\n    OPENSSL_free(wNAF_len);\n    if (wNAF != NULL) {\n        signed char **w;\n\n        for (w = wNAF; *w != NULL; w++)\n            OPENSSL_free(*w);\n\n        OPENSSL_free(wNAF);\n    }\n    if (val != NULL) {\n        for (v = val; *v != NULL; v++)\n            EC_POINT_clear_free(*v);\n\n        OPENSSL_free(val);\n    }\n    OPENSSL_free(val_sub);\n    return ret;\n}\n",
        "output": "0",
        "index": 15379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void findBigKeys(void) {\n    unsigned long long biggest[TYPE_COUNT] = {0}, counts[TYPE_COUNT] = {0}, totalsize[TYPE_COUNT] = {0};\n    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;\n    sds maxkeys[TYPE_COUNT] = {0};\n    char *typename[] = {\"string\",\"list\",\"set\",\"hash\",\"zset\",\"stream\",\"none\"};\n    char *typeunit[] = {\"bytes\",\"items\",\"members\",\"fields\",\"members\",\"entries\",\"\"};\n    redisReply *reply, *keys;\n    unsigned int arrsize=0, i;\n    int type, *types=NULL;\n    double pct;\n\n    /* Total keys pre scanning */\n    total_keys = getDbSize();\n\n    /* Status message */\n    printf(\"\\n# Scanning the entire keyspace to find biggest keys as well as\\n\");\n    printf(\"# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\\n\");\n    printf(\"# per 100 SCAN commands (not usually needed).\\n\\n\");\n\n    /* New up sds strings to keep track of overall biggest per type */\n    for(i=0;i<TYPE_NONE; i++) {\n        maxkeys[i] = sdsempty();\n        if(!maxkeys[i]) {\n            fprintf(stderr, \"Failed to allocate memory for largest key names!\\n\");\n            exit(1);\n        }\n    }\n\n    /* SCAN loop */\n    do {\n        /* Calculate approximate percentage completion */\n        pct = 100 * (double)sampled/total_keys;\n\n        /* Grab some keys and point to the keys array */\n        reply = sendScan(&it);\n        keys  = reply->element[1];\n\n        /* Reallocate our type and size array if we need to */\n        if(keys->elements > arrsize) {\n            types = zrealloc(types, sizeof(int)*keys->elements);\n            sizes = zrealloc(sizes, sizeof(unsigned long long)*keys->elements);\n\n            if(!types || !sizes) {\n                fprintf(stderr, \"Failed to allocate storage for keys!\\n\");\n                exit(1);\n            }\n\n            arrsize = keys->elements;\n        }\n\n        /* Retreive types and then sizes */\n        getKeyTypes(keys, types);\n        getKeySizes(keys, types, sizes);\n\n        /* Now update our stats */\n        for(i=0;i<keys->elements;i++) {\n            if((type = types[i]) == TYPE_NONE)\n                continue;\n\n            totalsize[type] += sizes[i];\n            counts[type]++;\n            totlen += keys->element[i]->len;\n            sampled++;\n\n            if(biggest[type]<sizes[i]) {\n                printf(\n                   \"[%05.2f%%] Biggest %-6s found so far '%s' with %llu %s\\n\",\n                   pct, typename[type], keys->element[i]->str, sizes[i],\n                   typeunit[type]);\n\n                /* Keep track of biggest key name for this type */\n                maxkeys[type] = sdscpy(maxkeys[type], keys->element[i]->str);\n                if(!maxkeys[type]) {\n                    fprintf(stderr, \"Failed to allocate memory for key!\\n\");\n                    exit(1);\n                }\n\n                /* Keep track of the biggest size for this type */\n                biggest[type] = sizes[i];\n            }\n\n            /* Update overall progress */\n            if(sampled % 1000000 == 0) {\n                printf(\"[%05.2f%%] Sampled %llu keys so far\\n\", pct, sampled);\n            }\n        }\n\n        /* Sleep if we've been directed to do so */\n        if(sampled && (sampled %100) == 0 && config.interval) {\n            usleep(config.interval);\n        }\n\n        freeReplyObject(reply);\n    } while(it != 0);\n\n    if(types) zfree(types);\n    if(sizes) zfree(sizes);\n\n    /* We're done */\n    printf(\"\\n-------- summary -------\\n\\n\");\n\n    printf(\"Sampled %llu keys in the keyspace!\\n\", sampled);\n    printf(\"Total key length in bytes is %llu (avg len %.2f)\\n\\n\",\n       totlen, totlen ? (double)totlen/sampled : 0);\n\n    /* Output the biggest keys we found, for types we did find */\n    for(i=0;i<TYPE_NONE;i++) {\n        if(sdslen(maxkeys[i])>0) {\n            printf(\"Biggest %6s found '%s' has %llu %s\\n\", typename[i], maxkeys[i],\n               biggest[i], typeunit[i]);\n        }\n    }\n\n    printf(\"\\n\");\n\n    for(i=0;i<TYPE_NONE;i++) {\n        printf(\"%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\\n\",\n           counts[i], typename[i], totalsize[i], typeunit[i],\n           sampled ? 100 * (double)counts[i]/sampled : 0,\n           counts[i] ? (double)totalsize[i]/counts[i] : 0);\n    }\n\n    /* Free sds strings containing max keys */\n    for(i=0;i<TYPE_NONE;i++) {\n        sdsfree(maxkeys[i]);\n    }\n\n    /* Success! */\n    exit(0);\n}\n",
        "output": "0",
        "index": 81956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                     const char *ptr, const char *end, STRING_POOL *pool) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  for (;;) {\n    const char *next;\n    int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n    switch (tok) {\n    case XML_TOK_NONE:\n      return XML_ERROR_NONE;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, ptr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BAD_CHAR_REF;\n      }\n      if (! isCdata && n == 0x20 /* space */\n          && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (! poolAppendChar(pool, buf[i]))\n          return XML_ERROR_NO_MEMORY;\n      }\n    } break;\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, ptr, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = ptr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_ATTRIBUTE_VALUE_S:\n    case XML_TOK_DATA_NEWLINE:\n      if (! isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      if (! poolAppendChar(pool, 0x20))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      char checkEntityDecl;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n        if (! poolAppendChar(pool, ch))\n          return XML_ERROR_NO_MEMORY;\n        break;\n      }\n      name = poolStoreString(&parser->m_temp2Pool, enc,\n                             ptr + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&parser->m_temp2Pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal.\n      */\n      if (pool == &dtd->pool) /* are we called from prolog? */\n        checkEntityDecl =\n#ifdef XML_DTD\n            parser->m_prologState.documentEntity &&\n#endif /* XML_DTD */\n            (dtd->standalone ? ! parser->m_openInternalEntities\n                             : ! dtd->hasParamEntityRefs);\n      else /* if (pool == &parser->m_tempPool): we are called from content */\n        checkEntityDecl = ! dtd->hasParamEntityRefs || dtd->standalone;\n      if (checkEntityDecl) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        /* Cannot report skipped entity here - see comments on\n           parser->m_skippedEntityHandler.\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        */\n        /* Cannot call the default handler because this would be\n           out of sync with the call to the startElementHandler.\n        if ((pool == &parser->m_tempPool) && parser->m_defaultHandler)\n          reportDefault(parser, enc, ptr, next);\n        */\n        break;\n      }\n      if (entity->open) {\n        if (enc == parser->m_encoding) {\n          /* It does not appear that this line can be executed.\n           *\n           * The \"if (entity->open)\" check catches recursive entity\n           * definitions.  In order to be called with an open\n           * entity, it must have gone through this code before and\n           * been through the recursive call to\n           * appendAttributeValue() some lines below.  That call\n           * sets the local encoding (\"enc\") to the parser's\n           * internal encoding (internal_utf8 or internal_utf16),\n           * which can never be the same as the principle encoding.\n           * It doesn't appear there is another code path that gets\n           * here with entity->open being TRUE.\n           *\n           * Since it is not certain that this logic is watertight,\n           * we keep the line and merely exclude it from coverage\n           * tests.\n           */\n          parser->m_eventPtr = ptr; /* LCOV_EXCL_LINE */\n        }\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      }\n      if (entity->notation) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BINARY_ENTITY_REF;\n      }\n      if (! entity->textPtr) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;\n      } else {\n        enum XML_Error result;\n        const XML_Char *textEnd = entity->textPtr + entity->textLen;\n        entity->open = XML_TRUE;\n        result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                      isCdata, (char *)entity->textPtr,\n                                      (char *)textEnd, pool);\n        entity->open = XML_FALSE;\n        if (result)\n          return result;\n      }\n    } break;\n    default:\n      /* The only token returned by XmlAttributeValueTok() that does\n       * not have an explicit case here is XML_TOK_PARTIAL_CHAR.\n       * Getting that would require an entity name to contain an\n       * incomplete XML character (e.g. \\xE2\\x82); however previous\n       * tokenisers will have already recognised and rejected such\n       * names before XmlAttributeValueTok() gets a look-in.  This\n       * default case should be retained as a safety net, but the code\n       * excluded from coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n    ptr = next;\n  }\n  /* not reached */\n}\n",
        "output": "0",
        "index": 88243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,\n                                 UWORD8 u1_nal_ref_idc,\n dec_struct_t *ps_dec /* Decoder parameters */\n )\n{\n dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;\n dec_pic_params_t *ps_pps;\n dec_seq_params_t *ps_seq;\n dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;\n pocstruct_t s_tmp_poc;\n    WORD32 i_delta_poc[2];\n    WORD32 i4_poc = 0;\n    UWORD16 u2_first_mb_in_slice, u2_frame_num;\n    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;\n    UWORD32 u4_idr_pic_id = 0;\n    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;\n\n    UWORD8 u1_nal_unit_type;\n    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;\n    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;\n    WORD8 i1_is_end_of_poc;\n\n    WORD32 ret, end_of_frame;\n    WORD32 prev_slice_err, num_mb_skipped;\n    UWORD8 u1_mbaff;\n pocstruct_t *ps_cur_poc;\n\n    UWORD32 u4_temp;\n    WORD32 i_temp;\n    UWORD32 u4_call_end_of_pic = 0;\n\n /* read FirstMbInSlice  and slice type*/\n    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;\n    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,\n                                     pu4_bitstrm_buf);\n if(u2_first_mb_in_slice\n > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))\n {\n\n return ERROR_CORRUPTED_SLICE;\n }\n\n /*we currently don not support ASO*/\n if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)\n <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n    COPYTHECONTEXT(\"SH: first_mb_in_slice\",u2_first_mb_in_slice);\n\n    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n\n if(u4_temp > 9)\n return ERROR_INV_SLC_TYPE_T;\n\n    u1_slice_type = u4_temp;\n    COPYTHECONTEXT(\"SH: slice_type\",(u1_slice_type));\n    ps_dec->u1_sl_typ_5_9 = 0;\n /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */\n /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/\n /* will be of same type of current                            */\n if(u1_slice_type > 4)\n {\n        u1_slice_type -= 5;\n        ps_dec->u1_sl_typ_5_9 = 1;\n }\n\n {\n        UWORD32 skip;\n\n if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)\n || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))\n {\n            UWORD32 u4_bit_stream_offset = 0;\n\n if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else if((I_SLICE == u1_slice_type)\n && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))\n {\n                skip = 0;\n\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;\n }\n else\n {\n                skip = 1;\n }\n\n /* If one frame worth of data is already skipped, do not skip the next one */\n if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))\n {\n                skip = 0;\n }\n\n if(skip)\n {\n                ps_dec->u4_prev_nal_skipped = 1;\n                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;\n return 0;\n }\n else\n {\n /* If the previous NAL was skipped, then\n                 do not process that buffer in this call.\n                 Return to app and process it in the next call.\n                 This is necessary to handle cases where I/IDR is not complete in\n                 the current buffer and application intends to fill the remaining part of the bitstream\n                 later. This ensures we process only frame worth of data in every call */\n if(1 == ps_dec->u4_prev_nal_skipped)\n {\n                    ps_dec->u4_return_to_app = 1;\n return 0;\n }\n }\n }\n\n }\n\n \n     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n     if(u4_temp & MASK_ERR_PIC_SET_ID)\n        return ERROR_INV_SPS_PPS_T;\n     /* discard slice if pic param is invalid */\n     COPYTHECONTEXT(\"SH: pic_parameter_set_id\", u4_temp);\n     ps_pps = &ps_dec->ps_pps[u4_temp];\n     if(FALSE == ps_pps->u1_is_valid)\n     {\n        return ERROR_INV_SPS_PPS_T;\n     }\n     ps_seq = ps_pps->ps_sps;\n     if(!ps_seq)\n        return ERROR_INV_SPS_PPS_T;\n     if(FALSE == ps_seq->u1_is_valid)\n        return ERROR_INV_SPS_PPS_T;\n \n     /* Get the frame num */\n     u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,\n                                         ps_seq->u1_bits_in_frm_num);\n\n    COPYTHECONTEXT(\"SH: frame_num\", u2_frame_num);\n\n /* Get the field related flags  */\n if(!ps_seq->u1_frame_mbs_only_flag)\n {\n\n        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);\n        COPYTHECONTEXT(\"SH: field_pic_flag\", u1_field_pic_flag);\n        u1_bottom_field_flag = 0;\n\n if(u1_field_pic_flag)\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;\n            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);\n            COPYTHECONTEXT(\"SH: bottom_field_flag\", u1_bottom_field_flag);\n\n }\n else\n {\n            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n }\n else\n {\n        u1_field_pic_flag = 0;\n        u1_bottom_field_flag = 0;\n\n        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;\n }\n\n    u1_nal_unit_type = SLICE_NAL;\n if(u1_is_idr_slice)\n {\n if(0 == u1_field_pic_flag)\n {\n            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n        u1_nal_unit_type = IDR_SLICE_NAL;\n\n         u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,\n                                    pu4_bitstrm_buf);\n         if(u4_idr_pic_id > 65535)\n            return ERROR_INV_SPS_PPS_T;\n         COPYTHECONTEXT(\"SH:  \", u4_idr_pic_id);\n     }\n \n /* read delta pic order count information*/\n    i_delta_poc[0] = i_delta_poc[1] = 0;\n    s_tmp_poc.i4_pic_order_cnt_lsb = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;\n    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;\n if(u1_pic_order_cnt_type == 0)\n {\n        i_temp = ih264d_get_bits_h264(\n\n                         ps_bitstrm,\n                         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);\n         if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)\n            return ERROR_INV_SPS_PPS_T;\n         s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;\n         COPYTHECONTEXT(\"SH: pic_order_cnt_lsb\", s_tmp_poc.i4_pic_order_cnt_lsb);\n \n if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))\n {\n            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt_bottom\",\n                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);\n }\n }\n\n    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;\n    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;\n if(u1_pic_order_cnt_type == 1\n && (!ps_seq->u1_delta_pic_order_always_zero_flag))\n {\n        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,\n                                                         pu4_bitstrm_buf);\n        COPYTHECONTEXT(\"SH: delta_pic_order_cnt[0]\",\n                        s_tmp_poc.i4_delta_pic_order_cnt[0]);\n\n if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)\n {\n            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(\n                            pu4_bitstrm_ofst, pu4_bitstrm_buf);\n            COPYTHECONTEXT(\"SH: delta_pic_order_cnt[1]\",\n                            s_tmp_poc.i4_delta_pic_order_cnt[1]);\n }\n }\n\n if(ps_pps->u1_redundant_pic_cnt_present_flag)\n\n     {\n         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);\n         if(u4_temp > MAX_REDUNDANT_PIC_CNT)\n            return ERROR_INV_SPS_PPS_T;\n         u1_redundant_pic_cnt = u4_temp;\n         COPYTHECONTEXT(\"SH: redundant_pic_cnt\", u1_redundant_pic_cnt);\n     }\n\n /*--------------------------------------------------------------------*/\n /* Check if the slice is part of new picture                          */\n /*--------------------------------------------------------------------*/\n    i1_is_end_of_poc = 0;\n if(!ps_dec->u1_first_slice_in_stream)\n {\n        i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,\n &s_tmp_poc, &ps_dec->s_cur_pic_poc,\n                                            ps_cur_slice, u1_pic_order_cnt_type,\n                                            u1_nal_unit_type, u4_idr_pic_id,\n                                            u1_field_pic_flag,\n                                            u1_bottom_field_flag);\n\n /* since we support only Full frame decode, every new process should\n         * process a new pic\n         */\n if((ps_dec->u4_first_slice_in_pic == 2) && (i1_is_end_of_poc == 0))\n {\n /* if it is the first slice is process call ,it should be a new frame. If it is not\n             * reject current pic and dont add it to dpb\n             */\n            ps_dec->ps_dec_err_status->u1_err_flag |= REJECT_CUR_PIC;\n            i1_is_end_of_poc = 1;\n }\n else\n {\n /* reset REJECT_CUR_PIC */\n            ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;\n }\n }\n\n /*--------------------------------------------------------------------*/\n /* Check for error in slice and parse the missing/corrupted MB's      */\n /* as skip-MB's in an inserted P-slice                                */\n /*--------------------------------------------------------------------*/\n    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);\n    prev_slice_err = 0;\n\n if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)\n {\n if(u2_frame_num != ps_dec->u2_prv_frame_num\n && ps_dec->u1_top_bottom_decoded != 0\n && ps_dec->u1_top_bottom_decoded\n != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))\n {\n            ps_dec->u1_dangling_field = 1;\n if(ps_dec->u4_first_slice_in_pic)\n {\n                prev_slice_err = 1;\n }\n else\n {\n                prev_slice_err = 2;\n }\n\n if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)\n                ps_cur_slice->u1_bottom_field_flag = 1;\n else\n                ps_cur_slice->u1_bottom_field_flag = 0;\n\n            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &ps_dec->s_cur_pic_poc;\n\n            u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;\n }\n else if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice > 0)\n {\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n                ps_cur_poc = &s_tmp_poc;\n\n                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n                ps_cur_slice->i4_pic_order_cnt_lsb =\n                        s_tmp_poc.i4_pic_order_cnt_lsb;\n                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag\n && (!u1_field_pic_flag);\n }\n }\n else\n {\n\n if(ps_dec->u4_first_slice_in_pic)\n {\n /* if valid slice header is not decoded do start of pic processing\n                 * since in the current process call, frame num is not updated in the slice structure yet\n                 * ih264d_is_end_of_pic is checked with valid frame num of previous process call,\n                 * although i1_is_end_of_poc is set there could be  more slices in the frame,\n                 * so conceal only till cur slice */\n                prev_slice_err = 1;\n                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;\n }\n else\n {\n /* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame\n                 * completely */\n                prev_slice_err = 2;\n                num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n }\n            ps_cur_poc = &s_tmp_poc;\n }\n }\n else\n {\n if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)\n {\n            prev_slice_err = 2;\n            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)\n - ps_dec->u2_total_mbs_coded;\n            ps_cur_poc = &s_tmp_poc;\n }\n else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)\n {\n return ERROR_CORRUPTED_SLICE;\n }\n }\n\n if(prev_slice_err)\n {\n        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);\n\n if(ps_dec->u1_dangling_field == 1)\n {\n            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;\n            ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n            ps_dec->u2_prv_frame_num = u2_frame_num;\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_DANGLING_FIELD_IN_PIC;\n }\n\n if(prev_slice_err == 2)\n {\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_INCOMPLETE_FRAME;\n }\n\n if(ps_dec->u2_total_mbs_coded\n >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n /* return if all MBs in frame are parsed*/\n            ps_dec->u1_first_slice_in_stream = 0;\n return ERROR_IN_LAST_SLICE_OF_PIC;\n }\n\n if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)\n {\n            ih264d_err_pic_dispbuf_mgr(ps_dec);\n return ERROR_NEW_FRAME_EXPECTED;\n }\n\n if(ret != OK)\n return ret;\n\n        i1_is_end_of_poc = 0;\n }\n\n if (ps_dec->u4_first_slice_in_pic == 0)\n {\n        ps_dec->ps_parse_cur_slice++;\n        ps_dec->u2_cur_slice_num++;\n }\n\n if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))\n {\n        ps_dec->ps_decode_cur_slice++;\n }\n    ps_dec->u1_slice_header_done = 0;\n\n /*--------------------------------------------------------------------*/\n /* If the slice is part of new picture, do End of Pic processing.     */\n /*--------------------------------------------------------------------*/\n if(!ps_dec->u1_first_slice_in_stream)\n {\n        UWORD8 uc_mbs_exceed = 0;\n\n if(ps_dec->u2_total_mbs_coded\n == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))\n {\n /*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so\n             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture */\n if(ps_dec->u4_first_slice_in_pic == 0)\n                uc_mbs_exceed = 1;\n }\n\n if(i1_is_end_of_poc || uc_mbs_exceed)\n {\n\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n if(ret != OK)\n return ret;\n#if WIN32\n                H264_DEC_DEBUG_PRINT(\" ------ PIC SKIPPED ------\\n\");\n#endif\n return RET_LAST_SKIP;\n }\n else\n {\n                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);\n if(ret != OK)\n return ret;\n }\n\n }\n }\n\n if(u1_field_pic_flag)\n {\n        ps_dec->u2_prv_frame_num = u2_frame_num;\n }\n\n if(ps_cur_slice->u1_mmco_equalto5)\n {\n        WORD32 i4_temp_poc;\n        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;\n\n if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair\n {\n            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n            i4_bot_field_order_poc =\n                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n            i4_temp_poc = MIN(i4_top_field_order_poc,\n                                     i4_bot_field_order_poc);\n }\n else if(!ps_cur_slice->u1_bottom_field_flag)\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n else\n            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n\n        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_top_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc\n - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;\n        ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;\n        ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;\n }\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n        ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,\n &ps_dec->s_prev_pic_poc,\n &s_tmp_poc, ps_cur_slice, ps_pps,\n                                          u1_nal_ref_idc,\n                                          u1_bottom_field_flag,\n                                          u1_field_pic_flag, &i4_poc);\n if(ret != OK)\n return ret;\n /* Display seq no calculations */\n if(i4_poc >= ps_dec->i4_max_poc)\n            ps_dec->i4_max_poc = i4_poc;\n /* IDR Picture or POC wrap around */\n if(i4_poc == 0)\n {\n            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq\n + ps_dec->i4_max_poc\n + ps_dec->u1_max_dec_frame_buffering + 1;\n            ps_dec->i4_max_poc = 0;\n }\n }\n\n /*--------------------------------------------------------------------*/\n /* Copy the values read from the bitstream to the slice header and then*/\n /* If the slice is first slice in picture, then do Start of Picture   */\n /* processing.                                                        */\n /*--------------------------------------------------------------------*/\n    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];\n    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];\n    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;\n    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;\n    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;\n    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;\n    ps_cur_slice->u1_slice_type = u1_slice_type;\n    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;\n\n    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;\n    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;\n    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;\n    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;\n\n if(ps_seq->u1_frame_mbs_only_flag)\n        ps_cur_slice->u1_direct_8x8_inference_flag =\n                        ps_seq->u1_direct_8x8_inference_flag;\n else\n        ps_cur_slice->u1_direct_8x8_inference_flag = 1;\n\n if(u1_slice_type == B_SLICE)\n {\n        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(\n                        ps_bitstrm);\n        COPYTHECONTEXT(\"SH: direct_spatial_mv_pred_flag\",\n                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);\n\n if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;\n else\n            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;\n }\n else\n {\n if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))\n            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;\n }\n\n if(ps_dec->u4_first_slice_in_pic == 2)\n {\n if(u2_first_mb_in_slice == 0)\n {\n            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);\n if(ret != OK)\n return ret;\n }\n\n        ps_dec->u4_output_present = 0;\n\n {\n            ih264d_get_next_display_field(ps_dec,\n                                          ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n /* If error code is non-zero then there is no buffer available for display,\n             hence avoid format conversion */\n\n if(0 != ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;\n }\n else\n                ps_dec->u4_output_present = 1;\n }\n if(ps_dec->u1_separate_parse == 1)\n {\n if(ps_dec->u4_dec_thread_created == 0)\n {\n                ithread_create(ps_dec->pv_dec_thread_handle, NULL,\n (void *)ih264d_decode_picture_thread,\n (void *)ps_dec);\n\n                ps_dec->u4_dec_thread_created = 1;\n }\n\n if((ps_dec->u4_num_cores == 3) &&\n ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)\n && (ps_dec->u4_bs_deblk_thread_created == 0))\n {\n                ps_dec->u4_start_recon_deblk = 0;\n                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,\n (void *)ih264d_recon_deblk_thread,\n (void *)ps_dec);\n                ps_dec->u4_bs_deblk_thread_created = 1;\n }\n }\n\n }\n\n /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */\n {\n        UWORD8 uc_nofield_nombaff;\n\n\n\n        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)\n && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)\n && (u1_slice_type != B_SLICE)\n && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));\n\n /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */\n\n if(uc_nofield_nombaff)\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;\n }\n else\n {\n            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;\n            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;\n }\n\n\n }\n\n /*\n     * Decide whether to decode the current picture or not\n     */\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if(ps_err->u4_frm_sei_sync == u2_frame_num)\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;\n }\n        ps_err->u4_cur_frm = u2_frame_num;\n }\n\n /* Decision for decoding if the picture is to be skipped */\n {\n        WORD32 i4_skip_b_pic, i4_skip_p_pic;\n\n        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)\n && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)\n && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);\n\n /**************************************************************/\n /* Skip the B picture if skip mask is set for B picture and   */\n /* Current B picture is a non reference B picture or there is */\n /* no user for reference B picture                            */\n /**************************************************************/\n if(i4_skip_b_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n /* Don't decode the picture in SKIP-B mode if that picture is B */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n /**************************************************************/\n /* Skip the P picture if skip mask is set for P picture and   */\n /* Current P picture is a non reference P picture or there is */\n /* no user for reference P picture                            */\n /**************************************************************/\n if(i4_skip_p_pic)\n {\n            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n /* Don't decode the picture in SKIP-P mode if that picture is P */\n /* and also it is not to be used as a reference picture         */\n            ps_dec->u1_last_pic_not_decoded = 1;\n\n return OK;\n }\n }\n\n {\n        UWORD16 u2_mb_x, u2_mb_y;\n\n        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice\n << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)\n - SUB_BLK_SIZE;\n if(u2_first_mb_in_slice)\n {\n            UWORD8 u1_mb_aff;\n            UWORD8 u1_field_pic;\n            UWORD16 u2_frm_wd_in_mbs;\n            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;\n            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;\n            u1_field_pic = ps_cur_slice->u1_field_pic_flag;\n\n {\n                UWORD32 x_offset;\n                UWORD32 y_offset;\n                UWORD32 u4_frame_stride;\n tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;\n\n if(ps_dec->u1_separate_parse)\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                    ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);\n\n                u2_mb_y <<= u1_mb_aff;\n\n if((u2_mb_x > u2_frm_wd_in_mbs - 1)\n || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))\n {\n return ERROR_CORRUPTED_SLICE;\n }\n\n                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;\n                x_offset = u2_mb_x << 4;\n                y_offset = (u2_mb_y * u4_frame_stride) << 4;\n\n                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset\n + y_offset;\n\n                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;\n                x_offset >>= 1;\n                y_offset = (u2_mb_y * u4_frame_stride) << 3;\n\n                x_offset *= YUV420SP_FACTOR;\n\n                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset\n + y_offset;\n                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset\n + y_offset;\n\n                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n\n if(ps_dec->u1_separate_parse == 1)\n {\n                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n else\n {\n                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic\n + (u2_first_mb_in_slice << u1_mb_aff);\n }\n\n                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);\n\n                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv\n + ((u2_first_mb_in_slice << u1_mb_aff) << 4);\n }\n }\n else\n {\n tfr_ctxt_t *ps_trns_addr;\n\n if(ps_dec->u1_separate_parse)\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;\n }\n else\n {\n                ps_trns_addr = &ps_dec->s_tran_addrecon;\n }\n\n            u2_mb_x = 0xffff;\n            u2_mb_y = 0;\n            ps_dec->u2_cur_mb_addr = 0;\n            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;\n            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;\n            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;\n            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;\n            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;\n\n            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;\n            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;\n            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;\n\n }\n\n        ps_dec->ps_part = ps_dec->ps_parse_part_params;\n\n        ps_dec->u2_mbx =\n (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby =\n (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));\n        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;\n        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n }\n\n /* RBSP stop bit is used for CABAC decoding*/\n    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;\n\n    ps_dec->u1_B = (u1_slice_type == B_SLICE);\n    ps_dec->u4_next_mb_skip = 0;\n\n    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =\n                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;\n    ps_dec->ps_parse_cur_slice->slice_type =\n                    ps_dec->ps_cur_slice->u1_slice_type;\n\n\n    ps_dec->u4_start_recon_deblk = 1;\n {\n        WORD32 num_entries;\n        WORD32 size;\n        UWORD8 *pu1_buf;\n\n        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);\n        num_entries = 2 * ((2 * num_entries) + 1);\n\n        size = num_entries * sizeof(void *);\n        size += PAD_MAP_IDX_POC * sizeof(void *);\n\n        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;\n        pu1_buf += size * ps_dec->u2_cur_slice_num;\n        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;\n }\n\n if(ps_dec->u1_separate_parse)\n {\n        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;\n }\n else\n {\n        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;\n }\n\n if(u1_slice_type == I_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;\n\n        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);\n\n if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)\n            ps_dec->i4_pic_type = I_SLICE;\n\n }\n else if(u1_slice_type == P_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;\n        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n if(ps_dec->i4_pic_type != B_SLICE)\n            ps_dec->i4_pic_type = P_SLICE;\n }\n else if(u1_slice_type == B_SLICE)\n {\n        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;\n        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);\n        ps_dec->u1_pr_sl_type = u1_slice_type;\n        ps_dec->i4_pic_type = B_SLICE;\n }\n else\n return ERROR_INV_SLC_TYPE_T;\n\n if(ps_dec->u1_slice_header_done)\n {\n /* set to zero to indicate a valid slice has been decoded */\n /* first slice header successfully decoded */\n        ps_dec->u4_first_slice_in_pic = 0;\n        ps_dec->u1_first_slice_in_stream = 0;\n }\n\n if(ret != OK)\n return ret;\n\n /* storing last Mb X and MbY of the slice */\n    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;\n    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;\n\n /* End of Picture detection */\n\n if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))\n {\n        ps_dec->u1_pic_decode_done = 1;\n\n }\n\n {\n dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;\n if((ps_err->u1_err_flag & REJECT_PB_PICS)\n && (ps_err->u1_cur_pic_type == PIC_TYPE_I))\n {\n            ps_err->u1_err_flag = ACCEPT_ALL_PICS;\n }\n }\n\n    PRINT_BIN_BIT_RATIO(ps_dec)\n\n return ret;\n}\n",
        "output": "1",
        "index": 188065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MYSQLND_METHOD(mysqlnd_conn_data, simple_command_handle_response)(MYSQLND_CONN_DATA * conn, enum mysqlnd_packet_type ok_packet,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t zend_bool silent, enum php_mysqlnd_server_command command,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t zend_bool ignore_upsert_status TSRMLS_DC)\n{\n\tenum_func_status ret = FAIL;\n\n\tDBG_ENTER(\"mysqlnd_conn_data::simple_command_handle_response\");\n\tDBG_INF_FMT(\"silent=%u packet=%u command=%s\", silent, ok_packet, mysqlnd_command_to_text[command]);\n\n\tswitch (ok_packet) {\n\t\tcase PROT_OK_PACKET:{\n\t\t\tMYSQLND_PACKET_OK * ok_response = conn->protocol->m.get_ok_packet(conn->protocol, FALSE TSRMLS_CC);\n\t\t\tif (!ok_response) {\n\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (FAIL == (ret = PACKET_READ(ok_response, conn))) {\n\t\t\t\tif (!silent) {\n\t\t\t\t\tDBG_ERR_FMT(\"Error while reading %s's OK packet\", mysqlnd_command_to_text[command]);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error while reading %s's OK packet. PID=%u\",\n\t\t\t\t\t\t\t\t\t mysqlnd_command_to_text[command], getpid());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDBG_INF_FMT(\"OK from server\");\n\t\t\t\tif (0xFF == ok_response->field_count) {\n\t\t\t\t\t/* The server signalled error. Set the error */\n\t\t\t\t\tSET_CLIENT_ERROR(*conn->error_info, ok_response->error_no, ok_response->sqlstate, ok_response->error);\n\t\t\t\t\tret = FAIL;\n\t\t\t\t\t/*\n\t\t\t\t\t  Cover a protocol design error: error packet does not\n\t\t\t\t\t  contain the server status. Therefore, the client has no way\n\t\t\t\t\t  to find out whether there are more result sets of\n\t\t\t\t\t  a multiple-result-set statement pending. Luckily, in 5.0 an\n\t\t\t\t\t  error always aborts execution of a statement, wherever it is\n\t\t\t\t\t  a multi-statement or a stored procedure, so it should be\n\t\t\t\t\t  safe to unconditionally turn off the flag here.\n\t\t\t\t\t*/\n\t\t\t\t\tconn->upsert_status->server_status &= ~SERVER_MORE_RESULTS_EXISTS;\n\t\t\t\t\tSET_ERROR_AFF_ROWS(conn);\n\t\t\t\t} else {\n\t\t\t\t\tSET_NEW_MESSAGE(conn->last_message, conn->last_message_len,\n\t\t\t\t\t\t\t\t\tok_response->message, ok_response->message_len,\n\t\t\t\t\t\t\t\t\tconn->persistent);\n\n\t\t\t\t\tif (!ignore_upsert_status) {\n\t\t\t\t\t\tmemset(conn->upsert_status, 0, sizeof(*conn->upsert_status));\n\t\t\t\t\t\tconn->upsert_status->warning_count = ok_response->warning_count;\n\t\t\t\t\t\tconn->upsert_status->server_status = ok_response->server_status;\n\t\t\t\t\t\tconn->upsert_status->affected_rows = ok_response->affected_rows;\n\t\t\t\t\t\tconn->upsert_status->last_insert_id = ok_response->last_insert_id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPACKET_FREE(ok_response);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROT_EOF_PACKET:{\n\t\t\tMYSQLND_PACKET_EOF * ok_response = conn->protocol->m.get_eof_packet(conn->protocol, FALSE TSRMLS_CC);\n\t\t\tif (!ok_response) {\n\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (FAIL == (ret = PACKET_READ(ok_response, conn))) {\n\t\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_MALFORMED_PACKET, UNKNOWN_SQLSTATE,\n\t\t\t\t\t\t\t\t \"Malformed packet\");\n\t\t\t\tif (!silent) {\n\t\t\t\t\tDBG_ERR_FMT(\"Error while reading %s's EOF packet\", mysqlnd_command_to_text[command]);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Error while reading %s's EOF packet. PID=%d\",\n\t\t\t\t\t\t\t\t\t mysqlnd_command_to_text[command], getpid());\n\t\t\t\t}\n\t\t\t} else if (0xFF == ok_response->field_count) {\n\t\t\t\t/* The server signalled error. Set the error */\n\t\t\t\tSET_CLIENT_ERROR(*conn->error_info, ok_response->error_no, ok_response->sqlstate, ok_response->error);\n\t\t\t\tSET_ERROR_AFF_ROWS(conn);\n\t\t\t} else if (0xFE != ok_response->field_count) {\n\t\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_MALFORMED_PACKET, UNKNOWN_SQLSTATE, \"Malformed packet\");\n\t\t\t\tif (!silent) {\n\t\t\t\t\tDBG_ERR_FMT(\"EOF packet expected, field count wasn't 0xFE but 0x%2X\", ok_response->field_count);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"EOF packet expected, field count wasn't 0xFE but 0x%2X\",\n\t\t\t\t\t\t\t\t\tok_response->field_count);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDBG_INF_FMT(\"OK from server\");\n\t\t\t}\n\t\t\tPACKET_FREE(ok_response);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_MALFORMED_PACKET, UNKNOWN_SQLSTATE, \"Malformed packet\");\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Wrong response packet %u passed to the function\", ok_packet);\n\t\t\tbreak;\n\t}\n\tDBG_INF(ret == PASS ? \"PASS\":\"FAIL\");\n\tDBG_RETURN(ret);\n}\n",
        "output": "0",
        "index": 14268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AudioMixerAlsa::ConnectInternal() {\n  DCHECK(MessageLoop::current() == thread_->message_loop());\n  num_connection_attempts_++;\n  int err;\n  snd_mixer_t* handle = NULL;\n\n  if ((err = snd_mixer_open(&handle, 0)) < 0) {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"Mixer open error: \" << snd_strerror(err);\n    return false;\n  }\n\n  if ((err = snd_mixer_attach(handle, kCardName)) < 0) {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"Attach to card \" << kCardName << \" failed: \"\n                   << snd_strerror(err);\n    snd_mixer_close(handle);\n    return false;\n  }\n\n  snd_pcm_t* pcm_out_handle;\n  if ((err = snd_pcm_open(&pcm_out_handle,\n                          kCardName,\n                          SND_PCM_STREAM_PLAYBACK,\n                          0)) >= 0) {\n    snd_pcm_close(pcm_out_handle);\n  } else {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"PCM open failed: \" << snd_strerror(err);\n  }\n\n  if ((err = snd_mixer_selem_register(handle, NULL, NULL)) < 0) {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"Mixer register error: \" << snd_strerror(err);\n    snd_mixer_close(handle);\n    return false;\n  }\n\n  if ((err = snd_mixer_load(handle)) < 0) {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"Mixer \" << kCardName << \" load error: %s\"\n                   << snd_strerror(err);\n    snd_mixer_close(handle);\n    return false;\n  }\n\n  VLOG(1) << \"Opened mixer \" << kCardName << \" successfully\";\n\n  double min_volume_db = kDefaultMinVolumeDb;\n  double max_volume_db = kDefaultMaxVolumeDb;\n\n  snd_mixer_elem_t* master_element = NULL;\n  for (size_t i = 0; i < arraysize(kMasterElementNames); ++i) {\n    master_element = FindElementWithName(handle, kMasterElementNames[i]);\n    if (master_element)\n      break;\n  }\n\n  if (!master_element) {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"Unable to find a master element on \" << kCardName;\n    snd_mixer_close(handle);\n    return false;\n  }\n\n  alsa_long_t long_low = static_cast<alsa_long_t>(kDefaultMinVolumeDb * 100);\n  alsa_long_t long_high = static_cast<alsa_long_t>(kDefaultMaxVolumeDb * 100);\n  err = snd_mixer_selem_get_playback_dB_range(\n      master_element, &long_low, &long_high);\n  if (err != 0) {\n    if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n      LOG(WARNING) << \"snd_mixer_selem_get_playback_dB_range() failed:\"\n                   << snd_strerror(err);\n    snd_mixer_close(handle);\n    return false;\n  }\n  min_volume_db = static_cast<double>(long_low) / 100.0;\n  max_volume_db = static_cast<double>(long_high) / 100.0;\n\n  snd_mixer_elem_t* pcm_element = FindElementWithName(handle, kPCMElementName);\n  if (pcm_element) {\n    alsa_long_t long_low = static_cast<alsa_long_t>(kDefaultMinVolumeDb * 100);\n    alsa_long_t long_high = static_cast<alsa_long_t>(kDefaultMaxVolumeDb * 100);\n    err = snd_mixer_selem_get_playback_dB_range(\n        pcm_element, &long_low, &long_high);\n    if (err != 0) {\n      if (num_connection_attempts_ == kConnectionAttemptToLogFailure)\n        LOG(WARNING) << \"snd_mixer_selem_get_playback_dB_range() failed for \"\n                     << kPCMElementName << \": \" << snd_strerror(err);\n      snd_mixer_close(handle);\n      return false;\n    }\n    min_volume_db += static_cast<double>(long_low) / 100.0;\n    max_volume_db += static_cast<double>(long_high) / 100.0;\n  }\n\n  VLOG(1) << \"Volume range is \" << min_volume_db << \" dB to \"\n          << max_volume_db << \" dB\";\n  {\n    base::AutoLock lock(lock_);\n    alsa_mixer_ = handle;\n    master_element_ = master_element;\n    pcm_element_ = pcm_element;\n    min_volume_db_ = min_volume_db;\n    max_volume_db_ = max_volume_db;\n    volume_db_ = min(max(volume_db_, min_volume_db_), max_volume_db_);\n  }\n\n  EnableChromeOsTts();\n\n  ApplyState();\n  return true;\n}\n",
        "output": "0",
        "index": 117515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ieee80211_radiotap_iterator_next(\n\tstruct ieee80211_radiotap_iterator *iterator)\n{\n\twhile (1) {\n\t\tint hit = 0;\n\t\tint pad, align, size, subns;\n\t\tuint32_t oui;\n\n\t\t/* if no more EXT bits, that's it */\n\t\tif ((iterator->_arg_index % 32) == IEEE80211_RADIOTAP_EXT &&\n\t\t    !(iterator->_bitmap_shifter & 1))\n\t\t\treturn -ENOENT;\n\n\t\tif (!(iterator->_bitmap_shifter & 1))\n\t\t\tgoto next_entry; /* arg not present */\n\n\t\t/* get alignment/size of data */\n\t\tswitch (iterator->_arg_index % 32) {\n\t\tcase IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE:\n\t\tcase IEEE80211_RADIOTAP_EXT:\n\t\t\talign = 1;\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase IEEE80211_RADIOTAP_VENDOR_NAMESPACE:\n\t\t\talign = 2;\n\t\t\tsize = 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iterator->current_namespace ||\n\t\t\t    iterator->_arg_index >= iterator->current_namespace->n_bits) {\n\t\t\t\tif (iterator->current_namespace == &radiotap_ns)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\talign = 0;\n\t\t\t} else {\n\t\t\t\talign = iterator->current_namespace->align_size[iterator->_arg_index].align;\n\t\t\t\tsize = iterator->current_namespace->align_size[iterator->_arg_index].size;\n\t\t\t}\n\t\t\tif (!align) {\n\t\t\t\t/* skip all subsequent data */\n\t\t\t\titerator->_arg = iterator->_next_ns_data;\n\t\t\t\t/* give up on this namespace */\n\t\t\t\titerator->current_namespace = NULL;\n\t\t\t\tgoto next_entry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * arg is present, account for alignment padding\n\t\t *\n\t\t * Note that these alignments are relative to the start\n\t\t * of the radiotap header.  There is no guarantee\n\t\t * that the radiotap header itself is aligned on any\n\t\t * kind of boundary.\n\t\t *\n\t\t * The above is why get_unaligned() is used to dereference\n\t\t * multibyte elements from the radiotap area.\n\t\t */\n\n\t\tpad = ((unsigned long)iterator->_arg -\n\t\t       (unsigned long)iterator->_rtheader) & (align - 1);\n\n\t\tif (pad)\n\t\t\titerator->_arg += align - pad;\n\n\t\tif (iterator->_arg_index % 32 == IEEE80211_RADIOTAP_VENDOR_NAMESPACE) {\n\t\t\tint vnslen;\n\n\t\t\tif ((unsigned long)iterator->_arg + size -\n\t\t\t    (unsigned long)iterator->_rtheader >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\n\t\t\toui = (*iterator->_arg << 16) |\n\t\t\t\t(*(iterator->_arg + 1) << 8) |\n\t\t\t\t*(iterator->_arg + 2);\n\t\t\tsubns = *(iterator->_arg + 3);\n\n\t\t\tfind_ns(iterator, oui, subns);\n\n\t\t\tvnslen = get_unaligned_le16(iterator->_arg + 4);\n\t\t\titerator->_next_ns_data = iterator->_arg + size + vnslen;\n\t\t\tif (!iterator->current_namespace)\n\t\t\t\tsize += vnslen;\n\t\t}\n\n\t\t/*\n\t\t * this is what we will return to user, but we need to\n\t\t * move on first so next call has something fresh to test\n\t\t */\n\t\titerator->this_arg_index = iterator->_arg_index;\n\t\titerator->this_arg = iterator->_arg;\n\t\titerator->this_arg_size = size;\n\n\t\t/* internally move on the size of this arg */\n\t\titerator->_arg += size;\n\n\t\t/*\n\t\t * check for insanity where we are given a bitmap that\n\t\t * claims to have more arg content than the length of the\n\t\t * radiotap section.  We will normally end up equalling this\n\t\t * max_length on the last arg, never exceeding it.\n\t\t */\n\n\t\tif ((unsigned long)iterator->_arg -\n\t\t    (unsigned long)iterator->_rtheader >\n\t\t    (unsigned long)iterator->_max_length)\n\t\t\treturn -EINVAL;\n\n\t\t/* these special ones are valid in each bitmap word */\n\t\tswitch (iterator->_arg_index % 32) {\n\t\tcase IEEE80211_RADIOTAP_VENDOR_NAMESPACE:\n\t\t\titerator->_reset_on_ext = 1;\n\n\t\t\titerator->is_radiotap_ns = 0;\n\t\t\t/*\n\t\t\t * If parser didn't register this vendor\n\t\t\t * namespace with us, allow it to show it\n\t\t\t * as 'raw. Do do that, set argument index\n\t\t\t * to vendor namespace.\n\t\t\t */\n\t\t\titerator->this_arg_index =\n\t\t\t\tIEEE80211_RADIOTAP_VENDOR_NAMESPACE;\n\t\t\tif (!iterator->current_namespace)\n\t\t\t\thit = 1;\n\t\t\tgoto next_entry;\n\t\tcase IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE:\n\t\t\titerator->_reset_on_ext = 1;\n\t\t\titerator->current_namespace = &radiotap_ns;\n\t\t\titerator->is_radiotap_ns = 1;\n\t\t\tgoto next_entry;\n\t\tcase IEEE80211_RADIOTAP_EXT:\n\t\t\t/*\n\t\t\t * bit 31 was set, there is more\n\t\t\t * -- move to next u32 bitmap\n\t\t\t */\n\t\t\titerator->_bitmap_shifter =\n\t\t\t\tget_unaligned_le32(iterator->_next_bitmap);\n\t\t\titerator->_next_bitmap++;\n\t\t\tif (iterator->_reset_on_ext)\n\t\t\t\titerator->_arg_index = 0;\n\t\t\telse\n\t\t\t\titerator->_arg_index++;\n\t\t\titerator->_reset_on_ext = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* we've got a hit! */\n\t\t\thit = 1;\n next_entry:\n\t\t\titerator->_bitmap_shifter >>= 1;\n\t\t\titerator->_arg_index++;\n\t\t}\n\n\t\t/* if we found a valid arg earlier, return it now */\n\t\tif (hit)\n\t\t\treturn 0;\n\t}\n}\n",
        "output": "0",
        "index": 27950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_fetch(pdo_stmt_t *stmt, int do_bind, zval *return_value,\n\tenum pdo_fetch_type how, enum pdo_fetch_orientation ori, long offset, zval *return_all TSRMLS_DC) /* {{{ */\n{\n\tint flags, idx, old_arg_count = 0;\n\tzend_class_entry *ce = NULL, *old_ce = NULL;\n\tzval grp_val, *grp, **pgrp, *retval, *old_ctor_args = NULL;\n\tint colno;\n\n\tif (how == PDO_FETCH_USE_DEFAULT) {\n\t\thow = stmt->default_fetch_type;\n\t}\n\tflags = how & PDO_FETCH_FLAGS;\n\thow = how & ~PDO_FETCH_FLAGS;\n\n\tif (!do_fetch_common(stmt, ori, offset, do_bind TSRMLS_CC)) {\n\t\treturn 0;\n\t}\n\n\tif (how == PDO_FETCH_BOUND) {\n\t\tRETVAL_TRUE;\n\t\treturn 1;\n\t}\n\n\tif (flags & PDO_FETCH_GROUP && stmt->fetch.column == -1) {\n\t\tcolno = 1;\n\t} else {\n\t\tcolno = stmt->fetch.column;\n\t}\n\n\tif (return_value) {\n\t\tint i = 0;\n\n\t\tif (how == PDO_FETCH_LAZY) {\n\t\t\tget_lazy_object(stmt, return_value TSRMLS_CC);\n\t\t\treturn 1;\n\t\t}\n\n\t\tRETVAL_FALSE;\n\n\t\tswitch (how) {\n\t\t\tcase PDO_FETCH_USE_DEFAULT:\n\t\t\tcase PDO_FETCH_ASSOC:\n\t\t\tcase PDO_FETCH_BOTH:\n\t\t\tcase PDO_FETCH_NUM:\n\t\t\tcase PDO_FETCH_NAMED:\n\t\t\t\tif (!return_all) {\n\t\t\t\t\tALLOC_HASHTABLE(return_value->value.ht);\n\t\t\t\t\tzend_hash_init(return_value->value.ht, stmt->column_count, NULL, ZVAL_PTR_DTOR, 0);\n\t\t\t\t\tZ_TYPE_P(return_value) = IS_ARRAY;\n\t\t\t\t} else {\n\t\t\t\t\tarray_init(return_value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PDO_FETCH_KEY_PAIR:\n\t\t\t\tif (stmt->column_count != 2) {\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"PDO::FETCH_KEY_PAIR fetch mode requires the result set to contain extactly 2 columns.\" TSRMLS_CC);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!return_all) {\n\t\t\t\t\tarray_init(return_value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PDO_FETCH_COLUMN:\n\t\t\t\tif (colno >= 0 && colno < stmt->column_count) {\n\t\t\t\t\tif (flags == PDO_FETCH_GROUP && stmt->fetch.column == -1) {\n\t\t\t\t\t\tfetch_value(stmt, return_value, 1, NULL TSRMLS_CC);\n\t\t\t\t\t} else if (flags == PDO_FETCH_GROUP && colno) {\n\t\t\t\t\t\tfetch_value(stmt, return_value, 0, NULL TSRMLS_CC);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfetch_value(stmt, return_value, colno, NULL TSRMLS_CC);\n\t\t\t\t\t}\n\t\t\t\t\tif (!return_all) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"Invalid column index\" TSRMLS_CC);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\n\t\t\tcase PDO_FETCH_OBJ:\n\t\t\t\tobject_init_ex(return_value, ZEND_STANDARD_CLASS_DEF_PTR);\n\t\t\t\tbreak;\n\n\t\t\tcase PDO_FETCH_CLASS:\n\t\t\t\tif (flags & PDO_FETCH_CLASSTYPE) {\n\t\t\t\t\tzval val;\n\t\t\t\t\tzend_class_entry **cep;\n\n\t\t\t\t\told_ce = stmt->fetch.cls.ce;\n\t\t\t\t\told_ctor_args = stmt->fetch.cls.ctor_args;\n\t\t\t\t\told_arg_count = stmt->fetch.cls.fci.param_count;\n\t\t\t\t\tdo_fetch_opt_finish(stmt, 0 TSRMLS_CC);\n\n\t\t\t\t\tINIT_PZVAL(&val);\n\t\t\t\t\tfetch_value(stmt, &val, i++, NULL TSRMLS_CC);\n\t\t\t\t\tif (Z_TYPE(val) != IS_NULL) {\n\t\t\t\t\t\tconvert_to_string(&val);\n\t\t\t\t\t\tif (zend_lookup_class(Z_STRVAL(val), Z_STRLEN(val), &cep TSRMLS_CC) == FAILURE) {\n\t\t\t\t\t\t\tstmt->fetch.cls.ce = ZEND_STANDARD_CLASS_DEF_PTR;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstmt->fetch.cls.ce = *cep;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdo_fetch_class_prepare(stmt TSRMLS_CC);\n\t\t\t\t\tzval_dtor(&val);\n\t\t\t\t}\n\t\t\t\tce = stmt->fetch.cls.ce;\n\t\t\t\tif (!ce) {\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"No fetch class specified\" TSRMLS_CC);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif ((flags & PDO_FETCH_SERIALIZE) == 0) {\n\t\t\t\t\tobject_init_ex(return_value, ce);\n\t\t\t\t\tif (!stmt->fetch.cls.fci.size) {\n\t\t\t\t\t\tif (!do_fetch_class_prepare(stmt TSRMLS_CC))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ce->constructor && (flags & PDO_FETCH_PROPS_LATE)) {\n\t\t\t\t\t\tstmt->fetch.cls.fci.object_ptr = return_value;\n\t\t\t\t\t\tstmt->fetch.cls.fcc.object_ptr = return_value;\n\t\t\t\t\t\tif (zend_call_function(&stmt->fetch.cls.fci, &stmt->fetch.cls.fcc TSRMLS_CC) == FAILURE) {\n\t\t\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"could not call class constructor\" TSRMLS_CC);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (stmt->fetch.cls.retval_ptr) {\n\t\t\t\t\t\t\t\tzval_ptr_dtor(&stmt->fetch.cls.retval_ptr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PDO_FETCH_INTO:\n\t\t\t\tif (!stmt->fetch.into) {\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"No fetch-into object specified.\" TSRMLS_CC);\n\t\t\t\t\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\t\t\t\tZ_OBJ_HANDLE_P(return_value) = Z_OBJ_HANDLE_P(stmt->fetch.into);\n\t\t\t\tZ_OBJ_HT_P(return_value) = Z_OBJ_HT_P(stmt->fetch.into);\n\t\t\t\tzend_objects_store_add_ref(stmt->fetch.into TSRMLS_CC);\n\n\t\t\t\tif (zend_get_class_entry(return_value TSRMLS_CC) == ZEND_STANDARD_CLASS_DEF_PTR) {\n\t\t\t\t\thow = PDO_FETCH_OBJ;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PDO_FETCH_FUNC:\n\t\t\t\tif (!stmt->fetch.func.function) {\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"No fetch function specified\" TSRMLS_CC);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!stmt->fetch.func.fci.size) {\n\t\t\t\t\tif (!do_fetch_func_prepare(stmt TSRMLS_CC))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\n\t\t\tdefault:\n\t\t\t\t/* shouldn't happen */\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (return_all && how != PDO_FETCH_KEY_PAIR) {\n\t\t\tINIT_PZVAL(&grp_val);\n\t\t\tif (flags == PDO_FETCH_GROUP && how == PDO_FETCH_COLUMN && stmt->fetch.column > 0) {\n\t\t\t\tfetch_value(stmt, &grp_val, colno, NULL TSRMLS_CC);\n\t\t\t} else {\n\t\t\t\tfetch_value(stmt, &grp_val, i, NULL TSRMLS_CC);\n\t\t\t}\n\t\t\tconvert_to_string(&grp_val);\n\t\t\tif (how == PDO_FETCH_COLUMN) {\n\t\t\t\ti = stmt->column_count; /* no more data to fetch */\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tfor (idx = 0; i < stmt->column_count; i++, idx++) {\n\t\t\tzval *val;\n\t\t\tMAKE_STD_ZVAL(val);\n\t\t\tfetch_value(stmt, val, i, NULL TSRMLS_CC);\n\n\t\t\tswitch (how) {\n\t\t\t\tcase PDO_FETCH_ASSOC:\n\t\t\t\t\tadd_assoc_zval(return_value, stmt->columns[i].name, val);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_KEY_PAIR:\n\t\t\t\t\t{\n\t\t\t\t\t\tzval *tmp;\n\t\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\t\tfetch_value(stmt, tmp, ++i, NULL TSRMLS_CC);\n\n\t\t\t\t\t\tif (Z_TYPE_P(val) == IS_LONG) {\n\t\t\t\t\t\t\tzend_hash_index_update((return_all ? Z_ARRVAL_P(return_all) : Z_ARRVAL_P(return_value)), Z_LVAL_P(val), &tmp, sizeof(zval *), NULL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconvert_to_string(val);\n\t\t\t\t\t\t\tzend_symtable_update((return_all ? Z_ARRVAL_P(return_all) : Z_ARRVAL_P(return_value)), Z_STRVAL_P(val), Z_STRLEN_P(val) + 1, &tmp, sizeof(zval *), NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_USE_DEFAULT:\n\t\t\t\tcase PDO_FETCH_BOTH:\n\t\t\t\t\tadd_assoc_zval(return_value, stmt->columns[i].name, val);\n\t\t\t\t\tZ_ADDREF_P(val);\n\t\t\t\t\tadd_next_index_zval(return_value, val);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_NAMED:\n\t\t\t\t\t/* already have an item with this name? */\n\t\t\t\t\t{\n\t\t\t\t\t\tzval **curr_val = NULL;\n\t\t\t\t\t\tif (zend_hash_find(Z_ARRVAL_P(return_value), stmt->columns[i].name,\n\t\t\t\t\t\t\t\t\tstrlen(stmt->columns[i].name)+1,\n\t\t\t\t\t\t\t\t\t(void**)&curr_val) == SUCCESS) {\n\t\t\t\t\t\t\tzval *arr;\n\t\t\t\t\t\t\tif (Z_TYPE_PP(curr_val) != IS_ARRAY) {\n\t\t\t\t\t\t\t\t/* a little bit of black magic here:\n\t\t\t\t\t\t\t\t * we're creating a new array and swapping it for the\n\t\t\t\t\t\t\t\t * zval that's already stored in the hash under the name\n\t\t\t\t\t\t\t\t * we want.  We then add that zval to the array.\n\t\t\t\t\t\t\t\t * This is effectively the same thing as:\n\t\t\t\t\t\t\t\t * if (!is_array($hash[$name])) {\n\t\t\t\t\t\t\t\t *   $hash[$name] = array($hash[$name]);\n\t\t\t\t\t\t\t\t * }\n\t\t\t\t\t\t\t\t * */\n\t\t\t\t\t\t\t\tzval *cur;\n\n\t\t\t\t\t\t\t\tMAKE_STD_ZVAL(arr);\n\t\t\t\t\t\t\t\tarray_init(arr);\n\n\t\t\t\t\t\t\t\tcur = *curr_val;\n\t\t\t\t\t\t\t\t*curr_val = arr;\n\n\t\t\t\t\t\t\t\tadd_next_index_zval(arr, cur);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tarr = *curr_val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tadd_next_index_zval(arr, val);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tadd_assoc_zval(return_value, stmt->columns[i].name, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_NUM:\n\t\t\t\t\tadd_next_index_zval(return_value, val);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_OBJ:\n\t\t\t\tcase PDO_FETCH_INTO:\n\t\t\t\t\tzend_update_property(NULL, return_value,\n\t\t\t\t\t\tstmt->columns[i].name, stmt->columns[i].namelen,\n\t\t\t\t\t\tval TSRMLS_CC);\n\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_CLASS:\n\t\t\t\t\tif ((flags & PDO_FETCH_SERIALIZE) == 0 || idx) {\n\t\t\t\t\t\tzend_update_property(ce, return_value,\n\t\t\t\t\t\t\tstmt->columns[i].name, stmt->columns[i].namelen,\n\t\t\t\t\t\t\tval TSRMLS_CC);\n\t\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\t} else {\n#ifdef MBO_0\n\t\t\t\t\t\tphp_unserialize_data_t var_hash;\n\n\t\t\t\t\t\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\t\t\t\t\t\tif (php_var_unserialize(&return_value, (const unsigned char**)&Z_STRVAL_P(val), Z_STRVAL_P(val)+Z_STRLEN_P(val), NULL TSRMLS_CC) == FAILURE) {\n\t\t\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"cannot unserialize data\" TSRMLS_CC);\n\t\t\t\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n#endif\n\t\t\t\t\t\tif (!ce->unserialize) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"cannot unserialize class\" TSRMLS_CC);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t} else if (ce->unserialize(&return_value, ce, (unsigned char *)(Z_TYPE_P(val) == IS_STRING ? Z_STRVAL_P(val) : \"\"), Z_TYPE_P(val) == IS_STRING ? Z_STRLEN_P(val) : 0, NULL TSRMLS_CC) == FAILURE) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"cannot unserialize class\" TSRMLS_CC);\n\t\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\t\tZVAL_NULL(return_value);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PDO_FETCH_FUNC:\n\t\t\t\t\tstmt->fetch.func.values[idx] = val;\n\t\t\t\t\tstmt->fetch.cls.fci.params[idx] = &stmt->fetch.func.values[idx];\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tzval_ptr_dtor(&val);\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"22003\", \"mode is out of range\" TSRMLS_CC);\n\t\t\t\t\treturn 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tswitch (how) {\n\t\t\tcase PDO_FETCH_CLASS:\n\t\t\t\tif (ce->constructor && !(flags & (PDO_FETCH_PROPS_LATE | PDO_FETCH_SERIALIZE))) {\n\t\t\t\t\tstmt->fetch.cls.fci.object_ptr = return_value;\n\t\t\t\t\tstmt->fetch.cls.fcc.object_ptr = return_value;\n\t\t\t\t\tif (zend_call_function(&stmt->fetch.cls.fci, &stmt->fetch.cls.fcc TSRMLS_CC) == FAILURE) {\n\t\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"could not call class constructor\" TSRMLS_CC);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (stmt->fetch.cls.retval_ptr) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&stmt->fetch.cls.retval_ptr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flags & PDO_FETCH_CLASSTYPE) {\n\t\t\t\t\tdo_fetch_opt_finish(stmt, 0 TSRMLS_CC);\n\t\t\t\t\tstmt->fetch.cls.ce = old_ce;\n\t\t\t\t\tstmt->fetch.cls.ctor_args = old_ctor_args;\n\t\t\t\t\tstmt->fetch.cls.fci.param_count = old_arg_count;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PDO_FETCH_FUNC:\n\t\t\t\tstmt->fetch.func.fci.param_count = idx;\n\t\t\t\tstmt->fetch.func.fci.retval_ptr_ptr = &retval;\n\t\t\t\tif (zend_call_function(&stmt->fetch.func.fci, &stmt->fetch.func.fcc TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tpdo_raise_impl_error(stmt->dbh, stmt, \"HY000\", \"could not call user-supplied function\" TSRMLS_CC);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tif (return_all) {\n\t\t\t\t\t\tzval_ptr_dtor(&return_value); /* we don't need that */\n\t\t\t\t\t\treturn_value = retval;\n\t\t\t\t\t} else if (retval) {\n\t\t\t\t\t\tMAKE_COPY_ZVAL(&retval, return_value);\n\t\t\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(idx--) {\n\t\t\t\t\tzval_ptr_dtor(&stmt->fetch.func.values[idx]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (return_all) {\n\t\t\tif ((flags & PDO_FETCH_UNIQUE) == PDO_FETCH_UNIQUE) {\n\t\t\t\tadd_assoc_zval(return_all, Z_STRVAL(grp_val), return_value);\n\t\t\t} else {\n\t\t\t\tif (zend_symtable_find(Z_ARRVAL_P(return_all), Z_STRVAL(grp_val), Z_STRLEN(grp_val)+1, (void**)&pgrp) == FAILURE) {\n\t\t\t\t\tMAKE_STD_ZVAL(grp);\n\t\t\t\t\tarray_init(grp);\n\t\t\t\t\tadd_assoc_zval(return_all, Z_STRVAL(grp_val), grp);\n\t\t\t\t} else {\n\t\t\t\t\tgrp = *pgrp;\n\t\t\t\t}\n\t\t\t\tadd_next_index_zval(grp, return_value);\n\t\t\t}\n\t\t\tzval_dtor(&grp_val);\n\t\t}\n\n\t}\n\n\treturn 1;\n}\n/* }}} */\n",
        "output": "0",
        "index": 72413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "main(int argc, char **argv)\n{\n   png_uint_32 opts = FAST_WRITE;\n   format_list formats;\n const char *touch = NULL;\n int log_pass = 0;\n int redundant = 0;\n int stride_extra = 0;\n int retval = 0;\n int c;\n\n   init_sRGB_to_d();\n#if 0\n   init_error_via_linear();\n#endif\n   format_init(&formats);\n\n for (c=1; c<argc; ++c)\n {\n const char *arg = argv[c];\n\n if (strcmp(arg, \"--log\") == 0)\n         log_pass = 1;\n else if (strcmp(arg, \"--fresh\") == 0)\n {\n         memset(gpc_error, 0, sizeof gpc_error);\n         memset(gpc_error_via_linear, 0, sizeof gpc_error_via_linear);\n }\n else if (strcmp(arg, \"--file\") == 0)\n#        ifdef PNG_STDIO_SUPPORTED\n            opts |= READ_FILE;\n#        else\n return 77; /* skipped: no support */\n#        endif\n else if (strcmp(arg, \"--memory\") == 0)\n         opts &= ~READ_FILE;\n else if (strcmp(arg, \"--stdio\") == 0)\n#        ifdef PNG_STDIO_SUPPORTED\n            opts |= USE_STDIO;\n#        else\n return 77; /* skipped: no support */\n#        endif\n else if (strcmp(arg, \"--name\") == 0)\n         opts &= ~USE_STDIO;\n else if (strcmp(arg, \"--verbose\") == 0)\n         opts |= VERBOSE;\n else if (strcmp(arg, \"--quiet\") == 0)\n         opts &= ~VERBOSE;\n else if (strcmp(arg, \"--preserve\") == 0)\n         opts |= KEEP_TMPFILES;\n else if (strcmp(arg, \"--nopreserve\") == 0)\n         opts &= ~KEEP_TMPFILES;\n else if (strcmp(arg, \"--keep-going\") == 0)\n         opts |= KEEP_GOING;\n else if (strcmp(arg, \"--fast\") == 0)\n         opts |= FAST_WRITE;\n else if (strcmp(arg, \"--slow\") == 0)\n         opts &= ~FAST_WRITE;\n else if (strcmp(arg, \"--accumulate\") == 0)\n         opts |= ACCUMULATE;\n else if (strcmp(arg, \"--redundant\") == 0)\n         redundant = 1;\n else if (strcmp(arg, \"--stop\") == 0)\n         opts &= ~KEEP_GOING;\n else if (strcmp(arg, \"--strict\") == 0)\n         opts |= STRICT;\n else if (strcmp(arg, \"--sRGB-16bit\") == 0)\n         opts |= sRGB_16BIT;\n else if (strcmp(arg, \"--linear-16bit\") == 0)\n         opts &= ~sRGB_16BIT;\n else if (strcmp(arg, \"--tmpfile\") == 0)\n {\n if (c+1 < argc)\n {\n if (strlen(argv[++c]) >= sizeof tmpf)\n {\n               fflush(stdout);\n               fprintf(stderr, \"%s: %s is too long for a temp file prefix\\n\",\n                  argv[0], argv[c]);\n               exit(99);\n\n             }\n \n             /* Safe: checked above */\n            strcpy(tmpf, argv[c]);\n          }\n \n          else\n {\n            fflush(stdout);\n            fprintf(stderr, \"%s: %s requires a temporary file prefix\\n\",\n               argv[0], arg);\n            exit(99);\n }\n }\n else if (strcmp(arg, \"--touch\") == 0)\n {\n if (c+1 < argc)\n            touch = argv[++c];\n\n else\n {\n            fflush(stdout);\n            fprintf(stderr, \"%s: %s requires a file name argument\\n\",\n               argv[0], arg);\n            exit(99);\n }\n }\n else if (arg[0] == '+')\n {\n         png_uint_32 format = formatof(arg+1);\n\n if (format > FORMAT_COUNT)\n            exit(99);\n\n         format_set(&formats, format);\n }\n else if (arg[0] == '-' && arg[1] != 0 && (arg[1] != '0' || arg[2] != 0))\n {\n         fflush(stdout);\n         fprintf(stderr, \"%s: unknown option: %s\\n\", argv[0], arg);\n         exit(99);\n }\n else\n {\n if (format_is_initial(&formats))\n            format_default(&formats, redundant);\n\n if (arg[0] == '-')\n {\n const int term = (arg[1] == '0' ? 0 : '\\n');\n unsigned int ich = 0;\n\n /* Loop reading files, use a static buffer to simplify this and just\n             * stop if the name gets to long.\n             */\n static char buffer[4096];\n\n do\n {\n int ch = getchar();\n\n /* Don't allow '\\0' in file names, and terminate with '\\n' or,\n                * for -0, just '\\0' (use -print0 to find to make this work!)\n                */\n if (ch == EOF || ch == term || ch == 0)\n {\n                  buffer[ich] = 0;\n\n if (ich > 0 && !test_one_file(buffer, &formats, opts,\n                     stride_extra, log_pass))\n                     retval = 1;\n\n if (ch == EOF)\n break;\n\n                  ich = 0;\n --ich; /* so that the increment below sets it to 0 again */\n }\n\n else\n                  buffer[ich] = (char)ch;\n } while (++ich < sizeof buffer);\n\n if (ich)\n {\n               buffer[32] = 0;\n               buffer[4095] = 0;\n               fprintf(stderr, \"%s...%s: file name too long\\n\", buffer,\n                  buffer+(4096-32));\n               exit(99);\n }\n }\n\n else if (!test_one_file(arg, &formats, opts, stride_extra, log_pass))\n            retval = 1;\n }\n }\n\n if (opts & ACCUMULATE)\n\n    {\n       unsigned int in;\n \n       printf(\"static png_uint_16 gpc_error[16/*in*/][16/*out*/][4/*a*/] =\\n\");\n       printf(\"{\\n\");\n       for (in=0; in<16; ++in)\n {\n unsigned int out;\n         printf(\" { /* input: %s */\\n \", format_names[in]);\n for (out=0; out<16; ++out)\n {\n unsigned int alpha;\n            printf(\" {\");\n for (alpha=0; alpha<4; ++alpha)\n {\n               printf(\" %d\", gpc_error[in][out][alpha]);\n if (alpha < 3) putchar(',');\n }\n            printf(\" }\");\n if (out < 15)\n {\n               putchar(',');\n if (out % 4 == 3) printf(\"\\n \");\n }\n }\n         printf(\"\\n }\");\n\n if (in < 15)\n            putchar(',');\n else\n            putchar('\\n');\n }\n      printf(\"};\\n\");\n\n      printf(\"static png_uint_16 gpc_error_via_linear[16][4/*out*/][4] =\\n\");\n      printf(\"{\\n\");\n for (in=0; in<16; ++in)\n {\n unsigned int out;\n         printf(\" { /* input: %s */\\n \", format_names[in]);\n for (out=0; out<4; ++out)\n {\n unsigned int alpha;\n            printf(\" {\");\n for (alpha=0; alpha<4; ++alpha)\n {\n               printf(\" %d\", gpc_error_via_linear[in][out][alpha]);\n if (alpha < 3) putchar(',');\n }\n            printf(\" }\");\n if (out < 3)\n               putchar(',');\n }\n         printf(\"\\n }\");\n\n if (in < 15)\n            putchar(',');\n else\n            putchar('\\n');\n }\n      printf(\"};\\n\");\n\n      printf(\"static png_uint_16 gpc_error_to_colormap[8/*i*/][8/*o*/][4] =\\n\");\n      printf(\"{\\n\");\n for (in=0; in<8; ++in)\n {\n unsigned int out;\n         printf(\" { /* input: %s */\\n \", format_names[in]);\n for (out=0; out<8; ++out)\n {\n unsigned int alpha;\n            printf(\" {\");\n for (alpha=0; alpha<4; ++alpha)\n {\n               printf(\" %d\", gpc_error_to_colormap[in][out][alpha]);\n if (alpha < 3) putchar(',');\n }\n            printf(\" }\");\n if (out < 7)\n {\n               putchar(',');\n if (out % 4 == 3) printf(\"\\n \");\n }\n }\n         printf(\"\\n }\");\n\n if (in < 7)\n            putchar(',');\n else\n\n             putchar('\\n');\n       }\n       printf(\"};\\n\");\n    }\n \n    if (retval == 0 && touch != NULL)\n {\n FILE *fsuccess = fopen(touch, \"wt\");\n\n if (fsuccess != NULL)\n {\n int error = 0;\n         fprintf(fsuccess, \"PNG simple API tests succeeded\\n\");\n         fflush(fsuccess);\n         error = ferror(fsuccess);\n\n if (fclose(fsuccess) || error)\n {\n            fflush(stdout);\n            fprintf(stderr, \"%s: write failed\\n\", touch);\n            exit(99);\n }\n }\n\n else\n {\n         fflush(stdout);\n         fprintf(stderr, \"%s: open failed\\n\", touch);\n         exit(99);\n }\n }\n\n return retval;\n}\n",
        "output": "1",
        "index": 187617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long cr3, cr4, evmcs_rsp;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr3 = __get_current_cr3_fast();\n\tif (unlikely(cr3 != vmx->loaded_vmcs->vmcs_host_cr3)) {\n\t\tvmcs_writel(HOST_CR3, cr3);\n\t\tvmx->loaded_vmcs->vmcs_host_cr3 = cr3;\n\t}\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->loaded_vmcs->vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->loaded_vmcs->vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    kvm_read_cr4_bits(vcpu, X86_CR4_PKE) &&\n\t    vcpu->arch.pkru != vmx->host_pkru)\n\t\t__write_pkru(vcpu->arch.pkru);\n\n\tatomic_switch_perf_msrs(vmx);\n\n\tvmx_arm_hv_timer(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tif (vmx->spec_ctrl)\n\t\tnative_wrmsrl(MSR_IA32_SPEC_CTRL, vmx->spec_ctrl);\n\n\tvmx->__launched = vmx->loaded_vmcs->launched;\n\n\tevmcs_rsp = static_branch_unlikely(&enable_evmcs) ?\n\t\t(unsigned long)&current_evmcs->host_rsp : 0;\n\n\tasm(\n\t\t/* Store host registers */\n\t\t\"push %%\" _ASM_DX \"; push %%\" _ASM_BP \";\"\n\t\t\"push %%\" _ASM_CX \" \\n\\t\" /* placeholder for guest rcx */\n\t\t\"push %%\" _ASM_CX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t\"je 1f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", %c[host_rsp](%0) \\n\\t\"\n\t\t/* Avoid VMWRITE when Enlightened VMCS is in use */\n\t\t\"test %%\" _ASM_SI \", %%\" _ASM_SI \" \\n\\t\"\n\t\t\"jz 2f \\n\\t\"\n\t\t\"mov %%\" _ASM_SP \", (%%\" _ASM_SI \") \\n\\t\"\n\t\t\"jmp 1f \\n\\t\"\n\t\t\"2: \\n\\t\"\n\t\t__ex(ASM_VMX_VMWRITE_RSP_RDX) \"\\n\\t\"\n\t\t\"1: \\n\\t\"\n\t\t/* Reload cr2 if changed */\n\t\t\"mov %c[cr2](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %%cr2, %%\" _ASM_DX \" \\n\\t\"\n\t\t\"cmp %%\" _ASM_AX \", %%\" _ASM_DX \" \\n\\t\"\n\t\t\"je 3f \\n\\t\"\n\t\t\"mov %%\" _ASM_AX\", %%cr2 \\n\\t\"\n\t\t\"3: \\n\\t\"\n\t\t/* Check if vmlaunch of vmresume is needed */\n\t\t\"cmpl $0, %c[launched](%0) \\n\\t\"\n\t\t/* Load guest registers.  Don't clobber flags. */\n\t\t\"mov %c[rax](%0), %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[rbx](%0), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rdx](%0), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%0), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%0), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%0), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%0),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%0),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%0), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%0), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%0), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%0), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%0), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%0), %%r15 \\n\\t\"\n#endif\n\t\t\"mov %c[rcx](%0), %%\" _ASM_CX \" \\n\\t\" /* kills %0 (ecx) */\n\n\t\t/* Enter guest mode */\n\t\t\"jne 1f \\n\\t\"\n\t\t__ex(ASM_VMX_VMLAUNCH) \"\\n\\t\"\n\t\t\"jmp 2f \\n\\t\"\n\t\t\"1: \" __ex(ASM_VMX_VMRESUME) \"\\n\\t\"\n\t\t\"2: \"\n\t\t/* Save guest registers, load host registers, keep flags */\n\t\t\"mov %0, %c[wordsize](%%\" _ASM_SP \") \\n\\t\"\n\t\t\"pop %0 \\n\\t\"\n\t\t\"setbe %c[fail](%0)\\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[rax](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%0) \\n\\t\"\n\t\t__ASM_SIZE(pop) \" %c[rcx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%0) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%0) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%0) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%0) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%0) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%0) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%0) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%0) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%0) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%0) \\n\\t\"\n\t\t\"xor %%r8d,  %%r8d \\n\\t\"\n\t\t\"xor %%r9d,  %%r9d \\n\\t\"\n\t\t\"xor %%r10d, %%r10d \\n\\t\"\n\t\t\"xor %%r11d, %%r11d \\n\\t\"\n\t\t\"xor %%r12d, %%r12d \\n\\t\"\n\t\t\"xor %%r13d, %%r13d \\n\\t\"\n\t\t\"xor %%r14d, %%r14d \\n\\t\"\n\t\t\"xor %%r15d, %%r15d \\n\\t\"\n#endif\n\t\t\"mov %%cr2, %%\" _ASM_AX \"   \\n\\t\"\n\t\t\"mov %%\" _ASM_AX \", %c[cr2](%0) \\n\\t\"\n\n\t\t\"xor %%eax, %%eax \\n\\t\"\n\t\t\"xor %%ebx, %%ebx \\n\\t\"\n\t\t\"xor %%esi, %%esi \\n\\t\"\n\t\t\"xor %%edi, %%edi \\n\\t\"\n\t\t\"pop  %%\" _ASM_BP \"; pop  %%\" _ASM_DX \" \\n\\t\"\n\t\t\".pushsection .rodata \\n\\t\"\n\t\t\".global vmx_return \\n\\t\"\n\t\t\"vmx_return: \" _ASM_PTR \" 2b \\n\\t\"\n\t\t\".popsection\"\n\t      : : \"c\"(vmx), \"d\"((unsigned long)HOST_RSP), \"S\"(evmcs_rsp),\n\t\t[launched]\"i\"(offsetof(struct vcpu_vmx, __launched)),\n\t\t[fail]\"i\"(offsetof(struct vcpu_vmx, fail)),\n\t\t[host_rsp]\"i\"(offsetof(struct vcpu_vmx, host_rsp)),\n\t\t[rax]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RAX])),\n\t\t[rbx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t[rcx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t[rdx]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t[rsi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t[rdi]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t[rbp]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_RBP])),\n#ifdef CONFIG_X86_64\n\t\t[r8]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t[r9]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t[r10]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t[r11]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t[r12]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t[r13]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t[r14]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t[r15]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.regs[VCPU_REGS_R15])),\n#endif\n\t\t[cr2]\"i\"(offsetof(struct vcpu_vmx, vcpu.arch.cr2)),\n\t\t[wordsize]\"i\"(sizeof(ulong))\n\t      : \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rax\", \"rbx\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"eax\", \"ebx\", \"edi\"\n#endif\n\t      );\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tvmx->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tif (vmx->spec_ctrl)\n\t\tnative_wrmsrl(MSR_IA32_SPEC_CTRL, 0);\n\n\t/* Eliminate branch target predictions from guest mode */\n\tvmexit_fill_RSB();\n\n\t/* All fields are clean at this point */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tcurrent_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (vmx->host_debugctlmsr)\n\t\tupdate_debugctlmsr(vmx->host_debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_load_host_state() since that function\n\t * may be executed in interrupt context, which saves and restore segments\n\t * around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\t/*\n\t * eager fpu is enabled if PKEY is supported and CR4 is switched\n\t * back on host, so it is safe to read guest PKRU from current\n\t * XSAVE.\n\t */\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    kvm_read_cr4_bits(vcpu, X86_CR4_PKE)) {\n\t\tvcpu->arch.pkru = __read_pkru();\n\t\tif (vcpu->arch.pkru != vmx->host_pkru)\n\t\t\t__write_pkru(vmx->host_pkru);\n\t}\n\n\tvmx->nested.nested_run_pending = 0;\n\tvmx->idt_vectoring_info = 0;\n\n\tvmx->exit_reason = vmx->fail ? 0xdead : vmcs_read32(VM_EXIT_REASON);\n\tif (vmx->fail || (vmx->exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY))\n\t\treturn;\n\n\tvmx->loaded_vmcs->launched = 1;\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx_complete_atomic_exit(vmx);\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}\n",
        "output": "0",
        "index": 81087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FeatureInfo::InitializeFloatAndHalfFloatFeatures(\n    const gfx::ExtensionSet& extensions) {\n  bool enable_texture_float = false;\n  bool enable_texture_float_linear = false;\n  bool enable_texture_half_float = false;\n  bool enable_texture_half_float_linear = false;\n  bool enable_ext_color_buffer_float = false;\n  bool enable_ext_color_buffer_half_float = false;\n\n  bool may_enable_chromium_color_buffer_float = false;\n\n  bool enable_es3 = IsWebGL2OrES3OrHigherContext();\n\n  if (gfx::HasExtension(extensions, \"GL_EXT_color_buffer_float\"))\n    enable_ext_color_buffer_float = true;\n  if (gfx::HasExtension(extensions, \"GL_EXT_color_buffer_half_float\")) {\n    enable_ext_color_buffer_half_float = true;\n  }\n\n  if (gfx::HasExtension(extensions, \"GL_ARB_texture_float\") ||\n      gl_version_info_->is_desktop_core_profile) {\n    enable_texture_float = true;\n    enable_texture_float_linear = true;\n    enable_texture_half_float = true;\n    enable_texture_half_float_linear = true;\n    may_enable_chromium_color_buffer_float = true;\n  } else {\n    if (gfx::HasExtension(extensions, \"GL_OES_texture_float\")) {\n      enable_texture_float = true;\n      if (enable_ext_color_buffer_float) {\n        may_enable_chromium_color_buffer_float = true;\n      }\n    }\n\n    if (gfx::HasExtension(extensions, \"GL_OES_texture_float_linear\")) {\n      enable_texture_float_linear = true;\n    }\n\n    if (gfx::HasExtension(extensions, \"GL_OES_texture_half_float\")) {\n      enable_texture_half_float = true;\n    }\n\n    if (gfx::HasExtension(extensions, \"GL_OES_texture_half_float_linear\")) {\n      enable_texture_half_float_linear = true;\n    }\n  }\n\n  if (enable_texture_float) {\n    validators_.pixel_type.AddValue(GL_FLOAT);\n    validators_.read_pixel_type.AddValue(GL_FLOAT);\n    AddExtensionString(\"GL_OES_texture_float\");\n  }\n\n  if (enable_texture_float_linear) {\n    oes_texture_float_linear_available_ = true;\n    if (!disallowed_features_.oes_texture_float_linear)\n      EnableOESTextureFloatLinear();\n  }\n\n  if (enable_texture_half_float) {\n    validators_.pixel_type.AddValue(GL_HALF_FLOAT_OES);\n    validators_.read_pixel_type.AddValue(GL_HALF_FLOAT_OES);\n    AddExtensionString(\"GL_OES_texture_half_float\");\n  }\n\n  if (enable_texture_half_float_linear) {\n    oes_texture_half_float_linear_available_ = true;\n    if (!disallowed_features_.oes_texture_half_float_linear)\n      EnableOESTextureHalfFloatLinear();\n  }\n\n  bool had_native_chromium_color_buffer_float_ext = false;\n  if (gfx::HasExtension(extensions, \"GL_CHROMIUM_color_buffer_float_rgb\")) {\n    had_native_chromium_color_buffer_float_ext = true;\n    feature_flags_.chromium_color_buffer_float_rgb = true;\n    if (!disallowed_features_.chromium_color_buffer_float_rgb) {\n      EnableCHROMIUMColorBufferFloatRGB();\n    }\n  }\n\n  if (gfx::HasExtension(extensions, \"GL_CHROMIUM_color_buffer_float_rgba\")) {\n    had_native_chromium_color_buffer_float_ext = true;\n    feature_flags_.chromium_color_buffer_float_rgba = true;\n    if (!disallowed_features_.chromium_color_buffer_float_rgba) {\n      EnableCHROMIUMColorBufferFloatRGBA();\n    }\n  }\n\n  if (!gl_version_info_->is_es ||\n      gfx::HasExtension(extensions, \"GL_EXT_float_blend\")) {\n    if (!disallowed_features_.ext_float_blend) {\n      EnableEXTFloatBlend();\n    }\n  }\n\n  if (may_enable_chromium_color_buffer_float &&\n      !had_native_chromium_color_buffer_float_ext) {\n    static_assert(GL_RGBA32F_ARB == GL_RGBA32F &&\n                      GL_RGBA32F_EXT == GL_RGBA32F &&\n                      GL_RGB32F_ARB == GL_RGB32F && GL_RGB32F_EXT == GL_RGB32F,\n                  \"sized float internal format variations must match\");\n    GLint fb_binding = 0;\n    GLint tex_binding = 0;\n    glGetIntegerv(GL_FRAMEBUFFER_BINDING, &fb_binding);\n    glGetIntegerv(GL_TEXTURE_BINDING_2D, &tex_binding);\n\n    GLuint tex_id = 0;\n    GLuint fb_id = 0;\n    GLsizei width = 16;\n\n    glGenTextures(1, &tex_id);\n    glGenFramebuffersEXT(1, &fb_id);\n    glBindTexture(GL_TEXTURE_2D, tex_id);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, width, width, 0, GL_RGBA,\n                 GL_FLOAT, nullptr);\n    glBindFramebufferEXT(GL_FRAMEBUFFER, fb_id);\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,\n                              GL_TEXTURE_2D, tex_id, 0);\n    GLenum status_rgba = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB32F, width, width, 0, GL_RGB, GL_FLOAT,\n                 nullptr);\n    GLenum status_rgb = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER);\n\n    if (status_rgba == GL_FRAMEBUFFER_COMPLETE && enable_es3) {\n      bool full_float_support = true;\n      GLenum internal_formats[] = {\n          GL_R16F, GL_RG16F, GL_RGBA16F, GL_R32F, GL_RG32F, GL_R11F_G11F_B10F,\n      };\n      GLenum formats[] = {\n          GL_RED, GL_RG, GL_RGBA, GL_RED, GL_RG, GL_RGB,\n      };\n      DCHECK_EQ(base::size(internal_formats), base::size(formats));\n      for (size_t i = 0; i < base::size(formats); ++i) {\n        glTexImage2D(GL_TEXTURE_2D, 0, internal_formats[i], width, width, 0,\n                     formats[i], GL_FLOAT, nullptr);\n        full_float_support &= glCheckFramebufferStatusEXT(GL_FRAMEBUFFER) ==\n                              GL_FRAMEBUFFER_COMPLETE;\n      }\n      enable_ext_color_buffer_float = full_float_support;\n    }\n    if (IsWebGL1OrES2Context() && !enable_ext_color_buffer_half_float &&\n        (gl_version_info_->IsAtLeastGLES(3, 0) ||\n         gl_version_info_->IsAtLeastGL(3, 0))) {\n      GLenum internal_format = GL_RGBA16F;\n      GLenum format = GL_RGBA;\n      GLenum data_type = GL_HALF_FLOAT;\n      glTexImage2D(GL_TEXTURE_2D, 0, internal_format, width, width, 0, format,\n                   data_type, nullptr);\n      enable_ext_color_buffer_half_float =\n          (glCheckFramebufferStatusEXT(GL_FRAMEBUFFER) ==\n           GL_FRAMEBUFFER_COMPLETE);\n    }\n\n    glDeleteFramebuffersEXT(1, &fb_id);\n    glDeleteTextures(1, &tex_id);\n\n    glBindFramebufferEXT(GL_FRAMEBUFFER, static_cast<GLuint>(fb_binding));\n    glBindTexture(GL_TEXTURE_2D, static_cast<GLuint>(tex_binding));\n\n    DCHECK_EQ(glGetError(), static_cast<GLuint>(GL_NO_ERROR));\n\n    if (status_rgba == GL_FRAMEBUFFER_COMPLETE) {\n      feature_flags_.chromium_color_buffer_float_rgba = true;\n      if (!disallowed_features_.chromium_color_buffer_float_rgba)\n        EnableCHROMIUMColorBufferFloatRGBA();\n    }\n    if (status_rgb == GL_FRAMEBUFFER_COMPLETE) {\n      feature_flags_.chromium_color_buffer_float_rgb = true;\n      if (!disallowed_features_.chromium_color_buffer_float_rgb)\n        EnableCHROMIUMColorBufferFloatRGB();\n    }\n  }\n\n  if (enable_ext_color_buffer_float && enable_es3) {\n    ext_color_buffer_float_available_ = true;\n    if (!disallowed_features_.ext_color_buffer_float)\n      EnableEXTColorBufferFloat();\n  }\n\n  if (enable_ext_color_buffer_half_float) {\n    ext_color_buffer_half_float_available_ = true;\n    if (!disallowed_features_.ext_color_buffer_half_float)\n      EnableEXTColorBufferHalfFloat();\n  }\n\n  if (enable_texture_float) {\n    validators_.texture_internal_format_storage.AddValue(GL_RGBA32F_EXT);\n    validators_.texture_internal_format_storage.AddValue(GL_RGB32F_EXT);\n    validators_.texture_internal_format_storage.AddValue(GL_ALPHA32F_EXT);\n    validators_.texture_internal_format_storage.AddValue(GL_LUMINANCE32F_EXT);\n    validators_.texture_internal_format_storage.AddValue(\n        GL_LUMINANCE_ALPHA32F_EXT);\n  }\n\n  if (enable_texture_half_float) {\n    validators_.texture_internal_format_storage.AddValue(GL_RGBA16F_EXT);\n    validators_.texture_internal_format_storage.AddValue(GL_RGB16F_EXT);\n    validators_.texture_internal_format_storage.AddValue(GL_ALPHA16F_EXT);\n    validators_.texture_internal_format_storage.AddValue(GL_LUMINANCE16F_EXT);\n    validators_.texture_internal_format_storage.AddValue(\n        GL_LUMINANCE_ALPHA16F_EXT);\n  }\n\n  g_l16_is_present =\n      enable_texture_half_float && feature_flags_.ext_texture_storage;\n}\n",
        "output": "0",
        "index": 153863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_snmp(INTERNAL_FUNCTION_PARAMETERS, int st, int version)\n{\n\tzval *oid, *value, *type;\n\tchar *a1, *a2, *a3, *a4, *a5, *a6, *a7;\n\tsize_t a1_len, a2_len, a3_len, a4_len, a5_len, a6_len, a7_len;\n\tzend_bool use_orignames = 0, suffix_keys = 0;\n\tzend_long timeout = SNMP_DEFAULT_TIMEOUT;\n\tzend_long retries = SNMP_DEFAULT_RETRIES;\n\tint argc = ZEND_NUM_ARGS();\n\tstruct objid_query objid_query;\n\tphp_snmp_session *session;\n\tint session_less_mode = (getThis() == NULL);\n\tphp_snmp_object *snmp_object;\n\tphp_snmp_object glob_snmp_object;\n\n\tobjid_query.max_repetitions = -1;\n\tobjid_query.non_repeaters = 0;\n\tobjid_query.valueretrieval = SNMP_G(valueretrieval);\n\tobjid_query.oid_increasing_check = TRUE;\n\n\tif (session_less_mode) {\n\t\tif (version == SNMP_VERSION_3) {\n\t\t\tif (st & SNMP_CMD_SET) {\n\t\t\t\tif (zend_parse_parameters(argc, \"ssssssszzz|ll\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t\t\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len, &oid, &type, &value, &timeout, &retries) == FAILURE) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* SNMP_CMD_GET\n\t\t\t\t * SNMP_CMD_GETNEXT\n\t\t\t\t * SNMP_CMD_WALK\n\t\t\t\t */\n\t\t\t\tif (zend_parse_parameters(argc, \"sssssssz|ll\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t\t\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len, &oid, &timeout, &retries) == FAILURE) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (st & SNMP_CMD_SET) {\n\t\t\t\tif (zend_parse_parameters(argc, \"sszzz|ll\", &a1, &a1_len, &a2, &a2_len, &oid, &type, &value, &timeout, &retries) == FAILURE) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* SNMP_CMD_GET\n\t\t\t\t * SNMP_CMD_GETNEXT\n\t\t\t\t * SNMP_CMD_WALK\n\t\t\t\t */\n\t\t\t\tif (zend_parse_parameters(argc, \"ssz|ll\", &a1, &a1_len, &a2, &a2_len, &oid, &timeout, &retries) == FAILURE) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (st & SNMP_CMD_SET) {\n\t\t\tif (zend_parse_parameters(argc, \"zzz\", &oid, &type, &value) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else if (st & SNMP_CMD_WALK) {\n\t\t\tif (zend_parse_parameters(argc, \"z|bll\", &oid, &suffix_keys, &(objid_query.max_repetitions), &(objid_query.non_repeaters)) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif (suffix_keys) {\n\t\t\t\tst |= SNMP_USE_SUFFIX_AS_KEYS;\n\t\t\t}\n\t\t} else if (st & SNMP_CMD_GET) {\n\t\t\tif (zend_parse_parameters(argc, \"z|b\", &oid, &use_orignames) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif (use_orignames) {\n\t\t\t\tst |= SNMP_ORIGINAL_NAMES_AS_KEYS;\n\t\t\t}\n\t\t} else {\n\t\t\t/* SNMP_CMD_GETNEXT\n\t\t\t */\n\t\t\tif (zend_parse_parameters(argc, \"z\", &oid) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!php_snmp_parse_oid(getThis(), st, &objid_query, oid, type, value)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (session_less_mode) {\n\t\tif (netsnmp_session_init(&session, version, a1, a2, timeout, retries)) {\n\t\t\tefree(objid_query.vars);\n\t\t\tnetsnmp_session_free(&session);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (version == SNMP_VERSION_3 && netsnmp_session_set_security(session, a3, a4, a5, a6, a7, NULL, NULL)) {\n\t\t\tefree(objid_query.vars);\n\t\t\tnetsnmp_session_free(&session);\n\t\t\t/* Warning message sent already, just bail out */\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tzval *object = getThis();\n\t\tsnmp_object = Z_SNMP_P(object);\n\t\tsession = snmp_object->session;\n\t\tif (!session) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid or uninitialized SNMP object\");\n\t\t\tefree(objid_query.vars);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (snmp_object->max_oids > 0) {\n\t\t\tobjid_query.step = snmp_object->max_oids;\n\t\t\tif (objid_query.max_repetitions < 0) { /* unspecified in function call, use session-wise */\n\t\t\t\tobjid_query.max_repetitions = snmp_object->max_oids;\n\t\t\t}\n\t\t}\n\t\tobjid_query.oid_increasing_check = snmp_object->oid_increasing_check;\n\t\tobjid_query.valueretrieval = snmp_object->valueretrieval;\n\t\tglob_snmp_object.enum_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n\t\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM, snmp_object->enum_print);\n\t\tglob_snmp_object.quick_print = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n\t\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT, snmp_object->quick_print);\n\t\tglob_snmp_object.oid_output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n\t\tnetsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT, snmp_object->oid_output_format);\n\t}\n\n\tif (objid_query.max_repetitions < 0) {\n\t\tobjid_query.max_repetitions = 20; /* provide correct default value */\n\t}\n\n\tphp_snmp_internal(INTERNAL_FUNCTION_PARAM_PASSTHRU, st, session, &objid_query);\n\n\tefree(objid_query.vars);\n\n\tif (session_less_mode) {\n\t\tnetsnmp_session_free(&session);\n\t} else {\n\t\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM, glob_snmp_object.enum_print);\n\t\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT, glob_snmp_object.quick_print);\n\t\tnetsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT, glob_snmp_object.oid_output_format);\n\t}\n}\n",
        "output": "0",
        "index": 11229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void JPEGSetImageQuality(struct jpeg_decompress_struct *jpeg_info,\n  Image *image)\n{\n  image->quality=UndefinedCompressionQuality;\n#if defined(D_PROGRESSIVE_SUPPORTED)\n  if (image->compression == LosslessJPEGCompression)\n    {\n      image->quality=100;\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"Quality: 100 (lossless)\");\n    }\n  else\n#endif\n  {\n    ssize_t\n      j,\n      qvalue,\n      sum;\n\n    register ssize_t\n      i;\n\n    /*\n      Determine the JPEG compression quality from the quantization tables.\n    */\n    sum=0;\n    for (i=0; i < NUM_QUANT_TBLS; i++)\n    {\n      if (jpeg_info->quant_tbl_ptrs[i] != NULL)\n        for (j=0; j < DCTSIZE2; j++)\n          sum+=jpeg_info->quant_tbl_ptrs[i]->quantval[j];\n    }\n    if ((jpeg_info->quant_tbl_ptrs[0] != NULL) &&\n        (jpeg_info->quant_tbl_ptrs[1] != NULL))\n      {\n        ssize_t\n          hash[101] =\n          {\n            1020, 1015,  932,  848,  780,  735,  702,  679,  660,  645,\n             632,  623,  613,  607,  600,  594,  589,  585,  581,  571,\n             555,  542,  529,  514,  494,  474,  457,  439,  424,  410,\n             397,  386,  373,  364,  351,  341,  334,  324,  317,  309,\n             299,  294,  287,  279,  274,  267,  262,  257,  251,  247,\n             243,  237,  232,  227,  222,  217,  213,  207,  202,  198,\n             192,  188,  183,  177,  173,  168,  163,  157,  153,  148,\n             143,  139,  132,  128,  125,  119,  115,  108,  104,   99,\n              94,   90,   84,   79,   74,   70,   64,   59,   55,   49,\n              45,   40,   34,   30,   25,   20,   15,   11,    6,    4,\n               0\n          },\n          sums[101] =\n          {\n            32640, 32635, 32266, 31495, 30665, 29804, 29146, 28599, 28104,\n            27670, 27225, 26725, 26210, 25716, 25240, 24789, 24373, 23946,\n            23572, 22846, 21801, 20842, 19949, 19121, 18386, 17651, 16998,\n            16349, 15800, 15247, 14783, 14321, 13859, 13535, 13081, 12702,\n            12423, 12056, 11779, 11513, 11135, 10955, 10676, 10392, 10208,\n             9928,  9747,  9564,  9369,  9193,  9017,  8822,  8639,  8458,\n             8270,  8084,  7896,  7710,  7527,  7347,  7156,  6977,  6788,\n             6607,  6422,  6236,  6054,  5867,  5684,  5495,  5305,  5128,\n             4945,  4751,  4638,  4442,  4248,  4065,  3888,  3698,  3509,\n             3326,  3139,  2957,  2775,  2586,  2405,  2216,  2037,  1846,\n             1666,  1483,  1297,  1109,   927,   735,   554,   375,   201,\n              128,     0\n          };\n\n        qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n          jpeg_info->quant_tbl_ptrs[0]->quantval[53]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[0]+\n          jpeg_info->quant_tbl_ptrs[1]->quantval[DCTSIZE2-1]);\n        for (i=0; i < 100; i++)\n        {\n          if ((qvalue < hash[i]) && (sum < sums[i]))\n            continue;\n          if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n            image->quality=(size_t) i+1;\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n              (sum <= sums[i]) ? \"exact\" : \"approximate\");\n          break;\n        }\n      }\n    else\n      if (jpeg_info->quant_tbl_ptrs[0] != NULL)\n        {\n          ssize_t\n            hash[101] =\n            {\n              510,  505,  422,  380,  355,  338,  326,  318,  311,  305,\n              300,  297,  293,  291,  288,  286,  284,  283,  281,  280,\n              279,  278,  277,  273,  262,  251,  243,  233,  225,  218,\n              211,  205,  198,  193,  186,  181,  177,  172,  168,  164,\n              158,  156,  152,  148,  145,  142,  139,  136,  133,  131,\n              129,  126,  123,  120,  118,  115,  113,  110,  107,  105,\n              102,  100,   97,   94,   92,   89,   87,   83,   81,   79,\n               76,   74,   70,   68,   66,   63,   61,   57,   55,   52,\n               50,   48,   44,   42,   39,   37,   34,   31,   29,   26,\n               24,   21,   18,   16,   13,   11,    8,    6,    3,    2,\n                0\n            },\n            sums[101] =\n            {\n              16320, 16315, 15946, 15277, 14655, 14073, 13623, 13230, 12859,\n              12560, 12240, 11861, 11456, 11081, 10714, 10360, 10027,  9679,\n               9368,  9056,  8680,  8331,  7995,  7668,  7376,  7084,  6823,\n               6562,  6345,  6125,  5939,  5756,  5571,  5421,  5240,  5086,\n               4976,  4829,  4719,  4616,  4463,  4393,  4280,  4166,  4092,\n               3980,  3909,  3835,  3755,  3688,  3621,  3541,  3467,  3396,\n               3323,  3247,  3170,  3096,  3021,  2952,  2874,  2804,  2727,\n               2657,  2583,  2509,  2437,  2362,  2290,  2211,  2136,  2068,\n               1996,  1915,  1858,  1773,  1692,  1620,  1552,  1477,  1398,\n               1326,  1251,  1179,  1109,  1031,   961,   884,   814,   736,\n                667,   592,   518,   441,   369,   292,   221,   151,    86,\n                 64,     0\n            };\n\n          qvalue=(ssize_t) (jpeg_info->quant_tbl_ptrs[0]->quantval[2]+\n            jpeg_info->quant_tbl_ptrs[0]->quantval[53]);\n          for (i=0; i < 100; i++)\n          {\n            if ((qvalue < hash[i]) && (sum < sums[i]))\n              continue;\n            if (((qvalue <= hash[i]) && (sum <= sums[i])) || (i >= 50))\n              image->quality=(size_t)i+1;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Quality: %.20g (%s)\",(double) i+1,(qvalue <= hash[i]) &&\n                (sum <= sums[i]) ? \"exact\" : \"approximate\");\n            break;\n          }\n        }\n  }\n}\n",
        "output": "0",
        "index": 87308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iasecc_set_security_env(struct sc_card *card,\n\t\tconst struct sc_security_env *env, int se_num)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo sdo;\n\tstruct iasecc_private_data *prv = (struct iasecc_private_data *) card->drv_data;\n\tunsigned algo_ref;\n\tstruct sc_apdu apdu;\n\tunsigned sign_meth, sign_ref, auth_meth, auth_ref, aflags;\n\tunsigned char cse_crt_at[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, IASECC_ALGORITHM_RSA_PKCS\n\t};\n\tunsigned char cse_crt_dst[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, (IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA1)\n\t};\n\tunsigned char cse_crt_ht[] = {\n\t\t0x80, 0x01, IASECC_ALGORITHM_SHA1\n\t};\n\tunsigned char cse_crt_ct[] = {\n\t\t0x84, 0x01, 0xFF,\n\t\t0x80, 0x01, (IASECC_ALGORITHM_RSA_PKCS_DECRYPT | IASECC_ALGORITHM_SHA1)\n\t};\n\tint rv, operation = env->operation;\n\n\t/* TODO: take algorithm references from 5032, not from header file. */\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"iasecc_set_security_env(card:%p) operation 0x%X; senv.algorithm 0x%X, senv.algorithm_ref 0x%X\",\n\t\t\tcard, env->operation, env->algorithm, env->algorithm_ref);\n\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_RSA_PRIVATE;\n\tsdo.sdo_ref  = env->key_ref[0] & ~IASECC_OBJECT_REF_LOCAL;\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get RSA PRIVATE SDO data\");\n\n\t/* To made by iasecc_sdo_convert_to_file() */\n\tprv->key_size = *(sdo.docp.size.value + 0) * 0x100 + *(sdo.docp.size.value + 1);\n\tsc_log(ctx, \"prv->key_size 0x%\"SC_FORMAT_LEN_SIZE_T\"X\", prv->key_size);\n\n\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_PSO_COMPUTE_SIGNATURE, &sign_meth, &sign_ref);\n\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_SIGN acl\");\n\n\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_INTERNAL_AUTHENTICATE, &auth_meth, &auth_ref);\n\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_INT_AUTH acl\");\n\n\taflags = env->algorithm_flags;\n\n\tif (!(aflags & SC_ALGORITHM_RSA_PAD_PKCS1))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Only supported signature with PKCS1 padding\");\n\n\tif (operation == SC_SEC_OPERATION_SIGN)   {\n\t\tif (!(aflags & (SC_ALGORITHM_RSA_HASH_SHA1 | SC_ALGORITHM_RSA_HASH_SHA256)))   {\n\t\t\tsc_log(ctx, \"CKM_RSA_PKCS asked -- use 'AUTHENTICATE' sign operation instead of 'SIGN'\");\n\t\t\toperation = SC_SEC_OPERATION_AUTHENTICATE;\n\t\t}\n\t\telse if (sign_meth == SC_AC_NEVER)   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PSO_DST not allowed for this key\");\n\t\t}\n\t}\n\n\tif (operation == SC_SEC_OPERATION_SIGN)   {\n\t\tprv->op_method = sign_meth;\n\t\tprv->op_ref = sign_ref;\n\t}\n\telse if (operation == SC_SEC_OPERATION_AUTHENTICATE)   {\n\t\tif (auth_meth == SC_AC_NEVER)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_ALLOWED, \"INTERNAL_AUTHENTICATE is not allowed for this key\");\n\n\t\tprv->op_method = auth_meth;\n\t\tprv->op_ref = auth_ref;\n\t}\n\n\tsc_log(ctx, \"senv.algorithm 0x%X, senv.algorithm_ref 0x%X\", env->algorithm, env->algorithm_ref);\n\tsc_log(ctx,\n\t       \"se_num %i, operation 0x%X, algorithm 0x%X, algorithm_ref 0x%X, flags 0x%X; key size %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       se_num, operation, env->algorithm, env->algorithm_ref,\n\t       env->algorithm_flags, prv->key_size);\n\tswitch (operation)  {\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tif (!(env->algorithm_flags & SC_ALGORITHM_RSA_PAD_PKCS1))\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_PKCS1 specified\");\n\n\t\tif (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA256)   {\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_HASH, CKM_SHA256);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports HASH:SHA256\");\n\n\t\t\tcse_crt_ht[2] = algo_ref; /* IASECC_ALGORITHM_SHA2 */\n\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_SHA256_RSA_PKCS);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports SIGNATURE:SHA1_RSA_PKCS\");\n\n\t\t\tcse_crt_dst[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\t\tcse_crt_dst[5] = algo_ref;   /* IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA2 */\n\t\t}\n\t\telse if (env->algorithm_flags & SC_ALGORITHM_RSA_HASH_SHA1)   {\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_HASH,  CKM_SHA_1);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports HASH:SHA1\");\n\n\t\t\tcse_crt_ht[2] = algo_ref;\t/* IASECC_ALGORITHM_SHA1 */\n\n\t\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_SHA1_RSA_PKCS);\n\t\t\tif (!algo_ref)\n\t\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Card application do not supports SIGNATURE:SHA1_RSA_PKCS\");\n\n\t\t\tcse_crt_dst[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\t\tcse_crt_dst[5] = algo_ref;   /* IASECC_ALGORITHM_RSA_PKCS | IASECC_ALGORITHM_SHA1 */\n\t\t}\n\t\telse   {\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Need RSA_HASH_SHA[1,256] specified\");\n\t\t}\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_HT);\n\t\tapdu.data = cse_crt_ht;\n\t\tapdu.datalen = sizeof(cse_crt_ht);\n\t\tapdu.lc = sizeof(cse_crt_ht);\n\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\t\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tLOG_TEST_RET(ctx, rv, \"MSE restore error\");\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_DST);\n\t\tapdu.data = cse_crt_dst;\n\t\tapdu.datalen = sizeof(cse_crt_dst);\n\t\tapdu.lc = sizeof(cse_crt_dst);\n\t\tbreak;\n\tcase SC_SEC_OPERATION_AUTHENTICATE:\n\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_COMPUTE_SIGNATURE,  CKM_RSA_PKCS);\n\t\tif (!algo_ref)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Application do not supports SIGNATURE:RSA_PKCS\");\n\n\t\tcse_crt_at[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\tcse_crt_at[5] = algo_ref;\t/* IASECC_ALGORITHM_RSA_PKCS */\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_AT);\n\t\tapdu.data = cse_crt_at;\n\t\tapdu.datalen = sizeof(cse_crt_at);\n\t\tapdu.lc = sizeof(cse_crt_at);\n\t\tbreak;\n\tcase SC_SEC_OPERATION_DECIPHER:\n\t\trv = iasecc_sdo_convert_acl(card, &sdo, SC_AC_OP_PSO_DECRYPT, &prv->op_method, &prv->op_ref);\n\t\tLOG_TEST_RET(ctx, rv, \"Cannot convert SC_AC_OP_PSO_DECRYPT acl\");\n\t\talgo_ref = iasecc_get_algorithm(ctx, env, SC_PKCS15_ALGO_OP_DECIPHER,  CKM_RSA_PKCS);\n\t\tif (!algo_ref)\n\t\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Application do not supports DECIPHER:RSA_PKCS\");\n\n\t\tcse_crt_ct[2] = env->key_ref[0] | IASECC_OBJECT_REF_LOCAL;\n\t\tcse_crt_ct[5] = algo_ref;\t/* IASECC_ALGORITHM_RSA_PKCS_DECRYPT | IASECC_ALGORITHM_SHA1 */\n\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x22, 0x41, IASECC_CRT_TAG_CT);\n\t\tapdu.data = cse_crt_ct;\n\t\tapdu.datalen = sizeof(cse_crt_ct);\n\t\tapdu.lc = sizeof(cse_crt_ct);\n\t\tbreak;\n\tdefault:\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"MSE restore error\");\n\n\tprv->security_env = *env;\n\tprv->security_env.operation = operation;\n\n\tLOG_FUNC_RETURN(ctx, 0);\n}\n",
        "output": "0",
        "index": 78526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayerService::AudioOutput::open(\n uint32_t sampleRate, int channelCount, audio_channel_mask_t channelMask,\n audio_format_t format, int bufferCount,\n AudioCallback cb, void *cookie,\n audio_output_flags_t flags,\n const audio_offload_info_t *offloadInfo,\n bool doNotReconnect,\n uint32_t suggestedFrameCount)\n{\n    ALOGV(\"open(%u, %d, 0x%x, 0x%x, %d, %d 0x%x)\", sampleRate, channelCount, channelMask,\n                format, bufferCount, mSessionId, flags);\n\n if (((flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) != 0) &&\n ((cb == NULL) || (offloadInfo == NULL))) {\n return BAD_VALUE;\n }\n\n size_t frameCount;\n if ((flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) != 0) {\n        frameCount = 0; // AudioTrack will get frame count from AudioFlinger\n } else {\n uint32_t afSampleRate;\n size_t afFrameCount;\n if (AudioSystem::getOutputFrameCount(&afFrameCount, mStreamType) != NO_ERROR) {\n return NO_INIT;\n }\n if (AudioSystem::getOutputSamplingRate(&afSampleRate, mStreamType) != NO_ERROR) {\n return NO_INIT;\n }\n const size_t framesPerBuffer =\n (unsigned long long)sampleRate * afFrameCount / afSampleRate;\n\n if (bufferCount == 0) {\n            bufferCount = (suggestedFrameCount + framesPerBuffer - 1) / framesPerBuffer;\n }\n if (bufferCount != 0 && bufferCount < mMinBufferCount) {\n            ALOGV(\"bufferCount (%d) increased to %d\", bufferCount, mMinBufferCount);\n            bufferCount = mMinBufferCount;\n }\n        frameCount = bufferCount * framesPerBuffer;\n }\n\n if (channelMask == CHANNEL_MASK_USE_CHANNEL_ORDER) {\n        channelMask = audio_channel_out_mask_from_count(channelCount);\n if (0 == channelMask) {\n            ALOGE(\"open() error, can\\'t derive mask for %d audio channels\", channelCount);\n return NO_INIT;\n }\n }\n\n Mutex::Autolock lock(mLock);\n    mCallback = cb;\n    mCallbackCookie = cookie;\n\n bool reuse = false;\n bool bothOffloaded = false;\n\n if (mRecycledTrack != 0) {\n        bothOffloaded = (flags & mRecycledTrack->getFlags()\n & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) != 0;\n\n        reuse = true;\n\n if ((mCallbackData == NULL && mCallback != NULL) ||\n (mCallbackData != NULL && mCallback == NULL)) {\n            ALOGV(\"can't chain callback and write\");\n            reuse = false;\n } else if ((mRecycledTrack->getSampleRate() != sampleRate) ||\n (mRecycledTrack->channelCount() != (uint32_t)channelCount) ) {\n            ALOGV(\"samplerate, channelcount differ: %u/%u Hz, %u/%d ch\",\n                  mRecycledTrack->getSampleRate(), sampleRate,\n                  mRecycledTrack->channelCount(), channelCount);\n            reuse = false;\n } else if (flags != mFlags) {\n            ALOGV(\"output flags differ %08x/%08x\", flags, mFlags);\n            reuse = false;\n } else if (mRecycledTrack->format() != format) {\n            reuse = false;\n }\n } else {\n        ALOGV(\"no track available to recycle\");\n }\n\n    ALOGV_IF(bothOffloaded, \"both tracks offloaded\");\n\n if (bothOffloaded && !reuse) {\n        ALOGV(\"both offloaded and not recycling\");\n        deleteRecycledTrack_l();\n }\n\n    sp<AudioTrack> t;\n CallbackData *newcbd = NULL;\n\n\n if (!(reuse && bothOffloaded)) {\n        ALOGV(\"creating new AudioTrack\");\n\n if (mCallback != NULL) {\n            newcbd = new CallbackData(this);\n            t = new AudioTrack(\n                    mStreamType,\n                    sampleRate,\n                    format,\n                    channelMask,\n                    frameCount,\n                    flags,\n CallbackWrapper,\n                    newcbd,\n 0, // notification frames\n                    mSessionId,\n AudioTrack::TRANSFER_CALLBACK,\n                    offloadInfo,\n                    mUid,\n                    mPid,\n                    mAttributes,\n                    doNotReconnect);\n } else {\n const float targetSpeed =\n                    std::min(std::max(mPlaybackRate.mSpeed, 1.0f), kMaxRequiredSpeed);\n            ALOGW_IF(targetSpeed != mPlaybackRate.mSpeed,\n \"track target speed:%f clamped from playback speed:%f\",\n                    targetSpeed, mPlaybackRate.mSpeed);\n            t = new AudioTrack(\n                    mStreamType,\n                    sampleRate,\n                    format,\n                    channelMask,\n                    frameCount,\n                    flags,\n                    NULL, // callback\n                    NULL, // user data\n 0, // notification frames\n                    mSessionId,\n AudioTrack::TRANSFER_DEFAULT,\n                    NULL, // offload info\n                    mUid,\n                    mPid,\n                    mAttributes,\n                    doNotReconnect,\n                    targetSpeed);\n }\n\n if ((t == 0) || (t->initCheck() != NO_ERROR)) {\n            ALOGE(\"Unable to create audio track\");\n delete newcbd;\n return NO_INIT;\n } else {\n            mStreamType = t->streamType();\n }\n }\n\n if (reuse) {\n        CHECK(mRecycledTrack != NULL);\n\n if (!bothOffloaded) {\n if (mRecycledTrack->frameCount() != t->frameCount()) {\n                ALOGV(\"framecount differs: %zu/%zu frames\",\n                      mRecycledTrack->frameCount(), t->frameCount());\n                reuse = false;\n }\n }\n\n if (reuse) {\n            ALOGV(\"chaining to next output and recycling track\");\n            close_l();\n            mTrack = mRecycledTrack;\n            mRecycledTrack.clear();\n if (mCallbackData != NULL) {\n                mCallbackData->setOutput(this);\n }\n delete newcbd;\n return OK;\n }\n }\n\n if (!bothOffloaded) {\n        deleteRecycledTrack_l();\n }\n\n    CHECK((t != NULL) && ((mCallback == NULL) || (newcbd != NULL)));\n\n    mCallbackData = newcbd;\n    ALOGV(\"setVolume\");\n    t->setVolume(mLeftVolume, mRightVolume);\n\n    mSampleRateHz = sampleRate;\n    mFlags = flags;\n    mMsecsPerFrame = 1E3f / (mPlaybackRate.mSpeed * sampleRate);\n    mFrameSize = t->frameSize();\n    mTrack = t;\n\n status_t res = NO_ERROR;\n if ((t->getFlags() & (AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD | AUDIO_OUTPUT_FLAG_DIRECT)) == 0) {\n        res = t->setPlaybackRate(mPlaybackRate);\n if (res == NO_ERROR) {\n            t->setAuxEffectSendLevel(mSendLevel);\n            res = t->attachAuxEffect(mAuxEffectId);\n }\n }\n    ALOGV(\"open() DONE status %d\", res);\n return res;\n}\n",
        "output": "0",
        "index": 171184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct rmap_item *scan_get_next_rmap_item(struct page **page)\n{\n\tstruct mm_struct *mm;\n\tstruct mm_slot *slot;\n\tstruct vm_area_struct *vma;\n\tstruct rmap_item *rmap_item;\n\n\tif (list_empty(&ksm_mm_head.mm_list))\n\t\treturn NULL;\n\n\tslot = ksm_scan.mm_slot;\n\tif (slot == &ksm_mm_head) {\n\t\t/*\n\t\t * A number of pages can hang around indefinitely on per-cpu\n\t\t * pagevecs, raised page count preventing write_protect_page\n\t\t * from merging them.  Though it doesn't really matter much,\n\t\t * it is puzzling to see some stuck in pages_volatile until\n\t\t * other activity jostles them out, and they also prevented\n\t\t * LTP's KSM test from succeeding deterministically; so drain\n\t\t * them here (here rather than on entry to ksm_do_scan(),\n\t\t * so we don't IPI too often when pages_to_scan is set low).\n\t\t */\n\t\tlru_add_drain_all();\n\n\t\troot_unstable_tree = RB_ROOT;\n\n\t\tspin_lock(&ksm_mmlist_lock);\n \t\tslot = list_entry(slot->mm_list.next, struct mm_slot, mm_list);\n \t\tksm_scan.mm_slot = slot;\n \t\tspin_unlock(&ksm_mmlist_lock);\n next_mm:\n \t\tksm_scan.address = 0;\n \t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\n\tmm = slot->mm;\n\tdown_read(&mm->mmap_sem);\n\tif (ksm_test_exit(mm))\n\t\tvma = NULL;\n\telse\n\t\tvma = find_vma(mm, ksm_scan.address);\n\n\tfor (; vma; vma = vma->vm_next) {\n\t\tif (!(vma->vm_flags & VM_MERGEABLE))\n\t\t\tcontinue;\n\t\tif (ksm_scan.address < vma->vm_start)\n\t\t\tksm_scan.address = vma->vm_start;\n\t\tif (!vma->anon_vma)\n\t\t\tksm_scan.address = vma->vm_end;\n\n\t\twhile (ksm_scan.address < vma->vm_end) {\n\t\t\tif (ksm_test_exit(mm))\n\t\t\t\tbreak;\n\t\t\t*page = follow_page(vma, ksm_scan.address, FOLL_GET);\n\t\t\tif (IS_ERR_OR_NULL(*page)) {\n\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\tcond_resched();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (PageAnon(*page) ||\n\t\t\t    page_trans_compound_anon(*page)) {\n\t\t\t\tflush_anon_page(vma, *page, ksm_scan.address);\n\t\t\t\tflush_dcache_page(*page);\n\t\t\t\trmap_item = get_next_rmap_item(slot,\n\t\t\t\t\tksm_scan.rmap_list, ksm_scan.address);\n\t\t\t\tif (rmap_item) {\n\t\t\t\t\tksm_scan.rmap_list =\n\t\t\t\t\t\t\t&rmap_item->rmap_list;\n\t\t\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tput_page(*page);\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\treturn rmap_item;\n\t\t\t}\n\t\t\tput_page(*page);\n\t\t\tksm_scan.address += PAGE_SIZE;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tif (ksm_test_exit(mm)) {\n\t\tksm_scan.address = 0;\n\t\tksm_scan.rmap_list = &slot->rmap_list;\n\t}\n\t/*\n\t * Nuke all the rmap_items that are above this current rmap:\n\t * because there were no VM_MERGEABLE vmas with such addresses.\n\t */\n\tremove_trailing_rmap_items(slot, ksm_scan.rmap_list);\n\n\tspin_lock(&ksm_mmlist_lock);\n\tksm_scan.mm_slot = list_entry(slot->mm_list.next,\n\t\t\t\t\t\tstruct mm_slot, mm_list);\n\tif (ksm_scan.address == 0) {\n\t\t/*\n\t\t * We've completed a full scan of all vmas, holding mmap_sem\n\t\t * throughout, and found no VM_MERGEABLE: so do the same as\n\t\t * __ksm_exit does to remove this mm from all our lists now.\n\t\t * This applies either when cleaning up after __ksm_exit\n\t\t * (but beware: we can reach here even before __ksm_exit),\n\t\t * or when all VM_MERGEABLE areas have been unmapped (and\n\t\t * mmap_sem then protects against race with MADV_MERGEABLE).\n\t\t */\n\t\thlist_del(&slot->link);\n\t\tlist_del(&slot->mm_list);\n\t\tspin_unlock(&ksm_mmlist_lock);\n\n\t\tfree_mm_slot(slot);\n\t\tclear_bit(MMF_VM_MERGEABLE, &mm->flags);\n\t\tup_read(&mm->mmap_sem);\n\t\tmmdrop(mm);\n\t} else {\n\t\tspin_unlock(&ksm_mmlist_lock);\n\t\tup_read(&mm->mmap_sem);\n\t}\n\n\t/* Repeat until we've completed scanning the whole list */\n\tslot = ksm_scan.mm_slot;\n\tif (slot != &ksm_mm_head)\n\t\tgoto next_mm;\n\n\tksm_scan.seqnr++;\n\treturn NULL;\n}\n",
        "output": "1",
        "index": 179043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_read_n(SSL *s, int n, int max, int extend)\n\t{\n\t/* If extend == 0, obtain new n-byte packet; if extend == 1, increase\n\t * packet by another n bytes.\n\t * The packet will be in the sub-array of s->s3->rbuf.buf specified\n\t * by s->packet and s->packet_length.\n\t * (If s->read_ahead is set, 'max' bytes may be stored in rbuf\n\t * [plus s->packet_length bytes if extend == 1].)\n\t */\n\tint i,len,left;\n\tlong align=0;\n\tunsigned char *pkt;\n\tSSL3_BUFFER *rb;\n\n\tif (n <= 0) return n;\n\n\trb    = &(s->s3->rbuf);\n\tif (rb->buf == NULL)\n\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\treturn -1;\n\n\tleft  = rb->left;\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n\talign = (long)rb->buf + SSL3_RT_HEADER_LENGTH;\n\talign = (-align)&(SSL3_ALIGN_PAYLOAD-1);\n#endif\n\n\tif (!extend)\n\t\t{\n\t\t/* start with empty packet ... */\n\t\tif (left == 0)\n\t\t\trb->offset = align;\n\t\telse if (align != 0 && left >= SSL3_RT_HEADER_LENGTH)\n\t\t\t{\n\t\t\t/* check if next packet length is large\n\t\t\t * enough to justify payload alignment... */\n\t\t\tpkt = rb->buf + rb->offset;\n\t\t\tif (pkt[0] == SSL3_RT_APPLICATION_DATA\n\t\t\t    && (pkt[3]<<8|pkt[4]) >= 128)\n\t\t\t\t{\n\t\t\t\t/* Note that even if packet is corrupted\n\t\t\t\t * and its length field is insane, we can\n\t\t\t\t * only be led to wrong decision about\n\t\t\t\t * whether memmove will occur or not.\n\t\t\t\t * Header values has no effect on memmove\n\t\t\t\t * arguments and therefore no buffer\n\t\t\t\t * overrun can be triggered. */\n\t\t\t\tmemmove (rb->buf+align,pkt,left);\n\t\t\t\trb->offset = align;\n\t\t\t\t}\n\t\t\t}\n\t\ts->packet = rb->buf + rb->offset;\n\t\ts->packet_length = 0;\n\t\t/* ... now we can act as if 'extend' was set */\n\t\t}\n\n\t/* For DTLS/UDP reads should not span multiple packets\n\t * because the read operation returns the whole packet\n\t * at once (as long as it fits into the buffer). */\n\tif (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)\n\t\t{\n\t\tif (left > 0 && n > left)\n\t\t\tn = left;\n\t\t}\n\n\t/* if there is enough in the buffer from a previous read, take some */\n\tif (left >= n)\n\t\t{\n\t\ts->packet_length+=n;\n\t\trb->left=left-n;\n\t\trb->offset+=n;\n\t\treturn(n);\n\t\t}\n\n\t/* else we need to read more data */\n\n\tlen = s->packet_length;\n\tpkt = rb->buf+align;\n\t/* Move any available bytes to front of buffer:\n\t * 'len' bytes already pointed to by 'packet',\n\t * 'left' extra ones at the end */\n\tif (s->packet != pkt) /* len > 0 */\n\t\t{\n\t\tmemmove(pkt, s->packet, len+left);\n\t\ts->packet = pkt;\n\t\trb->offset = len + align;\n\t\t}\n\n\tif (n > (int)(rb->len - rb->offset)) /* does not happen */\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_READ_N,ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\tif (!s->read_ahead)\n\t\t/* ignore max parameter */\n\t\tmax = n;\n\telse\n\t\t{\n\t\tif (max < n)\n\t\t\tmax = n;\n\t\tif (max > (int)(rb->len - rb->offset))\n\t\t\tmax = rb->len - rb->offset;\n\t\t}\n\n\twhile (left < n)\n\t\t{\n\t\t/* Now we have len+left bytes at the front of s->s3->rbuf.buf\n\t\t * and need to read in more until we have len+n (up to\n\t\t * len+max if possible) */\n\n\t\tclear_sys_error();\n\t\tif (s->rbio != NULL)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\ti=BIO_read(s->rbio,pkt+len+left, max-left);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_N,SSL_R_READ_BIO_NOT_SET);\n\t\t\ti = -1;\n\t\t\t}\n\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\trb->left = left;\n\t\t\tif (s->mode & SSL_MODE_RELEASE_BUFFERS &&\n\t\t\t    SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)\n\t\t\t\tif (len+left == 0)\n\t\t\t\t\tssl3_release_read_buffer(s);\n\t\t\treturn(i);\n\t\t\t}\n\t\tleft+=i;\n\t\t/* reads should *never* span multiple packets for DTLS because\n\t\t * the underlying transport protocol is message oriented as opposed\n\t\t * to byte oriented as in the TLS case. */\n\t\tif (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)\n\t\t\t{\n\t\t\tif (n > left)\n\t\t\t\tn = left; /* makes the while condition false */\n\t\t\t}\n\t\t}\n\n\t/* done reading, now the book-keeping */\n\trb->offset += n;\n\trb->left = left - n;\n\ts->packet_length += n;\n\ts->rwstate=SSL_NOTHING;\n\treturn(n);\n\t}\n",
        "output": "0",
        "index": 14342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType ReadOneLayer(const ImageInfo *image_info,Image* image,\n  XCFDocInfo* inDocInfo,XCFLayerInfo *outLayer,const ssize_t layer)\n{\n  MagickOffsetType\n    offset;\n\n  unsigned int\n    foundPropEnd = 0;\n\n  size_t\n    hierarchy_offset,\n    layer_mask_offset;\n\n  /* clear the block! */\n  (void) ResetMagickMemory( outLayer, 0, sizeof( XCFLayerInfo ) );\n  /* read in the layer width, height, type and name */\n  outLayer->width = ReadBlobMSBLong(image);\n  outLayer->height = ReadBlobMSBLong(image);\n  outLayer->type = ReadBlobMSBLong(image);\n  (void) ReadBlobStringWithLongSize(image, outLayer->name,\n    sizeof(outLayer->name));\n  if (EOFBlob(image) != MagickFalse)\n    ThrowBinaryException(CorruptImageError,\"InsufficientImageDataInFile\",\n      image->filename);\n  /* read the layer properties! */\n  foundPropEnd = 0;\n  while ( (foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse) ) {\n  PropType    prop_type = (PropType) ReadBlobMSBLong(image);\n  size_t  prop_size = ReadBlobMSBLong(image);\n    switch (prop_type)\n    {\n    case PROP_END:\n      foundPropEnd = 1;\n      break;\n    case PROP_ACTIVE_LAYER:\n      outLayer->active = 1;\n      break;\n    case PROP_FLOATING_SELECTION:\n      outLayer->floating_offset = ReadBlobMSBLong(image);\n      break;\n    case PROP_OPACITY:\n      outLayer->alpha = ReadBlobMSBLong(image);\n      break;\n    case PROP_VISIBLE:\n      outLayer->visible = ReadBlobMSBLong(image);\n      break;\n    case PROP_LINKED:\n      outLayer->linked = ReadBlobMSBLong(image);\n      break;\n    case PROP_PRESERVE_TRANSPARENCY:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n    case PROP_APPLY_MASK:\n      outLayer->apply_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_EDIT_MASK:\n      outLayer->edit_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_SHOW_MASK:\n      outLayer->show_mask = ReadBlobMSBLong(image);\n      break;\n    case PROP_OFFSETS:\n      outLayer->offset_x = ReadBlobMSBSignedLong(image);\n      outLayer->offset_y = ReadBlobMSBSignedLong(image);\n      break;\n    case PROP_MODE:\n      outLayer->mode = ReadBlobMSBLong(image);\n      break;\n    case PROP_TATTOO:\n      outLayer->preserve_trans = ReadBlobMSBLong(image);\n      break;\n     case PROP_PARASITES:\n     {\n       if (DiscardBlobBytes(image,prop_size) == MagickFalse)\n         ThrowFileException(&image->exception,CorruptImageError,\n           \"UnexpectedEndOfFile\",image->filename);\n\n        /*\n       ssize_t base = info->cp;\n       GimpParasite *p;\n       while (info->cp - base < prop_size)\n       {\n       p = xcf_load_parasite(info);\n       gimp_drawable_parasite_attach(GIMP_DRAWABLE(layer), p);\n       gimp_parasite_free(p);\n       }\n       if (info->cp - base != prop_size)\n       g_message (\"Error detected while loading a layer's parasites\");\n       */\n     }\n     break;\n    default:\n      /* g_message (\"unexpected/unknown layer property: %d (skipping)\",\n         prop_type); */\n\n      {\n      int buf[16];\n      ssize_t amount;\n\n      /* read over it... */\n      while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))\n        {\n        amount = (ssize_t) MagickMin(16, prop_size);\n        amount = ReadBlob(image, (size_t) amount, (unsigned char *) &buf);\n        if (!amount)\n          ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n            image->filename);\n        prop_size -= (size_t) MagickMin(16, (size_t) amount);\n        }\n      }\n      break;\n    }\n  }\n\n  if (foundPropEnd == MagickFalse)\n    return(MagickFalse);\n  /* allocate the image for this layer */\n  if (image_info->number_scenes != 0)\n    {\n      ssize_t\n        scene;\n\n      scene=inDocInfo->number_layers-layer-1;\n      if (scene > (ssize_t) (image_info->scene+image_info->number_scenes-1))\n        {\n          outLayer->image=CloneImage(image,0,0,MagickTrue,&image->exception);\n          if (outLayer->image == (Image *) NULL)\n            return(MagickFalse);\n          InitXCFImage(outLayer);\n          return(MagickTrue);\n        }\n    }\n  /* allocate the image for this layer */\n  outLayer->image=CloneImage(image,outLayer->width, outLayer->height,MagickTrue,\n     &image->exception);\n  if (outLayer->image == (Image *) NULL)\n    return(MagickFalse);\n  /* clear the image based on the layer opacity */\n  outLayer->image->background_color.opacity=\n    ScaleCharToQuantum((unsigned char) (255-outLayer->alpha));\n  (void) SetImageBackgroundColor(outLayer->image);\n\n  InitXCFImage(outLayer);\n\n  /* set the compositing mode */\n  outLayer->image->compose = GIMPBlendModeToCompositeOperator( outLayer->mode );\n  if ( outLayer->visible == MagickFalse )\n    {\n      /* BOGUS: should really be separate member var! */\n      outLayer->image->compose = NoCompositeOp;\n    }\n\n  /* read the hierarchy and layer mask offsets */\n  hierarchy_offset = ReadBlobMSBLong(image);\n  layer_mask_offset = ReadBlobMSBLong(image);\n\n  /* read in the hierarchy */\n  offset=SeekBlob(image, (MagickOffsetType) hierarchy_offset, SEEK_SET);\n  if (offset != (MagickOffsetType) hierarchy_offset)\n    (void) ThrowMagickException(&image->exception,GetMagickModule(),\n      CorruptImageError,\"InvalidImageHeader\",\"`%s'\",image->filename);\n  if (load_hierarchy (image, inDocInfo, outLayer) == 0)\n    return(MagickFalse);\n\n  /* read in the layer mask */\n  if (layer_mask_offset != 0)\n    {\n      offset=SeekBlob(image, (MagickOffsetType) layer_mask_offset, SEEK_SET);\n\n#if 0  /* BOGUS: support layer masks! */\n      layer_mask = xcf_load_layer_mask (info, gimage);\n      if (layer_mask == 0)\n  goto error;\n\n      /* set the offsets of the layer_mask */\n      GIMP_DRAWABLE (layer_mask)->offset_x = GIMP_DRAWABLE (layer)->offset_x;\n      GIMP_DRAWABLE (layer_mask)->offset_y = GIMP_DRAWABLE (layer)->offset_y;\n\n      gimp_layer_add_mask (layer, layer_mask, MagickFalse);\n\n      layer->mask->apply_mask = apply_mask;\n      layer->mask->edit_mask  = edit_mask;\n      layer->mask->show_mask  = show_mask;\n#endif\n  }\n\n  /* attach the floating selection... */\n#if 0  /* BOGUS: we may need to read this, even if we don't support it! */\n  if (add_floating_sel)\n    {\n      GimpLayer *floating_sel;\n\n      floating_sel = info->floating_sel;\n      floating_sel_attach (floating_sel, GIMP_DRAWABLE (layer));\n    }\n#endif\n\n  return MagickTrue;\n}\n",
        "output": "0",
        "index": 68001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgdImageDestroy(im);\n\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n\t\t\t\t\t\t\t\tgdImageDestroy(im);\n\t\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "index": 70906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int default_handler(request_rec *r)\n{\n    conn_rec *c = r->connection;\n    apr_bucket_brigade *bb;\n    apr_bucket *e;\n    core_dir_config *d;\n    int errstatus;\n    apr_file_t *fd = NULL;\n    apr_status_t status;\n    /* XXX if/when somebody writes a content-md5 filter we either need to\n     *     remove this support or coordinate when to use the filter vs.\n     *     when to use this code\n     *     The current choice of when to compute the md5 here matches the 1.3\n     *     support fairly closely (unlike 1.3, we don't handle computing md5\n     *     when the charset is translated).\n     */\n    int bld_content_md5;\n\n    d = (core_dir_config *)ap_get_core_module_config(r->per_dir_config);\n    bld_content_md5 = (d->content_md5 == AP_CONTENT_MD5_ON)\n                      && r->output_filters->frec->ftype != AP_FTYPE_RESOURCE;\n\n    ap_allow_standard_methods(r, MERGE_ALLOW, M_GET, M_OPTIONS, M_POST, -1);\n\n    /* If filters intend to consume the request body, they must\n     * register an InputFilter to slurp the contents of the POST\n     * data from the POST input stream.  It no longer exists when\n     * the output filters are invoked by the default handler.\n     */\n    if ((errstatus = ap_discard_request_body(r)) != OK) {\n        return errstatus;\n    }\n\n    if (r->method_number == M_GET || r->method_number == M_POST) {\n        if (r->finfo.filetype == APR_NOFILE) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00128)\n                          \"File does not exist: %s\",\n                          apr_pstrcat(r->pool, r->filename, r->path_info, NULL));\n            return HTTP_NOT_FOUND;\n        }\n\n        /* Don't try to serve a dir.  Some OSs do weird things with\n         * raw I/O on a dir.\n         */\n        if (r->finfo.filetype == APR_DIR) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00129)\n                          \"Attempt to serve directory: %s\", r->filename);\n            return HTTP_NOT_FOUND;\n        }\n\n        if ((r->used_path_info != AP_REQ_ACCEPT_PATH_INFO) &&\n            r->path_info && *r->path_info)\n        {\n            /* default to reject */\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00130)\n                          \"File does not exist: %s\",\n                          apr_pstrcat(r->pool, r->filename, r->path_info, NULL));\n            return HTTP_NOT_FOUND;\n        }\n\n        /* We understood the (non-GET) method, but it might not be legal for\n           this particular resource. Check to see if the 'deliver_script'\n           flag is set. If so, then we go ahead and deliver the file since\n           it isn't really content (only GET normally returns content).\n\n           Note: based on logic further above, the only possible non-GET\n           method at this point is POST. In the future, we should enable\n           script delivery for all methods.  */\n        if (r->method_number != M_GET) {\n            core_request_config *req_cfg;\n\n            req_cfg = ap_get_core_module_config(r->request_config);\n            if (!req_cfg->deliver_script) {\n                /* The flag hasn't been set for this request. Punt. */\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00131)\n                              \"This resource does not accept the %s method.\",\n                              r->method);\n                return HTTP_METHOD_NOT_ALLOWED;\n            }\n        }\n\n\n        if ((status = apr_file_open(&fd, r->filename, APR_READ | APR_BINARY\n#if APR_HAS_SENDFILE\n                            | AP_SENDFILE_ENABLED(d->enable_sendfile)\n#endif\n                                    , 0, r->pool)) != APR_SUCCESS) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, status, r, APLOGNO(00132)\n                          \"file permissions deny server access: %s\", r->filename);\n            return HTTP_FORBIDDEN;\n        }\n\n        ap_update_mtime(r, r->finfo.mtime);\n        ap_set_last_modified(r);\n        ap_set_etag(r);\n        ap_set_accept_ranges(r);\n        ap_set_content_length(r, r->finfo.size);\n        if (bld_content_md5) {\n            apr_table_setn(r->headers_out, \"Content-MD5\",\n                           ap_md5digest(r->pool, fd));\n        }\n\n        bb = apr_brigade_create(r->pool, c->bucket_alloc);\n\n        if ((errstatus = ap_meets_conditions(r)) != OK) {\n            apr_file_close(fd);\n            r->status = errstatus;\n        }\n        else {\n            e = apr_brigade_insert_file(bb, fd, 0, r->finfo.size, r->pool);\n\n#if APR_HAS_MMAP\n            if (d->enable_mmap == ENABLE_MMAP_OFF) {\n                (void)apr_bucket_file_enable_mmap(e, 0);\n            }\n#endif\n        }\n\n        e = apr_bucket_eos_create(c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(bb, e);\n\n        status = ap_pass_brigade(r->output_filters, bb);\n        apr_brigade_cleanup(bb);\n\n        if (status == APR_SUCCESS\n            || r->status != HTTP_OK\n            || c->aborted) {\n            return OK;\n        }\n        else {\n            /* no way to know what type of error occurred */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, status, r, APLOGNO(00133)\n                          \"default_handler: ap_pass_brigade returned %i\",\n                          status);\n            return AP_FILTER_ERROR;\n        }\n    }\n    else {              /* unusual method (not GET or POST) */\n        if (r->method_number == M_INVALID) {\n            /* See if this looks like an undecrypted SSL handshake attempt.\n             * It's safe to look a couple bytes into the_request if it exists, as it's\n             * always allocated at least MIN_LINE_ALLOC (80) bytes.\n             */\n            if (r->the_request\n                && r->the_request[0] == 0x16\n                && (r->the_request[1] == 0x2 || r->the_request[1] == 0x3)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00134)\n                              \"Invalid method in request %s - possible attempt to establish SSL connection on non-SSL port\", r->the_request);\n            } else {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00135)\n                              \"Invalid method in request %s\", r->the_request);\n            }\n            return HTTP_NOT_IMPLEMENTED;\n        }\n\n        if (r->method_number == M_OPTIONS) {\n            return ap_send_http_options(r);\n        }\n        return HTTP_METHOD_NOT_ALLOWED;\n    }\n}\n",
        "output": "0",
        "index": 64237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int PreProcessingFx_Process(effect_handle_t     self,\n audio_buffer_t *inBuffer,\n audio_buffer_t *outBuffer)\n{\n preproc_effect_t * effect = (preproc_effect_t *)self;\n int    status = 0;\n\n if (effect == NULL){\n        ALOGV(\"PreProcessingFx_Process() ERROR effect == NULL\");\n return -EINVAL;\n }\n preproc_session_t * session = (preproc_session_t *)effect->session;\n\n if (inBuffer == NULL  || inBuffer->raw == NULL  ||\n            outBuffer == NULL || outBuffer->raw == NULL){\n        ALOGW(\"PreProcessingFx_Process() ERROR bad pointer\");\n return -EINVAL;\n }\n\n    session->processedMsk |= (1<<effect->procId);\n\n\n if ((session->processedMsk & session->enabledMsk) == session->enabledMsk) {\n        effect->session->processedMsk = 0;\n size_t framesRq = outBuffer->frameCount;\n size_t framesWr = 0;\n if (session->framesOut) {\n size_t fr = session->framesOut;\n if (outBuffer->frameCount < fr) {\n                fr = outBuffer->frameCount;\n }\n            memcpy(outBuffer->s16,\n                  session->outBuf,\n                  fr * session->outChannelCount * sizeof(int16_t));\n            memcpy(session->outBuf,\n                  session->outBuf + fr * session->outChannelCount,\n (session->framesOut - fr) * session->outChannelCount * sizeof(int16_t));\n            session->framesOut -= fr;\n            framesWr += fr;\n }\n        outBuffer->frameCount = framesWr;\n if (framesWr == framesRq) {\n            inBuffer->frameCount = 0;\n return 0;\n }\n\n if (session->inResampler != NULL) {\n size_t fr = session->frameCount - session->framesIn;\n if (inBuffer->frameCount < fr) {\n                fr = inBuffer->frameCount;\n }\n if (session->inBufSize < session->framesIn + fr) {\n                session->inBufSize = session->framesIn + fr;\n                session->inBuf = (int16_t *)realloc(session->inBuf,\n                                 session->inBufSize * session->inChannelCount * sizeof(int16_t));\n }\n            memcpy(session->inBuf + session->framesIn * session->inChannelCount,\n                   inBuffer->s16,\n                   fr * session->inChannelCount * sizeof(int16_t));\n#ifdef DUAL_MIC_TEST\n            pthread_mutex_lock(&gPcmDumpLock);\n if (gPcmDumpFh != NULL) {\n                fwrite(inBuffer->raw,\n                       fr * session->inChannelCount * sizeof(int16_t), 1, gPcmDumpFh);\n }\n            pthread_mutex_unlock(&gPcmDumpLock);\n#endif\n\n            session->framesIn += fr;\n            inBuffer->frameCount = fr;\n if (session->framesIn < session->frameCount) {\n return 0;\n }\n spx_uint32_t frIn = session->framesIn;\n spx_uint32_t frOut = session->apmFrameCount;\n if (session->inChannelCount == 1) {\n                speex_resampler_process_int(session->inResampler,\n 0,\n                                            session->inBuf,\n &frIn,\n                                            session->procFrame->_payloadData,\n &frOut);\n } else {\n                speex_resampler_process_interleaved_int(session->inResampler,\n                                                        session->inBuf,\n &frIn,\n                                                        session->procFrame->_payloadData,\n &frOut);\n }\n            memcpy(session->inBuf,\n                   session->inBuf + frIn * session->inChannelCount,\n (session->framesIn - frIn) * session->inChannelCount * sizeof(int16_t));\n            session->framesIn -= frIn;\n } else {\n size_t fr = session->frameCount - session->framesIn;\n if (inBuffer->frameCount < fr) {\n                fr = inBuffer->frameCount;\n }\n            memcpy(session->procFrame->_payloadData + session->framesIn * session->inChannelCount,\n                   inBuffer->s16,\n                   fr * session->inChannelCount * sizeof(int16_t));\n\n#ifdef DUAL_MIC_TEST\n            pthread_mutex_lock(&gPcmDumpLock);\n if (gPcmDumpFh != NULL) {\n                fwrite(inBuffer->raw,\n                       fr * session->inChannelCount * sizeof(int16_t), 1, gPcmDumpFh);\n }\n            pthread_mutex_unlock(&gPcmDumpLock);\n#endif\n\n            session->framesIn += fr;\n            inBuffer->frameCount = fr;\n if (session->framesIn < session->frameCount) {\n return 0;\n }\n            session->framesIn = 0;\n }\n        session->procFrame->_payloadDataLengthInSamples =\n                session->apmFrameCount * session->inChannelCount;\n\n        effect->session->apm->ProcessStream(session->procFrame);\n\n if (session->outBufSize < session->framesOut + session->frameCount) {\n            session->outBufSize = session->framesOut + session->frameCount;\n            session->outBuf = (int16_t *)realloc(session->outBuf,\n                              session->outBufSize * session->outChannelCount * sizeof(int16_t));\n }\n\n if (session->outResampler != NULL) {\n spx_uint32_t frIn = session->apmFrameCount;\n spx_uint32_t frOut = session->frameCount;\n if (session->inChannelCount == 1) {\n                speex_resampler_process_int(session->outResampler,\n 0,\n                                    session->procFrame->_payloadData,\n &frIn,\n                                    session->outBuf + session->framesOut * session->outChannelCount,\n &frOut);\n } else {\n                speex_resampler_process_interleaved_int(session->outResampler,\n                                    session->procFrame->_payloadData,\n &frIn,\n                                    session->outBuf + session->framesOut * session->outChannelCount,\n &frOut);\n }\n            session->framesOut += frOut;\n } else {\n            memcpy(session->outBuf + session->framesOut * session->outChannelCount,\n                   session->procFrame->_payloadData,\n                   session->frameCount * session->outChannelCount * sizeof(int16_t));\n            session->framesOut += session->frameCount;\n }\n size_t fr = session->framesOut;\n if (framesRq - framesWr < fr) {\n            fr = framesRq - framesWr;\n }\n        memcpy(outBuffer->s16 + framesWr * session->outChannelCount,\n              session->outBuf,\n              fr * session->outChannelCount * sizeof(int16_t));\n        memcpy(session->outBuf,\n              session->outBuf + fr * session->outChannelCount,\n (session->framesOut - fr) * session->outChannelCount * sizeof(int16_t));\n        session->framesOut -= fr;\n        outBuffer->frameCount += fr;\n\n return 0;\n } else {\n return -ENODATA;\n }\n}\n",
        "output": "0",
        "index": 170653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vldb_reply_print(netdissect_options *ndo,\n                 register const u_char *bp, int length, int32_t opcode)\n{\n\tconst struct rx_header *rxh;\n\tunsigned long i;\n\n\tif (length < (int)sizeof(struct rx_header))\n\t\treturn;\n\n\trxh = (const struct rx_header *) bp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from vlserver/vldbint.xg.  Check to see if it's a\n\t * Ubik call, however.\n\t */\n\n\tND_PRINT((ndo, \" vldb\"));\n\n\tif (is_ubik(opcode)) {\n\t\tubik_reply_print(ndo, bp, length, opcode);\n\t\treturn;\n\t}\n\n\tND_PRINT((ndo, \" reply %s\", tok2str(vldb_req, \"op#%d\", opcode)));\n\n\tbp += sizeof(struct rx_header);\n\n\t/*\n\t * If it was a data packet, interpret the response\n\t */\n\n\tif (rxh->type == RX_PACKET_TYPE_DATA)\n\t\tswitch (opcode) {\n\t\tcase 510:\t/* List entry */\n\t\t\tND_PRINT((ndo, \" count\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" nextindex\"));\n\t\t\tINTOUT();\n\t\tcase 503:\t/* Get entry by id */\n\t\tcase 504:\t/* Get entry by name */\n\t\t{\tunsigned long nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" numservers\"));\n\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\tnservers = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" %lu\", nservers));\n\t\t\tND_PRINT((ndo, \" servers\"));\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\t\tif (i < nservers)\n\t\t\t\t\tND_PRINT((ndo, \" %s\",\n\t\t\t\t\t   intoa(((const struct in_addr *) bp)->s_addr)));\n\t\t\t\tbp += sizeof(int32_t);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" partitions\"));\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\t\tj = EXTRACT_32BITS(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT((ndo, \" %c\", 'a' + (int)j));\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT((ndo, \" %lu\", j));\n\t\t\t\tbp += sizeof(int32_t);\n\t\t\t}\n\t\t\tND_TCHECK2(bp[0], 8 * sizeof(int32_t));\n\t\t\tbp += 8 * sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" rwvol\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" rovol\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" backup\"));\n\t\t\tUINTOUT();\n\t\t}\n\t\t\tbreak;\n\t\tcase 505:\t/* Get new volume ID */\n\t\t\tND_PRINT((ndo, \" newvol\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 521:\t/* List entry */\n\t\tcase 529:\t/* List entry U */\n\t\t\tND_PRINT((ndo, \" count\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" nextindex\"));\n\t\t\tINTOUT();\n\t\tcase 518:\t/* Get entry by ID N */\n\t\tcase 519:\t/* Get entry by name N */\n\t\t{\tunsigned long nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_PRINT((ndo, \" numservers\"));\n\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\tnservers = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" %lu\", nservers));\n\t\t\tND_PRINT((ndo, \" servers\"));\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\t\tif (i < nservers)\n\t\t\t\t\tND_PRINT((ndo, \" %s\",\n\t\t\t\t\t   intoa(((const struct in_addr *) bp)->s_addr)));\n\t\t\t\tbp += sizeof(int32_t);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" partitions\"));\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\t\tj = EXTRACT_32BITS(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT((ndo, \" %c\", 'a' + (int)j));\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT((ndo, \" %lu\", j));\n\t\t\t\tbp += sizeof(int32_t);\n\t\t\t}\n\t\t\tND_TCHECK2(bp[0], 13 * sizeof(int32_t));\n\t\t\tbp += 13 * sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" rwvol\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" rovol\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" backup\"));\n\t\t\tUINTOUT();\n\t\t}\n\t\t\tbreak;\n\t\tcase 526:\t/* Get entry by ID U */\n\t\tcase 527:\t/* Get entry by name U */\n\t\t{\tunsigned long nservers, j;\n\t\t\tVECOUT(VLNAMEMAX);\n\t\t\tND_PRINT((ndo, \" numservers\"));\n\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\tnservers = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" %lu\", nservers));\n\t\t\tND_PRINT((ndo, \" servers\"));\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tif (i < nservers) {\n\t\t\t\t\tND_PRINT((ndo, \" afsuuid\"));\n\t\t\t\t\tAFSUUIDOUT();\n\t\t\t\t} else {\n\t\t\t\t\tND_TCHECK2(bp[0], 44);\n\t\t\t\t\tbp += 44;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_TCHECK2(bp[0], 4 * 13);\n\t\t\tbp += 4 * 13;\n\t\t\tND_PRINT((ndo, \" partitions\"));\n\t\t\tfor (i = 0; i < 13; i++) {\n\t\t\t\tND_TCHECK2(bp[0], sizeof(int32_t));\n\t\t\t\tj = EXTRACT_32BITS(bp);\n\t\t\t\tif (i < nservers && j <= 26)\n\t\t\t\t\tND_PRINT((ndo, \" %c\", 'a' + (int)j));\n\t\t\t\telse if (i < nservers)\n\t\t\t\t\tND_PRINT((ndo, \" %lu\", j));\n\t\t\t\tbp += sizeof(int32_t);\n\t\t\t}\n\t\t\tND_TCHECK2(bp[0], 13 * sizeof(int32_t));\n\t\t\tbp += 13 * sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" rwvol\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" rovol\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" backup\"));\n\t\t\tUINTOUT();\n\t\t}\n\t\tdefault:\n\t\t\t;\n\t\t}\n\n\telse {\n\t\t/*\n\t\t * Otherwise, just print out the return code\n\t\t */\n\t\tND_PRINT((ndo, \" errcode\"));\n\t\tINTOUT();\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|vldb]\"));\n}\n",
        "output": "0",
        "index": 62285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tconst struct ikev2_n *p;\n\tstruct ikev2_n n;\n\tconst u_char *cp;\n\tu_char showspi, showsomedata;\n\tconst char *notify_name;\n\tuint32_t type;\n\n\tp = (const struct ikev2_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n\n\tshowspi = 1;\n\tshowsomedata=0;\n\tnotify_name=NULL;\n\n\tND_PRINT((ndo,\" prot_id=%s\", PROTOIDSTR(n.prot_id)));\n\n\ttype = ntohs(n.type);\n\n\t/* notify space is annoying sparse */\n\tswitch(type) {\n\tcase IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:\n\t\tnotify_name = \"unsupported_critical_payload\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_IKE_SPI:\n\t\tnotify_name = \"invalid_ike_spi\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MAJOR_VERSION:\n\t\tnotify_name = \"invalid_major_version\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SYNTAX:\n\t\tnotify_name = \"invalid_syntax\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MESSAGE_ID:\n\t\tnotify_name = \"invalid_message_id\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SPI:\n\t\tnotify_name = \"invalid_spi\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_PROPOSAL_CHOSEN:\n\t\tnotify_name = \"no_protocol_chosen\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_KE_PAYLOAD:\n\t\tnotify_name = \"invalid_ke_payload\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_AUTHENTICATION_FAILED:\n\t\tnotify_name = \"authentication_failed\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SINGLE_PAIR_REQUIRED:\n\t\tnotify_name = \"single_pair_required\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_ADDITIONAL_SAS:\n\t\tnotify_name = \"no_additional_sas\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:\n\t\tnotify_name = \"internal_address_failure\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_FAILED_CP_REQUIRED:\n\t\tnotify_name = \"failed:cp_required\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SELECTORS:\n\t\tnotify_name = \"invalid_selectors\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INITIAL_CONTACT:\n\t\tnotify_name = \"initial_contact\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SET_WINDOW_SIZE:\n\t\tnotify_name = \"set_window_size\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:\n\t\tnotify_name = \"additional_ts_possible\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_IPCOMP_SUPPORTED:\n\t\tnotify_name = \"ipcomp_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:\n\t\tnotify_name = \"nat_detection_source_ip\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:\n\t\tnotify_name = \"nat_detection_destination_ip\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_COOKIE:\n\t\tnotify_name = \"cookie\";\n\t\tshowspi = 1;\n\t\tshowsomedata= 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n\t\tnotify_name = \"use_transport_mode\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:\n\t\tnotify_name = \"http_cert_lookup_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_REKEY_SA:\n\t\tnotify_name = \"rekey_sa\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:\n\t\tnotify_name = \"tfc_padding_not_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:\n\t\tnotify_name = \"non_first_fragment_also\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (type < 8192) {\n\t\t\tnotify_name=\"error\";\n\t\t} else if(type < 16384) {\n\t\t\tnotify_name=\"private-error\";\n\t\t} else if(type < 40960) {\n\t\t\tnotify_name=\"status\";\n\t\t} else {\n\t\t\tnotify_name=\"private-status\";\n\t\t}\n\t}\n\n\tif(notify_name) {\n\t\tND_PRINT((ndo,\" type=%u(%s)\", type, notify_name));\n\t}\n\n\n\tif (showspi && n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\n\tif (cp < ep) {\n\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\tgoto trunc;\n\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t} else if (showsomedata) {\n\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 62007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport Image *CropImageToTiles(const Image *image,\n  const char *crop_geometry,ExceptionInfo *exception)\n{\n  Image\n    *next,\n    *crop_image;\n\n  MagickStatusType\n    flags;\n\n  RectangleInfo\n    geometry;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  crop_image=NewImageList();\n  next=NewImageList();\n  flags=ParseGravityGeometry(image,crop_geometry,&geometry,exception);\n  if ((flags & AreaValue) != 0)\n    {\n      PointInfo\n        delta,\n        offset;\n\n      RectangleInfo\n        crop;\n\n      size_t\n        height,\n        width;\n\n      /*\n        Crop into NxM tiles (@ flag).\n      */\n      width=image->columns;\n      height=image->rows;\n      if (geometry.width == 0)\n        geometry.width=1;\n      if (geometry.height == 0)\n        geometry.height=1;\n      if ((flags & AspectValue) == 0)\n        {\n          width-=(geometry.x < 0 ? -1 : 1)*geometry.x;\n          height-=(geometry.y < 0 ? -1 : 1)*geometry.y;\n        }\n      else\n        {\n          width+=(geometry.x < 0 ? -1 : 1)*geometry.x;\n          height+=(geometry.y < 0 ? -1 : 1)*geometry.y;\n        }\n      delta.x=(double) width/geometry.width;\n      delta.y=(double) height/geometry.height;\n      if (delta.x < 1.0)\n        delta.x=1.0;\n      if (delta.y < 1.0)\n        delta.y=1.0;\n      for (offset.y=0; offset.y < (double) height; )\n      {\n        if ((flags & AspectValue) == 0)\n          {\n            crop.y=(ssize_t) MagickRound((double) (offset.y-\n              (geometry.y > 0 ? 0 : geometry.y)));\n            offset.y+=delta.y;   /* increment now to find width */\n            crop.height=(size_t) MagickRound((double) (offset.y+\n              (geometry.y < 0 ? 0 : geometry.y)));\n          }\n        else\n          {\n            crop.y=(ssize_t) MagickRound((double) (offset.y-\n              (geometry.y > 0 ? geometry.y : 0)));\n            offset.y+=delta.y;  /* increment now to find width */\n            crop.height=(size_t) MagickRound((double)\n              (offset.y+(geometry.y < -1 ? geometry.y : 0)));\n          }\n        crop.height-=crop.y;\n        crop.y+=image->page.y;\n        for (offset.x=0; offset.x < (double) width; )\n        {\n          if ((flags & AspectValue) == 0)\n            {\n              crop.x=(ssize_t) MagickRound((double) (offset.x-\n                (geometry.x > 0 ? 0 : geometry.x)));\n              offset.x+=delta.x;  /* increment now to find height */\n              crop.width=(size_t) MagickRound((double) (offset.x+\n                (geometry.x < 0 ? 0 : geometry.x)));\n            }\n          else\n            {\n              crop.x=(ssize_t) MagickRound((double) (offset.x-\n                (geometry.x > 0 ? geometry.x : 0)));\n              offset.x+=delta.x;  /* increment now to find height */\n              crop.width=(size_t) MagickRound((double) (offset.x+\n                (geometry.x < 0 ? geometry.x : 0)));\n            }\n          crop.width-=crop.x;\n          crop.x+=image->page.x;\n          next=CropImage(image,&crop,exception);\n          if (next != (Image *) NULL)\n            AppendImageToList(&crop_image,next);\n        }\n      }\n      ClearMagickException(exception);\n      return(crop_image);\n    }\n  if (((geometry.width == 0) && (geometry.height == 0)) ||\n      ((flags & XValue) != 0) || ((flags & YValue) != 0))\n    {\n      /*\n        Crop a single region at +X+Y.\n      */\n      crop_image=CropImage(image,&geometry,exception);\n      if ((crop_image != (Image *) NULL) && ((flags & AspectValue) != 0))\n        {\n          crop_image->page.width=geometry.width;\n          crop_image->page.height=geometry.height;\n          crop_image->page.x-=geometry.x;\n          crop_image->page.y-=geometry.y;\n        }\n      return(crop_image);\n    }\n  if ((image->columns > geometry.width) || (image->rows > geometry.height))\n    {\n      RectangleInfo\n        page;\n\n      size_t\n        height,\n        width;\n\n      ssize_t\n        x,\n        y;\n\n      /*\n        Crop into tiles of fixed size WxH.\n      */\n      page=image->page;\n      if (page.width == 0)\n        page.width=image->columns;\n      if (page.height == 0)\n        page.height=image->rows;\n      width=geometry.width;\n      if (width == 0)\n        width=page.width;\n      height=geometry.height;\n      if (height == 0)\n        height=page.height;\n      next=NewImageList();\n      for (y=0; y < (ssize_t) page.height; y+=(ssize_t) height)\n      {\n        for (x=0; x < (ssize_t) page.width; x+=(ssize_t) width)\n        {\n          geometry.width=width;\n          geometry.height=height;\n          geometry.x=x;\n          geometry.y=y;\n          next=CropImage(image,&geometry,exception);\n          if (next == (Image *) NULL)\n            break;\n          AppendImageToList(&crop_image,next);\n        }\n        if (next == (Image *) NULL)\n          break;\n      }\n      return(crop_image);\n    }\n  return(CloneImage(image,0,0,MagickTrue,exception));\n}\n",
        "output": "0",
        "index": 74019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2DecoderImpl::GetHelper(\n    GLenum pname, GLint* params, GLsizei* num_written) {\n  DCHECK(num_written);\n  switch (pname) {\n    case GL_IMPLEMENTATION_COLOR_READ_FORMAT:\n    case GL_IMPLEMENTATION_COLOR_READ_TYPE:\n      *num_written = 1;\n      {\n        Framebuffer* framebuffer = GetBoundReadFramebuffer();\n        if (framebuffer &&\n            framebuffer->IsPossiblyComplete(feature_info_.get()) !=\n            GL_FRAMEBUFFER_COMPLETE) {\n          LOCAL_SET_GL_ERROR(\n              GL_INVALID_OPERATION, \"glGetIntegerv\", \"incomplete framebuffer\");\n          if (params) {\n            *params = 0;\n          }\n          return true;\n        }\n      }\n      if (params) {\n        if (feature_info_->gl_version_info().is_es) {\n          api()->glGetIntegervFn(pname, params);\n        } else {\n          if (pname == GL_IMPLEMENTATION_COLOR_READ_FORMAT) {\n            *params = GLES2Util::GetGLReadPixelsImplementationFormat(\n                GetBoundReadFramebufferInternalFormat(),\n                GetBoundReadFramebufferTextureType(),\n                feature_info_->feature_flags().ext_read_format_bgra);\n          } else {\n            *params = GLES2Util::GetGLReadPixelsImplementationType(\n                GetBoundReadFramebufferInternalFormat(),\n                GetBoundReadFramebufferTextureType());\n          }\n        }\n        if (*params == GL_HALF_FLOAT && feature_info_->IsWebGL1OrES2Context()) {\n          *params = GL_HALF_FLOAT_OES;\n        }\n        if (*params == GL_SRGB_ALPHA_EXT) {\n          *params = GL_RGBA;\n        }\n        if (*params == GL_SRGB_EXT) {\n          *params = GL_RGB;\n        }\n      }\n      return true;\n    default:\n      break;\n  }\n\n  if (!gl_version_info().is_es) {\n    switch (pname) {\n      case GL_MAX_FRAGMENT_UNIFORM_VECTORS:\n        *num_written = 1;\n        if (params) {\n          *params = group_->max_fragment_uniform_vectors();\n        }\n        return true;\n      case GL_MAX_VARYING_VECTORS:\n        *num_written = 1;\n        if (params) {\n          *params = group_->max_varying_vectors();\n        }\n        return true;\n      case GL_MAX_VERTEX_UNIFORM_VECTORS:\n        *num_written = 1;\n        if (params) {\n          *params = group_->max_vertex_uniform_vectors();\n        }\n        return true;\n      }\n  }\n  if (feature_info_->IsWebGL2OrES3Context()) {\n    switch (pname) {\n      case GL_MAX_VARYING_COMPONENTS: {\n        if (gl_version_info().is_es) {\n          *num_written = 1;\n          break;\n        }\n\n        GLint max_varying_vectors = 0;\n        api()->glGetIntegervFn(GL_MAX_VARYING_VECTORS, &max_varying_vectors);\n        *num_written = 1;\n        if (params) {\n          *params = max_varying_vectors * 4;\n        }\n        return true;\n      }\n      case GL_READ_BUFFER:\n        *num_written = 1;\n        if (params) {\n          Framebuffer* framebuffer = GetBoundReadFramebuffer();\n          GLenum read_buffer;\n          if (framebuffer) {\n            read_buffer = framebuffer->read_buffer();\n          } else {\n            read_buffer = back_buffer_read_buffer_;\n          }\n          *params = static_cast<GLint>(read_buffer);\n        }\n        return true;\n      case GL_TRANSFORM_FEEDBACK_ACTIVE:\n        *num_written = 1;\n        if (params) {\n          *params =\n              static_cast<GLint>(state_.bound_transform_feedback->active());\n        }\n        return true;\n      case GL_TRANSFORM_FEEDBACK_PAUSED:\n        *num_written = 1;\n        if (params) {\n          *params =\n              static_cast<GLint>(state_.bound_transform_feedback->paused());\n        }\n        return true;\n      case GL_WINDOW_RECTANGLE_EXT:\n        *num_written = 4;\n        DCHECK(!params);\n        return true;\n    }\n  }\n  switch (pname) {\n    case GL_MAX_VIEWPORT_DIMS:\n      *num_written = 2;\n      if (offscreen_target_frame_buffer_.get()) {\n        if (params) {\n          params[0] = renderbuffer_manager()->max_renderbuffer_size();\n          params[1] = renderbuffer_manager()->max_renderbuffer_size();\n        }\n        return true;\n      }\n      break;\n    case GL_MAX_SAMPLES:\n      *num_written = 1;\n      if (params) {\n        params[0] = renderbuffer_manager()->max_samples();\n      }\n      return true;\n    case GL_MAX_RENDERBUFFER_SIZE:\n      *num_written = 1;\n      if (params) {\n        params[0] = renderbuffer_manager()->max_renderbuffer_size();\n      }\n      return true;\n    case GL_MAX_TEXTURE_SIZE:\n      *num_written = 1;\n      if (params) {\n        params[0] = texture_manager()->MaxSizeForTarget(GL_TEXTURE_2D);\n      }\n      return true;\n    case GL_MAX_CUBE_MAP_TEXTURE_SIZE:\n      *num_written = 1;\n      if (params) {\n        params[0] = texture_manager()->MaxSizeForTarget(GL_TEXTURE_CUBE_MAP);\n      }\n      return true;\n    case GL_MAX_COLOR_ATTACHMENTS_EXT:\n      *num_written = 1;\n      if (params) {\n        params[0] = group_->max_color_attachments();\n      }\n      return true;\n    case GL_MAX_DRAW_BUFFERS_ARB:\n      *num_written = 1;\n      if (params) {\n        params[0] = group_->max_draw_buffers();\n      }\n      return true;\n    case GL_ALPHA_BITS:\n      *num_written = 1;\n      if (params) {\n        GLint v = 0;\n        Framebuffer* framebuffer = GetBoundDrawFramebuffer();\n        if (framebuffer) {\n          if (framebuffer->HasAlphaMRT() &&\n              framebuffer->HasSameInternalFormatsMRT()) {\n            if (gl_version_info().is_desktop_core_profile) {\n              for (uint32_t i = 0; i < group_->max_draw_buffers(); i++) {\n                if (framebuffer->HasColorAttachment(i)) {\n                  api()->glGetFramebufferAttachmentParameterivEXTFn(\n                      GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i,\n                      GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, &v);\n                  break;\n                }\n              }\n            } else {\n              api()->glGetIntegervFn(GL_ALPHA_BITS, &v);\n            }\n          }\n        } else {\n          v = (ClientExposedBackBufferHasAlpha() ? 8 : 0);\n        }\n        params[0] = v;\n      }\n      return true;\n    case GL_DEPTH_BITS:\n      *num_written = 1;\n      if (params) {\n        GLint v = 0;\n        if (gl_version_info().is_desktop_core_profile) {\n          Framebuffer* framebuffer = GetBoundDrawFramebuffer();\n          if (framebuffer) {\n            if (framebuffer->HasDepthAttachment()) {\n              api()->glGetFramebufferAttachmentParameterivEXTFn(\n                  GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,\n                  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, &v);\n            }\n          } else {\n            v = (back_buffer_has_depth_ ? 24 : 0);\n          }\n        } else {\n          api()->glGetIntegervFn(GL_DEPTH_BITS, &v);\n        }\n        params[0] = BoundFramebufferHasDepthAttachment() ? v : 0;\n      }\n      return true;\n    case GL_RED_BITS:\n    case GL_GREEN_BITS:\n    case GL_BLUE_BITS:\n      *num_written = 1;\n      if (params) {\n        GLint v = 0;\n        if (gl_version_info().is_desktop_core_profile) {\n          Framebuffer* framebuffer = GetBoundDrawFramebuffer();\n          if (framebuffer) {\n            if (framebuffer->HasSameInternalFormatsMRT()) {\n              GLenum framebuffer_enum = 0;\n              switch (pname) {\n                case GL_RED_BITS:\n                  framebuffer_enum = GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE;\n                  break;\n                case GL_GREEN_BITS:\n                  framebuffer_enum = GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE;\n                  break;\n                case GL_BLUE_BITS:\n                  framebuffer_enum = GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE;\n                  break;\n              }\n              for (uint32_t i = 0; i < group_->max_draw_buffers(); i++) {\n                if (framebuffer->HasColorAttachment(i)) {\n                  api()->glGetFramebufferAttachmentParameterivEXTFn(\n                      GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i,\n                      framebuffer_enum, &v);\n                  break;\n                }\n              }\n            }\n          } else {\n            v = 8;\n          }\n        } else {\n          api()->glGetIntegervFn(pname, &v);\n        }\n        params[0] = v;\n      }\n      return true;\n    case GL_STENCIL_BITS:\n      *num_written = 1;\n      if (params) {\n        GLint v = 0;\n        if (gl_version_info().is_desktop_core_profile) {\n          Framebuffer* framebuffer = GetBoundDrawFramebuffer();\n          if (framebuffer) {\n            if (framebuffer->HasStencilAttachment()) {\n              api()->glGetFramebufferAttachmentParameterivEXTFn(\n                  GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT,\n                  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE, &v);\n            }\n          } else {\n            v = (back_buffer_has_stencil_ ? 8 : 0);\n          }\n        } else {\n          api()->glGetIntegervFn(GL_STENCIL_BITS, &v);\n        }\n        params[0] = BoundFramebufferHasStencilAttachment() ? v : 0;\n      }\n      return true;\n    case GL_COMPRESSED_TEXTURE_FORMATS:\n      *num_written = validators_->compressed_texture_format.GetValues().size();\n      if (params) {\n        for (GLint ii = 0; ii < *num_written; ++ii) {\n          params[ii] = validators_->compressed_texture_format.GetValues()[ii];\n        }\n      }\n      return true;\n    case GL_NUM_COMPRESSED_TEXTURE_FORMATS:\n      *num_written = 1;\n      if (params) {\n        *params = validators_->compressed_texture_format.GetValues().size();\n      }\n      return true;\n    case GL_NUM_SHADER_BINARY_FORMATS:\n      *num_written = 1;\n      if (params) {\n        *params = validators_->shader_binary_format.GetValues().size();\n      }\n      return true;\n    case GL_SHADER_BINARY_FORMATS:\n      *num_written = validators_->shader_binary_format.GetValues().size();\n      if (params) {\n        for (GLint ii = 0; ii <  *num_written; ++ii) {\n          params[ii] = validators_->shader_binary_format.GetValues()[ii];\n        }\n      }\n      return true;\n    case GL_SHADER_COMPILER:\n      *num_written = 1;\n      if (params) {\n        *params = GL_TRUE;\n      }\n      return true;\n    case GL_ARRAY_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_array_buffer.get());\n      }\n      return true;\n    case GL_ELEMENT_ARRAY_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(),\n            state_.vertex_attrib_manager->element_array_buffer());\n      }\n      return true;\n    case GL_COPY_READ_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_copy_read_buffer.get());\n      }\n      return true;\n    case GL_COPY_WRITE_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_copy_write_buffer.get());\n      }\n      return true;\n    case GL_PIXEL_PACK_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_pixel_pack_buffer.get());\n      }\n      return true;\n    case GL_PIXEL_UNPACK_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_pixel_unpack_buffer.get());\n      }\n      return true;\n    case GL_TRANSFORM_FEEDBACK_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_transform_feedback_buffer.get());\n      }\n      return true;\n    case GL_UNIFORM_BUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            buffer_manager(), state_.bound_uniform_buffer.get());\n      }\n      return true;\n    case GL_FRAMEBUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            framebuffer_manager(),\n            GetFramebufferInfoForTarget(GL_FRAMEBUFFER));\n      }\n      return true;\n    case GL_READ_FRAMEBUFFER_BINDING_EXT:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(\n            framebuffer_manager(),\n            GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT));\n      }\n      return true;\n    case GL_RENDERBUFFER_BINDING:\n      *num_written = 1;\n      if (params) {\n        Renderbuffer* renderbuffer =\n            GetRenderbufferInfoForTarget(GL_RENDERBUFFER);\n        if (renderbuffer) {\n          *params = renderbuffer->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_CURRENT_PROGRAM:\n      *num_written = 1;\n      if (params) {\n        *params = GetClientId(program_manager(), state_.current_program.get());\n      }\n      return true;\n    case GL_VERTEX_ARRAY_BINDING_OES:\n      *num_written = 1;\n      if (params) {\n        if (state_.vertex_attrib_manager.get() !=\n            state_.default_vertex_attrib_manager.get()) {\n          GLuint client_id = 0;\n          vertex_array_manager_->GetClientId(\n              state_.vertex_attrib_manager->service_id(), &client_id);\n          *params = client_id;\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_TEXTURE_BINDING_2D:\n      *num_written = 1;\n      if (params) {\n        TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n        if (unit.bound_texture_2d.get()) {\n          *params = unit.bound_texture_2d->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_TEXTURE_BINDING_CUBE_MAP:\n      *num_written = 1;\n      if (params) {\n        TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n        if (unit.bound_texture_cube_map.get()) {\n          *params = unit.bound_texture_cube_map->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_TEXTURE_BINDING_EXTERNAL_OES:\n      *num_written = 1;\n      if (params) {\n        TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n        if (unit.bound_texture_external_oes.get()) {\n          *params = unit.bound_texture_external_oes->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_TEXTURE_BINDING_RECTANGLE_ARB:\n      *num_written = 1;\n      if (params) {\n        TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n        if (unit.bound_texture_rectangle_arb.get()) {\n          *params = unit.bound_texture_rectangle_arb->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_BIND_GENERATES_RESOURCE_CHROMIUM:\n      *num_written = 1;\n      if (params) {\n        params[0] = group_->bind_generates_resource() ? 1 : 0;\n      }\n      return true;\n    case GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT:\n      *num_written = 1;\n      if (params) {\n        params[0] = group_->max_dual_source_draw_buffers();\n      }\n      return true;\n\n    case GL_MAJOR_VERSION:\n      *num_written = 1;\n      if (params) {\n        params[0] = 3;\n      }\n      return true;\n    case GL_MINOR_VERSION:\n      *num_written = 1;\n      if (params) {\n        params[0] = 0;\n      }\n      return true;\n\n    case GL_NUM_EXTENSIONS:\n      *num_written = 1;\n      if (params) {\n        params[0] = 0;\n      }\n      return true;\n    case GL_GPU_DISJOINT_EXT:\n      *num_written = 1;\n      if (params) {\n        params[0] = 0;\n      }\n      return true;\n    case GL_TIMESTAMP_EXT:\n      *num_written = 1;\n      if (params) {\n        params[0] = 0;\n      }\n      return true;\n    case GL_TEXTURE_BINDING_2D_ARRAY:\n      *num_written = 1;\n      if (params) {\n        TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n        if (unit.bound_texture_2d_array.get()) {\n          *params = unit.bound_texture_2d_array->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_TEXTURE_BINDING_3D:\n      *num_written = 1;\n      if (params) {\n        TextureUnit& unit = state_.texture_units[state_.active_texture_unit];\n        if (unit.bound_texture_3d.get()) {\n          *params = unit.bound_texture_3d->client_id();\n        } else {\n          *params = 0;\n        }\n      }\n      return true;\n    case GL_SAMPLER_BINDING:\n      *num_written = 1;\n      if (params) {\n        DCHECK_LT(state_.active_texture_unit, state_.sampler_units.size());\n        Sampler* sampler =\n            state_.sampler_units[state_.active_texture_unit].get();\n        *params = sampler ? sampler->client_id() : 0;\n      }\n      return true;\n    case GL_TRANSFORM_FEEDBACK_BINDING:\n      *num_written = 1;\n      if (params) {\n        *params = state_.bound_transform_feedback->client_id();\n      }\n      return true;\n    case GL_NUM_PROGRAM_BINARY_FORMATS:\n      *num_written = 1;\n      if (params) {\n        *params = 0;\n      }\n      return true;\n    case GL_PROGRAM_BINARY_FORMATS:\n      *num_written = 0;\n      return true;\n    default:\n      if (pname >= GL_DRAW_BUFFER0_ARB && pname <= GL_DRAW_BUFFER15_ARB) {\n        *num_written = 1;\n        if (params) {\n          if (pname < GL_DRAW_BUFFER0_ARB + group_->max_draw_buffers()) {\n            Framebuffer* framebuffer =\n                GetFramebufferInfoForTarget(GL_FRAMEBUFFER);\n            if (framebuffer) {\n              *params = framebuffer->GetDrawBuffer(pname);\n            } else {  // backbuffer\n              if (pname == GL_DRAW_BUFFER0_ARB)\n                *params = back_buffer_draw_buffer_;\n              else\n                *params = GL_NONE;\n            }\n          } else {\n            *params = GL_NONE;\n          }\n        }\n        return true;\n      }\n\n      *num_written = util_.GLGetNumValuesReturned(pname);\n      if (*num_written)\n        break;\n\n      return false;\n  }\n\n  if (params) {\n    DCHECK(*num_written);\n    pname = AdjustGetPname(pname);\n    api()->glGetIntegervFn(pname, params);\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 158704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CHANNELINDEX CSoundFile::CheckNNA(CHANNELINDEX nChn, uint32 instr, int note, bool forceCut)\n{\n\tCHANNELINDEX nnaChn = CHANNELINDEX_INVALID;\n\tModChannel &srcChn = m_PlayState.Chn[nChn];\n\tconst ModInstrument *pIns = nullptr;\n\tif(!ModCommand::IsNote(static_cast<ModCommand::NOTE>(note)))\n\t{\n\t\treturn nnaChn;\n\t}\n\tif((!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_MT2)) || !m_nInstruments || forceCut) && !srcChn.HasMIDIOutput())\n\t{\n\t\tif(!srcChn.nLength || srcChn.dwFlags[CHN_MUTE] || !(srcChn.rightVol | srcChn.leftVol))\n\t\t{\n\t\t\treturn CHANNELINDEX_INVALID;\n\t\t}\n\n\t\tnnaChn = GetNNAChannel(nChn);\n\t\tif(!nnaChn) return CHANNELINDEX_INVALID;\n\t\tModChannel &chn = m_PlayState.Chn[nnaChn];\n\t\tchn = srcChn;\n\t\tchn.dwFlags.reset(CHN_VIBRATO | CHN_TREMOLO | CHN_MUTE | CHN_PORTAMENTO);\n\t\tchn.nPanbrelloOffset = 0;\n\t\tchn.nMasterChn = nChn + 1;\n\t\tchn.nCommand = CMD_NONE;\n\t\tchn.rowCommand.Clear();\n\t\tchn.nFadeOutVol = 0;\n\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\tsrcChn.nLength = 0;\n\t\tsrcChn.position.Set(0);\n\t\tsrcChn.nROfs = srcChn.nLOfs = 0;\n\t\tsrcChn.rightVol = srcChn.leftVol = 0;\n\t\treturn nnaChn;\n\t}\n\tif(instr > GetNumInstruments()) instr = 0;\n\tconst ModSample *pSample = srcChn.pModSample;\n\tpIns = instr > 0 ? Instruments[instr] : srcChn.pModInstrument;\n\tif(pIns != nullptr)\n\t{\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tnote = pIns->NoteMap[note - NOTE_MIN];\n\t\tif ((n) && (n < MAX_SAMPLES))\n\t\t{\n\t\t\tpSample = &Samples[n];\n\t\t} else if(m_playBehaviour[kITEmptyNoteMapSlot] && !pIns->HasValidMIDIChannel())\n\t\t{\n\t\t\treturn CHANNELINDEX_INVALID;\n\t\t}\n\t}\n\tif (srcChn.dwFlags[CHN_MUTE])\n\t\treturn CHANNELINDEX_INVALID;\n\n\tfor(CHANNELINDEX i = nChn; i < MAX_CHANNELS; i++)\n\tif(i >= m_nChannels || i == nChn)\n\t{\n\t\tModChannel &chn = m_PlayState.Chn[i];\n\t\tbool applyDNAtoPlug = false;\n\t\tif((chn.nMasterChn == nChn + 1 || i == nChn) && chn.pModInstrument != nullptr)\n\t\t{\n\t\t\tbool bOk = false;\n\t\t\tswitch(chn.pModInstrument->nDCT)\n\t\t\t{\n\t\t\tcase DCT_NOTE:\n\t\t\t\tif(note && chn.nNote == note && pIns == chn.pModInstrument) bOk = true;\n\t\t\t\tif(pIns && pIns->nMixPlug) applyDNAtoPlug = true;\n\t\t\t\tbreak;\n\t\t\tcase DCT_SAMPLE:\n\t\t\t\tif(pSample != nullptr && pSample == chn.pModSample) bOk = true;\n\t\t\t\tbreak;\n\t\t\tcase DCT_INSTRUMENT:\n\t\t\t\tif(pIns == chn.pModInstrument) bOk = true;\n\t\t\t\tif(pIns && pIns->nMixPlug) applyDNAtoPlug = true;\n\t\t\t\tbreak;\n\t\t\tcase DCT_PLUGIN:\n\t\t\t\tif(pIns && (pIns->nMixPlug) && (pIns->nMixPlug == chn.pModInstrument->nMixPlug))\n\t\t\t\t{\n\t\t\t\t\tapplyDNAtoPlug = true;\n\t\t\t\t\tbOk = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tif (bOk)\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif (applyDNAtoPlug && chn.nNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tswitch(chn.pModInstrument->nDNA)\n\t\t\t\t\t{\n\t\t\t\t\tcase DNA_NOTECUT:\n\t\t\t\t\tcase DNA_NOTEOFF:\n\t\t\t\t\tcase DNA_NOTEFADE:\n\t\t\t\t\t\tSendMIDINote(i, chn.GetPluginNote(m_playBehaviour[kITRealNoteMapping]) + NOTE_MAX_SPECIAL, 0);\n\t\t\t\t\t\tchn.nArpeggioLastNote = NOTE_NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif // NO_PLUGINS\n\n\t\t\t\tswitch(chn.pModInstrument->nDNA)\n\t\t\t\t{\n\t\t\t\tcase DNA_NOTECUT:\n\t\t\t\t\tKeyOff(&chn);\n\t\t\t\t\tchn.nVolume = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DNA_NOTEOFF:\n\t\t\t\t\tKeyOff(&chn);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DNA_NOTEFADE:\n\t\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!chn.nVolume)\n\t\t\t\t{\n\t\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool applyNNAtoPlug = false;\n#ifndef NO_PLUGINS\n\tIMixPlugin *pPlugin = nullptr;\n\tif(srcChn.HasMIDIOutput() && ModCommand::IsNote(srcChn.nNote)) // instro sends to a midi chan\n\t{\n\t\tPLUGINDEX nPlugin = GetBestPlugin(nChn, PrioritiseInstrument, RespectMutes);\n\n\t\tif(nPlugin > 0 && nPlugin <= MAX_MIXPLUGINS)\n\t\t{\n\t\t\tpPlugin =  m_MixPlugins[nPlugin-1].pMixPlugin;\n\t\t\tif(pPlugin)\n\t\t\t{\n\t\t\t\tapplyNNAtoPlug = pPlugin->IsNotePlaying(srcChn.GetPluginNote(m_playBehaviour[kITRealNoteMapping]), GetBestMidiChannel(nChn), nChn);\n\t\t\t}\n\t\t}\n\t}\n#endif // NO_PLUGINS\n\n\tif((srcChn.nRealVolume > 0 && srcChn.nLength > 0) || applyNNAtoPlug)\n\t{\n\t\tnnaChn = GetNNAChannel(nChn);\n\t\tif(nnaChn != 0)\n\t\t{\n\t\t\tModChannel &chn = m_PlayState.Chn[nnaChn];\n\t\t\tchn = srcChn;\n\t\t\tchn.dwFlags.reset(CHN_VIBRATO | CHN_TREMOLO | CHN_PORTAMENTO);\n\t\t\tchn.nPanbrelloOffset = 0;\n\n\t\t\tchn.nMasterChn = nChn < GetNumChannels() ? nChn + 1 : 0;\n\t\t\tchn.nCommand = CMD_NONE;\n#ifndef NO_PLUGINS\n\t\t\tif(applyNNAtoPlug && pPlugin)\n\t\t\t{\n\t\t\t\tswitch(srcChn.nNNA)\n\t\t\t\t{\n\t\t\t\tcase NNA_NOTEOFF:\n\t\t\t\tcase NNA_NOTECUT:\n\t\t\t\tcase NNA_NOTEFADE:\n\t\t\t\t\tSendMIDINote(nChn, NOTE_KEYOFF, 0);\n\t\t\t\t\tsrcChn.nArpeggioLastNote = NOTE_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\n\t\t\tswitch(srcChn.nNNA)\n\t\t\t{\n\t\t\tcase NNA_NOTEOFF:\n\t\t\t\tKeyOff(&chn);\n\t\t\t\tbreak;\n\t\t\tcase NNA_NOTECUT:\n\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\tbreak;\n\t\t\tcase NNA_NOTEFADE:\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!chn.nVolume)\n\t\t\t{\n\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\tsrcChn.nLength = 0;\n\t\t\tsrcChn.position.Set(0);\n\t\t\tsrcChn.nROfs = srcChn.nLOfs = 0;\n\t\t}\n\t}\n\treturn nnaChn;\n}\n",
        "output": "0",
        "index": 83285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg)\n{\n\tstruct sock *sk;\n\tstruct sockaddr_vm dst;\n\tstruct sockaddr_vm src;\n\tstruct vmci_transport_packet *pkt;\n\tstruct vsock_sock *vsk;\n\tbool bh_process_pkt;\n\tint err;\n\n\tsk = NULL;\n\terr = VMCI_SUCCESS;\n\tbh_process_pkt = false;\n\n\t/* Ignore incoming packets from contexts without sockets, or resources\n\t * that aren't vsock implementations.\n\t */\n\n\tif (!vmci_transport_stream_allow(dg->src.context, -1)\n\t    || VMCI_TRANSPORT_PACKET_RID != dg->src.resource)\n\t\treturn VMCI_ERROR_NO_ACCESS;\n\n\tif (VMCI_DG_SIZE(dg) < sizeof(*pkt))\n\t\t/* Drop datagrams that do not contain full VSock packets. */\n\t\treturn VMCI_ERROR_INVALID_ARGS;\n\n\tpkt = (struct vmci_transport_packet *)dg;\n\n\t/* Find the socket that should handle this packet.  First we look for a\n\t * connected socket and if there is none we look for a socket bound to\n\t * the destintation address.\n\t */\n\tvsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);\n\tvsock_addr_init(&dst, pkt->dg.dst.context, pkt->dst_port);\n\n\tsk = vsock_find_connected_socket(&src, &dst);\n\tif (!sk) {\n\t\tsk = vsock_find_bound_socket(&dst);\n\t\tif (!sk) {\n\t\t\t/* We could not find a socket for this specified\n\t\t\t * address.  If this packet is a RST, we just drop it.\n\t\t\t * If it is another packet, we send a RST.  Note that\n\t\t\t * we do not send a RST reply to RSTs so that we do not\n\t\t\t * continually send RSTs between two endpoints.\n\t\t\t *\n\t\t\t * Note that since this is a reply, dst is src and src\n\t\t\t * is dst.\n\t\t\t */\n\t\t\tif (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)\n\t\t\t\tpr_err(\"unable to send reset\\n\");\n\n\t\t\terr = VMCI_ERROR_NOT_FOUND;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* If the received packet type is beyond all types known to this\n\t * implementation, reply with an invalid message.  Hopefully this will\n\t * help when implementing backwards compatibility in the future.\n\t */\n\tif (pkt->type >= VMCI_TRANSPORT_PACKET_TYPE_MAX) {\n\t\tvmci_transport_send_invalid_bh(&dst, &src);\n\t\terr = VMCI_ERROR_INVALID_ARGS;\n\t\tgoto out;\n\t}\n\n\t/* This handler is privileged when this module is running on the host.\n\t * We will get datagram connect requests from all endpoints (even VMs\n\t * that are in a restricted context). If we get one from a restricted\n\t * context then the destination socket must be trusted.\n\t *\n\t * NOTE: We access the socket struct without holding the lock here.\n\t * This is ok because the field we are interested is never modified\n\t * outside of the create and destruct socket functions.\n\t */\n\tvsk = vsock_sk(sk);\n\tif (!vmci_transport_allow_dgram(vsk, pkt->dg.src.context)) {\n\t\terr = VMCI_ERROR_NO_ACCESS;\n\t\tgoto out;\n\t}\n\n\t/* We do most everything in a work queue, but let's fast path the\n\t * notification of reads and writes to help data transfer performance.\n\t * We can only do this if there is no process context code executing\n\t * for this socket since that may change the state.\n\t */\n\tbh_lock_sock(sk);\n\n\tif (!sock_owned_by_user(sk)) {\n\t\t/* The local context ID may be out of date, update it. */\n\t\tvsk->local_addr.svm_cid = dst.svm_cid;\n\n\t\tif (sk->sk_state == SS_CONNECTED)\n\t\t\tvmci_trans(vsk)->notify_ops->handle_notify_pkt(\n\t\t\t\t\tsk, pkt, true, &dst, &src,\n\t\t\t\t\t&bh_process_pkt);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\tif (!bh_process_pkt) {\n\t\tstruct vmci_transport_recv_pkt_info *recv_pkt_info;\n\n\t\trecv_pkt_info = kmalloc(sizeof(*recv_pkt_info), GFP_ATOMIC);\n\t\tif (!recv_pkt_info) {\n\t\t\tif (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)\n\t\t\t\tpr_err(\"unable to send reset\\n\");\n\n\t\t\terr = VMCI_ERROR_NO_MEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trecv_pkt_info->sk = sk;\n\t\tmemcpy(&recv_pkt_info->pkt, pkt, sizeof(recv_pkt_info->pkt));\n\t\tINIT_WORK(&recv_pkt_info->work, vmci_transport_recv_pkt_work);\n\n\t\tschedule_work(&recv_pkt_info->work);\n\t\t/* Clear sk so that the reference count incremented by one of\n\t\t * the Find functions above is not decremented below.  We need\n\t\t * that reference count for the packet handler we've scheduled\n\t\t * to run.\n\t\t */\n\t\tsk = NULL;\n\t}\n\nout:\n\tif (sk)\n\t\tsock_put(sk);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 30411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::InitializeNewContext() {\n  DCHECK(!isContextLost());\n  DCHECK(GetDrawingBuffer());\n\n\n  marked_canvas_dirty_ = false;\n  must_paint_to_canvas_ = false;\n  active_texture_unit_ = 0;\n  pack_alignment_ = 4;\n  unpack_alignment_ = 4;\n  unpack_flip_y_ = false;\n  unpack_premultiply_alpha_ = false;\n  unpack_colorspace_conversion_ = GC3D_BROWSER_DEFAULT_WEBGL;\n  bound_array_buffer_ = nullptr;\n  current_program_ = nullptr;\n  framebuffer_binding_ = nullptr;\n  renderbuffer_binding_ = nullptr;\n  depth_mask_ = true;\n  stencil_enabled_ = false;\n  stencil_mask_ = 0xFFFFFFFF;\n  stencil_mask_back_ = 0xFFFFFFFF;\n  stencil_func_ref_ = 0;\n  stencil_func_ref_back_ = 0;\n  stencil_func_mask_ = 0xFFFFFFFF;\n  stencil_func_mask_back_ = 0xFFFFFFFF;\n  num_gl_errors_to_console_allowed_ = kMaxGLErrorsAllowedToConsole;\n\n  clear_color_[0] = clear_color_[1] = clear_color_[2] = clear_color_[3] = 0;\n  scissor_enabled_ = false;\n  clear_depth_ = 1;\n  clear_stencil_ = 0;\n  color_mask_[0] = color_mask_[1] = color_mask_[2] = color_mask_[3] = true;\n\n  GLint num_combined_texture_image_units = 0;\n  ContextGL()->GetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS,\n                           &num_combined_texture_image_units);\n  texture_units_.clear();\n  texture_units_.resize(num_combined_texture_image_units);\n\n  GLint num_vertex_attribs = 0;\n  ContextGL()->GetIntegerv(GL_MAX_VERTEX_ATTRIBS, &num_vertex_attribs);\n  max_vertex_attribs_ = num_vertex_attribs;\n\n  max_texture_size_ = 0;\n  ContextGL()->GetIntegerv(GL_MAX_TEXTURE_SIZE, &max_texture_size_);\n  max_texture_level_ =\n      WebGLTexture::ComputeLevelCount(max_texture_size_, max_texture_size_, 1);\n  max_cube_map_texture_size_ = 0;\n  ContextGL()->GetIntegerv(GL_MAX_CUBE_MAP_TEXTURE_SIZE,\n                           &max_cube_map_texture_size_);\n  max3d_texture_size_ = 0;\n  max3d_texture_level_ = 0;\n  max_array_texture_layers_ = 0;\n  if (IsWebGL2OrHigher()) {\n    ContextGL()->GetIntegerv(GL_MAX_3D_TEXTURE_SIZE, &max3d_texture_size_);\n    max3d_texture_level_ = WebGLTexture::ComputeLevelCount(\n        max3d_texture_size_, max3d_texture_size_, max3d_texture_size_);\n    ContextGL()->GetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS,\n                             &max_array_texture_layers_);\n  }\n  max_cube_map_texture_level_ = WebGLTexture::ComputeLevelCount(\n      max_cube_map_texture_size_, max_cube_map_texture_size_, 1);\n  max_renderbuffer_size_ = 0;\n  ContextGL()->GetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &max_renderbuffer_size_);\n\n  max_draw_buffers_ = 0;\n  max_color_attachments_ = 0;\n\n  back_draw_buffer_ = GL_BACK;\n\n  read_buffer_of_default_framebuffer_ = GL_BACK;\n\n  default_vertex_array_object_ = WebGLVertexArrayObject::Create(\n      this, WebGLVertexArrayObjectBase::kVaoTypeDefault);\n\n  bound_vertex_array_object_ = default_vertex_array_object_;\n\n  vertex_attrib_type_.resize(max_vertex_attribs_);\n\n  ContextGL()->Viewport(0, 0, drawingBufferWidth(), drawingBufferHeight());\n  scissor_box_[0] = scissor_box_[1] = 0;\n  scissor_box_[2] = drawingBufferWidth();\n  scissor_box_[3] = drawingBufferHeight();\n  ContextGL()->Scissor(scissor_box_[0], scissor_box_[1], scissor_box_[2],\n                       scissor_box_[3]);\n\n  GetDrawingBuffer()->ContextProvider()->SetLostContextCallback(\n      WTF::BindRepeating(&WebGLRenderingContextBase::ForceLostContext,\n                         WrapWeakPersistent(this),\n                         WebGLRenderingContextBase::kRealLostContext,\n                         WebGLRenderingContextBase::kAuto));\n  GetDrawingBuffer()->ContextProvider()->SetErrorMessageCallback(\n      WTF::BindRepeating(&WebGLRenderingContextBase::OnErrorMessage,\n                         WrapWeakPersistent(this)));\n\n  is_origin_top_left_ = GetDrawingBuffer()\n                            ->ContextProvider()\n                            ->GetCapabilities()\n                            .mesa_framebuffer_flip_y;\n\n  if (IsWebGL2OrHigher())\n    ContextGL()->Enable(GL_PRIMITIVE_RESTART_FIXED_INDEX);\n\n  ContextGL()->Flush();\n\n  for (int i = 0; i < kWebGLExtensionNameCount; ++i)\n    extension_enabled_[i] = false;\n\n  if (String(ContextGL()->GetString(GL_EXTENSIONS))\n          .Contains(\"GL_KHR_parallel_shader_compile\")) {\n    ContextGL()->MaxShaderCompilerThreadsKHR(2);\n  }\n  is_web_gl2_formats_types_added_ = false;\n  is_web_gl2_tex_image_source_formats_types_added_ = false;\n  is_web_gl2_internal_formats_copy_tex_image_added_ = false;\n  is_oes_texture_float_formats_types_added_ = false;\n  is_oes_texture_half_float_formats_types_added_ = false;\n  is_web_gl_depth_texture_formats_types_added_ = false;\n  is_ext_srgb_formats_types_added_ = false;\n  is_ext_color_buffer_float_formats_added_ = false;\n\n  supported_internal_formats_.clear();\n  ADD_VALUES_TO_SET(supported_internal_formats_, kSupportedFormatsES2);\n  supported_tex_image_source_internal_formats_.clear();\n  ADD_VALUES_TO_SET(supported_tex_image_source_internal_formats_,\n                    kSupportedFormatsES2);\n  supported_internal_formats_copy_tex_image_.clear();\n  ADD_VALUES_TO_SET(supported_internal_formats_copy_tex_image_,\n                    kSupportedFormatsES2);\n  supported_formats_.clear();\n  ADD_VALUES_TO_SET(supported_formats_, kSupportedFormatsES2);\n  supported_tex_image_source_formats_.clear();\n  ADD_VALUES_TO_SET(supported_tex_image_source_formats_, kSupportedFormatsES2);\n  supported_types_.clear();\n  ADD_VALUES_TO_SET(supported_types_, kSupportedTypesES2);\n  supported_tex_image_source_types_.clear();\n  ADD_VALUES_TO_SET(supported_tex_image_source_types_, kSupportedTypesES2);\n\n  GetDrawingBuffer()->RestoreAllState();\n  ActivateContext(this);\n}\n",
        "output": "0",
        "index": 154959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_get_client_hello(SSL *s)\n{\n    int i, j, ok, al = SSL_AD_INTERNAL_ERROR, ret = -1;\n    unsigned int cookie_len;\n    long n;\n    unsigned long id;\n    unsigned char *p, *d;\n    SSL_CIPHER *c;\n#ifndef OPENSSL_NO_COMP\n    unsigned char *q;\n    SSL_COMP *comp = NULL;\n#endif\n    STACK_OF(SSL_CIPHER) *ciphers = NULL;\n\n    if (s->state == SSL3_ST_SR_CLNT_HELLO_C && !s->first_packet)\n        goto retry_cert;\n\n    /*\n     * We do this so that we will respond with our native type. If we are\n     * TLSv1 and we get SSLv3, we will respond with TLSv1, This down\n     * switching should be handled by a different method. If we are SSLv3, we\n     * will respond with SSLv3, even if prompted with TLSv1.\n     */\n    if (s->state == SSL3_ST_SR_CLNT_HELLO_A) {\n        s->state = SSL3_ST_SR_CLNT_HELLO_B;\n    }\n    s->first_packet = 1;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_SR_CLNT_HELLO_B,\n                                   SSL3_ST_SR_CLNT_HELLO_C,\n                                   SSL3_MT_CLIENT_HELLO,\n                                   SSL3_RT_MAX_PLAIN_LENGTH, &ok);\n\n    if (!ok)\n        return ((int)n);\n    s->first_packet = 0;\n    d = p = (unsigned char *)s->init_msg;\n\n    /*\n     * use version from inside client hello, not from record header (may\n     * differ: see RFC 2246, Appendix E, second paragraph)\n     */\n    s->client_version = (((int)p[0]) << 8) | (int)p[1];\n    p += 2;\n\n    if (SSL_IS_DTLS(s) ? (s->client_version > s->version &&\n                          s->method->version != DTLS_ANY_VERSION)\n        : (s->client_version < s->version)) {\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_WRONG_VERSION_NUMBER);\n        if ((s->client_version >> 8) == SSL3_VERSION_MAJOR &&\n            !s->enc_write_ctx && !s->write_hash) {\n            /*\n             * similar to ssl3_get_record, send alert using remote version\n             * number\n             */\n            s->version = s->client_version;\n        }\n        al = SSL_AD_PROTOCOL_VERSION;\n        goto f_err;\n    }\n\n    /*\n     * If we require cookies and this ClientHello doesn't contain one, just\n     * return since we do not want to allocate any memory yet. So check\n     * cookie length...\n     */\n    if (SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) {\n        unsigned int session_length, cookie_length;\n\n        session_length = *(p + SSL3_RANDOM_SIZE);\n        cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);\n\n        if (cookie_length == 0)\n            return 1;\n    }\n\n    /* load the client random */\n    memcpy(s->s3->client_random, p, SSL3_RANDOM_SIZE);\n    p += SSL3_RANDOM_SIZE;\n\n    /* get the session-id */\n    j = *(p++);\n\n    s->hit = 0;\n    /*\n     * Versions before 0.9.7 always allow clients to resume sessions in\n     * renegotiation. 0.9.7 and later allow this by default, but optionally\n     * ignore resumption requests with flag\n     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION (it's a new flag rather\n     * than a change to default behavior so that applications relying on this\n     * for security won't even compile against older library versions).\n     * 1.0.1 and later also have a function SSL_renegotiate_abbreviated() to\n     * request renegotiation but not a new session (s->new_session remains\n     * unset): for servers, this essentially just means that the\n     * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION setting will be ignored.\n     */\n    if ((s->new_session\n         && (s->options & SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION))) {\n        if (!ssl_get_new_session(s, 1))\n            goto err;\n    } else {\n        i = ssl_get_prev_session(s, p, j, d + n);\n        /*\n         * Only resume if the session's version matches the negotiated\n         * version.\n         * RFC 5246 does not provide much useful advice on resumption\n         * with a different protocol version. It doesn't forbid it but\n         * the sanity of such behaviour would be questionable.\n         * In practice, clients do not accept a version mismatch and\n         * will abort the handshake with an error.\n         */\n        if (i == 1 && s->version == s->session->ssl_version) { /* previous\n                                                                * session */\n            s->hit = 1;\n        } else if (i == -1)\n            goto err;\n        else {                  /* i == 0 */\n\n            if (!ssl_get_new_session(s, 1))\n                goto err;\n        }\n    }\n\n    p += j;\n\n    if (SSL_IS_DTLS(s)) {\n        /* cookie stuff */\n        cookie_len = *(p++);\n\n        /*\n         * The ClientHello may contain a cookie even if the\n         * HelloVerify message has not been sent--make sure that it\n         * does not cause an overflow.\n         */\n        if (cookie_len > sizeof(s->d1->rcvd_cookie)) {\n            /* too much data */\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\n            goto f_err;\n        }\n\n        /* verify the cookie if appropriate option is set. */\n        if ((SSL_get_options(s) & SSL_OP_COOKIE_EXCHANGE) && cookie_len > 0) {\n            memcpy(s->d1->rcvd_cookie, p, cookie_len);\n\n            if (s->ctx->app_verify_cookie_cb != NULL) {\n                if (s->ctx->app_verify_cookie_cb(s, s->d1->rcvd_cookie,\n                                                 cookie_len) == 0) {\n                    al = SSL_AD_HANDSHAKE_FAILURE;\n                    SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                           SSL_R_COOKIE_MISMATCH);\n                    goto f_err;\n                }\n                /* else cookie verification succeeded */\n            }\n            /* default verification */\n            else if (memcmp(s->d1->rcvd_cookie, s->d1->cookie,\n                            s->d1->cookie_len) != 0) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_COOKIE_MISMATCH);\n                goto f_err;\n            }\n            /* Set to -2 so if successful we return 2 */\n            ret = -2;\n        }\n\n        p += cookie_len;\n        if (s->method->version == DTLS_ANY_VERSION) {\n            /* Select version to use */\n            if (s->client_version <= DTLS1_2_VERSION &&\n                !(s->options & SSL_OP_NO_DTLSv1_2)) {\n                s->version = DTLS1_2_VERSION;\n                s->method = DTLSv1_2_server_method();\n            } else if (tls1_suiteb(s)) {\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                       SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n                s->version = s->client_version;\n                al = SSL_AD_PROTOCOL_VERSION;\n                goto f_err;\n            } else if (s->client_version <= DTLS1_VERSION &&\n                       !(s->options & SSL_OP_NO_DTLSv1)) {\n                s->version = DTLS1_VERSION;\n                s->method = DTLSv1_server_method();\n            } else {\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                       SSL_R_WRONG_VERSION_NUMBER);\n                s->version = s->client_version;\n                al = SSL_AD_PROTOCOL_VERSION;\n                goto f_err;\n            }\n            s->session->ssl_version = s->version;\n        }\n    }\n\n    n2s(p, i);\n    if ((i == 0) && (j != 0)) {\n        /* we need a cipher if we are not resuming a session */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_SPECIFIED);\n        goto f_err;\n    }\n    if ((p + i) >= (d + n)) {\n        /* not enough data */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if ((i > 0) && (ssl_bytes_to_cipher_list(s, p, i, &(ciphers))\n                    == NULL)) {\n        goto err;\n    }\n    p += i;\n\n    /* If it is a hit, check that the cipher is in the list */\n    if ((s->hit) && (i > 0)) {\n        j = 0;\n        id = s->session->cipher->id;\n\n#ifdef CIPHER_DEBUG\n        fprintf(stderr, \"client sent %d ciphers\\n\",\n                sk_SSL_CIPHER_num(ciphers));\n#endif\n        for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {\n            c = sk_SSL_CIPHER_value(ciphers, i);\n#ifdef CIPHER_DEBUG\n            fprintf(stderr, \"client [%2d of %2d]:%s\\n\",\n                    i, sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));\n#endif\n            if (c->id == id) {\n                j = 1;\n                break;\n            }\n        }\n        /*\n         * Disabled because it can be used in a ciphersuite downgrade attack:\n         * CVE-2010-4180.\n         */\n#if 0\n        if (j == 0 && (s->options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG)\n            && (sk_SSL_CIPHER_num(ciphers) == 1)) {\n            /*\n             * Special case as client bug workaround: the previously used\n             * cipher may not be in the current list, the client instead\n             * might be trying to continue using a cipher that before wasn't\n             * chosen due to server preferences.  We'll have to reject the\n             * connection if the cipher is not enabled, though.\n             */\n            c = sk_SSL_CIPHER_value(ciphers, 0);\n            if (sk_SSL_CIPHER_find(SSL_get_ciphers(s), c) >= 0) {\n                s->session->cipher = c;\n                j = 1;\n            }\n        }\n#endif\n        if (j == 0) {\n            /*\n             * we need to have the cipher in the cipher list if we are asked\n             * to reuse it\n             */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_REQUIRED_CIPHER_MISSING);\n            goto f_err;\n        }\n    }\n\n    /* compression */\n    i = *(p++);\n    if ((p + i) > (d + n)) {\n        /* not enough data */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_COMP\n    q = p;\n#endif\n    for (j = 0; j < i; j++) {\n        if (p[j] == 0)\n            break;\n    }\n\n    p += i;\n    if (j >= i) {\n        /* no compress */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_COMPRESSION_SPECIFIED);\n        goto f_err;\n    }\n#ifndef OPENSSL_NO_TLSEXT\n    /* TLS extensions */\n    if (s->version >= SSL3_VERSION) {\n        if (!ssl_parse_clienthello_tlsext(s, &p, d, n)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_PARSE_TLSEXT);\n            goto err;\n        }\n    }\n\n    /*\n     * Check if we want to use external pre-shared secret for this handshake\n     * for not reused session only. We need to generate server_random before\n     * calling tls_session_secret_cb in order to allow SessionTicket\n     * processing to use it in key derivation.\n     */\n    {\n        unsigned char *pos;\n        pos = s->s3->server_random;\n        if (ssl_fill_hello_random(s, 1, pos, SSL3_RANDOM_SIZE) <= 0) {\n            goto f_err;\n        }\n    }\n\n    if (!s->hit && s->version >= TLS1_VERSION && s->tls_session_secret_cb) {\n        SSL_CIPHER *pref_cipher = NULL;\n\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length, ciphers,\n                                     &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->hit = 1;\n            s->session->ciphers = ciphers;\n            s->session->verify_result = X509_V_OK;\n\n            ciphers = NULL;\n\n            /* check if some cipher was preferred by call back */\n            pref_cipher =\n                pref_cipher ? pref_cipher : ssl3_choose_cipher(s,\n                                                               s->\n                                                               session->ciphers,\n                                                               SSL_get_ciphers\n                                                               (s));\n            if (pref_cipher == NULL) {\n                al = SSL_AD_HANDSHAKE_FAILURE;\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);\n                goto f_err;\n            }\n\n            s->session->cipher = pref_cipher;\n\n            if (s->cipher_list)\n                sk_SSL_CIPHER_free(s->cipher_list);\n\n            if (s->cipher_list_by_id)\n                sk_SSL_CIPHER_free(s->cipher_list_by_id);\n\n            s->cipher_list = sk_SSL_CIPHER_dup(s->session->ciphers);\n            s->cipher_list_by_id = sk_SSL_CIPHER_dup(s->session->ciphers);\n        }\n    }\n#endif\n\n    /*\n     * Worst case, we will use the NULL compression, but if we have other\n     * options, we will now look for them.  We have i-1 compression\n     * algorithms from the client, starting at q.\n     */\n    s->s3->tmp.new_compression = NULL;\n#ifndef OPENSSL_NO_COMP\n    /* This only happens if we have a cache hit */\n    if (s->session->compress_meth != 0) {\n        int m, comp_id = s->session->compress_meth;\n        /* Perform sanity checks on resumed compression algorithm */\n        /* Can't disable compression */\n        if (s->options & SSL_OP_NO_COMPRESSION) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_INCONSISTENT_COMPRESSION);\n            goto f_err;\n        }\n        /* Look for resumed compression method */\n        for (m = 0; m < sk_SSL_COMP_num(s->ctx->comp_methods); m++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);\n            if (comp_id == comp->id) {\n                s->s3->tmp.new_compression = comp;\n                break;\n            }\n        }\n        if (s->s3->tmp.new_compression == NULL) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_INVALID_COMPRESSION_ALGORITHM);\n            goto f_err;\n        }\n        /* Look for resumed method in compression list */\n        for (m = 0; m < i; m++) {\n            if (q[m] == comp_id)\n                break;\n        }\n        if (m >= i) {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,\n                   SSL_R_REQUIRED_COMPRESSSION_ALGORITHM_MISSING);\n            goto f_err;\n        }\n    } else if (s->hit)\n        comp = NULL;\n    else if (!(s->options & SSL_OP_NO_COMPRESSION) && s->ctx->comp_methods) {\n        /* See if we have a match */\n        int m, nn, o, v, done = 0;\n\n        nn = sk_SSL_COMP_num(s->ctx->comp_methods);\n        for (m = 0; m < nn; m++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, m);\n            v = comp->id;\n            for (o = 0; o < i; o++) {\n                if (v == q[o]) {\n                    done = 1;\n                    break;\n                }\n            }\n            if (done)\n                break;\n        }\n        if (done)\n            s->s3->tmp.new_compression = comp;\n        else\n            comp = NULL;\n    }\n#else\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#endif\n\n    /*\n     * Given s->session->ciphers and SSL_get_ciphers, we must pick a cipher\n     */\n\n    if (!s->hit) {\n#ifdef OPENSSL_NO_COMP\n        s->session->compress_meth = 0;\n#else\n        s->session->compress_meth = (comp == NULL) ? 0 : comp->id;\n#endif\n        if (s->session->ciphers != NULL)\n            sk_SSL_CIPHER_free(s->session->ciphers);\n        s->session->ciphers = ciphers;\n        if (ciphers == NULL) {\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_CIPHERS_PASSED);\n            goto f_err;\n        }\n        ciphers = NULL;\n        if (!tls1_set_server_sigalgs(s)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n        /* Let cert callback update server certificates if required */\n retry_cert:\n        if (s->cert->cert_cb) {\n            int rv = s->cert->cert_cb(s, s->cert->cert_cb_arg);\n            if (rv == 0) {\n                al = SSL_AD_INTERNAL_ERROR;\n                SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CERT_CB_ERROR);\n                goto f_err;\n            }\n            if (rv < 0) {\n                s->rwstate = SSL_X509_LOOKUP;\n                return -1;\n            }\n            s->rwstate = SSL_NOTHING;\n        }\n        c = ssl3_choose_cipher(s, s->session->ciphers, SSL_get_ciphers(s));\n\n        if (c == NULL) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_NO_SHARED_CIPHER);\n            goto f_err;\n        }\n        s->s3->tmp.new_cipher = c;\n    } else {\n        /* Session-id reuse */\n#ifdef REUSE_CIPHER_BUG\n        STACK_OF(SSL_CIPHER) *sk;\n        SSL_CIPHER *nc = NULL;\n        SSL_CIPHER *ec = NULL;\n\n        if (s->options & SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG) {\n            sk = s->session->ciphers;\n            for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\n                c = sk_SSL_CIPHER_value(sk, i);\n                if (c->algorithm_enc & SSL_eNULL)\n                    nc = c;\n                if (SSL_C_IS_EXPORT(c))\n                    ec = c;\n            }\n            if (nc != NULL)\n                s->s3->tmp.new_cipher = nc;\n            else if (ec != NULL)\n                s->s3->tmp.new_cipher = ec;\n            else\n                s->s3->tmp.new_cipher = s->session->cipher;\n        } else\n#endif\n            s->s3->tmp.new_cipher = s->session->cipher;\n    }\n\n    if (!SSL_USE_SIGALGS(s) || !(s->verify_mode & SSL_VERIFY_PEER)) {\n        if (!ssl3_digest_cached_records(s))\n            goto f_err;\n    }\n\n    /*-\n    * we now have the following setup.\n     * client_random\n     * cipher_list          - our prefered list of ciphers\n     * ciphers              - the clients prefered list of ciphers\n     * compression          - basically ignored right now\n     * ssl version is set   - sslv3\n     * s->session           - The ssl session has been setup.\n     * s->hit               - session reuse flag\n     * s->tmp.new_cipher    - the new cipher to use.\n     */\n\n    /* Handles TLS extensions that we couldn't check earlier */\n    if (s->version >= SSL3_VERSION) {\n        if (ssl_check_clienthello_tlsext_late(s) <= 0) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);\n            goto err;\n        }\n    }\n\n    if (ret < 0)\n        ret = -ret;\n    if (0) {\n f_err:\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    }\n err:\n    if (ciphers != NULL)\n        sk_SSL_CIPHER_free(ciphers);\n    return ret < 0 ? -1 : ret;\n}\n",
        "output": "0",
        "index": 5055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceDispatcherHostImpl::BeginRequest(\n    int request_id,\n    const ResourceHostMsg_Request& request_data,\n    IPC::Message* sync_result,  // only valid for sync\n    int route_id) {\n  ProcessType process_type = filter_->process_type();\n  int child_id = filter_->child_id();\n\n  char url_buf[128];\n  base::strlcpy(url_buf, request_data.url.spec().c_str(), arraysize(url_buf));\n  base::debug::Alias(url_buf);\n\n  net::URLRequest* deferred_request = NULL;\n\n  GlobalRequestID old_request_id(request_data.transferred_request_child_id,\n                                 request_data.transferred_request_request_id);\n  TransferredNavigations::iterator iter =\n      transferred_navigations_.find(old_request_id);\n  if (iter != transferred_navigations_.end()) {\n    deferred_request = iter->second;\n    pending_requests_.erase(old_request_id);\n    transferred_navigations_.erase(iter);\n  }\n\n  ResourceContext* resource_context = filter_->resource_context();\n  CHECK(ContainsKey(active_resource_contexts_, resource_context));\n\n  if (request_data.upload_data) {\n    GetBlobStorageControllerForResourceContext(resource_context)->\n        ResolveBlobReferencesInUploadData(request_data.upload_data.get());\n  }\n\n  if (is_shutdown_ ||\n      !ShouldServiceRequest(process_type, child_id, request_data)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, route_id, request_id);\n    return;\n  }\n\n  const Referrer referrer(MaybeStripReferrer(request_data.referrer),\n                          request_data.referrer_policy);\n\n  if (delegate_ && !delegate_->ShouldBeginRequest(child_id,\n                                                  route_id,\n                                                  request_data.method,\n                                                  request_data.url,\n                                                  request_data.resource_type,\n                                                  resource_context,\n                                                  referrer)) {\n    AbortRequestBeforeItStarts(filter_, sync_result, route_id, request_id);\n    return;\n  }\n\n  scoped_refptr<ResourceHandler> handler;\n  if (sync_result) {\n    handler = new SyncResourceHandler(\n        filter_, request_data.url, sync_result, this);\n  } else {\n    handler = new AsyncResourceHandler(\n        filter_, route_id, request_data.url, this);\n  }\n\n  if (request_data.download_to_file)\n    handler = new RedirectToFileResourceHandler(handler, child_id, this);\n\n  if (HandleExternalProtocol(\n      request_id, child_id, route_id, request_data.url,\n      request_data.resource_type,\n      *resource_context->GetRequestContext()->job_factory(), handler)) {\n    return;\n  }\n\n  net::URLRequest* request;\n  if (deferred_request) {\n    request = deferred_request;\n  } else {\n    request = new net::URLRequest(request_data.url, this);\n    request->set_method(request_data.method);\n    request->set_first_party_for_cookies(request_data.first_party_for_cookies);\n    request->set_referrer(referrer.url.spec());\n    webkit_glue::ConfigureURLRequestForReferrerPolicy(request, referrer.policy);\n    net::HttpRequestHeaders headers;\n    headers.AddHeadersFromString(request_data.headers);\n    request->SetExtraRequestHeaders(headers);\n  }\n\n  int load_flags = request_data.load_flags;\n  load_flags |= net::LOAD_VERIFY_EV_CERT;\n  if (request_data.resource_type == ResourceType::MAIN_FRAME) {\n    load_flags |= net::LOAD_MAIN_FRAME;\n  } else if (request_data.resource_type == ResourceType::SUB_FRAME) {\n    load_flags |= net::LOAD_SUB_FRAME;\n  } else if (request_data.resource_type == ResourceType::PREFETCH) {\n    load_flags |= (net::LOAD_PREFETCH | net::LOAD_DO_NOT_PROMPT_FOR_LOGIN);\n  } else if (request_data.resource_type == ResourceType::FAVICON) {\n    load_flags |= net::LOAD_DO_NOT_PROMPT_FOR_LOGIN;\n  }\n\n  if (sync_result)\n    load_flags |= net::LOAD_IGNORE_LIMITS;\n\n  ChildProcessSecurityPolicyImpl* policy =\n      ChildProcessSecurityPolicyImpl::GetInstance();\n  if (!policy->CanUseCookiesForOrigin(child_id, request_data.url)) {\n    load_flags |= (net::LOAD_DO_NOT_SEND_COOKIES |\n                   net::LOAD_DO_NOT_SEND_AUTH_DATA |\n                   net::LOAD_DO_NOT_SAVE_COOKIES);\n  }\n\n  if ((load_flags & net::LOAD_REPORT_RAW_HEADERS)\n      && !policy->CanReadRawCookies(child_id)) {\n    VLOG(1) << \"Denied unauthorized request for raw headers\";\n    load_flags &= ~net::LOAD_REPORT_RAW_HEADERS;\n  }\n\n  request->set_load_flags(load_flags);\n\n  request->set_context(\n      filter_->GetURLRequestContext(request_data.resource_type));\n  request->set_priority(DetermineRequestPriority(request_data.resource_type));\n\n  uint64 upload_size = 0;\n  if (request_data.upload_data) {\n    request->set_upload(request_data.upload_data);\n    base::ThreadRestrictions::ScopedAllowIO allow_io;\n    upload_size = request_data.upload_data->GetContentLengthSync();\n  }\n\n  if (request_data.resource_type == ResourceType::MAIN_FRAME &&\n      process_type == PROCESS_TYPE_RENDERER &&\n      CrossSiteRequestManager::GetInstance()->\n          HasPendingCrossSiteRequest(child_id, route_id)) {\n    handler = new CrossSiteResourceHandler(handler, child_id, route_id, this);\n  }\n\n  handler = new BufferedResourceHandler(handler, this, request);\n\n  ScopedVector<ResourceThrottle> throttles;\n  if (delegate_) {\n    bool is_continuation_of_transferred_request =\n        (deferred_request != NULL);\n\n    delegate_->RequestBeginning(request,\n                                resource_context,\n                                request_data.resource_type,\n                                child_id,\n                                route_id,\n                                is_continuation_of_transferred_request,\n                                &throttles);\n  }\n\n  if (request_data.resource_type == ResourceType::MAIN_FRAME) {\n    throttles.insert(\n        throttles.begin(), new TransferNavigationResourceThrottle(request));\n  }\n\n  if (!throttles.empty()) {\n    handler = new ThrottlingResourceHandler(this, handler, child_id, request_id,\n                                            throttles.Pass());\n  }\n\n  bool allow_download = request_data.allow_download &&\n      ResourceType::IsFrame(request_data.resource_type);\n  ResourceRequestInfoImpl* extra_info =\n      new ResourceRequestInfoImpl(\n          handler,\n          process_type,\n          child_id,\n          route_id,\n          request_data.origin_pid,\n          request_id,\n          request_data.is_main_frame,\n          request_data.frame_id,\n          request_data.parent_is_main_frame,\n          request_data.parent_frame_id,\n          request_data.resource_type,\n          request_data.transition_type,\n          upload_size,\n          false,  // is download\n          allow_download,\n          request_data.has_user_gesture,\n          request_data.referrer_policy,\n          resource_context);\n  extra_info->AssociateWithRequest(request);  // Request takes ownership.\n\n  if (request->url().SchemeIs(chrome::kBlobScheme)) {\n    webkit_blob::BlobStorageController* controller =\n        GetBlobStorageControllerForResourceContext(resource_context);\n    extra_info->set_requested_blob_data(\n        controller->GetBlobDataFromUrl(request->url()));\n  }\n\n  appcache::AppCacheInterceptor::SetExtraRequestInfo(\n      request, ResourceContext::GetAppCacheService(resource_context), child_id,\n      request_data.appcache_host_id, request_data.resource_type);\n\n  if (deferred_request) {\n    GlobalRequestID global_id(extra_info->GetChildID(),\n                              extra_info->GetRequestID());\n    pending_requests_[global_id] = request;\n    request->FollowDeferredRedirect();\n  } else {\n    BeginRequestInternal(request);\n  }\n}\n",
        "output": "0",
        "index": 116116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Cluster::Parse(long long& pos, long& len) const\n{\n    long status = Load(pos, len);\n    if (status < 0)\n        return status;\n    assert(m_pos >= m_element_start);\n    assert(m_timecode >= 0);\n    const long long cluster_stop =\n        (m_element_size < 0) ? -1 : m_element_start + m_element_size;\n    if ((cluster_stop >= 0) && (m_pos >= cluster_stop))\n        return 1;  //nothing else to do\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long total, avail;\n    status = pReader->Length(&total, &avail);\n    if (status < 0)  //error\n        return status;\n    assert((total < 0) || (avail <= total));\n    pos = m_pos;\n    for (;;)\n    {\n        if ((cluster_stop >= 0) && (pos >= cluster_stop))\n            break;\n        if ((total >= 0) && (pos >= total))\n        {\n            if (m_element_size < 0)\n                m_element_size = pos - m_element_start;\n            break;\n        }\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        long long result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(pReader, pos, len);\n        if (id < 0) //error\n            return static_cast<long>(id);\n        if (id == 0)  //weird\n            return E_FILE_FORMAT_INVALID;\n        if ((id == 0x0F43B675) || (id == 0x0C53BB6B)) //Cluster or Cues ID\n        {\n            if (m_element_size < 0)\n                m_element_size = pos - m_element_start;\n            break;\n        }\n        pos += len;  //consume ID field\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(pReader, pos, len);\n        if (size < 0)  //error\n            return static_cast<long>(size);\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)\n            return E_FILE_FORMAT_INVALID;\n        pos += len;  //consume size field\n        if ((cluster_stop >= 0) && (pos > cluster_stop))\n            return E_FILE_FORMAT_INVALID;\n        if (size == 0)  //weird\n            continue;\n        const long long block_stop = pos + size;\n        if (cluster_stop >= 0)\n        {\n            if (block_stop > cluster_stop)\n            {\n                if ((id == 0x20) || (id == 0x23))\n                    return E_FILE_FORMAT_INVALID;\n                pos = cluster_stop;\n                break;\n            }\n        }\n        else if ((total >= 0) && (block_stop > total))\n        {\n            m_element_size = total - m_element_start;\n            pos = total;\n            break;\n        }\n        else if (block_stop > avail)\n        {\n            len = static_cast<long>(size);\n            return E_BUFFER_NOT_FULL;\n        }\n        Cluster* const this_ = const_cast<Cluster*>(this);\n        if (id == 0x20)  //BlockGroup\n            return this_->ParseBlockGroup(size, pos, len);\n        if (id == 0x23)  //SimpleBlock\n            return this_->ParseSimpleBlock(size, pos, len);\n        pos += size;  //consume payload\n        assert((cluster_stop < 0) || (pos <= cluster_stop));\n    }\n    assert(m_element_size > 0);\n    m_pos = pos;\n    assert((cluster_stop < 0) || (m_pos <= cluster_stop));\n    if (m_entries_count > 0)\n    {\n        const long idx = m_entries_count - 1;\n        const BlockEntry* const pLast = m_entries[idx];\n        assert(pLast);\n        const Block* const pBlock = pLast->GetBlock();\n        assert(pBlock);\n        const long long start = pBlock->m_start;\n        if ((total >= 0) && (start > total))\n            return -1;  //defend against trucated stream\n        const long long size = pBlock->m_size;\n        const long long stop = start + size;\n        assert((cluster_stop < 0) || (stop <= cluster_stop));\n        if ((total >= 0) && (stop > total))\n            return -1;  //defend against trucated stream\n    }\n    return 1;  //no more entries\n}\n",
        "output": "1",
        "index": 188431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_image_t *jas_image_chclrspc(jas_image_t *image, jas_cmprof_t *outprof,\n  int intent)\n{\n\tjas_image_t *inimage;\n\tint minhstep;\n\tint minvstep;\n\tint i;\n\tint j;\n\tint k;\n\tint n;\n\tint hstep;\n\tint vstep;\n\tint numinauxchans;\n\tint numoutauxchans;\n\tint numinclrchans;\n\tint numoutclrchans;\n\tint prec;\n\tjas_image_t *outimage;\n\tint cmpttype;\n\tint numoutchans;\n\tjas_cmprof_t *inprof;\n\tjas_cmprof_t *tmpprof;\n\tjas_image_cmptparm_t cmptparm;\n\tint width;\n\tint height;\n\tjas_cmxform_t *xform;\n\tjas_cmpixmap_t inpixmap;\n\tjas_cmpixmap_t outpixmap;\n\tjas_cmcmptfmt_t *incmptfmts;\n\tjas_cmcmptfmt_t *outcmptfmts;\n\n#if 0\njas_eprintf(\"IMAGE\\n\");\njas_image_dump(image, stderr);\n#endif\n\n\toutimage = 0;\n\txform = 0;\n\tif (!(inimage = jas_image_copy(image)))\n\t\tgoto error;\n\timage = 0;\n\n\tif (!jas_image_ishomosamp(inimage)) {\n\t\tminhstep = jas_image_cmpthstep(inimage, 0);\n\t\tminvstep = jas_image_cmptvstep(inimage, 0);\n\t\tfor (i = 1; i < jas_image_numcmpts(inimage); ++i) {\n\t\t\thstep = jas_image_cmpthstep(inimage, i);\n\t\t\tvstep = jas_image_cmptvstep(inimage, i);\n\t\t\tif (hstep < minhstep) {\n\t\t\t\tminhstep = hstep;\n\t\t\t}\n\t\t\tif (vstep < minvstep) {\n\t\t\t\tminvstep = vstep;\n\t\t\t}\n\t\t}\n\t\tn = jas_image_numcmpts(inimage);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tcmpttype = jas_image_cmpttype(inimage, i);\n\t\t\tif (jas_image_sampcmpt(inimage, i, i + 1, 0, 0, minhstep, minvstep,\n\t\t\t  jas_image_cmptsgnd(inimage, i), jas_image_cmptprec(inimage, i))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_setcmpttype(inimage, i + 1, cmpttype);\n\t\t\tjas_image_delcmpt(inimage, i);\n\t\t}\n\t}\n\n\twidth = jas_image_cmptwidth(inimage, 0);\n\theight = jas_image_cmptheight(inimage, 0);\n\thstep = jas_image_cmpthstep(inimage, 0);\n\tvstep = jas_image_cmptvstep(inimage, 0);\n\n\tif (!(inprof = jas_image_cmprof(inimage))) {\n\t\tabort();\n\t}\n\tnuminclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(inprof));\n\tnuminauxchans = jas_image_numcmpts(inimage) - numinclrchans;\n\tnumoutclrchans = jas_clrspc_numchans(jas_cmprof_clrspc(outprof));\n\tnumoutauxchans = 0;\n\tnumoutchans = numoutclrchans + numoutauxchans;\n\tprec = 8;\n\n\tif (!(outimage = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\t/* Create a component for each of the colorants. */\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tcmptparm.tlx = 0;\n\t\tcmptparm.tly = 0;\n\t\tcmptparm.hstep = hstep;\n\t\tcmptparm.vstep = vstep;\n\t\tcmptparm.width = width;\n\t\tcmptparm.height = height;\n\t\tcmptparm.prec = prec;\n\t\tcmptparm.sgnd = 0;\n\t\tif (jas_image_addcmpt(outimage, -1, &cmptparm))\n\t\t\tgoto error;\n\t\tjas_image_setcmpttype(outimage, i, JAS_IMAGE_CT_COLOR(i));\n\t}\n#if 0\n\t/* Copy the auxiliary components without modification. */\n\tfor (i = 0; i < jas_image_numcmpts(inimage); ++i) {\n\t\tif (!ISCOLOR(jas_image_cmpttype(inimage, i))) {\n\t\t\tjas_image_copycmpt(outimage, -1, inimage, i);\n/* XXX - need to specify laydown of component on ref. grid */\n\t\t}\n\t}\n#endif\n\n\tif (!(tmpprof = jas_cmprof_copy(outprof)))\n\t\tgoto error;\n\tassert(!jas_image_cmprof(outimage));\n\tjas_image_setcmprof(outimage, tmpprof);\n\ttmpprof = 0;\n\tjas_image_setclrspc(outimage, jas_cmprof_clrspc(outprof));\n\n\tif (!(xform = jas_cmxform_create(inprof, outprof, 0, JAS_CMXFORM_OP_FWD,\n\t  intent, 0))) {\n\t\tgoto error;\n\t}\n\n\tinpixmap.numcmpts = numinclrchans;\n\tif (!(incmptfmts = jas_alloc2(numinclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\tinpixmap.cmptfmts = incmptfmts;\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(incmptfmts[i].buf = jas_alloc2(width, sizeof(long)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tincmptfmts[i].prec = jas_image_cmptprec(inimage, j);\n\t\tincmptfmts[i].sgnd = jas_image_cmptsgnd(inimage, j);\n\t\tincmptfmts[i].width = width;\n\t\tincmptfmts[i].height = 1;\n\t}\n\n\toutpixmap.numcmpts = numoutclrchans;\n\tif (!(outcmptfmts = jas_alloc2(numoutclrchans, sizeof(jas_cmcmptfmt_t)))) {\n\t\tabort();\n\t}\n\toutpixmap.cmptfmts = outcmptfmts;\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tj = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(i));\n\t\tassert(j >= 0);\n\t\tif (!(outcmptfmts[i].buf = jas_alloc2(width, sizeof(long))))\n\t\t\tgoto error;\n\t\toutcmptfmts[i].prec = jas_image_cmptprec(outimage, j);\n\t\toutcmptfmts[i].sgnd = jas_image_cmptsgnd(outimage, j);\n\t\toutcmptfmts[i].width = width;\n\t\toutcmptfmts[i].height = 1;\n\t}\n\n\tfor (i = 0; i < height; ++i) {\n\t\tfor (j = 0; j < numinclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(inimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_readcmpt2(inimage, k, 0, i, width, 1,\n\t\t\t  incmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t\tjas_cmxform_apply(xform, &inpixmap, &outpixmap);\n\t\tfor (j = 0; j < numoutclrchans; ++j) {\n\t\t\tk = jas_image_getcmptbytype(outimage, JAS_IMAGE_CT_COLOR(j));\n\t\t\tif (jas_image_writecmpt2(outimage, k, 0, i, width, 1,\n\t\t\t  outcmptfmts[j].buf))\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numoutclrchans; ++i) {\n\t\tjas_free(outcmptfmts[i].buf);\n\t}\n\tjas_free(outcmptfmts);\n\tfor (i = 0; i < numinclrchans; ++i) {\n\t\tjas_free(incmptfmts[i].buf);\n\t}\n\tjas_free(incmptfmts);\n\tjas_cmxform_destroy(xform);\n\tjas_image_destroy(inimage);\n\n#if 0\njas_eprintf(\"INIMAGE\\n\");\njas_image_dump(inimage, stderr);\njas_eprintf(\"OUTIMAGE\\n\");\njas_image_dump(outimage, stderr);\n#endif\n\treturn outimage;\nerror:\n\tif (xform)\n\t\tjas_cmxform_destroy(xform);\n\tif (inimage)\n\t\tjas_image_destroy(inimage);\n\tif (outimage)\n\t\tjas_image_destroy(outimage);\n\treturn 0;\n}\n",
        "output": "0",
        "index": 72756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(openssl_pkcs7_encrypt)\n{\n\tzval ** zrecipcerts, * zheaders = NULL;\n\tSTACK_OF(X509) * recipcerts = NULL;\n\tBIO * infile = NULL, * outfile = NULL;\n\tlong flags = 0;\n\tPKCS7 * p7 = NULL;\n\tHashPosition hpos;\n\tzval ** zcertval;\n\tX509 * cert;\n\tconst EVP_CIPHER *cipher = NULL;\n\tlong cipherid = PHP_OPENSSL_CIPHER_DEFAULT;\n\tuint strindexlen;\n\tulong intindex;\n\tchar * strindex;\n\tchar * infilename = NULL;\tint infilename_len;\n\tchar * outfilename = NULL;\tint outfilename_len;\n\n\tRETVAL_FALSE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ppZa!|ll\", &infilename, &infilename_len,\n\t\t\t\t&outfilename, &outfilename_len, &zrecipcerts, &zheaders, &flags, &cipherid) == FAILURE)\n\t\treturn;\n\n\n\tif (php_openssl_open_base_dir_chk(infilename TSRMLS_CC) || php_openssl_open_base_dir_chk(outfilename TSRMLS_CC)) {\n\t\treturn;\n\t}\n\n\tinfile = BIO_new_file(infilename, \"r\");\n\tif (infile == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\toutfile = BIO_new_file(outfilename, \"w\");\n\tif (outfile == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\trecipcerts = sk_X509_new_null();\n\n\t/* get certs */\n\tif (Z_TYPE_PP(zrecipcerts) == IS_ARRAY) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(*zrecipcerts), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(*zrecipcerts), (void**)&zcertval, &hpos) == SUCCESS) {\n\t\t\tlong certresource;\n\n\t\t\tcert = php_openssl_x509_from_zval(zcertval, 0, &certresource TSRMLS_CC);\n\t\t\tif (cert == NULL) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\n\t\t\tif (certresource != -1) {\n\t\t\t\t/* we shouldn't free this particular cert, as it is a resource.\n\t\t\t\t\tmake a copy and push that on the stack instead */\n\t\t\t\tcert = X509_dup(cert);\n\t\t\t\tif (cert == NULL) {\n\t\t\t\t\tgoto clean_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsk_X509_push(recipcerts, cert);\n\n\t\t\tzend_hash_move_forward_ex(HASH_OF(*zrecipcerts), &hpos);\n\t\t}\n\t} else {\n\t\t/* a single certificate */\n\t\tlong certresource;\n\n\t\tcert = php_openssl_x509_from_zval(zrecipcerts, 0, &certresource TSRMLS_CC);\n\t\tif (cert == NULL) {\n\t\t\tgoto clean_exit;\n\t\t}\n\n\t\tif (certresource != -1) {\n\t\t\t/* we shouldn't free this particular cert, as it is a resource.\n\t\t\t\tmake a copy and push that on the stack instead */\n\t\t\tcert = X509_dup(cert);\n\t\t\tif (cert == NULL) {\n\t\t\t\tgoto clean_exit;\n\t\t\t}\n\t\t}\n\t\tsk_X509_push(recipcerts, cert);\n\t}\n\n\t/* sanity check the cipher */\n\tcipher = php_openssl_get_evp_cipher_from_algo(cipherid);\n\tif (cipher == NULL) {\n\t\t/* shouldn't happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to get cipher\");\n\t\tgoto clean_exit;\n\t}\n\n\tp7 = PKCS7_encrypt(recipcerts, infile, (EVP_CIPHER*)cipher, flags);\n\n\tif (p7 == NULL) {\n\t\tgoto clean_exit;\n\t}\n\n\t/* tack on extra headers */\n\tif (zheaders) {\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(zheaders), &hpos);\n\t\twhile(zend_hash_get_current_data_ex(HASH_OF(zheaders), (void**)&zcertval, &hpos) == SUCCESS) {\n\t\t\tstrindex = NULL;\n\t\t\tzend_hash_get_current_key_ex(HASH_OF(zheaders), &strindex, &strindexlen, &intindex, 0, &hpos);\n\n\t\t\tconvert_to_string_ex(zcertval);\n\n\t\t\tif (strindex) {\n\t\t\t\tBIO_printf(outfile, \"%s: %s\\n\", strindex, Z_STRVAL_PP(zcertval));\n\t\t\t} else {\n\t\t\t\tBIO_printf(outfile, \"%s\\n\", Z_STRVAL_PP(zcertval));\n\t\t\t}\n\n\t\t\tzend_hash_move_forward_ex(HASH_OF(zheaders), &hpos);\n\t\t}\n\t}\n\n\t(void)BIO_reset(infile);\n\n\t/* write the encrypted data */\n\tSMIME_write_PKCS7(outfile, p7, infile, flags);\n\n\tRETVAL_TRUE;\n\nclean_exit:\n\tPKCS7_free(p7);\n\tBIO_free(infile);\n\tBIO_free(outfile);\n\tif (recipcerts) {\n\t\tsk_X509_pop_free(recipcerts, X509_free);\n\t}\n}\n",
        "output": "0",
        "index": 14216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)\n\t{\n\tunsigned char *p,*pseq;\n\tint i,mac_size,clear=0;\n\tint prefix_len = 0;\n\tint eivlen;\n\tSSL3_RECORD *wr;\n\tSSL3_BUFFER *wb;\n\tSSL_SESSION *sess;\n\n\t/* first check if there is a SSL3_BUFFER still being written\n\t * out.  This will happen with non blocking IO */\n\tif (s->s3->wbuf.left != 0)\n\t\t{\n\t\tOPENSSL_assert(0); /* XDTLS:  want to see if we ever get here */\n\t\treturn(ssl3_write_pending(s,type,buf,len));\n\t\t}\n\n\t/* If we have an alert to send, lets send it */\n\tif (s->s3->alert_dispatch)\n\t\t{\n\t\ti=s->method->ssl_dispatch_alert(s);\n\t\tif (i <= 0)\n\t\t\treturn(i);\n\t\t/* if it went, fall through and send more stuff */\n\t\t}\n\n\tif (len == 0 && !create_empty_fragment)\n\t\treturn 0;\n\n\twr= &(s->s3->wrec);\n\twb= &(s->s3->wbuf);\n\tsess=s->session;\n\n\tif (\t(sess == NULL) ||\n\t\t(s->enc_write_ctx == NULL) ||\n\t\t(EVP_MD_CTX_md(s->write_hash) == NULL))\n\t\tclear=1;\n\n\tif (clear)\n\t\tmac_size=0;\n\telse\n\t\t{\n\t\tmac_size=EVP_MD_CTX_size(s->write_hash);\n\t\tif (mac_size < 0)\n\t\t\tgoto err;\n\t\t}\n\n\t/* DTLS implements explicit IV, so no need for empty fragments */\n#if 0\n\t/* 'create_empty_fragment' is true only when this function calls itself */\n\tif (!clear && !create_empty_fragment && !s->s3->empty_fragment_done\n\t    && SSL_version(s) != DTLS1_VERSION && SSL_version(s) != DTLS1_BAD_VER)\n\t\t{\n\t\t/* countermeasure against known-IV weakness in CBC ciphersuites\n\t\t * (see http://www.openssl.org/~bodo/tls-cbc.txt) \n\t\t */\n\n\t\tif (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)\n\t\t\t{\n\t\t\t/* recursive function call with 'create_empty_fragment' set;\n\t\t\t * this prepares and buffers the data for an empty fragment\n\t\t\t * (these 'prefix_len' bytes are sent out later\n\t\t\t * together with the actual payload) */\n\t\t\tprefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);\n\t\t\tif (prefix_len <= 0)\n\t\t\t\tgoto err;\n\n\t\t\tif (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)\n\t\t\t\t{\n\t\t\t\t/* insufficient space */\n\t\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\ts->s3->empty_fragment_done = 1;\n\t\t}\n#endif\n\tp = wb->buf + prefix_len;\n\n\t/* write the header */\n\n\t*(p++)=type&0xff;\n\twr->type=type;\n\t/* Special case: for hello verify request, client version 1.0 and\n\t * we haven't decided which version to use yet send back using \n\t * version 1.0 header: otherwise some clients will ignore it.\n\t */\n\tif (s->method->version == DTLS_ANY_VERSION)\n\t\t{\n\t\t*(p++)=DTLS1_VERSION>>8;\n\t\t*(p++)=DTLS1_VERSION&0xff;\n\t\t}\n\telse\n\t\t{\n\t\t*(p++)=s->version>>8;\n\t\t*(p++)=s->version&0xff;\n\t\t}\n\n\t/* field where we are to write out packet epoch, seq num and len */\n\tpseq=p; \n\tp+=10;\n\n\t/* Explicit IV length, block ciphers appropriate version flag */\n\tif (s->enc_write_ctx)\n\t\t{\n\t\tint mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);\n\t\tif (mode == EVP_CIPH_CBC_MODE)\n\t\t\t{\n\t\t\teivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);\n\t\t\tif (eivlen <= 1)\n\t\t\t\teivlen = 0;\n\t\t\t}\n\t\t/* Need explicit part of IV for GCM mode */\n\t\telse if (mode == EVP_CIPH_GCM_MODE)\n\t\t\teivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;\n\t\telse\n\t\t\teivlen = 0;\n\t\t}\n\telse \n\t\teivlen = 0;\n\n\t/* lets setup the record stuff. */\n\twr->data=p + eivlen;  /* make room for IV in case of CBC */\n\twr->length=(int)len;\n\twr->input=(unsigned char *)buf;\n\n\t/* we now 'read' from wr->input, wr->length bytes into\n\t * wr->data */\n\n\t/* first we compress */\n\tif (s->compress != NULL)\n\t\t{\n\t\tif (!ssl3_do_compress(s))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(wr->data,wr->input,wr->length);\n\t\twr->input=wr->data;\n\t\t}\n\n\t/* we should still have the output to wr->data and the input\n\t * from wr->input.  Length should be wr->length.\n\t * wr->data still points in the wb->buf */\n\n\tif (mac_size != 0)\n\t\t{\n\t\tif(s->method->ssl3_enc->mac(s,&(p[wr->length + eivlen]),1) < 0)\n\t\t\tgoto err;\n\t\twr->length+=mac_size;\n\t\t}\n\n\t/* this is true regardless of mac size */\n\twr->input=p;\n\twr->data=p;\n\n\tif (eivlen)\n\t\twr->length += eivlen;\n\n\tif(s->method->ssl3_enc->enc(s,1) < 1) goto err;\n\n\t/* record length after mac and block padding */\n/*\tif (type == SSL3_RT_APPLICATION_DATA ||\n\t(type == SSL3_RT_ALERT && ! SSL_in_init(s))) */\n\t\n\t/* there's only one epoch between handshake and app data */\n\t\n\ts2n(s->d1->w_epoch, pseq);\n\n\t/* XDTLS: ?? */\n/*\telse\n\ts2n(s->d1->handshake_epoch, pseq); */\n\n\tmemcpy(pseq, &(s->s3->write_sequence[2]), 6);\n\tpseq+=6;\n\ts2n(wr->length,pseq);\n\n\tif (s->msg_callback)\n\t\ts->msg_callback(1, 0, SSL3_RT_HEADER, pseq - DTLS1_RT_HEADER_LENGTH, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);\n\n\t/* we should now have\n\t * wr->data pointing to the encrypted data, which is\n\t * wr->length long */\n\twr->type=type; /* not needed but helps for debugging */\n\twr->length+=DTLS1_RT_HEADER_LENGTH;\n\n#if 0  /* this is now done at the message layer */\n\t/* buffer the record, making it easy to handle retransmits */\n\tif ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\tdtls1_buffer_record(s, wr->data, wr->length, \n\t\t\t*((PQ_64BIT *)&(s->s3->write_sequence[0])));\n#endif\n\n\tssl3_record_sequence_update(&(s->s3->write_sequence[0]));\n\n\tif (create_empty_fragment)\n\t\t{\n\t\t/* we are in a recursive call;\n\t\t * just return the length, don't write out anything here\n\t\t */\n\t\treturn wr->length;\n\t\t}\n\n\t/* now let's set up wb */\n\twb->left = prefix_len + wr->length;\n\twb->offset = 0;\n\n\t/* memorize arguments so that ssl3_write_pending can detect bad write retries later */\n\ts->s3->wpend_tot=len;\n\ts->s3->wpend_buf=buf;\n\ts->s3->wpend_type=type;\n\ts->s3->wpend_ret=len;\n\n\t/* we now just need to write the buffer */\n\treturn ssl3_write_pending(s,type,buf,len);\nerr:\n\treturn -1;\n\t}\n",
        "output": "0",
        "index": 45163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RendererSchedulerImpl::AsValueLocked(base::TimeTicks optional_now) const {\n  helper_.CheckOnValidThread();\n  any_thread_lock_.AssertAcquired();\n\n  if (optional_now.is_null())\n    optional_now = helper_.NowTicks();\n  std::unique_ptr<base::trace_event::TracedValue> state(\n      new base::trace_event::TracedValue());\n  state->SetBoolean(\n      \"has_visible_render_widget_with_touch_handler\",\n      main_thread_only().has_visible_render_widget_with_touch_handler);\n  state->SetString(\"current_use_case\",\n                   UseCaseToString(main_thread_only().current_use_case));\n  state->SetBoolean(\"loading_tasks_seem_expensive\",\n                    main_thread_only().loading_tasks_seem_expensive);\n  state->SetBoolean(\"timer_tasks_seem_expensive\",\n                    main_thread_only().timer_tasks_seem_expensive);\n  state->SetBoolean(\"begin_frame_not_expected_soon\",\n                    main_thread_only().begin_frame_not_expected_soon);\n  state->SetBoolean(\n      \"compositor_will_send_main_frame_not_expected\",\n      main_thread_only().compositor_will_send_main_frame_not_expected);\n  state->SetBoolean(\"touchstart_expected_soon\",\n                    main_thread_only().touchstart_expected_soon);\n  state->SetString(\"idle_period_state\",\n                   IdleHelper::IdlePeriodStateToString(\n                       idle_helper_.SchedulerIdlePeriodState()));\n  state->SetBoolean(\"renderer_hidden\", main_thread_only().renderer_hidden);\n  state->SetBoolean(\"have_seen_a_begin_main_frame\",\n                    main_thread_only().have_seen_a_begin_main_frame);\n  state->SetBoolean(\"waiting_for_meaningful_paint\",\n                    any_thread().waiting_for_meaningful_paint);\n  state->SetBoolean(\"have_seen_input_since_navigation\",\n                    any_thread().have_seen_input_since_navigation);\n  state->SetBoolean(\n      \"have_reported_blocking_intervention_in_current_policy\",\n      main_thread_only().have_reported_blocking_intervention_in_current_policy);\n  state->SetBoolean(\n      \"have_reported_blocking_intervention_since_navigation\",\n      main_thread_only().have_reported_blocking_intervention_since_navigation);\n  state->SetBoolean(\"renderer_backgrounded\",\n                    main_thread_only().renderer_backgrounded);\n  state->SetBoolean(\"stopped_when_backgrounded\",\n                    main_thread_only().stopped_when_backgrounded);\n  state->SetDouble(\"now\", (optional_now - base::TimeTicks()).InMillisecondsF());\n  state->SetDouble(\n      \"fling_compositor_escalation_deadline\",\n      (any_thread().fling_compositor_escalation_deadline - base::TimeTicks())\n          .InMillisecondsF());\n  state->SetInteger(\"navigation_task_expected_count\",\n                    main_thread_only().navigation_task_expected_count);\n  state->SetDouble(\"last_idle_period_end_time\",\n                   (any_thread().last_idle_period_end_time - base::TimeTicks())\n                       .InMillisecondsF());\n  state->SetBoolean(\"awaiting_touch_start_response\",\n                    any_thread().awaiting_touch_start_response);\n  state->SetBoolean(\"begin_main_frame_on_critical_path\",\n                    any_thread().begin_main_frame_on_critical_path);\n  state->SetBoolean(\"last_gesture_was_compositor_driven\",\n                    any_thread().last_gesture_was_compositor_driven);\n  state->SetBoolean(\"default_gesture_prevented\",\n                    any_thread().default_gesture_prevented);\n  state->SetDouble(\"expected_loading_task_duration\",\n                   main_thread_only()\n                       .loading_task_cost_estimator.expected_task_duration()\n                       .InMillisecondsF());\n  state->SetDouble(\"expected_timer_task_duration\",\n                   main_thread_only()\n                       .timer_task_cost_estimator.expected_task_duration()\n                       .InMillisecondsF());\n  state->SetBoolean(\"is_audio_playing\", main_thread_only().is_audio_playing);\n  state->SetBoolean(\"virtual_time_stopped\",\n                    main_thread_only().virtual_time_stopped);\n  state->SetDouble(\"virtual_time_pause_count\",\n                   main_thread_only().virtual_time_pause_count);\n  state->SetString(\n      \"virtual_time_policy\",\n      VirtualTimePolicyToString(main_thread_only().virtual_time_policy));\n  state->SetBoolean(\"virtual_time\", main_thread_only().use_virtual_time);\n\n  state->BeginDictionary(\"web_view_schedulers\");\n  for (WebViewSchedulerImpl* web_view_scheduler :\n       main_thread_only().web_view_schedulers) {\n    state->BeginDictionaryWithCopiedName(PointerToString(web_view_scheduler));\n    web_view_scheduler->AsValueInto(state.get());\n    state->EndDictionary();\n  }\n  state->EndDictionary();\n\n  state->BeginDictionary(\"policy\");\n  main_thread_only().current_policy.AsValueInto(state.get());\n  state->EndDictionary();\n\n  state->SetDouble(\n      \"longest_jank_free_task_duration\",\n      main_thread_only().longest_jank_free_task_duration->InMillisecondsF());\n  state->SetDouble(\n      \"compositor_frame_interval\",\n      main_thread_only().compositor_frame_interval.InMillisecondsF());\n  state->SetDouble(\n      \"estimated_next_frame_begin\",\n      (main_thread_only().estimated_next_frame_begin - base::TimeTicks())\n          .InMillisecondsF());\n  state->SetBoolean(\"in_idle_period\", any_thread().in_idle_period);\n\n  state->SetString(\n      \"expensive_task_policy\",\n      ExpensiveTaskPolicyToString(main_thread_only().expensive_task_policy));\n\n  any_thread().user_model.AsValueInto(state.get());\n  render_widget_scheduler_signals_.AsValueInto(state.get());\n\n  state->BeginDictionary(\"task_queue_throttler\");\n  task_queue_throttler_->AsValueInto(state.get(), optional_now);\n  state->EndDictionary();\n\n  return std::move(state);\n}\n",
        "output": "0",
        "index": 156164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "magiccheck(struct magic_set *ms, struct magic *m)\n{\n\tuint64_t l = m->value.q;\n\tuint64_t v;\n\tfloat fl, fv;\n\tdouble dl, dv;\n\tint matched;\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (m->type) {\n\tcase FILE_BYTE:\n\t\tv = p->b;\n\t\tbreak;\n\n\tcase FILE_SHORT:\n\tcase FILE_BESHORT:\n\tcase FILE_LESHORT:\n\t\tv = p->h;\n\t\tbreak;\n\n\tcase FILE_LONG:\n\tcase FILE_BELONG:\n\tcase FILE_LELONG:\n\tcase FILE_MELONG:\n\tcase FILE_DATE:\n\tcase FILE_BEDATE:\n\tcase FILE_LEDATE:\n\tcase FILE_MEDATE:\n\tcase FILE_LDATE:\n\tcase FILE_BELDATE:\n\tcase FILE_LELDATE:\n\tcase FILE_MELDATE:\n\t\tv = p->l;\n\t\tbreak;\n\n\tcase FILE_QUAD:\n\tcase FILE_LEQUAD:\n\tcase FILE_BEQUAD:\n\tcase FILE_QDATE:\n\tcase FILE_BEQDATE:\n\tcase FILE_LEQDATE:\n\tcase FILE_QLDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_QWDATE:\n\tcase FILE_BEQWDATE:\n\tcase FILE_LEQWDATE:\n\t\tv = p->q;\n\t\tbreak;\n\n\tcase FILE_FLOAT:\n\tcase FILE_BEFLOAT:\n\tcase FILE_LEFLOAT:\n\t\tfl = m->value.f;\n\t\tfv = p->f;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = fv != fl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = fv == fl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = fv > fl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = fv < fl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with float: invalid relation `%c'\",\n\t\t\t    m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DOUBLE:\n\tcase FILE_BEDOUBLE:\n\tcase FILE_LEDOUBLE:\n\t\tdl = m->value.d;\n\t\tdv = p->d;\n\t\tswitch (m->reln) {\n\t\tcase 'x':\n\t\t\tmatched = 1;\n\t\t\tbreak;\n\n\t\tcase '!':\n\t\t\tmatched = dv != dl;\n\t\t\tbreak;\n\n\t\tcase '=':\n\t\t\tmatched = dv == dl;\n\t\t\tbreak;\n\n\t\tcase '>':\n\t\t\tmatched = dv > dl;\n\t\t\tbreak;\n\n\t\tcase '<':\n\t\t\tmatched = dv < dl;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfile_magerror(ms, \"cannot happen with double: invalid relation `%c'\", m->reln);\n\t\t\treturn -1;\n\t\t}\n\t\treturn matched;\n\n\tcase FILE_DEFAULT:\n\tcase FILE_CLEAR:\n\t\tl = 0;\n\t\tv = 0;\n\t\tbreak;\n\n\tcase FILE_STRING:\n\tcase FILE_PSTRING:\n\t\tl = 0;\n\t\tv = file_strncmp(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_BESTRING16:\n\tcase FILE_LESTRING16:\n\t\tl = 0;\n\t\tv = file_strncmp16(m->value.s, p->s, (size_t)m->vallen, m->str_flags);\n\t\tbreak;\n\n\tcase FILE_SEARCH: { /* search ms->search.s for the string m->value.s */\n\t\tsize_t slen;\n\t\tsize_t idx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tslen = MIN(m->vallen, sizeof(m->value.s));\n\t\tl = 0;\n\t\tv = 0;\n\n\t\tfor (idx = 0; m->str_range == 0 || idx < m->str_range; idx++) {\n \t\t\tif (slen + idx > ms->search.s_len)\n \t\t\t\tbreak;\n \n\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen, m->str_flags);\n \t\t\tif (v == 0) {\t/* found match */\n \t\t\t\tms->search.offset += idx;\n \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase FILE_REGEX: {\n\t\tint rc;\n\t\tfile_regex_t rx;\n\n\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n \t\t\tfile_regerror(&rx, rc, ms);\n \t\t\tv = (uint64_t)-1;\n \t\t} else {\n#ifndef REG_STARTEND\n\t\t\tchar c;\n#endif\n \t\t\tregmatch_t pmatch[1];\n \t\t\tsize_t slen = ms->search.s_len;\n\t\t\t/* Limit by offset if requested */\n\t\t\tif (m->str_range > 0)\n\t\t\t\tslen = MIN(slen, m->str_range);\n #ifndef REG_STARTEND\n #define\tREG_STARTEND\t0\n \t\t\tif (slen != 0)\n \t\t\t\tslen--;\n \t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;\n\t\t\t\tms->search.rm_len =\n\t\t\t\t    (size_t)(pmatch[0].rm_eo - pmatch[0].rm_so);\n\t\t\t\tv = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase REG_NOMATCH:\n\t\t\t\tv = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\t\tv = (uint64_t)-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfile_regfree(&rx);\n\t\tif (v == (uint64_t)-1)\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\tcase FILE_INDIRECT:\n\tcase FILE_USE:\n\tcase FILE_NAME:\n\t\treturn 1;\n\tdefault:\n\t\tfile_magerror(ms, \"invalid type %d in magiccheck()\", m->type);\n\t\treturn -1;\n\t}\n\n\tv = file_signextend(ms, m, v);\n\n\tswitch (m->reln) {\n\tcase 'x':\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t    \"u == *any* = 1\\n\", (unsigned long long)v);\n\t\tmatched = 1;\n\t\tbreak;\n\n\tcase '!':\n\t\tmatched = v != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u != %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '=':\n\t\tmatched = v == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT \"u == %\"\n\t\t\t    INT64_T_FORMAT \"u = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, matched);\n\t\tbreak;\n\n\tcase '>':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v > l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u > %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v > (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d > %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t    (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '<':\n\t\tif (m->flag & UNSIGNED) {\n\t\t\tmatched = v < l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"u < %\" INT64_T_FORMAT \"u = %d\\n\",\n\t\t\t\t    (unsigned long long)v,\n\t\t\t\t    (unsigned long long)l, matched);\n\t\t}\n\t\telse {\n\t\t\tmatched = (int64_t) v < (int64_t) l;\n\t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t\t(void) fprintf(stderr, \"%\" INT64_T_FORMAT\n\t\t\t\t    \"d < %\" INT64_T_FORMAT \"d = %d\\n\",\n\t\t\t\t     (long long)v, (long long)l, matched);\n\t\t}\n\t\tbreak;\n\n\tcase '&':\n\t\tmatched = (v & l) == l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) == %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tcase '^':\n\t\tmatched = (v & l) != l;\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\t(void) fprintf(stderr, \"((%\" INT64_T_FORMAT \"x & %\"\n\t\t\t    INT64_T_FORMAT \"x) != %\" INT64_T_FORMAT\n\t\t\t    \"x) = %d\\n\", (unsigned long long)v,\n\t\t\t    (unsigned long long)l, (unsigned long long)l,\n\t\t\t    matched);\n\t\tbreak;\n\n\tdefault:\n\t\tfile_magerror(ms, \"cannot happen: invalid relation `%c'\",\n\t\t    m->reln);\n\t\treturn -1;\n\t}\n\n\treturn matched;\n}\n",
        "output": "1",
        "index": 179529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGLRenderingContextBase::TexImageHelperImageBitmap(\n    TexImageFunctionID function_id,\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLenum format,\n    GLenum type,\n    GLint xoffset,\n    GLint yoffset,\n    GLint zoffset,\n    ImageBitmap* bitmap,\n    const IntRect& source_sub_rect,\n    GLsizei depth,\n    GLint unpack_image_height,\n    ExceptionState& exception_state) {\n  const char* func_name = GetTexImageFunctionName(function_id);\n  if (isContextLost())\n    return;\n  if (!ValidateImageBitmap(func_name, bitmap, exception_state))\n    return;\n  WebGLTexture* texture =\n      ValidateTexImageBinding(func_name, function_id, target);\n  if (!texture)\n    return;\n\n  bool selecting_sub_rectangle = false;\n  if (!ValidateTexImageSubRectangle(func_name, function_id, bitmap,\n                                    source_sub_rect, depth, unpack_image_height,\n                                    &selecting_sub_rectangle)) {\n    return;\n  }\n\n  TexImageFunctionType function_type;\n  if (function_id == kTexImage2D)\n    function_type = kTexImage;\n  else\n    function_type = kTexSubImage;\n\n  GLsizei width = source_sub_rect.Width();\n  GLsizei height = source_sub_rect.Height();\n  if (!ValidateTexFunc(func_name, function_type, kSourceImageBitmap, target,\n                       level, internalformat, width, height, depth, 0, format,\n                       type, xoffset, yoffset, zoffset))\n    return;\n  scoped_refptr<StaticBitmapImage> image = bitmap->BitmapImage();\n  DCHECK(image);\n\n  if (function_id != kTexSubImage3D && function_id != kTexImage3D &&\n      image->IsTextureBacked() && CanUseTexImageViaGPU(format, type) &&\n      !selecting_sub_rectangle) {\n    AcceleratedStaticBitmapImage* accel_image =\n        static_cast<AcceleratedStaticBitmapImage*>(image.get());\n    bool premultiply_alpha = true;  // TODO(kbr): this looks wrong!\n    bool flip_y = false;\n    if (function_id == kTexImage2D) {\n      TexImage2DBase(target, level, internalformat, width, height, 0, format,\n                     type, nullptr);\n      TexImageViaGPU(function_id, texture, target, level, 0, 0, 0, accel_image,\n                     nullptr, source_sub_rect, premultiply_alpha, flip_y);\n    } else if (function_id == kTexSubImage2D) {\n      TexImageViaGPU(function_id, texture, target, level, xoffset, yoffset, 0,\n                     accel_image, nullptr, source_sub_rect, premultiply_alpha,\n                     flip_y);\n    }\n    return;\n  }\n\n  sk_sp<SkImage> sk_image =\n      bitmap->BitmapImage()->PaintImageForCurrentFrame().GetSkImage();\n  if (!sk_image) {\n    SynthesizeGLError(GL_OUT_OF_MEMORY, func_name,\n                      \"ImageBitmap unexpectedly empty\");\n    return;\n  }\n\n  SkPixmap pixmap;\n  uint8_t* pixel_data_ptr = nullptr;\n  scoped_refptr<Uint8Array> pixel_data;\n  bool peek_succeed = sk_image->peekPixels(&pixmap);\n  if (peek_succeed) {\n    pixel_data_ptr = static_cast<uint8_t*>(pixmap.writable_addr());\n  } else {\n    pixel_data = bitmap->CopyBitmapData(\n        bitmap->IsPremultiplied() ? kPremultiplyAlpha : kUnpremultiplyAlpha);\n    pixel_data_ptr = pixel_data->Data();\n  }\n  Vector<uint8_t> data;\n  bool need_conversion = true;\n  bool have_peekable_rgba =\n      (peek_succeed &&\n       pixmap.colorType() == SkColorType::kRGBA_8888_SkColorType);\n  bool is_pixel_data_rgba = (have_peekable_rgba || !peek_succeed);\n  if (is_pixel_data_rgba && format == GL_RGBA && type == GL_UNSIGNED_BYTE &&\n      !selecting_sub_rectangle && depth == 1) {\n    need_conversion = false;\n  } else {\n    if (type == GL_UNSIGNED_INT_10F_11F_11F_REV) {\n      type = GL_FLOAT;\n    }\n    bool is_pixel_data_bgra =\n        pixmap.colorType() == SkColorType::kBGRA_8888_SkColorType;\n    if ((is_pixel_data_bgra &&\n         !WebGLImageConversion::ExtractImageData(\n             pixel_data_ptr, WebGLImageConversion::DataFormat::kDataFormatBGRA8,\n             bitmap->Size(), source_sub_rect, depth, unpack_image_height,\n             format, type, false, false, data)) ||\n        (is_pixel_data_rgba &&\n         !WebGLImageConversion::ExtractImageData(\n             pixel_data_ptr, WebGLImageConversion::DataFormat::kDataFormatRGBA8,\n             bitmap->Size(), source_sub_rect, depth, unpack_image_height,\n             format, type, false, false, data))) {\n      SynthesizeGLError(GL_INVALID_VALUE, func_name, \"bad image data\");\n      return;\n    }\n  }\n  ScopedUnpackParametersResetRestore temporary_reset_unpack(this);\n  if (function_id == kTexImage2D) {\n    TexImage2DBase(target, level, internalformat, width, height, 0, format,\n                   type, need_conversion ? data.data() : pixel_data_ptr);\n  } else if (function_id == kTexSubImage2D) {\n    ContextGL()->TexSubImage2D(target, level, xoffset, yoffset, width, height,\n                               format, type,\n                               need_conversion ? data.data() : pixel_data_ptr);\n  } else if (function_id == kTexImage3D) {\n    ContextGL()->TexImage3D(target, level, internalformat, width, height, depth,\n                            0, format, type,\n                            need_conversion ? data.data() : pixel_data_ptr);\n  } else {\n    DCHECK_EQ(function_id, kTexSubImage3D);\n    ContextGL()->TexSubImage3D(target, level, xoffset, yoffset, zoffset, width,\n                               height, depth, format, type,\n                               need_conversion ? data.data() : pixel_data_ptr);\n  }\n}\n",
        "output": "0",
        "index": 154985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType WriteSUNImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  SUNInfo\n    sun_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SUN raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    sun_info.magic=0x59a66a95;\n    if ((image->columns != (unsigned int) image->columns) ||\n        (image->rows != (unsigned int) image->rows))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    sun_info.width=(unsigned int) image->columns;\n    sun_info.height=(unsigned int) image->rows;\n    sun_info.type=(unsigned int)\n      (image->storage_class == DirectClass ? RT_FORMAT_RGB : RT_STANDARD);\n    sun_info.maptype=RMT_NONE;\n    sun_info.maplength=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*number_pixels) != (size_t) (4*number_pixels))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color SUN raster.\n        */\n        sun_info.depth=(unsigned int) image->alpha_trait != UndefinedPixelTrait ?\n          32U : 24U;\n        sun_info.length=(unsigned int) ((image->alpha_trait != UndefinedPixelTrait ?\n          4 : 3)*number_pixels);\n        sun_info.length+=sun_info.length & 0x01 ? (unsigned int) image->rows :\n          0;\n      }\n    else\n      if (IsImageMonochrome(image,exception) != MagickFalse)\n        {\n          /*\n            Monochrome SUN raster.\n          */\n          sun_info.depth=1;\n          sun_info.length=(unsigned int) (((image->columns+7) >> 3)*\n            image->rows);\n          sun_info.length+=(unsigned int) (((image->columns/8)+(image->columns %\n            8 ? 1 : 0)) % 2 ? image->rows : 0);\n        }\n      else\n        {\n          /*\n            Colormapped SUN raster.\n          */\n          sun_info.depth=8;\n          sun_info.length=(unsigned int) number_pixels;\n          sun_info.length+=(unsigned int) (image->columns & 0x01 ? image->rows :\n            0);\n          sun_info.maptype=RMT_EQUAL_RGB;\n          sun_info.maplength=(unsigned int) (3*image->colors);\n        }\n    /*\n      Write SUN header.\n    */\n    (void) WriteBlobMSBLong(image,sun_info.magic);\n    (void) WriteBlobMSBLong(image,sun_info.width);\n    (void) WriteBlobMSBLong(image,sun_info.height);\n    (void) WriteBlobMSBLong(image,sun_info.depth);\n    (void) WriteBlobMSBLong(image,sun_info.length);\n    (void) WriteBlobMSBLong(image,sun_info.type);\n    (void) WriteBlobMSBLong(image,sun_info.maptype);\n    (void) WriteBlobMSBLong(image,sun_info.maplength);\n    /*\n      Convert MIFF to SUN raster pixels.\n    */\n    x=0;\n    y=0;\n    if (image->storage_class == DirectClass)\n      {\n        register unsigned char\n          *q;\n\n        size_t\n          bytes_per_pixel,\n          length;\n\n        unsigned char\n          *pixels;\n\n        /*\n          Allocate memory for pixels.\n        */\n        bytes_per_pixel=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          bytes_per_pixel++;\n        length=image->columns;\n        pixels=(unsigned char *) AcquireQuantumMemory(length,4*sizeof(*pixels));\n        if (pixels == (unsigned char *) NULL)\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert DirectClass packet to SUN RGB pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (((bytes_per_pixel*image->columns) & 0x01) != 0)\n            *q++='\\0';  /* pad scanline */\n          (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      }\n    else\n      if (IsImageMonochrome(image,exception) != MagickFalse)\n        {\n          register unsigned char\n            bit,\n            byte;\n\n          /*\n            Convert PseudoClass image to a SUN monochrome image.\n          */\n          (void) SetImageType(image,BilevelType,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            bit=0;\n            byte=0;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              byte<<=1;\n              if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                byte|=0x01;\n              bit++;\n              if (bit == 8)\n                {\n                  (void) WriteBlobByte(image,byte);\n                  bit=0;\n                  byte=0;\n                }\n              p+=GetPixelChannels(image);\n            }\n            if (bit != 0)\n              (void) WriteBlobByte(image,(unsigned char) (byte << (8-bit)));\n            if ((((image->columns/8)+\n                (image->columns % 8 ? 1 : 0)) % 2) != 0)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          /*\n            Dump colormap to file.\n          */\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].red)));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].green)));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            (void) WriteBlobByte(image,ScaleQuantumToChar(\n              ClampToQuantum(image->colormap[i].blue)));\n          /*\n            Convert PseudoClass packet to SUN colormapped pixel.\n          */\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              (void) WriteBlobByte(image,(unsigned char)\n                GetPixelIndex(image,p));\n              p+=GetPixelChannels(image);\n            }\n            if (image->columns & 0x01)\n              (void) WriteBlobByte(image,0);  /* pad scanline */\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "output": "0",
        "index": 74005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bta_av_rc_opened(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {\n  tBTA_AV_RC_OPEN rc_open;\n  tBTA_AV_SCB* p_scb;\n int i;\n uint8_t shdl = 0;\n  tBTA_AV_LCB* p_lcb;\n  tBTA_AV_RCB* p_rcb;\n uint8_t tmp;\n uint8_t disc = 0;\n\n /* find the SCB & stop the timer */\n for (i = 0; i < BTA_AV_NUM_STRS; i++) {\n    p_scb = p_cb->p_scb[i];\n if (p_scb && p_scb->PeerAddress() == p_data->rc_conn_chg.peer_addr) {\n      p_scb->rc_handle = p_data->rc_conn_chg.handle;\n      APPL_TRACE_DEBUG(\"%s: shdl:%d, srch %d\", __func__, i + 1,\n                       p_scb->rc_handle);\n      shdl = i + 1;\n      LOG_INFO(LOG_TAG, \"%s: allow incoming AVRCP connections:%d\", __func__,\n               p_scb->use_rc);\n      alarm_cancel(p_scb->avrc_ct_timer);\n      disc = p_scb->hndl;\n break;\n }\n }\n\n  i = p_data->rc_conn_chg.handle;\n if (p_cb->rcb[i].handle == BTA_AV_RC_HANDLE_NONE) {\n    APPL_TRACE_ERROR(\"%s: not a valid handle:%d any more\", __func__, i);\n return;\n }\n\n  APPL_TRACE_DEBUG(\"%s: local features %d peer features %d\", __func__,\n                   p_cb->features, p_cb->rcb[i].peer_features);\n\n /* listen to browsing channel when the connection is open,\n   * if peer initiated AVRCP connection and local device supports browsing\n   * channel */\n  AVRC_OpenBrowse(p_data->rc_conn_chg.handle, AVCT_ACP);\n\n if (p_cb->rcb[i].lidx == (BTA_AV_NUM_LINKS + 1) && shdl != 0) {\n /* rc is opened on the RC only ACP channel, but is for a specific\n     * SCB -> need to switch RCBs */\n    p_rcb = bta_av_get_rcb_by_shdl(shdl);\n if (p_rcb) {\n      p_rcb->shdl = p_cb->rcb[i].shdl;\n      tmp = p_rcb->lidx;\n      p_rcb->lidx = p_cb->rcb[i].lidx;\n      p_cb->rcb[i].lidx = tmp;\n      p_cb->rc_acp_handle = p_rcb->handle;\n      p_cb->rc_acp_idx = (p_rcb - p_cb->rcb) + 1;\n      APPL_TRACE_DEBUG(\"%s: switching RCB rc_acp_handle:%d idx:%d\", __func__,\n                       p_cb->rc_acp_handle, p_cb->rc_acp_idx);\n }\n }\n\n  p_cb->rcb[i].shdl = shdl;\n  rc_open.rc_handle = i;\n  APPL_TRACE_ERROR(\"%s: rcb[%d] shdl:%d lidx:%d/%d\", __func__, i, shdl,\n                   p_cb->rcb[i].lidx, p_cb->lcb[BTA_AV_NUM_LINKS].lidx);\n  p_cb->rcb[i].status |= BTA_AV_RC_CONN_MASK;\n\n if (!shdl && 0 == p_cb->lcb[BTA_AV_NUM_LINKS].lidx) {\n /* no associated SCB -> connected to an RC only device\n     * update the index to the extra LCB */\n    p_lcb = &p_cb->lcb[BTA_AV_NUM_LINKS];\n    p_lcb->addr = p_data->rc_conn_chg.peer_addr;\n    p_lcb->lidx = BTA_AV_NUM_LINKS + 1;\n    p_cb->rcb[i].lidx = p_lcb->lidx;\n    p_lcb->conn_msk = 1;\n    APPL_TRACE_ERROR(\"%s: bd_addr: %s rcb[%d].lidx=%d, lcb.conn_msk=x%x\",\n                     __func__, p_lcb->addr.ToString().c_str(), i,\n                     p_cb->rcb[i].lidx, p_lcb->conn_msk);\n    disc = p_data->rc_conn_chg.handle | BTA_AV_CHNL_MSK;\n }\n\n  rc_open.peer_addr = p_data->rc_conn_chg.peer_addr;\n  rc_open.peer_features = p_cb->rcb[i].peer_features;\n  rc_open.status = BTA_AV_SUCCESS;\n  APPL_TRACE_DEBUG(\"%s: local features:x%x peer_features:x%x\", __func__,\n                   p_cb->features, rc_open.peer_features);\n if (rc_open.peer_features == 0) {\n /* we have not done SDP on peer RC capabilities.\n     * peer must have initiated the RC connection */\n if (p_cb->features & BTA_AV_FEAT_RCCT)\n      rc_open.peer_features |= BTA_AV_FEAT_RCTG;\n if (p_cb->features & BTA_AV_FEAT_RCTG)\n      rc_open.peer_features |= BTA_AV_FEAT_RCCT;\n\n    bta_av_rc_disc(disc);\n }\n  tBTA_AV bta_av_data;\n  bta_av_data.rc_open = rc_open;\n (*p_cb->p_cback)(BTA_AV_RC_OPEN_EVT, &bta_av_data);\n\n /* if local initiated AVRCP connection and both peer and locals device support\n   * browsing channel, open the browsing channel now\n   * TODO (sanketa): Some TG would not broadcast browse feature hence check\n   * inter-op. */\n if ((p_cb->features & BTA_AV_FEAT_BROWSE) &&\n (rc_open.peer_features & BTA_AV_FEAT_BROWSE) &&\n ((p_cb->rcb[i].status & BTA_AV_RC_ROLE_MASK) == BTA_AV_RC_ROLE_INT)) {\n    APPL_TRACE_DEBUG(\"%s: opening AVRC Browse channel\", __func__);\n    AVRC_OpenBrowse(p_data->rc_conn_chg.handle, AVCT_INT);\n }\n}\n",
        "output": "0",
        "index": 176035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pmul(struct pt_regs *regs, unsigned int insn, unsigned int opf)\n{\n\tstruct fpustate *f = FPUSTATE;\n\tunsigned long rs1, rs2, rd_val;\n\n\tswitch (opf) {\n\tcase FMUL8x16_OPF: {\n\t\tunsigned long byte;\n\n\t\trs1 = fps_regval(f, RS1(insn));\n\t\trs2 = fpd_regval(f, RS2(insn));\n\n\t\trd_val = 0;\n\t\tfor (byte = 0; byte < 4; byte++) {\n\t\t\tu16 src1 = (rs1 >> (byte *  8)) & 0x00ff;\n\t\t\ts16 src2 = (rs2 >> (byte * 16)) & 0xffff;\n\t\t\tu32 prod = src1 * src2;\n\t\t\tu16 scaled = ((prod & 0x00ffff00) >> 8);\n\n\t\t\t/* Round up.  */\n\t\t\tif (prod & 0x80)\n\t\t\t\tscaled++;\n\t\t\trd_val |= ((scaled & 0xffffUL) << (byte * 16UL));\n\t\t}\n\n\t\t*fpd_regaddr(f, RD(insn)) = rd_val;\n\t\tbreak;\n\t}\n\n\tcase FMUL8x16AU_OPF:\n\tcase FMUL8x16AL_OPF: {\n\t\tunsigned long byte;\n\t\ts16 src2;\n\n\t\trs1 = fps_regval(f, RS1(insn));\n\t\trs2 = fps_regval(f, RS2(insn));\n\n\t\trd_val = 0;\n\t\tsrc2 = rs2 >> (opf == FMUL8x16AU_OPF ? 16 : 0);\n\t\tfor (byte = 0; byte < 4; byte++) {\n\t\t\tu16 src1 = (rs1 >> (byte * 8)) & 0x00ff;\n\t\t\tu32 prod = src1 * src2;\n\t\t\tu16 scaled = ((prod & 0x00ffff00) >> 8);\n\n\t\t\t/* Round up.  */\n\t\t\tif (prod & 0x80)\n\t\t\t\tscaled++;\n\t\t\trd_val |= ((scaled & 0xffffUL) << (byte * 16UL));\n\t\t}\n\n\t\t*fpd_regaddr(f, RD(insn)) = rd_val;\n\t\tbreak;\n\t}\n\n\tcase FMUL8SUx16_OPF:\n\tcase FMUL8ULx16_OPF: {\n\t\tunsigned long byte, ushift;\n\n\t\trs1 = fpd_regval(f, RS1(insn));\n\t\trs2 = fpd_regval(f, RS2(insn));\n\n\t\trd_val = 0;\n\t\tushift = (opf == FMUL8SUx16_OPF) ? 8 : 0;\n\t\tfor (byte = 0; byte < 4; byte++) {\n\t\t\tu16 src1;\n\t\t\ts16 src2;\n\t\t\tu32 prod;\n\t\t\tu16 scaled;\n\n\t\t\tsrc1 = ((rs1 >> ((16 * byte) + ushift)) & 0x00ff);\n\t\t\tsrc2 = ((rs2 >> (16 * byte)) & 0xffff);\n\t\t\tprod = src1 * src2;\n\t\t\tscaled = ((prod & 0x00ffff00) >> 8);\n\n\t\t\t/* Round up.  */\n\t\t\tif (prod & 0x80)\n\t\t\t\tscaled++;\n\t\t\trd_val |= ((scaled & 0xffffUL) << (byte * 16UL));\n\t\t}\n\n\t\t*fpd_regaddr(f, RD(insn)) = rd_val;\n\t\tbreak;\n\t}\n\n\tcase FMULD8SUx16_OPF:\n\tcase FMULD8ULx16_OPF: {\n\t\tunsigned long byte, ushift;\n\n\t\trs1 = fps_regval(f, RS1(insn));\n\t\trs2 = fps_regval(f, RS2(insn));\n\n\t\trd_val = 0;\n\t\tushift = (opf == FMULD8SUx16_OPF) ? 8 : 0;\n\t\tfor (byte = 0; byte < 2; byte++) {\n\t\t\tu16 src1;\n\t\t\ts16 src2;\n\t\t\tu32 prod;\n\t\t\tu16 scaled;\n\n\t\t\tsrc1 = ((rs1 >> ((16 * byte) + ushift)) & 0x00ff);\n\t\t\tsrc2 = ((rs2 >> (16 * byte)) & 0xffff);\n\t\t\tprod = src1 * src2;\n\t\t\tscaled = ((prod & 0x00ffff00) >> 8);\n\n\t\t\t/* Round up.  */\n\t\t\tif (prod & 0x80)\n\t\t\t\tscaled++;\n\t\t\trd_val |= ((scaled & 0xffffUL) <<\n\t\t\t\t   ((byte * 32UL) + 7UL));\n\t\t}\n\t\t*fpd_regaddr(f, RD(insn)) = rd_val;\n\t\tbreak;\n\t}\n\t}\n}\n",
        "output": "0",
        "index": 25720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qib_get_base_info(struct file *fp, void __user *ubase,\n\t\t\t     size_t ubase_size)\n{\n\tstruct qib_ctxtdata *rcd = ctxt_fp(fp);\n\tint ret = 0;\n\tstruct qib_base_info *kinfo = NULL;\n\tstruct qib_devdata *dd = rcd->dd;\n\tstruct qib_pportdata *ppd = rcd->ppd;\n\tunsigned subctxt_cnt;\n\tint shared, master;\n\tsize_t sz;\n\n\tsubctxt_cnt = rcd->subctxt_cnt;\n\tif (!subctxt_cnt) {\n\t\tshared = 0;\n\t\tmaster = 0;\n\t\tsubctxt_cnt = 1;\n\t} else {\n\t\tshared = 1;\n\t\tmaster = !subctxt_fp(fp);\n\t}\n\n\tsz = sizeof(*kinfo);\n\t/* If context sharing is not requested, allow the old size structure */\n\tif (!shared)\n\t\tsz -= 7 * sizeof(u64);\n\tif (ubase_size < sz) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tkinfo = kzalloc(sizeof(*kinfo), GFP_KERNEL);\n\tif (kinfo == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = dd->f_get_base_info(rcd, kinfo);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\tkinfo->spi_rcvhdr_cnt = dd->rcvhdrcnt;\n\tkinfo->spi_rcvhdrent_size = dd->rcvhdrentsize;\n\tkinfo->spi_tidegrcnt = rcd->rcvegrcnt;\n\tkinfo->spi_rcv_egrbufsize = dd->rcvegrbufsize;\n\t/*\n\t * have to mmap whole thing\n\t */\n\tkinfo->spi_rcv_egrbuftotlen =\n\t\trcd->rcvegrbuf_chunks * rcd->rcvegrbuf_size;\n\tkinfo->spi_rcv_egrperchunk = rcd->rcvegrbufs_perchunk;\n\tkinfo->spi_rcv_egrchunksize = kinfo->spi_rcv_egrbuftotlen /\n\t\trcd->rcvegrbuf_chunks;\n\tkinfo->spi_tidcnt = dd->rcvtidcnt / subctxt_cnt;\n\tif (master)\n\t\tkinfo->spi_tidcnt += dd->rcvtidcnt % subctxt_cnt;\n\t/*\n\t * for this use, may be cfgctxts summed over all chips that\n\t * are are configured and present\n\t */\n\tkinfo->spi_nctxts = dd->cfgctxts;\n\t/* unit (chip/board) our context is on */\n\tkinfo->spi_unit = dd->unit;\n\tkinfo->spi_port = ppd->port;\n\t/* for now, only a single page */\n\tkinfo->spi_tid_maxsize = PAGE_SIZE;\n\n\t/*\n\t * Doing this per context, and based on the skip value, etc.  This has\n\t * to be the actual buffer size, since the protocol code treats it\n\t * as an array.\n\t *\n\t * These have to be set to user addresses in the user code via mmap.\n\t * These values are used on return to user code for the mmap target\n\t * addresses only.  For 32 bit, same 44 bit address problem, so use\n\t * the physical address, not virtual.  Before 2.6.11, using the\n\t * page_address() macro worked, but in 2.6.11, even that returns the\n\t * full 64 bit address (upper bits all 1's).  So far, using the\n\t * physical addresses (or chip offsets, for chip mapping) works, but\n\t * no doubt some future kernel release will change that, and we'll be\n\t * on to yet another method of dealing with this.\n\t * Normally only one of rcvhdr_tailaddr or rhf_offset is useful\n\t * since the chips with non-zero rhf_offset don't normally\n\t * enable tail register updates to host memory, but for testing,\n\t * both can be enabled and used.\n\t */\n\tkinfo->spi_rcvhdr_base = (u64) rcd->rcvhdrq_phys;\n\tkinfo->spi_rcvhdr_tailaddr = (u64) rcd->rcvhdrqtailaddr_phys;\n\tkinfo->spi_rhf_offset = dd->rhf_offset;\n\tkinfo->spi_rcv_egrbufs = (u64) rcd->rcvegr_phys;\n\tkinfo->spi_pioavailaddr = (u64) dd->pioavailregs_phys;\n\t/* setup per-unit (not port) status area for user programs */\n\tkinfo->spi_status = (u64) kinfo->spi_pioavailaddr +\n\t\t(char *) ppd->statusp -\n\t\t(char *) dd->pioavailregs_dma;\n\tkinfo->spi_uregbase = (u64) dd->uregbase + dd->ureg_align * rcd->ctxt;\n\tif (!shared) {\n\t\tkinfo->spi_piocnt = rcd->piocnt;\n\t\tkinfo->spi_piobufbase = (u64) rcd->piobufs;\n\t\tkinfo->spi_sendbuf_status = cvt_kvaddr(rcd->user_event_mask);\n\t} else if (master) {\n\t\tkinfo->spi_piocnt = (rcd->piocnt / subctxt_cnt) +\n\t\t\t\t    (rcd->piocnt % subctxt_cnt);\n\t\t/* Master's PIO buffers are after all the slave's */\n\t\tkinfo->spi_piobufbase = (u64) rcd->piobufs +\n\t\t\tdd->palign *\n\t\t\t(rcd->piocnt - kinfo->spi_piocnt);\n\t} else {\n\t\tunsigned slave = subctxt_fp(fp) - 1;\n\n\t\tkinfo->spi_piocnt = rcd->piocnt / subctxt_cnt;\n\t\tkinfo->spi_piobufbase = (u64) rcd->piobufs +\n\t\t\tdd->palign * kinfo->spi_piocnt * slave;\n\t}\n\n\tif (shared) {\n\t\tkinfo->spi_sendbuf_status =\n\t\t\tcvt_kvaddr(&rcd->user_event_mask[subctxt_fp(fp)]);\n\t\t/* only spi_subctxt_* fields should be set in this block! */\n\t\tkinfo->spi_subctxt_uregbase = cvt_kvaddr(rcd->subctxt_uregbase);\n\n\t\tkinfo->spi_subctxt_rcvegrbuf =\n\t\t\tcvt_kvaddr(rcd->subctxt_rcvegrbuf);\n\t\tkinfo->spi_subctxt_rcvhdr_base =\n\t\t\tcvt_kvaddr(rcd->subctxt_rcvhdr_base);\n\t}\n\n\t/*\n\t * All user buffers are 2KB buffers.  If we ever support\n\t * giving 4KB buffers to user processes, this will need some\n\t * work.  Can't use piobufbase directly, because it has\n\t * both 2K and 4K buffer base values.\n\t */\n\tkinfo->spi_pioindex = (kinfo->spi_piobufbase - dd->pio2k_bufbase) /\n\t\tdd->palign;\n\tkinfo->spi_pioalign = dd->palign;\n\tkinfo->spi_qpair = QIB_KD_QP;\n\t/*\n\t * user mode PIO buffers are always 2KB, even when 4KB can\n\t * be received, and sent via the kernel; this is ibmaxlen\n\t * for 2K MTU.\n\t */\n\tkinfo->spi_piosize = dd->piosize2k - 2 * sizeof(u32);\n\tkinfo->spi_mtu = ppd->ibmaxlen; /* maxlen, not ibmtu */\n\tkinfo->spi_ctxt = rcd->ctxt;\n\tkinfo->spi_subctxt = subctxt_fp(fp);\n\tkinfo->spi_sw_version = QIB_KERN_SWVERSION;\n\tkinfo->spi_sw_version |= 1U << 31; /* QLogic-built, not kernel.org */\n\tkinfo->spi_hw_version = dd->revision;\n\n\tif (master)\n\t\tkinfo->spi_runtime_flags |= QIB_RUNTIME_MASTER;\n\n\tsz = (ubase_size < sizeof(*kinfo)) ? ubase_size : sizeof(*kinfo);\n\tif (copy_to_user(ubase, kinfo, sz))\n\t\tret = -EFAULT;\nbail:\n\tkfree(kinfo);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 52938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char* FileDialog(BOOL save, char* path, const ext_t* ext, DWORD options)\n{\n\tDWORD tmp;\n\tOPENFILENAMEA ofn;\n\tchar selected_name[MAX_PATH];\n\tchar *ext_string = NULL, *all_files = NULL;\n\tsize_t i, j, ext_strlen;\n\tBOOL r;\n\tchar* filepath = NULL;\n\tHRESULT hr = FALSE;\n\tIFileDialog *pfd = NULL;\n\tIShellItem *psiResult;\n\tCOMDLG_FILTERSPEC* filter_spec = NULL;\n\twchar_t *wpath = NULL, *wfilename = NULL;\n\tIShellItem *si_path = NULL;\t// Automatically freed\n\n\tif ((ext == NULL) || (ext->count == 0) || (ext->extension == NULL) || (ext->description == NULL))\n\t\treturn NULL;\n\tdialog_showing++;\n\n\tif (nWindowsVersion >= WINDOWS_VISTA) {\n\t\tINIT_VISTA_SHELL32;\n\t\tfilter_spec = (COMDLG_FILTERSPEC*)calloc(ext->count + 1, sizeof(COMDLG_FILTERSPEC));\n\t\tif ((IS_VISTA_SHELL32_AVAILABLE) && (filter_spec != NULL)) {\n\t\t\tfor (i = 0; i < ext->count; i++) {\n\t\t\t\tfilter_spec[i].pszSpec = utf8_to_wchar(ext->extension[i]);\n\t\t\t\tfilter_spec[i].pszName = utf8_to_wchar(ext->description[i]);\n\t\t\t}\n\t\t\tfilter_spec[i].pszSpec = L\"*.*\";\n\t\t\tfilter_spec[i].pszName = utf8_to_wchar(lmprintf(MSG_107));\n\n\t\t\thr = CoCreateInstance(save ? &CLSID_FileSaveDialog : &CLSID_FileOpenDialog, NULL, CLSCTX_INPROC,\n\t\t\t\t&IID_IFileDialog, (LPVOID)&pfd);\n\n\t\t\tif (FAILED(hr)) {\n\t\t\t\tSetLastError(hr);\n\t\t\t\tuprintf(\"CoCreateInstance for FileOpenDialog failed: %s\\n\", WindowsErrorString());\n\t\t\t\tpfd = NULL;\t// Just in case\n\t\t\t\tgoto fallback;\n\t\t\t}\n\n\t\t\tpfd->lpVtbl->SetFileTypes(pfd, (UINT)ext->count + 1, filter_spec);\n\n\t\t\twpath = utf8_to_wchar(path);\n\t\t\thr = (*pfSHCreateItemFromParsingName)(wpath, NULL, &IID_IShellItem, (LPVOID)&si_path);\n\t\t\tif (SUCCEEDED(hr)) {\n\t\t\t\tpfd->lpVtbl->SetFolder(pfd, si_path);\n\t\t\t}\n\t\t\tsafe_free(wpath);\n\n\t\t\twfilename = utf8_to_wchar((ext->filename == NULL) ? \"\" : ext->filename);\n\t\t\tif (wfilename != NULL) {\n\t\t\t\tpfd->lpVtbl->SetFileName(pfd, wfilename);\n\t\t\t}\n\n\t\t\thr = pfd->lpVtbl->Show(pfd, hMainDialog);\n\n\t\t\tsafe_free(wfilename);\n\t\t\tfor (i = 0; i < ext->count; i++) {\n\t\t\t\tsafe_free(filter_spec[i].pszSpec);\n\t\t\t\tsafe_free(filter_spec[i].pszName);\n\t\t\t}\n\t\t\tsafe_free(filter_spec[i].pszName);\n\t\t\tsafe_free(filter_spec);\n\n\t\t\tif (SUCCEEDED(hr)) {\n\t\t\t\thr = pfd->lpVtbl->GetResult(pfd, &psiResult);\n\t\t\t\tif (SUCCEEDED(hr)) {\n\t\t\t\t\thr = psiResult->lpVtbl->GetDisplayName(psiResult, SIGDN_FILESYSPATH, &wpath);\n\t\t\t\t\tif (SUCCEEDED(hr)) {\n\t\t\t\t\t\tfilepath = wchar_to_utf8(wpath);\n\t\t\t\t\t\tCoTaskMemFree(wpath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSetLastError(hr);\n\t\t\t\t\t\tuprintf(\"Unable to access file path: %s\\n\", WindowsErrorString());\n\t\t\t\t\t}\n\t\t\t\t\tpsiResult->lpVtbl->Release(psiResult);\n\t\t\t\t}\n\t\t\t} else if ((hr & 0xFFFF) != ERROR_CANCELLED) {\n\t\t\t\tSetLastError(hr);\n\t\t\t\tuprintf(\"Could not show FileOpenDialog: %s\\n\", WindowsErrorString());\n\t\t\t\tgoto fallback;\n\t\t\t}\n\t\t\tpfd->lpVtbl->Release(pfd);\n\t\t\tdialog_showing--;\n\t\t\treturn filepath;\n\t\t}\n\tfallback:\n\t\tsafe_free(filter_spec);\n\t\tif (pfd != NULL) {\n\t\t\tpfd->lpVtbl->Release(pfd);\n\t\t}\n\t}\n\n\tmemset(&ofn, 0, sizeof(ofn));\n\tofn.lStructSize = sizeof(ofn);\n\tofn.hwndOwner = hMainDialog;\n\tstatic_sprintf(selected_name, \"%s\", (ext->filename == NULL)?\"\":ext->filename);\n\tofn.lpstrFile = selected_name;\n\tofn.nMaxFile = MAX_PATH;\n\tall_files = lmprintf(MSG_107);\n\text_strlen = 0;\n\tfor (i=0; i<ext->count; i++) {\n\t\text_strlen += safe_strlen(ext->description[i]) + 2*safe_strlen(ext->extension[i]) + sizeof(\" ()\\r\\r\");\n\t}\n\text_strlen += safe_strlen(all_files) + sizeof(\" (*.*)\\r*.*\\r\");\n\text_string = (char*)malloc(ext_strlen+1);\n\tif (ext_string == NULL)\n\t\treturn NULL;\n\text_string[0] = 0;\n\tfor (i=0, j=0; i<ext->count; i++) {\n\t\tj += _snprintf(&ext_string[j], ext_strlen-j, \"%s (%s)\\r%s\\r\", ext->description[i], ext->extension[i], ext->extension[i]);\n\t}\n\tj = _snprintf(&ext_string[j], ext_strlen-j, \"%s (*.*)\\r*.*\\r\", all_files);\n\tfor (i=0; i<ext_strlen; i++) {\n#if defined(_MSC_VER)\n#pragma warning(suppress: 6385)\n#endif\n\t\tif (ext_string[i] == '\\r') {\n#if defined(_MSC_VER)\n#pragma warning(suppress: 6386)\n#endif\n\t\t\text_string[i] = 0;\n\t\t}\n\t}\n\tofn.lpstrFilter = ext_string;\n\tofn.nFilterIndex = 1;\n\tofn.lpstrInitialDir = path;\n\tofn.Flags = OFN_OVERWRITEPROMPT | options;\n\tif (save) {\n\t\tr = GetSaveFileNameU(&ofn);\n\t} else {\n\t\tr = GetOpenFileNameU(&ofn);\n\t}\n\tif (r) {\n\t\tfilepath = safe_strdup(selected_name);\n\t} else {\n\t\ttmp = CommDlgExtendedError();\n\t\tif (tmp != 0) {\n\t\t\tuprintf(\"Could not select file for %s. Error %X\\n\", save?\"save\":\"open\", tmp);\n\t\t}\n\t}\n\tsafe_free(ext_string);\n\tdialog_showing--;\n\treturn filepath;\n}\n",
        "output": "0",
        "index": 62185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssl_decrypt_buf( ssl_context *ssl )\n{\n    size_t i, padlen = 0, correct = 1;\n    unsigned char tmp[POLARSSL_SSL_MAX_MAC_SIZE];\n\n    SSL_DEBUG_MSG( 2, ( \"=> decrypt buf\" ) );\n\n    if( ssl->in_msglen < ssl->transform_in->minlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"in_msglen (%d) < minlen (%d)\",\n                       ssl->in_msglen, ssl->transform_in->minlen ) );\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n    }\n\n    if( ssl->transform_in->ivlen == 0 )\n    {\n#if defined(POLARSSL_ARC4_C)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_RC4_128_MD5 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_RC4_128_SHA )\n        {\n            arc4_crypt( (arc4_context *) ssl->transform_in->ctx_dec,\n                    ssl->in_msglen, ssl->in_msg,\n                    ssl->in_msg );\n        } else\n#endif\n#if defined(POLARSSL_CIPHER_NULL_CIPHER)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_MD5 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_SHA ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_NULL_SHA256 )\n        {\n        } else\n#endif\n        return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n    else if( ssl->transform_in->ivlen == 12 )\n    {\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        unsigned char add_data[13];\n        int ret = POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE;\n\n#if defined(POLARSSL_AES_C) && defined(POLARSSL_GCM_C)\n        if( ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_GCM_SHA384 ||\n            ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ||\n            ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 )\n        {\n            dec_msglen = ssl->in_msglen - ( ssl->transform_in->ivlen -\n                                            ssl->transform_in->fixed_ivlen );\n            dec_msglen -= 16;\n            dec_msg = ssl->in_msg + ( ssl->transform_in->ivlen -\n                                      ssl->transform_in->fixed_ivlen );\n            dec_msg_result = ssl->in_msg;\n            ssl->in_msglen = dec_msglen;\n\n            memcpy( add_data, ssl->in_ctr, 8 );\n            add_data[8]  = ssl->in_msgtype;\n            add_data[9]  = ssl->major_ver;\n            add_data[10] = ssl->minor_ver;\n            add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;\n            add_data[12] = ssl->in_msglen & 0xFF;\n\n            SSL_DEBUG_BUF( 4, \"additional data used for AEAD\",\n                           add_data, 13 );\n\n            memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,\n                    ssl->in_msg,\n                    ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );\n\n            SSL_DEBUG_BUF( 4, \"IV used\", ssl->transform_in->iv_dec,\n                                         ssl->transform_in->ivlen );\n            SSL_DEBUG_BUF( 4, \"TAG used\", dec_msg + dec_msglen, 16 );\n\n            memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,\n                    ssl->in_msg,\n                    ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );\n\n            ret = gcm_auth_decrypt( (gcm_context *) ssl->transform_in->ctx_dec,\n                                     dec_msglen,\n                                     ssl->transform_in->iv_dec,\n                                     ssl->transform_in->ivlen,\n                                     add_data, 13,\n                                     dec_msg + dec_msglen, 16,\n                                     dec_msg, dec_msg_result );\n            \n            if( ret != 0 )\n            {\n                SSL_DEBUG_MSG( 1, ( \"AEAD decrypt failed on validation (ret = -0x%02x)\",\n                                    -ret ) );\n\n                return( POLARSSL_ERR_SSL_INVALID_MAC );\n            }\n        } else\n#endif\n        return( ret );\n    }\n    else\n    {\n        /*\n         * Decrypt and check the padding\n         */\n        unsigned char *dec_msg;\n        unsigned char *dec_msg_result;\n        size_t dec_msglen;\n        size_t minlen = 0;\n\n        /*\n         * Check immediate ciphertext sanity\n         */\n        if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) %% ivlen (%d) != 0\",\n                           ssl->in_msglen, ssl->transform_in->ivlen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n            minlen += ssl->transform_in->ivlen;\n\n        if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||\n            ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) < max( ivlen(%d), maclen (%d) + 1 ) ( + expl IV )\",\n                           ssl->in_msglen, ssl->transform_in->ivlen, ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n\n        dec_msglen = ssl->in_msglen;\n        dec_msg = ssl->in_msg;\n        dec_msg_result = ssl->in_msg;\n\n        /*\n         * Initialize for prepended IV for block cipher in TLS v1.1 and up\n         */\n        if( ssl->minor_ver >= SSL_MINOR_VERSION_2 )\n        {\n            dec_msg += ssl->transform_in->ivlen;\n            dec_msglen -= ssl->transform_in->ivlen;\n            ssl->in_msglen -= ssl->transform_in->ivlen;\n\n            for( i = 0; i < ssl->transform_in->ivlen; i++ )\n                ssl->transform_in->iv_dec[i] = ssl->in_msg[i];\n        }\n\n        switch( ssl->transform_in->ivlen )\n        {\n#if defined(POLARSSL_DES_C)\n            case  8:\n#if defined(POLARSSL_ENABLE_WEAK_CIPHERSUITES)\n                if( ssl->session_in->ciphersuite == TLS_RSA_WITH_DES_CBC_SHA ||\n                    ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_DES_CBC_SHA )\n                {\n                    des_crypt_cbc( (des_context *) ssl->transform_in->ctx_dec,\n                                   DES_DECRYPT, dec_msglen,\n                                   ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                }\n                else\n#endif\n                    des3_crypt_cbc( (des3_context *) ssl->transform_in->ctx_dec,\n                        DES_DECRYPT, dec_msglen,\n                        ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                break;\n#endif\n\n            case 16:\n#if defined(POLARSSL_AES_C)\n        if ( ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_AES_256_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 )\n        {\n                    aes_crypt_cbc( (aes_context *) ssl->transform_in->ctx_dec,\n                       AES_DECRYPT, dec_msglen,\n                       ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                    break;\n        }\n#endif\n\n#if defined(POLARSSL_CAMELLIA_C)\n        if ( ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 ||\n             ssl->session_in->ciphersuite == TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 )\n        {\n                    camellia_crypt_cbc( (camellia_context *) ssl->transform_in->ctx_dec,\n                       CAMELLIA_DECRYPT, dec_msglen,\n                       ssl->transform_in->iv_dec, dec_msg, dec_msg_result );\n                    break;\n        }\n#endif\n\n            default:\n                return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n\n        padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];\n\n        if( ssl->in_msglen < ssl->transform_in->maclen + padlen )\n        {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            SSL_DEBUG_MSG( 1, ( \"msglen (%d) < maclen (%d) + padlen (%d)\",\n                        ssl->in_msglen, ssl->transform_in->maclen, padlen ) );\n#endif\n            padlen = 0;\n            correct = 0;\n        }\n\n        if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n        {\n            if( padlen > ssl->transform_in->ivlen )\n            {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n                SSL_DEBUG_MSG( 1, ( \"bad padding length: is %d, \"\n                                    \"should be no more than %d\",\n                               padlen, ssl->transform_in->ivlen ) );\n#endif\n                correct = 0;\n            }\n        }\n        else\n        {\n            /*\n             * TLSv1+: always check the padding up to the first failure\n             * and fake check up to 256 bytes of padding\n             */\n            size_t pad_count = 0, fake_pad_count = 0;\n            size_t padding_idx = ssl->in_msglen - padlen - 1;\n\n            for( i = 1; i <= padlen; i++ )\n                pad_count += ( ssl->in_msg[padding_idx + i] == padlen - 1 );\n\n            for( ; i <= 256; i++ )\n                fake_pad_count += ( ssl->in_msg[padding_idx + i] == padlen - 1 );\n\n            correct &= ( pad_count == padlen ); /* Only 1 on correct padding */\n            correct &= ( pad_count + fake_pad_count < 512 ); /* Always 1 */\n\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n            if( padlen > 0 && correct == 0)\n                SSL_DEBUG_MSG( 1, ( \"bad padding byte detected\" ) );\n#endif\n            padlen &= correct * 0x1FF;\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"raw buffer after decryption\",\n                   ssl->in_msg, ssl->in_msglen );\n\n    /*\n     * Always compute the MAC (RFC4346, CBCTIME).\n     */\n    ssl->in_msglen -= ( ssl->transform_in->maclen + padlen );\n\n    ssl->in_hdr[3] = (unsigned char)( ssl->in_msglen >> 8 );\n    ssl->in_hdr[4] = (unsigned char)( ssl->in_msglen      );\n\n    memcpy( tmp, ssl->in_msg + ssl->in_msglen, ssl->transform_in->maclen );\n\n    if( ssl->minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        if( ssl->transform_in->maclen == 16 )\n             ssl_mac_md5( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen == 20 )\n            ssl_mac_sha1( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen == 32 )\n            ssl_mac_sha2( ssl->transform_in->mac_dec,\n                          ssl->in_msg, ssl->in_msglen,\n                          ssl->in_ctr, ssl->in_msgtype );\n        else if( ssl->transform_in->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n    else\n    {\n        /*\n         * Process MAC and always update for padlen afterwards to make\n         * total time independent of padlen\n         *\n         * extra_run compensates MAC check for padlen \n         *\n         * Known timing attacks:\n         *  - Lucky Thirteen (http://www.isg.rhul.ac.uk/tls/TLStiming.pdf)\n         *\n         * We use ( ( Lx + 8 ) / 64 ) to handle 'negative Lx' values\n         * correctly. (We round down instead of up, so -56 is the correct\n         * value for our calculations instead of -55)\n         */\n        int j, extra_run = 0;\n        extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -\n                    ( 13 + ssl->in_msglen          + 8 ) / 64;\n\n        extra_run &= correct * 0xFF;\n\n        if( ssl->transform_in->maclen == 16 )\n        {\n            md5_context ctx;\n            md5_hmac_starts( &ctx, ssl->transform_in->mac_dec, 16 );\n            md5_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            md5_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                md5_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen == 20 )\n        {\n            sha1_context ctx;\n            sha1_hmac_starts( &ctx, ssl->transform_in->mac_dec, 20 );\n            sha1_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            sha1_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                sha1_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen == 32 )\n        {\n            sha2_context ctx;\n            sha2_hmac_starts( &ctx, ssl->transform_in->mac_dec, 32, 0 );\n            sha2_hmac_update( &ctx, ssl->in_ctr,  ssl->in_msglen + 13 );\n            sha2_hmac_finish( &ctx, ssl->in_msg + ssl->in_msglen );\n\n            for( j = 0; j < extra_run; j++ )\n                sha2_process( &ctx, ssl->in_msg ); \n        }\n        else if( ssl->transform_in->maclen != 0 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"invalid MAC len: %d\",\n                                ssl->transform_in->maclen ) );\n            return( POLARSSL_ERR_SSL_FEATURE_UNAVAILABLE );\n        }\n    }\n\n    SSL_DEBUG_BUF( 4, \"message  mac\", tmp, ssl->transform_in->maclen );\n    SSL_DEBUG_BUF( 4, \"computed mac\", ssl->in_msg + ssl->in_msglen,\n                   ssl->transform_in->maclen );\n\n    if( memcmp( tmp, ssl->in_msg + ssl->in_msglen,\n                     ssl->transform_in->maclen ) != 0 )\n    {\n#if defined(POLARSSL_SSL_DEBUG_ALL)\n        SSL_DEBUG_MSG( 1, ( \"message mac does not match\" ) );\n#endif\n        correct = 0;\n    }\n\n    /*\n     * Finally check the correct flag\n     */\n    if( correct == 0 )\n        return( POLARSSL_ERR_SSL_INVALID_MAC );\n\n    if( ssl->in_msglen == 0 )\n    {\n        ssl->nb_zero++;\n\n        /*\n         * Three or more empty messages may be a DoS attack\n         * (excessive CPU consumption).\n         */\n        if( ssl->nb_zero > 3 )\n        {\n            SSL_DEBUG_MSG( 1, ( \"received four consecutive empty \"\n                                \"messages, possible DoS attack\" ) );\n            return( POLARSSL_ERR_SSL_INVALID_MAC );\n        }\n    }\n    else\n        ssl->nb_zero = 0;\n            \n    for( i = 8; i > 0; i-- )\n        if( ++ssl->in_ctr[i - 1] != 0 )\n            break;\n\n    SSL_DEBUG_MSG( 2, ( \"<= decrypt buf\" ) );\n\n    return( 0 );\n}\n",
        "output": "0",
        "index": 28991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType WritePNGImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    excluding,\n    logging,\n    status;\n\n  MngInfo\n    *mng_info;\n\n  const char\n    *value;\n\n  int\n    source;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\"Enter WritePNGImage()\");\n  /*\n    Allocate a MngInfo structure.\n  */\n  mng_info=(MngInfo *) AcquireMagickMemory(sizeof(MngInfo));\n\n  if (mng_info == (MngInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /*\n    Initialize members of the MngInfo structure.\n  */\n  (void) memset(mng_info,0,sizeof(MngInfo));\n  mng_info->image=image;\n  mng_info->equal_backgrounds=MagickTrue;\n\n  /* See if user has requested a specific PNG subformat */\n\n  mng_info->write_png8=LocaleCompare(image_info->magick,\"PNG8\") == 0;\n  mng_info->write_png24=LocaleCompare(image_info->magick,\"PNG24\") == 0;\n  mng_info->write_png32=LocaleCompare(image_info->magick,\"PNG32\") == 0;\n  mng_info->write_png48=LocaleCompare(image_info->magick,\"PNG48\") == 0;\n  mng_info->write_png64=LocaleCompare(image_info->magick,\"PNG64\") == 0;\n\n  value=GetImageOption(image_info,\"png:format\");\n\n  if (value != (char *) NULL || LocaleCompare(image_info->magick,\"PNG00\") == 0)\n    {\n      mng_info->write_png8 = MagickFalse;\n      mng_info->write_png24 = MagickFalse;\n      mng_info->write_png32 = MagickFalse;\n      mng_info->write_png48 = MagickFalse;\n      mng_info->write_png64 = MagickFalse;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",value);\n\n      if (LocaleCompare(value,\"png8\") == 0)\n        mng_info->write_png8 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png24\") == 0)\n        mng_info->write_png24 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png32\") == 0)\n        mng_info->write_png32 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png48\") == 0)\n        mng_info->write_png48 = MagickTrue;\n\n      else if (LocaleCompare(value,\"png64\") == 0)\n        mng_info->write_png64 = MagickTrue;\n\n      else if ((LocaleCompare(value,\"png00\") == 0) ||\n         LocaleCompare(image_info->magick,\"PNG00\") == 0)\n        {\n          /* Retrieve png:IHDR.bit-depth-orig and png:IHDR.color-type-orig */\n          value=GetImageProperty(image,\"png:IHDR.bit-depth-orig\");\n\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  png00 inherited bit depth=%s\",value);\n\n          if (value != (char *) NULL)\n          {\n\n            if (LocaleCompare(value,\"1\") == 0)\n              mng_info->write_png_depth = 1;\n\n            else if (LocaleCompare(value,\"2\") == 0)\n              mng_info->write_png_depth = 2;\n\n            else if (LocaleCompare(value,\"4\") == 0)\n              mng_info->write_png_depth = 4;\n\n            else if (LocaleCompare(value,\"8\") == 0)\n              mng_info->write_png_depth = 8;\n\n            else if (LocaleCompare(value,\"16\") == 0)\n              mng_info->write_png_depth = 16;\n          }\n\n          value=GetImageProperty(image,\"png:IHDR.color-type-orig\");\n\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  png00 inherited color type=%s\",value);\n\n          if (value != (char *) NULL)\n          {\n            if (LocaleCompare(value,\"0\") == 0)\n              mng_info->write_png_colortype = 1;\n\n            else if (LocaleCompare(value,\"2\") == 0)\n              mng_info->write_png_colortype = 3;\n\n            else if (LocaleCompare(value,\"3\") == 0)\n              mng_info->write_png_colortype = 4;\n\n            else if (LocaleCompare(value,\"4\") == 0)\n              mng_info->write_png_colortype = 5;\n\n            else if (LocaleCompare(value,\"6\") == 0)\n              mng_info->write_png_colortype = 7;\n          }\n        }\n    }\n\n  if (mng_info->write_png8)\n    {\n      mng_info->write_png_colortype = /* 3 */ 4;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n    }\n\n  if (mng_info->write_png24)\n    {\n      mng_info->write_png_colortype = /* 2 */ 3;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n\n      if (image->matte != MagickFalse)\n        (void) SetImageType(image,TrueColorMatteType);\n\n      else\n        (void) SetImageType(image,TrueColorType);\n\n      (void) SyncImage(image);\n    }\n\n  if (mng_info->write_png32)\n    {\n      mng_info->write_png_colortype = /* 6 */  7;\n      mng_info->write_png_depth = 8;\n      image->depth = 8;\n      image->matte = MagickTrue;\n      (void) SetImageType(image,TrueColorMatteType);\n      (void) SyncImage(image);\n    }\n\n  if (mng_info->write_png48)\n    {\n      mng_info->write_png_colortype = /* 2 */ 3;\n      mng_info->write_png_depth = 16;\n      image->depth = 16;\n\n      if (image->matte != MagickFalse)\n        (void) SetImageType(image,TrueColorMatteType);\n\n      else\n        (void) SetImageType(image,TrueColorType);\n\n      (void) SyncImage(image);\n    }\n\n  if (mng_info->write_png64)\n    {\n      mng_info->write_png_colortype = /* 6 */  7;\n      mng_info->write_png_depth = 16;\n      image->depth = 16;\n      image->matte = MagickTrue;\n      (void) SetImageType(image,TrueColorMatteType);\n      (void) SyncImage(image);\n    }\n\n  value=GetImageOption(image_info,\"png:bit-depth\");\n\n  if (value != (char *) NULL)\n    {\n      if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_depth = 1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_depth = 2;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_depth = 4;\n\n      else if (LocaleCompare(value,\"8\") == 0)\n        mng_info->write_png_depth = 8;\n\n      else if (LocaleCompare(value,\"16\") == 0)\n        mng_info->write_png_depth = 16;\n\n      else\n        (void) ThrowMagickException(&image->exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:bit-depth\",\n             \"=%s\",value);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  png:bit-depth=%d was defined.\\n\",mng_info->write_png_depth);\n    }\n\n  value=GetImageOption(image_info,\"png:color-type\");\n\n  if (value != (char *) NULL)\n    {\n      /* We must store colortype+1 because 0 is a valid colortype */\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_colortype = 1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_colortype = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_colortype = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_colortype = 5;\n\n      else if (LocaleCompare(value,\"6\") == 0)\n        mng_info->write_png_colortype = 7;\n\n      else\n        (void) ThrowMagickException(&image->exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:color-type\",\n             \"=%s\",value);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  png:color-type=%d was defined.\\n\",mng_info->write_png_colortype-1);\n    }\n\n  /* Check for chunks to be excluded:\n   *\n   * The default is to not exclude any known chunks except for any\n   * listed in the \"unused_chunks\" array, above.\n   *\n   * Chunks can be listed for exclusion via a \"png:exclude-chunk\"\n   * define (in the image properties or in the image artifacts)\n   * or via a mng_info member.  For convenience, in addition\n   * to or instead of a comma-separated list of chunks, the\n   * \"exclude-chunk\" string can be simply \"all\" or \"none\".\n   *\n   * The exclude-chunk define takes priority over the mng_info.\n   *\n   * A \"png:include-chunk\" define takes  priority over both the\n   * mng_info and the \"png:exclude-chunk\" define.  Like the\n   * \"exclude-chunk\" string, it can define \"all\" or \"none\" as\n   * well as a comma-separated list.  Chunks that are unknown to\n   * ImageMagick are always excluded, regardless of their \"copy-safe\"\n   * status according to the PNG specification, and even if they\n   * appear in the \"include-chunk\" list. Such defines appearing among\n   * the image options take priority over those found among the image\n   * artifacts.\n   *\n   * Finally, all chunks listed in the \"unused_chunks\" array are\n   * automatically excluded, regardless of the other instructions\n   * or lack thereof.\n   *\n   * if you exclude sRGB but not gAMA (recommended), then sRGB chunk\n   * will not be written and the gAMA chunk will only be written if it\n   * is not between .45 and .46, or approximately (1.0/2.2).\n   *\n   * If you exclude tRNS and the image has transparency, the colortype\n   * is forced to be 4 or 6 (GRAY_ALPHA or RGB_ALPHA).\n   *\n   * The -strip option causes StripImage() to set the png:include-chunk\n   * artifact to \"none,trns,gama\".\n   */\n\n  mng_info->ping_exclude_bKGD=MagickFalse;\n  mng_info->ping_exclude_caNv=MagickFalse;\n  mng_info->ping_exclude_cHRM=MagickFalse;\n  mng_info->ping_exclude_date=MagickFalse;\n  mng_info->ping_exclude_eXIf=MagickFalse;\n  mng_info->ping_exclude_EXIF=MagickFalse; /* hex-encoded EXIF in zTXt */\n  mng_info->ping_exclude_gAMA=MagickFalse;\n  mng_info->ping_exclude_iCCP=MagickFalse;\n  /* mng_info->ping_exclude_iTXt=MagickFalse; */\n  mng_info->ping_exclude_oFFs=MagickFalse;\n  mng_info->ping_exclude_pHYs=MagickFalse;\n  mng_info->ping_exclude_sRGB=MagickFalse;\n  mng_info->ping_exclude_tEXt=MagickFalse;\n  mng_info->ping_exclude_tIME=MagickFalse;\n  mng_info->ping_exclude_tRNS=MagickFalse;\n  mng_info->ping_exclude_zCCP=MagickFalse; /* hex-encoded iCCP in zTXt */\n  mng_info->ping_exclude_zTXt=MagickFalse;\n\n  mng_info->ping_preserve_colormap=MagickFalse;\n\n  value=GetImageOption(image_info,\"png:preserve-colormap\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:preserve-colormap\");\n  if (value != NULL)\n     mng_info->ping_preserve_colormap=MagickTrue;\n\n\n  mng_info->ping_preserve_iCCP=MagickFalse;\n\n  value=GetImageOption(image_info,\"png:preserve-iCCP\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:preserve-iCCP\");\n  if (value != NULL)\n     mng_info->ping_preserve_iCCP=MagickTrue;\n\n  /* These compression-level, compression-strategy, and compression-filter\n   * defines take precedence over values from the -quality option.\n   */\n  value=GetImageOption(image_info,\"png:compression-level\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-level\");\n  if (value != NULL)\n  {\n      /* To do: use a \"LocaleInteger:()\" function here. */\n\n      /* We have to add 1 to everything because 0 is a valid input,\n       * and we want to use 0 (the default) to mean undefined.\n       */\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_level = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_level = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_level = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_compression_level = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_compression_level = 5;\n\n      else if (LocaleCompare(value,\"5\") == 0)\n        mng_info->write_png_compression_level = 6;\n\n      else if (LocaleCompare(value,\"6\") == 0)\n        mng_info->write_png_compression_level = 7;\n\n      else if (LocaleCompare(value,\"7\") == 0)\n        mng_info->write_png_compression_level = 8;\n\n      else if (LocaleCompare(value,\"8\") == 0)\n        mng_info->write_png_compression_level = 9;\n\n      else if (LocaleCompare(value,\"9\") == 0)\n        mng_info->write_png_compression_level = 10;\n\n      else\n        (void) ThrowMagickException(&image->exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-level\",\n             \"=%s\",value);\n    }\n\n  value=GetImageOption(image_info,\"png:compression-strategy\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-strategy\");\n  if (value != NULL)\n  {\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_strategy = Z_FILTERED+1;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n#ifdef Z_RLE  /* Z_RLE was added to zlib-1.2.0 */\n        mng_info->write_png_compression_strategy = Z_RLE+1;\n#else\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n\n      else if (LocaleCompare(value,\"4\") == 0)\n#ifdef Z_FIXED  /* Z_FIXED was added to zlib-1.2.2.2 */\n        mng_info->write_png_compression_strategy = Z_FIXED+1;\n#else\n        mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;\n#endif\n\n      else\n        (void) ThrowMagickException(&image->exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-strategy\",\n             \"=%s\",value);\n    }\n\n  value=GetImageOption(image_info,\"png:compression-filter\");\n  if (value == NULL)\n     value=GetImageArtifact(image,\"png:compression-filter\");\n  if (value != NULL)\n  {\n      /* To do: combinations of filters allowed by libpng\n       * masks 0x08 through 0xf8\n       *\n       * Implement this as a comma-separated list of 0,1,2,3,4,5\n       * where 5 is a special case meaning PNG_ALL_FILTERS.\n       */\n\n      if (LocaleCompare(value,\"0\") == 0)\n        mng_info->write_png_compression_filter = 1;\n\n      else if (LocaleCompare(value,\"1\") == 0)\n        mng_info->write_png_compression_filter = 2;\n\n      else if (LocaleCompare(value,\"2\") == 0)\n        mng_info->write_png_compression_filter = 3;\n\n      else if (LocaleCompare(value,\"3\") == 0)\n        mng_info->write_png_compression_filter = 4;\n\n      else if (LocaleCompare(value,\"4\") == 0)\n        mng_info->write_png_compression_filter = 5;\n\n      else if (LocaleCompare(value,\"5\") == 0)\n        mng_info->write_png_compression_filter = 6;\n\n      else\n        (void) ThrowMagickException(&image->exception,\n             GetMagickModule(),CoderWarning,\n             \"ignoring invalid defined png:compression-filter\",\n             \"=%s\",value);\n    }\n\n  for (source=0; source<8; source++)\n  {\n    value = NULL;\n\n    if (source == 0)\n      value=GetImageOption(image_info,\"png:exclude-chunks\");\n\n    if (source == 1)\n      value=GetImageArtifact(image,\"png:exclude-chunks\");\n\n    if (source == 2)\n      value=GetImageOption(image_info,\"png:exclude-chunk\");\n\n    if (source == 3)\n      value=GetImageArtifact(image,\"png:exclude-chunk\");\n\n    if (source == 4)\n      value=GetImageOption(image_info,\"png:include-chunks\");\n\n    if (source == 5)\n      value=GetImageArtifact(image,\"png:include-chunks\");\n\n    if (source == 6)\n      value=GetImageOption(image_info,\"png:include-chunk\");\n\n    if (source == 7)\n      value=GetImageArtifact(image,\"png:include-chunk\");\n\n    if (value == NULL)\n       continue;\n\n    if (source < 4)\n      excluding = MagickTrue;\n    else\n      excluding = MagickFalse;\n\n    if (logging != MagickFalse)\n      {\n        if (source == 0 || source == 2)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:exclude-chunk=%s found in image options.\\n\", value);\n        else if (source == 1 || source == 3)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:exclude-chunk=%s found in image artifacts.\\n\", value);\n        else if (source == 4 || source == 6)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:include-chunk=%s found in image options.\\n\", value);\n        else /* if (source == 5 || source == 7) */\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  png:include-chunk=%s found in image artifacts.\\n\", value);\n      }\n\n    if (IsOptionMember(\"all\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_bKGD=excluding;\n        mng_info->ping_exclude_caNv=excluding;\n        mng_info->ping_exclude_cHRM=excluding;\n        mng_info->ping_exclude_date=excluding;\n        mng_info->ping_exclude_EXIF=excluding;\n        mng_info->ping_exclude_eXIf=excluding;\n        mng_info->ping_exclude_gAMA=excluding;\n        mng_info->ping_exclude_iCCP=excluding;\n        /* mng_info->ping_exclude_iTXt=excluding; */\n        mng_info->ping_exclude_oFFs=excluding;\n        mng_info->ping_exclude_pHYs=excluding;\n        mng_info->ping_exclude_sRGB=excluding;\n        mng_info->ping_exclude_tIME=excluding;\n        mng_info->ping_exclude_tEXt=excluding;\n        mng_info->ping_exclude_tRNS=excluding;\n        mng_info->ping_exclude_zCCP=excluding;\n        mng_info->ping_exclude_zTXt=excluding;\n      }\n\n    if (IsOptionMember(\"none\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_bKGD=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_caNv=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_cHRM=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_date=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_eXIf=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_EXIF=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_gAMA=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_iCCP=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        /* mng_info->ping_exclude_iTXt=!excluding; */\n        mng_info->ping_exclude_oFFs=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_pHYs=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_sRGB=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tEXt=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tIME=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_tRNS=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_zCCP=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n        mng_info->ping_exclude_zTXt=excluding != MagickFalse ? MagickFalse :\n          MagickTrue;\n      }\n\n    if (IsOptionMember(\"bkgd\",value) != MagickFalse)\n      mng_info->ping_exclude_bKGD=excluding;\n\n    if (IsOptionMember(\"caNv\",value) != MagickFalse)\n      mng_info->ping_exclude_caNv=excluding;\n\n    if (IsOptionMember(\"chrm\",value) != MagickFalse)\n      mng_info->ping_exclude_cHRM=excluding;\n\n    if (IsOptionMember(\"date\",value) != MagickFalse)\n      mng_info->ping_exclude_date=excluding;\n\n    if (IsOptionMember(\"exif\",value) != MagickFalse)\n      {\n        mng_info->ping_exclude_EXIF=excluding;\n        mng_info->ping_exclude_eXIf=excluding;\n      }\n\n    if (IsOptionMember(\"gama\",value) != MagickFalse)\n      mng_info->ping_exclude_gAMA=excluding;\n\n    if (IsOptionMember(\"iccp\",value) != MagickFalse)\n      mng_info->ping_exclude_iCCP=excluding;\n\n#if 0\n    if (IsOptionMember(\"itxt\",value) != MagickFalse)\n      mng_info->ping_exclude_iTXt=excluding;\n#endif\n\n    if (IsOptionMember(\"offs\",value) != MagickFalse)\n      mng_info->ping_exclude_oFFs=excluding;\n\n    if (IsOptionMember(\"phys\",value) != MagickFalse)\n      mng_info->ping_exclude_pHYs=excluding;\n\n    if (IsOptionMember(\"srgb\",value) != MagickFalse)\n      mng_info->ping_exclude_sRGB=excluding;\n\n    if (IsOptionMember(\"text\",value) != MagickFalse)\n      mng_info->ping_exclude_tEXt=excluding;\n\n    if (IsOptionMember(\"time\",value) != MagickFalse)\n      mng_info->ping_exclude_tIME=excluding;\n\n    if (IsOptionMember(\"trns\",value) != MagickFalse)\n      mng_info->ping_exclude_tRNS=excluding;\n\n    if (IsOptionMember(\"zccp\",value) != MagickFalse)\n      mng_info->ping_exclude_zCCP=excluding;\n\n    if (IsOptionMember(\"ztxt\",value) != MagickFalse)\n      mng_info->ping_exclude_zTXt=excluding;\n  }\n\n  if (logging != MagickFalse)\n  {\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Chunks to be excluded from the output png:\");\n    if (mng_info->ping_exclude_bKGD != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    bKGD\");\n    if (mng_info->ping_exclude_caNv != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    caNv\");\n    if (mng_info->ping_exclude_cHRM != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    cHRM\");\n    if (mng_info->ping_exclude_date != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    date\");\n    if (mng_info->ping_exclude_EXIF != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    EXIF\");\n    if (mng_info->ping_exclude_eXIf != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    eXIf\");\n    if (mng_info->ping_exclude_gAMA != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    gAMA\");\n    if (mng_info->ping_exclude_iCCP != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    iCCP\");\n#if 0\n    if (mng_info->ping_exclude_iTXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    iTXt\");\n#endif\n\n    if (mng_info->ping_exclude_oFFs != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    oFFs\");\n    if (mng_info->ping_exclude_pHYs != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    pHYs\");\n    if (mng_info->ping_exclude_sRGB != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    sRGB\");\n    if (mng_info->ping_exclude_tEXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tEXt\");\n    if (mng_info->ping_exclude_tIME != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tIME\");\n    if (mng_info->ping_exclude_tRNS != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    tRNS\");\n    if (mng_info->ping_exclude_zCCP != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    zCCP\");\n    if (mng_info->ping_exclude_zTXt != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    zTXt\");\n  }\n\n  mng_info->need_blob = MagickTrue;\n\n  status=WriteOnePNGImage(mng_info,image_info,image);\n\n  (void) CloseBlob(image);\n\n  mng_info=MngInfoFreeStruct(mng_info);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit WritePNGImage()\");\n\n  return(status);\n}\n",
        "output": "0",
        "index": 77952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n  }\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ((int) ReadBlobLSBLong(image));\n    icon_info.height=(unsigned char) ((int) ReadBlobLSBLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n           Icon image encoded as a compressed PNG image.\n         */\n         length=icon_file.directory[i].size;\n         png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n         if (png == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MagickPathExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->alpha_trait=BlendPixelTrait;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors,exception) ==\n              MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows,exception);\n        if (status == MagickFalse)\n          return(DestroyImageList(image));\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                {\n                  SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :\n                    0x00),q);\n                  q+=GetPixelChannels(image);\n                }\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                  {\n                    SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :\n                      0x00),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(image,((byte >> 4) & 0xf),q);\n                q+=GetPixelChannels(image);\n                SetPixelIndex(image,((byte) & 0xf),q);\n                q+=GetPixelChannels(image);\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(image,((byte >> 4) & 0xf),q);\n                  q+=GetPixelChannels(image);\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(image,byte,q);\n                q+=GetPixelChannels(image);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(image,byte,q);\n                q+=GetPixelChannels(image);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                SetPixelRed(image,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)),q);\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)),q);\n                q+=GetPixelChannels(image);\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if (image_info->ping == MagickFalse)\n          (void) SyncImage(image,exception);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                {\n                  SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentAlpha : OpaqueAlpha),q);\n                  q+=GetPixelChannels(image);\n                }\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                  {\n                    SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentAlpha : OpaqueAlpha),q);\n                    q+=GetPixelChannels(image);\n                  }\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n",
        "output": "1",
        "index": 182035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::HandleReadPixels(\n    uint32 immediate_data_size, const gles2::ReadPixels& c) {\n  GLint x = c.x;\n  GLint y = c.y;\n  GLsizei width = c.width;\n  GLsizei height = c.height;\n  GLenum format = c.format;\n  GLenum type = c.type;\n  if (width < 0 || height < 0) {\n    SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions < 0\");\n    return error::kNoError;\n  }\n  typedef gles2::ReadPixels::Result Result;\n  uint32 pixels_size;\n  if (!GLES2Util::ComputeImageDataSize(\n      width, height, format, type, pack_alignment_, &pixels_size)) {\n    return error::kOutOfBounds;\n  }\n  void* pixels = GetSharedMemoryAs<void*>(\n      c.pixels_shm_id, c.pixels_shm_offset, pixels_size);\n  Result* result = GetSharedMemoryAs<Result*>(\n        c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!pixels || !result) {\n    return error::kOutOfBounds;\n  }\n\n  if (!validators_->read_pixel_format.IsValid(format)) {\n    SetGLError(GL_INVALID_ENUM, \"glReadPixels: format GL_INVALID_ENUM\");\n    return error::kNoError;\n  }\n  if (!validators_->pixel_type.IsValid(type)) {\n    SetGLError(GL_INVALID_ENUM, \"glReadPixels: type GL_INVALID_ENUM\");\n    return error::kNoError;\n  }\n  if (width == 0 || height == 0) {\n    return error::kNoError;\n  }\n\n  CopyRealGLErrorsToWrapper();\n\n  ScopedResolvedFrameBufferBinder binder(this, false, true);\n\n  gfx::Size max_size = GetBoundReadFrameBufferSize();\n\n  GLint max_x;\n  GLint max_y;\n  if (!SafeAdd(x, width, &max_x) || !SafeAdd(y, height, &max_y)) {\n    SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n    return error::kNoError;\n  }\n\n  if (x < 0 || y < 0 || max_x > max_size.width() || max_y > max_size.height()) {\n    uint32 temp_size;\n    if (!GLES2Util::ComputeImageDataSize(\n        width, 1, format, type, pack_alignment_, &temp_size)) {\n      SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n      return error::kNoError;\n    }\n    GLsizei unpadded_row_size = temp_size;\n    if (!GLES2Util::ComputeImageDataSize(\n        width, 2, format, type, pack_alignment_, &temp_size)) {\n      SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n      return error::kNoError;\n    }\n    GLsizei padded_row_size = temp_size - unpadded_row_size;\n    if (padded_row_size < 0 || unpadded_row_size < 0) {\n      SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n      return error::kNoError;\n    }\n\n    GLint dest_x_offset = std::max(-x, 0);\n    uint32 dest_row_offset;\n    if (!GLES2Util::ComputeImageDataSize(\n      dest_x_offset, 1, format, type, pack_alignment_, &dest_row_offset)) {\n      SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n      return error::kNoError;\n    }\n\n    int8* dst = static_cast<int8*>(pixels);\n    GLint read_x = std::max(0, x);\n    GLint read_end_x = std::max(0, std::min(max_size.width(), max_x));\n    GLint read_width = read_end_x - read_x;\n    for (GLint yy = 0; yy < height; ++yy) {\n      GLint ry = y + yy;\n\n      memset(dst, 0, unpadded_row_size);\n\n      if (ry >= 0 && ry < max_size.height() && read_width > 0) {\n        glReadPixels(\n            read_x, ry, read_width, 1, format, type, dst + dest_row_offset);\n      }\n      dst += padded_row_size;\n    }\n  } else {\n    glReadPixels(x, y, width, height, format, type, pixels);\n  }\n  GLenum error = PeekGLError();\n  if (error == GL_NO_ERROR) {\n    *result = true;\n\n    GLenum read_format = GetBoundReadFrameBufferInternalFormat();\n    uint32 channels_exist = GLES2Util::GetChannelsForFormat(read_format);\n    if ((channels_exist & 0x0008) == 0) {\n      uint32 temp_size;\n      if (!GLES2Util::ComputeImageDataSize(\n          width, 1, format, type, pack_alignment_, &temp_size)) {\n        SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n        return error::kNoError;\n      }\n      GLsizei unpadded_row_size = temp_size;\n      if (!GLES2Util::ComputeImageDataSize(\n          width, 2, format, type, pack_alignment_, &temp_size)) {\n        SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n        return error::kNoError;\n      }\n      GLsizei padded_row_size = temp_size - unpadded_row_size;\n      if (padded_row_size < 0 || unpadded_row_size < 0) {\n        SetGLError(GL_INVALID_VALUE, \"glReadPixels: dimensions out of range\");\n        return error::kNoError;\n      }\n      if (type != GL_UNSIGNED_BYTE) {\n        SetGLError(GL_INVALID_OPERATION, \"unsupported readPixel format\");\n        return error::kNoError;\n      }\n      switch (format) {\n        case GL_RGBA:\n        case GL_BGRA_EXT:\n        case GL_ALPHA: {\n          int offset = (format == GL_ALPHA) ? 0 : 3;\n          int step = (format == GL_ALPHA) ? 1 : 4;\n          uint8* dst = static_cast<uint8*>(pixels) + offset;\n          for (GLint yy = 0; yy < height; ++yy) {\n            uint8* end = dst + unpadded_row_size;\n            for (uint8* d = dst; d < end; d += step) {\n              *d = 255;\n            }\n            dst += padded_row_size;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 104146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n               X509_STORE *store, BIO *dcont, BIO *out, unsigned int flags)\n{\n    CMS_SignerInfo *si;\n    STACK_OF(CMS_SignerInfo) *sinfos;\n    STACK_OF(X509) *cms_certs = NULL;\n    STACK_OF(X509_CRL) *crls = NULL;\n    X509 *signer;\n    int i, scount = 0, ret = 0;\n    BIO *cmsbio = NULL, *tmpin = NULL, *tmpout = NULL;\n\n    if (!dcont && !check_content(cms))\n        return 0;\n    if (dcont && !(flags & CMS_BINARY)) {\n        const ASN1_OBJECT *coid = CMS_get0_eContentType(cms);\n        if (OBJ_obj2nid(coid) == NID_id_ct_asciiTextWithCRLF)\n            flags |= CMS_ASCIICRLF;\n    }\n\n    /* Attempt to find all signer certificates */\n\n    sinfos = CMS_get0_SignerInfos(cms);\n\n    if (sk_CMS_SignerInfo_num(sinfos) <= 0) {\n        CMSerr(CMS_F_CMS_VERIFY, CMS_R_NO_SIGNERS);\n        goto err;\n    }\n\n    for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {\n        si = sk_CMS_SignerInfo_value(sinfos, i);\n        CMS_SignerInfo_get0_algs(si, NULL, &signer, NULL, NULL);\n        if (signer)\n            scount++;\n    }\n\n    if (scount != sk_CMS_SignerInfo_num(sinfos))\n        scount += CMS_set1_signers_certs(cms, certs, flags);\n\n    if (scount != sk_CMS_SignerInfo_num(sinfos)) {\n        CMSerr(CMS_F_CMS_VERIFY, CMS_R_SIGNER_CERTIFICATE_NOT_FOUND);\n        goto err;\n    }\n\n    /* Attempt to verify all signers certs */\n\n    if (!(flags & CMS_NO_SIGNER_CERT_VERIFY)) {\n        cms_certs = CMS_get1_certs(cms);\n        if (!(flags & CMS_NOCRL))\n            crls = CMS_get1_crls(cms);\n        for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {\n            si = sk_CMS_SignerInfo_value(sinfos, i);\n            if (!cms_signerinfo_verify_cert(si, store, cms_certs, crls))\n                goto err;\n        }\n    }\n\n    /* Attempt to verify all SignerInfo signed attribute signatures */\n\n    if (!(flags & CMS_NO_ATTR_VERIFY)) {\n        for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {\n            si = sk_CMS_SignerInfo_value(sinfos, i);\n            if (CMS_signed_get_attr_count(si) < 0)\n                continue;\n            if (CMS_SignerInfo_verify(si) <= 0)\n                goto err;\n        }\n    }\n\n    /*\n     * Performance optimization: if the content is a memory BIO then store\n     * its contents in a temporary read only memory BIO. This avoids\n     * potentially large numbers of slow copies of data which will occur when\n     * reading from a read write memory BIO when signatures are calculated.\n     */\n\n    if (dcont && (BIO_method_type(dcont) == BIO_TYPE_MEM)) {\n        char *ptr;\n        long len;\n        len = BIO_get_mem_data(dcont, &ptr);\n        tmpin = BIO_new_mem_buf(ptr, len);\n        if (tmpin == NULL) {\n            CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);\n            goto err2;\n        }\n    } else\n        tmpin = dcont;\n    /*\n     * If not binary mode and detached generate digests by *writing* through\n     * the BIO. That makes it possible to canonicalise the input.\n     */\n    if (!(flags & SMIME_BINARY) && dcont) {\n        /*\n         * Create output BIO so we can either handle text or to ensure\n         * included content doesn't override detached content.\n         */\n        tmpout = cms_get_text_bio(out, flags);\n        if (!tmpout) {\n            CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        cmsbio = CMS_dataInit(cms, tmpout);\n        if (!cmsbio)\n            goto err;\n        /*\n         * Don't use SMIME_TEXT for verify: it adds headers and we want to\n         * remove them.\n         */\n        SMIME_crlf_copy(dcont, cmsbio, flags & ~SMIME_TEXT);\n\n        if (flags & CMS_TEXT) {\n            if (!SMIME_text(tmpout, out)) {\n                CMSerr(CMS_F_CMS_VERIFY, CMS_R_SMIME_TEXT_ERROR);\n                goto err;\n            }\n        }\n    } else {\n        cmsbio = CMS_dataInit(cms, tmpin);\n        if (!cmsbio)\n            goto err;\n\n        if (!cms_copy_content(out, cmsbio, flags))\n            goto err;\n\n    }\n    if (!(flags & CMS_NO_CONTENT_VERIFY)) {\n        for (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {\n            si = sk_CMS_SignerInfo_value(sinfos, i);\n            if (CMS_SignerInfo_verify_content(si, cmsbio) <= 0) {\n                CMSerr(CMS_F_CMS_VERIFY, CMS_R_CONTENT_VERIFY_ERROR);\n                goto err;\n            }\n        }\n    }\n\n    ret = 1;\n\n err:\n    if (!(flags & SMIME_BINARY) && dcont) {\n        do_free_upto(cmsbio, tmpout);\n        if (tmpin != dcont)\n            BIO_free(tmpin);\n    } else {\n        if (dcont && (tmpin == dcont))\n            do_free_upto(cmsbio, dcont);\n        else\n            BIO_free_all(cmsbio);\n    }\n\n    if (out != tmpout)\n        BIO_free_all(tmpout);\n\n err2:\n    sk_X509_pop_free(cms_certs, X509_free);\n    sk_X509_CRL_pop_free(crls, X509_CRL_free);\n\n    return ret;\n}\n",
        "output": "0",
        "index": 11945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n   int retval = PAM_IGNORE;\n   device_t *devices = NULL;\n   unsigned n_devices = 0;\n  int openasuser;\n   int should_free_origin = 0;\n   int should_free_appid = 0;\n   int should_free_auth_file = 0;\n   int should_free_authpending_file = 0;\n \n   parse_cfg(flags, argc, argv, cfg);\n \n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n         goto done;\n       }\n \n       snprintf(buf, authfile_dir_len,\n                \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n     } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n \n       snprintf(buf, authfile_dir_len,\n                \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n     }\n \n    DBG(\"Using default authentication file %s\", buf);\n \n     cfg->auth_file = buf; /* cfg takes ownership */\n     should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n     DBG(\"Using authentication file %s\", cfg->auth_file);\n   }\n \n  openasuser = geteuid() == 0 && cfg->openasuser;\n   if (openasuser) {\n    if (seteuid(pw_s.pw_uid)) {\n      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);\n       retval = PAM_IGNORE;\n       goto done;\n     }\n    DBG(\"Switched to uid %i\", pw_s.pw_uid);\n   }\n   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                      cfg->debug, cfg->debug_file,\n                                      devices, &n_devices);\n   if (openasuser) {\n    if (seteuid(0)) {\n      DBG(\"Unable to switch back to uid 0\");\n       retval = PAM_IGNORE;\n       goto done;\n     }\n    DBG(\"Switched back to uid 0\");\n   }\n \n   if (retval != 1) {\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}\n",
        "output": "1",
        "index": 182836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::CreateNewWindow(\n    mojom::CreateNewWindowParamsPtr params,\n    CreateNewWindowCallback callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  TRACE_EVENT2(\"navigation\", \"RenderFrameHostImpl::CreateNewWindow\",\n               \"frame_tree_node\", frame_tree_node_->frame_tree_node_id(), \"url\",\n               params->target_url.possibly_invalid_spec());\n\n  bool no_javascript_access = false;\n\n  GetProcess()->FilterURL(false, &params->target_url);\n  if (!GetContentClient()->browser()->ShouldAllowOpenURL(GetSiteInstance(),\n                                                         params->target_url)) {\n    params->target_url = GURL(url::kAboutBlankURL);\n  }\n\n  bool can_create_window =\n      IsCurrent() && render_frame_created_ &&\n      GetContentClient()->browser()->CanCreateWindow(\n          this, GetLastCommittedURL(),\n          frame_tree_node_->frame_tree()->GetMainFrame()->GetLastCommittedURL(),\n          last_committed_origin_.GetURL(), params->window_container_type,\n          params->target_url, params->referrer, params->frame_name,\n          params->disposition, *params->features, params->user_gesture,\n          params->opener_suppressed, &no_javascript_access);\n\n  if (!can_create_window) {\n    std::move(callback).Run(mojom::CreateNewWindowStatus::kIgnore, nullptr);\n    return;\n  }\n\n  if (!render_view_host_->GetWebkitPreferences().supports_multiple_windows) {\n    std::move(callback).Run(mojom::CreateNewWindowStatus::kReuse, nullptr);\n    return;\n  }\n\n  StoragePartition* storage_partition = BrowserContext::GetStoragePartition(\n      GetSiteInstance()->GetBrowserContext(), GetSiteInstance());\n  DOMStorageContextWrapper* dom_storage_context =\n      static_cast<DOMStorageContextWrapper*>(\n          storage_partition->GetDOMStorageContext());\n\n  scoped_refptr<SessionStorageNamespaceImpl> cloned_namespace;\n  if (base::FeatureList::IsEnabled(features::kMojoSessionStorage)) {\n    cloned_namespace = SessionStorageNamespaceImpl::Create(\n        dom_storage_context, params->session_storage_namespace_id);\n  } else {\n    cloned_namespace = SessionStorageNamespaceImpl::CloneFrom(\n        dom_storage_context, params->session_storage_namespace_id,\n        params->clone_from_session_storage_namespace_id);\n  }\n\n  int render_view_route_id = MSG_ROUTING_NONE;\n  int main_frame_route_id = MSG_ROUTING_NONE;\n  int main_frame_widget_route_id = MSG_ROUTING_NONE;\n  int render_process_id = GetProcess()->GetID();\n  if (!params->opener_suppressed && !no_javascript_access) {\n    render_view_route_id = GetProcess()->GetNextRoutingID();\n    main_frame_route_id = GetProcess()->GetNextRoutingID();\n    main_frame_widget_route_id = render_view_route_id;\n    auto block_requests_for_route = base::Bind(\n        [](const GlobalFrameRoutingId& id) {\n          auto* rdh = ResourceDispatcherHostImpl::Get();\n          if (rdh)\n            rdh->BlockRequestsForRoute(id);\n        },\n        GlobalFrameRoutingId(render_process_id, main_frame_route_id));\n    BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                            std::move(block_requests_for_route));\n  }\n\n  DCHECK(IsRenderFrameLive());\n\n  delegate_->CreateNewWindow(this, render_view_route_id, main_frame_route_id,\n                             main_frame_widget_route_id, *params,\n                             cloned_namespace.get());\n\n  if (main_frame_route_id == MSG_ROUTING_NONE) {\n    std::move(callback).Run(mojom::CreateNewWindowStatus::kIgnore, nullptr);\n    return;\n  }\n\n  bool succeeded =\n      RenderWidgetHost::FromID(render_process_id, main_frame_widget_route_id) !=\n      nullptr;\n  if (!succeeded) {\n    DCHECK(!RenderFrameHost::FromID(render_process_id, main_frame_route_id));\n    DCHECK(!RenderViewHost::FromID(render_process_id, render_view_route_id));\n    std::move(callback).Run(mojom::CreateNewWindowStatus::kIgnore, nullptr);\n    return;\n  }\n\n  DCHECK(RenderViewHost::FromID(render_process_id, render_view_route_id));\n  RenderFrameHostImpl* rfh =\n      RenderFrameHostImpl::FromID(GetProcess()->GetID(), main_frame_route_id);\n  DCHECK(rfh);\n\n  service_manager::mojom::InterfaceProviderPtrInfo\n      main_frame_interface_provider_info;\n  rfh->BindInterfaceProviderRequest(\n      mojo::MakeRequest(&main_frame_interface_provider_info));\n\n  mojom::CreateNewWindowReplyPtr reply = mojom::CreateNewWindowReply::New(\n      render_view_route_id, main_frame_route_id, main_frame_widget_route_id,\n      std::move(main_frame_interface_provider_info), cloned_namespace->id(),\n      rfh->GetDevToolsFrameToken());\n  std::move(callback).Run(mojom::CreateNewWindowStatus::kSuccess,\n                          std::move(reply));\n}\n",
        "output": "0",
        "index": 169148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf, unsigned char *limit, int *al)\n\t{\n\tint extdatalen=0;\n\tunsigned char *orig = buf;\n\tunsigned char *ret = buf;\n\tsize_t i;\n\tcustom_srv_ext_record *record;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\tint next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n\tunsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\tunsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n\tint using_ecc = (alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)) || (alg_a & SSL_aECDSA);\n\tusing_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\t/* don't add extensions for SSLv3, unless doing secure renegotiation */\n\tif (s->version == SSL3_VERSION && !s->s3->send_connection_binding)\n\t\treturn orig;\n\t\n\tret+=2;\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n\tif (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)\n\t\t{ \n\t\tif ((long)(limit - ret - 4) < 0) return NULL; \n\n\t\ts2n(TLSEXT_TYPE_server_name,ret);\n\t\ts2n(0,ret);\n\t\t}\n\n\tif(s->s3->send_connection_binding)\n        {\n          int el;\n          \n          if(!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0))\n              {\n              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          if((limit - ret - 4 - el) < 0) return NULL;\n          \n          s2n(TLSEXT_TYPE_renegotiate,ret);\n          s2n(el,ret);\n\n          if(!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el))\n              {\n              SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          ret += el;\n        }\n\n#ifndef OPENSSL_NO_EC\n\tif (using_ecc)\n\t\t{\n\t\tconst unsigned char *plist;\n\t\tsize_t plistlen;\n\t\t/* Add TLS extension ECPointFormats to the ServerHello message */\n\t\tlong lenmax; \n\n\t\ttls1_get_formatlist(s, &plist, &plistlen);\n\n\t\tif ((lenmax = limit - ret - 5) < 0) return NULL; \n\t\tif (plistlen > (size_t)lenmax) return NULL;\n\t\tif (plistlen > 255)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\ts2n(TLSEXT_TYPE_ec_point_formats,ret);\n\t\ts2n(plistlen + 1,ret);\n\t\t*(ret++) = (unsigned char) plistlen;\n\t\tmemcpy(ret, plist, plistlen);\n\t\tret+=plistlen;\n\n\t\t}\n\t/* Currently the server should not respond with a SupportedCurves extension */\n#endif /* OPENSSL_NO_EC */\n\n\tif (s->tlsext_ticket_expected && tls_use_ticket(s))\n\t\t{ \n\t\tif ((long)(limit - ret - 4) < 0) return NULL; \n\t\ts2n(TLSEXT_TYPE_session_ticket,ret);\n\t\ts2n(0,ret);\n\t\t}\n\n\tif (s->tlsext_status_expected)\n\t\t{ \n\t\tif ((long)(limit - ret - 4) < 0) return NULL; \n\t\ts2n(TLSEXT_TYPE_status_request,ret);\n\t\ts2n(0,ret);\n\t\t}\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->server_opaque_prf_input != NULL)\n\t\t{\n\t\tsize_t sol = s->s3->server_opaque_prf_input_len;\n\t\t\n\t\tif ((long)(limit - ret - 6 - sol) < 0)\n\t\t\treturn NULL;\n\t\tif (sol > 0xFFFD) /* can't happen */\n\t\t\treturn NULL;\n\n\t\ts2n(TLSEXT_TYPE_opaque_prf_input, ret); \n\t\ts2n(sol + 2, ret);\n\t\ts2n(sol, ret);\n\t\tmemcpy(ret, s->s3->server_opaque_prf_input, sol);\n\t\tret += sol;\n\t\t}\n#endif\n\n        if(s->srtp_profile)\n                {\n                int el;\n\n                ssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);\n                \n                if((limit - ret - 4 - el) < 0) return NULL;\n\n                s2n(TLSEXT_TYPE_use_srtp,ret);\n                s2n(el,ret);\n\n                if(ssl_add_serverhello_use_srtp_ext(s, ret, &el, el))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n                ret+=el;\n                }\n\n\tif (((s->s3->tmp.new_cipher->id & 0xFFFF)==0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF)==0x81) \n\t\t&& (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG))\n\t\t{ const unsigned char cryptopro_ext[36] = {\n\t\t\t0xfd, 0xe8, /*65000*/\n\t\t\t0x00, 0x20, /*32 bytes length*/\n\t\t\t0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, \n\t\t\t0x03,   0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06, \n\t\t\t0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08, \n\t\t\t0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17};\n\t\t\tif (limit-ret<36) return NULL;\n\t\t\tmemcpy(ret,cryptopro_ext,36);\n\t\t\tret+=36;\n\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* Add Heartbeat extension if we've received one */\n\tif (s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED)\n\t\t{\n\t\tif ((limit - ret - 4 - 1) < 0)\n\t\t\treturn NULL;\n\t\ts2n(TLSEXT_TYPE_heartbeat,ret);\n\t\ts2n(1,ret);\n\t\t/* Set mode:\n\t\t * 1: peer may send requests\n\t\t * 2: peer not allowed to send requests\n\t\t */\n\t\tif (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)\n\t\t\t*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n\t\telse\n\t\t\t*(ret++) = SSL_TLSEXT_HB_ENABLED;\n\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\tnext_proto_neg_seen = s->s3->next_proto_neg_seen;\n\ts->s3->next_proto_neg_seen = 0;\n\tif (next_proto_neg_seen && s->ctx->next_protos_advertised_cb)\n\t\t{\n\t\tconst unsigned char *npa;\n\t\tunsigned int npalen;\n\t\tint r;\n\n\t\tr = s->ctx->next_protos_advertised_cb(s, &npa, &npalen, s->ctx->next_protos_advertised_cb_arg);\n\t\tif (r == SSL_TLSEXT_ERR_OK)\n\t\t\t{\n\t\t\tif ((long)(limit - ret - 4 - npalen) < 0) return NULL;\n\t\t\ts2n(TLSEXT_TYPE_next_proto_neg,ret);\n\t\t\ts2n(npalen,ret);\n\t\t\tmemcpy(ret, npa, npalen);\n\t\t\tret += npalen;\n\t\t\ts->s3->next_proto_neg_seen = 1;\n\t\t\t}\n\t\t}\n#endif\n\n\tfor (i = 0; i < s->ctx->custom_srv_ext_records_count; i++)\n\t\t{\n\t\tconst unsigned char *out = NULL;\n\t\tunsigned short outlen = 0;\n\t\tint cb_retval = 0;\n\n\t\trecord = &s->ctx->custom_srv_ext_records[i];\n\n\t\t/* NULL callback or -1 omits extension */\n\t\tif (!record->fn2)\n\t\t\tcontinue;\n\t\tcb_retval = record->fn2(s, record->ext_type,\n\t\t\t\t\t\t\t\t&out, &outlen, al,\n\t\t\t\t\t\t\t\trecord->arg);\n\t\tif (cb_retval == 0)\n\t\t\treturn NULL; /* error */\n\t\tif (cb_retval == -1)\n\t\t\tcontinue; /* skip this extension */\n\t\tif (limit < ret + 4 + outlen)\n\t\t\treturn NULL;\n\t\ts2n(record->ext_type, ret);\n\t\ts2n(outlen, ret);\n\t\tmemcpy(ret, out, outlen);\n\t\tret += outlen;\n\t\t}\n#ifdef TLSEXT_TYPE_encrypt_then_mac\n\tif (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC)\n\t\t{\n\t\t/* Don't use encrypt_then_mac if AEAD: might want\n\t\t * to disable for other ciphersuites too.\n\t\t */\n\t\tif (s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD)\n\t\t\ts->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n\t\telse\n\t\t\t{\n\t\t\ts2n(TLSEXT_TYPE_encrypt_then_mac,ret);\n\t\t\ts2n(0,ret);\n\t\t\t}\n\t\t}\n#endif\n\n\tif (s->s3->alpn_selected)\n\t\t{\n\t\tconst unsigned char *selected = s->s3->alpn_selected;\n\t\tunsigned len = s->s3->alpn_selected_len;\n\n\t\tif ((long)(limit - ret - 4 - 2 - 1 - len) < 0)\n\t\t\treturn NULL;\n\t\ts2n(TLSEXT_TYPE_application_layer_protocol_negotiation,ret);\n\t\ts2n(3 + len,ret);\n\t\ts2n(1 + len,ret);\n\t\t*ret++ = len;\n\t\tmemcpy(ret, selected, len);\n\t\tret += len;\n\t\t}\n\n\tif ((extdatalen = ret-orig-2)== 0) \n\t\treturn orig;\n\n\ts2n(extdatalen, orig);\n\treturn ret;\n\t}\n",
        "output": "0",
        "index": 10781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sctp_cmd_interpreter(sctp_event_t event_type,\n\t\t\t\tsctp_subtype_t subtype,\n\t\t\t\tsctp_state_t state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tsctp_disposition_t status,\n\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\tgfp_t gfp)\n{\n\tint error = 0;\n\tint force;\n\tsctp_cmd_t *cmd;\n\tstruct sctp_chunk *new_obj;\n\tstruct sctp_chunk *chunk = NULL;\n\tstruct sctp_packet *packet;\n\tstruct timer_list *timer;\n\tunsigned long timeout;\n\tstruct sctp_transport *t;\n\tstruct sctp_sackhdr sackh;\n\tint local_cork = 0;\n\n\tif (SCTP_EVENT_T_TIMEOUT != event_type)\n\t\tchunk = event_arg;\n\n\t/* Note:  This whole file is a huge candidate for rework.\n\t * For example, each command could either have its own handler, so\n\t * the loop would look like:\n\t *     while (cmds)\n\t *         cmd->handle(x, y, z)\n\t * --jgrimm\n\t */\n\twhile (NULL != (cmd = sctp_next_cmd(commands))) {\n\t\tswitch (cmd->verb) {\n\t\tcase SCTP_CMD_NOP:\n\t\t\t/* Do nothing. */\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_ASOC:\n\t\t\t/* Register a new association.  */\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\n\t\t\t/* Register with the endpoint.  */\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tBUG_ON(asoc->peer.primary_path == NULL);\n\t\t\tsctp_endpoint_add_asoc(ep, asoc);\n\t\t\tsctp_hash_established(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_UPDATE_ASSOC:\n\t\t       sctp_assoc_update(asoc, cmd->obj.asoc);\n\t\t       break;\n\n\t\tcase SCTP_CMD_PURGE_OUTQUEUE:\n\t\t       sctp_outq_teardown(&asoc->outqueue);\n\t\t       break;\n\n\t\tcase SCTP_CMD_DELETE_TCB:\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\t/* Delete the current association.  */\n\t\t\tsctp_cmd_delete_tcb(commands, asoc);\n\t\t\tasoc = NULL;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_STATE:\n\t\t\t/* Enter a new state.  */\n\t\t\tsctp_cmd_new_state(commands, asoc, cmd->obj.state);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_TSN:\n\t\t\t/* Record the arrival of a TSN.  */\n\t\t\terror = sctp_tsnmap_mark(&asoc->peer.tsn_map,\n\t\t\t\t\t\t cmd->obj.u32, NULL);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_FWDTSN:\n\t\t\t/* Move the Cumulattive TSN Ack ahead. */\n\t\t\tsctp_tsnmap_skip(&asoc->peer.tsn_map, cmd->obj.u32);\n\n\t\t\t/* purge the fragmentation queue */\n\t\t\tsctp_ulpq_reasm_flushtsn(&asoc->ulpq, cmd->obj.u32);\n\n\t\t\t/* Abort any in progress partial delivery. */\n\t\t\tsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_FWDTSN:\n\t\t\tsctp_cmd_process_fwdtsn(&asoc->ulpq, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SACK:\n\t\t\t/* Generate a Selective ACK.\n\t\t\t * The argument tells us whether to just count\n\t\t\t * the packet and MAYBE generate a SACK, or\n\t\t\t * force a SACK out.\n\t\t\t */\n\t\t\tforce = cmd->obj.i32;\n\t\t\terror = sctp_gen_sack(asoc, force, commands);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_SACK:\n\t\t\t/* Process an inbound SACK.  */\n\t\t\terror = sctp_cmd_process_sack(commands, asoc,\n\t\t\t\t\t\t      cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_INIT_ACK:\n\t\t\t/* Generate an INIT ACK chunk.  */\n\t\t\tnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,\n\t\t\t\t\t\t     0);\n\t\t\tif (!new_obj)\n\t\t\t\tgoto nomem;\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PEER_INIT:\n\t\t\t/* Process a unified INIT from the peer.\n\t\t\t * Note: Only used during INIT-ACK processing.  If\n\t\t\t * there is an error just return to the outter\n\t\t\t * layer which will bail.\n\t\t\t */\n\t\t\terror = sctp_cmd_process_init(commands, asoc, chunk,\n\t\t\t\t\t\t      cmd->obj.init, gfp);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_COOKIE_ECHO:\n\t\t\t/* Generate a COOKIE ECHO chunk.  */\n\t\t\tnew_obj = sctp_make_cookie_echo(asoc, chunk);\n\t\t\tif (!new_obj) {\n\t\t\t\tif (cmd->obj.chunk)\n\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);\n\t\t\t\tgoto nomem;\n\t\t\t}\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\n\t\t\t/* If there is an ERROR chunk to be sent along with\n\t\t\t * the COOKIE_ECHO, send it, too.\n\t\t\t */\n\t\t\tif (cmd->obj.chunk)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(cmd->obj.chunk));\n\n\t\t\tif (new_obj->transport) {\n\t\t\t\tnew_obj->transport->init_sent_count++;\n\t\t\t\tasoc->init_last_sent_to = new_obj->transport;\n\t\t\t}\n\n\t\t\t/* FIXME - Eventually come up with a cleaner way to\n\t\t\t * enabling COOKIE-ECHO + DATA bundling during\n\t\t\t * multihoming stale cookie scenarios, the following\n\t\t\t * command plays with asoc->peer.retran_path to\n\t\t\t * avoid the problem of sending the COOKIE-ECHO and\n\t\t\t * DATA in different paths, which could result\n\t\t\t * in the association being ABORTed if the DATA chunk\n\t\t\t * is processed first by the server.  Checking the\n\t\t\t * init error counter simply causes this command\n\t\t\t * to be executed only during failed attempts of\n\t\t\t * association establishment.\n\t\t\t */\n\t\t\tif ((asoc->peer.retran_path !=\n\t\t\t     asoc->peer.primary_path) &&\n\t\t\t    (asoc->init_err_counter > 0)) {\n\t\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\t\tSCTP_CMD_FORCE_PRIM_RETRAN,\n\t\t\t\t\t\tSCTP_NULL());\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SHUTDOWN:\n\t\t\t/* Generate SHUTDOWN when in SHUTDOWN_SENT state.\n\t\t\t * Reset error counts.\n\t\t\t */\n\t\t\tasoc->overall_error_count = 0;\n\n\t\t\t/* Generate a SHUTDOWN chunk.  */\n\t\t\tnew_obj = sctp_make_shutdown(asoc, chunk);\n\t\t\tif (!new_obj)\n\t\t\t\tgoto nomem;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_CHUNK_ULP:\n\t\t\t/* Send a chunk to the sockets layer.  */\n\t\t\tpr_debug(\"%s: sm_sideff: chunk_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.chunk, &asoc->ulpq);\n\n\t\t\tsctp_ulpq_tail_data(&asoc->ulpq, cmd->obj.chunk,\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_EVENT_ULP:\n\t\t\t/* Send a notification to the sockets layer.  */\n\t\t\tpr_debug(\"%s: sm_sideff: event_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.ulpevent, &asoc->ulpq);\n\n\t\t\tsctp_ulpq_tail_event(&asoc->ulpq, cmd->obj.ulpevent);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPLY:\n\t\t\t/* If an caller has not already corked, do cork. */\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\t/* Send a chunk to our peer.  */\n\t\t\terror = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SEND_PKT:\n\t\t\t/* Send a full packet to our peer.  */\n\t\t\tpacket = cmd->obj.packet;\n\t\t\tsctp_packet_transmit(packet);\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_T1_RETRAN:\n\t\t\t/* Mark a transport for retransmission.  */\n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T1_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RETRAN:\n\t\t\t/* Mark a transport for retransmission.  */\n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T3_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CE:\n\t\t\t/* Do delayed CE processing.   */\n\t\t\tsctp_do_ecn_ce_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_ECNE:\n\t\t\t/* Do delayed ECNE processing. */\n\t\t\tnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,\n\t\t\t\t\t\t\tchunk);\n\t\t\tif (new_obj)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CWR:\n\t\t\t/* Do delayed CWR processing.  */\n\t\t\tsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T2:\n\t\t\tsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_START_ONCE:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\n\t\t\tif (timer_pending(timer))\n\t\t\t\tbreak;\n\t\t\t/* fall through */\n\n\t\tcase SCTP_CMD_TIMER_START:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tBUG_ON(!timeout);\n\n\t\t\ttimer->expires = jiffies + timeout;\n\t\t\tsctp_association_hold(asoc);\n\t\t\tadd_timer(timer);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_RESTART:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tif (!mod_timer(timer, jiffies + timeout))\n\t\t\t\tsctp_association_hold(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_STOP:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\tif (del_timer(timer))\n\t\t\t\tsctp_association_put(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_CHOOSE_TRANSPORT:\n\t\t\tchunk = cmd->obj.chunk;\n\t\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t\tasoc->init_last_sent_to);\n\t\t\tasoc->init_last_sent_to = t;\n\t\t\tchunk->transport = t;\n\t\t\tt->init_sent_count++;\n\t\t\t/* Set the new transport as primary */\n\t\t\tsctp_assoc_set_primary(asoc, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_RESTART:\n\t\t\t/* Do the needed accounting and updates\n\t\t\t * associated with restarting an initialization\n\t\t\t * timer. Only multiply the timeout by two if\n\t\t\t * all transports have been tried at the current\n\t\t\t * timeout.\n\t\t\t */\n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_INIT,\n\t\t\t\t\t\t\"INIT\");\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_COOKIEECHO_RESTART:\n\t\t\t/* Do the needed accounting and updates\n\t\t\t * associated with restarting an initialization\n\t\t\t * timer. Only multiply the timeout by two if\n\t\t\t * all transports have been tried at the current\n\t\t\t * timeout.\n\t\t\t */\n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_COOKIE,\n\t\t\t\t\t\t\"COOKIE\");\n\n\t\t\t/* If we've sent any data bundled with\n\t\t\t * COOKIE-ECHO we need to resend.\n\t\t\t */\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tsctp_retransmit_mark(&asoc->outqueue, t,\n\t\t\t\t\t    SCTP_RTXR_T1_RTX);\n\t\t\t}\n\n\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\tSCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_FAILED:\n\t\t\tsctp_cmd_init_failed(commands, asoc, cmd->obj.err);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_FAILED:\n\t\t\tsctp_cmd_assoc_failed(commands, asoc, event_type,\n\t\t\t\t\t      subtype, chunk, cmd->obj.err);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_INC:\n\t\t\tasoc->init_err_counter++;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_RESET:\n\t\t\tasoc->init_err_counter = 0;\n\t\t\tasoc->init_cycle = 0;\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tt->init_sent_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_DUP:\n\t\t\tsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,\n\t\t\t\t\t     cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_BAD_TAG:\n\t\t\tpr_debug(\"%s: vtag mismatch!\\n\", __func__);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_STRIKE:\n\t\t\t/* Mark one strike against a transport.  */\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t    cmd->obj.transport, 0);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_IDLE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_HB_SENT:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t     t, 1);\n\t\t\tt->hb_sent = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_ON:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_transport_on(commands, asoc, t, chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_START:\n\t\t\tsctp_cmd_hb_timers_start(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMER_UPDATE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_hb_timer_update(commands, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_STOP:\n\t\t\tsctp_cmd_hb_timers_stop(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_ERROR:\n\t\t\terror = cmd->obj.error;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_CTSN:\n\t\t\t/* Dummy up a SACK for processing. */\n\t\t\tsackh.cum_tsn_ack = cmd->obj.be32;\n\t\t\tsackh.a_rwnd = asoc->peer.rwnd +\n\t\t\t\t\tasoc->outqueue.outstanding_bytes;\n\t\t\tsackh.num_gap_ack_blocks = 0;\n\t\t\tsackh.num_dup_tsns = 0;\n\t\t\tchunk->subh.sack_hdr = &sackh;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,\n\t\t\t\t\tSCTP_CHUNK(chunk));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_DISCARD_PACKET:\n\t\t\t/* We need to discard the whole packet.\n\t\t\t * Uncork the queue since there might be\n\t\t\t * responses pending\n\t\t\t */\n\t\t\tchunk->pdiscard = 1;\n\t\t\tif (asoc) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RTO_PENDING:\n\t\t\tt = cmd->obj.transport;\n\t\t\tt->rto_pending = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PART_DELIVER:\n\t\t\tsctp_ulpq_partial_delivery(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RENEGE:\n\t\t\tsctp_ulpq_renege(&asoc->ulpq, cmd->obj.chunk,\n\t\t\t\t\t GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T4:\n\t\t\tsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_OPERR:\n\t\t\tsctp_cmd_process_operr(commands, asoc, chunk);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_CLEAR_INIT_TAG:\n\t\t\tasoc->peer.i.init_tag = 0;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_DEL_NON_PRIMARY:\n\t\t\tsctp_cmd_del_non_primary(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_T3_RTX_TIMERS_STOP:\n\t\t\tsctp_cmd_t3_rtx_timers_stop(commands, asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_FORCE_PRIM_RETRAN:\n\t\t\tt = asoc->peer.retran_path;\n\t\t\tasoc->peer.retran_path = asoc->peer.primary_path;\n\t\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\t\t\tlocal_cork = 0;\n\t\t\tasoc->peer.retran_path = t;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SET_SK_ERR:\n\t\t\tsctp_cmd_set_sk_err(asoc, cmd->obj.error);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ASSOC_CHANGE:\n\t\t\tsctp_cmd_assoc_change(commands, asoc,\n\t\t\t\t\t      cmd->obj.u8);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ADAPTATION_IND:\n\t\t\tsctp_cmd_adaptation_ind(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_SHKEY:\n\t\t\terror = sctp_auth_asoc_init_active_key(asoc,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_UPDATE_INITTAG:\n\t\t\tasoc->peer.i.init_tag = cmd->obj.u32;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_MSG:\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\terror = sctp_cmd_send_msg(asoc, cmd->obj.msg);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_NEXT_ASCONF:\n\t\t\tsctp_cmd_send_asconf(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_PURGE_ASCONF_QUEUE:\n\t\t\tsctp_asconf_queue_teardown(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SET_ASOC:\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"Impossible command: %u\\n\",\n\t\t\t\tcmd->verb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\nout:\n\t/* If this is in response to a received chunk, wait until\n\t * we are done with the packet to open the queue so that we don't\n\t * send multiple packets in response to a single request.\n\t */\n\tif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {\n\t\tif (chunk->end_of_packet || chunk->singleton)\n\t\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\t} else if (local_cork)\n\t\terror = sctp_outq_uncork(&asoc->outqueue);\n\treturn error;\nnomem:\n\terror = -ENOMEM;\n\tgoto out;\n}\n",
        "output": "0",
        "index": 57000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n \t\t\toffset += 3;\n \t\t\tlength -= 3;\n \n\t\t\tmemcpy(tim.bitmap, p + (tim.length - 3),\n\t\t\t    (tim.length - 3));\n \t\t\toffset += tim.length - 3;\n \t\t\tlength -= tim.length - 3;\n \t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n",
        "output": "1",
        "index": 183204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SoftAMR::onQueueFilled(OMX_U32 /* portIndex */) {\n List<BufferInfo *> &inQueue = getPortQueue(0);\n List<BufferInfo *> &outQueue = getPortQueue(1);\n\n if (mSignalledError || mOutputPortSettingsChange != NONE) {\n return;\n }\n\n while (!inQueue.empty() && !outQueue.empty()) {\n\n         BufferInfo *inInfo = *inQueue.begin();\n         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;\n \n         BufferInfo *outInfo = *outQueue.begin();\n         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;\n \n if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {\n            inQueue.erase(inQueue.begin());\n            inInfo->mOwnedByUs = false;\n            notifyEmptyBufferDone(inHeader);\n\n            outHeader->nFilledLen = 0;\n            outHeader->nFlags = OMX_BUFFERFLAG_EOS;\n\n            outQueue.erase(outQueue.begin());\n            outInfo->mOwnedByUs = false;\n            notifyFillBufferDone(outHeader);\n return;\n }\n\n if (inHeader->nOffset == 0) {\n            mAnchorTimeUs = inHeader->nTimeStamp;\n            mNumSamplesOutput = 0;\n }\n\n const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset;\n int32_t numBytesRead;\n\n if (mMode == MODE_NARROW) {\n if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: NB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n\n                 return;\n             }\n \n             numBytesRead =\n                 AMRDecode(mState,\n                   (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),\n (UWord8 *)&inputPtr[1],\n reinterpret_cast<int16_t *>(outHeader->pBuffer),\n                  MIME_IETF);\n\n if (numBytesRead == -1) {\n                ALOGE(\"PV AMR decoder AMRDecode() call failed\");\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n\n ++numBytesRead; // Include the frame type header byte.\n\n if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) {\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n }\n } else {\n if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {\n                ALOGE(\"b/27662364: WB expected output buffer %zu bytes vs %u\",\n                       kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);\n                android_errorWriteLog(0x534e4554, \"27662364\");\n                notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);\n                mSignalledError = true;\n return;\n }\n\n int16 mode = ((inputPtr[0] >> 3) & 0x0f);\n\n if (mode >= 10 && mode <= 13) {\n                ALOGE(\"encountered illegal frame type %d in AMR WB content.\",\n                      mode);\n\n                notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n                mSignalledError = true;\n\n return;\n\n             }\n \n             size_t frameSize = getFrameSize(mode);\n            CHECK_GE(inHeader->nFilledLen, frameSize);\n \n             int16_t *outPtr = (int16_t *)outHeader->pBuffer;\n \n if (mode >= 9) {\n                memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t));\n } else if (mode < 9) {\n int16 frameType;\n                RX_State_wb rx_state;\n                mime_unsorting(\n const_cast<uint8_t *>(&inputPtr[1]),\n                        mInputSampleBuffer,\n &frameType, &mode, 1, &rx_state);\n\n int16_t numSamplesOutput;\n                pvDecoder_AmrWb(\n                        mode, mInputSampleBuffer,\n                        outPtr,\n &numSamplesOutput,\n                        mDecoderBuf, frameType, mDecoderCookie);\n\n                CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB);\n\n for (int i = 0; i < kNumSamplesPerFrameWB; ++i) {\n /* Delete the 2 LSBs (14-bit output) */\n                    outPtr[i] &= 0xfffC;\n }\n }\n\n            numBytesRead = frameSize;\n }\n\n        inHeader->nOffset += numBytesRead;\n        inHeader->nFilledLen -= numBytesRead;\n\n        outHeader->nFlags = 0;\n        outHeader->nOffset = 0;\n\n if (mMode == MODE_NARROW) {\n            outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateNB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameNB;\n } else {\n            outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t);\n\n            outHeader->nTimeStamp =\n                mAnchorTimeUs\n + (mNumSamplesOutput * 1000000ll) / kSampleRateWB;\n\n            mNumSamplesOutput += kNumSamplesPerFrameWB;\n }\n\n if (inHeader->nFilledLen == 0) {\n            inInfo->mOwnedByUs = false;\n            inQueue.erase(inQueue.begin());\n            inInfo = NULL;\n            notifyEmptyBufferDone(inHeader);\n            inHeader = NULL;\n }\n\n        outInfo->mOwnedByUs = false;\n        outQueue.erase(outQueue.begin());\n        outInfo = NULL;\n        notifyFillBufferDone(outHeader);\n        outHeader = NULL;\n\n ++mInputBufferCount;\n }\n}\n",
        "output": "1",
        "index": 188253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)\n\t{\n\tint al,i,j,ret;\n\tunsigned int n;\n\tSSL3_RECORD *rr;\n\tvoid (*cb)(const SSL *ssl,int type2,int val)=NULL;\n\n\tif (s->s3->rbuf.buf == NULL) /* Not initialized yet */\n\t\tif (!ssl3_setup_read_buffer(s))\n\t\t\treturn(-1);\n\n\tif ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE)) ||\n\t    (peek && (type != SSL3_RT_APPLICATION_DATA)))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR);\n\t\treturn -1;\n\t\t}\n\n\tif ((type == SSL3_RT_HANDSHAKE) && (s->s3->handshake_fragment_len > 0))\n\t\t/* (partially) satisfy request from storage */\n\t\t{\n\t\tunsigned char *src = s->s3->handshake_fragment;\n\t\tunsigned char *dst = buf;\n\t\tunsigned int k;\n\n\t\t/* peek == 0 */\n\t\tn = 0;\n\t\twhile ((len > 0) && (s->s3->handshake_fragment_len > 0))\n\t\t\t{\n\t\t\t*dst++ = *src++;\n\t\t\tlen--; s->s3->handshake_fragment_len--;\n\t\t\tn++;\n\t\t\t}\n\t\t/* move any remaining fragment bytes: */\n\t\tfor (k = 0; k < s->s3->handshake_fragment_len; k++)\n\t\t\ts->s3->handshake_fragment[k] = *src++;\n\t\treturn n;\n\t}\n\n\t/* Now s->s3->handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE. */\n\n\tif (!s->in_handshake && SSL_in_init(s))\n\t\t{\n\t\t/* type == SSL3_RT_APPLICATION_DATA */\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\t\t}\nstart:\n\ts->rwstate=SSL_NOTHING;\n\n\t/*-\n\t * s->s3->rrec.type\t    - is the type of record\n\t * s->s3->rrec.data,    - data\n\t * s->s3->rrec.off,     - offset into 'data' for next read\n\t * s->s3->rrec.length,  - number of bytes. \n\t */\n\trr = &(s->s3->rrec);\n\n\t/* get new packet if necessary */\n\tif ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))\n\t\t{\n\t\tret=ssl3_get_record(s);\n\t\tif (ret <= 0) return(ret);\n\t\t}\n\n\t/* we now have a packet which can be read and processed */\n\n\tif (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,\n\t                               * reset by ssl3_get_finished */\n\t\t&& (rr->type != SSL3_RT_HANDSHAKE))\n\t\t{\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_DATA_BETWEEN_CCS_AND_FINISHED);\n\t\tgoto f_err;\n\t\t}\n\n\t/* If the other end has shut down, throw anything we read away\n\t * (even in 'peek' mode) */\n\tif (s->shutdown & SSL_RECEIVED_SHUTDOWN)\n\t\t{\n\t\trr->length=0;\n\t\ts->rwstate=SSL_NOTHING;\n\t\treturn(0);\n\t\t}\n\n\n\tif (type == rr->type) /* SSL3_RT_APPLICATION_DATA or SSL3_RT_HANDSHAKE */\n\t\t{\n\t\t/* make sure that we are not getting application data when we\n\t\t * are doing a handshake for the first time */\n\t\tif (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&\n\t\t\t(s->enc_read_ctx == NULL))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (len <= 0) return(len);\n\n\t\tif ((unsigned int)len > rr->length)\n\t\t\tn = rr->length;\n\t\telse\n\t\t\tn = (unsigned int)len;\n\n\t\tmemcpy(buf,&(rr->data[rr->off]),n);\n\t\tif (!peek)\n\t\t\t{\n\t\t\trr->length-=n;\n\t\t\trr->off+=n;\n\t\t\tif (rr->length == 0)\n\t\t\t\t{\n\t\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\t\trr->off=0;\n\t\t\t\tif (s->mode & SSL_MODE_RELEASE_BUFFERS && s->s3->rbuf.left == 0)\n\t\t\t\t\tssl3_release_read_buffer(s);\n\t\t\t\t}\n\t\t\t}\n\t\treturn(n);\n\t\t}\n\n\n\t/* If we get here, then type != rr->type; if we have a handshake\n\t * message, then it was unexpected (Hello Request or Client Hello). */\n\n\t/* In case of record types for which we have 'fragment' storage,\n\t * fill that so that we can process the data at a fixed place.\n\t */\n\t\t{\n\t\tunsigned int dest_maxlen = 0;\n\t\tunsigned char *dest = NULL;\n\t\tunsigned int *dest_len = NULL;\n\n\t\tif (rr->type == SSL3_RT_HANDSHAKE)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->s3->handshake_fragment;\n\t\t\tdest = s->s3->handshake_fragment;\n\t\t\tdest_len = &s->s3->handshake_fragment_len;\n\t\t\t}\n\t\telse if (rr->type == SSL3_RT_ALERT)\n\t\t\t{\n\t\t\tdest_maxlen = sizeof s->s3->alert_fragment;\n\t\t\tdest = s->s3->alert_fragment;\n\t\t\tdest_len = &s->s3->alert_fragment_len;\n\t\t\t}\n#ifndef OPENSSL_NO_HEARTBEATS\n\t\telse if (rr->type == TLS1_RT_HEARTBEAT)\n\t\t\t{\n\t\t\ttls1_process_heartbeat(s);\n\n\t\t\t/* Exit and notify application to read again */\n\t\t\trr->length = 0;\n\t\t\ts->rwstate=SSL_READING;\n\t\t\tBIO_clear_retry_flags(SSL_get_rbio(s));\n\t\t\tBIO_set_retry_read(SSL_get_rbio(s));\n\t\t\treturn(-1);\n\t\t\t}\n#endif\n\n\t\tif (dest_maxlen > 0)\n\t\t\t{\n\t\t\tn = dest_maxlen - *dest_len; /* available space in 'dest' */\n\t\t\tif (rr->length < n)\n\t\t\t\tn = rr->length; /* available bytes */\n\n\t\t\t/* now move 'n' bytes: */\n\t\t\twhile (n-- > 0)\n\t\t\t\t{\n\t\t\t\tdest[(*dest_len)++] = rr->data[rr->off++];\n\t\t\t\trr->length--;\n\t\t\t\t}\n\n\t\t\tif (*dest_len < dest_maxlen)\n\t\t\t\tgoto start; /* fragment was too small */\n\t\t\t}\n\t\t}\n\n\t/*-\n\t * s->s3->handshake_fragment_len == 4  iff  rr->type == SSL3_RT_HANDSHAKE;\n\t * s->s3->alert_fragment_len == 2      iff  rr->type == SSL3_RT_ALERT.\n\t * (Possibly rr is 'empty' now, i.e. rr->length may be 0.) \n\t */\n\n\t/* If we are a client, check for an incoming 'Hello Request': */\n\tif ((!s->server) &&\n\t\t(s->s3->handshake_fragment_len >= 4) &&\n\t\t(s->s3->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL))\n\t\t{\n\t\ts->s3->handshake_fragment_len = 0;\n\n\t\tif ((s->s3->handshake_fragment[1] != 0) ||\n\t\t\t(s->s3->handshake_fragment[2] != 0) ||\n\t\t\t(s->s3->handshake_fragment[3] != 0))\n\t\t\t{\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->s3->handshake_fragment, 4, s, s->msg_callback_arg);\n\n\t\tif (SSL_is_init_finished(s) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&\n\t\t\t!s->s3->renegotiate)\n\t\t\t{\n\t\t\tssl3_renegotiate(s);\n\t\t\tif (ssl3_renegotiate_check(s))\n\t\t\t\t{\n\t\t\t\ti=s->handshake_func(s);\n\t\t\t\tif (i < 0) return(i);\n\t\t\t\tif (i == 0)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\t\t\treturn(-1);\n\t\t\t\t\t}\n\n\t\t\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t\t\t{\n\t\t\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t\t\t{\n\t\t\t\t\t\tBIO *bio;\n\t\t\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t/* we either finished a handshake or ignored the request,\n\t\t * now try again to obtain the (application) data we were asked for */\n\t\tgoto start;\n\t\t}\n\t/* If we are a server and get a client hello when renegotiation isn't\n\t * allowed send back a no renegotiation alert and carry on.\n\t * WARNING: experimental code, needs reviewing (steve)\n\t */\n\tif (s->server &&\n\t\tSSL_is_init_finished(s) &&\n    \t\t!s->s3->send_connection_binding &&\n\t\t(s->version > SSL3_VERSION) &&\n\t\t(s->s3->handshake_fragment_len >= 4) &&\n\t\t(s->s3->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&\n\t\t(s->session != NULL) && (s->session->cipher != NULL) &&\n\t\t!(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\n\t\t{\n\t\t/*s->s3->handshake_fragment_len = 0;*/\n\t\trr->length = 0;\n\t\tssl3_send_alert(s,SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);\n\t\tgoto start;\n\t\t}\n\tif (s->s3->alert_fragment_len >= 2)\n\t\t{\n\t\tint alert_level = s->s3->alert_fragment[0];\n\t\tint alert_descr = s->s3->alert_fragment[1];\n\n\t\ts->s3->alert_fragment_len = 0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_ALERT, s->s3->alert_fragment, 2, s, s->msg_callback_arg);\n\n\t\tif (s->info_callback != NULL)\n\t\t\tcb=s->info_callback;\n\t\telse if (s->ctx->info_callback != NULL)\n\t\t\tcb=s->ctx->info_callback;\n\n\t\tif (cb != NULL)\n\t\t\t{\n\t\t\tj = (alert_level << 8) | alert_descr;\n\t\t\tcb(s, SSL_CB_READ_ALERT, j);\n\t\t\t}\n\n\t\tif (alert_level == 1) /* warning */\n\t\t\t{\n\t\t\ts->s3->warn_alert = alert_descr;\n\t\t\tif (alert_descr == SSL_AD_CLOSE_NOTIFY)\n\t\t\t\t{\n\t\t\t\ts->shutdown |= SSL_RECEIVED_SHUTDOWN;\n\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t/* This is a warning but we receive it if we requested\n\t\t\t * renegotiation and the peer denied it. Terminate with\n\t\t\t * a fatal alert because if application tried to\n\t\t\t * renegotiatie it presumably had a good reason and\n\t\t\t * expects it to succeed.\n\t\t\t *\n\t\t\t * In future we might have a renegotiation where we\n\t\t\t * don't care if the peer refused it where we carry on.\n\t\t\t */\n\t\t\telse if (alert_descr == SSL_AD_NO_RENEGOTIATION)\n\t\t\t\t{\n\t\t\t\tal = SSL_AD_HANDSHAKE_FAILURE;\n\t\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_NO_RENEGOTIATION);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_AD_MISSING_SRP_USERNAME\n\t\t\telse if (alert_descr == SSL_AD_MISSING_SRP_USERNAME)\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\telse if (alert_level == 2) /* fatal */\n\t\t\t{\n\t\t\tchar tmp[16];\n\n\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\ts->s3->fatal_alert = alert_descr;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%d\",alert_descr);\n\t\t\tERR_add_error_data(2,\"SSL alert number \",tmp);\n\t\t\ts->shutdown|=SSL_RECEIVED_SHUTDOWN;\n\t\t\tSSL_CTX_remove_session(s->ctx,s->session);\n\t\t\treturn(0);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tgoto start;\n\t\t}\n\n\tif (s->shutdown & SSL_SENT_SHUTDOWN) /* but we have not received a shutdown */\n\t\t{\n\t\ts->rwstate=SSL_NOTHING;\n\t\trr->length=0;\n\t\treturn(0);\n\t\t}\n\n\tif (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\t{\n\t\t/* 'Change Cipher Spec' is just a single byte, so we know\n\t\t * exactly what the record payload has to look like */\n\t\tif (\t(rr->length != 1) || (rr->off != 0) ||\n\t\t\t(rr->data[0] != SSL3_MT_CCS))\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\t/* Check we have a cipher to change to */\n\t\tif (s->s3->tmp.new_cipher == NULL)\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (!(s->s3->flags & SSL3_FLAGS_CCS_OK))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\ts->s3->flags &= ~SSL3_FLAGS_CCS_OK;\n\n\t\trr->length=0;\n\n\t\tif (s->msg_callback)\n\t\t\ts->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, rr->data, 1, s, s->msg_callback_arg);\n\n\t\ts->s3->change_cipher_spec=1;\n\t\tif (!ssl3_do_change_cipher_spec(s))\n\t\t\tgoto err;\n\t\telse\n\t\t\tgoto start;\n\t\t}\n\n\t/* Unexpected handshake message (Client Hello, or protocol violation) */\n\tif ((s->s3->handshake_fragment_len >= 4) &&\t!s->in_handshake)\n\t\t{\n\t\tif (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&\n\t\t\t!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))\n\t\t\t{\n#if 0 /* worked only because C operator preferences are not as expected (and\n       * because this is not really needed for clients except for detecting\n       * protocol violations): */\n\t\t\ts->state=SSL_ST_BEFORE|(s->server)\n\t\t\t\t?SSL_ST_ACCEPT\n\t\t\t\t:SSL_ST_CONNECT;\n#else\n\t\t\ts->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;\n#endif\n\t\t\ts->renegotiate=1;\n\t\t\ts->new_session=1;\n\t\t\t}\n\t\ti=s->handshake_func(s);\n\t\tif (i < 0) return(i);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);\n\t\t\treturn(-1);\n\t\t\t}\n\n\t\tif (!(s->mode & SSL_MODE_AUTO_RETRY))\n\t\t\t{\n\t\t\tif (s->s3->rbuf.left == 0) /* no read-ahead left? */\n\t\t\t\t{\n\t\t\t\tBIO *bio;\n\t\t\t\t/* In the case where we try to read application data,\n\t\t\t\t * but we trigger an SSL handshake, we return -1 with\n\t\t\t\t * the retry option set.  Otherwise renegotiation may\n\t\t\t\t * cause nasty problems in the blocking world */\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\tbio=SSL_get_rbio(s);\n\t\t\t\tBIO_clear_retry_flags(bio);\n\t\t\t\tBIO_set_retry_read(bio);\n\t\t\t\treturn(-1);\n\t\t\t\t}\n\t\t\t}\n\t\tgoto start;\n\t\t}\n\n\tswitch (rr->type)\n\t\t{\n\tdefault:\n#ifndef OPENSSL_NO_TLS\n\t\t/* TLS up to v1.1 just ignores unknown message types:\n\t\t * TLS v1.2 give an unexpected message alert.\n\t\t */\n\t\tif (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION)\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\tgoto start;\n\t\t\t}\n#endif\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\tgoto f_err;\n\tcase SSL3_RT_CHANGE_CIPHER_SPEC:\n\tcase SSL3_RT_ALERT:\n\tcase SSL3_RT_HANDSHAKE:\n\t\t/* we already handled all of these, with the possible exception\n\t\t * of SSL3_RT_HANDSHAKE when s->in_handshake is set, but that\n\t\t * should not happen when type != rr->type */\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tSSLerr(SSL_F_SSL3_READ_BYTES,ERR_R_INTERNAL_ERROR);\n\t\tgoto f_err;\n\tcase SSL3_RT_APPLICATION_DATA:\n\t\t/* At this point, we were expecting handshake data,\n\t\t * but have application data.  If the library was\n\t\t * running inside ssl3_read() (i.e. in_read_app_data\n\t\t * is set) and it makes sense to read application data\n\t\t * at this point (session renegotiation not yet started),\n\t\t * we will indulge it.\n\t\t */\n\t\tif (s->s3->in_read_app_data &&\n\t\t\t(s->s3->total_renegotiations != 0) &&\n\t\t\t((\n\t\t\t\t(s->state & SSL_ST_CONNECT) &&\n\t\t\t\t(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&\n\t\t\t\t(s->state <= SSL3_ST_CR_SRVR_HELLO_A)\n\t\t\t\t) || (\n\t\t\t\t\t(s->state & SSL_ST_ACCEPT) &&\n\t\t\t\t\t(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&\n\t\t\t\t\t(s->state >= SSL3_ST_SR_CLNT_HELLO_A)\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t{\n\t\t\ts->s3->in_read_app_data=2;\n\t\t\treturn(-1);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_READ_BYTES,SSL_R_UNEXPECTED_RECORD);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\t/* not reached */\n\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\treturn(-1);\n\t}\n",
        "output": "0",
        "index": 94702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScreenSaverSetAttributes(ClientPtr client)\n{\n    REQUEST(xScreenSaverSetAttributesReq);\n    DrawablePtr pDraw;\n    WindowPtr pParent;\n    ScreenPtr pScreen;\n    ScreenSaverScreenPrivatePtr pPriv = 0;\n    ScreenSaverAttrPtr pAttr = 0;\n    int ret, len, class, bw, depth;\n    unsigned long visual;\n    int idepth, ivisual;\n    Bool fOK;\n    DepthPtr pDepth;\n    WindowOptPtr ancwopt;\n    unsigned int *pVlist;\n    unsigned long *values = 0;\n    unsigned long tmask, imask;\n    unsigned long val;\n    Pixmap pixID;\n    PixmapPtr pPixmap;\n    Cursor cursorID;\n    CursorPtr pCursor;\n    Colormap cmap;\n    ColormapPtr pCmap;\n\n    REQUEST_AT_LEAST_SIZE(xScreenSaverSetAttributesReq);\n    ret = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,\n                            DixGetAttrAccess);\n    if (ret != Success)\n        return ret;\n    pScreen = pDraw->pScreen;\n    pParent = pScreen->root;\n\n    ret = XaceHook(XACE_SCREENSAVER_ACCESS, client, pScreen, DixSetAttrAccess);\n    if (ret != Success)\n        return ret;\n\n    len = stuff->length - bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));\n    if (Ones(stuff->mask) != len)\n        return BadLength;\n    if (!stuff->width || !stuff->height) {\n        client->errorValue = 0;\n        return BadValue;\n    }\n    switch (class = stuff->c_class) {\n    case CopyFromParent:\n    case InputOnly:\n    case InputOutput:\n        break;\n    default:\n        client->errorValue = class;\n        return BadValue;\n    }\n    bw = stuff->borderWidth;\n    depth = stuff->depth;\n    visual = stuff->visualID;\n\n    /* copied directly from CreateWindow */\n\n    if (class == CopyFromParent)\n        class = pParent->drawable.class;\n\n    if ((class != InputOutput) && (class != InputOnly)) {\n        client->errorValue = class;\n        return BadValue;\n    }\n\n    if ((class != InputOnly) && (pParent->drawable.class == InputOnly))\n        return BadMatch;\n\n    if ((class == InputOnly) && ((bw != 0) || (depth != 0)))\n        return BadMatch;\n\n    if ((class == InputOutput) && (depth == 0))\n        depth = pParent->drawable.depth;\n    ancwopt = pParent->optional;\n    if (!ancwopt)\n        ancwopt = FindWindowWithOptional(pParent)->optional;\n    if (visual == CopyFromParent)\n        visual = ancwopt->visual;\n\n    /* Find out if the depth and visual are acceptable for this Screen */\n    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth)) {\n        fOK = FALSE;\n        for (idepth = 0; idepth < pScreen->numDepths; idepth++) {\n            pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];\n            if ((depth == pDepth->depth) || (depth == 0)) {\n                for (ivisual = 0; ivisual < pDepth->numVids; ivisual++) {\n                    if (visual == pDepth->vids[ivisual]) {\n                        fOK = TRUE;\n                        break;\n                    }\n                }\n            }\n        }\n        if (fOK == FALSE)\n            return BadMatch;\n    }\n\n    if (((stuff->mask & (CWBorderPixmap | CWBorderPixel)) == 0) &&\n        (class != InputOnly) && (depth != pParent->drawable.depth)) {\n        return BadMatch;\n    }\n\n    if (((stuff->mask & CWColormap) == 0) &&\n        (class != InputOnly) &&\n        ((visual != ancwopt->visual) || (ancwopt->colormap == None))) {\n        return BadMatch;\n    }\n\n    /* end of errors from CreateWindow */\n\n    pPriv = GetScreenPrivate(pScreen);\n    if (pPriv && pPriv->attr) {\n        if (pPriv->attr->client != client)\n            return BadAccess;\n    }\n    if (!pPriv) {\n        pPriv = MakeScreenPrivate(pScreen);\n        if (!pPriv)\n            return FALSE;\n    }\n    pAttr = New(ScreenSaverAttrRec);\n    if (!pAttr) {\n        ret = BadAlloc;\n        goto bail;\n    }\n    /* over allocate for override redirect */\n    pAttr->values = values = xallocarray(len + 1, sizeof(unsigned long));\n    if (!values) {\n        ret = BadAlloc;\n        goto bail;\n    }\n    pAttr->screen = pScreen;\n    pAttr->client = client;\n    pAttr->x = stuff->x;\n    pAttr->y = stuff->y;\n    pAttr->width = stuff->width;\n    pAttr->height = stuff->height;\n    pAttr->borderWidth = stuff->borderWidth;\n    pAttr->class = stuff->c_class;\n    pAttr->depth = depth;\n    pAttr->visual = visual;\n    pAttr->colormap = None;\n    pAttr->pCursor = NullCursor;\n    pAttr->pBackgroundPixmap = NullPixmap;\n    pAttr->pBorderPixmap = NullPixmap;\n    /*\n     * go through the mask, checking the values,\n     * looking up pixmaps and cursors and hold a reference\n     * to them.\n     */\n    pAttr->mask = tmask = stuff->mask | CWOverrideRedirect;\n    pVlist = (unsigned int *) (stuff + 1);\n    while (tmask) {\n        imask = lowbit(tmask);\n        tmask &= ~imask;\n        switch (imask) {\n        case CWBackPixmap:\n            pixID = (Pixmap) * pVlist;\n            if (pixID == None) {\n                *values++ = None;\n            }\n            else if (pixID == ParentRelative) {\n                if (depth != pParent->drawable.depth) {\n                    ret = BadMatch;\n                    goto PatchUp;\n                }\n                *values++ = ParentRelative;\n            }\n            else {\n                ret =\n                    dixLookupResourceByType((void **) &pPixmap, pixID,\n                                            RT_PIXMAP, client, DixReadAccess);\n                if (ret == Success) {\n                    if ((pPixmap->drawable.depth != depth) ||\n                        (pPixmap->drawable.pScreen != pScreen)) {\n                        ret = BadMatch;\n                        goto PatchUp;\n                    }\n                    pAttr->pBackgroundPixmap = pPixmap;\n                    pPixmap->refcnt++;\n                    pAttr->mask &= ~CWBackPixmap;\n                }\n                else {\n                    client->errorValue = pixID;\n                    goto PatchUp;\n                }\n            }\n            break;\n        case CWBackPixel:\n            *values++ = (CARD32) *pVlist;\n            break;\n        case CWBorderPixmap:\n            pixID = (Pixmap) * pVlist;\n            if (pixID == CopyFromParent) {\n                if (depth != pParent->drawable.depth) {\n                    ret = BadMatch;\n                    goto PatchUp;\n                }\n                *values++ = CopyFromParent;\n            }\n            else {\n                ret =\n                    dixLookupResourceByType((void **) &pPixmap, pixID,\n                                            RT_PIXMAP, client, DixReadAccess);\n                if (ret == Success) {\n                    if ((pPixmap->drawable.depth != depth) ||\n                        (pPixmap->drawable.pScreen != pScreen)) {\n                        ret = BadMatch;\n                        goto PatchUp;\n                    }\n                    pAttr->pBorderPixmap = pPixmap;\n                    pPixmap->refcnt++;\n                    pAttr->mask &= ~CWBorderPixmap;\n                }\n                else {\n                    client->errorValue = pixID;\n                    goto PatchUp;\n                }\n            }\n            break;\n        case CWBorderPixel:\n            *values++ = (CARD32) *pVlist;\n            break;\n        case CWBitGravity:\n            val = (CARD8) *pVlist;\n            if (val > StaticGravity) {\n                ret = BadValue;\n                client->errorValue = val;\n                goto PatchUp;\n            }\n            *values++ = val;\n            break;\n        case CWWinGravity:\n            val = (CARD8) *pVlist;\n            if (val > StaticGravity) {\n                ret = BadValue;\n                client->errorValue = val;\n                goto PatchUp;\n            }\n            *values++ = val;\n            break;\n        case CWBackingStore:\n            val = (CARD8) *pVlist;\n            if ((val != NotUseful) && (val != WhenMapped) && (val != Always)) {\n                ret = BadValue;\n                client->errorValue = val;\n                goto PatchUp;\n            }\n            *values++ = val;\n            break;\n        case CWBackingPlanes:\n            *values++ = (CARD32) *pVlist;\n            break;\n        case CWBackingPixel:\n            *values++ = (CARD32) *pVlist;\n            break;\n        case CWSaveUnder:\n            val = (BOOL) * pVlist;\n            if ((val != xTrue) && (val != xFalse)) {\n                ret = BadValue;\n                client->errorValue = val;\n                goto PatchUp;\n            }\n            *values++ = val;\n            break;\n        case CWEventMask:\n            *values++ = (CARD32) *pVlist;\n            break;\n        case CWDontPropagate:\n            *values++ = (CARD32) *pVlist;\n            break;\n        case CWOverrideRedirect:\n            if (!(stuff->mask & CWOverrideRedirect))\n                pVlist--;\n            else {\n                val = (BOOL) * pVlist;\n                if ((val != xTrue) && (val != xFalse)) {\n                    ret = BadValue;\n                    client->errorValue = val;\n                    goto PatchUp;\n                }\n            }\n            *values++ = xTrue;\n            break;\n        case CWColormap:\n            cmap = (Colormap) * pVlist;\n            ret = dixLookupResourceByType((void **) &pCmap, cmap, RT_COLORMAP,\n                                          client, DixUseAccess);\n            if (ret != Success) {\n                client->errorValue = cmap;\n                goto PatchUp;\n            }\n            if (pCmap->pVisual->vid != visual || pCmap->pScreen != pScreen) {\n                ret = BadMatch;\n                goto PatchUp;\n            }\n            pAttr->colormap = cmap;\n            pAttr->mask &= ~CWColormap;\n            break;\n        case CWCursor:\n            cursorID = (Cursor) * pVlist;\n            if (cursorID == None) {\n                *values++ = None;\n            }\n            else {\n                ret = dixLookupResourceByType((void **) &pCursor, cursorID,\n                                              RT_CURSOR, client, DixUseAccess);\n                if (ret != Success) {\n                    client->errorValue = cursorID;\n                    goto PatchUp;\n                }\n                pAttr->pCursor = RefCursor(pCursor);\n                pAttr->mask &= ~CWCursor;\n            }\n            break;\n        default:\n            ret = BadValue;\n            client->errorValue = stuff->mask;\n            goto PatchUp;\n        }\n        pVlist++;\n    }\n    if (pPriv->attr)\n        FreeScreenAttr(pPriv->attr);\n    pPriv->attr = pAttr;\n    pAttr->resource = FakeClientID(client->index);\n    if (!AddResource(pAttr->resource, AttrType, (void *) pAttr))\n        return BadAlloc;\n    return Success;\n PatchUp:\n    FreeAttrs(pAttr);\n bail:\n    CheckScreenPrivate(pScreen);\n    if (pAttr)\n        free(pAttr->values);\n    free(pAttr);\n    return ret;\n}\n",
        "output": "0",
        "index": 17421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct ppp_file *pf;\n\tstruct ppp *ppp;\n\tint err = -EFAULT, val, val2, i;\n\tstruct ppp_idle idle;\n\tstruct npioctl npi;\n\tint unit, cflags;\n\tstruct slcompress *vj;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\n\tmutex_lock(&ppp_mutex);\n\n\tpf = file->private_data;\n\tif (!pf) {\n\t\terr = ppp_unattached_ioctl(current->nsproxy->net_ns,\n\t\t\t\t\t   pf, file, cmd, arg);\n\t\tgoto out;\n\t}\n\n\tif (cmd == PPPIOCDETACH) {\n\t\t/*\n\t\t * We have to be careful here... if the file descriptor\n\t\t * has been dup'd, we could have another process in the\n\t\t * middle of a poll using the same file *, so we had\n\t\t * better not free the interface data structures -\n\t\t * instead we fail the ioctl.  Even in this case, we\n\t\t * shut down the interface if we are the owner of it.\n\t\t * Actually, we should get rid of PPPIOCDETACH, userland\n\t\t * (i.e. pppd) could achieve the same effect by closing\n\t\t * this fd and reopening /dev/ppp.\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tppp = PF_TO_PPP(pf);\n\t\t\trtnl_lock();\n\t\t\tif (file == ppp->owner)\n\t\t\t\tunregister_netdevice(ppp->dev);\n\t\t\trtnl_unlock();\n\t\t}\n\t\tif (atomic_long_read(&file->f_count) < 2) {\n\t\t\tppp_release(NULL, file);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tpr_warn(\"PPPIOCDETACH file->f_count=%ld\\n\",\n\t\t\t\tatomic_long_read(&file->f_count));\n\t\tgoto out;\n\t}\n\n\tif (pf->kind == CHANNEL) {\n\t\tstruct channel *pch;\n\t\tstruct ppp_channel *chan;\n\n\t\tpch = PF_TO_CHANNEL(pf);\n\n\t\tswitch (cmd) {\n\t\tcase PPPIOCCONNECT:\n\t\t\tif (get_user(unit, p))\n\t\t\t\tbreak;\n\t\t\terr = ppp_connect_channel(pch, unit);\n\t\t\tbreak;\n\n\t\tcase PPPIOCDISCONN:\n\t\t\terr = ppp_disconnect_channel(pch);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdown_read(&pch->chan_sem);\n\t\t\tchan = pch->chan;\n\t\t\terr = -ENOTTY;\n\t\t\tif (chan && chan->ops->ioctl)\n\t\t\t\terr = chan->ops->ioctl(chan, cmd, arg);\n\t\t\tup_read(&pch->chan_sem);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (pf->kind != INTERFACE) {\n\t\t/* can't happen */\n\t\tpr_err(\"PPP: not interface or channel??\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tppp = PF_TO_PPP(pf);\n\tswitch (cmd) {\n\tcase PPPIOCSMRU:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp->mru = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSFLAGS:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp_lock(ppp);\n\t\tcflags = ppp->flags & ~val;\n#ifdef CONFIG_PPP_MULTILINK\n\t\tif (!(ppp->flags & SC_MULTILINK) && (val & SC_MULTILINK))\n\t\t\tppp->nextseq = 0;\n#endif\n\t\tppp->flags = val & SC_FLAG_BITS;\n\t\tppp_unlock(ppp);\n\t\tif (cflags & SC_CCP_OPEN)\n\t\t\tppp_ccp_closed(ppp);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGFLAGS:\n\t\tval = ppp->flags | ppp->xstate | ppp->rstate;\n\t\tif (put_user(val, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSCOMPRESS:\n\t\terr = ppp_set_compress(ppp, arg);\n\t\tbreak;\n\n\tcase PPPIOCGUNIT:\n\t\tif (put_user(ppp->file.index, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSDEBUG:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp->debug = val;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGDEBUG:\n\t\tif (put_user(ppp->debug, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGIDLE:\n\t\tidle.xmit_idle = (jiffies - ppp->last_xmit) / HZ;\n\t\tidle.recv_idle = (jiffies - ppp->last_recv) / HZ;\n\t\tif (copy_to_user(argp, &idle, sizeof(idle)))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCSMAXCID:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tval2 = 15;\n\t\tif ((val >> 16) != 0) {\n\t\t\tval2 = val >> 16;\n\t\t\tval &= 0xffff;\n\t\t}\n\t\tvj = slhc_init(val2+1, val+1);\n\t\tif (IS_ERR(vj)) {\n\t\t\terr = PTR_ERR(vj);\n\t\t\tbreak;\n\t\t}\n\t\tppp_lock(ppp);\n\t\tif (ppp->vj)\n\t\t\tslhc_free(ppp->vj);\n\t\tppp->vj = vj;\n\t\tppp_unlock(ppp);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase PPPIOCGNPMODE:\n\tcase PPPIOCSNPMODE:\n\t\tif (copy_from_user(&npi, argp, sizeof(npi)))\n\t\t\tbreak;\n\t\terr = proto_to_npindex(npi.protocol);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\ti = err;\n\t\tif (cmd == PPPIOCGNPMODE) {\n\t\t\terr = -EFAULT;\n\t\t\tnpi.mode = ppp->npmode[i];\n\t\t\tif (copy_to_user(argp, &npi, sizeof(npi)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tppp->npmode[i] = npi.mode;\n\t\t\t/* we may be able to transmit more packets now (??) */\n\t\t\tnetif_wake_queue(ppp->dev);\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n#ifdef CONFIG_PPP_FILTER\n\tcase PPPIOCSPASS:\n\t{\n\t\tstruct sock_filter *code;\n\n\t\terr = get_filter(argp, &code);\n\t\tif (err >= 0) {\n\t\t\tstruct bpf_prog *pass_filter = NULL;\n\t\t\tstruct sock_fprog_kern fprog = {\n\t\t\t\t.len = err,\n\t\t\t\t.filter = code,\n\t\t\t};\n\n\t\t\terr = 0;\n\t\t\tif (fprog.filter)\n\t\t\t\terr = bpf_prog_create(&pass_filter, &fprog);\n\t\t\tif (!err) {\n\t\t\t\tppp_lock(ppp);\n\t\t\t\tif (ppp->pass_filter)\n\t\t\t\t\tbpf_prog_destroy(ppp->pass_filter);\n\t\t\t\tppp->pass_filter = pass_filter;\n\t\t\t\tppp_unlock(ppp);\n\t\t\t}\n\t\t\tkfree(code);\n\t\t}\n\t\tbreak;\n\t}\n\tcase PPPIOCSACTIVE:\n\t{\n\t\tstruct sock_filter *code;\n\n\t\terr = get_filter(argp, &code);\n\t\tif (err >= 0) {\n\t\t\tstruct bpf_prog *active_filter = NULL;\n\t\t\tstruct sock_fprog_kern fprog = {\n\t\t\t\t.len = err,\n\t\t\t\t.filter = code,\n\t\t\t};\n\n\t\t\terr = 0;\n\t\t\tif (fprog.filter)\n\t\t\t\terr = bpf_prog_create(&active_filter, &fprog);\n\t\t\tif (!err) {\n\t\t\t\tppp_lock(ppp);\n\t\t\t\tif (ppp->active_filter)\n\t\t\t\t\tbpf_prog_destroy(ppp->active_filter);\n\t\t\t\tppp->active_filter = active_filter;\n\t\t\t\tppp_unlock(ppp);\n\t\t\t}\n\t\t\tkfree(code);\n\t\t}\n\t\tbreak;\n\t}\n#endif /* CONFIG_PPP_FILTER */\n\n#ifdef CONFIG_PPP_MULTILINK\n\tcase PPPIOCSMRRU:\n\t\tif (get_user(val, p))\n\t\t\tbreak;\n\t\tppp_recv_lock(ppp);\n\t\tppp->mrru = val;\n\t\tppp_recv_unlock(ppp);\n\t\terr = 0;\n\t\tbreak;\n#endif /* CONFIG_PPP_MULTILINK */\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\nout:\n\tmutex_unlock(&ppp_mutex);\n\n\treturn err;\n}\n",
        "output": "0",
        "index": 52635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int recv_files(int f_in, int f_out, char *local_name)\n{\n\tint fd1,fd2;\n\tSTRUCT_STAT st;\n\tint iflags, xlen;\n\tchar *fname, fbuf[MAXPATHLEN];\n\tchar xname[MAXPATHLEN];\n\tchar fnametmp[MAXPATHLEN];\n\tchar *fnamecmp, *partialptr;\n\tchar fnamecmpbuf[MAXPATHLEN];\n\tuchar fnamecmp_type;\n\tstruct file_struct *file;\n\tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;\n\tenum logcode log_code = log_before_transfer ? FLOG : FINFO;\n\tint max_phase = protocol_version >= 29 ? 2 : 1;\n\tint dflt_perms = (ACCESSPERMS & ~orig_umask);\n#ifdef SUPPORT_ACLS\n\tconst char *parent_dirname = \"\";\n#endif\n\tint ndx, recv_ok;\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO, \"recv_files(%d) starting\\n\", cur_flist->used);\n\n\tif (delay_updates)\n\t\tdelayed_bits = bitbag_create(cur_flist->used + 1);\n\n\twhile (1) {\n\t\tcleanup_disable();\n\n\t\t/* This call also sets cur_flist. */\n\t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,\n\t\t\t\t\t xname, &xlen);\n\t\tif (ndx == NDX_DONE) {\n\t\t\tif (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {\n\t\t\t\tset_current_file_index(NULL, 0);\n\t\t\t\tend_progress(0);\n\t\t\t}\n\t\t\tif (inc_recurse && first_flist) {\n\t\t\t\tif (read_batch) {\n\t\t\t\t\tndx = first_flist->used + first_flist->ndx_start;\n\t\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t\t}\n\t\t\t\tflist_free(first_flist);\n\t\t\t\tif (first_flist)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (read_batch && first_flist) {\n\t\t\t\tndx = first_flist->used;\n\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);\n\t\t\t}\n\t\t\tif (++phase > max_phase)\n\t\t\t\tbreak;\n\t\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\t\trprintf(FINFO, \"recv_files phase=%d\\n\", phase);\n\t\t\tif (phase == 2 && delay_updates)\n\t\t\t\thandle_delayed_updates(local_name);\n\t\t\twrite_int(f_out, NDX_DONE);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ndx - cur_flist->ndx_start >= 0)\n\t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];\n\t\telse\n\t\t\tfile = dir_flist->files[cur_flist->parent_ndx];\n\t\tfname = local_name ? local_name : f_name(file, fbuf);\n\n\t\tif (daemon_filter_list.head\n\t\t    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {\n\t\t\trprintf(FERROR, \"attempt to hack rsync failed.\\n\");\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (DEBUG_GTE(RECV, 1))\n\t\t\trprintf(FINFO, \"recv_files(%s)\\n\", fname);\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))\n\t\t\trecv_xattr_request(file, f_in);\n#endif\n\n\t\tif (!(iflags & ITEM_TRANSFER)) {\n\t\t\tmaybe_log_item(file, iflags, itemizing, xname);\n#ifdef SUPPORT_XATTRS\n\t\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers\n\t\t\t && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))\n\t\t\t\tset_file_attrs(fname, file, NULL, fname, 0);\n#endif\n\t\t\tif (iflags & ITEM_IS_NEW) {\n\t\t\t\tstats.created_files++;\n\t\t\t\tif (S_ISREG(file->mode)) {\n\t\t\t\t\t/* Nothing further to count. */\n\t\t\t\t} else if (S_ISDIR(file->mode))\n\t\t\t\t\tstats.created_dirs++;\n#ifdef SUPPORT_LINKS\n\t\t\t\telse if (S_ISLNK(file->mode))\n\t\t\t\t\tstats.created_symlinks++;\n#endif\n\t\t\t\telse if (IS_DEVICE(file->mode))\n\t\t\t\t\tstats.created_devices++;\n\t\t\t\telse\n\t\t\t\t\tstats.created_specials++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (phase == 2) {\n\t\t\trprintf(FERROR,\n\t\t\t\t\"got transfer request in phase 2 [%s]\\n\",\n\t\t\t\twho_am_i());\n\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t}\n\n\t\tif (file->flags & FLAG_FILE_SENT) {\n\t\t\tif (csum_length == SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups; /* prevents double backup */\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SUM_LENGTH;\n\t\t\t\tredoing = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (csum_length != SHORT_SUM_LENGTH) {\n\t\t\t\tif (keep_partial && !partial_dir)\n\t\t\t\t\tmake_backups = -make_backups;\n\t\t\t\tif (append_mode)\n\t\t\t\t\tsparse_files = -sparse_files;\n\t\t\t\tappend_mode = -append_mode;\n\t\t\t\tcsum_length = SHORT_SUM_LENGTH;\n\t\t\t\tredoing = 0;\n\t\t\t}\n\t\t\tif (iflags & ITEM_IS_NEW)\n\t\t\t\tstats.created_files++;\n\t\t}\n\n\t\tif (!am_server && INFO_GTE(PROGRESS, 1))\n\t\t\tset_current_file_index(file, ndx);\n\t\tstats.xferred_files++;\n\t\tstats.total_transferred_size += F_LENGTH(file);\n\n\t\tcleanup_got_literal = 0;\n\n\t\tif (read_batch) {\n\t\t\tint wanted = redoing\n\t\t\t\t   ? we_want_redo(ndx)\n\t\t\t\t   : gen_wants_ndx(ndx, cur_flist->flist_num);\n\t\t\tif (!wanted) {\n\t\t\t\trprintf(FINFO,\n\t\t\t\t\t\"(Skipping batched update for%s \\\"%s\\\")\\n\",\n\t\t\t\t\tredoing ? \" resend of\" : \"\",\n\t\t\t\t\tfname);\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tremember_initial_stats();\n\n\t\tif (!do_xfers) { /* log the transfer */\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (read_batch)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tcontinue;\n\t\t}\n\t\tif (write_batch < 0) {\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\t\tif (!am_server)\n\t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpartialptr = partial_dir ? partial_dir_fname(fname) : fname;\n\n\t\tif (protocol_version >= 29) {\n\t\t\tswitch (fnamecmp_type) {\n\t\t\tcase FNAMECMP_FNAME:\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_PARTIAL_DIR:\n\t\t\t\tfnamecmp = partialptr;\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_BACKUP:\n\t\t\t\tfnamecmp = get_backup_name(fname);\n\t\t\t\tbreak;\n\t\t\tcase FNAMECMP_FUZZY:\n\t\t\t\tif (file->dirname) {\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);\n\t\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\t} else\n\t\t\t\t\tfnamecmp = xname;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {\n\t\t\t\t\tfnamecmp_type -= FNAMECMP_FUZZY + 1;\n\t\t\t\t\tif (file->dirname) {\n\t\t\t\t\t\tstringjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t\t\t   basis_dir[fnamecmp_type], \"/\", file->dirname, \"/\", xname, NULL);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);\n\t\t\t\t} else if (fnamecmp_type >= basis_dir_cnt) {\n\t\t\t\t\trprintf(FERROR,\n\t\t\t\t\t\t\"invalid basis_dir index: %d.\\n\",\n\t\t\t\t\t\tfnamecmp_type);\n\t\t\t\t\texit_cleanup(RERR_PROTOCOL);\n\t\t\t\t} else\n\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n                                break;\n                        }\n                        if (!fnamecmp || (daemon_filter_list.head\n                         && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {\n                                fnamecmp = fname;\n                                fnamecmp_type = FNAMECMP_FNAME;\n                        }\n\t\t} else {\n\t\t\t/* Reminder: --inplace && --partial-dir are never\n\t\t\t * enabled at the same time. */\n\t\t\tif (inplace && make_backups > 0) {\n\t\t\t\tif (!(fnamecmp = get_backup_name(fname)))\n\t\t\t\t\tfnamecmp = fname;\n\t\t\t\telse\n\t\t\t\t\tfnamecmp_type = FNAMECMP_BACKUP;\n\t\t\t} else if (partial_dir && partialptr)\n\t\t\t\tfnamecmp = partialptr;\n\t\t\telse\n\t\t\t\tfnamecmp = fname;\n\t\t}\n\n\t\t/* open the file */\n\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\n\t\tif (fd1 == -1 && protocol_version < 29) {\n\t\t\tif (fnamecmp != fname) {\n\t\t\t\tfnamecmp = fname;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\n\t\t\tif (fd1 == -1 && basis_dir[0]) {\n\t\t\t\t/* pre-29 allowed only one alternate basis */\n\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf,\n\t\t\t\t\t basis_dir[0], fname);\n\t\t\t\tfnamecmp = fnamecmpbuf;\n\t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);\n\t\t\t}\n\t\t}\n\n\t\tupdating_basis_or_equiv = inplace\n\t\t    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);\n\n\t\tif (fd1 == -1) {\n\t\t\tst.st_mode = 0;\n\t\t\tst.st_size = 0;\n\t\t} else if (do_fstat(fd1,&st) != 0) {\n\t\t\trsyserr(FERROR_XFER, errno, \"fstat %s failed\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {\n\t\t\t/* this special handling for directories\n\t\t\t * wouldn't be necessary if robust_rename()\n\t\t\t * and the underlying robust_unlink could cope\n\t\t\t * with directories\n\t\t\t */\n\t\t\trprintf(FERROR_XFER, \"recv_files: %s is a directory\\n\",\n\t\t\t\tfull_fname(fnamecmp));\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fd1 != -1 && !S_ISREG(st.st_mode)) {\n\t\t\tclose(fd1);\n\t\t\tfd1 = -1;\n\t\t}\n\n\t\t/* If we're not preserving permissions, change the file-list's\n\t\t * mode based on the local permissions and some heuristics. */\n\t\tif (!preserve_perms) {\n\t\t\tint exists = fd1 != -1;\n#ifdef SUPPORT_ACLS\n\t\t\tconst char *dn = file->dirname ? file->dirname : \".\";\n\t\t\tif (parent_dirname != dn\n\t\t\t && strcmp(parent_dirname, dn) != 0) {\n\t\t\t\tdflt_perms = default_perms_for_dir(dn);\n\t\t\t\tparent_dirname = dn;\n\t\t\t}\n#endif\n\t\t\tfile->mode = dest_mode(file->mode, st.st_mode,\n\t\t\t\t\t       dflt_perms, exists);\n\t\t}\n\n\t\t/* We now check to see if we are writing the file \"inplace\" */\n\t\tif (inplace)  {\n\t\t\tfd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);\n\t\t\tif (fd2 == -1) {\n\t\t\t\trsyserr(FERROR_XFER, errno, \"open %s failed\",\n\t\t\t\t\tfull_fname(fname));\n\t\t\t} else if (updating_basis_or_equiv)\n\t\t\t\tcleanup_set(NULL, NULL, file, fd1, fd2);\n\t\t} else {\n\t\t\tfd2 = open_tmpfile(fnametmp, fname, file);\n\t\t\tif (fd2 != -1)\n\t\t\t\tcleanup_set(fnametmp, partialptr, file, fd1, fd2);\n\t\t}\n\n\t\tif (fd2 == -1) {\n\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));\n\t\t\tif (fd1 != -1)\n\t\t\t\tclose(fd1);\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* log the transfer */\n\t\tif (log_before_transfer)\n\t\t\tlog_item(FCLIENT, file, iflags, NULL);\n\t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))\n\t\t\trprintf(FINFO, \"%s\\n\", fname);\n\n\t\t/* recv file data */\n\t\trecv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,\n\t\t\t\t       fname, fd2, F_LENGTH(file));\n\n\t\tlog_item(log_code, file, iflags, NULL);\n\n\t\tif (fd1 != -1)\n\t\t\tclose(fd1);\n\t\tif (close(fd2) < 0) {\n\t\t\trsyserr(FERROR, errno, \"close failed on %s\",\n\t\t\t\tfull_fname(fnametmp));\n\t\t\texit_cleanup(RERR_FILEIO);\n\t\t}\n\n\t\tif ((recv_ok && (!delay_updates || !partialptr)) || inplace) {\n\t\t\tif (partialptr == fname)\n\t\t\t\tpartialptr = NULL;\n\t\t\tif (!finish_transfer(fname, fnametmp, fnamecmp,\n\t\t\t\t\t     partialptr, file, recv_ok, 1))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (fnamecmp == partialptr) {\n\t\t\t\tdo_unlink(partialptr);\n\t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);\n\t\t\t}\n\t\t} else if (keep_partial && partialptr) {\n\t\t\tif (!handle_partial_dir(partialptr, PDIR_CREATE)) {\n\t\t\t\trprintf(FERROR,\n\t\t\t\t    \"Unable to create partial-dir for %s -- discarding %s.\\n\",\n\t\t\t\t    local_name ? local_name : f_name(file, NULL),\n\t\t\t\t    recv_ok ? \"completed file\" : \"partial file\");\n\t\t\t\tdo_unlink(fnametmp);\n\t\t\t\trecv_ok = -1;\n\t\t\t} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,\n\t\t\t\t\t\t    file, recv_ok, !partial_dir))\n\t\t\t\trecv_ok = -1;\n\t\t\telse if (delay_updates && recv_ok) {\n\t\t\t\tbitbag_set_bit(delayed_bits, ndx);\n\t\t\t\trecv_ok = 2;\n\t\t\t} else\n\t\t\t\tpartialptr = NULL;\n\t\t} else\n\t\t\tdo_unlink(fnametmp);\n\n\t\tcleanup_disable();\n\n\t\tif (read_batch)\n\t\t\tfile->flags |= FLAG_FILE_SENT;\n\n\t\tswitch (recv_ok) {\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (remove_source_files || inc_recurse\n\t\t\t || (preserve_hard_links && F_IS_HLINKED(file)))\n\t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);\n\t\t\tbreak;\n\t\tcase 0: {\n\t\t\tenum logcode msgtype = redoing ? FERROR_XFER : FWARNING;\n\t\t\tif (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {\n\t\t\t\tchar *errstr, *redostr, *keptstr;\n\t\t\t\tif (!(keep_partial && partialptr) && !inplace)\n\t\t\t\t\tkeptstr = \"discarded\";\n\t\t\t\telse if (partial_dir)\n\t\t\t\t\tkeptstr = \"put into partial-dir\";\n\t\t\t\telse\n\t\t\t\t\tkeptstr = \"retained\";\n\t\t\t\tif (msgtype == FERROR_XFER) {\n\t\t\t\t\terrstr = \"ERROR\";\n\t\t\t\t\tredostr = \"\";\n\t\t\t\t} else {\n\t\t\t\t\terrstr = \"WARNING\";\n\t\t\t\t\tredostr = read_batch ? \" (may try again)\"\n\t\t\t\t\t\t\t     : \" (will try again)\";\n\t\t\t\t}\n\t\t\t\trprintf(msgtype,\n\t\t\t\t\t\"%s: %s failed verification -- update %s%s.\\n\",\n\t\t\t\t\terrstr, local_name ? f_name(file, NULL) : fname,\n\t\t\t\t\tkeptstr, redostr);\n\t\t\t}\n\t\t\tif (!redoing) {\n\t\t\t\tif (read_batch)\n\t\t\t\t\tflist_ndx_push(&batch_redo_list, ndx);\n\t\t\t\tsend_msg_int(MSG_REDO, ndx);\n\t\t\t\tfile->flags |= FLAG_FILE_SENT;\n\t\t\t} else if (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t    }\n\t\tcase -1:\n\t\t\tif (inc_recurse)\n\t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (make_backups < 0)\n\t\tmake_backups = -make_backups;\n\n\tif (phase == 2 && delay_updates) /* for protocol_version < 29 */\n\t\thandle_delayed_updates(local_name);\n\n\tif (DEBUG_GTE(RECV, 1))\n\t\trprintf(FINFO,\"recv_files finished\\n\");\n\n\treturn 0;\n}\n",
        "output": "1",
        "index": 177769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)\n{\n\tstruct packet_type *ptype, *pt_prev;\n\trx_handler_func_t *rx_handler;\n\tstruct net_device *orig_dev;\n\tbool deliver_exact = false;\n\tint ret = NET_RX_DROP;\n\t__be16 type;\n\n\tnet_timestamp_check(!netdev_tstamp_prequeue, skb);\n\n\ttrace_netif_receive_skb(skb);\n\n\torig_dev = skb->dev;\n\n\tskb_reset_network_header(skb);\n\tif (!skb_transport_header_was_set(skb))\n\t\tskb_reset_transport_header(skb);\n\tskb_reset_mac_len(skb);\n\n\tpt_prev = NULL;\n\nanother_round:\n\tskb->skb_iif = skb->dev->ifindex;\n\n\t__this_cpu_inc(softnet_data.processed);\n\n\tif (skb->protocol == cpu_to_be16(ETH_P_8021Q) ||\n\t    skb->protocol == cpu_to_be16(ETH_P_8021AD)) {\n\t\tskb = skb_vlan_untag(skb);\n\t\tif (unlikely(!skb))\n\t\t\tgoto out;\n\t}\n\n#ifdef CONFIG_NET_CLS_ACT\n\tif (skb->tc_verd & TC_NCLS) {\n\t\tskb->tc_verd = CLR_TC_NCLS(skb->tc_verd);\n\t\tgoto ncls;\n\t}\n#endif\n\n\tif (pfmemalloc)\n\t\tgoto skip_taps;\n\n\tlist_for_each_entry_rcu(ptype, &ptype_all, list) {\n\t\tif (pt_prev)\n\t\t\tret = deliver_skb(skb, pt_prev, orig_dev);\n\t\tpt_prev = ptype;\n\t}\n\n\tlist_for_each_entry_rcu(ptype, &skb->dev->ptype_all, list) {\n\t\tif (pt_prev)\n\t\t\tret = deliver_skb(skb, pt_prev, orig_dev);\n\t\tpt_prev = ptype;\n\t}\n\nskip_taps:\n#ifdef CONFIG_NET_INGRESS\n\tif (static_key_false(&ingress_needed)) {\n\t\tskb = sch_handle_ingress(skb, &pt_prev, &ret, orig_dev);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (nf_ingress(skb, &pt_prev, &ret, orig_dev) < 0)\n\t\t\tgoto out;\n\t}\n#endif\n#ifdef CONFIG_NET_CLS_ACT\n\tskb->tc_verd = 0;\nncls:\n#endif\n\tif (pfmemalloc && !skb_pfmemalloc_protocol(skb))\n\t\tgoto drop;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tif (pt_prev) {\n\t\t\tret = deliver_skb(skb, pt_prev, orig_dev);\n\t\t\tpt_prev = NULL;\n\t\t}\n\t\tif (vlan_do_receive(&skb))\n\t\t\tgoto another_round;\n\t\telse if (unlikely(!skb))\n\t\t\tgoto out;\n\t}\n\n\trx_handler = rcu_dereference(skb->dev->rx_handler);\n\tif (rx_handler) {\n\t\tif (pt_prev) {\n\t\t\tret = deliver_skb(skb, pt_prev, orig_dev);\n\t\t\tpt_prev = NULL;\n\t\t}\n\t\tswitch (rx_handler(&skb)) {\n\t\tcase RX_HANDLER_CONSUMED:\n\t\t\tret = NET_RX_SUCCESS;\n\t\t\tgoto out;\n\t\tcase RX_HANDLER_ANOTHER:\n\t\t\tgoto another_round;\n\t\tcase RX_HANDLER_EXACT:\n\t\t\tdeliver_exact = true;\n\t\tcase RX_HANDLER_PASS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\tif (unlikely(skb_vlan_tag_present(skb))) {\n\t\tif (skb_vlan_tag_get_id(skb))\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t/* Note: we might in the future use prio bits\n\t\t * and set skb->priority like in vlan_do_receive()\n\t\t * For the time being, just ignore Priority Code Point\n\t\t */\n\t\tskb->vlan_tci = 0;\n\t}\n\n\ttype = skb->protocol;\n\n\t/* deliver only exact match when indicated */\n\tif (likely(!deliver_exact)) {\n\t\tdeliver_ptype_list_skb(skb, &pt_prev, orig_dev, type,\n\t\t\t\t       &ptype_base[ntohs(type) &\n\t\t\t\t\t\t   PTYPE_HASH_MASK]);\n\t}\n\n\tdeliver_ptype_list_skb(skb, &pt_prev, orig_dev, type,\n\t\t\t       &orig_dev->ptype_specific);\n\n\tif (unlikely(skb->dev != orig_dev)) {\n\t\tdeliver_ptype_list_skb(skb, &pt_prev, orig_dev, type,\n\t\t\t\t       &skb->dev->ptype_specific);\n\t}\n\n\tif (pt_prev) {\n\t\tif (unlikely(skb_orphan_frags(skb, GFP_ATOMIC)))\n\t\t\tgoto drop;\n\t\telse\n\t\t\tret = pt_prev->func(skb, skb->dev, pt_prev, orig_dev);\n\t} else {\ndrop:\n\t\tif (!deliver_exact)\n\t\t\tatomic_long_inc(&skb->dev->rx_dropped);\n\t\telse\n\t\t\tatomic_long_inc(&skb->dev->rx_nohandler);\n\t\tkfree_skb(skb);\n\t\t/* Jamal, now you will not able to escape explaining\n\t\t * me how you were going to use this. :-)\n\t\t */\n\t\tret = NET_RX_DROP;\n\t}\n\nout:\n\treturn ret;\n}\n",
        "output": "0",
        "index": 48760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TRBCCode xhci_address_slot(XHCIState *xhci, unsigned int slotid,\n                                  uint64_t pictx, bool bsr)\n{\n    XHCISlot *slot;\n    USBPort *uport;\n    USBDevice *dev;\n    dma_addr_t ictx, octx, dcbaap;\n    uint64_t poctx;\n    uint32_t ictl_ctx[2];\n    uint32_t slot_ctx[4];\n    uint32_t ep0_ctx[5];\n    int i;\n    TRBCCode res;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n\n    dcbaap = xhci_addr64(xhci->dcbaap_low, xhci->dcbaap_high);\n    poctx = ldq_le_pci_dma(PCI_DEVICE(xhci), dcbaap + 8 * slotid);\n    ictx = xhci_mask64(pictx);\n    octx = xhci_mask64(poctx);\n\n    DPRINTF(\"xhci: input context at \"DMA_ADDR_FMT\"\\n\", ictx);\n    DPRINTF(\"xhci: output context at \"DMA_ADDR_FMT\"\\n\", octx);\n\n    xhci_dma_read_u32s(xhci, ictx, ictl_ctx, sizeof(ictl_ctx));\n\n    if (ictl_ctx[0] != 0x0 || ictl_ctx[1] != 0x3) {\n        DPRINTF(\"xhci: invalid input context control %08x %08x\\n\",\n                ictl_ctx[0], ictl_ctx[1]);\n        return CC_TRB_ERROR;\n    }\n\n    xhci_dma_read_u32s(xhci, ictx+32, slot_ctx, sizeof(slot_ctx));\n    xhci_dma_read_u32s(xhci, ictx+64, ep0_ctx, sizeof(ep0_ctx));\n\n    DPRINTF(\"xhci: input slot context: %08x %08x %08x %08x\\n\",\n            slot_ctx[0], slot_ctx[1], slot_ctx[2], slot_ctx[3]);\n\n    DPRINTF(\"xhci: input ep0 context: %08x %08x %08x %08x %08x\\n\",\n            ep0_ctx[0], ep0_ctx[1], ep0_ctx[2], ep0_ctx[3], ep0_ctx[4]);\n\n    uport = xhci_lookup_uport(xhci, slot_ctx);\n    if (uport == NULL) {\n        DPRINTF(\"xhci: port not found\\n\");\n        return CC_TRB_ERROR;\n    }\n    trace_usb_xhci_slot_address(slotid, uport->path);\n\n    dev = uport->dev;\n    if (!dev || !dev->attached) {\n        DPRINTF(\"xhci: port %s not connected\\n\", uport->path);\n        return CC_USB_TRANSACTION_ERROR;\n    }\n\n    for (i = 0; i < xhci->numslots; i++) {\n        if (i == slotid-1) {\n            continue;\n        }\n        if (xhci->slots[i].uport == uport) {\n            DPRINTF(\"xhci: port %s already assigned to slot %d\\n\",\n                    uport->path, i+1);\n            return CC_TRB_ERROR;\n        }\n    }\n\n    slot = &xhci->slots[slotid-1];\n    slot->uport = uport;\n    slot->ctx = octx;\n\n    /* Make sure device is in USB_STATE_DEFAULT state */\n    usb_device_reset(dev);\n    if (bsr) {\n        slot_ctx[3] = SLOT_DEFAULT << SLOT_STATE_SHIFT;\n    } else {\n        USBPacket p;\n        uint8_t buf[1];\n\n        slot_ctx[3] = (SLOT_ADDRESSED << SLOT_STATE_SHIFT) | slotid;\n        memset(&p, 0, sizeof(p));\n        usb_packet_addbuf(&p, buf, sizeof(buf));\n        usb_packet_setup(&p, USB_TOKEN_OUT,\n                         usb_ep_get(dev, USB_TOKEN_OUT, 0), 0,\n                         0, false, false);\n        usb_device_handle_control(dev, &p,\n                                  DeviceOutRequest | USB_REQ_SET_ADDRESS,\n                                  slotid, 0, 0, NULL);\n        assert(p.status != USB_RET_ASYNC);\n    }\n\n    res = xhci_enable_ep(xhci, slotid, 1, octx+32, ep0_ctx);\n\n    DPRINTF(\"xhci: output slot context: %08x %08x %08x %08x\\n\",\n            slot_ctx[0], slot_ctx[1], slot_ctx[2], slot_ctx[3]);\n    DPRINTF(\"xhci: output ep0 context: %08x %08x %08x %08x %08x\\n\",\n            ep0_ctx[0], ep0_ctx[1], ep0_ctx[2], ep0_ctx[3], ep0_ctx[4]);\n\n    xhci_dma_write_u32s(xhci, octx, slot_ctx, sizeof(slot_ctx));\n    xhci_dma_write_u32s(xhci, octx+32, ep0_ctx, sizeof(ep0_ctx));\n\n    xhci->slots[slotid-1].addressed = 1;\n    return res;\n}\n",
        "output": "0",
        "index": 5678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "next_cache_entry(struct archive_read *a, struct iso9660 *iso9660,\n    struct file_info **pfile)\n{\n\tstruct file_info *file;\n\tstruct {\n\t\tstruct file_info\t*first;\n\t\tstruct file_info\t**last;\n\t}\tempty_files;\n\tint64_t number;\n\tint count;\n\n\tfile = cache_get_entry(iso9660);\n\tif (file != NULL) {\n\t\t*pfile = file;\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tfor (;;) {\n\t\tstruct file_info *re, *d;\n\n\t\t*pfile = file = next_entry(iso9660);\n\t\tif (file == NULL) {\n\t\t\t/*\n\t\t\t * If directory entries all which are descendant of\n\t\t\t * rr_moved are stil remaning, expose their. \n\t\t\t */\n\t\t\tif (iso9660->re_files.first != NULL && \n\t\t\t    iso9660->rr_moved != NULL &&\n\t\t\t    iso9660->rr_moved->rr_moved_has_re_only)\n\t\t\t\t/* Expose \"rr_moved\" entry. */\n\t\t\t\tcache_add_entry(iso9660, iso9660->rr_moved);\n\t\t\twhile ((re = re_get_entry(iso9660)) != NULL) {\n\t\t\t\t/* Expose its descendant dirs. */\n\t\t\t\twhile ((d = rede_get_entry(re)) != NULL)\n\t\t\t\t\tcache_add_entry(iso9660, d);\n\t\t\t}\n\t\t\tif (iso9660->cache_files.first != NULL)\n\t\t\t\treturn (next_cache_entry(a, iso9660, pfile));\n\t\t\treturn (ARCHIVE_EOF);\n\t\t}\n\n\t\tif (file->cl_offset) {\n\t\t\tstruct file_info *first_re = NULL;\n\t\t\tint nexted_re = 0;\n\n\t\t\t/*\n\t\t\t * Find \"RE\" dir for the current file, which\n\t\t\t * has \"CL\" flag.\n\t\t\t */\n\t\t\twhile ((re = re_get_entry(iso9660))\n\t\t\t    != first_re) {\n\t\t\t\tif (first_re == NULL)\n\t\t\t\t\tfirst_re = re;\n\t\t\t\tif (re->offset == file->cl_offset) {\n\t\t\t\t\tre->parent->subdirs--;\n\t\t\t\t\tre->parent = file->parent;\n\t\t\t\t\tre->re = 0;\n\t\t\t\t\tif (re->parent->re_descendant) {\n\t\t\t\t\t\tnexted_re = 1;\n\t\t\t\t\t\tre->re_descendant = 1;\n\t\t\t\t\t\tif (rede_add_entry(re) < 0)\n\t\t\t\t\t\t\tgoto fatal_rr;\n\t\t\t\t\t\t/* Move a list of descendants\n\t\t\t\t\t\t * to a new ancestor. */\n\t\t\t\t\t\twhile ((d = rede_get_entry(\n\t\t\t\t\t\t    re)) != NULL)\n\t\t\t\t\t\t\tif (rede_add_entry(d)\n\t\t\t\t\t\t\t    < 0)\n\t\t\t\t\t\t\t\tgoto fatal_rr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* Replace the current file\n\t\t\t\t\t * with \"RE\" dir */\n\t\t\t\t\t*pfile = file = re;\n\t\t\t\t\t/* Expose its descendant */\n\t\t\t\t\twhile ((d = rede_get_entry(\n\t\t\t\t\t    file)) != NULL)\n\t\t\t\t\t\tcache_add_entry(\n\t\t\t\t\t\t    iso9660, d);\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tre_add_entry(iso9660, re);\n\t\t\t}\n\t\t\tif (nexted_re) {\n\t\t\t\t/*\n\t\t\t\t * Do not expose this at this time\n\t\t\t\t * because we have not gotten its full-path\n\t\t\t\t * name yet.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if ((file->mode & AE_IFMT) == AE_IFDIR) {\n\t\t\tint r;\n\n\t\t\t/* Read file entries in this dir. */\n\t\t\tr = read_children(a, file);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\n\t\t\t/*\n\t\t\t * Handle a special dir of Rockridge extensions,\n\t\t\t * \"rr_moved\".\n\t\t\t */\n\t\t\tif (file->rr_moved) {\n\t\t\t\t/*\n\t\t\t\t * If this has only the subdirectories which\n\t\t\t\t * have \"RE\" flags, do not expose at this time.\n\t\t\t\t */\n\t\t\t\tif (file->rr_moved_has_re_only)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Otherwise expose \"rr_moved\" entry. */\n\t\t\t} else if (file->re) {\n\t\t\t\t/*\n\t\t\t\t * Do not expose this at this time\n\t\t\t\t * because we have not gotten its full-path\n\t\t\t\t * name yet.\n\t\t\t\t */\n\t\t\t\tre_add_entry(iso9660, file);\n\t\t\t\tcontinue;\n\t\t\t} else if (file->re_descendant) {\n\t\t\t\t/*\n\t\t\t\t * If the top level \"RE\" entry of this entry\n\t\t\t\t * is not exposed, we, accordingly, should not\n\t\t\t\t * expose this entry at this time because\n\t\t\t\t * we cannot make its proper full-path name.\n\t\t\t\t */\n\t\t\t\tif (rede_add_entry(file) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* Otherwise we can expose this entry because\n\t\t\t\t * it seems its top level \"RE\" has already been\n\t\t\t\t * exposed. */\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif ((file->mode & AE_IFMT) != AE_IFREG || file->number == -1)\n\t\treturn (ARCHIVE_OK);\n\n\tcount = 0;\n\tnumber = file->number;\n\tiso9660->cache_files.first = NULL;\n\tiso9660->cache_files.last = &(iso9660->cache_files.first);\n\tempty_files.first = NULL;\n\tempty_files.last = &empty_files.first;\n\t/* Collect files which has the same file serial number.\n\t * Peek pending_files so that file which number is different\n\t * is not put bak. */\n\twhile (iso9660->pending_files.used > 0 &&\n\t    (iso9660->pending_files.files[0]->number == -1 ||\n\t     iso9660->pending_files.files[0]->number == number)) {\n\t\tif (file->number == -1) {\n\t\t\t/* This file has the same offset\n\t\t\t * but it's wrong offset which empty files\n\t\t\t * and symlink files have.\n\t\t\t * NOTE: This wrong offse was recorded by\n\t\t\t * old mkisofs utility. If ISO images is\n\t\t\t * created by latest mkisofs, this does not\n\t\t\t * happen.\n\t\t\t */\n\t\t\tfile->next = NULL;\n\t\t\t*empty_files.last = file;\n\t\t\tempty_files.last = &(file->next);\n\t\t} else {\n\t\t\tcount++;\n\t\t\tcache_add_entry(iso9660, file);\n\t\t}\n\t\tfile = next_entry(iso9660);\n\t}\n\n\tif (count == 0) {\n\t\t*pfile = file;\n\t\treturn ((file == NULL)?ARCHIVE_EOF:ARCHIVE_OK);\n\t}\n\tif (file->number == -1) {\n\t\tfile->next = NULL;\n\t\t*empty_files.last = file;\n\t\tempty_files.last = &(file->next);\n\t} else {\n\t\tcount++;\n\t\tcache_add_entry(iso9660, file);\n\t}\n\n\tif (count > 1) {\n\t\t/* The count is the same as number of hardlink,\n\t\t * so much so that each nlinks of files in cache_file\n\t\t * is overwritten by value of the count.\n\t\t */\n\t\tfor (file = iso9660->cache_files.first;\n\t\t    file != NULL; file = file->next)\n\t\t\tfile->nlinks = count;\n\t}\n\t/* If there are empty files, that files are added\n\t * to the tail of the cache_files. */\n\tif (empty_files.first != NULL) {\n\t\t*iso9660->cache_files.last = empty_files.first;\n\t\tiso9660->cache_files.last = empty_files.last;\n\t}\n\t*pfile = cache_get_entry(iso9660);\n\treturn ((*pfile == NULL)?ARCHIVE_EOF:ARCHIVE_OK);\n\nfatal_rr:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t    \"Failed to connect 'CL' pointer to 'RE' rr_moved pointer of \"\n\t    \"Rockridge extensions: current position = %jd, CL offset = %jd\",\n\t    (intmax_t)iso9660->current_position, (intmax_t)file->cl_offset);\n\treturn (ARCHIVE_FATAL);\n}\n",
        "output": "0",
        "index": 51208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ppp_bsdos_if_print(netdissect_options *ndo _U_,\n                   const struct pcap_pkthdr *h _U_, register const u_char *p _U_)\n{\n\tregister int hdrlength;\n#ifdef __bsdi__\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tuint16_t ptype;\n\tconst u_char *q;\n\tint i;\n\n\tif (caplen < PPP_BSDI_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|ppp]\"));\n\t\treturn (caplen)\n\t}\n\n\thdrlength = 0;\n\n#if 0\n\tif (p[0] == PPP_ADDRESS && p[1] == PPP_CONTROL) {\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x %02x \", p[0], p[1]));\n\t\tp += 2;\n\t\thdrlength = 2;\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%d \", length));\n\t/* Retrieve the protocol type */\n\tif (*p & 01) {\n\t\t/* Compressed protocol field */\n\t\tptype = *p;\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%02x \", ptype));\n\t\tp++;\n\t\thdrlength += 1;\n\t} else {\n\t\t/* Un-compressed protocol field */\n\t\tptype = EXTRACT_16BITS(p);\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%04x \", ptype));\n\t\tp += 2;\n\t\thdrlength += 2;\n\t}\n#else\n\tptype = 0;\t/*XXX*/\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%c \", p[SLC_DIR] ? 'O' : 'I'));\n\tif (p[SLC_LLHL]) {\n\t\t/* link level header */\n\t\tstruct ppp_header *ph;\n\n\t\tq = p + SLC_BPFHDRLEN;\n\t\tph = (struct ppp_header *)q;\n\t\tif (ph->phdr_addr == PPP_ADDRESS\n\t\t && ph->phdr_ctl == PPP_CONTROL) {\n\t\t\tif (ndo->ndo_eflag)\n\t\t\t\tND_PRINT((ndo, \"%02x %02x \", q[0], q[1]));\n\t\t\tptype = EXTRACT_16BITS(&ph->phdr_type);\n\t\t\tif (ndo->ndo_eflag && (ptype == PPP_VJC || ptype == PPP_VJNC)) {\n\t\t\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str,\n\t\t\t\t\t\t\"proto-#%d\", ptype)));\n\t\t\t}\n\t\t} else {\n\t\t\tif (ndo->ndo_eflag) {\n\t\t\t\tND_PRINT((ndo, \"LLH=[\"));\n\t\t\t\tfor (i = 0; i < p[SLC_LLHL]; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", q[i]));\n\t\t\t\tND_PRINT((ndo, \"] \"));\n\t\t\t}\n\t\t}\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"%d \", length));\n\tif (p[SLC_CHL]) {\n\t\tq = p + SLC_BPFHDRLEN + p[SLC_LLHL];\n\n\t\tswitch (ptype) {\n\t\tcase PPP_VJC:\n\t\t\tptype = vjc_print(ndo, q, ptype);\n\t\t\thdrlength = PPP_BSDI_HDRLEN;\n\t\t\tp += hdrlength;\n\t\t\tswitch (ptype) {\n\t\t\tcase PPP_IP:\n\t\t\t\tip_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6:\n\t\t\t\tip6_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_MPLS_UCAST:\n\t\t\tcase PPP_MPLS_MCAST:\n\t\t\t\tmpls_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto printx;\n\t\tcase PPP_VJNC:\n\t\t\tptype = vjc_print(ndo, q, ptype);\n\t\t\thdrlength = PPP_BSDI_HDRLEN;\n\t\t\tp += hdrlength;\n\t\t\tswitch (ptype) {\n\t\t\tcase PPP_IP:\n\t\t\t\tip_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_IPV6:\n\t\t\t\tip6_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\tcase PPP_MPLS_UCAST:\n\t\t\tcase PPP_MPLS_MCAST:\n\t\t\t\tmpls_print(ndo, p, length);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto printx;\n\t\tdefault:\n\t\t\tif (ndo->ndo_eflag) {\n\t\t\t\tND_PRINT((ndo, \"CH=[\"));\n\t\t\t\tfor (i = 0; i < p[SLC_LLHL]; i++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", q[i]));\n\t\t\t\tND_PRINT((ndo, \"] \"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thdrlength = PPP_BSDI_HDRLEN;\n#endif\n\n\tlength -= hdrlength;\n\tp += hdrlength;\n\n\tswitch (ptype) {\n\tcase PPP_IP:\n\t\tip_print(p, length);\n\t\tbreak;\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", ptype)));\n\t}\n\nprintx:\n#else /* __bsdi */\n\thdrlength = 0;\n#endif /* __bsdi__ */\n\treturn (hdrlength);\n}\n",
        "output": "0",
        "index": 35435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n                              anum_t last, int restore)\n{\n  struct NntpData *nntp_data = ctx->data;\n  struct FetchCtx fc;\n  struct Header *hdr = NULL;\n  char buf[HUGE_STRING];\n  int rc = 0;\n  int oldmsgcount = ctx->msgcount;\n  anum_t current;\n  anum_t first_over = first;\n#ifdef USE_HCACHE\n  void *hdata = NULL;\n#endif\n\n  /* if empty group or nothing to do */\n  if (!last || first > last)\n    return 0;\n\n  /* init fetch context */\n  fc.ctx = ctx;\n  fc.first = first;\n   fc.last = last;\n   fc.restore = restore;\n   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n #ifdef USE_HCACHE\n   fc.hc = hc;\n #endif\n\n  /* fetch list of articles */\n  if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted)\n  {\n    if (!ctx->quiet)\n      mutt_message(_(\"Fetching list of articles...\"));\n    if (nntp_data->nserv->hasLISTGROUPrange)\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s %u-%u\\r\\n\", nntp_data->group, first, last);\n    else\n      snprintf(buf, sizeof(buf), \"LISTGROUP %s\\r\\n\", nntp_data->group);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"LISTGROUP: %s\", buf);\n    }\n    if (rc == 0)\n    {\n      for (current = first; current <= last && rc == 0; current++)\n      {\n        if (fc.messages[current - first])\n          continue;\n\n        snprintf(buf, sizeof(buf), \"%u\", current);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#1 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n\n#ifdef USE_HCACHE\n        if (fc.hc)\n        {\n          mutt_debug(2, \"mutt_hcache_delete %s\\n\", buf);\n          mutt_hcache_delete(fc.hc, buf, strlen(buf));\n        }\n#endif\n      }\n    }\n  }\n  else\n  {\n    for (current = first; current <= last; current++)\n      fc.messages[current - first] = 1;\n  }\n\n  /* fetching header from cache or server, or fallback to fetch overview */\n  if (!ctx->quiet)\n  {\n    mutt_progress_init(&fc.progress, _(\"Fetching message headers...\"),\n                       MUTT_PROGRESS_MSG, ReadInc, last - first + 1);\n  }\n  for (current = first; current <= last && rc == 0; current++)\n  {\n    if (!ctx->quiet)\n      mutt_progress_update(&fc.progress, current - first + 1, -1);\n\n#ifdef USE_HCACHE\n    snprintf(buf, sizeof(buf), \"%u\", current);\n#endif\n\n    /* delete header from cache that does not exist on server */\n    if (!fc.messages[current - first])\n      continue;\n\n    /* allocate memory for headers */\n    if (ctx->msgcount >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n\n#ifdef USE_HCACHE\n    /* try to fetch header from cache */\n    hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf));\n    if (hdata)\n    {\n      mutt_debug(2, \"mutt_hcache_fetch %s\\n\", buf);\n      ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata);\n      mutt_hcache_free(fc.hc, &hdata);\n      hdr->data = 0;\n\n      /* skip header marked as deleted in cache */\n      if (hdr->deleted && !restore)\n      {\n        mutt_header_free(&hdr);\n        if (nntp_data->bcache)\n        {\n          mutt_debug(2, \"#2 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        continue;\n      }\n\n      hdr->read = false;\n      hdr->old = false;\n    }\n    else\n#endif\n\n        /* don't try to fetch header from removed newsgroup */\n        if (nntp_data->deleted)\n      continue;\n\n    /* fallback to fetch overview */\n    else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER)\n    {\n      if (NntpListgroup && nntp_data->nserv->hasLISTGROUP)\n        break;\n      else\n        continue;\n    }\n\n    /* fetch header from server */\n    else\n    {\n      FILE *fp = mutt_file_mkstemp();\n      if (!fp)\n      {\n        mutt_perror(\"mutt_file_mkstemp() failed!\");\n        rc = -1;\n        break;\n      }\n\n      snprintf(buf, sizeof(buf), \"HEAD %u\\r\\n\", current);\n      rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp);\n      if (rc)\n      {\n        mutt_file_fclose(&fp);\n        if (rc < 0)\n          break;\n\n        /* invalid response */\n        if (mutt_str_strncmp(\"423\", buf, 3) != 0)\n        {\n          mutt_error(\"HEAD: %s\", buf);\n          break;\n        }\n\n        /* no such article */\n        if (nntp_data->bcache)\n        {\n          snprintf(buf, sizeof(buf), \"%u\", current);\n          mutt_debug(2, \"#3 mutt_bcache_del %s\\n\", buf);\n          mutt_bcache_del(nntp_data->bcache, buf);\n        }\n        rc = 0;\n        continue;\n      }\n\n      /* parse header */\n      hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new();\n      hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0);\n      hdr->received = hdr->date_sent;\n      mutt_file_fclose(&fp);\n    }\n\n    /* save header in context */\n    hdr->index = ctx->msgcount++;\n    hdr->read = false;\n    hdr->old = false;\n    hdr->deleted = false;\n    hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData));\n    NHDR(hdr)->article_num = current;\n    if (restore)\n      hdr->changed = true;\n    else\n    {\n      nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num);\n      if (!hdr->read)\n        nntp_parse_xref(ctx, hdr);\n    }\n    if (current > nntp_data->last_loaded)\n      nntp_data->last_loaded = current;\n    first_over = current + 1;\n  }\n\n  if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP)\n    current = first_over;\n\n  /* fetch overview information */\n  if (current <= last && rc == 0 && !nntp_data->deleted)\n  {\n    char *cmd = nntp_data->nserv->hasOVER ? \"OVER\" : \"XOVER\";\n    snprintf(buf, sizeof(buf), \"%s %u-%u\\r\\n\", cmd, current, last);\n    rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc);\n    if (rc > 0)\n    {\n      mutt_error(\"%s: %s\", cmd, buf);\n    }\n  }\n\n  if (ctx->msgcount > oldmsgcount)\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n\n  FREE(&fc.messages);\n  if (rc != 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n",
        "output": "1",
        "index": 182296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)\n{\n\tint rc;\n\tint reply = 0;\n\tfilesize_t bytes=0;\n\tMyString filename;;\n\tMyString fullname;\n\tchar *tmp_buf = NULL;\n\tint final_transfer = 0;\n\tbool download_success = true;\n\tbool try_again = true;\n\tint hold_code = 0;\n\tint hold_subcode = 0;\n\tMyString error_buf;\n\tint delegation_method = 0; /* 0 means this transfer is not a delegation. 1 means it is.*/\n\ttime_t start, elapsed;\n\tbool I_go_ahead_always = false;\n\tbool peer_goes_ahead_always = false;\n\tDCTransferQueue xfer_queue(m_xfer_queue_contact_info);\n\tCondorError errstack;\n\n\tpriv_state saved_priv = PRIV_UNKNOWN;\n\t*total_bytes = 0;\n\n\tbool want_fsync = ( ((IsClient() && !simple_init) ||  // starter receiving\n\t\t\t\t\t\t (IsServer() && simple_init))     // schedd receiving\n\t\t\t\t\t\t && upload_changed_files );\n\n\tdprintf(D_FULLDEBUG,\"entering FileTransfer::DoDownload sync=%d\\n\",\n\t\t\t\t\twant_fsync ? 1 : 0);\n\n\ts->decode();\n\n\tbool socket_default_crypto = s->get_encryption();\n\n\tif( !s->code(final_transfer) ) {\n\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\treturn_and_resetpriv( -1 );\n\t}\n\tif( !s->end_of_message() ) {\n\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\treturn_and_resetpriv( -1 );\n\t}\t\n\n\tif( !final_transfer && IsServer() ) {\n\t\tSpooledJobFiles::createJobSpoolDirectory(&jobAd,desired_priv_state);\n\t}\n\n\tfor (;;) {\n\t\tif( !s->code(reply) ) {\n\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\treturn_and_resetpriv( -1 );\n\t\t}\n\t\tif( !s->end_of_message() ) {\n\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\treturn_and_resetpriv( -1 );\n\t\t}\n\t\tdprintf( D_SECURITY, \"FILETRANSFER: incoming file_command is %i\\n\", reply);\n\t\tif( !reply ) {\n\t\t\tbreak;\n\t\t}\n\t\tif (reply == 2) {\n\t\t\ts->set_crypto_mode(true);\n\t\t} else if (reply == 3) {\n\t\t\ts->set_crypto_mode(false);\n\t\t}\n\t\telse {\n\t\t\ts->set_crypto_mode(socket_default_crypto);\n\t\t}\n\n\t\ttmp_buf = NULL;\n\t\tif( !s->code(tmp_buf) ) {\n\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\treturn_and_resetpriv( -1 );\n\t\t}\n\t\tfilename = tmp_buf;\n\t\tfree( tmp_buf );\n\t\ttmp_buf = NULL;\n\n\n\t\t\t/*\n\t\t\t  if we want to change priv states but haven't done so\n\t\t\t  yet, set it now.  we only need to do this once since\n\t\t\t  we're no longer doing any hard-coded insanity with\n\t\t\t  PRIV_CONDOR and everything can either be done in our\n\t\t\t  existing priv state (want_priv_change == FALSE) or in\n\t\t\t  the priv state we were told to use... Derek, 2005-04-21\n\t\t\t*/\n\t\tif( want_priv_change && saved_priv == PRIV_UNKNOWN ) {\n\t\t\tsaved_priv = set_priv( desired_priv_state );\n\t\t}\n\n\t\tif( !LegalPathInSandbox(filename.Value(),Iwd) ) {\n\n\t\t\tdownload_success = false;\n\t\t\ttry_again = false;\n\t\t\thold_code = CONDOR_HOLD_CODE_DownloadFileError;\n\t\t\thold_subcode = EPERM;\n\n\t\t\terror_buf.sprintf_cat(\n\t\t\t\t\" Attempt to write to illegal sandbox path: %s\",\n\t\t\t\tfilename.Value());\n\n\t\t\tdprintf(D_ALWAYS,\"DoDownload: attempt to write to illegal sandbox path by our peer %s: %s.\\n\",\n\t\t\t\t\ts->peer_description(),\n\t\t\t\t\tfilename.Value());\n\n\t\t\tfilename = NULL_FILE;\n\t\t}\n\n\t\tif( !strcmp(filename.Value(),NULL_FILE) ) {\n\t\t\tfullname = filename;\n\t\t}\n\t\telse if( final_transfer || IsClient() ) {\n\t\t\tMyString remap_filename;\n\t\t\tif(filename_remap_find(download_filename_remaps.Value(),filename.Value(),remap_filename)) {\n\t\t\t\tif(!is_relative_to_cwd(remap_filename.Value())) {\n\t\t\t\t\tfullname = remap_filename;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfullname.sprintf(\"%s%c%s\",Iwd,DIR_DELIM_CHAR,remap_filename.Value());\n\t\t\t\t}\n\t\t\t\tdprintf(D_FULLDEBUG,\"Remapped downloaded file from %s to %s\\n\",filename.Value(),remap_filename.Value());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfullname.sprintf(\"%s%c%s\",Iwd,DIR_DELIM_CHAR,filename.Value());\n\t\t\t}\n#ifdef WIN32\n\t\t\tif ( perm_obj && (perm_obj->write_access(fullname.Value()) != 1) ) {\n\t\t\t\terror_buf.sprintf(\"Permission denied to write file %s!\",\n\t\t\t\t                   fullname.Value());\n\t\t\t\tdprintf(D_ALWAYS,\"DoDownload: %s\\n\",error_buf.Value());\n\t\t\t\tdownload_success = false;\n\t\t\t\ttry_again = false;\n\t\t\t\thold_code = CONDOR_HOLD_CODE_DownloadFileError;\n\t\t\t\thold_subcode = EPERM;\n\n\t\t\t\tfullname = NULL_FILE;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tfullname.sprintf(\"%s%c%s\",TmpSpoolSpace,DIR_DELIM_CHAR,filename.Value());\n\t\t}\n\n\t\tif( PeerDoesGoAhead ) {\n\t\t\tif( !s->end_of_message() ) {\n\t\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: failed on eom before GoAhead: exiting at %d\\n\",__LINE__);\n\t\t\t\treturn_and_resetpriv( -1 );\n\t\t\t}\n\n\t\t\tif( !I_go_ahead_always ) {\n\t\t\t\tif( !ObtainAndSendTransferGoAhead(xfer_queue,true,s,fullname.Value(),I_go_ahead_always) ) {\n\t\t\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\t\t\treturn_and_resetpriv( -1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( !peer_goes_ahead_always ) {\n\n\t\t\t\tif( !ReceiveTransferGoAhead(s,fullname.Value(),true,peer_goes_ahead_always) ) {\n\t\t\t\t\tdprintf(D_FULLDEBUG, \"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\t\t\treturn_and_resetpriv( -1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts->decode();\n\t\t}\n\n\t\tstart = time(NULL);\n\n\n\t\tif (reply == 999) {\n\t\t\tClassAd file_info;\n\t\t\tif (!file_info.initFromStream(*s)) {\n\t\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\t\treturn_and_resetpriv( -1 );\n\t\t\t}\n\n\t\t\t\t\n\t\t\tint      subcommand = 0;\n\t\t\tif(!file_info.LookupInteger(\"Result\",subcommand)) {\n\t\t\t\tsubcommand = -1;\n\t\t\t}\n\n\n\t\t\tif(subcommand == 7) {\n\t\t\t\t\n\t\t\t\tMyString rt_src;\n\t\t\t\tMyString rt_dst;\n\t\t\t\tMyString rt_err;\n\t\t\t\tint      rt_result = 0;\n\t\t\t\tif(!file_info.LookupInteger(\"Result\",rt_result)) {\n\t\t\t\t\trt_result = -1;\n\t\t\t\t}\n\n\t\t\t\tif(!file_info.LookupString(\"Filename\", rt_src)) {\n\t\t\t\t\trt_src = \"<null>\";\n\t\t\t\t}\n\n\t\t\t\tif(!file_info.LookupString(\"OutputDestination\", rt_dst)) {\n\t\t\t\t\trt_dst = \"<null>\";\n\t\t\t\t}\n\n\t\t\t\tif(!file_info.LookupString(\"ErrorString\", rt_err)) {\n\t\t\t\t\trt_err = \"<null>\";\n\t\t\t\t}\n\n\t\t\t\tdprintf(D_ALWAYS, \"DoDownload: other side transferred %s to %s and got result %i\\n\",\n\t\t\t\t\t\trt_src.Value(), rt_dst.Value(), rt_result );\n\n\t\t\t\tif(rt_result == 0) {\n\t\t\t\t\trc = 0;\n\t\t\t\t} else {\n\t\t\t\t\trc = 0; \n\n\t\t\t\t\terror_buf.sprintf(\n\t\t\t\t\t\t\"%s at %s failed due to remote transfer hook error: %s\",\n\t\t\t\t\t\tget_mySubSystem()->getName(),\n\t\t\t\t\t\ts->my_ip_str(),fullname.Value());\n\t\t\t\t\tdownload_success = false;\n\t\t\t\t\ttry_again = false;\n\t\t\t\t\thold_code = CONDOR_HOLD_CODE_DownloadFileError;\n\t\t\t\t\thold_subcode = rt_result;\n\n\t\t\t\t\tdprintf(D_ALWAYS,\n\t\t\t\t\t\t\"DoDownload: consuming rest of transfer and failing \"\n\t\t\t\t\t\t\"after encountering the following error: %s\\n\",\n\t\t\t\t\t\terror_buf.Value());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdprintf(D_ALWAYS, \"FILETRANSFER: unrecognized subcommand %i! skipping!\\n\", subcommand);\n\t\t\t\tfile_info.dPrint(D_FULLDEBUG);\n\t\t\t\t\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t} else if (reply == 5) {\n\n\t\t\tMyString URL;\n\n\t\t\tif (!s->code(URL)) {\n\t\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\t\treturn_and_resetpriv( -1 );\n\t\t\t}\n\n\t\t\tdprintf( D_FULLDEBUG, \"DoDownload: doing a URL transfer: (%s) to (%s)\\n\", URL.Value(), fullname.Value());\n\n\t\t\trc = InvokeFileTransferPlugin(errstack, URL.Value(), fullname.Value(), LocalProxyName.Value());\n\n\n\t\t} else if ( reply == 4 ) {\n\t\t\tif ( PeerDoesGoAhead || s->end_of_message() ) {\n\t\t\t\trc = s->get_x509_delegation( &bytes, fullname.Value() );\n\t\t\t\tdprintf( D_FULLDEBUG,\n\t\t\t\t         \"DoDownload: get_x509_delegation() returned %d\\n\",\n\t\t\t\t         rc );\n\t\t\t\tif (rc == 0) {\n\t\t\t\t\tLocalProxyName = fullname;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = -1;\n\t\t\t}\n\t\t\tdelegation_method = 1;/* This is a delegation, unseuccessful or not */\n\t\t} else if( reply == 6 ) { // mkdir\n\t\t\tcondor_mode_t file_mode = NULL_FILE_PERMISSIONS;\n\t\t\tif( !s->code(file_mode) ) {\n\t\t\t\trc = -1;\n\t\t\t\tdprintf(D_ALWAYS,\"DoDownload: failed to read mkdir mode.\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\trc = mkdir(fullname.Value(),file_mode);\n\t\t\t\tif( rc == -1 && errno == EEXIST ) {\n\t\t\t\t\tStatInfo st( fullname.Value() );\n\t\t\t\t\tif( !st.Error() && st.IsDirectory() ) {\n\t\t\t\t\t\tdprintf(D_FULLDEBUG,\"Requested to create directory but using existing one: %s\\n\",fullname.Value());\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if( !strcmp(fullname.Value(),NULL_FILE) ) {\n\t\t\t\t\t\trc = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tremove(fullname.Value());\n\t\t\t\t\t\trc = mkdir(fullname.Value(),file_mode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( rc == -1 ) {\n\t\t\t\t\trc = 0; \n\n\t\t\t\t\tint the_error = errno;\n\t\t\t\t\terror_buf.sprintf(\n\t\t\t\t\t\t\"%s at %s failed to create directory %s: %s (errno %d)\",\n\t\t\t\t\t\tget_mySubSystem()->getName(),\n\t\t\t\t\t\ts->my_ip_str(),fullname.Value(),\n\t\t\t\t\t\tstrerror(the_error),the_error);\n\t\t\t\t\tdownload_success = false;\n\t\t\t\t\ttry_again = false;\n\t\t\t\t\thold_code = CONDOR_HOLD_CODE_DownloadFileError;\n\t\t\t\t\thold_subcode = the_error;\n\n\t\t\t\t\tdprintf(D_ALWAYS,\n\t\t\t\t\t\t\"DoDownload: consuming rest of transfer and failing \"\n\t\t\t\t\t\t\"after encountering the following error: %s\\n\",\n\t\t\t\t\t\terror_buf.Value());\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( TransferFilePermissions ) {\n\t\t\trc = s->get_file_with_permissions( &bytes, fullname.Value() );\n\t\t} else {\n\t\t\trc = s->get_file( &bytes, fullname.Value() );\n\t\t}\n\n\t\telapsed = time(NULL)-start;\n\n\t\tif( rc < 0 ) {\n\t\t\tint the_error = errno;\n\t\t\terror_buf.sprintf(\"%s at %s failed to receive file %s\",\n\t\t\t                  get_mySubSystem()->getName(),\n\t\t\t\t\t\t\t  s->my_ip_str(),fullname.Value());\n\t\t\tdownload_success = false;\n\t\t\tif(rc == GET_FILE_OPEN_FAILED || rc == GET_FILE_WRITE_FAILED ||\n\t\t\t\t\trc == GET_FILE_PLUGIN_FAILED) {\n\n\t\t\t\tif (rc == GET_FILE_PLUGIN_FAILED) {\n\t\t\t\t\terror_buf.sprintf_cat(\": %s\", errstack.getFullText());\n\t\t\t\t} else {\n\t\t\t\t\terror_buf.replaceString(\"receive\",\"write to\");\n\t\t\t\t\terror_buf.sprintf_cat(\": (errno %d) %s\",the_error,strerror(the_error));\n\t\t\t\t}\n\n\n\t\t\t\ttry_again = false;\n\t\t\t\thold_code = CONDOR_HOLD_CODE_DownloadFileError;\n\t\t\t\thold_subcode = the_error;\n\n\t\t\t\tdprintf(D_ALWAYS,\n\t\t\t\t\t\t\"DoDownload: consuming rest of transfer and failing \"\n\t\t\t\t\t\t\"after encountering the following error: %s\\n\",\n\t\t\t\t\t\terror_buf.Value());\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry_again = true;\n\n\t\t\t\tdprintf(D_ALWAYS,\"DoDownload: %s\\n\",error_buf.Value());\n\n\t\t\t\tSendTransferAck(s,download_success,try_again,hold_code,hold_subcode,error_buf.Value());\n\n\t\t\t\tdprintf(D_FULLDEBUG,\"DoDownload: exiting at %d\\n\",__LINE__);\n\t\t\t\treturn_and_resetpriv( -1 );\n\t\t\t}\n\t\t}\n\n\t\tif ( want_fsync ) {\n\t\t\tstruct utimbuf timewrap;\n\n\t\t\ttime_t current_time = time(NULL);\n\t\t\ttimewrap.actime = current_time;\t\t// set access time to now\n\t\t\ttimewrap.modtime = current_time - 180;\t// set modify time to 3 min ago\n\n\t\t\tutime(fullname.Value(),&timewrap);\n\t\t}\n\n\t\tif( !s->end_of_message() ) {\n\t\t\treturn_and_resetpriv( -1 );\n\t\t}\n\t\t*total_bytes += bytes;\n\n#ifdef HAVE_EXT_POSTGRESQL\n\t        file_transfer_record record;\n\t\trecord.fullname = fullname.Value();\n\t\trecord.bytes = bytes;\n\t\trecord.elapsed  = elapsed;\n    \n\t\tchar daemon[16]; daemon[15] = '\\0';\n\t\tstrncpy(daemon, get_mySubSystem()->getName(), 15);\n\t\trecord.daemon = daemon;\n\n\t\trecord.sockp =s;\n\t\trecord.transfer_time = start;\n\t\trecord.delegation_method_id = delegation_method;\n\t\tfile_transfer_db(&record, &jobAd);\n#else\n\t\tif (delegation_method) {}\n\t\tif (elapsed) {}\n#endif\n\t}\n\n\ts->set_crypto_mode(socket_default_crypto);\n\n#ifdef WIN32\n\tbytesRcvd += (float)(signed __int64)(*total_bytes);\n#else\n\tbytesRcvd += (*total_bytes);\n#endif\n\n\tbool upload_success = false;\n\tMyString upload_error_buf;\n\tbool upload_try_again = true;\n\tint upload_hold_code = 0;\n\tint upload_hold_subcode = 0;\n\tGetTransferAck(s,upload_success,upload_try_again,upload_hold_code,\n\t\t\t\t   upload_hold_subcode,upload_error_buf);\n\tif(!upload_success) {\n\n\t\tchar const *peer_ip_str = \"disconnected socket\";\n\t\tif(s->type() == Stream::reli_sock) {\n\t\t\tpeer_ip_str = ((Sock *)s)->get_sinful_peer();\n\t\t}\n\n\t\tMyString download_error_buf;\n\t\tdownload_error_buf.sprintf(\"%s failed to receive file(s) from %s\",\n\t\t\t\t\t\t  get_mySubSystem()->getName(),peer_ip_str);\n\t\terror_buf.sprintf(\"%s; %s\",\n\t\t\t\t\t\t  upload_error_buf.Value(),\n\t\t\t\t\t\t  download_error_buf.Value());\n\t\tdprintf(D_ALWAYS,\"DoDownload: %s\\n\",error_buf.Value());\n\n\t\tdownload_success = false;\n\t\tSendTransferAck(s,download_success,upload_try_again,upload_hold_code,\n\t\t\t\t\t\tupload_hold_subcode,download_error_buf.Value());\n\n\t\tInfo.error_desc = error_buf.Value();\n\n\t\tdprintf( D_FULLDEBUG, \"DoDownload: exiting with upload errors\\n\" );\n\t\treturn_and_resetpriv( -1 );\n\t}\n\n\tif( !download_success ) {\n\t\tSendTransferAck(s,download_success,try_again,hold_code,\n\t\t\t\t\t\thold_subcode,error_buf.Value());\n\n\t\tdprintf( D_FULLDEBUG, \"DoDownload: exiting with download errors\\n\" );\n\t\treturn_and_resetpriv( -1 );\n\t}\n\n\tif ( !final_transfer && IsServer() ) {\n\t\tMyString buf;\n\t\tint fd;\n\n\t\tbuf.sprintf(\"%s%c%s\",TmpSpoolSpace,DIR_DELIM_CHAR,COMMIT_FILENAME);\n#if defined(WIN32)\n\t\tif ((fd = safe_open_wrapper_follow(buf.Value(), O_WRONLY | O_CREAT | O_TRUNC | \n\t\t\t_O_BINARY | _O_SEQUENTIAL, 0644)) < 0)\n#else\n\t\tif ((fd = safe_open_wrapper_follow(buf.Value(), O_WRONLY | O_CREAT | O_TRUNC, 0644)) < 0)\n#endif\n\t\t{\n\t\t\tdprintf(D_ALWAYS, \n\t\t\t\t\"FileTransfer::DoDownload failed to write commit file\\n\");\n\t\t\treturn_and_resetpriv( -1 );\n\t\t}\n\n\t\t::close(fd);\n\n\t\tCommitFiles();\n\n\t}\n\n\tdownload_success = true;\n\tSendTransferAck(s,download_success,try_again,hold_code,hold_subcode,NULL);\n\n\treturn_and_resetpriv( 0 );\n}\n",
        "output": "0",
        "index": 16567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_decode_flow_mod(struct ofputil_flow_mod *fm,\n                        const struct ofp_header *oh,\n                        enum ofputil_protocol protocol,\n                        const struct tun_table *tun_table,\n                        const struct vl_mff_map *vl_mff_map,\n                        struct ofpbuf *ofpacts,\n                        ofp_port_t max_port, uint8_t max_table)\n{\n    ovs_be16 raw_flags;\n    enum ofperr error;\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n    if (raw == OFPRAW_OFPT11_FLOW_MOD) {\n        /* Standard OpenFlow 1.1+ flow_mod. */\n        const struct ofp11_flow_mod *ofm;\n\n        ofm = ofpbuf_pull(&b, sizeof *ofm);\n\n        error = ofputil_pull_ofp11_match(&b, tun_table, vl_mff_map, &fm->match,\n                                         NULL);\n        if (error) {\n            return error;\n        }\n\n        /* Translate the message. */\n        fm->priority = ntohs(ofm->priority);\n        if (ofm->command == OFPFC_ADD\n            || (oh->version == OFP11_VERSION\n                && (ofm->command == OFPFC_MODIFY ||\n                    ofm->command == OFPFC_MODIFY_STRICT)\n                && ofm->cookie_mask == htonll(0))) {\n            /* In OpenFlow 1.1 only, a \"modify\" or \"modify-strict\" that does\n             * not match on the cookie is treated as an \"add\" if there is no\n             * match. */\n            fm->cookie = htonll(0);\n            fm->cookie_mask = htonll(0);\n            fm->new_cookie = ofm->cookie;\n        } else {\n            fm->cookie = ofm->cookie;\n            fm->cookie_mask = ofm->cookie_mask;\n            fm->new_cookie = OVS_BE64_MAX;\n        }\n        fm->modify_cookie = false;\n        fm->command = ofm->command;\n\n        /* Get table ID.\n         *\n         * OF1.1 entirely forbids table_id == OFPTT_ALL.\n         * OF1.2+ allows table_id == OFPTT_ALL only for deletes. */\n        fm->table_id = ofm->table_id;\n        if (fm->table_id == OFPTT_ALL\n            && (oh->version == OFP11_VERSION\n                || (ofm->command != OFPFC_DELETE &&\n                    ofm->command != OFPFC_DELETE_STRICT))) {\n            return OFPERR_OFPFMFC_BAD_TABLE_ID;\n        }\n\n        fm->idle_timeout = ntohs(ofm->idle_timeout);\n        fm->hard_timeout = ntohs(ofm->hard_timeout);\n        if (oh->version >= OFP14_VERSION && ofm->command == OFPFC_ADD) {\n            fm->importance = ntohs(ofm->importance);\n        } else {\n            fm->importance = 0;\n        }\n        fm->buffer_id = ntohl(ofm->buffer_id);\n        error = ofputil_port_from_ofp11(ofm->out_port, &fm->out_port);\n        if (error) {\n            return error;\n        }\n\n        fm->out_group = (ofm->command == OFPFC_DELETE ||\n                         ofm->command == OFPFC_DELETE_STRICT\n                         ? ntohl(ofm->out_group)\n                         : OFPG_ANY);\n        raw_flags = ofm->flags;\n    } else {\n        uint16_t command;\n\n        if (raw == OFPRAW_OFPT10_FLOW_MOD) {\n            /* Standard OpenFlow 1.0 flow_mod. */\n            const struct ofp10_flow_mod *ofm;\n\n            /* Get the ofp10_flow_mod. */\n            ofm = ofpbuf_pull(&b, sizeof *ofm);\n\n            /* Translate the rule. */\n            ofputil_match_from_ofp10_match(&ofm->match, &fm->match);\n            ofputil_normalize_match(&fm->match);\n\n            /* OpenFlow 1.0 says that exact-match rules have to have the\n             * highest possible priority. */\n            fm->priority = (ofm->match.wildcards & htonl(OFPFW10_ALL)\n                            ? ntohs(ofm->priority)\n                            : UINT16_MAX);\n\n            /* Translate the message. */\n            command = ntohs(ofm->command);\n            fm->cookie = htonll(0);\n            fm->cookie_mask = htonll(0);\n            fm->new_cookie = ofm->cookie;\n            fm->idle_timeout = ntohs(ofm->idle_timeout);\n            fm->hard_timeout = ntohs(ofm->hard_timeout);\n            fm->importance = 0;\n            fm->buffer_id = ntohl(ofm->buffer_id);\n            fm->out_port = u16_to_ofp(ntohs(ofm->out_port));\n            fm->out_group = OFPG_ANY;\n            raw_flags = ofm->flags;\n        } else if (raw == OFPRAW_NXT_FLOW_MOD) {\n            /* Nicira extended flow_mod. */\n            const struct nx_flow_mod *nfm;\n\n            /* Dissect the message. */\n            nfm = ofpbuf_pull(&b, sizeof *nfm);\n            error = nx_pull_match(&b, ntohs(nfm->match_len),\n                                  &fm->match, &fm->cookie, &fm->cookie_mask,\n                                  tun_table, vl_mff_map);\n            if (error) {\n                return error;\n            }\n\n            /* Translate the message. */\n            command = ntohs(nfm->command);\n            if ((command & 0xff) == OFPFC_ADD && fm->cookie_mask) {\n                /* Flow additions may only set a new cookie, not match an\n                 * existing cookie. */\n                return OFPERR_NXBRC_NXM_INVALID;\n            }\n            fm->priority = ntohs(nfm->priority);\n            fm->new_cookie = nfm->cookie;\n            fm->idle_timeout = ntohs(nfm->idle_timeout);\n            fm->hard_timeout = ntohs(nfm->hard_timeout);\n            fm->importance = 0;\n            fm->buffer_id = ntohl(nfm->buffer_id);\n            fm->out_port = u16_to_ofp(ntohs(nfm->out_port));\n            fm->out_group = OFPG_ANY;\n            raw_flags = nfm->flags;\n        } else {\n            OVS_NOT_REACHED();\n        }\n\n        fm->modify_cookie = fm->new_cookie != OVS_BE64_MAX;\n        if (protocol & OFPUTIL_P_TID) {\n            fm->command = command & 0xff;\n            fm->table_id = command >> 8;\n        } else {\n            if (command > 0xff) {\n                VLOG_WARN_RL(&bad_ofmsg_rl, \"flow_mod has explicit table_id \"\n                             \"but flow_mod_table_id extension is not enabled\");\n            }\n            fm->command = command;\n            fm->table_id = 0xff;\n        }\n    }\n\n    if (fm->command > OFPFC_DELETE_STRICT) {\n        return OFPERR_OFPFMFC_BAD_COMMAND;\n    }\n\n    fm->ofpacts_tlv_bitmap = 0;\n    error = ofpacts_pull_openflow_instructions(&b, b.size, oh->version,\n                                               vl_mff_map,\n                                               &fm->ofpacts_tlv_bitmap,\n                                               ofpacts);\n    if (error) {\n        return error;\n    }\n    fm->ofpacts = ofpacts->data;\n    fm->ofpacts_len = ofpacts->size;\n\n    error = ofputil_decode_flow_mod_flags(raw_flags, fm->command,\n                                          oh->version, &fm->flags);\n    if (error) {\n        return error;\n    }\n\n    if (fm->flags & OFPUTIL_FF_EMERG) {\n        /* We do not support the OpenFlow 1.0 emergency flow cache, which\n         * is not required in OpenFlow 1.0.1 and removed from OpenFlow 1.1.\n         *\n         * OpenFlow 1.0 specifies the error code to use when idle_timeout\n         * or hard_timeout is nonzero.  Otherwise, there is no good error\n         * code, so just state that the flow table is full. */\n        return (fm->hard_timeout || fm->idle_timeout\n                ? OFPERR_OFPFMFC_BAD_EMERG_TIMEOUT\n                : OFPERR_OFPFMFC_TABLE_FULL);\n    }\n\n    return ofpacts_check_consistency(fm->ofpacts, fm->ofpacts_len,\n                                     &fm->match.flow, max_port,\n                                     fm->table_id, max_table, protocol);\n}\n",
        "output": "0",
        "index": 77494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fs_print(netdissect_options *ndo,\n         register const u_char *bp, int length)\n{\n\tint fs_op;\n\tunsigned long i;\n\n\tif (length <= (int)sizeof(struct rx_header))\n\t\treturn;\n\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t))) {\n\t\tgoto trunc;\n\t}\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from fsint/afsint.xg\n\t */\n\n\tfs_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" fs call %s\", tok2str(fs_req, \"op#%d\", fs_op)));\n\n\t/*\n\t * Print out arguments to some of the AFS calls.  This stuff is\n\t * all from afsint.xg\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\t/*\n\t * Sigh.  This is gross.  Ritchie forgive me.\n\t */\n\n\tswitch (fs_op) {\n\t\tcase 130:\t/* Fetch data */\n\t\t\tFIDOUT();\n\t\t\tND_PRINT((ndo, \" offset\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 131:\t/* Fetch ACL */\n\t\tcase 132:\t/* Fetch Status */\n\t\tcase 143:\t/* Old set lock */\n\t\tcase 144:\t/* Old extend lock */\n\t\tcase 145:\t/* Old release lock */\n\t\tcase 156:\t/* Set lock */\n\t\tcase 157:\t/* Extend lock */\n\t\tcase 158:\t/* Release lock */\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 135:\t/* Store status */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tbreak;\n\t\tcase 133:\t/* Store data */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tND_PRINT((ndo, \" offset\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tUINTOUT();\n\t\t\tND_PRINT((ndo, \" flen\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 134:\t/* Store ACL */\n\t\t{\n\t\t\tchar a[AFSOPAQUEMAX+1];\n\t\t\tFIDOUT();\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ti = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_TCHECK2(bp[0], i);\n\t\t\ti = min(AFSOPAQUEMAX, i);\n\t\t\tstrncpy(a, (const char *) bp, i);\n\t\t\ta[i] = '\\0';\n\t\t\tacl_print(ndo, (u_char *) a, sizeof(a), (u_char *) a + i);\n\t\t\tbreak;\n\t\t}\n\t\tcase 137:\t/* Create file */\n\t\tcase 141:\t/* MakeDir */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tSTOREATTROUT();\n\t\t\tbreak;\n\t\tcase 136:\t/* Remove file */\n\t\tcase 142:\t/* Remove directory */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 138:\t/* Rename file */\n\t\t\tND_PRINT((ndo, \" old\"));\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT((ndo, \" new\"));\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 139:\t/* Symlink */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT((ndo, \" link to\"));\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 140:\t/* Link */\n\t\t\tFIDOUT();\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tND_PRINT((ndo, \" link to\"));\n\t\t\tFIDOUT();\n\t\t\tbreak;\n\t\tcase 148:\t/* Get volume info */\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 149:\t/* Get volume stats */\n\t\tcase 150:\t/* Set volume stats */\n\t\t\tND_PRINT((ndo, \" volid\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 154:\t/* New get volume info */\n\t\t\tND_PRINT((ndo, \" volname\"));\n\t\t\tSTROUT(AFSNAMEMAX);\n\t\t\tbreak;\n\t\tcase 155:\t/* Bulk stat */\n\t\tcase 65536:     /* Inline bulk stat */\n\t\t{\n\t\t\tunsigned long j;\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\tj = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\n\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\tFIDOUT();\n\t\t\t\tif (i != j - 1)\n\t\t\t\t\tND_PRINT((ndo, \",\"));\n\t\t\t}\n\t\t\tif (j == 0)\n\t\t\t\tND_PRINT((ndo, \" <none!>\"));\n\t\t}\n\t\tcase 65537:\t/* Fetch data 64 */\n\t\t\tFIDOUT();\n\t\t\tND_PRINT((ndo, \" offset\"));\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tUINT64OUT();\n\t\t\tbreak;\n\t\tcase 65538:\t/* Store data 64 */\n\t\t\tFIDOUT();\n\t\t\tSTOREATTROUT();\n\t\t\tND_PRINT((ndo, \" offset\"));\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tUINT64OUT();\n\t\t\tND_PRINT((ndo, \" flen\"));\n\t\t\tUINT64OUT();\n\t\t\tbreak;\n\t\tcase 65541:    /* CallBack rx conn address */\n\t\t\tND_PRINT((ndo, \" addr\"));\n\t\t\tUINTOUT();\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|fs]\"));\n}\n",
        "output": "0",
        "index": 62272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  BMPSubtype\n    bmp_subtype;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    imageListLength,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  MagickOffsetType\n    profile_data,\n    profile_size,\n    profile_size_pad;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (((image->columns << 3) != (int) (image->columns << 3)) ||\n      ((image->rows << 3) != (int) (image->rows << 3)))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) memset(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    bmp_info.red_mask=0x00ff0000U;\n    bmp_info.green_mask=0x0000ff00U;\n    bmp_info.blue_mask=0x000000ffU;\n    bmp_info.alpha_mask=0xff000000U;\n    bmp_subtype=UndefinedSubtype;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        option=GetImageOption(image_info,\"bmp:subtype\");\n        if (option != (const char *) NULL)\n        {\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              if (LocaleNCompare(option,\"ARGB4444\",8) == 0)\n                {\n                  bmp_subtype=ARGB4444;\n                  bmp_info.red_mask=0x00000f00U;\n                  bmp_info.green_mask=0x000000f0U;\n                  bmp_info.blue_mask=0x0000000fU;\n                  bmp_info.alpha_mask=0x0000f000U;\n                }\n              else if (LocaleNCompare(option,\"ARGB1555\",8) == 0)\n                {\n                  bmp_subtype=ARGB1555;\n                  bmp_info.red_mask=0x00007c00U;\n                  bmp_info.green_mask=0x000003e0U;\n                  bmp_info.blue_mask=0x0000001fU;\n                  bmp_info.alpha_mask=0x00008000U;\n                }\n            }\n          else\n          {\n            if (LocaleNCompare(option,\"RGB555\",6) == 0)\n              {\n                bmp_subtype=RGB555;\n                bmp_info.red_mask=0x00007c00U;\n                bmp_info.green_mask=0x000003e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n            else if (LocaleNCompare(option,\"RGB565\",6) == 0)\n              {\n                bmp_subtype=RGB565;\n                bmp_info.red_mask=0x0000f800U;\n                bmp_info.green_mask=0x000007e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n          }\n        }\n        if (bmp_subtype != UndefinedSubtype)\n          {\n            bmp_info.bits_per_pixel=16;\n            bmp_info.compression=BI_BITFIELDS;\n          }\n        else\n          {\n            bmp_info.bits_per_pixel=(unsigned short) ((type > 3) &&\n               (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n            bmp_info.compression=(unsigned int) ((type > 3) &&\n              (image->alpha_trait != UndefinedPixelTrait) ? BI_BITFIELDS : BI_RGB);\n            if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n              {\n                option=GetImageOption(image_info,\"bmp3:alpha\");\n                if (IsStringTrue(option))\n                  bmp_info.bits_per_pixel=32;\n              }\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if (((ssize_t) image->columns != (ssize_t) ((signed int) image->columns)) ||\n        ((ssize_t) image->rows != (ssize_t) ((signed int) image->rows)))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n      image->columns+256UL)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        unsigned int\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((unsigned int) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 16:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            unsigned short\n              pixel;\n\n            pixel=0;\n            if (bmp_subtype == ARGB4444)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelAlpha(image,p),15) << 12);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),15) << 8);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),15) << 4);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),15));\n              }\n            else if (bmp_subtype == RGB565)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 11);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),63) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            else\n              {\n                if (bmp_subtype == ARGB1555)\n                  pixel=(unsigned short) (ScaleQuantumToAny(\n                    GetPixelAlpha(image,p),1) << 15);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 10);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),31) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            *((unsigned short *) q)=pixel;\n            q+=2;\n            p+=GetPixelChannels(image);\n          }\n          for (x=2L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%u)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%u\",bmp_info.number_colors);\n      }\n    profile_data=0;\n    profile_size=0;\n    profile_size_pad=0;\n    if (profile != (StringInfo *) NULL)\n      {\n        profile_data=(MagickOffsetType) bmp_info.file_size-14;  /* from head of BMP info header */\n        profile_size=(MagickOffsetType) GetStringInfoLength(profile);\n        if ((profile_size % 4) > 0)\n          profile_size_pad=4-(profile_size%4);\n        bmp_info.file_size+=profile_size+profile_size_pad;\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.red_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.green_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.blue_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.alpha_mask);\n        if (profile != (StringInfo *) NULL)\n          (void) WriteBlobLSBLong(image,0x4D424544U);  /* PROFILE_EMBEDDED */\n        else\n          (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,(unsigned int) profile_data);\n            (void) WriteBlobLSBLong(image,(unsigned int)\n              (profile_size+profile_size_pad));\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %u bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    if (profile != (StringInfo *) NULL)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                                \"  Profile:  %g bytes\",(double) profile_size+profile_size_pad);\n        (void) WriteBlob(image,(size_t) profile_size,GetStringInfoDatum(profile));\n        if (profile_size_pad > 0)  /* padding for 4 bytes multiple */\n          (void) WriteBlob(image,(size_t) profile_size_pad,\"\\0\\0\\0\");\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "output": "0",
        "index": 89276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}\n",
        "output": "0",
        "index": 60787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void processRequest(struct reqelem * req)\n{\n\tssize_t n;\n\tunsigned int l, m;\n\tunsigned char buf[2048];\n\tconst unsigned char * p;\n\tint type;\n\tstruct device * d = devlist;\n\tunsigned char rbuf[4096];\n\tunsigned char * rp = rbuf+1;\n\tunsigned char nrep = 0;\n\ttime_t t;\n\tstruct service * newserv = NULL;\n\tstruct service * serv;\n\n\tn = read(req->socket, buf, sizeof(buf));\n\tif(n<0) {\n\t\tif(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn;\t/* try again later */\n\t\tsyslog(LOG_ERR, \"(s=%d) processRequest(): read(): %m\", req->socket);\n\t\tgoto error;\n\t}\n\tif(n==0) {\n\t\tsyslog(LOG_INFO, \"(s=%d) request connection closed\", req->socket);\n\t\tgoto error;\n\t}\n\tt = time(NULL);\n\ttype = buf[0];\n\tp = buf + 1;\n\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\tif(p+l > buf+n) {\n\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\tgoto error;\n\t}\n\tif(l == 0 && type != 3) {\n\t\tsyslog(LOG_WARNING, \"bad request (length=0)\");\n\t\tgoto error;\n\t}\n\tsyslog(LOG_INFO, \"(s=%d) request type=%d str='%.*s'\",\n\t       req->socket, type, l, p);\n\tswitch(type) {\n\tcase 1:\t/* request by type */\n\tcase 2:\t/* request by USN (unique id) */\n\tcase 3:\t/* everything */\n\t\twhile(d && (nrep < 255)) {\n\t\t\tif(d->t < t) {\n\t\t\t\tsyslog(LOG_INFO, \"outdated device\");\n\t\t\t} else {\n\t\t\t\t/* test if we can put more responses in the buffer */\n\t\t\t\tif(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l\n\t\t\t\t  + d->headers[HEADER_USN].l + 6\n\t\t\t\t  + (rp - rbuf) >= (int)sizeof(rbuf))\n\t\t\t\t\tbreak;\n\t\t\t\tif( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))\n\t\t\t\t  ||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))\n\t\t\t\t  ||(type==3) ) {\n\t\t\t\t\t/* response :\n\t\t\t\t\t * 1 - Location\n\t\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t\t * 3 - usn */\n\t\t\t\t\tm = d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);\n\t\t\t\t\trp += d->headers[HEADER_LOCATION].l;\n\t\t\t\t\tm = d->headers[HEADER_NT].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);\n\t\t\t\t\trp += d->headers[HEADER_NT].l;\n\t\t\t\t\tm = d->headers[HEADER_USN].l;\n\t\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\t\tmemcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);\n\t\t\t\t\trp += d->headers[HEADER_USN].l;\n\t\t\t\t\tnrep++;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d->next;\n\t\t}\n\t\t/* Also look in service list */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv && (nrep < 255);\n\t\t    serv = serv->entries.le_next) {\n\t\t\t/* test if we can put more responses in the buffer */\n\t\t\tif(strlen(serv->location) + strlen(serv->st)\n\t\t\t  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))\n\t\t\t  \tbreak;\n\t\t\tif( (type==1 && 0==strncmp(serv->st, (const char *)p, l))\n\t\t\t  ||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))\n\t\t\t  ||(type==3) ) {\n\t\t\t\t/* response :\n\t\t\t\t * 1 - Location\n\t\t\t\t * 2 - NT (device/service type)\n\t\t\t\t * 3 - usn */\n\t\t\t\tm = strlen(serv->location);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->location, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->st);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->st, m);\n\t\t\t\trp += m;\n\t\t\t\tm = strlen(serv->usn);\n\t\t\t\tCODELENGTH(m, rp);\n\t\t\t\tmemcpy(rp, serv->usn, m);\n\t\t\t\trp += m;\n\t\t\t\tnrep++;\n\t\t\t}\n\t\t}\n\t\trbuf[0] = nrep;\n\t\tsyslog(LOG_DEBUG, \"(s=%d) response : %d device%s\",\n\t\t       req->socket, nrep, (nrep > 1) ? \"s\" : \"\");\n\t\tif(write(req->socket, rbuf, rp - rbuf) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase 4:\t/* submit service */\n\t\tnewserv = malloc(sizeof(struct service));\n\t\tif(!newserv) {\n \t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n \t\t\tgoto error;\n \t\t}\n \t\tif(containsForbiddenChars(p, l)) {\n \t\t\tsyslog(LOG_ERR, \"bad request (st contains forbidden chars)\");\n \t\t\tgoto error;\n\t\t}\n\t\tnewserv->st = malloc(l + 1);\n\t\tif(!newserv->st) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->st, p, l);\n\t\tnewserv->st[l] = '\\0';\n\t\tp += l;\n\t\tif(p >= buf + n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (missing usn)\");\n\t\t\tgoto error;\n\t\t}\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (usn contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"usn='%.*s'\", l, p);\n\t\tnewserv->usn = malloc(l + 1);\n\t\tif(!newserv->usn) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->usn, p, l);\n\t\tnewserv->usn[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (server contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"server='%.*s'\", l, p);\n\t\tnewserv->server = malloc(l + 1);\n\t\tif(!newserv->server) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->server, p, l);\n\t\tnewserv->server[l] = '\\0';\n\t\tp += l;\n\t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n\t\tif(p+l > buf+n) {\n\t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n\t\t\tgoto error;\n\t\t}\n\t\tif(containsForbiddenChars(p, l)) {\n\t\t\tsyslog(LOG_ERR, \"bad request (location contains forbidden chars)\");\n\t\t\tgoto error;\n\t\t}\n\t\tsyslog(LOG_INFO, \"location='%.*s'\", l, p);\n\t\tnewserv->location = malloc(l + 1);\n\t\tif(!newserv->location) {\n\t\t\tsyslog(LOG_ERR, \"cannot allocate memory\");\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(newserv->location, p, l);\n\t\tnewserv->location[l] = '\\0';\n\t\t/* look in service list for duplicate */\n\t\tfor(serv = servicelisthead.lh_first;\n\t\t    serv;\n\t\t    serv = serv->entries.le_next) {\n\t\t\tif(0 == strcmp(newserv->usn, serv->usn)\n\t\t\t  && 0 == strcmp(newserv->st, serv->st)) {\n\t\t\t\tsyslog(LOG_INFO, \"Service allready in the list. Updating...\");\n\t\t\t\tfree(newserv->st);\n\t\t\t\tfree(newserv->usn);\n\t\t\t\tfree(serv->server);\n\t\t\t\tserv->server = newserv->server;\n\t\t\t\tfree(serv->location);\n\t\t\t\tserv->location = newserv->location;\n\t\t\t\tfree(newserv);\n\t\t\t\tnewserv = NULL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t/* Inserting new service */\n\t\tLIST_INSERT_HEAD(&servicelisthead, newserv, entries);\n\t\tnewserv = NULL;\n\t\t/*rbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0)\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t*/\n\t\tbreak;\n\tdefault:\n\t\tsyslog(LOG_WARNING, \"Unknown request type %d\", type);\n\t\trbuf[0] = '\\0';\n\t\tif(write(req->socket, rbuf, 1) < 0) {\n\t\t\tsyslog(LOG_ERR, \"(s=%d) write: %m\", req->socket);\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn;\nerror:\n\tif(newserv) {\n\t\tfree(newserv->st);\n\t\tfree(newserv->usn);\n\t\tfree(newserv->server);\n\t\tfree(newserv->location);\n\t\tfree(newserv);\n\t\tnewserv = NULL;\n\t}\n\tclose(req->socket);\n\treq->socket = -1;\n\treturn;\n}\n",
        "output": "1",
        "index": 182015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOLEAN btm_sec_set_security_level (CONNECTION_TYPE conn_type, char *p_name, UINT8 service_id,\n                                           UINT16 sec_level, UINT16 psm, UINT32 mx_proto_id,\n                                           UINT32 mx_chan_id)\n{\n    tBTM_SEC_SERV_REC   *p_srec;\n    UINT16               index;\n    UINT16               first_unused_record = BTM_NO_AVAIL_SEC_SERVICES;\n    BOOLEAN              record_allocated = FALSE;\n    BOOLEAN              is_originator;\n#if (L2CAP_UCD_INCLUDED == TRUE)\n    BOOLEAN              is_ucd;\n\n if (conn_type & CONNECTION_TYPE_ORIG_MASK)\n        is_originator = TRUE;\n else\n        is_originator = FALSE;\n\n if (conn_type & CONNECTION_TYPE_CONNLESS_MASK )\n {\n        is_ucd = TRUE;\n }\n else\n {\n        is_ucd = FALSE;\n }\n#else\n    is_originator = conn_type;\n#endif\n\n /* See if the record can be reused (same service name, psm, mx_proto_id,\n       service_id, and mx_chan_id), or obtain the next unused record */\n\n    p_srec = &btm_cb.sec_serv_rec[0];\n\n\n for (index = 0; index < BTM_SEC_MAX_SERVICE_RECORDS; index++, p_srec++)\n {\n /* Check if there is already a record for this service */\n if (p_srec->security_flags & BTM_SEC_IN_USE)\n {\n#if BTM_SEC_SERVICE_NAME_LEN > 0\n if (p_srec->psm == psm                  &&\n                p_srec->mx_proto_id == mx_proto_id  &&\n                service_id == p_srec->service_id    &&\n (!strncmp (p_name, (char *) p_srec->orig_service_name,\n                           BTM_SEC_SERVICE_NAME_LEN) ||\n !strncmp (p_name, (char *) p_srec->term_service_name,\n                           BTM_SEC_SERVICE_NAME_LEN)))\n#else\n if (p_srec->psm == psm                  &&\n                p_srec->mx_proto_id == mx_proto_id  &&\n                service_id == p_srec->service_id)\n#endif\n {\n                record_allocated = TRUE;\n break;\n }\n }\n /* Mark the first available service record */\n else if (!record_allocated)\n {\n            memset (p_srec, 0, sizeof(tBTM_SEC_SERV_REC));\n            record_allocated = TRUE;\n            first_unused_record = index;\n }\n }\n\n if (!record_allocated)\n {\n        BTM_TRACE_WARNING(\"BTM_SEC_REG: Out of Service Records (%d)\",  BTM_SEC_MAX_SERVICE_RECORDS);\n return(record_allocated);\n }\n\n /* Process the request if service record is valid */\n /* If a duplicate service wasn't found, use the first available */\n if (index >= BTM_SEC_MAX_SERVICE_RECORDS)\n {\n        index = first_unused_record;\n        p_srec = &btm_cb.sec_serv_rec[index];\n }\n\n    p_srec->psm         = psm;\n    p_srec->service_id  = service_id;\n    p_srec->mx_proto_id = mx_proto_id;\n\n if (is_originator)\n {\n        p_srec->orig_mx_chan_id = mx_chan_id;\n#if BTM_SEC_SERVICE_NAME_LEN > 0\n        BCM_STRNCPY_S ((char *)p_srec->orig_service_name, sizeof(p_srec->orig_service_name), p_name, BTM_SEC_SERVICE_NAME_LEN);\n#endif\n /* clear out the old setting, just in case it exists */\n#if (L2CAP_UCD_INCLUDED == TRUE)\n if ( is_ucd )\n {\n            p_srec->ucd_security_flags &=\n ~(BTM_SEC_OUT_AUTHORIZE | BTM_SEC_OUT_ENCRYPT    | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM |\n              BTM_SEC_FORCE_MASTER | BTM_SEC_ATTEMPT_MASTER | BTM_SEC_FORCE_SLAVE | BTM_SEC_ATTEMPT_SLAVE);\n }\n else\n#endif\n {\n            p_srec->security_flags &=\n ~(BTM_SEC_OUT_AUTHORIZE | BTM_SEC_OUT_ENCRYPT    | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM |\n              BTM_SEC_FORCE_MASTER | BTM_SEC_ATTEMPT_MASTER | BTM_SEC_FORCE_SLAVE | BTM_SEC_ATTEMPT_SLAVE);\n }\n\n /* Parameter validation.  Originator should not set requirements for incoming connections */\n        sec_level &= ~(BTM_SEC_IN_AUTHORIZE | BTM_SEC_IN_ENCRYPT | BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_MITM);\n\n if (btm_cb.security_mode == BTM_SEC_MODE_SP)\n {\n if (sec_level & BTM_SEC_OUT_AUTHENTICATE)\n                sec_level |= BTM_SEC_OUT_MITM;\n }\n\n /* Make sure the authenticate bit is set, when encrypt bit is set */\n if (sec_level & BTM_SEC_OUT_ENCRYPT)\n            sec_level |= BTM_SEC_OUT_AUTHENTICATE;\n\n /* outgoing connections usually set the security level right before\n         * the connection is initiated.\n         * set it to be the outgoing service */\n#if (L2CAP_UCD_INCLUDED == TRUE)\n if ( is_ucd == FALSE )\n#endif\n {\n            btm_cb.p_out_serv = p_srec;\n }\n }\n else\n {\n        p_srec->term_mx_chan_id = mx_chan_id;\n#if BTM_SEC_SERVICE_NAME_LEN > 0\n        BCM_STRNCPY_S ((char *)p_srec->term_service_name, sizeof(p_srec->term_service_name), p_name, BTM_SEC_SERVICE_NAME_LEN);\n#endif\n /* clear out the old setting, just in case it exists */\n#if (L2CAP_UCD_INCLUDED == TRUE)\n if ( is_ucd )\n {\n            p_srec->ucd_security_flags &=\n ~(BTM_SEC_IN_AUTHORIZE | BTM_SEC_IN_ENCRYPT     | BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_MITM |\n              BTM_SEC_FORCE_MASTER | BTM_SEC_ATTEMPT_MASTER | BTM_SEC_FORCE_SLAVE | BTM_SEC_ATTEMPT_SLAVE);\n }\n else\n#endif\n {\n            p_srec->security_flags &=\n ~(BTM_SEC_IN_AUTHORIZE | BTM_SEC_IN_ENCRYPT     | BTM_SEC_IN_AUTHENTICATE | BTM_SEC_IN_MITM |\n              BTM_SEC_FORCE_MASTER | BTM_SEC_ATTEMPT_MASTER | BTM_SEC_FORCE_SLAVE | BTM_SEC_ATTEMPT_SLAVE);\n }\n\n /* Parameter validation.  Acceptor should not set requirements for outgoing connections */\n        sec_level &= ~(BTM_SEC_OUT_AUTHORIZE | BTM_SEC_OUT_ENCRYPT | BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_MITM);\n\n if (btm_cb.security_mode == BTM_SEC_MODE_SP)\n {\n if (sec_level & BTM_SEC_IN_AUTHENTICATE)\n                sec_level |= BTM_SEC_IN_MITM;\n }\n\n /* Make sure the authenticate bit is set, when encrypt bit is set */\n if (sec_level & BTM_SEC_IN_ENCRYPT)\n            sec_level |= BTM_SEC_IN_AUTHENTICATE;\n }\n\n#if (L2CAP_UCD_INCLUDED == TRUE)\n if ( is_ucd )\n {\n        p_srec->security_flags     |= (UINT16)(BTM_SEC_IN_USE);\n        p_srec->ucd_security_flags |= (UINT16)(sec_level | BTM_SEC_IN_USE);\n }\n else\n {\n        p_srec->security_flags |= (UINT16)(sec_level | BTM_SEC_IN_USE);\n }\n\n    BTM_TRACE_API(\"BTM_SEC_REG[%d]: id %d, conn_type 0x%x, psm 0x%04x, proto_id %d, chan_id %d\",\n                   index, service_id, conn_type, psm, mx_proto_id, mx_chan_id);\n\n    BTM_TRACE_API(\"               : security_flags: 0x%04x, ucd_security_flags: 0x%04x\",\n                   p_srec->security_flags, p_srec->ucd_security_flags);\n\n#if BTM_SEC_SERVICE_NAME_LEN > 0\n    BTM_TRACE_API(\"               : service name [%s] (up to %d chars saved)\",\n                   p_name, BTM_SEC_SERVICE_NAME_LEN);\n#endif\n#else\n    p_srec->security_flags |= (UINT16)(sec_level | BTM_SEC_IN_USE);\n\n    BTM_TRACE_API(\"BTM_SEC_REG[%d]: id %d, is_orig %d, psm 0x%04x, proto_id %d, chan_id %d\",\n                   index, service_id, is_originator, psm, mx_proto_id, mx_chan_id);\n\n#if BTM_SEC_SERVICE_NAME_LEN > 0\n    BTM_TRACE_API(\"               : sec: 0x%x, service name [%s] (up to %d chars saved)\",\n                   p_srec->security_flags, p_name, BTM_SEC_SERVICE_NAME_LEN);\n#endif\n#endif\n\n\n return(record_allocated);\n}\n",
        "output": "0",
        "index": 174632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::CreateFrame(\n    int routing_id,\n    service_manager::mojom::InterfaceProviderPtr interface_provider,\n    int proxy_routing_id,\n    int opener_routing_id,\n    int parent_routing_id,\n    int previous_sibling_routing_id,\n    const base::UnguessableToken& devtools_frame_token,\n    const FrameReplicationState& replicated_state,\n    CompositorDependencies* compositor_deps,\n    const mojom::CreateFrameWidgetParams& widget_params,\n    const FrameOwnerProperties& frame_owner_properties,\n    bool has_committed_real_load) {\n  RenderViewImpl* render_view = nullptr;\n  RenderFrameImpl* render_frame = nullptr;\n  blink::WebLocalFrame* web_frame = nullptr;\n  if (proxy_routing_id == MSG_ROUTING_NONE) {\n\n    RenderFrameProxy* parent_proxy =\n        RenderFrameProxy::FromRoutingID(parent_routing_id);\n    CHECK(parent_proxy);\n    blink::WebRemoteFrame* parent_web_frame = parent_proxy->web_frame();\n\n    blink::WebFrame* previous_sibling_web_frame = nullptr;\n    RenderFrameProxy* previous_sibling_proxy =\n        RenderFrameProxy::FromRoutingID(previous_sibling_routing_id);\n    if (previous_sibling_proxy)\n      previous_sibling_web_frame = previous_sibling_proxy->web_frame();\n\n    render_view = parent_proxy->render_view();\n    render_frame = RenderFrameImpl::Create(\n        parent_proxy->render_view(), routing_id, std::move(interface_provider),\n        devtools_frame_token);\n    render_frame->InitializeBlameContext(FromRoutingID(parent_routing_id));\n    render_frame->unique_name_helper_.set_propagated_name(\n        replicated_state.unique_name);\n    web_frame = parent_web_frame->CreateLocalChild(\n        replicated_state.scope, WebString::FromUTF8(replicated_state.name),\n        replicated_state.frame_policy.sandbox_flags, render_frame,\n        render_frame->blink_interface_registry_.get(),\n        previous_sibling_web_frame,\n        replicated_state.frame_policy.container_policy,\n        ConvertFrameOwnerPropertiesToWebFrameOwnerProperties(\n            frame_owner_properties),\n        replicated_state.frame_owner_element_type,\n        ResolveOpener(opener_routing_id));\n\n    render_frame->in_frame_tree_ = true;\n  } else {\n    RenderFrameProxy* proxy =\n        RenderFrameProxy::FromRoutingID(proxy_routing_id);\n    if (!proxy)\n      return;\n\n    const bool proxy_is_main_frame = !proxy->web_frame()->Parent();\n\n    render_view = proxy->render_view();\n    render_frame = RenderFrameImpl::Create(render_view, routing_id,\n                                           std::move(interface_provider),\n                                           devtools_frame_token);\n    render_frame->InitializeBlameContext(nullptr);\n    render_frame->proxy_routing_id_ = proxy_routing_id;\n    proxy->set_provisional_frame_routing_id(routing_id);\n    web_frame = blink::WebLocalFrame::CreateProvisional(\n        render_frame, render_frame->blink_interface_registry_.get(),\n        proxy->web_frame(), replicated_state.frame_policy.sandbox_flags,\n        replicated_state.frame_policy.container_policy);\n    DCHECK_EQ(proxy_is_main_frame, !web_frame->Parent());\n  }\n\n  DCHECK(render_view);\n  DCHECK(render_frame);\n  DCHECK(web_frame);\n\n  const bool is_main_frame = !web_frame->Parent();\n\n  if (!is_main_frame)\n    DCHECK_NE(parent_routing_id, MSG_ROUTING_NONE);\n\n  if (is_main_frame) {\n\n    DCHECK_NE(widget_params.routing_id, MSG_ROUTING_NONE);\n\n    RenderWidget* render_widget = render_view->GetWidget();\n\n    auto* web_frame_widget = blink::WebFrameWidget::CreateForMainFrame(\n        render_view->WidgetClient(), web_frame);\n    render_view->AttachWebFrameWidget(web_frame_widget);\n    render_widget->UpdateWebViewWithDeviceScaleFactor();\n\n    render_widget->WarmupCompositor();\n\n    render_frame->render_widget_ = render_widget;\n  } else if (widget_params.routing_id != MSG_ROUTING_NONE) {\n\n    const ScreenInfo& screen_info_from_main_frame =\n        render_view->GetWidget()->GetWebScreenInfo();\n\n    scoped_refptr<RenderWidget> render_widget;\n    if (g_create_render_widget) {\n      render_widget = g_create_render_widget(\n          widget_params.routing_id, compositor_deps,\n          screen_info_from_main_frame, blink::kWebDisplayModeUndefined,\n          /*is_frozen=*/false, widget_params.hidden,\n          /*never_visible=*/false);\n    } else {\n      render_widget = base::MakeRefCounted<RenderWidget>(\n          widget_params.routing_id, compositor_deps,\n          screen_info_from_main_frame, blink::kWebDisplayModeUndefined,\n          /*is_frozen=*/false, widget_params.hidden,\n          /*never_visible=*/false);\n    }\n\n    auto* web_frame_widget = blink::WebFrameWidget::CreateForChildLocalRoot(\n        render_widget.get(), web_frame);\n\n    render_widget->InitForChildLocalRoot(web_frame_widget);\n    render_widget->UpdateWebViewWithDeviceScaleFactor();\n\n    if (g_render_widget_initialized)\n      g_render_widget_initialized(render_widget.get());\n\n    render_frame->render_widget_ = std::move(render_widget);\n  }\n\n  if (has_committed_real_load)\n    render_frame->frame_->SetCommittedFirstRealLoad();\n\n  render_frame->Initialize();\n}\n",
        "output": "0",
        "index": 165878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_server_print_log ()\n{\n    struct t_irc_server *ptr_server;\n    struct t_irc_channel *ptr_channel;\n    int i;\n    \n    for (ptr_server = irc_servers; ptr_server;\n         ptr_server = ptr_server->next_server)\n    {\n        weechat_log_printf (\"\");\n        weechat_log_printf (\"[server %s (addr:0x%lx)]\", ptr_server->name, ptr_server);\n        /* addresses */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ADDRESSES]))\n            weechat_log_printf (\"  addresses. . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_ADDRESSES));\n        else\n            weechat_log_printf (\"  addresses. . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_ADDRESSES]));\n        /* proxy */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_PROXY]))\n            weechat_log_printf (\"  proxy. . . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_PROXY));\n        else\n            weechat_log_printf (\"  proxy. . . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_PROXY]));\n        /* ipv6 */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_IPV6]))\n            weechat_log_printf (\"  ipv6 . . . . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_IPV6)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ipv6 . . . . . . . . : %s\",\n                                weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_IPV6]) ?\n                                \"on\" : \"off\");\n        /* ssl */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL]))\n            weechat_log_printf (\"  ssl. . . . . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_SSL)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ssl. . . . . . . . . : %s\",\n                                weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_SSL]) ?\n                                \"on\" : \"off\");\n        /* ssl_cert */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_CERT]))\n            weechat_log_printf (\"  ssl_cert . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SSL_CERT));\n        else\n            weechat_log_printf (\"  ssl_cert . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_SSL_CERT]));\n        /* ssl_dhkey_size */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_DHKEY_SIZE]))\n            weechat_log_printf (\"  ssl_dhkey_size . . . : null ('%d')\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n        else\n            weechat_log_printf (\"  ssl_dhkey_size . . . : '%d'\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SSL_DHKEY_SIZE]));\n        /* ssl_verify */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SSL_VERIFY]))\n            weechat_log_printf (\"  ssl_verify . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_SSL_VERIFY)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  ssl_verify . . . . . : %s\",\n                                weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_SSL_VERIFY]) ?\n                                \"on\" : \"off\");\n        /* password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_PASSWORD]))\n            weechat_log_printf (\"  password . . . . . . : null\");\n        else\n            weechat_log_printf (\"  password . . . . . . : (hidden)\");\n        /* sasl_mechanism */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_MECHANISM]))\n            weechat_log_printf (\"  sasl_mechanism . . . : null ('%s')\",\n                                irc_sasl_mechanism_string[IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_SASL_MECHANISM)]);\n        else\n            weechat_log_printf (\"  sasl_mechanism . . . : '%s'\",\n                                irc_sasl_mechanism_string[weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_SASL_MECHANISM])]);\n        /* sasl_username */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_USERNAME]))\n            weechat_log_printf (\"  sasl_username. . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_SASL_USERNAME));\n        else\n            weechat_log_printf (\"  sasl_username. . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_USERNAME]));\n        /* sasl_password */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_SASL_PASSWORD]))\n            weechat_log_printf (\"  sasl_password. . . . : null\");\n        else\n            weechat_log_printf (\"  sasl_password. . . . : (hidden)\");\n        /* autoconnect */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT]))\n            weechat_log_printf (\"  autoconnect. . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOCONNECT)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autoconnect. . . . . : %s\",\n                                weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTOCONNECT]) ?\n                                \"on\" : \"off\");\n        /* autoreconnect */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT]))\n            weechat_log_printf (\"  autoreconnect. . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTORECONNECT)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autoreconnect. . . . : %s\",\n                                weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT]) ?\n                                \"on\" : \"off\");\n        /* autoreconnect_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT_DELAY]))\n            weechat_log_printf (\"  autoreconnect_delay. : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY));\n        else\n            weechat_log_printf (\"  autoreconnect_delay. : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AUTORECONNECT_DELAY]));\n        /* nicks */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_NICKS]))\n            weechat_log_printf (\"  nicks. . . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_NICKS));\n        else\n            weechat_log_printf (\"  nicks. . . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_NICKS]));\n        /* username */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_USERNAME]))\n            weechat_log_printf (\"  username . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_USERNAME));\n        else\n            weechat_log_printf (\"  username . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_USERNAME]));\n        /* realname */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_REALNAME]))\n            weechat_log_printf (\"  realname . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_REALNAME));\n        else\n            weechat_log_printf (\"  realname . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_REALNAME]));\n        /* local_hostname */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_LOCAL_HOSTNAME]))\n            weechat_log_printf (\"  local_hostname . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_LOCAL_HOSTNAME));\n        else\n            weechat_log_printf (\"  local_hostname . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_LOCAL_HOSTNAME]));\n        /* command */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_COMMAND]))\n            weechat_log_printf (\"  command. . . . . . . : null\");\n        else\n            weechat_log_printf (\"  command. . . . . . . : (hidden)\");\n        /* command_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_COMMAND_DELAY]))\n            weechat_log_printf (\"  command_delay. . . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_COMMAND_DELAY));\n        else\n            weechat_log_printf (\"  command_delay. . . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_COMMAND_DELAY]));\n        /* autojoin */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN]))\n            weechat_log_printf (\"  autojoin . . . . . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_AUTOJOIN));\n        else\n            weechat_log_printf (\"  autojoin . . . . . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_AUTOJOIN]));\n        /* autorejoin */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN]))\n            weechat_log_printf (\"  autorejoin . . . . . : null (%s)\",\n                                (IRC_SERVER_OPTION_BOOLEAN(ptr_server, IRC_SERVER_OPTION_AUTOREJOIN)) ?\n                                \"on\" : \"off\");\n        else\n            weechat_log_printf (\"  autorejoin . . . . . : %s\",\n                                weechat_config_boolean (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN]) ?\n                                \"on\" : \"off\");\n        /* autorejoin_delay */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN_DELAY]))\n            weechat_log_printf (\"  autorejoin_delay . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AUTOREJOIN_DELAY));\n        else\n            weechat_log_printf (\"  autorejoin_delay . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AUTOREJOIN_DELAY]));\n        /* connection_timeout */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_CONNECTION_TIMEOUT]))\n            weechat_log_printf (\"  connection_timeout . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_CONNECTION_TIMEOUT));\n        else\n            weechat_log_printf (\"  connection_timeout . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_CONNECTION_TIMEOUT]));\n        /* anti_flood_prio_high */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH]))\n            weechat_log_printf (\"  anti_flood_prio_high : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH));\n        else\n            weechat_log_printf (\"  anti_flood_prio_high : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_HIGH]));\n        /* anti_flood_prio_low */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW]))\n            weechat_log_printf (\"  anti_flood_prio_low. : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW));\n        else\n            weechat_log_printf (\"  anti_flood_prio_low. : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_ANTI_FLOOD_PRIO_LOW]));\n        /* away_check */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK]))\n            weechat_log_printf (\"  away_check . . . . . : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AWAY_CHECK));\n        else\n            weechat_log_printf (\"  away_check . . . . . : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK]));\n        /* away_check_max_nicks */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS]))\n            weechat_log_printf (\"  away_check_max_nicks : null (%d)\",\n                                IRC_SERVER_OPTION_INTEGER(ptr_server, IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS));\n        else\n            weechat_log_printf (\"  away_check_max_nicks : %d\",\n                                weechat_config_integer (ptr_server->options[IRC_SERVER_OPTION_AWAY_CHECK_MAX_NICKS]));\n        /* default_msg_part */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_DEFAULT_MSG_PART]))\n            weechat_log_printf (\"  default_msg_part . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_DEFAULT_MSG_PART));\n        else\n            weechat_log_printf (\"  default_msg_part . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_DEFAULT_MSG_PART]));\n        /* default_msg_quit */\n        if (weechat_config_option_is_null (ptr_server->options[IRC_SERVER_OPTION_DEFAULT_MSG_QUIT]))\n            weechat_log_printf (\"  default_msg_quit . . : null ('%s')\",\n                                IRC_SERVER_OPTION_STRING(ptr_server, IRC_SERVER_OPTION_DEFAULT_MSG_QUIT));\n        else\n            weechat_log_printf (\"  default_msg_quit . . : '%s'\",\n                                weechat_config_string (ptr_server->options[IRC_SERVER_OPTION_DEFAULT_MSG_QUIT]));\n        /* other server variables */\n        weechat_log_printf (\"  temp_server. . . . . : %d\",    ptr_server->temp_server);\n        weechat_log_printf (\"  reloading_from_config: %d\",    ptr_server->reloaded_from_config);\n        weechat_log_printf (\"  reloaded_from_config : %d\",    ptr_server->reloaded_from_config);\n        weechat_log_printf (\"  addresses_count. . . : %d\",    ptr_server->addresses_count);\n        weechat_log_printf (\"  addresses_array. . . : 0x%lx\", ptr_server->addresses_array);\n        weechat_log_printf (\"  ports_array. . . . . : 0x%lx\", ptr_server->ports_array);\n        weechat_log_printf (\"  index_current_address: %d\",    ptr_server->index_current_address);\n        weechat_log_printf (\"  current_address. . . : '%s'\",  ptr_server->current_address);\n        weechat_log_printf (\"  current_ip . . . . . : '%s'\",  ptr_server->current_ip);\n        weechat_log_printf (\"  current_port . . . . : %d\",    ptr_server->current_port);\n        weechat_log_printf (\"  sock . . . . . . . . : %d\",    ptr_server->sock);\n        weechat_log_printf (\"  hook_connect . . . . : 0x%lx\", ptr_server->hook_connect);\n        weechat_log_printf (\"  hook_fd. . . . . . . : 0x%lx\", ptr_server->hook_fd);\n        weechat_log_printf (\"  hook_timer_connection: 0x%lx\", ptr_server->hook_timer_connection);\n        weechat_log_printf (\"  hook_timer_sasl. . . : 0x%lx\", ptr_server->hook_timer_sasl);\n        weechat_log_printf (\"  is_connected . . . . : %d\",    ptr_server->is_connected);\n        weechat_log_printf (\"  ssl_connected. . . . : %d\",    ptr_server->ssl_connected);\n#ifdef HAVE_GNUTLS\n        weechat_log_printf (\"  gnutls_sess. . . . . : 0x%lx\", ptr_server->gnutls_sess);\n#endif\n        weechat_log_printf (\"  unterminated_message : '%s'\",  ptr_server->unterminated_message);\n        weechat_log_printf (\"  nicks_count. . . . . : %d\",    ptr_server->nicks_count);\n        weechat_log_printf (\"  nicks_array. . . . . : 0x%lx\", ptr_server->nicks_array);\n        weechat_log_printf (\"  nick_first_tried . . : %d\",    ptr_server->nick_first_tried);\n        weechat_log_printf (\"  nick . . . . . . . . : '%s'\",  ptr_server->nick);\n        weechat_log_printf (\"  nick_modes . . . . . : '%s'\",  ptr_server->nick_modes);\n        weechat_log_printf (\"  isupport . . . . . . : '%s'\",  ptr_server->isupport);\n        weechat_log_printf (\"  prefix_modes . . . . : '%s'\",  ptr_server->prefix_modes);\n        weechat_log_printf (\"  prefix_chars . . . . : '%s'\",  ptr_server->prefix_chars);\n        weechat_log_printf (\"  reconnect_delay. . . : %d\",    ptr_server->reconnect_delay);\n        weechat_log_printf (\"  reconnect_start. . . : %ld\",   ptr_server->reconnect_start);\n        weechat_log_printf (\"  command_time . . . . : %ld\",   ptr_server->command_time);\n        weechat_log_printf (\"  reconnect_join . . . : %d\",    ptr_server->reconnect_join);\n        weechat_log_printf (\"  disable_autojoin . . : %d\",    ptr_server->disable_autojoin);\n        weechat_log_printf (\"  is_away. . . . . . . : %d\",    ptr_server->is_away);\n        weechat_log_printf (\"  away_message . . . . : '%s'\",  ptr_server->away_message);\n        weechat_log_printf (\"  away_time. . . . . . : %ld\",   ptr_server->away_time);\n        weechat_log_printf (\"  lag. . . . . . . . . : %d\",    ptr_server->lag);\n        weechat_log_printf (\"  lag_check_time . . . : tv_sec:%d, tv_usec:%d\",\n                            ptr_server->lag_check_time.tv_sec,\n                            ptr_server->lag_check_time.tv_usec);\n        weechat_log_printf (\"  lag_next_check . . . : %ld\",   ptr_server->lag_next_check);\n        weechat_log_printf (\"  lag_last_refresh . . : %ld\",   ptr_server->lag_last_refresh);\n        weechat_log_printf (\"  cmd_list_regexp. . . : 0x%lx\", ptr_server->cmd_list_regexp);\n        weechat_log_printf (\"  last_user_message. . : %ld\",   ptr_server->last_user_message);\n        weechat_log_printf (\"  last_away_check. . . : %ld\",   ptr_server->last_away_check);\n        for (i = 0; i < IRC_SERVER_NUM_OUTQUEUES_PRIO; i++)\n        {\n            weechat_log_printf (\"  outqueue[%02d] . . . . : 0x%lx\", i, ptr_server->outqueue[i]);\n            weechat_log_printf (\"  last_outqueue[%02d]. . : 0x%lx\", i, ptr_server->last_outqueue[i]);\n        }\n        weechat_log_printf (\"  redirects. . . . . . : 0x%lx\", ptr_server->redirects);\n        weechat_log_printf (\"  last_redirect. . . . : 0x%lx\", ptr_server->last_redirect);\n        weechat_log_printf (\"  notify_list. . . . . : 0x%lx\", ptr_server->notify_list);\n        weechat_log_printf (\"  last_notify. . . . . : 0x%lx\", ptr_server->last_notify);\n        weechat_log_printf (\"  buffer . . . . . . . : 0x%lx\", ptr_server->buffer);\n        weechat_log_printf (\"  buffer_as_string . . : 0x%lx\", ptr_server->buffer_as_string);\n        weechat_log_printf (\"  channels . . . . . . : 0x%lx\", ptr_server->channels);\n        weechat_log_printf (\"  last_channel . . . . : 0x%lx\", ptr_server->last_channel);\n        weechat_log_printf (\"  prev_server. . . . . : 0x%lx\", ptr_server->prev_server);\n        weechat_log_printf (\"  next_server. . . . . : 0x%lx\", ptr_server->next_server);\n        \n        irc_redirect_print_log (ptr_server);\n        \n        irc_notify_print_log (ptr_server);\n        \n        for (ptr_channel = ptr_server->channels; ptr_channel;\n             ptr_channel = ptr_channel->next_channel)\n        {\n            irc_channel_print_log (ptr_channel);\n        }\n    }\n}\n",
        "output": "0",
        "index": 3503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n \ts64 smin_val, smax_val;\n \tu64 umin_val, umax_val;\n \tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n \n \tif (insn_bitness == 32) {\n \t\t/* Relevant for 32-bit RSH: Information can propagate towards\n\t\t * LSB, so it isn't sufficient to only truncate the output to\n\t\t * 32 bits.\n\t\t */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tif ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||\n\t    smin_val > smax_val || umin_val > umax_val) {\n\t\t/* Taint dst register if offset had invalid bounds derived from\n\t\t * e.g. dead branches.\n\t\t */\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n\n\tif (!src_known &&\n\t    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {\n\t\t__mark_reg_unknown(dst_reg);\n\t\treturn 0;\n\t}\n \n \tswitch (opcode) {\n \tcase BPF_ADD:\n \t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n \t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n \t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value += smin_val;\n\t\t\tdst_reg->smax_value += smax_val;\n\t\t}\n\t\tif (dst_reg->umin_value + umin_val < umin_val ||\n\t\t    dst_reg->umax_value + umax_val < umax_val) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value += umin_val;\n\t\t\tdst_reg->umax_value += umax_val;\n\t\t}\n \t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n \t\tbreak;\n \tcase BPF_SUB:\n \t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n \t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n \t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value -= smax_val;\n\t\t\tdst_reg->smax_value -= smin_val;\n\t\t}\n\t\tif (dst_reg->umin_value < umax_val) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\t/* Cannot overflow (as long as bounds are consistent) */\n\t\t\tdst_reg->umin_value -= umax_val;\n\t\t\tdst_reg->umax_value -= umin_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);\n\t\tbreak;\n\tcase BPF_MUL:\n\t\tdst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);\n\t\tif (smin_val < 0 || dst_reg->smin_value < 0) {\n\t\t\t/* Ain't nobody got time to multiply that sign */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* Both values are positive, so we can work with unsigned and\n\t\t * copy the result to signed (unless it exceeds S64_MAX).\n\t\t */\n\t\tif (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {\n\t\t\t/* Potential overflow, we know nothing */\n\t\t\t__mark_reg_unbounded(dst_reg);\n\t\t\t/* (except what we can learn from the var_off) */\n\t\t\t__update_reg_bounds(dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\tdst_reg->umin_value *= umin_val;\n\t\tdst_reg->umax_value *= umax_val;\n\t\tif (dst_reg->umax_value > S64_MAX) {\n\t\t\t/* Overflow possible, we know nothing */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\tbreak;\n\tcase BPF_AND:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value &\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our minimum from the var_off, since that's inherently\n\t\t * bitwise.  Our maximum is the minimum of the operands' maxima.\n\t\t */\n\t\tdst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = dst_reg->var_off.value;\n\t\tdst_reg->umax_value = min(dst_reg->umax_value, umax_val);\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ANDing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ANDing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_OR:\n\t\tif (src_known && dst_known) {\n\t\t\t__mark_reg_known(dst_reg, dst_reg->var_off.value |\n\t\t\t\t\t\t  src_reg.var_off.value);\n\t\t\tbreak;\n\t\t}\n\t\t/* We get our maximum from the var_off, and our minimum is the\n\t\t * maximum of the operands' minima\n\t\t */\n\t\tdst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);\n\t\tdst_reg->umin_value = max(dst_reg->umin_value, umin_val);\n\t\tdst_reg->umax_value = dst_reg->var_off.value |\n\t\t\t\t      dst_reg->var_off.mask;\n\t\tif (dst_reg->smin_value < 0 || smin_val < 0) {\n\t\t\t/* Lose signed bounds when ORing negative numbers,\n\t\t\t * ain't nobody got time for that.\n\t\t\t */\n\t\t\tdst_reg->smin_value = S64_MIN;\n\t\t\tdst_reg->smax_value = S64_MAX;\n\t\t} else {\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\tif (dst_reg->umax_value > 1ULL << (63 - umax_val)) {\n\t\t\tdst_reg->umin_value = 0;\n\t\t\tdst_reg->umax_value = U64_MAX;\n\t\t} else {\n\t\t\tdst_reg->umin_value <<= umin_val;\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t * 3) the signed bounds cross zero, so they tell us nothing\n\t\t *    about the result\n\t\t * If the value in dst_reg is known nonnegative, then again the\n\t\t * unsigned bounts capture the signed bounds.\n\t\t * Thus, in all cases it suffices to blow away our signed bounds\n\t\t * and rely on inferring new ones from the unsigned bounds and\n\t\t * var_off of the result.\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\tdst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_ARSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Upon reaching here, src_known is true and\n\t\t * umax_val is equal to umin_val.\n\t\t */\n\t\tdst_reg->smin_value >>= umin_val;\n\t\tdst_reg->smax_value >>= umin_val;\n\t\tdst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);\n\n\t\t/* blow away the dst_reg umin_value/umax_value and rely on\n\t\t * dst_reg var_off to refine the result.\n\t\t */\n\t\tdst_reg->umin_value = 0;\n\t\tdst_reg->umax_value = U64_MAX;\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}\n",
        "output": "1",
        "index": 182902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType ContrastStretchImage(Image *image,\n  const double black_point,const double white_point,ExceptionInfo *exception)\n{\n#define MaxRange(color)  ((double) ScaleQuantumToMap((Quantum) (color)))\n#define ContrastStretchImageTag  \"ContrastStretch/Image\"\n\n  CacheView\n    *image_view;\n\n  double\n    *black,\n    *histogram,\n    *stretch_map,\n    *white;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate histogram and stretch map.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   if (SetImageGray(image,exception) != MagickFalse)\n     (void) SetImageColorspace(image,GRAYColorspace,exception);\n   black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));\n   white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));\n   histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n    sizeof(*histogram));\n  stretch_map=(double *) AcquireQuantumMemory(MaxMap+1UL,\n    GetPixelChannels(image)*sizeof(*stretch_map));\n  if ((black == (double *) NULL) || (white == (double *) NULL) ||\n      (histogram == (double *) NULL) || (stretch_map == (double *) NULL))\n    {\n      if (stretch_map != (double *) NULL)\n        stretch_map=(double *) RelinquishMagickMemory(stretch_map);\n      if (histogram != (double *) NULL)\n        histogram=(double *) RelinquishMagickMemory(histogram);\n      if (white != (double *) NULL)\n        white=(double *) RelinquishMagickMemory(white);\n      if (black != (double *) NULL)\n        black=(double *) RelinquishMagickMemory(black);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  /*\n    Form histogram.\n  */\n  status=MagickTrue;\n  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        pixel;\n\n      pixel=GetPixelIntensity(image,p);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        if (image->channel_mask != DefaultChannels)\n          pixel=(double) p[i];\n        histogram[GetPixelChannels(image)*ScaleQuantumToMap(\n          ClampToQuantum(pixel))+i]++;\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  /*\n    Find the histogram boundaries by locating the black/white levels.\n  */\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    double\n      intensity;\n\n    register ssize_t\n      j;\n\n    black[i]=0.0;\n    white[i]=MaxRange(QuantumRange);\n    intensity=0.0;\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      intensity+=histogram[GetPixelChannels(image)*j+i];\n      if (intensity > black_point)\n        break;\n    }\n    black[i]=(double) j;\n    intensity=0.0;\n    for (j=(ssize_t) MaxMap; j != 0; j--)\n    {\n      intensity+=histogram[GetPixelChannels(image)*j+i];\n      if (intensity > ((double) image->columns*image->rows-white_point))\n        break;\n    }\n    white[i]=(double) j;\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  /*\n    Stretch the histogram to create the stretched image mapping.\n  */\n  (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*\n    sizeof(*stretch_map));\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    register ssize_t\n      j;\n\n    for (j=0; j <= (ssize_t) MaxMap; j++)\n    {\n      double\n        gamma;\n\n      gamma=PerceptibleReciprocal(white[i]-black[i]);\n      if (j < (ssize_t) black[i])\n        stretch_map[GetPixelChannels(image)*j+i]=0.0;\n      else\n        if (j > (ssize_t) white[i])\n          stretch_map[GetPixelChannels(image)*j+i]=(double) QuantumRange;\n        else\n          stretch_map[GetPixelChannels(image)*j+i]=(double) ScaleMapToQuantum(\n            (double) (MaxMap*gamma*(j-black[i])));\n    }\n  }\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        j;\n\n      /*\n        Stretch-contrast colormap.\n      */\n      for (j=0; j < (ssize_t) image->colors; j++)\n      {\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,RedPixelChannel);\n            image->colormap[j].red=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+i];\n          }\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,GreenPixelChannel);\n            image->colormap[j].green=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+i];\n          }\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,BluePixelChannel);\n            image->colormap[j].blue=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+i];\n          }\n        if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n          {\n            i=GetPixelChannelOffset(image,AlphaPixelChannel);\n            image->colormap[j].alpha=stretch_map[GetPixelChannels(image)*\n              ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+i];\n          }\n      }\n    }\n  /*\n    Stretch-contrast image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        j;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (j=0; j < (ssize_t) GetPixelChannels(image); j++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,j);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits & UpdatePixelTrait) == 0)\n          continue;\n        q[j]=ClampToQuantum(stretch_map[GetPixelChannels(image)*\n          ScaleQuantumToMap(q[j])+j]);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_ContrastStretchImage)\n#endif\n        proceed=SetImageProgress(image,ContrastStretchImageTag,progress++,\n          image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  stretch_map=(double *) RelinquishMagickMemory(stretch_map);\n  white=(double *) RelinquishMagickMemory(white);\n  black=(double *) RelinquishMagickMemory(black);\n  return(status);\n}\n",
        "output": "1",
        "index": 180167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\n\tmips_instruction ir)\n{\n\tint rfmt;\t\t/* resulting format */\n\tunsigned rcsr = 0;\t/* resulting csr */\n\tunsigned cond;\n\tunion {\n\t\tieee754dp d;\n\t\tieee754sp s;\n\t\tint w;\n#ifdef __mips64\n\t\ts64 l;\n#endif\n\t} rv;\t\t\t/* resulting value */\n\n\tMIPS_FPU_EMU_INC_STATS(cp1ops);\n\tswitch (rfmt = (MIPSInst_FFMT(ir) & 0xf)) {\n\tcase s_fmt:{\t\t/* 0 */\n\t\tunion {\n\t\t\tieee754sp(*b) (ieee754sp, ieee754sp);\n\t\t\tieee754sp(*u) (ieee754sp);\n\t\t} handler;\n\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\t\t/* binary ops */\n\t\tcase fadd_op:\n\t\t\thandler.b = ieee754sp_add;\n\t\t\tgoto scopbop;\n\t\tcase fsub_op:\n\t\t\thandler.b = ieee754sp_sub;\n\t\t\tgoto scopbop;\n\t\tcase fmul_op:\n\t\t\thandler.b = ieee754sp_mul;\n\t\t\tgoto scopbop;\n\t\tcase fdiv_op:\n\t\t\thandler.b = ieee754sp_div;\n\t\t\tgoto scopbop;\n\n\t\t\t/* unary  ops */\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fsqrt_op:\n\t\t\thandler.u = ieee754sp_sqrt;\n\t\t\tgoto scopuop;\n#endif\n#if __mips >= 4 && __mips != 32\n\t\tcase frsqrt_op:\n\t\t\thandler.u = fpemu_sp_rsqrt;\n\t\t\tgoto scopuop;\n\t\tcase frecip_op:\n\t\t\thandler.u = fpemu_sp_recip;\n\t\t\tgoto scopuop;\n#endif\n#if __mips >= 4\n\t\tcase fmovc_op:\n\t\t\tcond = fpucondbit[MIPSInst_FT(ir) >> 2];\n\t\t\tif (((ctx->fcr31 & cond) != 0) !=\n\t\t\t\t((MIPSInst_FT(ir) & 1) != 0))\n\t\t\t\treturn 0;\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovz_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] != 0)\n\t\t\t\treturn 0;\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovn_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] == 0)\n\t\t\t\treturn 0;\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tbreak;\n#endif\n\t\tcase fabs_op:\n\t\t\thandler.u = ieee754sp_abs;\n\t\t\tgoto scopuop;\n\t\tcase fneg_op:\n\t\t\thandler.u = ieee754sp_neg;\n\t\t\tgoto scopuop;\n\t\tcase fmov_op:\n\t\t\t/* an easy one */\n\t\t\tSPFROMREG(rv.s, MIPSInst_FS(ir));\n\t\t\tgoto copcsr;\n\n\t\t\t/* binary op on handler */\n\t\t      scopbop:\n\t\t\t{\n\t\t\t\tieee754sp fs, ft;\n\n\t\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tSPFROMREG(ft, MIPSInst_FT(ir));\n\n\t\t\t\trv.s = (*handler.b) (fs, ft);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\t\t      scopuop:\n\t\t\t{\n\t\t\t\tieee754sp fs;\n\n\t\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\trv.s = (*handler.u) (fs);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\t\t      copcsr:\n\t\t\tif (ieee754_cxtest(IEEE754_INEXACT))\n\t\t\t\trcsr |= FPU_CSR_INE_X | FPU_CSR_INE_S;\n\t\t\tif (ieee754_cxtest(IEEE754_UNDERFLOW))\n\t\t\t\trcsr |= FPU_CSR_UDF_X | FPU_CSR_UDF_S;\n\t\t\tif (ieee754_cxtest(IEEE754_OVERFLOW))\n\t\t\t\trcsr |= FPU_CSR_OVF_X | FPU_CSR_OVF_S;\n\t\t\tif (ieee754_cxtest(IEEE754_ZERO_DIVIDE))\n\t\t\t\trcsr |= FPU_CSR_DIV_X | FPU_CSR_DIV_S;\n\t\t\tif (ieee754_cxtest(IEEE754_INVALID_OPERATION))\n\t\t\t\trcsr |= FPU_CSR_INV_X | FPU_CSR_INV_S;\n\t\t\tbreak;\n\n\t\t\t/* unary conv ops */\n\t\tcase fcvts_op:\n\t\t\treturn SIGILL;\t/* not defined */\n\t\tcase fcvtd_op:{\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.d = ieee754dp_fsp(fs);\n\t\t\trfmt = d_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\t\tcase fcvtw_op:{\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.w = ieee754sp_tint(fs);\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fround_op:\n\t\tcase ftrunc_op:\n\t\tcase fceil_op:\n\t\tcase ffloor_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\n\t\t\trv.w = ieee754sp_tint(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif /* __mips >= 2 */\n\n#if defined(__mips64)\n\t\tcase fcvtl_op:{\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.l = ieee754sp_tlong(fs);\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n\t\tcase froundl_op:\n\t\tcase ftruncl_op:\n\t\tcase fceill_op:\n\t\tcase ffloorl_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754sp fs;\n\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\n\t\t\trv.l = ieee754sp_tlong(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif /* defined(__mips64) */\n\n\t\tdefault:\n\t\t\tif (MIPSInst_FUNC(ir) >= fcmp_op) {\n\t\t\t\tunsigned cmpop = MIPSInst_FUNC(ir) - fcmp_op;\n\t\t\t\tieee754sp fs, ft;\n\n\t\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tSPFROMREG(ft, MIPSInst_FT(ir));\n\t\t\t\trv.w = ieee754sp_cmp(fs, ft,\n\t\t\t\t\tcmptab[cmpop & 0x7], cmpop & 0x8);\n\t\t\t\trfmt = -1;\n\t\t\t\tif ((cmpop & 0x8) && ieee754_cxtest\n\t\t\t\t\t(IEEE754_INVALID_OPERATION))\n\t\t\t\t\trcsr = FPU_CSR_INV_X | FPU_CSR_INV_S;\n\t\t\t\telse\n\t\t\t\t\tgoto copcsr;\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase d_fmt:{\n\t\tunion {\n\t\t\tieee754dp(*b) (ieee754dp, ieee754dp);\n\t\t\tieee754dp(*u) (ieee754dp);\n\t\t} handler;\n\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\t\t/* binary ops */\n\t\tcase fadd_op:\n\t\t\thandler.b = ieee754dp_add;\n\t\t\tgoto dcopbop;\n\t\tcase fsub_op:\n\t\t\thandler.b = ieee754dp_sub;\n\t\t\tgoto dcopbop;\n\t\tcase fmul_op:\n\t\t\thandler.b = ieee754dp_mul;\n\t\t\tgoto dcopbop;\n\t\tcase fdiv_op:\n\t\t\thandler.b = ieee754dp_div;\n\t\t\tgoto dcopbop;\n\n\t\t\t/* unary  ops */\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fsqrt_op:\n\t\t\thandler.u = ieee754dp_sqrt;\n\t\t\tgoto dcopuop;\n#endif\n#if __mips >= 4 && __mips != 32\n\t\tcase frsqrt_op:\n\t\t\thandler.u = fpemu_dp_rsqrt;\n\t\t\tgoto dcopuop;\n\t\tcase frecip_op:\n\t\t\thandler.u = fpemu_dp_recip;\n\t\t\tgoto dcopuop;\n#endif\n#if __mips >= 4\n\t\tcase fmovc_op:\n\t\t\tcond = fpucondbit[MIPSInst_FT(ir) >> 2];\n\t\t\tif (((ctx->fcr31 & cond) != 0) !=\n\t\t\t\t((MIPSInst_FT(ir) & 1) != 0))\n\t\t\t\treturn 0;\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovz_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] != 0)\n\t\t\t\treturn 0;\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tbreak;\n\t\tcase fmovn_op:\n\t\t\tif (xcp->regs[MIPSInst_FT(ir)] == 0)\n\t\t\t\treturn 0;\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tbreak;\n#endif\n\t\tcase fabs_op:\n\t\t\thandler.u = ieee754dp_abs;\n\t\t\tgoto dcopuop;\n\n\t\tcase fneg_op:\n\t\t\thandler.u = ieee754dp_neg;\n\t\t\tgoto dcopuop;\n\n\t\tcase fmov_op:\n\t\t\t/* an easy one */\n\t\t\tDPFROMREG(rv.d, MIPSInst_FS(ir));\n\t\t\tgoto copcsr;\n\n\t\t\t/* binary op on handler */\n\t\t      dcopbop:{\n\t\t\t\tieee754dp fs, ft;\n\n\t\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tDPFROMREG(ft, MIPSInst_FT(ir));\n\n\t\t\t\trv.d = (*handler.b) (fs, ft);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\t\t      dcopuop:{\n\t\t\t\tieee754dp fs;\n\n\t\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\trv.d = (*handler.u) (fs);\n\t\t\t\tgoto copcsr;\n\t\t\t}\n\n\t\t\t/* unary conv ops */\n\t\tcase fcvts_op:{\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.s = ieee754sp_fdp(fs);\n\t\t\trfmt = s_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\t\tcase fcvtd_op:\n\t\t\treturn SIGILL;\t/* not defined */\n\n\t\tcase fcvtw_op:{\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.w = ieee754dp_tint(fs);\t/* wrong */\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n#if __mips >= 2 || defined(__mips64)\n\t\tcase fround_op:\n\t\tcase ftrunc_op:\n\t\tcase fceil_op:\n\t\tcase ffloor_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\n\t\t\trv.w = ieee754dp_tint(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = w_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif\n\n#if defined(__mips64)\n\t\tcase fcvtl_op:{\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.l = ieee754dp_tlong(fs);\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n\n\t\tcase froundl_op:\n\t\tcase ftruncl_op:\n\t\tcase fceill_op:\n\t\tcase ffloorl_op:{\n\t\t\tunsigned int oldrm = ieee754_csr.rm;\n\t\t\tieee754dp fs;\n\n\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\tieee754_csr.rm = ieee_rm[modeindex(MIPSInst_FUNC(ir))];\n\t\t\trv.l = ieee754dp_tlong(fs);\n\t\t\tieee754_csr.rm = oldrm;\n\t\t\trfmt = l_fmt;\n\t\t\tgoto copcsr;\n\t\t}\n#endif /* __mips >= 3 */\n\n\t\tdefault:\n\t\t\tif (MIPSInst_FUNC(ir) >= fcmp_op) {\n\t\t\t\tunsigned cmpop = MIPSInst_FUNC(ir) - fcmp_op;\n\t\t\t\tieee754dp fs, ft;\n\n\t\t\t\tDPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\t\tDPFROMREG(ft, MIPSInst_FT(ir));\n\t\t\t\trv.w = ieee754dp_cmp(fs, ft,\n\t\t\t\t\tcmptab[cmpop & 0x7], cmpop & 0x8);\n\t\t\t\trfmt = -1;\n\t\t\t\tif ((cmpop & 0x8)\n\t\t\t\t\t&&\n\t\t\t\t\tieee754_cxtest\n\t\t\t\t\t(IEEE754_INVALID_OPERATION))\n\t\t\t\t\trcsr = FPU_CSR_INV_X | FPU_CSR_INV_S;\n\t\t\t\telse\n\t\t\t\t\tgoto copcsr;\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn SIGILL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase w_fmt:{\n\t\tieee754sp fs;\n\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\tcase fcvts_op:\n\t\t\t/* convert word to single precision real */\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.s = ieee754sp_fint(fs.bits);\n\t\t\trfmt = s_fmt;\n\t\t\tgoto copcsr;\n\t\tcase fcvtd_op:\n\t\t\t/* convert word to double precision real */\n\t\t\tSPFROMREG(fs, MIPSInst_FS(ir));\n\t\t\trv.d = ieee754dp_fint(fs.bits);\n\t\t\trfmt = d_fmt;\n\t\t\tgoto copcsr;\n\t\tdefault:\n\t\t\treturn SIGILL;\n\t\t}\n\t\tbreak;\n\t}\n\n#if defined(__mips64)\n\tcase l_fmt:{\n\t\tswitch (MIPSInst_FUNC(ir)) {\n\t\tcase fcvts_op:\n\t\t\t/* convert long to single precision real */\n\t\t\trv.s = ieee754sp_flong(ctx->fpr[MIPSInst_FS(ir)]);\n\t\t\trfmt = s_fmt;\n\t\t\tgoto copcsr;\n\t\tcase fcvtd_op:\n\t\t\t/* convert long to double precision real */\n\t\t\trv.d = ieee754dp_flong(ctx->fpr[MIPSInst_FS(ir)]);\n\t\t\trfmt = d_fmt;\n\t\t\tgoto copcsr;\n\t\tdefault:\n\t\t\treturn SIGILL;\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\t/*\n\t * Update the fpu CSR register for this operation.\n\t * If an exception is required, generate a tidy SIGFPE exception,\n\t * without updating the result register.\n\t * Note: cause exception bits do not accumulate, they are rewritten\n\t * for each op; only the flag/sticky bits accumulate.\n\t */\n\tctx->fcr31 = (ctx->fcr31 & ~FPU_CSR_ALL_X) | rcsr;\n\tif ((ctx->fcr31 >> 5) & ctx->fcr31 & FPU_CSR_ALL_E) {\n\t\t/*printk (\"SIGFPE: fpu csr = %08x\\n\",ctx->fcr31); */\n\t\treturn SIGFPE;\n\t}\n\n\t/*\n\t * Now we can safely write the result back to the register file.\n\t */\n\tswitch (rfmt) {\n\tcase -1:{\n#if __mips >= 4\n\t\tcond = fpucondbit[MIPSInst_FD(ir) >> 2];\n#else\n\t\tcond = FPU_CSR_COND;\n#endif\n\t\tif (rv.w)\n\t\t\tctx->fcr31 |= cond;\n\t\telse\n\t\t\tctx->fcr31 &= ~cond;\n\t\tbreak;\n\t}\n\tcase d_fmt:\n\t\tDPTOREG(rv.d, MIPSInst_FD(ir));\n\t\tbreak;\n\tcase s_fmt:\n\t\tSPTOREG(rv.s, MIPSInst_FD(ir));\n\t\tbreak;\n\tcase w_fmt:\n\t\tSITOREG(rv.w, MIPSInst_FD(ir));\n\t\tbreak;\n#if defined(__mips64)\n\tcase l_fmt:\n\t\tDITOREG(rv.l, MIPSInst_FD(ir));\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn SIGILL;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 25441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Effect_command(effect_handle_t  self,\n uint32_t            cmdCode,\n uint32_t            cmdSize,\n void *pCmdData,\n uint32_t *replySize,\n void *pReplyData){\n EffectContext * pContext = (EffectContext *) self;\n int retsize;\n\n\n if(pContext->EffectType == LVM_BASS_BOOST){\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n }\n if(pContext->EffectType == LVM_VOLUME){\n }\n\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : Effect_command ERROR pContext == NULL\");\n return -EINVAL;\n }\n\n\n\n\n switch (cmdCode){\n case EFFECT_CMD_INIT:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){\n                ALOGV(\"\\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d\",\n                        pContext->EffectType);\n return -EINVAL;\n }\n *(int *) pReplyData = 0;\n if(pContext->EffectType == LVM_BASS_BOOST){\n                android::BassSetStrength(pContext, 0);\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n                android::VirtualizerSetStrength(pContext, 0);\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n                android::EqualizerSetPreset(pContext, 0);\n }\n if(pContext->EffectType == LVM_VOLUME){\n *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);\n }\n break;\n\n case EFFECT_CMD_SET_CONFIG:\n if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||\n                    pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n \"EFFECT_CMD_SET_CONFIG: ERROR\");\n return -EINVAL;\n }\n *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);\n break;\n\n case EFFECT_CMD_GET_CONFIG:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n \"EFFECT_CMD_GET_CONFIG: ERROR\");\n return -EINVAL;\n }\n\n            android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);\n break;\n\n case EFFECT_CMD_RESET:\n            android::Effect_setConfig(pContext, &pContext->config);\n break;\n\n case EFFECT_CMD_GET_PARAM:{\n\n effect_param_t *p = (effect_param_t *)pCmdData;\n if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {\n                android_errorWriteLog(0x534e4554, \"26347509\");\n return -EINVAL;\n }\n if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||\n                    cmdSize < (sizeof(effect_param_t) + p->psize) ||\n                    pReplyData == NULL || replySize == NULL ||\n *replySize < (sizeof(effect_param_t) + p->psize)) {\n                ALOGV(\"\\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR\");\n return -EINVAL;\n }\n\n            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);\n\n            p = (effect_param_t *)pReplyData;\n\n int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);\n\n if(pContext->EffectType == LVM_BASS_BOOST){\n                p->status = android::BassBoost_getParameter(pContext,\n                                                            p->data,\n &p->vsize,\n                                                            p->data + voffset);\n }\n\n if(pContext->EffectType == LVM_VIRTUALIZER){\n                p->status = android::Virtualizer_getParameter(pContext,\n (void *)p->data,\n &p->vsize,\n                                                              p->data + voffset);\n\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n                p->status = android::Equalizer_getParameter(pContext,\n                                                            p->data,\n &p->vsize,\n                                                            p->data + voffset);\n\n }\n if(pContext->EffectType == LVM_VOLUME){\n                p->status = android::Volume_getParameter(pContext,\n (void *)p->data,\n &p->vsize,\n                                                         p->data + voffset);\n\n }\n *replySize = sizeof(effect_param_t) + voffset + p->vsize;\n\n } break;\n case EFFECT_CMD_SET_PARAM:{\n if(pContext->EffectType == LVM_BASS_BOOST){\n\n if (pCmdData   == NULL ||\n                        cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::BassBoost_setParameter(pContext,\n (void *)p->data,\n                                                                    p->data + p->psize);\n }\n if(pContext->EffectType == LVM_VIRTUALIZER){\n\n if (pCmdData   == NULL ||\n                        cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n if (p->psize != sizeof(int32_t)){\n                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");\n return -EINVAL;\n }\n\n\n *(int *)pReplyData = android::Virtualizer_setParameter(pContext,\n (void *)p->data,\n                                                                       p->data + p->psize);\n }\n if(pContext->EffectType == LVM_EQUALIZER){\n\n if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n *(int *)pReplyData = android::Equalizer_setParameter(pContext,\n (void *)p->data,\n                                                                     p->data + p->psize);\n }\n if(pContext->EffectType == LVM_VOLUME){\n\n if (pCmdData   == NULL ||\n                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||\n                        pReplyData == NULL || replySize == NULL ||\n *replySize != sizeof(int32_t)) {\n                    ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"\n \"EFFECT_CMD_SET_PARAM: ERROR\");\n return -EINVAL;\n }\n effect_param_t *p = (effect_param_t *) pCmdData;\n\n *(int *)pReplyData = android::Volume_setParameter(pContext,\n (void *)p->data,\n                                                                 p->data + p->psize);\n }\n } break;\n\n case EFFECT_CMD_ENABLE:\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start\");\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");\n return -EINVAL;\n }\n\n *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);\n break;\n\n case EFFECT_CMD_DISABLE:\n if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");\n return -EINVAL;\n }\n *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);\n break;\n\n case EFFECT_CMD_SET_DEVICE:\n {\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start\");\n if (pCmdData   == NULL){\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR\");\n return -EINVAL;\n }\n\n uint32_t device = *(uint32_t *)pCmdData;\n            pContext->pBundledContext->nOutputDevice = (audio_devices_t) device;\n\n if (pContext->EffectType == LVM_BASS_BOOST) {\n if((device == AUDIO_DEVICE_OUT_SPEAKER) ||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||\n (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST\");\n\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_disable(pContext);\n }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;\n } else {\n                    ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d\",\n *(int32_t *)pCmdData);\n                        android::LvmEffect_enable(pContext);\n }\n                    pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;\n }\n }\n if (pContext->EffectType == LVM_VIRTUALIZER) {\n if (pContext->pBundledContext->nVirtualizerForcedDevice == AUDIO_DEVICE_NONE) {\n if (android::VirtualizerIsDeviceSupported(device) != 0) {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER\");\n\n\n if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {\n                            ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                            android::LvmEffect_disable(pContext);\n }\n                        pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;\n } else {\n                        ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n\n\n if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){\n                            ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d\",\n *(int32_t *)pCmdData);\n                            android::LvmEffect_enable(pContext);\n }\n                        pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;\n }\n } // else virtualization mode is forced to a certain device, nothing to do\n }\n            ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end\");\n break;\n }\n case EFFECT_CMD_SET_VOLUME:\n {\n uint32_t leftVolume, rightVolume;\n int16_t  leftdB, rightdB;\n int16_t  maxdB, pandB;\n int32_t  vol_ret[2] = {1<<24,1<<24}; // Apply no volume\n int      status = 0;\n LVM_ControlParams_t ActiveParams; /* Current control Parameters */\n            LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */\n\n if(pReplyData == LVM_NULL){\n break;\n }\n\n if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||\n                    replySize == NULL || *replySize < 2*sizeof(int32_t)) {\n                ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"\n \"EFFECT_CMD_SET_VOLUME: ERROR\");\n return -EINVAL;\n }\n\n            leftVolume  = ((*(uint32_t *)pCmdData));\n            rightVolume = ((*((uint32_t *)pCmdData + 1)));\n\n if(leftVolume == 0x1000000){\n                leftVolume -= 1;\n }\n if(rightVolume == 0x1000000){\n                rightVolume -= 1;\n }\n\n            leftdB  = android::LVC_Convert_VolToDb(leftVolume);\n            rightdB = android::LVC_Convert_VolToDb(rightVolume);\n\n            pandB = rightdB - leftdB;\n\n            maxdB = leftdB;\n if(rightdB > maxdB){\n                maxdB = rightdB;\n }\n\n            memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);\n            android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));\n\n /* Get the current settings */\n LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"VolumeSetStereoPosition\")\n if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n\n /* Volume parameters */\n ActiveParams.VC_Balance  = pandB;\n            ALOGV(\"\\t\\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\\n\", ActiveParams.VC_Balance );\n\n /* Activate the initial settings */\n LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);\n            LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"VolumeSetStereoPosition\")\n if(LvmStatus != LVM_SUCCESS) return -EINVAL;\n break;\n }\n case EFFECT_CMD_SET_AUDIO_MODE:\n break;\n default:\n return -EINVAL;\n }\n\n return 0;\n} /* end Effect_command */\n",
        "output": "0",
        "index": 175810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MediaContainerName LookupContainerByFirst4(const uint8_t* buffer,\n                                                  int buffer_size) {\n  if (buffer_size < kMinimumContainerSize)\n    return CONTAINER_UNKNOWN;\n\n  uint32_t first4 = Read32(buffer);\n  switch (first4) {\n    case 0x1a45dfa3:\n      if (CheckWebm(buffer, buffer_size))\n        return CONTAINER_WEBM;\n      break;\n\n    case 0x3026b275:\n      if (StartsWith(buffer,\n                     buffer_size,\n                     kAsfSignature,\n                     sizeof(kAsfSignature))) {\n        return CONTAINER_ASF;\n      }\n      break;\n\n    case TAG('#','!','A','M'):\n      if (StartsWith(buffer, buffer_size, kAmrSignature))\n        return CONTAINER_AMR;\n      break;\n\n    case TAG('#','E','X','T'):\n      if (CheckHls(buffer, buffer_size))\n        return CONTAINER_HLS;\n      break;\n\n    case TAG('.','R','M','F'):\n      if (buffer[4] == 0 && buffer[5] == 0)\n        return CONTAINER_RM;\n      break;\n\n    case TAG('.','r','a','\\xfd'):\n      return CONTAINER_RM;\n\n    case TAG('B','I','K','b'):\n    case TAG('B','I','K','d'):\n    case TAG('B','I','K','f'):\n    case TAG('B','I','K','g'):\n    case TAG('B','I','K','h'):\n    case TAG('B','I','K','i'):\n      if (CheckBink(buffer, buffer_size))\n        return CONTAINER_BINK;\n      break;\n\n    case TAG('c','a','f','f'):\n      if (CheckCaf(buffer, buffer_size))\n        return CONTAINER_CAF;\n      break;\n\n    case TAG('D','E','X','A'):\n      if (buffer_size > 15 &&\n          Read16(buffer + 11) <= 2048 &&\n          Read16(buffer + 13) <= 2048) {\n        return CONTAINER_DXA;\n      }\n      break;\n\n    case TAG('D','T','S','H'):\n      if (Read32(buffer + 4) == TAG('D','H','D','R'))\n        return CONTAINER_DTSHD;\n      break;\n\n    case 0x64a30100:\n    case 0x64a30200:\n    case 0x64a30300:\n    case 0x64a30400:\n    case 0x0001a364:\n    case 0x0002a364:\n    case 0x0003a364:\n      if (Read32(buffer + 4) != 0 && Read32(buffer + 8) != 0)\n        return CONTAINER_IRCAM;\n      break;\n\n    case TAG('f','L','a','C'):\n      return CONTAINER_FLAC;\n\n    case TAG('F','L','V',0):\n    case TAG('F','L','V',1):\n    case TAG('F','L','V',2):\n    case TAG('F','L','V',3):\n    case TAG('F','L','V',4):\n      if (buffer[5] == 0 && Read32(buffer + 5) > 8)\n        return CONTAINER_FLV;\n      break;\n\n    case TAG('F','O','R','M'):\n      switch (Read32(buffer + 8)) {\n        case TAG('A','I','F','F'):\n        case TAG('A','I','F','C'):\n          return CONTAINER_AIFF;\n      }\n      break;\n\n    case TAG('M','A','C',' '):\n      return CONTAINER_APE;\n\n    case TAG('O','N','2',' '):\n      if (Read32(buffer + 8) == TAG('O','N','2','f'))\n        return CONTAINER_AVI;\n      break;\n\n    case TAG('O','g','g','S'):\n      if (buffer[5] <= 7)\n        return CONTAINER_OGG;\n      break;\n\n    case TAG('R','F','6','4'):\n      if (buffer_size > 16 && Read32(buffer + 12) == TAG('d','s','6','4'))\n        return CONTAINER_WAV;\n      break;\n\n    case TAG('R','I','F','F'):\n      switch (Read32(buffer + 8)) {\n        case TAG('A','V','I',' '):\n        case TAG('A','V','I','X'):\n        case TAG('A','V','I','\\x19'):\n        case TAG('A','M','V',' '):\n          return CONTAINER_AVI;\n        case TAG('W','A','V','E'):\n          return CONTAINER_WAV;\n      }\n      break;\n\n    case TAG('[','S','c','r'):\n      if (StartsWith(buffer, buffer_size, kAssSignature))\n        return CONTAINER_ASS;\n      break;\n\n    case TAG('\\xef','\\xbb','\\xbf','['):\n      if (StartsWith(buffer, buffer_size, kAssBomSignature))\n        return CONTAINER_ASS;\n      break;\n\n    case 0x7ffe8001:\n    case 0xfe7f0180:\n    case 0x1fffe800:\n    case 0xff1f00e8:\n      if (CheckDts(buffer, buffer_size))\n        return CONTAINER_DTS;\n      break;\n\n    case 0xb7d80020:\n      if (StartsWith(buffer,\n                     buffer_size,\n                     kWtvSignature,\n                     sizeof(kWtvSignature))) {\n        return CONTAINER_WTV;\n      }\n      break;\n  }\n\n  uint32_t first3 = first4 & 0xffffff00;\n  switch (first3) {\n    case TAG('C','W','S',0):\n    case TAG('F','W','S',0):\n      return CONTAINER_SWF;\n\n    case TAG('I','D','3',0):\n      return CONTAINER_MP3;\n  }\n\n  uint32_t first2 = Read16(buffer);\n  switch (first2) {\n    case kAc3SyncWord:\n      if (CheckAc3(buffer, buffer_size))\n        return CONTAINER_AC3;\n      if (CheckEac3(buffer, buffer_size))\n        return CONTAINER_EAC3;\n      break;\n\n    case 0xfff0:\n    case 0xfff1:\n    case 0xfff8:\n    case 0xfff9:\n      if (CheckAac(buffer, buffer_size))\n        return CONTAINER_AAC;\n      break;\n  }\n\n  if (CheckMp3(buffer, buffer_size))\n    return CONTAINER_MP3;\n\n  return CONTAINER_UNKNOWN;\n}\n",
        "output": "0",
        "index": 164802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_da_writepages(struct address_space *mapping,\n\t\t\t      struct writeback_control *wbc)\n{\n\tpgoff_t\tindex;\n\tint range_whole = 0;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint no_nrwrite_index_update;\n\tint pages_written = 0;\n\tlong pages_skipped;\n\tunsigned int max_pages;\n\tint range_cyclic, cycled = 1, io_done = 0;\n\tint needed_blocks, ret = 0;\n\tlong desired_nr_to_write, nr_to_writebump = 0;\n\tloff_t range_start = wbc->range_start;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\n\ttrace_ext4_da_writepages(inode, wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\treturn 0;\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_da_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED))\n\t\treturn -EROFS;\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\trange_cyclic = wbc->range_cyclic;\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index;\n\t\tif (index)\n\t\t\tcycled = 0;\n\t\twbc->range_start = index << PAGE_CACHE_SHIFT;\n\t\twbc->range_end  = LLONG_MAX;\n\t\twbc->range_cyclic = 0;\n\t} else\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * This works around two forms of stupidity.  The first is in\n\t * the writeback code, which caps the maximum number of pages\n\t * written to be 1024 pages.  This is wrong on multiple\n\t * levels; different architectues have a different page size,\n\t * which changes the maximum amount of data which gets\n\t * written.  Secondly, 4 megabytes is way too small.  XFS\n\t * forces this value to be 16 megabytes by multiplying\n\t * nr_to_write parameter by four, and then relies on its\n\t * allocator to allocate larger extents to make them\n\t * contiguous.  Unfortunately this brings us to the second\n\t * stupidity, which is that ext4's mballoc code only allocates\n\t * at most 2048 blocks.  So we force contiguous writes up to\n\t * the number of dirty blocks in the inode, or\n\t * sbi->max_writeback_mb_bump whichever is smaller.\n\t */\n\tmax_pages = sbi->s_max_writeback_mb_bump << (20 - PAGE_CACHE_SHIFT);\n\tif (!range_cyclic && range_whole)\n\t\tdesired_nr_to_write = wbc->nr_to_write * 8;\n\telse\n\t\tdesired_nr_to_write = ext4_num_dirty_pages(inode, index,\n\t\t\t\t\t\t\t   max_pages);\n\tif (desired_nr_to_write > max_pages)\n\t\tdesired_nr_to_write = max_pages;\n\n\tif (wbc->nr_to_write < desired_nr_to_write) {\n\t\tnr_to_writebump = desired_nr_to_write - wbc->nr_to_write;\n\t\twbc->nr_to_write = desired_nr_to_write;\n\t}\n\n\tmpd.wbc = wbc;\n\tmpd.inode = mapping->host;\n\n\t/*\n\t * we don't want write_cache_pages to update\n\t * nr_to_write and writeback_index\n\t */\n\tno_nrwrite_index_update = wbc->no_nrwrite_index_update;\n\twbc->no_nrwrite_index_update = 1;\n\tpages_skipped = wbc->pages_skipped;\n\nretry:\n\twhile (!ret && wbc->nr_to_write > 0) {\n\n\t\t/*\n\t\t * we  insert one extent at a time. So we need\n\t\t * credit needed for single extent allocation.\n\t\t * journalled mode is currently not supported\n\t\t * by delalloc\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction*/\n\t\thandle = ext4_journal_start(inode, needed_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\\n\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\tgoto out_writepages;\n\t\t}\n\n\t\t/*\n\t\t * Now call __mpage_da_writepage to find the next\n\t\t * contiguous region of logical blocks that need\n\t\t * blocks to be allocated by ext4.  We don't actually\n\t\t * submit the blocks for I/O here, even though\n\t\t * write_cache_pages thinks it will, and will set the\n\t\t * pages as clean for write before calling\n\t\t * __mpage_da_writepage().\n\t\t */\n\t\tmpd.b_size = 0;\n\t\tmpd.b_state = 0;\n\t\tmpd.b_blocknr = 0;\n\t\tmpd.first_page = 0;\n\t\tmpd.next_page = 0;\n\t\tmpd.io_done = 0;\n\t\tmpd.pages_written = 0;\n\t\tmpd.retval = 0;\n\t\tret = write_cache_pages(mapping, wbc, __mpage_da_writepage,\n\t\t\t\t\t&mpd);\n\t\t/*\n\t\t * If we have a contiguous extent of pages and we\n\t\t * haven't done the I/O yet, map the blocks and submit\n\t\t * them for I/O.\n\t\t */\n\t\tif (!mpd.io_done && mpd.next_page != mpd.first_page) {\n\t\t\tif (mpage_da_map_blocks(&mpd) == 0)\n\t\t\t\tmpage_da_submit_io(&mpd);\n\t\t\tmpd.io_done = 1;\n\t\t\tret = MPAGE_DA_EXTENT_TAIL;\n\t\t}\n\t\ttrace_ext4_da_write_pages(inode, &mpd);\n\t\twbc->nr_to_write -= mpd.pages_written;\n\n\t\text4_journal_stop(handle);\n\n\t\tif ((mpd.retval == -ENOSPC) && sbi->s_journal) {\n\t\t\t/* commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\twbc->pages_skipped = pages_skipped;\n\t\t\tret = 0;\n\t\t} else if (ret == MPAGE_DA_EXTENT_TAIL) {\n\t\t\t/*\n\t\t\t * got one extent now try with\n\t\t\t * rest of the pages\n\t\t\t */\n\t\t\tpages_written += mpd.pages_written;\n\t\t\twbc->pages_skipped = pages_skipped;\n\t\t\tret = 0;\n\t\t\tio_done = 1;\n\t\t} else if (wbc->nr_to_write)\n\t\t\t/*\n\t\t\t * There is no more writeout needed\n\t\t\t * or we requested for a noblocking writeout\n\t\t\t * and we found the device congested\n\t\t\t */\n\t\t\tbreak;\n\t}\n\tif (!io_done && !cycled) {\n\t\tcycled = 1;\n\t\tindex = 0;\n\t\twbc->range_start = index << PAGE_CACHE_SHIFT;\n\t\twbc->range_end  = mapping->writeback_index - 1;\n\t\tgoto retry;\n\t}\n\tif (pages_skipped != wbc->pages_skipped)\n\t\text4_msg(inode->i_sb, KERN_CRIT,\n\t\t\t \"This should not happen leaving %s \"\n\t\t\t \"with nr_to_write = %ld ret = %d\\n\",\n\t\t\t __func__, wbc->nr_to_write, ret);\n\n\t/* Update index */\n\tindex += pages_written;\n\twbc->range_cyclic = range_cyclic;\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = index;\n\nout_writepages:\n\tif (!no_nrwrite_index_update)\n\t\twbc->no_nrwrite_index_update = 0;\n\twbc->nr_to_write -= nr_to_writebump;\n\twbc->range_start = range_start;\n\ttrace_ext4_da_writepages_result(inode, wbc, ret, pages_written);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 57501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void impeg2d_dec_pic_data_thread(dec_state_t *ps_dec)\n{\n    WORD32 i4_continue_decode;\n\n    WORD32 i4_cur_row, temp;\n    UWORD32 u4_bits_read;\n    WORD32 i4_dequeue_job;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    i4_cur_row = ps_dec->u2_mb_y + 1;\n\n    i4_continue_decode = 1;\n\n    i4_dequeue_job = 1;\n do\n {\n if(i4_cur_row > ps_dec->u2_num_vert_mb)\n {\n            i4_continue_decode = 0;\n break;\n }\n\n {\n if((ps_dec->i4_num_cores> 1) && (i4_dequeue_job))\n {\n job_t s_job;\n                IV_API_CALL_STATUS_T e_ret;\n                UWORD8 *pu1_buf;\n\n                e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);\n if(e_ret != IV_SUCCESS)\n break;\n\n if(CMD_PROCESS == s_job.i4_cmd)\n {\n                    pu1_buf = ps_dec->pu1_inp_bits_buf + s_job.i4_bistream_ofst;\n                    impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), pu1_buf,\n (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst));\n                    i4_cur_row      = s_job.i2_start_mb_y;\n                    ps_dec->i4_start_mb_y = s_job.i2_start_mb_y;\n                    ps_dec->i4_end_mb_y = s_job.i2_end_mb_y;\n                    ps_dec->u2_mb_x = 0;\n                    ps_dec->u2_mb_y = ps_dec->i4_start_mb_y;\n                    ps_dec->u2_num_mbs_left = (ps_dec->i4_end_mb_y - ps_dec->i4_start_mb_y) * ps_dec->u2_num_horiz_mb;\n\n }\n else\n {\n                    WORD32 start_row;\n                    WORD32 num_rows;\n                    start_row = s_job.i2_start_mb_y << 4;\n                    num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);\n                    num_rows -= start_row;\n\n if(ps_dec->u4_deinterlace && (0 == ps_dec->u2_progressive_frame))\n {\n                        impeg2d_deinterlace(ps_dec,\n                                            ps_dec->ps_disp_pic,\n                                            ps_dec->ps_disp_frm_buf,\n                                            start_row,\n                                            num_rows);\n\n }\n else\n {\n                        impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,\n                                               ps_dec->ps_disp_frm_buf,\n                                               start_row, num_rows);\n }\n break;\n\n }\n\n }\n            e_error = impeg2d_dec_slice(ps_dec);\n\n if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n {\n                impeg2d_next_start_code(ps_dec);\n if(ps_dec->s_bit_stream.u4_offset >= ps_dec->s_bit_stream.u4_max_offset)\n {\n                    ps_dec->u4_error_code = IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n return;\n }\n }\n }\n\n /* Detecting next slice start code */\n while(1)\n {\n            u4_bits_read = impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,START_CODE_LEN);\n            temp = u4_bits_read & 0xFF;\n            i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));\n\n if (1 == ps_dec->i4_num_cores && 0 == ps_dec->u2_num_mbs_left)\n {\n                i4_continue_decode = 0;\n#ifdef __ANDROID__\n                android_errorWriteLog(0x534e4554, \"26070014\");\n#endif\n }\n\n if(i4_continue_decode)\n {\n /* If the slice is from the same row, then continue decoding without dequeue */\n if((temp - 1) == i4_cur_row)\n {\n                    i4_dequeue_job = 0;\n break;\n }\n\n if(temp < ps_dec->i4_end_mb_y)\n {\n                    i4_cur_row = ps_dec->u2_mb_y;\n }\n else\n {\n                    i4_dequeue_job = 1;\n }\n break;\n\n }\n else\n break;\n }\n\n }while(i4_continue_decode);\n if(ps_dec->i4_num_cores > 1)\n {\n while(1)\n {\n job_t s_job;\n            IV_API_CALL_STATUS_T e_ret;\n\n            e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);\n if(e_ret != IV_SUCCESS)\n break;\n if(CMD_FMTCONV == s_job.i4_cmd)\n {\n                WORD32 start_row;\n                WORD32 num_rows;\n                start_row = s_job.i2_start_mb_y << 4;\n                num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);\n                num_rows -= start_row;\n if(ps_dec->u4_deinterlace && (0 == ps_dec->u2_progressive_frame))\n {\n                    impeg2d_deinterlace(ps_dec,\n                                        ps_dec->ps_disp_pic,\n                                        ps_dec->ps_disp_frm_buf,\n                                        start_row,\n                                        num_rows);\n\n }\n else\n {\n                    impeg2d_format_convert(ps_dec,\n                                           ps_dec->ps_disp_pic,\n                                           ps_dec->ps_disp_frm_buf,\n                                           start_row,\n                                           num_rows);\n }\n }\n }\n }\n else\n {\n if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))\n {\n if(ps_dec->u4_deinterlace && (0 == ps_dec->u2_progressive_frame))\n {\n                impeg2d_deinterlace(ps_dec,\n                                    ps_dec->ps_disp_pic,\n                                    ps_dec->ps_disp_frm_buf,\n 0,\n                                    ps_dec->u2_vertical_size);\n\n }\n else\n {\n                impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,\n                                        ps_dec->ps_disp_frm_buf,\n 0, ps_dec->u2_vertical_size);\n }\n }\n }\n}\n",
        "output": "0",
        "index": 176427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WORD32 impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)\n{\n stream_t *ps_stream = &ps_dec->s_bit_stream;\n    UWORD16 u2_mb_addr_incr;\n    UWORD16 u2_total_len;\n    UWORD16 u2_len;\n    UWORD16 u2_mb_type;\n    UWORD32 u4_next_word;\n const dec_mb_params_t *ps_dec_mb_params;\n if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n {\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n }\n else\n {\n        u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);\n\n if(ps_dec->u2_first_mb)\n {\n /****************************************************************/\n /* Section 6.3.17                                               */\n /* The first MB of a slice cannot be skipped                    */\n /* But the mb_addr_incr can be > 1, because at the beginning of */\n /* a slice, it indicates the offset from the last MB in the     */\n /* previous row. Hence for the first slice in a row, the        */\n /* mb_addr_incr needs to be 1.                                  */\n /****************************************************************/\n /* MB_x is set to zero whenever MB_y changes.                   */\n            ps_dec->u2_mb_x = u2_mb_addr_incr - 1;\n /* For error resilience */\n            ps_dec->u2_mb_x = MIN(ps_dec->u2_mb_x, (ps_dec->u2_num_horiz_mb - 1));\n\n /****************************************************************/\n /* mb_addr_incr is forced to 1 because in this decoder it is used */\n /* more as an indicator of the number of MBs skipped than the   */\n /* as defined by the standard (Section 6.3.17)                  */\n /****************************************************************/\n            u2_mb_addr_incr = 1;\n            ps_dec->u2_first_mb = 0;\n }\n else\n {\n /****************************************************************/\n /* In MPEG-2, the last MB of the row cannot be skipped and the  */\n /* mb_addr_incr cannot be such that it will take the current MB   */\n /* beyond the current row                                       */\n /* In MPEG-1, the slice could start and end anywhere and is not */\n /* restricted to a row like in MPEG-2. Hence this check should  */\n /* not be done for MPEG-1 streams.                              */\n /****************************************************************/\n if(ps_dec->u2_is_mpeg2 &&\n ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb))\n {\n                u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;\n }\n\n if ((u2_mb_addr_incr - 1) > ps_dec->u2_num_mbs_left)\n {\n /* If the number of skip MBs are more than the number of MBs\n                 * left, indicate error.\n                 */\n return IV_FAIL;\n }\n\n            impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));\n }\n\n }\n    u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);\n /*-----------------------------------------------------------------------*/\n /* MB type                                                               */\n /*-----------------------------------------------------------------------*/\n {\n        u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];\n        u2_len      = BITS(u2_mb_type,15,8);\n        u2_total_len = u2_len;\n        u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);\n }\n /*-----------------------------------------------------------------------*/\n /* motion type                                                           */\n /*-----------------------------------------------------------------------*/\n {\n        WORD32 i4_motion_type = ps_dec->u2_motion_type;\n\n if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)\n {\n            ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);\n            u2_total_len += MB_MOTION_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);\n            i4_motion_type     = ps_dec->u2_motion_type;\n\n }\n\n\n if ((u2_mb_type & MB_FORW_OR_BACK) &&\n ((i4_motion_type == 0) ||\n (i4_motion_type == 3) ||\n (i4_motion_type == 4) ||\n (i4_motion_type >= 7)))\n {\n            i4_motion_type = 1;\n }\n\n }\n /*-----------------------------------------------------------------------*/\n /* dct type                                                              */\n /*-----------------------------------------------------------------------*/\n {\n if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)\n {\n            ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);\n            u2_total_len += MB_DCT_TYPE_LEN;\n            u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);\n }\n }\n /*-----------------------------------------------------------------------*/\n /* Quant scale code                                                      */\n /*-----------------------------------------------------------------------*/\n if(u2_mb_type & MB_QUANT)\n {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);\n\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n        u2_total_len += MB_QUANT_SCALE_CODE_LEN;\n }\n    impeg2d_bit_stream_flush(ps_stream,u2_total_len);\n /*-----------------------------------------------------------------------*/\n /* Set the function pointers                                             */\n /*-----------------------------------------------------------------------*/\n    ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);\n\n if(u2_mb_type & MB_BIDRECT)\n {\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred         = BIDIRECT;\n        ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];\n        ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n if(NULL == ps_dec_mb_params->pf_func_mb_params)\n return -1;\n        ps_dec_mb_params->pf_func_mb_params(ps_dec);\n }\n else if(u2_mb_type & MB_FORW_OR_BACK)\n {\n\n        UWORD16 u2_refPic      = !(u2_mb_type & MB_MV_FORW);\n        UWORD16 u2_index       = (ps_dec->u2_motion_type);\n        ps_dec->u2_prev_intra_mb    = 0;\n        ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;\n        ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];\n        ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;\n if(NULL == ps_dec_mb_params->pf_func_mb_params)\n return -1;\n        ps_dec_mb_params->pf_func_mb_params(ps_dec);\n\n }\n else if(u2_mb_type & MB_TYPE_INTRA)\n {\n        ps_dec->u2_prev_intra_mb    = 1;\n        impeg2d_dec_intra_mb(ps_dec);\n\n }\n else\n {\n        ps_dec->u2_prev_intra_mb =0;\n        ps_dec->e_mb_pred = FORW;\n        ps_dec->u2_motion_type = 0;\n        impeg2d_dec_0mv_coded_mb(ps_dec);\n }\n\n /*-----------------------------------------------------------------------*/\n /* decode cbp                                                            */\n /*-----------------------------------------------------------------------*/\n if((u2_mb_type & MB_TYPE_INTRA))\n {\n        ps_dec->u2_cbp  = 0x3f;\n        ps_dec->u2_prev_intra_mb    = 1;\n }\n else\n {\n        ps_dec->u2_prev_intra_mb  = 0;\n        ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n        ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;\n if((ps_dec->u2_coded_mb))\n {\n            UWORD16 cbpValue;\n            cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];\n            ps_dec->u2_cbp  = cbpValue & 0xFF;\n            impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);\n }\n else\n {\n            ps_dec->u2_cbp  = 0;\n }\n }\n return 0;\n}\n",
        "output": "0",
        "index": 175535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType TraceBezier(MVGInfo *mvg_info,\n  const size_t number_coordinates)\n{\n  double\n    alpha,\n    *coefficients,\n    weight;\n\n  PointInfo\n    end,\n    point,\n    *points;\n\n  PrimitiveInfo\n    *primitive_info;\n\n  register PrimitiveInfo\n    *p;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    control_points,\n    quantum;\n\n  /*\n    Allocate coefficients.\n  */\n  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n  quantum=number_coordinates;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n  {\n    for (j=i+1; j < (ssize_t) number_coordinates; j++)\n    {\n      alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n        quantum=(size_t) alpha;\n      alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);\n      if (alpha > (double) SSIZE_MAX)\n        {\n          (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n          return(MagickFalse);\n        }\n      if (alpha > (double) quantum)\n         quantum=(size_t) alpha;\n     }\n   }\n  quantum=MagickMin(quantum/number_coordinates,BezierQuantum);\n   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;\n   coefficients=(double *) AcquireQuantumMemory(number_coordinates,\n     sizeof(*coefficients));\n   points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates*\n    sizeof(*points));\n  if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))\n    {\n      if (points != (PointInfo *) NULL)\n        points=(PointInfo *) RelinquishMagickMemory(points);\n      if (coefficients != (double *) NULL)\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n      (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n      return(MagickFalse);\n    }\n  control_points=quantum*number_coordinates;\n  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n       coefficients=(double *) RelinquishMagickMemory(coefficients);\n       return(MagickFalse);\n     }\n   /*\n     Compute bezier points.\n   */\n  end=primitive_info[number_coordinates-1].point;\n  for (i=0; i < (ssize_t) number_coordinates; i++)\n    coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);\n  weight=0.0;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    p=primitive_info;\n    point.x=0.0;\n    point.y=0.0;\n    alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);\n    for (j=0; j < (ssize_t) number_coordinates; j++)\n    {\n      point.x+=alpha*coefficients[j]*p->point.x;\n      point.y+=alpha*coefficients[j]*p->point.y;\n      alpha*=weight/(1.0-weight);\n      p++;\n    }\n    points[i]=point;\n    weight+=1.0/control_points;\n  }\n  /*\n    Bezier curves are just short segmented polys.\n  */\n  p=primitive_info;\n  for (i=0; i < (ssize_t) control_points; i++)\n  {\n    if (TracePoint(p,points[i]) == MagickFalse)\n      {\n        points=(PointInfo *) RelinquishMagickMemory(points);\n        coefficients=(double *) RelinquishMagickMemory(coefficients);\n        return(MagickFalse);\n      }\n    p+=p->coordinates;\n  }\n  if (TracePoint(p,end) == MagickFalse)\n    {\n      points=(PointInfo *) RelinquishMagickMemory(points);\n      coefficients=(double *) RelinquishMagickMemory(coefficients);\n      return(MagickFalse);\n    }\n  p+=p->coordinates;\n  primitive_info->coordinates=(size_t) (p-primitive_info);\n  primitive_info->closed_subpath=MagickFalse;\n  for (i=0; i < (ssize_t) primitive_info->coordinates; i++)\n  {\n    p->primitive=primitive_info->primitive;\n    p--;\n  }\n  points=(PointInfo *) RelinquishMagickMemory(points);\n  coefficients=(double *) RelinquishMagickMemory(coefficients);\n  return(MagickTrue);\n}\n",
        "output": "1",
        "index": 182657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win = !irqchip_in_kernel(vcpu->kvm) &&\n\t\tvcpu->run->request_interrupt_window;\n\tbool req_immediate_exit = false;\n\n\tif (vcpu->requests) {\n\t\tif (kvm_check_request(KVM_REQ_MMU_RELOAD, vcpu))\n\t\t\tkvm_mmu_unload(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu))\n\t\t\tkvm_vcpu_flush_tlb(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_DEACTIVATE_FPU, vcpu)) {\n\t\t\tvcpu->fpu_active = 0;\n\t\t\tkvm_x86_ops->fpu_deactivate(vcpu);\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_handle_pmu_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win) {\n\t\tkvm_apic_accept_events(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (inject_pending_event(vcpu, req_int_win) != 0)\n\t\t\treq_immediate_exit = true;\n\t\t/* enable NMI/IRQ window open exits if needed */\n\t\telse if (vcpu->arch.nmi_pending)\n\t\t\tkvm_x86_ops->enable_nmi_window(vcpu);\n\t\telse if (kvm_cpu_has_injectable_intr(vcpu) || req_int_win)\n\t\t\tkvm_x86_ops->enable_irq_window(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\t/*\n\t\t\t * Update architecture specific hints for APIC\n\t\t\t * virtual interrupt delivery.\n\t\t\t */\n\t\t\tif (kvm_x86_ops->hwapic_irr_update)\n\t\t\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\t\tkvm_lapic_find_highest_irr(vcpu));\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tkvm_x86_ops->prepare_guest_switch(vcpu);\n\tif (vcpu->fpu_active)\n\t\tkvm_load_guest_fpu(vcpu);\n\tkvm_load_guest_xcr0(vcpu);\n\n\tvcpu->mode = IN_GUEST_MODE;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\n\t/* We should set ->mode before check ->requests,\n\t * see the comment in make_all_cpus_request.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\tlocal_irq_disable();\n\n\tif (vcpu->mode == EXITING_GUEST_MODE || vcpu->requests\n\t    || need_resched() || signal_pending(current)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit)\n\t\tsmp_send_reschedule(vcpu->cpu);\n\n\tkvm_guest_enter();\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\t}\n\n\ttrace_kvm_entry(vcpu->vcpu_id);\n\tkvm_x86_ops->run(vcpu);\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tint i;\n\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tkvm_x86_ops->sync_dirty_debug_regs(vcpu);\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_guest_tsc = kvm_x86_ops->read_l1_tsc(vcpu,\n\t\t\t\t\t\t\t   native_read_tsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/* Interrupt is enabled by handle_external_intr() */\n\tkvm_x86_ops->handle_external_intr(vcpu);\n\n\t++vcpu->stat.exits;\n\n\t/*\n\t * We must have an instruction between local_irq_enable() and\n\t * kvm_guest_exit(), so the timer interrupt isn't delayed by\n\t * the interrupt shadow.  The stat.exits increment will do nicely.\n\t * But we need to prevent reordering, hence this barrier():\n\t */\n\tbarrier();\n\n\tkvm_guest_exit();\n\n\tpreempt_enable();\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = kvm_x86_ops->handle_exit(vcpu);\n\treturn r;\n\ncancel_injection:\n\tkvm_x86_ops->cancel_injection(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n",
        "output": "0",
        "index": 37944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}\n",
        "output": "0",
        "index": 45356
    }
]