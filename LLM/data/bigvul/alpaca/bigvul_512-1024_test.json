[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_src_operand(\n   struct translate_ctx *ctx,\n   struct tgsi_full_src_register *src )\n{\n   uint file;\n   uint swizzle[4];\n   boolean parsed_swizzle;\n   struct parsed_bracket bracket[2];\n   int parsed_opt_brackets;\n\n   if (*ctx->cur == '-') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Negate = 1;\n   }\n\n   if (*ctx->cur == '|') {\n      ctx->cur++;\n      eat_opt_white( &ctx->cur );\n      src->Register.Absolute = 1;\n   }\n\n   if (!parse_register_src(ctx, &file, &bracket[0]))\n      return FALSE;\n   if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))\n      return FALSE;\n\n   src->Register.File = file;\n   if (parsed_opt_brackets) {\n      src->Register.Dimension = 1;\n      src->Dimension.Indirect = 0;\n      src->Dimension.Dimension = 0;\n      src->Dimension.Index = bracket[0].index;\n      if (bracket[0].ind_file != TGSI_FILE_NULL) {\n         src->Dimension.Indirect = 1;\n         src->DimIndirect.File = bracket[0].ind_file;\n         src->DimIndirect.Index = bracket[0].ind_index;\n         src->DimIndirect.Swizzle = bracket[0].ind_comp;\n         src->DimIndirect.ArrayID = bracket[0].ind_array;\n      }\n      bracket[0] = bracket[1];\n   }\n   src->Register.Index = bracket[0].index;\n   if (bracket[0].ind_file != TGSI_FILE_NULL) {\n      src->Register.Indirect = 1;\n      src->Indirect.File = bracket[0].ind_file;\n      src->Indirect.Index = bracket[0].ind_index;\n      src->Indirect.Swizzle = bracket[0].ind_comp;\n      src->Indirect.ArrayID = bracket[0].ind_array;\n   }\n\n   /* Parse optional swizzle.\n    */\n   if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {\n      if (parsed_swizzle) {\n         src->Register.SwizzleX = swizzle[0];\n         src->Register.SwizzleY = swizzle[1];\n         src->Register.SwizzleZ = swizzle[2];\n         src->Register.SwizzleW = swizzle[3];\n      }\n   }\n\n   if (src->Register.Absolute) {\n      eat_opt_white( &ctx->cur );\n      if (*ctx->cur != '|') {\n         report_error( ctx, \"Expected `|'\" );\n         return FALSE;\n      }\n      ctx->cur++;\n   }\n\n\n   return TRUE;\n}\n",
        "output": "0",
        "index": 9744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int exif_process_IFD_in_JPEG(image_info_type *ImageInfo, char *dir_start, char *offset_base, size_t IFDlength, size_t displacement, int section_index TSRMLS_DC)\n{\n\tint de;\n\tint NumDirEntries;\n\tint NextDirOffset;\n\n#ifdef EXIF_DEBUG\n\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process %s (x%04X(=%d))\", exif_get_sectionname(section_index), IFDlength, IFDlength);\n#endif\n \n        ImageInfo->sections_found |= FOUND_IFD0;\n \n        NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel);\n \n        if ((dir_start+2+NumDirEntries*12) > (offset_base+IFDlength)) {\n\t\tif (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de,\n\t\t\t\t\t\t\t\t  offset_base, IFDlength, displacement, section_index, 1, exif_get_tag_table(section_index) TSRMLS_CC)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\t/*\n\t * Ignore IFD2 if it purportedly exists\n\t */\n\tif (section_index == SECTION_THUMBNAIL) {\n\t\treturn TRUE;\n\t}\n\t/*\n\t * Hack to make it process IDF1 I hope\n\t * There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail\n\t */\n\tNextDirOffset = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);\n\tif (NextDirOffset) {\n         * Hack to make it process IDF1 I hope\n         * There are 2 IDFs, the second one holds the keys (0x0201 and 0x0202) to the thumbnail\n         */\n        NextDirOffset = php_ifd_get32u(dir_start+2+12*de, ImageInfo->motorola_intel);\n        if (NextDirOffset) {\n                /* the next line seems false but here IFDlength means length of all IFDs */\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Thumbnail size: 0x%04X\", ImageInfo->Thumbnail.size);\n#endif\n\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t) {\n\t\t\t\texif_thumbnail_extract(ImageInfo, offset_base, IFDlength TSRMLS_CC);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n",
        "output": "1",
        "index": 178205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dma_tx_fragment(struct b43_dmaring *ring,\n\t\t\t   struct sk_buff *skb)\n{\n\tconst struct b43_dma_ops *ops = ring->ops;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct b43_private_tx_info *priv_info = b43_get_priv_tx_info(info);\n\tu8 *header;\n\tint slot, old_top_slot, old_used_slots;\n\tint err;\n\tstruct b43_dmadesc_generic *desc;\n\tstruct b43_dmadesc_meta *meta;\n\tstruct b43_dmadesc_meta *meta_hdr;\n\tu16 cookie;\n\tsize_t hdrsize = b43_txhdr_size(ring->dev);\n\n\t/* Important note: If the number of used DMA slots per TX frame\n\t * is changed here, the TX_SLOTS_PER_FRAME definition at the top of\n\t * the file has to be updated, too!\n\t */\n\n\told_top_slot = ring->current_slot;\n\told_used_slots = ring->used_slots;\n\n\t/* Get a slot for the header. */\n\tslot = request_slot(ring);\n\tdesc = ops->idx2desc(ring, slot, &meta_hdr);\n\tmemset(meta_hdr, 0, sizeof(*meta_hdr));\n\n\theader = &(ring->txhdr_cache[(slot / TX_SLOTS_PER_FRAME) * hdrsize]);\n\tcookie = generate_cookie(ring, slot);\n\terr = b43_generate_txhdr(ring->dev, header,\n\t\t\t\t skb, info, cookie);\n\tif (unlikely(err)) {\n\t\tring->current_slot = old_top_slot;\n\t\tring->used_slots = old_used_slots;\n\t\treturn err;\n\t}\n\n\tmeta_hdr->dmaaddr = map_descbuffer(ring, (unsigned char *)header,\n\t\t\t\t\t   hdrsize, 1);\n\tif (b43_dma_mapping_error(ring, meta_hdr->dmaaddr, hdrsize, 1)) {\n\t\tring->current_slot = old_top_slot;\n\t\tring->used_slots = old_used_slots;\n\t\treturn -EIO;\n\t}\n\tops->fill_descriptor(ring, desc, meta_hdr->dmaaddr,\n\t\t\t     hdrsize, 1, 0, 0);\n\n\t/* Get a slot for the payload. */\n\tslot = request_slot(ring);\n\tdesc = ops->idx2desc(ring, slot, &meta);\n\tmemset(meta, 0, sizeof(*meta));\n\n\tmeta->skb = skb;\n\tmeta->is_last_fragment = 1;\n\tpriv_info->bouncebuffer = NULL;\n\n\tmeta->dmaaddr = map_descbuffer(ring, skb->data, skb->len, 1);\n\t/* create a bounce buffer in zone_dma on mapping failure. */\n\tif (b43_dma_mapping_error(ring, meta->dmaaddr, skb->len, 1)) {\n\t\tpriv_info->bouncebuffer = kmemdup(skb->data, skb->len,\n\t\t\t\t\t\t  GFP_ATOMIC | GFP_DMA);\n\t\tif (!priv_info->bouncebuffer) {\n\t\t\tring->current_slot = old_top_slot;\n\t\t\tring->used_slots = old_used_slots;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unmap_hdr;\n\t\t}\n\n\t\tmeta->dmaaddr = map_descbuffer(ring, priv_info->bouncebuffer, skb->len, 1);\n\t\tif (b43_dma_mapping_error(ring, meta->dmaaddr, skb->len, 1)) {\n\t\t\tkfree(priv_info->bouncebuffer);\n\t\t\tpriv_info->bouncebuffer = NULL;\n\t\t\tring->current_slot = old_top_slot;\n\t\t\tring->used_slots = old_used_slots;\n\t\t\terr = -EIO;\n\t\t\tgoto out_unmap_hdr;\n\t\t}\n\t}\n\n\tops->fill_descriptor(ring, desc, meta->dmaaddr, skb->len, 0, 1, 1);\n\n\tif (info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\n\t\t/* Tell the firmware about the cookie of the last\n\t\t * mcast frame, so it can clear the more-data bit in it. */\n\t\tb43_shm_write16(ring->dev, B43_SHM_SHARED,\n\t\t\t\tB43_SHM_SH_MCASTCOOKIE, cookie);\n\t}\n\t/* Now transfer the whole frame. */\n\twmb();\n\tops->poke_tx(ring, next_slot(ring, slot));\n\treturn 0;\n\nout_unmap_hdr:\n\tunmap_descbuffer(ring, meta_hdr->dmaaddr,\n\t\t\t hdrsize, 1);\n\treturn err;\n}\n",
        "output": "0",
        "index": 24546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::Destroy() {\n  bool have_context = context_.get() && MakeCurrent();\n\n  ChildList children = children_;\n  for (ChildList::iterator it = children.begin(); it != children.end(); ++it)\n    (*it)->SetParent(NULL, 0);\n  DCHECK(children_.empty());\n  SetParent(NULL, 0);\n\n  vertex_attrib_manager_.reset();\n  texture_units_.reset();\n  bound_array_buffer_ = NULL;\n  bound_element_array_buffer_ = NULL;\n  current_query_ = NULL;\n  current_program_ = NULL;\n  bound_read_framebuffer_ = NULL;\n  bound_draw_framebuffer_ = NULL;\n  bound_renderbuffer_ = NULL;\n\n  if (have_context) {\n    if (current_program_) {\n      program_manager()->UnuseProgram(shader_manager(), current_program_);\n      current_program_ = NULL;\n    }\n\n    if (attrib_0_buffer_id_) {\n      glDeleteBuffersARB(1, &attrib_0_buffer_id_);\n    }\n    if (fixed_attrib_buffer_id_) {\n      glDeleteBuffersARB(1, &fixed_attrib_buffer_id_);\n    }\n\n    if (offscreen_target_frame_buffer_.get())\n      offscreen_target_frame_buffer_->Destroy();\n    if (offscreen_target_color_texture_.get())\n      offscreen_target_color_texture_->Destroy();\n    if (offscreen_target_color_render_buffer_.get())\n      offscreen_target_color_render_buffer_->Destroy();\n    if (offscreen_target_depth_render_buffer_.get())\n      offscreen_target_depth_render_buffer_->Destroy();\n    if (offscreen_target_stencil_render_buffer_.get())\n      offscreen_target_stencil_render_buffer_->Destroy();\n    if (offscreen_saved_frame_buffer_.get())\n      offscreen_saved_frame_buffer_->Destroy();\n    if (offscreen_saved_color_texture_.get())\n      offscreen_saved_color_texture_->Destroy();\n    if (offscreen_resolved_frame_buffer_.get())\n      offscreen_resolved_frame_buffer_->Destroy();\n    if (offscreen_resolved_color_texture_.get())\n      offscreen_resolved_color_texture_->Destroy();\n  } else {\n    if (offscreen_target_frame_buffer_.get())\n      offscreen_target_frame_buffer_->Invalidate();\n    if (offscreen_target_color_texture_.get())\n      offscreen_target_color_texture_->Invalidate();\n    if (offscreen_target_color_render_buffer_.get())\n      offscreen_target_color_render_buffer_->Invalidate();\n    if (offscreen_target_depth_render_buffer_.get())\n      offscreen_target_depth_render_buffer_->Invalidate();\n    if (offscreen_target_stencil_render_buffer_.get())\n      offscreen_target_stencil_render_buffer_->Invalidate();\n    if (offscreen_saved_frame_buffer_.get())\n      offscreen_saved_frame_buffer_->Invalidate();\n    if (offscreen_saved_color_texture_.get())\n      offscreen_saved_color_texture_->Invalidate();\n    if (offscreen_resolved_frame_buffer_.get())\n      offscreen_resolved_frame_buffer_->Invalidate();\n    if (offscreen_resolved_color_texture_.get())\n      offscreen_resolved_color_texture_->Invalidate();\n  }\n\n  if (query_manager_.get()) {\n    query_manager_->Destroy(have_context);\n    query_manager_.reset();\n  }\n\n  if (group_) {\n    group_->Destroy(have_context);\n    group_ = NULL;\n  }\n\n  if (context_.get()) {\n    context_->ReleaseCurrent(NULL);\n    context_ = NULL;\n  }\n\n  offscreen_target_frame_buffer_.reset();\n  offscreen_target_color_texture_.reset();\n  offscreen_target_color_render_buffer_.reset();\n  offscreen_target_depth_render_buffer_.reset();\n  offscreen_target_stencil_render_buffer_.reset();\n  offscreen_saved_frame_buffer_.reset();\n  offscreen_saved_color_texture_.reset();\n  offscreen_resolved_frame_buffer_.reset();\n  offscreen_resolved_color_texture_.reset();\n\n#if defined(OS_MACOSX)\n  for (TextureToIOSurfaceMap::iterator it = texture_to_io_surface_map_.begin();\n       it != texture_to_io_surface_map_.end(); ++it) {\n    CFRelease(it->second);\n  }\n  texture_to_io_surface_map_.clear();\n#endif\n}\n",
        "output": "0",
        "index": 117210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LvmEffect_limitLevel(EffectContext *pContext) {\n LVM_ControlParams_t ActiveParams; /* Current control Parameters */\n    LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS; /* Function call status */\n\n /* Get the current settings */\n LvmStatus = LVM_GetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);\n    LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"LvmEffect_limitLevel\")\n\n int gainCorrection = 0;\n float energyContribution = 0;\n float energyCross = 0;\n float energyBassBoost = 0;\n float crossCorrection = 0;\n\n if (pContext->pBundledContext->bEqualizerEnabled == LVM_TRUE) {\n for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {\n float bandFactor = pContext->pBundledContext->bandGaindB[i]/15.0;\n float bandCoefficient = LimitLevel_bandEnergyCoefficient[i];\n float bandEnergy = bandFactor * bandCoefficient * bandCoefficient;\n if (bandEnergy > 0)\n                energyContribution += bandEnergy;\n }\n\n float bandFactorSum = 0;\n for (int i = 0; i < FIVEBAND_NUMBANDS-1; i++) {\n float bandFactor1 = pContext->pBundledContext->bandGaindB[i]/15.0;\n float bandFactor2 = pContext->pBundledContext->bandGaindB[i+1]/15.0;\n\n if (bandFactor1 > 0 && bandFactor2 > 0) {\n float crossEnergy = bandFactor1 * bandFactor2 *\n LimitLevel_bandEnergyCrossCoefficient[i];\n                bandFactorSum += bandFactor1 * bandFactor2;\n\n if (crossEnergy > 0)\n                    energyCross += crossEnergy;\n }\n }\n        bandFactorSum -= 1.0;\n if (bandFactorSum > 0)\n            crossCorrection = bandFactorSum * 0.7;\n }\n\n if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {\n float boostFactor = (pContext->pBundledContext->BassStrengthSaved)/1000.0;\n float boostCoefficient = LimitLevel_bassBoostEnergyCoefficient;\n\n        energyContribution += boostFactor * boostCoefficient * boostCoefficient;\n\n for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {\n float bandFactor = pContext->pBundledContext->bandGaindB[i]/15.0;\n float bandCrossCoefficient = LimitLevel_bassBoostEnergyCrossCoefficient[i];\n float bandEnergy = boostFactor * bandFactor *\n                    bandCrossCoefficient;\n if (bandEnergy > 0)\n                energyBassBoost += bandEnergy;\n }\n }\n\n if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {\n        energyContribution += LimitLevel_virtualizerContribution *\n LimitLevel_virtualizerContribution;\n }\n\n double totalEnergyEstimation = sqrt(energyContribution + energyCross + energyBassBoost) -\n            crossCorrection;\n    ALOGV(\" TOTAL energy estimation: %0.2f\", totalEnergyEstimation);\n\n int maxLevelRound = (int)(totalEnergyEstimation + 0.99);\n if (maxLevelRound + pContext->pBundledContext->volume > 0) {\n        gainCorrection = maxLevelRound + pContext->pBundledContext->volume;\n }\n\n ActiveParams.VC_EffectLevel  = pContext->pBundledContext->volume - gainCorrection;\n if (ActiveParams.VC_EffectLevel < -96) {\n ActiveParams.VC_EffectLevel = -96;\n }\n    ALOGV(\"\\tVol:%d, GainCorrection: %d, Actual vol: %d\", pContext->pBundledContext->volume,\n            gainCorrection, ActiveParams.VC_EffectLevel);\n\n /* Activate the initial settings */\n LvmStatus = LVM_SetControlParameters(pContext->pBundledContext->hInstance, &ActiveParams);\n    LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"LvmEffect_limitLevel\")\n\n if (pContext->pBundledContext->firstVolume == LVM_TRUE){\n LvmStatus = LVM_SetVolumeNoSmoothing(pContext->pBundledContext->hInstance, &ActiveParams);\n        LVM_ERROR_CHECK(LvmStatus, \"LVM_SetVolumeNoSmoothing\", \"LvmBundle_process\")\n        ALOGV(\"\\tLVM_VOLUME: Disabling Smoothing for first volume change to remove spikes/clicks\");\n        pContext->pBundledContext->firstVolume = LVM_FALSE;\n }\n}\n",
        "output": "0",
        "index": 175812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_capacity_10(struct scsi_disk *sdkp, struct scsi_device *sdp,\n\t\t\t\t\t\tunsigned char *buffer)\n{\n\tunsigned char cmd[16];\n\tstruct scsi_sense_hdr sshdr;\n\tint sense_valid = 0;\n\tint the_result;\n\tint retries = 3, reset_retries = READ_CAPACITY_RETRIES_ON_RESET;\n\tsector_t lba;\n\tunsigned sector_size;\n\n\tdo {\n\t\tcmd[0] = READ_CAPACITY;\n\t\tmemset(&cmd[1], 0, 9);\n\t\tmemset(buffer, 0, 8);\n\n\t\tthe_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,\n\t\t\t\t\tbuffer, 8, &sshdr,\n\t\t\t\t\tSD_TIMEOUT, SD_MAX_RETRIES, NULL);\n\n\t\tif (media_not_present(sdkp, &sshdr))\n\t\t\treturn -ENODEV;\n\n\t\tif (the_result) {\n\t\t\tsense_valid = scsi_sense_valid(&sshdr);\n\t\t\tif (sense_valid &&\n\t\t\t    sshdr.sense_key == UNIT_ATTENTION &&\n\t\t\t    sshdr.asc == 0x29 && sshdr.ascq == 0x00)\n\t\t\t\t/* Device reset might occur several times,\n\t\t\t\t * give it one more chance */\n\t\t\t\tif (--reset_retries > 0)\n\t\t\t\t\tcontinue;\n\t\t}\n\t\tretries--;\n\n\t} while (the_result && retries);\n\n\tif (the_result) {\n\t\tsd_printk(KERN_NOTICE, sdkp, \"READ CAPACITY failed\\n\");\n\t\tread_capacity_error(sdkp, sdp, &sshdr, sense_valid, the_result);\n\t\treturn -EINVAL;\n\t}\n\n\tsector_size = get_unaligned_be32(&buffer[4]);\n\tlba = get_unaligned_be32(&buffer[0]);\n\n\tif (sdp->no_read_capacity_16 && (lba == 0xffffffff)) {\n\t\t/* Some buggy (usb cardreader) devices return an lba of\n\t\t   0xffffffff when the want to report a size of 0 (with\n\t\t   which they really mean no media is present) */\n\t\tsdkp->capacity = 0;\n\t\tsdkp->physical_block_size = sector_size;\n\t\treturn sector_size;\n\t}\n\n\tif ((sizeof(sdkp->capacity) == 4) && (lba == 0xffffffff)) {\n\t\tsd_printk(KERN_ERR, sdkp, \"Too big for this kernel. Use a \"\n\t\t\t\"kernel compiled with support for large block \"\n\t\t\t\"devices.\\n\");\n\t\tsdkp->capacity = 0;\n\t\treturn -EOVERFLOW;\n\t}\n\n\tsdkp->capacity = lba + 1;\n\tsdkp->physical_block_size = sector_size;\n\treturn sector_size;\n}\n",
        "output": "0",
        "index": 94377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ComputeBuiltInPlugins(std::vector<content::PepperPluginInfo>* plugins) {\n  static bool skip_pdf_file_check = false;\n  FilePath path;\n  if (PathService::Get(chrome::FILE_PDF_PLUGIN, &path)) {\n    if (skip_pdf_file_check || file_util::PathExists(path)) {\n      content::PepperPluginInfo pdf;\n      pdf.path = path;\n      pdf.name = kPDFPluginName;\n      webkit::WebPluginMimeType pdf_mime_type(kPDFPluginMimeType,\n                                              kPDFPluginExtension,\n                                              kPDFPluginDescription);\n      webkit::WebPluginMimeType print_preview_pdf_mime_type(\n          kPDFPluginPrintPreviewMimeType,\n          kPDFPluginExtension,\n          kPDFPluginDescription);\n      pdf.mime_types.push_back(pdf_mime_type);\n      pdf.mime_types.push_back(print_preview_pdf_mime_type);\n      plugins->push_back(pdf);\n\n      skip_pdf_file_check = true;\n    }\n  }\n\n  static bool skip_nacl_file_check = false;\n  if (PathService::Get(chrome::FILE_NACL_PLUGIN, &path)) {\n    if (skip_nacl_file_check || file_util::PathExists(path)) {\n      content::PepperPluginInfo nacl;\n      nacl.path = path;\n      nacl.name = kNaClPluginName;\n      webkit::WebPluginMimeType nacl_mime_type(kNaClPluginMimeType,\n                                               kNaClPluginExtension,\n                                               kNaClPluginDescription);\n      nacl.mime_types.push_back(nacl_mime_type);\n      plugins->push_back(nacl);\n\n      skip_nacl_file_check = true;\n    }\n  }\n\n  static bool skip_o3d_file_check = false;\n  if (PathService::Get(chrome::FILE_O3D_PLUGIN, &path)) {\n    if (skip_o3d_file_check || file_util::PathExists(path)) {\n      content::PepperPluginInfo o3d;\n      o3d.path = path;\n      o3d.name = kO3DPluginName;\n      o3d.is_out_of_process = true;\n      o3d.is_sandboxed = false;\n      webkit::WebPluginMimeType o3d_mime_type(kO3DPluginMimeType,\n                                              kO3DPluginExtension,\n                                              kO3DPluginDescription);\n      o3d.mime_types.push_back(o3d_mime_type);\n      plugins->push_back(o3d);\n\n      skip_o3d_file_check = true;\n    }\n  }\n\n  static bool skip_gtalk_file_check = false;\n  if (PathService::Get(chrome::FILE_GTALK_PLUGIN, &path)) {\n    if (skip_gtalk_file_check || file_util::PathExists(path)) {\n      content::PepperPluginInfo gtalk;\n      gtalk.path = path;\n      gtalk.name = kGTalkPluginName;\n      gtalk.is_out_of_process = true;\n      gtalk.is_sandboxed = false;\n      webkit::WebPluginMimeType gtalk_mime_type(kGTalkPluginMimeType,\n                                                kGTalkPluginExtension,\n                                                kGTalkPluginDescription);\n      gtalk.mime_types.push_back(gtalk_mime_type);\n      plugins->push_back(gtalk);\n\n      skip_gtalk_file_check = true;\n    }\n  }\n\n#if defined(ENABLE_REMOTING)\n  content::PepperPluginInfo info;\n  info.is_internal = true;\n  info.name = kRemotingViewerPluginName;\n  info.path = FilePath(kRemotingViewerPluginPath);\n  webkit::WebPluginMimeType remoting_mime_type(\n      kRemotingViewerPluginMimeType,\n      std::string(),\n      std::string());\n  info.mime_types.push_back(remoting_mime_type);\n  webkit::WebPluginMimeType old_remoting_mime_type(\n      kRemotingViewerPluginOldMimeType,\n      std::string(),\n      std::string());\n  info.mime_types.push_back(old_remoting_mime_type);\n  info.internal_entry_points.get_interface = remoting::PPP_GetInterface;\n  info.internal_entry_points.initialize_module =\n      remoting::PPP_InitializeModule;\n  info.internal_entry_points.shutdown_module = remoting::PPP_ShutdownModule;\n\n  plugins->push_back(info);\n#endif\n}\n",
        "output": "0",
        "index": 114168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " construct_command_line(struct manager_ctx *manager, struct server *server)\n {\n     static char cmd[BUF_SIZE];\n    char *method = manager->method;\n     int i;\n \n    build_config(working_dir, server);\n \n    if (server->method) method = server->method;\n     memset(cmd, 0, BUF_SIZE);\n     snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n \n     if (manager->acl != NULL) {\n         int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}\n",
        "output": "1",
        "index": 180886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebContentsImpl::OnMessageReceived(RenderViewHost* render_view_host,\n                                        RenderFrameHost* render_frame_host,\n                                        const IPC::Message& message) {\n  DCHECK(render_view_host || render_frame_host);\n  if (GetWebUI() &&\n      static_cast<WebUIImpl*>(GetWebUI())->OnMessageReceived(message)) {\n    return true;\n  }\n\n  ObserverListBase<WebContentsObserver>::Iterator it(observers_);\n  WebContentsObserver* observer;\n  while ((observer = it.GetNext()) != NULL)\n    if (observer->OnMessageReceived(message))\n      return true;\n\n  render_view_message_source_ = render_view_host;\n  bool handled = true;\n  bool message_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(WebContentsImpl, message, message_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_PepperPluginHung, OnPepperPluginHung)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_PluginCrashed, OnPluginCrashed)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DidLoadResourceFromMemoryCache,\n                        OnDidLoadResourceFromMemoryCache)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DidDisplayInsecureContent,\n                        OnDidDisplayInsecureContent)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DidRunInsecureContent,\n                        OnDidRunInsecureContent)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DocumentLoadedInFrame,\n                        OnDocumentLoadedInFrame)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DidFinishLoad, OnDidFinishLoad)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_GoToEntryAtOffset, OnGoToEntryAtOffset)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_UpdateZoomLimits, OnUpdateZoomLimits)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_EnumerateDirectory, OnEnumerateDirectory)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_JSOutOfMemory, OnJSOutOfMemory)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_RegisterProtocolHandler,\n                        OnRegisterProtocolHandler)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_Find_Reply, OnFindReply)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_AppCacheAccessed, OnAppCacheAccessed)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_OpenColorChooser, OnOpenColorChooser)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_EndColorChooser, OnEndColorChooser)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_SetSelectedColorInColorChooser,\n                        OnSetSelectedColorInColorChooser)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_WebUISend, OnWebUISend)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_RequestPpapiBrokerPermission,\n                        OnRequestPpapiBrokerPermission)\n    IPC_MESSAGE_HANDLER_GENERIC(BrowserPluginHostMsg_AllocateInstanceID,\n                                OnBrowserPluginMessage(message))\n    IPC_MESSAGE_HANDLER_GENERIC(BrowserPluginHostMsg_Attach,\n                                OnBrowserPluginMessage(message))\n    IPC_MESSAGE_HANDLER(ImageHostMsg_DidDownloadImage, OnDidDownloadImage)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_UpdateFaviconURL, OnUpdateFaviconURL)\n#if defined(OS_ANDROID)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_FindMatchRects_Reply,\n                        OnFindMatchRectsReply)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_OpenDateTimeDialog,\n                        OnOpenDateTimeDialog)\n    IPC_MESSAGE_HANDLER_DELAY_REPLY(JavaBridgeHostMsg_GetChannelHandle,\n                                    OnJavaBridgeGetChannelHandle)\n#endif\n    IPC_MESSAGE_HANDLER(ViewHostMsg_MediaNotification, OnMediaNotification)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_DidFirstVisuallyNonEmptyPaint,\n                        OnFirstVisuallyNonEmptyPaint)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_ShowValidationMessage,\n                        OnShowValidationMessage)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_HideValidationMessage,\n                        OnHideValidationMessage)\n    IPC_MESSAGE_HANDLER(ViewHostMsg_MoveValidationMessage,\n                        OnMoveValidationMessage)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP_EX()\n  render_view_message_source_ = NULL;\n\n  if (!message_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RVD\"));\n    GetRenderProcessHost()->ReceivedBadMessage();\n  }\n\n  return handled;\n}\n",
        "output": "0",
        "index": 133606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int llc_ui_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_llc *, addr, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tsize_t size = 0;\n\tint rc = -EINVAL, copied = 0, hdrlen;\n\n\tdprintk(\"%s: sending from %02X to %02X\\n\", __func__,\n\t\tllc->laddr.lsap, llc->daddr.lsap);\n\tlock_sock(sk);\n\tif (addr) {\n\t\tif (msg->msg_namelen < sizeof(*addr))\n\t\t\tgoto release;\n\t} else {\n\t\tif (llc_ui_addr_null(&llc->addr))\n\t\t\tgoto release;\n\t\taddr = &llc->addr;\n\t}\n\t/* must bind connection to sap if user hasn't done it. */\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* bind to sap with null dev, exclusive. */\n\t\trc = llc_ui_autobind(sock, addr);\n\t\tif (rc)\n\t\t\tgoto release;\n\t}\n\thdrlen = llc->dev->hard_header_len + llc_ui_header_len(sk, addr);\n\tsize = hdrlen + len;\n\tif (size > llc->dev->mtu)\n\t\tsize = llc->dev->mtu;\n\tcopied = size - hdrlen;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto release;\n\tskb->dev      = llc->dev;\n\tskb->protocol = llc_proto_type(addr->sllc_arphrd);\n\tskb_reserve(skb, hdrlen);\n\trc = memcpy_from_msg(skb_put(skb, copied), msg, copied);\n\tif (rc)\n\t\tgoto out;\n\tif (sk->sk_type == SOCK_DGRAM || addr->sllc_ua) {\n\t\tllc_build_and_send_ui_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t  addr->sllc_sap);\n\t\tgoto out;\n\t}\n\tif (addr->sllc_test) {\n\t\tllc_build_and_send_test_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t    addr->sllc_sap);\n\t\tgoto out;\n\t}\n\tif (addr->sllc_xid) {\n\t\tllc_build_and_send_xid_pkt(llc->sap, skb, addr->sllc_mac,\n\t\t\t\t\t   addr->sllc_sap);\n\t\tgoto out;\n\t}\n\trc = -ENOPROTOOPT;\n\tif (!(sk->sk_type == SOCK_STREAM && !addr->sllc_ua))\n\t\tgoto out;\n\trc = llc_ui_send_data(sk, skb, noblock);\nout:\n\tif (rc) {\n\t\tkfree_skb(skb);\nrelease:\n\t\tdprintk(\"%s: failed sending from %02X to %02X: %d\\n\",\n\t\t\t__func__, llc->laddr.lsap, llc->daddr.lsap, rc);\n\t}\n\trelease_sock(sk);\n\treturn rc ? : copied;\n}\n",
        "output": "0",
        "index": 53182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IPV6DefragReverseSimpleTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n     if (dc == NULL)\n         goto end;\n \n    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);\n     if (p1 == NULL)\n         goto end;\n    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);\n     if (p2 == NULL)\n         goto end;\n    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);\n     if (p3 == NULL)\n         goto end;\n \n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)\n        goto end;\n\n    /* 40 bytes in we should find 8 bytes of A. */\n    for (i = 40; i < 40 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'A')\n            goto end;\n    }\n\n    /* 28 bytes in we should find 8 bytes of B. */\n    for (i = 48; i < 48 + 8; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'B')\n            goto end;\n    }\n\n    /* And 36 bytes in we should find 3 bytes of C. */\n    for (i = 56; i < 56 + 3; i++) {\n        if (GET_PKT_DATA(reassembled)[i] != 'C')\n            goto end;\n    }\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    if (p3 != NULL)\n        SCFree(p3);\n    if (reassembled != NULL)\n        SCFree(reassembled);\n\n    DefragDestroy();\n    return ret;\n}\n",
        "output": "1",
        "index": 181482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PrintWebViewHelper::UpdatePrintSettings(\n    WebKit::WebFrame* frame, const WebKit::WebNode& node,\n    const DictionaryValue& passed_job_settings, bool print_for_preview) {\n  DCHECK(is_preview_enabled_);\n  const DictionaryValue* job_settings = &passed_job_settings;\n  DictionaryValue modified_job_settings;\n  if (job_settings->empty()) {\n    if (!print_for_preview)\n      print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);\n    return false;\n  }\n\n  bool source_is_html = true;\n  if (print_for_preview) {\n    if (!job_settings->GetBoolean(printing::kSettingPreviewModifiable,\n                                  &source_is_html)) {\n      NOTREACHED();\n    }\n  } else {\n    source_is_html = !PrintingNodeOrPdfFrame(frame, node);\n  }\n\n  if (print_for_preview || !source_is_html) {\n    modified_job_settings.MergeDictionary(job_settings);\n    modified_job_settings.SetBoolean(printing::kSettingHeaderFooterEnabled,\n                                     false);\n\n#if defined(OS_MACOSX) && !defined(USE_SKIA)\n    bool get_margins_from_pdf = !source_is_html && !print_for_preview;\n#elif defined(OS_WIN) || defined(OS_MACOSX)\n    bool get_margins_from_pdf = !source_is_html && print_for_preview;\n#else\n    bool get_margins_from_pdf = false;\n#endif\n\n    printing::MarginType margin_type = printing::NO_MARGINS;\n    if (get_margins_from_pdf)\n      margin_type = GetMarginsForPdf(frame, node);\n    modified_job_settings.SetInteger(printing::kSettingMarginsType,\n                                     margin_type);\n    job_settings = &modified_job_settings;\n  }\n\n  int cookie = print_pages_params_.get() ?\n      print_pages_params_->params.document_cookie : 0;\n  PrintMsg_PrintPages_Params settings;\n  Send(new PrintHostMsg_UpdatePrintSettings(routing_id(),\n      cookie, *job_settings, &settings));\n  print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));\n\n  if (PrintMsg_Print_Params_IsEmpty(settings.params)) {\n    if (!print_for_preview) {\n      print_preview_context_.set_error(PREVIEW_ERROR_INVALID_PRINTER_SETTINGS);\n    } else {\n      WebKit::WebFrame* print_frame = NULL;\n      GetPrintFrame(&print_frame);\n      if (print_frame) {\n        render_view()->RunModalAlertDialog(\n            print_frame,\n            l10n_util::GetStringUTF16(\n                IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));\n      }\n    }\n    return false;\n  }\n\n  if (settings.params.dpi < kMinDpi || !settings.params.document_cookie) {\n    print_preview_context_.set_error(PREVIEW_ERROR_UPDATING_PRINT_SETTINGS);\n    return false;\n  }\n\n  if (!print_for_preview) {\n    if (!job_settings->GetString(printing::kPreviewUIAddr,\n                                 &(settings.params.preview_ui_addr)) ||\n        !job_settings->GetInteger(printing::kPreviewRequestID,\n                                  &(settings.params.preview_request_id)) ||\n        !job_settings->GetBoolean(printing::kIsFirstRequest,\n                                  &(settings.params.is_first_request))) {\n      NOTREACHED();\n      print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);\n      return false;\n    }\n\n    PageSizeMargins default_page_layout;\n    GetPageSizeAndMarginsInPoints(NULL, -1, settings.params,\n                                  &default_page_layout);\n    if (!old_print_pages_params_.get() ||\n        !PageLayoutIsEqual(*old_print_pages_params_, settings)) {\n      Send(new PrintHostMsg_DidGetDefaultPageLayout(routing_id(),\n                                                    default_page_layout));\n    }\n\n    if (settings.params.display_header_footer) {\n      header_footer_info_.reset(new DictionaryValue());\n      header_footer_info_->SetString(printing::kSettingHeaderFooterDate,\n                                     settings.params.date);\n      header_footer_info_->SetString(printing::kSettingHeaderFooterURL,\n                                     settings.params.url);\n      header_footer_info_->SetString(printing::kSettingHeaderFooterTitle,\n                                     settings.params.title);\n    }\n  }\n\n  print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));\n  Send(new PrintHostMsg_DidGetDocumentCookie(routing_id(),\n                                             settings.params.document_cookie));\n  return true;\n}\n",
        "output": "0",
        "index": 101539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ipa_device_begin(wmfAPI * API)\n{\n  char\n    comment[MaxTextExtent];\n\n  wmf_magick_t\n    *ddata = WMF_MAGICK_GetData(API);\n\n  /* Make SVG output happy */\n  (void) PushDrawingWand(WmfDrawingWand);\n\n  DrawSetViewbox(WmfDrawingWand, 0, 0, ddata->image->columns, ddata->image->rows );\n\n  (void) FormatLocaleString(comment,MaxTextExtent,\"Created by ImageMagick %s\",\n    GetMagickVersion((size_t *) NULL));\n  DrawComment(WmfDrawingWand,comment);\n\n  /* Scale width and height to image */\n  DrawScale(WmfDrawingWand, ddata->scale_x, ddata->scale_y);\n\n  /* Translate to TL corner of bounding box */\n  DrawTranslate(WmfDrawingWand, ddata->translate_x, ddata->translate_y);\n\n  /* Apply rotation */\n  DrawRotate(WmfDrawingWand, ddata->rotate);\n\n  if (ddata->image_info->texture == NULL)\n    {\n      PixelWand\n        *background_color;\n\n      /* Draw rectangle in background color */\n      background_color=NewPixelWand();\n      PixelSetQuantumColor(background_color,&ddata->image->background_color);\n      DrawSetFillColor(WmfDrawingWand,background_color);\n      background_color=DestroyPixelWand(background_color);\n      DrawRectangle(WmfDrawingWand,\n                     XC(ddata->bbox.TL.x),YC(ddata->bbox.TL.y),\n                     XC(ddata->bbox.BR.x),YC(ddata->bbox.BR.y));\n    }\n  else\n    {\n      /* Draw rectangle with texture image the SVG way */\n      Image\n        *image;\n\n      ImageInfo\n        *image_info;\n\n      ExceptionInfo\n        *exception;\n\n      exception=AcquireExceptionInfo();\n\n      image_info = CloneImageInfo((ImageInfo *) 0);\n      (void) CopyMagickString(image_info->filename,ddata->image_info->texture,\n        MaxTextExtent);\n      if ( ddata->image_info->size )\n        CloneString(&image_info->size,ddata->image_info->size);\n\n      image = ReadImage(image_info,exception);\n      image_info=DestroyImageInfo(image_info);\n      if (image)\n        {\n          char\n            pattern_id[30];\n\n          MagickWand\n            *magick_wand;\n\n          (void) CopyMagickString(image->magick,\"MIFF\",MaxTextExtent);\n          DrawPushDefs(WmfDrawingWand);\n          draw_pattern_push(API,ddata->pattern_id,image->columns,image->rows);\n          magick_wand=NewMagickWandFromImage(image);\n          (void) DrawComposite(WmfDrawingWand,CopyCompositeOp,0,0,\n            image->columns,image->rows,magick_wand);\n          magick_wand=DestroyMagickWand(magick_wand);\n          (void) DrawPopPattern(WmfDrawingWand);\n          DrawPopDefs(WmfDrawingWand);\n          (void) FormatLocaleString(pattern_id,MaxTextExtent,\"#brush_%lu\",\n            ddata->pattern_id);\n          (void) DrawSetFillPatternURL(WmfDrawingWand,pattern_id);\n          ++ddata->pattern_id;\n\n          DrawRectangle(WmfDrawingWand,\n                         XC(ddata->bbox.TL.x),YC(ddata->bbox.TL.y),\n                         XC(ddata->bbox.BR.x),YC(ddata->bbox.BR.y));\n          image=DestroyImageList(image);\n        }\n      else\n        {\n          LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"reading texture image failed!\");\n          InheritException(&ddata->image->exception,exception);\n        }\n      (void) DestroyExceptionInfo(exception);\n    }\n\n  DrawSetClipRule(WmfDrawingWand,EvenOddRule); /* Default for WMF is ALTERNATE polygon fill mode */\n  draw_fill_color_string(WmfDrawingWand,\"none\"); /* Default brush is WHITE_BRUSH */\n  draw_stroke_color_string(WmfDrawingWand,\"none\"); /* Default pen is BLACK_PEN */\n  DrawSetStrokeLineCap(WmfDrawingWand,ButtCap); /* Default linecap is PS_ENDCAP_FLAT */\n  DrawSetStrokeLineJoin(WmfDrawingWand,MiterJoin); /* Default linejoin is PS_JOIN_MITER */\n  draw_under_color_string(WmfDrawingWand,\"white\"); /* Default text box is white */\n}\n",
        "output": "0",
        "index": 71817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderFrameHostImpl::ValidateDidCommitParams(\n    FrameHostMsg_DidCommitProvisionalLoad_Params* validated_params) {\n  RenderProcessHost* process = GetProcess();\n\n  bool is_permitted_error_page = false;\n  if (SiteIsolationPolicy::IsErrorPageIsolationEnabled(\n          frame_tree_node_->IsMainFrame())) {\n    if (site_instance_->GetSiteURL() == GURL(content::kUnreachableWebDataURL)) {\n      if (!validated_params->url_is_unreachable) {\n        DEBUG_ALIAS_FOR_ORIGIN(origin_debug_alias, validated_params->origin);\n        bad_message::ReceivedBadMessage(\n            process, bad_message::RFH_ERROR_PROCESS_NON_ERROR_COMMIT);\n        return false;\n      }\n\n      if (!validated_params->origin.opaque()) {\n        DEBUG_ALIAS_FOR_ORIGIN(origin_debug_alias, validated_params->origin);\n        bad_message::ReceivedBadMessage(\n            process, bad_message::RFH_ERROR_PROCESS_NON_UNIQUE_ORIGIN_COMMIT);\n        return false;\n      }\n\n      is_permitted_error_page = true;\n    }\n  } else {\n    if (GetNavigationHandle() && GetNavigationHandle()->GetNetErrorCode() ==\n                                     net::ERR_BLOCKED_BY_CLIENT) {\n      if (!validated_params->origin.opaque()) {\n        DEBUG_ALIAS_FOR_ORIGIN(origin_debug_alias, validated_params->origin);\n        bad_message::ReceivedBadMessage(\n            process, bad_message::RFH_ERROR_PROCESS_NON_UNIQUE_ORIGIN_COMMIT);\n        return false;\n      }\n\n      is_permitted_error_page = true;\n    }\n  }\n\n  if (!is_permitted_error_page && !CanCommitURL(validated_params->url)) {\n    VLOG(1) << \"Blocked URL \" << validated_params->url.spec();\n    LogRendererKillCrashKeys(GetSiteInstance()->GetSiteURL());\n\n    bad_message::ReceivedBadMessage(process,\n                                    bad_message::RFH_CAN_COMMIT_URL_BLOCKED);\n    return false;\n  }\n\n  if (!CanCommitOrigin(validated_params->origin, validated_params->url)) {\n    DEBUG_ALIAS_FOR_ORIGIN(origin_debug_alias, validated_params->origin);\n    LogRendererKillCrashKeys(GetSiteInstance()->GetSiteURL());\n\n    bad_message::ReceivedBadMessage(process,\n                                    bad_message::RFH_INVALID_ORIGIN_ON_COMMIT);\n    return false;\n  }\n\n  process->FilterURL(false, &validated_params->url);\n  process->FilterURL(true, &validated_params->referrer.url);\n  for (auto it(validated_params->redirects.begin());\n       it != validated_params->redirects.end(); ++it) {\n    process->FilterURL(false, &(*it));\n  }\n\n  if (!CanAccessFilesOfPageState(validated_params->page_state)) {\n    bad_message::ReceivedBadMessage(\n        process, bad_message::RFH_CAN_ACCESS_FILES_OF_PAGE_STATE);\n    return false;\n  }\n\n  return true;\n}\n",
        "output": "0",
        "index": 166163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void led_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, leds.work);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\ti;\n\tunsigned\t\tchanged = 0;\n\tint\t\t\tcursor = -1;\n\n\tif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\n\t\treturn;\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tunsigned\tselector, mode;\n\n\t\t/* 30%-50% duty cycle */\n\n\t\tswitch (hub->indicator[i]) {\n\t\t/* cycle marker */\n\t\tcase INDICATOR_CYCLE:\n\t\t\tcursor = i;\n\t\t\tselector = HUB_LED_AUTO;\n\t\t\tmode = INDICATOR_AUTO;\n\t\t\tbreak;\n\t\t/* blinking green = sw attention */\n\t\tcase INDICATOR_GREEN_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_GREEN_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_GREEN_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_GREEN_BLINK;\n\t\t\tbreak;\n\t\t/* blinking amber = hw attention */\n\t\tcase INDICATOR_AMBER_BLINK:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_AMBER_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_AMBER_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_AMBER_BLINK;\n\t\t\tbreak;\n\t\t/* blink green/amber = reserved */\n\t\tcase INDICATOR_ALT_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_ALT_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_ALT_BLINK_OFF:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_ALT_BLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (selector != HUB_LED_AUTO)\n\t\t\tchanged = 1;\n\t\tset_port_led(hub, i + 1, selector);\n\t\thub->indicator[i] = mode;\n\t}\n\tif (!changed && blinkenlights) {\n\t\tcursor++;\n\t\tcursor %= hdev->maxchild;\n\t\tset_port_led(hub, cursor + 1, HUB_LED_GREEN);\n\t\thub->indicator[cursor] = INDICATOR_CYCLE;\n\t\tchanged++;\n\t}\n\tif (changed)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n}\n",
        "output": "0",
        "index": 56778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::InstallFeatureName(\n    v8::Isolate* isolate,\n    const DOMWrapperWorld& world,\n    v8::Local<v8::Object> instance,\n    v8::Local<v8::Object> prototype,\n    v8::Local<v8::Function> interface) {\n  v8::Local<v8::FunctionTemplate> interface_template =\n      V8TestObject::GetWrapperTypeInfo()->DomTemplate(isolate, world);\n  v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_template);\n  ALLOW_UNUSED_LOCAL(signature);\n  static constexpr V8DOMConfiguration::AccessorConfiguration\n  kAccessorConfigurations[] = {\n      { \"originTrialEnabledLongAttribute\", V8TestObject::OriginTrialEnabledLongAttributeAttributeGetterCallback, V8TestObject::OriginTrialEnabledLongAttributeAttributeSetterCallback, V8PrivateProperty::kNoCachedAccessor, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::kOnPrototype, V8DOMConfiguration::kCheckHolder, V8DOMConfiguration::kHasSideEffect, V8DOMConfiguration::kAlwaysCallGetter, V8DOMConfiguration::kAllWorlds },\n      { \"unscopableOriginTrialEnabledLongAttribute\", V8TestObject::UnscopableOriginTrialEnabledLongAttributeAttributeGetterCallback, V8TestObject::UnscopableOriginTrialEnabledLongAttributeAttributeSetterCallback, V8PrivateProperty::kNoCachedAccessor, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::kOnPrototype, V8DOMConfiguration::kCheckHolder, V8DOMConfiguration::kHasSideEffect, V8DOMConfiguration::kAlwaysCallGetter, V8DOMConfiguration::kAllWorlds },\n  };\n  V8DOMConfiguration::InstallAccessors(\n      isolate, world, instance, prototype, interface,\n      signature, kAccessorConfigurations,\n      base::size(kAccessorConfigurations));\n  static constexpr V8DOMConfiguration::MethodConfiguration\n  kOriginTrialEnabledVoidMethodConfigurations[] = {\n      {\"originTrialEnabledVoidMethod\", V8TestObject::OriginTrialEnabledVoidMethodMethodCallback, 0, v8::None, V8DOMConfiguration::kOnPrototype, V8DOMConfiguration::kCheckHolder, V8DOMConfiguration::kDoNotCheckAccess, V8DOMConfiguration::kHasSideEffect, V8DOMConfiguration::kAllWorlds}\n  };\n  for (const auto& config : kOriginTrialEnabledVoidMethodConfigurations) {\n    V8DOMConfiguration::InstallMethod(\n        isolate, world, instance, prototype,\n        interface, signature, config);\n  }\n  static constexpr V8DOMConfiguration::MethodConfiguration\n  kPerWorldBindingsOriginTrialEnabledVoidMethodConfigurations[] = {\n      {\"perWorldBindingsOriginTrialEnabledVoidMethod\", V8TestObject::PerWorldBindingsOriginTrialEnabledVoidMethodMethodCallbackForMainWorld, 0, v8::None, V8DOMConfiguration::kOnPrototype, V8DOMConfiguration::kCheckHolder, V8DOMConfiguration::kDoNotCheckAccess, V8DOMConfiguration::kHasSideEffect, V8DOMConfiguration::kMainWorld},\n      {\"perWorldBindingsOriginTrialEnabledVoidMethod\", V8TestObject::PerWorldBindingsOriginTrialEnabledVoidMethodMethodCallback, 0, v8::None, V8DOMConfiguration::kOnPrototype, V8DOMConfiguration::kCheckHolder, V8DOMConfiguration::kDoNotCheckAccess, V8DOMConfiguration::kHasSideEffect, V8DOMConfiguration::kNonMainWorlds}\n  };\n  for (const auto& config : kPerWorldBindingsOriginTrialEnabledVoidMethodConfigurations) {\n    V8DOMConfiguration::InstallMethod(\n        isolate, world, instance, prototype,\n        interface, signature, config);\n  }\n}\n",
        "output": "0",
        "index": 147454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tstruct nfsd4_release_lockowner *rlockowner)\n{\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_stateowner *sop;\n\tstruct nfs4_lockowner *lo = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct xdr_netobj *owner = &rlockowner->rl_owner;\n\tunsigned int hashval = ownerstr_hashval(owner);\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_client *clp;\n\tLIST_HEAD (reaplist);\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\n\tclp = cstate->clp;\n\t/* Find the matching lock stateowner */\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(sop, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\n\t\tif (sop->so_is_open_owner || !same_owner_str(sop, owner))\n\t\t\tcontinue;\n\n\t\t/* see if there are still any locks associated with it */\n\t\tlo = lockowner(sop);\n\t\tlist_for_each_entry(stp, &sop->so_stateids, st_perstateowner) {\n\t\t\tif (check_for_locks(stp->st_stid.sc_file, lo)) {\n\t\t\t\tstatus = nfserr_locks_held;\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tnfs4_get_stateowner(sop);\n\t\tbreak;\n\t}\n\tif (!lo) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\treturn status;\n\t}\n\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\t       struct nfs4_ol_stateid,\n\t\t\t\t       st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n\n\treturn status;\n}\n",
        "output": "0",
        "index": 65625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pp::VarDictionary PDFiumEngine::TraverseBookmarks(FPDF_BOOKMARK bookmark,\n                                                  unsigned int depth) {\n  pp::VarDictionary dict;\n  base::string16 title;\n  unsigned long buffer_size = FPDFBookmark_GetTitle(bookmark, nullptr, 0);\n  if (buffer_size > 0) {\n    PDFiumAPIStringBufferSizeInBytesAdapter<base::string16> api_string_adapter(\n        &title, buffer_size, true);\n    api_string_adapter.Close(FPDFBookmark_GetTitle(\n        bookmark, api_string_adapter.GetData(), buffer_size));\n  }\n  dict.Set(pp::Var(\"title\"), pp::Var(base::UTF16ToUTF8(title)));\n\n  FPDF_DEST dest = FPDFBookmark_GetDest(doc_, bookmark);\n  if (dest) {\n    unsigned long page_index = FPDFDest_GetPageIndex(doc_, dest);\n    if (page_index < pages_.size() &&\n        base::IsValueInRangeForNumericType<int32_t>(page_index)) {\n      dict.Set(pp::Var(\"page\"), pp::Var(static_cast<int32_t>(page_index)));\n      PDFiumPage::LinkTarget target;\n      pages_[page_index]->GetPageYTarget(dest, &target);\n      if (target.y_in_pixels)\n        dict.Set(pp::Var(\"y\"), pp::Var(target.y_in_pixels.value()));\n    }\n  } else {\n    FPDF_ACTION action = FPDFBookmark_GetAction(bookmark);\n    buffer_size = FPDFAction_GetURIPath(doc_, action, nullptr, 0);\n    if (buffer_size > 0) {\n      std::string uri;\n      PDFiumAPIStringBufferAdapter<std::string> api_string_adapter(\n          &uri, buffer_size, true);\n      api_string_adapter.Close(FPDFAction_GetURIPath(\n          doc_, action, api_string_adapter.GetData(), buffer_size));\n      dict.Set(pp::Var(\"uri\"), pp::Var(uri));\n    }\n  }\n\n  pp::VarArray children;\n\n  const unsigned int kMaxDepth = 128;\n  if (depth < kMaxDepth) {\n    int child_index = 0;\n    std::set<FPDF_BOOKMARK> seen_bookmarks;\n    for (FPDF_BOOKMARK child_bookmark =\n             FPDFBookmark_GetFirstChild(doc_, bookmark);\n         child_bookmark;\n         child_bookmark = FPDFBookmark_GetNextSibling(doc_, child_bookmark)) {\n      if (base::ContainsKey(seen_bookmarks, child_bookmark))\n        break;\n\n      seen_bookmarks.insert(child_bookmark);\n      children.Set(child_index, TraverseBookmarks(child_bookmark, depth + 1));\n      child_index++;\n    }\n  }\n  dict.Set(pp::Var(\"children\"), children);\n  return dict;\n}\n",
        "output": "0",
        "index": 159032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {\n ANativeWindowBuffer *buf;\n    CHECK(mNativeWindow.get() != NULL);\n\n if (mTunneled) {\n        ALOGW(\"dequeueBufferFromNativeWindow() should not be called in tunnel\"\n \" video playback mode mode!\");\n return NULL;\n }\n\n if (mFatalError) {\n        ALOGW(\"not dequeuing from native window due to fatal error\");\n return NULL;\n }\n\n int fenceFd = -1;\n do {\n status_t err = mNativeWindow->dequeueBuffer(mNativeWindow.get(), &buf, &fenceFd);\n if (err != 0) {\n            ALOGE(\"dequeueBuffer failed: %s(%d).\", asString(err), err);\n return NULL;\n }\n\n bool stale = false;\n for (size_t i = mBuffers[kPortIndexOutput].size(); i-- > 0;) {\n BufferInfo *info = &mBuffers[kPortIndexOutput].editItemAt(i);\n\n if (info->mGraphicBuffer != NULL &&\n                    info->mGraphicBuffer->handle == buf->handle) {\n if (info->mStatus != BufferInfo::OWNED_BY_NATIVE_WINDOW) {\n                    ALOGI(\"dequeued stale buffer %p. discarding\", buf);\n                    stale = true;\n break;\n }\n\n                ALOGV(\"dequeued buffer %p\", info->mGraphicBuffer->getNativeBuffer());\n                info->mStatus = BufferInfo::OWNED_BY_US;\n                info->setWriteFence(fenceFd, \"dequeueBufferFromNativeWindow\");\n                updateRenderInfoForDequeuedBuffer(buf, fenceFd, info);\n return info;\n }\n }\n\n if (!stale && (!storingMetadataInDecodedBuffers() || mLegacyAdaptiveExperiment)) {\n            ALOGI(\"dequeued unrecognized (stale) buffer %p. discarding\", buf);\n            stale = true;\n }\n if (stale) {\n            buf = NULL;\n }\n } while (buf == NULL);\n\n BufferInfo *oldest = NULL;\n for (size_t i = mBuffers[kPortIndexOutput].size(); i-- > 0;) {\n BufferInfo *info =\n &mBuffers[kPortIndexOutput].editItemAt(i);\n if (info->mStatus == BufferInfo::OWNED_BY_NATIVE_WINDOW &&\n (oldest == NULL ||\n             mDequeueCounter - info->mDequeuedAt >\n                    mDequeueCounter - oldest->mDequeuedAt)) {\n            oldest = info;\n }\n }\n\n    CHECK(oldest != NULL);\n    CHECK(storingMetadataInDecodedBuffers());\n\n    oldest->mGraphicBuffer = new GraphicBuffer(buf, false);\n    oldest->mStatus = BufferInfo::OWNED_BY_US;\n    oldest->setWriteFence(fenceFd, \"dequeueBufferFromNativeWindow for oldest\");\n    mRenderTracker.untrackFrame(oldest->mRenderInfo);\n    oldest->mRenderInfo = NULL;\n\n    mOMX->updateGraphicBufferInMeta(\n            mNode, kPortIndexOutput, oldest->mGraphicBuffer,\n            oldest->mBufferID);\n\n if (mOutputMetadataType == kMetadataBufferTypeGrallocSource) {\n VideoGrallocMetadata *grallocMeta =\n reinterpret_cast<VideoGrallocMetadata *>(oldest->mData->base());\n        ALOGV(\"replaced oldest buffer #%u with age %u (%p/%p stored in %p)\",\n (unsigned)(oldest - &mBuffers[kPortIndexOutput][0]),\n                mDequeueCounter - oldest->mDequeuedAt,\n (void *)(uintptr_t)grallocMeta->pHandle,\n                oldest->mGraphicBuffer->handle, oldest->mData->base());\n } else if (mOutputMetadataType == kMetadataBufferTypeANWBuffer) {\n VideoNativeMetadata *nativeMeta =\n reinterpret_cast<VideoNativeMetadata *>(oldest->mData->base());\n        ALOGV(\"replaced oldest buffer #%u with age %u (%p/%p stored in %p)\",\n (unsigned)(oldest - &mBuffers[kPortIndexOutput][0]),\n                mDequeueCounter - oldest->mDequeuedAt,\n (void *)(uintptr_t)nativeMeta->pBuffer,\n                oldest->mGraphicBuffer->getNativeBuffer(), oldest->mData->base());\n }\n\n    updateRenderInfoForDequeuedBuffer(buf, fenceFd, oldest);\n return oldest;\n}\n",
        "output": "0",
        "index": 177221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n \n \t\t\t/* Copy key */\n \t\t\tif (firstItem == URI_TRUE) {\n \t\t\t\tfirstItem = URI_FALSE;\n \t\t\t} else {\n \t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
        "output": "1",
        "index": 182148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kioctx *ioctx_alloc(unsigned nr_events)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct kioctx *ctx;\n\tint err = -ENOMEM;\n\n\t/*\n\t * We keep track of the number of available ringbuffer slots, to prevent\n\t * overflow (reqs_available), and we also use percpu counters for this.\n\t *\n\t * So since up to half the slots might be on other cpu's percpu counters\n\t * and unavailable, double nr_events so userspace sees what they\n\t * expected: additionally, we move req_batch slots to/from percpu\n\t * counters at a time, so make sure that isn't 0:\n\t */\n\tnr_events = max(nr_events, num_possible_cpus() * 4);\n\tnr_events *= 2;\n\n\t/* Prevent overflows */\n\tif ((nr_events > (0x10000000U / sizeof(struct io_event))) ||\n\t    (nr_events > (0x10000000U / sizeof(struct kiocb)))) {\n\t\tpr_debug(\"ENOMEM: nr_events too high\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!nr_events || (unsigned long)nr_events > (aio_max_nr * 2UL))\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tctx = kmem_cache_zalloc(kioctx_cachep, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->max_reqs = nr_events;\n\n\tspin_lock_init(&ctx->ctx_lock);\n\tspin_lock_init(&ctx->completion_lock);\n\tmutex_init(&ctx->ring_lock);\n\t/* Protect against page migration throughout kiotx setup by keeping\n\t * the ring_lock mutex held until setup is complete. */\n\tmutex_lock(&ctx->ring_lock);\n\tinit_waitqueue_head(&ctx->wait);\n\n\tINIT_LIST_HEAD(&ctx->active_reqs);\n\n\tif (percpu_ref_init(&ctx->users, free_ioctx_users))\n\t\tgoto err;\n\n\tif (percpu_ref_init(&ctx->reqs, free_ioctx_reqs))\n\t\tgoto err;\n\n\tctx->cpu = alloc_percpu(struct kioctx_cpu);\n\tif (!ctx->cpu)\n\t\tgoto err;\n\n\terr = aio_setup_ring(ctx);\n\tif (err < 0)\n\t\tgoto err;\n\n\tatomic_set(&ctx->reqs_available, ctx->nr_events - 1);\n\tctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);\n\tif (ctx->req_batch < 1)\n\t\tctx->req_batch = 1;\n\n\t/* limit the number of system wide aios */\n\tspin_lock(&aio_nr_lock);\n\tif (aio_nr + nr_events > (aio_max_nr * 2UL) ||\n\t    aio_nr + nr_events < aio_nr) {\n\t\tspin_unlock(&aio_nr_lock);\n\t\terr = -EAGAIN;\n\t\tgoto err_ctx;\n\t}\n\taio_nr += ctx->max_reqs;\n\tspin_unlock(&aio_nr_lock);\n\n\tpercpu_ref_get(&ctx->users);\t/* io_setup() will drop this ref */\n\tpercpu_ref_get(&ctx->reqs);\t/* free_ioctx_users() will drop this */\n\n\terr = ioctx_add_table(ctx, mm);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\t/* Release the ring_lock mutex now that all setup is complete. */\n\tmutex_unlock(&ctx->ring_lock);\n\n\tpr_debug(\"allocated ioctx %p[%ld]: mm=%p mask=0x%x\\n\",\n\t\t ctx, ctx->user_id, mm, ctx->nr_events);\n\treturn ctx;\n\nerr_cleanup:\n\taio_nr_sub(ctx->max_reqs);\nerr_ctx:\n\taio_free_ring(ctx);\nerr:\n\tmutex_unlock(&ctx->ring_lock);\n\tfree_percpu(ctx->cpu);\n\tfree_percpu(ctx->reqs.pcpu_count);\n\tfree_percpu(ctx->users.pcpu_count);\n\tkmem_cache_free(kioctx_cachep, ctx);\n\tpr_debug(\"error allocating ioctx %d\\n\", err);\n\treturn ERR_PTR(err);\n}\n",
        "output": "0",
        "index": 39611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderImpl::HandleVertexAttribPointer(\n    uint32 immediate_data_size, const gles2::VertexAttribPointer& c) {\n  if (!bound_array_buffer_ || bound_array_buffer_->IsDeleted()) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glVertexAttribPointer: no array buffer bound\");\n    return error::kNoError;\n  }\n\n  GLuint indx = c.indx;\n  GLint size = c.size;\n  GLenum type = c.type;\n  GLboolean normalized = c.normalized;\n  GLsizei stride = c.stride;\n  GLsizei offset = c.offset;\n  const void* ptr = reinterpret_cast<const void*>(offset);\n  if (!validators_->vertex_attrib_type.IsValid(type)) {\n    SetGLError(GL_INVALID_ENUM,\n               \"glVertexAttribPointer: type GL_INVALID_ENUM\");\n    return error::kNoError;\n  }\n  if (!validators_->vertex_attrib_size.IsValid(size)) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glVertexAttribPointer: size GL_INVALID_VALUE\");\n    return error::kNoError;\n  }\n  if (indx >= group_->max_vertex_attribs()) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttribPointer: index out of range\");\n    return error::kNoError;\n  }\n  if (stride < 0) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glVertexAttribPointer: stride < 0\");\n    return error::kNoError;\n  }\n  if (stride > 255) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glVertexAttribPointer: stride > 255\");\n    return error::kNoError;\n  }\n  if (offset < 0) {\n    SetGLError(GL_INVALID_VALUE,\n               \"glVertexAttribPointer: offset < 0\");\n    return error::kNoError;\n  }\n  GLsizei component_size =\n      GLES2Util::GetGLTypeSizeForTexturesAndBuffers(type);\n  if (offset % component_size > 0) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glVertexAttribPointer: offset not valid for type\");\n    return error::kNoError;\n  }\n  if (stride % component_size > 0) {\n    SetGLError(GL_INVALID_OPERATION,\n               \"glVertexAttribPointer: stride not valid for type\");\n    return error::kNoError;\n  }\n  vertex_attrib_manager_->SetAttribInfo(\n      indx,\n      bound_array_buffer_,\n      size,\n      type,\n      normalized,\n      stride,\n      stride != 0 ? stride : component_size * size,\n      offset);\n  if (type != GL_FIXED) {\n    glVertexAttribPointer(indx, size, type, normalized, stride, ptr);\n  }\n  return error::kNoError;\n}\n",
        "output": "0",
        "index": 117281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_init_creds_set_keytab(krb5_context context,\n\t\t\t   krb5_init_creds_context ctx,\n\t\t\t   krb5_keytab keytab)\n{\n    krb5_keytab_key_proc_args *a;\n    krb5_keytab_entry entry;\n    krb5_kt_cursor cursor;\n    krb5_enctype *etypes = NULL;\n    krb5_error_code ret;\n    size_t netypes = 0;\n    int kvno = 0, found = 0;\n\n    a = malloc(sizeof(*a));\n    if (a == NULL)\n\treturn krb5_enomem(context);\n\n    a->principal = ctx->cred.client;\n    a->keytab    = keytab;\n\n    ctx->keytab_data = a;\n    ctx->keyseed = (void *)a;\n    ctx->keyproc = keytab_key_proc;\n\n    /*\n     * We need to the KDC what enctypes we support for this keytab,\n     * esp if the keytab is really a password based entry, then the\n     * KDC might have more enctypes in the database then what we have\n     * in the keytab.\n     */\n\n    ret = krb5_kt_start_seq_get(context, keytab, &cursor);\n    if(ret)\n\tgoto out;\n\n    while(krb5_kt_next_entry(context, keytab, &entry, &cursor) == 0){\n\tvoid *ptr;\n\n\tif (!krb5_principal_compare(context, entry.principal, ctx->cred.client))\n\t    goto next;\n\n\tfound = 1;\n\n\t/* check if we ahve this kvno already */\n\tif (entry.vno > kvno) {\n\t    /* remove old list of etype */\n\t    if (etypes)\n\t\tfree(etypes);\n\t    etypes = NULL;\n\t    netypes = 0;\n\t    kvno = entry.vno;\n\t} else if (entry.vno != kvno)\n\t    goto next;\n\n\t/* check if enctype is supported */\n\tif (krb5_enctype_valid(context, entry.keyblock.keytype) != 0)\n\t    goto next;\n\n\t/* add enctype to supported list */\n\tptr = realloc(etypes, sizeof(etypes[0]) * (netypes + 2));\n\tif (ptr == NULL) {\n\t    free(etypes);\n\t    ret = krb5_enomem(context);\n\t    goto out;\n\t}\n\n\tetypes = ptr;\n\tetypes[netypes] = entry.keyblock.keytype;\n\tetypes[netypes + 1] = ETYPE_NULL;\n\tnetypes++;\n    next:\n\tkrb5_kt_free_entry(context, &entry);\n    }\n    krb5_kt_end_seq_get(context, keytab, &cursor);\n\n    if (etypes) {\n\tif (ctx->etypes)\n\t    free(ctx->etypes);\n\tctx->etypes = etypes;\n    }\n\n out:\n    if (!found) {\n\tif (ret == 0)\n\t    ret = KRB5_KT_NOTFOUND;\n\t_krb5_kt_principal_not_found(context, ret, keytab, ctx->cred.client, 0, 0);\n    }\n\n    return ret;\n}\n",
        "output": "0",
        "index": 89927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int proto_register(struct proto *prot, int alloc_slab)\n{\n\tif (alloc_slab) {\n\t\tprot->slab = kmem_cache_create(prot->name, prot->obj_size, 0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN | prot->slab_flags,\n\t\t\t\t\tNULL);\n\n\t\tif (prot->slab == NULL) {\n\t\t\tprintk(KERN_CRIT \"%s: Can't create sock SLAB cache!\\n\",\n\t\t\t       prot->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (prot->rsk_prot != NULL) {\n\t\t\tprot->rsk_prot->slab_name = kasprintf(GFP_KERNEL, \"request_sock_%s\", prot->name);\n\t\t\tif (prot->rsk_prot->slab_name == NULL)\n\t\t\t\tgoto out_free_sock_slab;\n\n\t\t\tprot->rsk_prot->slab = kmem_cache_create(prot->rsk_prot->slab_name,\n\t\t\t\t\t\t\t\t prot->rsk_prot->obj_size, 0,\n\t\t\t\t\t\t\t\t SLAB_HWCACHE_ALIGN, NULL);\n\n\t\t\tif (prot->rsk_prot->slab == NULL) {\n\t\t\t\tprintk(KERN_CRIT \"%s: Can't create request sock SLAB cache!\\n\",\n\t\t\t\t       prot->name);\n\t\t\t\tgoto out_free_request_sock_slab_name;\n\t\t\t}\n\t\t}\n\n\t\tif (prot->twsk_prot != NULL) {\n\t\t\tprot->twsk_prot->twsk_slab_name = kasprintf(GFP_KERNEL, \"tw_sock_%s\", prot->name);\n\n\t\t\tif (prot->twsk_prot->twsk_slab_name == NULL)\n\t\t\t\tgoto out_free_request_sock_slab;\n\n\t\t\tprot->twsk_prot->twsk_slab =\n\t\t\t\tkmem_cache_create(prot->twsk_prot->twsk_slab_name,\n\t\t\t\t\t\t  prot->twsk_prot->twsk_obj_size,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t\t\tprot->slab_flags,\n\t\t\t\t\t\t  NULL);\n\t\t\tif (prot->twsk_prot->twsk_slab == NULL)\n\t\t\t\tgoto out_free_timewait_sock_slab_name;\n\t\t}\n\t}\n\n\tmutex_lock(&proto_list_mutex);\n\tlist_add(&prot->node, &proto_list);\n\tassign_proto_idx(prot);\n\tmutex_unlock(&proto_list_mutex);\n\treturn 0;\n\nout_free_timewait_sock_slab_name:\n\tkfree(prot->twsk_prot->twsk_slab_name);\nout_free_request_sock_slab:\n\tif (prot->rsk_prot && prot->rsk_prot->slab) {\n\t\tkmem_cache_destroy(prot->rsk_prot->slab);\n\t\tprot->rsk_prot->slab = NULL;\n\t}\nout_free_request_sock_slab_name:\n\tif (prot->rsk_prot)\n\t\tkfree(prot->rsk_prot->slab_name);\nout_free_sock_slab:\n\tkmem_cache_destroy(prot->slab);\n\tprot->slab = NULL;\nout:\n\treturn -ENOBUFS;\n}\n",
        "output": "0",
        "index": 58679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::OnFind(int request_id, const string16& search_text,\n                        const WebFindOptions& options) {\n  WebFrame* main_frame = webview()->mainFrame();\n\n  if (main_frame->document().isPluginDocument()) {\n    if (options.findNext) {\n      GetWebPluginFromPluginDocument()->selectFindResult(options.forward);\n    } else {\n      if (GetWebPluginFromPluginDocument()->startFind(\n          search_text, options.matchCase, request_id)) {\n      } else {\n        ReportNoFindInPageResults(request_id);\n      }\n    }\n    return;\n  }\n\n  WebFrame* frame_after_main = main_frame->traverseNext(true);\n  WebFrame* focused_frame = webview()->focusedFrame();\n  WebFrame* search_frame = focused_frame;  // start searching focused frame.\n\n  bool multi_frame = (frame_after_main != main_frame);\n\n  bool wrap_within_frame = !multi_frame;\n\n  WebRect selection_rect;\n  bool result = false;\n\n  WebRange current_selection = focused_frame->selectionRange();\n\n  do {\n    result = search_frame->find(\n        request_id, search_text, options, wrap_within_frame, &selection_rect);\n\n    if (!result) {\n      search_frame->executeCommand(WebString::fromUTF8(\"Unselect\"));\n\n      do {\n        search_frame = options.forward ?\n            search_frame->traverseNext(true) :\n            search_frame->traversePrevious(true);\n      } while (!search_frame->hasVisibleContent() &&\n               search_frame != focused_frame);\n\n      search_frame->executeCommand(WebString::fromUTF8(\"Unselect\"));\n\n      if (multi_frame && search_frame == focused_frame) {\n        result = search_frame->find(\n            request_id, search_text, options, true,  // Force wrapping.\n            &selection_rect);\n      }\n    }\n\n    webview()->setFocusedFrame(search_frame);\n  } while (!result && search_frame != focused_frame);\n\n  if (options.findNext && current_selection.isNull()) {\n    main_frame->increaseMatchCount(0, request_id);\n  } else {\n    int ordinal = result ? -1 : 0;  // -1 here means, we might know more later.\n    int match_count = result ? 1 : 0;  // 1 here means possibly more coming.\n\n    bool final_status_update = !result;\n\n    Send(new ViewHostMsg_Find_Reply(routing_id_,\n                                    request_id,\n                                    match_count,\n                                    selection_rect,\n                                    ordinal,\n                                    final_status_update));\n\n    search_frame = main_frame;\n\n    main_frame->resetMatchCount();\n\n    do {\n      search_frame->cancelPendingScopingEffort();\n\n      if (result) {\n        search_frame->scopeStringMatches(request_id,\n                                         search_text,\n                                         options,\n                                         true);  // reset the tickmarks\n      }\n\n      search_frame = search_frame->traverseNext(true);\n    } while (search_frame != main_frame);\n  }\n}\n",
        "output": "0",
        "index": 97955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SP_DEVICE_INTERFACE_DETAIL_DATA_A *get_interface_details_filter(struct libusb_context *ctx,\n\tHDEVINFO *dev_info, SP_DEVINFO_DATA *dev_info_data, const GUID* guid, unsigned _index, char* filter_path){\n\tSP_DEVICE_INTERFACE_DATA dev_interface_data;\n\tSP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_interface_details = NULL;\n\tDWORD size;\n\tif (_index <= 0) {\n\t\t*dev_info = pSetupDiGetClassDevsA(guid, NULL, NULL, DIGCF_PRESENT|DIGCF_DEVICEINTERFACE);\n\t}\n\tif (dev_info_data != NULL) {\n\t\tdev_info_data->cbSize = sizeof(SP_DEVINFO_DATA);\n\t\tif (!pSetupDiEnumDeviceInfo(*dev_info, _index, dev_info_data)) {\n\t\t\tif (GetLastError() != ERROR_NO_MORE_ITEMS) {\n\t\t\t\tusbi_err(ctx, \"Could not obtain device info data for index %u: %s\",\n\t\t\t\t\t_index, windows_error_str(0));\n\t\t\t}\n\t\t\tpSetupDiDestroyDeviceInfoList(*dev_info);\n\t\t\t*dev_info = INVALID_HANDLE_VALUE;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tdev_interface_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);\n\tif (!pSetupDiEnumDeviceInterfaces(*dev_info, NULL, guid, _index, &dev_interface_data)) {\n\t\tif (GetLastError() != ERROR_NO_MORE_ITEMS) {\n\t\t\tusbi_err(ctx, \"Could not obtain interface data for index %u: %s\",\n\t\t\t\t_index, windows_error_str(0));\n\t\t}\n\t\tpSetupDiDestroyDeviceInfoList(*dev_info);\n\t\t*dev_info = INVALID_HANDLE_VALUE;\n\t\treturn NULL;\n\t}\n\tif (!pSetupDiGetDeviceInterfaceDetailA(*dev_info, &dev_interface_data, NULL, 0, &size, NULL)) {\n\t\tif (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tusbi_err(ctx, \"could not access interface data (dummy) for index %u: %s\",\n\t\t\t\t_index, windows_error_str(0));\n\t\t\tgoto err_exit;\n\t\t}\n\t} else {\n\t\tusbi_err(ctx, \"program assertion failed - http://msdn.microsoft.com/en-us/library/ms792901.aspx is wrong.\");\n\t\tgoto err_exit;\n\t}\n\tif ((dev_interface_details = malloc(size)) == NULL) {\n\t\tusbi_err(ctx, \"could not allocate interface data for index %u.\", _index);\n\t\tgoto err_exit;\n\t}\n\tdev_interface_details->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A);\n\tif (!pSetupDiGetDeviceInterfaceDetailA(*dev_info, &dev_interface_data,\n\t\tdev_interface_details, size, &size, NULL)) {\n\t\tusbi_err(ctx, \"could not access interface data (actual) for index %u: %s\",\n\t\t\t_index, windows_error_str(0));\n\t}\n\tif (dev_interface_details) {\n\t\tHKEY hkey_device_interface=pSetupDiOpenDeviceInterfaceRegKey(*dev_info,&dev_interface_data,0,KEY_READ);\n\t\tif (hkey_device_interface != INVALID_HANDLE_VALUE) {\n\t\t\tDWORD libusb0_symboliclink_index=0;\n\t\t\tDWORD value_length=sizeof(DWORD);\n\t\t\tDWORD value_type=0;\n\t\t\tLONG status;\n\t\t\tstatus = pRegQueryValueExW(hkey_device_interface, L\"LUsb0\", NULL, &value_type,\n\t\t\t\t(LPBYTE) &libusb0_symboliclink_index, &value_length);\n\t\t\tif (status == ERROR_SUCCESS) {\n\t\t\t\tif (libusb0_symboliclink_index < 256) {\n\t\t\t\t\tsafe_sprintf(filter_path, sizeof(\"\\\\\\\\.\\\\libusb0-0000\"), \"\\\\\\\\.\\\\libusb0-%04d\", libusb0_symboliclink_index);\n\t\t\t\t\tusbi_dbg(\"assigned libusb0 symbolic link %s\", filter_path);\n\t\t\t\t} else {\n\t\t\t\t}\n\t\t\t}\n\t\t\tpRegCloseKey(hkey_device_interface);\n\t\t}\n\t}\n\treturn dev_interface_details;\nerr_exit:\n\tpSetupDiDestroyDeviceInfoList(*dev_info);\n\t*dev_info = INVALID_HANDLE_VALUE;\n\treturn NULL;}\n",
        "output": "0",
        "index": 168540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int build_filter(ResampleContext *c, double factor)\n{\n    int ph, i;\n    double x, y, w;\n    double *tab;\n    int tap_count    = c->filter_length;\n    int phase_count  = 1 << c->phase_shift;\n    const int center = (tap_count - 1) / 2;\n\n    tab = av_malloc(tap_count * sizeof(*tab));\n    if (!tab)\n        return AVERROR(ENOMEM);\n\n    for (ph = 0; ph < phase_count; ph++) {\n        double norm = 0;\n        for (i = 0; i < tap_count; i++) {\n            x = M_PI * ((double)(i - center) - (double)ph / phase_count) * factor;\n            if (x == 0) y = 1.0;\n            else        y = sin(x) / x;\n            switch (c->filter_type) {\n            case AV_RESAMPLE_FILTER_TYPE_CUBIC: {\n                const float d = -0.5; //first order derivative = -0.5\n                x = fabs(((double)(i - center) - (double)ph / phase_count) * factor);\n                if (x < 1.0) y = 1 - 3 * x*x + 2 * x*x*x + d * (                -x*x + x*x*x);\n                else         y =                           d * (-4 + 8 * x - 5 * x*x + x*x*x);\n                break;\n            }\n            case AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL:\n                w  = 2.0 * x / (factor * tap_count) + M_PI;\n                y *= 0.3635819 - 0.4891775 * cos(    w) +\n                                 0.1365995 * cos(2 * w) -\n                                 0.0106411 * cos(3 * w);\n                break;\n            case AV_RESAMPLE_FILTER_TYPE_KAISER:\n                w  = 2.0 * x / (factor * tap_count * M_PI);\n                y *= bessel(c->kaiser_beta * sqrt(FFMAX(1 - w * w, 0)));\n                break;\n            }\n\n            tab[i] = y;\n            norm  += y;\n        }\n        /* normalize so that an uniform color remains the same */\n        for (i = 0; i < tap_count; i++)\n            tab[i] = tab[i] / norm;\n\n        c->set_filter(c->filter_bank, tab, ph, tap_count);\n    }\n\n    av_free(tab);\n    return 0;\n}\n",
        "output": "0",
        "index": 14373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pkinit_create_sequence_of_principal_identifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    int type,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n    krb5_external_principal_identifier **krb5_trusted_certifiers = NULL;\n    krb5_data *td_certifiers = NULL;\n    krb5_pa_data **pa_data = NULL;\n\n    switch(type) {\n    case TD_TRUSTED_CERTIFIERS:\n        retval = create_krb5_trustedCertifiers(context, plg_cryptoctx,\n                                               req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_trustedCertifiers failed\\n\");\n            goto cleanup;\n        }\n        break;\n    case TD_INVALID_CERTIFICATES:\n        retval = create_krb5_invalidCertificates(context, plg_cryptoctx,\n                                                 req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_invalidCertificates failed\\n\");\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    retval = k5int_encode_krb5_td_trusted_certifiers((const krb5_external_principal_identifier **)krb5_trusted_certifiers, &td_certifiers);\n    if (retval) {\n        pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)td_certifiers->data,\n                     td_certifiers->length, \"/tmp/kdc_td_certifiers\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = type;\n    pa_data[0]->length = td_certifiers->length;\n    pa_data[0]->contents = (krb5_octet *)td_certifiers->data;\n    *e_data_out = pa_data;\n    retval = 0;\n\ncleanup:\n    if (krb5_trusted_certifiers != NULL)\n        free_krb5_external_principal_identifier(&krb5_trusted_certifiers);\n    free(td_certifiers);\n    return retval;\n}\n",
        "output": "0",
        "index": 33653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf_xref_size_from_old_trailer(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)\n{\n\tint64_t len;\n\tchar *s;\n\tint64_t t;\n\tpdf_token tok;\n\tint c;\n\tint size = 0;\n\tint64_t ofs;\n\tpdf_obj *trailer = NULL;\n\tsize_t n;\n\n\tfz_var(trailer);\n\n\t/* Record the current file read offset so that we can reinstate it */\n\tofs = fz_tell(ctx, doc->file);\n\n\tfz_skip_space(ctx, doc->file);\n\tif (fz_skip_string(ctx, doc->file, \"xref\"))\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot find xref marker\");\n\tfz_skip_space(ctx, doc->file);\n\n\twhile (1)\n\t{\n\t\tc = fz_peek_byte(ctx, doc->file);\n\t\tif (!(c >= '0' && c <= '9'))\n\t\t\tbreak;\n\n\t\tfz_read_line(ctx, doc->file, buf->scratch, buf->size);\n\t\ts = buf->scratch;\n\t\tfz_strsep(&s, \" \"); /* ignore ofs */\n\t\tif (!s)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"invalid range marker in xref\");\n\t\tlen = fz_atoi64(fz_strsep(&s, \" \"));\n\t\tif (len < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref range marker must be positive\");\n\n\t\t/* broken pdfs where the section is not on a separate line */\n\t\tif (s && *s != '\\0')\n\t\t\tfz_seek(ctx, doc->file, -(2 + (int)strlen(s)), SEEK_CUR);\n\n\t\tt = fz_tell(ctx, doc->file);\n\t\tif (t < 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot tell in file\");\n\n\t\t/* Spec says xref entries should be 20 bytes, but it's not infrequent\n\t\t * to see 19, in particular for some PCLm drivers. Cope. */\n\t\tif (len > 0)\n\t\t{\n\t\t\tn = fz_read(ctx, doc->file, (unsigned char *)buf->scratch, 20);\n\t\t\tif (n < 19)\n\t\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"malformed xref table\");\n\t\t\tif (n == 20 && buf->scratch[19] > 32)\n\t\t\t\tn = 19;\n\t\t}\n\t\telse\n\t\t\tn = 20;\n\n\t\tif (len > (int64_t)((INT64_MAX - t) / n))\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref has too many entries\");\n\n\t\tfz_seek(ctx, doc->file, (int64_t)(t + n * len), SEEK_SET);\n\t}\n\n\tfz_try(ctx)\n\t{\n\t\ttok = pdf_lex(ctx, doc->file, buf);\n\t\tif (tok != PDF_TOK_TRAILER)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"expected trailer marker\");\n\n\t\ttok = pdf_lex(ctx, doc->file, buf);\n\t\tif (tok != PDF_TOK_OPEN_DICT)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"expected trailer dictionary\");\n\n\t\ttrailer = pdf_parse_dict(ctx, doc, doc->file, buf);\n\n\t\tsize = pdf_to_int(ctx, pdf_dict_get(ctx, trailer, PDF_NAME_Size));\n\t\tif (!size)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"trailer missing Size entry\");\n\t}\n\tfz_always(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, trailer);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow(ctx);\n\t}\n\n\tfz_seek(ctx, doc->file, ofs, SEEK_SET);\n\n\treturn size;\n}\n",
        "output": "0",
        "index": 16731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {\n    xmlParserInputPtr input;\n    xmlBufferPtr buf;\n    int l, c;\n    int count = 0;\n\n    if ((ctxt == NULL) || (entity == NULL) ||\n        ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||\n\t(entity->content != NULL)) {\n\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t            \"xmlLoadEntityContent parameter error\");\n        return(-1);\n    }\n\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Reading %s entity content input\\n\", entity->name);\n\n    buf = xmlBufferCreate();\n    if (buf == NULL) {\n\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t            \"xmlLoadEntityContent parameter error\");\n        return(-1);\n    }\n\n    input = xmlNewEntityInputStream(ctxt, entity);\n    if (input == NULL) {\n\txmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n\t            \"xmlLoadEntityContent input error\");\n\txmlBufferFree(buf);\n        return(-1);\n    }\n\n    /*\n     * Push the entity as the current input, read char by char\n     * saving to the buffer until the end of the entity or an error\n     */\n    if (xmlPushInput(ctxt, input) < 0) {\n        xmlBufferFree(buf);\n\treturn(-1);\n    }\n\n    GROW;\n    c = CUR_CHAR(l);\n    while ((ctxt->input == input) && (ctxt->input->cur < ctxt->input->end) &&\n           (IS_CHAR(c))) {\n        xmlBufferAdd(buf, ctxt->input->cur, l);\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF) {\n                xmlBufferFree(buf);\n                return(-1);\n            }\n\t}\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF) {\n                xmlBufferFree(buf);\n                return(-1);\n            }\n\t    c = CUR_CHAR(l);\n\t}\n    }\n\n    if ((ctxt->input == input) && (ctxt->input->cur >= ctxt->input->end)) {\n        xmlPopInput(ctxt);\n    } else if (!IS_CHAR(c)) {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n                          \"xmlLoadEntityContent: invalid char value %d\\n\",\n\t                  c);\n\txmlBufferFree(buf);\n\treturn(-1);\n    }\n    entity->content = buf->content;\n    buf->content = NULL;\n    xmlBufferFree(buf);\n\n    return(0);\n}\n",
        "output": "0",
        "index": 59445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool venc_dev::venc_use_buf(void *buf_addr, unsigned port,unsigned index)\n{\n\n struct pmem *pmem_tmp;\n struct v4l2_buffer buf;\n struct v4l2_plane plane[VIDEO_MAX_PLANES];\n int rc = 0;\n unsigned int extra_idx;\n\n    pmem_tmp = (struct pmem *)buf_addr;\n    DEBUG_PRINT_LOW(\"venc_use_buf:: pmem_tmp = %p\", pmem_tmp);\n\n if (port == PORT_INDEX_IN) {\n        buf.index = index;\n        buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n        buf.memory = V4L2_MEMORY_USERPTR;\n        plane[0].length = pmem_tmp->size;\n        plane[0].m.userptr = (unsigned long)pmem_tmp->buffer;\n        plane[0].reserved[0] = pmem_tmp->fd;\n        plane[0].reserved[1] = 0;\n        plane[0].data_offset = pmem_tmp->offset;\n        buf.m.planes = plane;\n        buf.length = 1;\n\n        rc = ioctl(m_nDriver_fd, VIDIOC_PREPARE_BUF, &buf);\n\n if (rc)\n            DEBUG_PRINT_LOW(\"VIDIOC_PREPARE_BUF Failed\");\n } else if (port == PORT_INDEX_OUT) {\n        extra_idx = EXTRADATA_IDX(num_planes);\n\n if ((num_planes > 1) && (extra_idx)) {\n            rc = allocate_extradata();\n\n if (rc)\n                DEBUG_PRINT_ERROR(\"Failed to allocate extradata: %d\", rc);\n }\n\n        buf.index = index;\n        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n        buf.memory = V4L2_MEMORY_USERPTR;\n        plane[0].length = pmem_tmp->size;\n        plane[0].m.userptr = (unsigned long)pmem_tmp->buffer;\n        plane[0].reserved[0] = pmem_tmp->fd;\n        plane[0].reserved[1] = 0;\n        plane[0].data_offset = pmem_tmp->offset;\n        buf.m.planes = plane;\n        buf.length = num_planes;\n\n if (extra_idx && (extra_idx < VIDEO_MAX_PLANES)) {\n            plane[extra_idx].length = extradata_info.buffer_size;\n            plane[extra_idx].m.userptr = (unsigned long) (extradata_info.uaddr + index * extradata_info.buffer_size);\n#ifdef USE_ION\n            plane[extra_idx].reserved[0] = extradata_info.ion.fd_ion_data.fd;\n#endif\n            plane[extra_idx].reserved[1] = extradata_info.buffer_size * index;\n            plane[extra_idx].data_offset = 0;\n } else if (extra_idx >= VIDEO_MAX_PLANES) {\n            DEBUG_PRINT_ERROR(\"Extradata index is more than allowed: %d\", extra_idx);\n return OMX_ErrorBadParameter;\n }\n\n        rc = ioctl(m_nDriver_fd, VIDIOC_PREPARE_BUF, &buf);\n\n if (rc)\n            DEBUG_PRINT_LOW(\"VIDIOC_PREPARE_BUF Failed\");\n } else {\n        DEBUG_PRINT_ERROR(\"ERROR: venc_use_buf:Invalid Port Index \");\n return false;\n }\n\n return true;\n}\n",
        "output": "0",
        "index": 172491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_openssl_is_private_key(EVP_PKEY* pkey)\n{\n\tassert(pkey != NULL);\n\n\tswitch (EVP_PKEY_id(pkey)) {\n#ifndef NO_RSA\n\t\tcase EVP_PKEY_RSA:\n\t\tcase EVP_PKEY_RSA2:\n\t\t\t{\n\t\t\t\tRSA *rsa = EVP_PKEY_get0_RSA(pkey);\n\t\t\t\tif (rsa != NULL) {\n\t\t\t\t\tconst BIGNUM *p, *q;\n\n\t\t\t\t\tRSA_get0_factors(rsa, &p, &q);\n\t\t\t\t\t if (p == NULL || q == NULL) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t }\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifndef NO_DSA\n\t\tcase EVP_PKEY_DSA:\n\t\tcase EVP_PKEY_DSA1:\n\t\tcase EVP_PKEY_DSA2:\n\t\tcase EVP_PKEY_DSA3:\n\t\tcase EVP_PKEY_DSA4:\n\t\t\t{\n\t\t\t\tDSA *dsa = EVP_PKEY_get0_DSA(pkey);\n\t\t\t\tif (dsa != NULL) {\n\t\t\t\t\tconst BIGNUM *p, *q, *g, *pub_key, *priv_key;\n\n\t\t\t\t\tDSA_get0_pqg(dsa, &p, &q, &g);\n\t\t\t\t\tif (p == NULL || q == NULL) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tDSA_get0_key(dsa, &pub_key, &priv_key);\n\t\t\t\t\tif (priv_key == NULL) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifndef NO_DH\n\t\tcase EVP_PKEY_DH:\n\t\t\t{\n\t\t\t\tDH *dh = EVP_PKEY_get0_DH(pkey);\n\t\t\t\tif (dh != NULL) {\n\t\t\t\t\tconst BIGNUM *p, *q, *g, *pub_key, *priv_key;\n\n\t\t\t\t\tDH_get0_pqg(dh, &p, &q, &g);\n\t\t\t\t\tif (p == NULL) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tDH_get0_key(dh, &pub_key, &priv_key);\n\t\t\t\t\tif (priv_key == NULL) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef HAVE_EVP_PKEY_EC\n\t\tcase EVP_PKEY_EC:\n\t\t\t{\n\t\t\t\tEC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);\n\t\t\t\tif (ec != NULL && NULL == EC_KEY_get0_private_key(ec)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tphp_error_docref(NULL, E_WARNING, \"key type not supported in this PHP build!\");\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n",
        "output": "0",
        "index": 4562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::recalcStyle(StyleRecalcChange change)\n{\n    RELEASE_ASSERT(!view() || !view()->isPainting());\n\n    if (!renderer() || !view())\n        return;\n\n    if (m_inStyleRecalc)\n        return;\n\n    TRACE_EVENT0(\"webkit\", \"Document::recalcStyle\");\n    TRACE_EVENT_SCOPED_SAMPLING_STATE(\"Blink\", \"RecalcStyle\");\n\n    updateDistributionIfNeeded();\n\n    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(this);\n\n    if (m_evaluateMediaQueriesOnStyleRecalc) {\n        m_evaluateMediaQueriesOnStyleRecalc = false;\n        evaluateMediaQueryList();\n    }\n\n\n    if (m_styleEngine->needsUpdateActiveStylesheetsOnStyleRecalc())\n        m_styleEngine->updateActiveStyleSheets(FullStyleUpdate);\n\n    if (m_elemSheet && m_elemSheet->contents()->usesRemUnits())\n        m_styleEngine->setUsesRemUnit(true);\n\n    {\n        PostAttachCallbacks::SuspendScope suspendPostAttachCallbacks;\n        RenderWidget::UpdateSuspendScope suspendWidgetHierarchyUpdates;\n        FrameView::DeferredRepaintScope deferRepaints(*view());\n        TemporaryChange<bool> changeInStyleRecalc(m_inStyleRecalc, true);\n\n        if (styleChangeType() >= SubtreeStyleChange)\n            change = Force;\n\n        if (change == Force || (change >= Inherit && shouldDisplaySeamlesslyWithParent())) {\n            m_hasNodesWithPlaceholderStyle = false;\n            RefPtr<RenderStyle> documentStyle = StyleResolver::styleForDocument(*this, m_styleResolver ? m_styleResolver->fontSelector() : 0);\n            StyleRecalcChange localChange = RenderStyle::compare(documentStyle.get(), renderer()->style());\n            if (localChange != NoChange)\n                renderer()->setStyle(documentStyle.release());\n        }\n\n        inheritHtmlAndBodyElementStyles(change);\n\n        if (Element* documentElement = this->documentElement()) {\n            if (shouldRecalcStyle(change, documentElement))\n                documentElement->recalcStyle(change);\n        }\n\n        view()->updateCompositingLayersAfterStyleChange();\n\n        clearNeedsStyleRecalc();\n        clearChildNeedsStyleRecalc();\n        unscheduleStyleRecalc();\n\n        if (m_styleEngine->needsUpdateActiveStylesheetsOnStyleRecalc())\n            setNeedsStyleRecalc();\n\n        if (m_styleResolver) {\n            m_styleEngine->resetCSSFeatureFlags(m_styleResolver->ruleFeatureSet());\n            m_styleResolver->clearStyleSharingList();\n        }\n    }\n\n    STYLE_STATS_PRINT();\n    STYLE_STATS_CLEAR();\n\n    InspectorInstrumentation::didRecalculateStyle(cookie);\n\n    if (hoverNode() && !hoverNode()->renderer() && frame())\n        frame()->eventHandler()->dispatchFakeMouseMoveEventSoon();\n}\n",
        "output": "0",
        "index": 109774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parserInit(XML_Parser parser, const XML_Char *encodingName)\n{\n  parser->m_processor = prologInitProcessor;\n  XmlPrologStateInit(&parser->m_prologState);\n  if (encodingName != NULL) {\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n  }\n  parser->m_curBase = NULL;\n  XmlInitEncoding(&parser->m_initEncoding, &parser->m_encoding, 0);\n  parser->m_userData = NULL;\n  parser->m_handlerArg = NULL;\n  parser->m_startElementHandler = NULL;\n  parser->m_endElementHandler = NULL;\n  parser->m_characterDataHandler = NULL;\n  parser->m_processingInstructionHandler = NULL;\n  parser->m_commentHandler = NULL;\n  parser->m_startCdataSectionHandler = NULL;\n  parser->m_endCdataSectionHandler = NULL;\n  parser->m_defaultHandler = NULL;\n  parser->m_startDoctypeDeclHandler = NULL;\n  parser->m_endDoctypeDeclHandler = NULL;\n  parser->m_unparsedEntityDeclHandler = NULL;\n  parser->m_notationDeclHandler = NULL;\n  parser->m_startNamespaceDeclHandler = NULL;\n  parser->m_endNamespaceDeclHandler = NULL;\n  parser->m_notStandaloneHandler = NULL;\n  parser->m_externalEntityRefHandler = NULL;\n  parser->m_externalEntityRefHandlerArg = parser;\n  parser->m_skippedEntityHandler = NULL;\n  parser->m_elementDeclHandler = NULL;\n  parser->m_attlistDeclHandler = NULL;\n  parser->m_entityDeclHandler = NULL;\n  parser->m_xmlDeclHandler = NULL;\n  parser->m_bufferPtr = parser->m_buffer;\n  parser->m_bufferEnd = parser->m_buffer;\n  parser->m_parseEndByteIndex = 0;\n  parser->m_parseEndPtr = NULL;\n  parser->m_declElementType = NULL;\n  parser->m_declAttributeId = NULL;\n  parser->m_declEntity = NULL;\n  parser->m_doctypeName = NULL;\n  parser->m_doctypeSysid = NULL;\n  parser->m_doctypePubid = NULL;\n  parser->m_declAttributeType = NULL;\n  parser->m_declNotationName = NULL;\n  parser->m_declNotationPublicId = NULL;\n  parser->m_declAttributeIsCdata = XML_FALSE;\n  parser->m_declAttributeIsId = XML_FALSE;\n  memset(&parser->m_position, 0, sizeof(POSITION));\n  parser->m_errorCode = XML_ERROR_NONE;\n  parser->m_eventPtr = NULL;\n  parser->m_eventEndPtr = NULL;\n  parser->m_positionPtr = NULL;\n  parser->m_openInternalEntities = NULL;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n  parser->m_tagLevel = 0;\n  parser->m_tagStack = NULL;\n  parser->m_inheritedBindings = NULL;\n  parser->m_nSpecifiedAtts = 0;\n  parser->m_unknownEncodingMem = NULL;\n  parser->m_unknownEncodingRelease = NULL;\n  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n}\n",
        "output": "0",
        "index": 92351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t punch_start, punch_stop;\n\thandle_t *handle;\n\tunsigned int credits;\n\tloff_t new_size, ioffset;\n\tint ret;\n\n\t/*\n\t * We need to test this early because xfstests assumes that a\n\t * collapse range of (0, 1) will return EOPNOTSUPP if the file\n\t * system does not support collapse range.\n\t */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range works only on fs block size aligned offsets. */\n\tif (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||\n\t    len & (EXT4_CLUSTER_SIZE(sb) - 1))\n\t\treturn -EINVAL;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\ttrace_ext4_collapse_range(inode, offset, len);\n\n\tpunch_start = offset >> EXT4_BLOCK_SIZE_BITS(sb);\n\tpunch_stop = (offset + len) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* Call ext4_force_commit to flush all data in case of data=journal. */\n\tif (ext4_should_journal_data(inode)) {\n\t\tret = ext4_force_commit(inode->i_sb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * Need to round down offset to be aligned with page size boundary\n\t * for page size > block size.\n\t */\n\tioffset = round_down(offset, PAGE_SIZE);\n\n\t/* Write out all dirty pages */\n\tret = filemap_write_and_wait_range(inode->i_mapping, ioffset,\n\t\t\t\t\t   LLONG_MAX);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Take mutex lock */\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * There is no need to overlap collapse range with EOF, in which case\n\t * it is effectively a truncate operation\n\t */\n\tif (offset + len >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n \t\tgoto out_mutex;\n \t}\n \n\ttruncate_pagecache(inode, ioffset);\n \t/* Wait for existing dio to complete */\n \text4_inode_block_unlocked_dio(inode);\n \tinode_dio_wait(inode);\n \n \tcredits = ext4_writepage_trans_blocks(inode);\n \thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n \tif (IS_ERR(handle)) {\n \t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n \t}\n \n \tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, punch_start,\n\t\t\t\t    EXT_MAX_BLOCKS - punch_start);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tret = ext4_ext_remove_space(inode, punch_start, punch_stop - 1);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\text4_discard_preallocations(inode);\n\n\tret = ext4_ext_shift_extents(inode, handle, punch_stop,\n\t\t\t\t     punch_stop - punch_start, SHIFT_LEFT);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tnew_size = i_size_read(inode) - len;\n\ti_size_write(inode, new_size);\n\tEXT4_I(inode)->i_disksize = new_size;\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n \n out_stop:\n \text4_journal_stop(handle);\nout_dio:\n \text4_inode_resume_unlocked_dio(inode);\n out_mutex:\n \tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}\n",
        "output": "1",
        "index": 180655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n {\n \tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\n\t/* A stream associated with a memory buffer is always opened\n\tfor both reading and writing in binary mode. */\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\n\t/* Since the stream data is already resident in memory, buffering\n\tis not necessary. */\n\t/* But... It still may be faster to use buffering anyways. */\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\n\t/* Select the operations for a memory stream. */\n\tstream->ops_ = &jas_stream_memops;\n\n\t/* Allocate memory for the underlying memory stream object. */\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\n\t/* Initialize a few important members of the memory stream object. */\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\n\t/* If the buffer size specified is nonpositive, then the buffer\n\tis allocated internally and automatically grown as needed. */\n\tif (bufsize <= 0) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = (unsigned char *) buf;\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\n\tif (bufsize > 0 && buf) {\n\t\t/* If a buffer was supplied by the caller and its length is positive,\n\t\t  make the associated buffer data appear in the stream initially. */\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\t/* The stream is initially empty. */\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\t\n \treturn stream;\n }\n",
        "output": "0",
        "index": 73127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofputil_pull_queue_get_config_reply10(struct ofpbuf *msg,\n                                      struct ofputil_queue_config *queue)\n{\n    const struct ofp_header *oh = msg->header;\n    unsigned int opq_len;       /* Length of protocol-specific queue header. */\n    unsigned int len;           /* Total length of queue + properties. */\n\n    /* Obtain the port number from the message header. */\n    if (oh->version == OFP10_VERSION) {\n        const struct ofp10_queue_get_config_reply *oqgcr10 = msg->msg;\n        queue->port = u16_to_ofp(ntohs(oqgcr10->port));\n    } else {\n        const struct ofp11_queue_get_config_reply *oqgcr11 = msg->msg;\n        enum ofperr error = ofputil_port_from_ofp11(oqgcr11->port,\n                                                    &queue->port);\n        if (error) {\n            return error;\n        }\n    }\n\n    /* Pull off the queue header and get the queue number and length. */\n    if (oh->version < OFP12_VERSION) {\n        const struct ofp10_packet_queue *opq10;\n        opq10 = ofpbuf_try_pull(msg, sizeof *opq10);\n        if (!opq10) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        queue->queue = ntohl(opq10->queue_id);\n        len = ntohs(opq10->len);\n        opq_len = sizeof *opq10;\n    } else {\n        const struct ofp12_packet_queue *opq12;\n        opq12 = ofpbuf_try_pull(msg, sizeof *opq12);\n        if (!opq12) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n        queue->queue = ntohl(opq12->queue_id);\n        len = ntohs(opq12->len);\n        opq_len = sizeof *opq12;\n    }\n\n    /* Length check. */\n    if (len < opq_len || len > msg->size + opq_len || len % 8) {\n        return OFPERR_OFPBRC_BAD_LEN;\n    }\n    len -= opq_len;\n\n    /* Pull properties.  The format of these properties differs from used in\n     * OF1.4+ so we can't use the common property functions. */\n    while (len > 0) {\n        const struct ofp10_queue_prop_header *hdr;\n        unsigned int property;\n        unsigned int prop_len;\n        enum ofperr error = 0;\n\n        hdr = ofpbuf_at_assert(msg, 0, sizeof *hdr);\n        prop_len = ntohs(hdr->len);\n        if (prop_len < sizeof *hdr || prop_len > len || prop_len % 8) {\n            return OFPERR_OFPBRC_BAD_LEN;\n        }\n\n        property = ntohs(hdr->property);\n        switch (property) {\n        case OFPQT10_MIN_RATE:\n            error = parse_ofp10_queue_rate(hdr, &queue->min_rate);\n            break;\n\n        case OFPQT11_MAX_RATE:\n            error = parse_ofp10_queue_rate(hdr, &queue->max_rate);\n            break;\n\n        default:\n            VLOG_INFO_RL(&bad_ofmsg_rl, \"unknown queue property %u\", property);\n            break;\n        }\n        if (error) {\n            return error;\n        }\n\n        ofpbuf_pull(msg, prop_len);\n        len -= prop_len;\n    }\n    return 0;\n}\n",
        "output": "0",
        "index": 77683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gx_device_finalize(const gs_memory_t *cmem, void *vptr)\n{\n    gx_device * const dev = (gx_device *)vptr;\n    (void)cmem; /* unused */\n\n    if (dev->icc_struct != NULL) {\n        rc_decrement(dev->icc_struct, \"gx_device_finalize(icc_profile)\");\n    }\n    if (dev->finalize)\n        dev->finalize(dev);\n\n    /* Deal with subclassed devices. Ordinarily these should not be a problem, we\n     * will never see them, but if ths is a end of job restore we can end up\n     * with the 'child' device(s) being freed before their parents. We need to make\n     * sure we don't leave any dangling pointers in that case.\n     */\n    if (dev->child)\n        dev->child->parent = dev->parent;\n    if (dev->parent)\n        dev->parent->child = dev->child;\n    if (dev->PageList) {\n        rc_decrement(dev->PageList, \"gx_device_finalize(PageList)\");\n        dev->PageList = 0;\n    }\n\n    discard(gs_closedevice(dev));\n    if (dev->stype_is_dynamic)\n        gs_free_const_object(dev->memory->non_gc_memory, dev->stype,\n                             \"gx_device_finalize\");\n\n#ifdef DEBUG\n    /* Slightly ugly hack: because the garbage collector makes no promises\n     * about the order objects can be garbage collected, it is possible for\n     * a forwarding device to remain in existence (awaiting garbage collection\n     * itself) after it's target marked as free memory by the garbage collector.\n     * In such a case, the normal reference counting is fine (since the garbage\n     * collector leaves the object contents alone until is has completed its\n     * sweep), but the reference counting debugging attempts to access the\n     * memory header to output type information - and the header has been\n     * overwritten by the garbage collector, causing a crash.\n     * Setting the rc memory to NULL here should be safe, since the memory\n     * is now in the hands of the garbage collector, and means we can check in\n     * debugging code to ensure we don't try to use values that not longer exist\n     * in the memmory header.\n     * In the non-gc case, finalize is the very last thing to happen before the\n     * memory is actually freed, so the rc.memory pointer is moot.\n     * See rc_object_type_name()\n     */\n    if (gs_debug_c('^'))\n        dev->rc.memory = NULL;\n#endif\n}\n",
        "output": "0",
        "index": 2805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MODRET set_timeoutsession(cmd_rec *cmd) {\n  int timeout = 0, precedence = 0;\n  config_rec *c = NULL;\n\n  int ctxt = (cmd->config && cmd->config->config_type != CONF_PARAM ?\n     cmd->config->config_type : cmd->server->config_type ?\n     cmd->server->config_type : CONF_ROOT);\n\n  /* this directive must have either 1 or 3 arguments */\n  if (cmd->argc-1 != 1 && cmd->argc-1 != 3)\n    CONF_ERROR(cmd, \"missing arguments\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* Set the precedence for this config_rec based on its configuration\n   * context.\n   */\n  if (ctxt & CONF_GLOBAL) {\n    precedence = 1;\n\n  /* These will never appear simultaneously */\n  } else if ((ctxt & CONF_ROOT) ||\n             (ctxt & CONF_VIRTUAL)) {\n    precedence = 2;\n\n  } else if (ctxt & CONF_ANON) {\n    precedence = 3;\n  }\n\n  if (pr_str_get_duration(cmd->argv[1], &timeout) < 0) {\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"error parsing timeout value '\",\n      cmd->argv[1], \"': \", strerror(errno), NULL));\n  }\n\n  if (timeout == 0) {\n    /* do nothing */\n    return PR_HANDLED(cmd);\n  }\n\n  if (cmd->argc-1 == 3) {\n    if (strncmp(cmd->argv[2], \"user\", 5) == 0 ||\n        strncmp(cmd->argv[2], \"group\", 6) == 0 ||\n        strncmp(cmd->argv[2], \"class\", 6) == 0) {\n\n       /* no op */\n\n     } else {\n       CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],\n         \": unknown classifier used: '\", cmd->argv[2], \"'\", NULL));\n    }\n  }\n\n  if (cmd->argc-1 == 1) {\n    c = add_config_param(cmd->argv[0], 2, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(int));\n    *((int *) c->argv[0]) = timeout;\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = precedence;\n\n  } else if (cmd->argc-1 == 3) {\n    array_header *acl = NULL;\n    int argc = cmd->argc - 3;\n    char **argv = cmd->argv + 2;\n\n    acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n    c = add_config_param(cmd->argv[0], 0);\n    c->argc = argc + 2;\n\n    /* add 3 to argc for the argv of the config_rec: one for the\n     * seconds value, one for the precedence, one for the classifier,\n     * and one for the terminating NULL\n     */\n    c->argv = pcalloc(c->pool, ((argc + 4) * sizeof(char *)));\n\n    /* capture the config_rec's argv pointer for doing the by-hand\n     * population\n     */\n    argv = (char **) c->argv;\n\n    /* Copy in the seconds. */\n    *argv = pcalloc(c->pool, sizeof(int));\n    *((int *) *argv++) = timeout;\n\n    /* Copy in the precedence. */\n    *argv = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) *argv++) = precedence;\n\n    /* Copy in the classifier. */\n    *argv++ = pstrdup(c->pool, cmd->argv[2]);\n\n    /* now, copy in the expression arguments */\n    if (argc && acl) {\n      while (argc--) {\n        *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n        acl->elts = ((char **) acl->elts) + 1;\n      }\n    }\n\n    /* don't forget the terminating NULL */\n    *argv = NULL;\n\n  } else {\n    /* Should never reach here. */\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n  }\n\n  c->flags |= CF_MERGEDOWN_MULTI;\n  return PR_HANDLED(cmd);\n}\n",
        "output": "0",
        "index": 95413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __inet_hash_connect(struct inet_timewait_death_row *death_row,\n\t\tstruct sock *sk, u32 port_offset,\n\t\tint (*check_established)(struct inet_timewait_death_row *,\n\t\t\tstruct sock *, __u16, struct inet_timewait_sock **),\n\t\tint (*hash)(struct sock *sk, struct inet_timewait_sock *twp))\n{\n\tstruct inet_hashinfo *hinfo = death_row->hashinfo;\n\tconst unsigned short snum = inet_sk(sk)->inet_num;\n\tstruct inet_bind_hashbucket *head;\n\tstruct inet_bind_bucket *tb;\n\tint ret;\n\tstruct net *net = sock_net(sk);\n\tint twrefcnt = 1;\n\n\tif (!snum) {\n\t\tint i, remaining, low, high, port;\n\t\tstatic u32 hint;\n\t\tu32 offset = hint + port_offset;\n\t\tstruct hlist_node *node;\n\t\tstruct inet_timewait_sock *tw = NULL;\n\n\t\tinet_get_local_port_range(&low, &high);\n\t\tremaining = (high - low) + 1;\n\n\t\tlocal_bh_disable();\n\t\tfor (i = 1; i <= remaining; i++) {\n\t\t\tport = low + (i + offset) % remaining;\n\t\t\tif (inet_is_reserved_local_port(port))\n\t\t\t\tcontinue;\n\t\t\thead = &hinfo->bhash[inet_bhashfn(net, port,\n\t\t\t\t\thinfo->bhash_size)];\n\t\t\tspin_lock(&head->lock);\n\n\t\t\t/* Does not bother with rcv_saddr checks,\n\t\t\t * because the established check is already\n\t\t\t * unique enough.\n\t\t\t */\n\t\t\tinet_bind_bucket_for_each(tb, node, &head->chain) {\n\t\t\t\tif (net_eq(ib_net(tb), net) &&\n\t\t\t\t    tb->port == port) {\n\t\t\t\t\tif (tb->fastreuse >= 0)\n\t\t\t\t\t\tgoto next_port;\n\t\t\t\t\tWARN_ON(hlist_empty(&tb->owners));\n\t\t\t\t\tif (!check_established(death_row, sk,\n\t\t\t\t\t\t\t\tport, &tw))\n\t\t\t\t\t\tgoto ok;\n\t\t\t\t\tgoto next_port;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttb = inet_bind_bucket_create(hinfo->bind_bucket_cachep,\n\t\t\t\t\tnet, head, port);\n\t\t\tif (!tb) {\n\t\t\t\tspin_unlock(&head->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttb->fastreuse = -1;\n\t\t\tgoto ok;\n\n\t\tnext_port:\n\t\t\tspin_unlock(&head->lock);\n\t\t}\n\t\tlocal_bh_enable();\n\n\t\treturn -EADDRNOTAVAIL;\n\nok:\n\t\thint += i;\n\n\t\t/* Head lock still held and bh's disabled */\n\t\tinet_bind_hash(sk, tb, port);\n\t\tif (sk_unhashed(sk)) {\n\t\t\tinet_sk(sk)->inet_sport = htons(port);\n\t\t\ttwrefcnt += hash(sk, tw);\n\t\t}\n\t\tif (tw)\n\t\t\ttwrefcnt += inet_twsk_bind_unhash(tw, hinfo);\n\t\tspin_unlock(&head->lock);\n\n\t\tif (tw) {\n\t\t\tinet_twsk_deschedule(tw, death_row);\n\t\t\twhile (twrefcnt) {\n\t\t\t\ttwrefcnt--;\n\t\t\t\tinet_twsk_put(tw);\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\thead = &hinfo->bhash[inet_bhashfn(net, snum, hinfo->bhash_size)];\n\ttb  = inet_csk(sk)->icsk_bind_hash;\n\tspin_lock_bh(&head->lock);\n\tif (sk_head(&tb->owners) == sk && !sk->sk_bind_node.next) {\n\t\thash(sk, NULL);\n\t\tspin_unlock_bh(&head->lock);\n\t\treturn 0;\n\t} else {\n\t\tspin_unlock(&head->lock);\n\t\t/* No definite answer... Walk to established hash table */\n\t\tret = check_established(death_row, sk, snum, NULL);\nout:\n\t\tlocal_bh_enable();\n\t\treturn ret;\n\t}\n}\n",
        "output": "0",
        "index": 25065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_recvmsg(struct socket *sock, struct msghdr *m, size_t buf_len,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tipc_sock *tsk = tipc_sk(sk);\n\tstruct sk_buff *buf;\n\tstruct tipc_msg *msg;\n\tlong timeo;\n\tunsigned int sz;\n\tu32 err;\n\tint res, hlen;\n\n\t/* Catch invalid receive requests */\n\tif (unlikely(!buf_len))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (unlikely(sock->state == SS_UNCONNECTED)) {\n\t\tres = -ENOTCONN;\n\t\tgoto exit;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\nrestart:\n\n\t/* Look for a message in receive queue; wait if necessary */\n\tres = tipc_wait_for_rcvmsg(sock, &timeo);\n\tif (res)\n\t\tgoto exit;\n\n\t/* Look at first message in receive queue */\n\tbuf = skb_peek(&sk->sk_receive_queue);\n\tmsg = buf_msg(buf);\n\tsz = msg_data_sz(msg);\n\thlen = msg_hdr_sz(msg);\n\terr = msg_errcode(msg);\n\n\t/* Discard an empty non-errored message & try again */\n\tif ((!sz) && (!err)) {\n\t\ttsk_advance_rx_queue(sk);\n\t\tgoto restart;\n\t}\n\n\t/* Capture sender's address (optional) */\n\tset_orig_addr(m, msg);\n\n\t/* Capture ancillary data (optional) */\n\tres = tipc_sk_anc_data_recv(m, msg, tsk);\n\tif (res)\n\t\tgoto exit;\n\n\t/* Capture message data (if valid) & compute return value (always) */\n\tif (!err) {\n\t\tif (unlikely(buf_len < sz)) {\n\t\t\tsz = buf_len;\n\t\t\tm->msg_flags |= MSG_TRUNC;\n\t\t}\n\t\tres = skb_copy_datagram_msg(buf, hlen, m, sz);\n\t\tif (res)\n\t\t\tgoto exit;\n\t\tres = sz;\n\t} else {\n\t\tif ((sock->state == SS_READY) ||\n\t\t    ((err == TIPC_CONN_SHUTDOWN) || m->msg_control))\n\t\t\tres = 0;\n\t\telse\n\t\t\tres = -ECONNRESET;\n\t}\n\n\tif (unlikely(flags & MSG_PEEK))\n\t\tgoto exit;\n\n\tif (likely(sock->state != SS_READY)) {\n\t\ttsk->rcv_unacked += tsk_inc(tsk, hlen + sz);\n\t\tif (unlikely(tsk->rcv_unacked >= (tsk->rcv_win / 4)))\n\t\t\ttipc_sk_send_ack(tsk);\n\t}\n\ttsk_advance_rx_queue(sk);\nexit:\n\trelease_sock(sk);\n\treturn res;\n}\n",
        "output": "0",
        "index": 52487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tsize_t t2p_write_pdf_name(unsigned char* name, TIFF* output){\n\n\ttsize_t written=0;\n\tuint32 i=0;\n\tchar buffer[64];\n\tuint16 nextchar=0;\n\tsize_t namelen=0;\n\t\n\tnamelen = strlen((char *)name);\n\tif (namelen>126) {\n\t\tnamelen=126;\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"/\", 1);\n\tfor (i=0;i<namelen;i++){\n\t\tif ( ((unsigned char)name[i]) < 0x21){\n\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\tnextchar=1;\n\t\t}\n\t\tif ( ((unsigned char)name[i]) > 0x7E){\n\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\tnextchar=1;\n\t\t}\n\t\tif (nextchar==0){\n\t\t\tswitch (name[i]){\n\t\t\t\tcase 0x23:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x25:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x28:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x29:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2F:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x3C:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x3E:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x5B:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x5D:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x7B:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x7D:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) &name[i], 1);\n\t\t\t}\n\t\t}\n\t\tnextchar=0;\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\n\treturn(written);\n}\n",
        "output": "0",
        "index": 48373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Document::DispatchBeforeUnloadEvent(ChromeClient* chrome_client,\n                                         bool is_reload,\n                                         bool& did_allow_navigation) {\n  if (!dom_window_)\n    return true;\n\n  if (!body())\n    return true;\n\n  if (ProcessingBeforeUnload())\n    return false;\n\n  BeforeUnloadEvent& before_unload_event = *BeforeUnloadEvent::Create();\n  before_unload_event.initEvent(event_type_names::kBeforeunload, false, true);\n  load_event_progress_ = kBeforeUnloadEventInProgress;\n  const TimeTicks beforeunload_event_start = CurrentTimeTicks();\n  dom_window_->DispatchEvent(before_unload_event, this);\n  const TimeTicks beforeunload_event_end = CurrentTimeTicks();\n  load_event_progress_ = kBeforeUnloadEventCompleted;\n  DEFINE_STATIC_LOCAL(\n      CustomCountHistogram, beforeunload_histogram,\n      (\"DocumentEventTiming.BeforeUnloadDuration\", 0, 10000000, 50));\n  beforeunload_histogram.CountMicroseconds(beforeunload_event_end -\n                                           beforeunload_event_start);\n  if (!before_unload_event.defaultPrevented())\n    DefaultEventHandler(before_unload_event);\n\n  enum BeforeUnloadDialogHistogramEnum {\n    kNoDialogNoText,\n    kNoDialogNoUserGesture,\n    kNoDialogMultipleConfirmationForNavigation,\n    kShowDialog,\n    kNoDialogAutoCancelTrue,\n    kDialogEnumMax\n  };\n  DEFINE_STATIC_LOCAL(EnumerationHistogram, beforeunload_dialog_histogram,\n                      (\"Document.BeforeUnloadDialog\", kDialogEnumMax));\n  if (before_unload_event.returnValue().IsNull()) {\n    beforeunload_dialog_histogram.Count(kNoDialogNoText);\n  }\n  if (!GetFrame() || before_unload_event.returnValue().IsNull())\n    return true;\n\n  if (!GetFrame()->HasBeenActivated()) {\n    beforeunload_dialog_histogram.Count(kNoDialogNoUserGesture);\n    String message =\n        \"Blocked attempt to show a 'beforeunload' confirmation panel for a \"\n        \"frame that never had a user gesture since its load. \"\n        \"https://www.chromestatus.com/feature/5082396709879808\";\n    Intervention::GenerateReport(frame_, \"BeforeUnloadNoGesture\", message);\n    return true;\n  }\n\n  if (did_allow_navigation) {\n    beforeunload_dialog_histogram.Count(\n        kNoDialogMultipleConfirmationForNavigation);\n    String message =\n        \"Blocked attempt to show multiple 'beforeunload' confirmation panels \"\n        \"for a single navigation.\";\n    Intervention::GenerateReport(frame_, \"BeforeUnloadMultiple\", message);\n    return true;\n  }\n\n  if (!chrome_client) {\n    beforeunload_dialog_histogram.Count(kNoDialogAutoCancelTrue);\n    did_allow_navigation = false;\n    return false;\n  }\n\n  String text = before_unload_event.returnValue();\n  beforeunload_dialog_histogram.Count(\n      BeforeUnloadDialogHistogramEnum::kShowDialog);\n  const TimeTicks beforeunload_confirmpanel_start = CurrentTimeTicks();\n  did_allow_navigation =\n      chrome_client->OpenBeforeUnloadConfirmPanel(text, frame_, is_reload);\n  const TimeTicks beforeunload_confirmpanel_end = CurrentTimeTicks();\n  if (did_allow_navigation) {\n    UMA_HISTOGRAM_MEDIUM_TIMES(\n        \"DocumentEventTiming.BeforeUnloadDialogDuration.ByNavigation\",\n        beforeunload_confirmpanel_end - beforeunload_confirmpanel_start);\n    return true;\n  }\n\n  return false;\n}\n",
        "output": "0",
        "index": 141030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n \t\t\t\tgoto trunc;\n \t\t\t}\n \t\t\t/* units of 4 secs */\n \t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n \t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n \t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "output": "1",
        "index": 181040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_getfattr(struct xdr_stream *xdr, struct nfs_fattr *fattr, const struct nfs_server *server)\n{\n\t__be32 *savep;\n\tuint32_t attrlen,\n\t\t bitmap[2] = {0},\n\t\t type;\n\tint status, fmode = 0;\n\tuint64_t fileid;\n\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\n\tfattr->bitmap[0] = bitmap[0];\n\tfattr->bitmap[1] = bitmap[1];\n\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\n\n\tif ((status = decode_attr_type(xdr, bitmap, &type)) != 0)\n\t\tgoto xdr_error;\n\tfattr->type = nfs_type2fmt[type].nfs2type;\n\tfmode = nfs_type2fmt[type].mode;\n\n\tif ((status = decode_attr_change(xdr, bitmap, &fattr->change_attr)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_size(xdr, bitmap, &fattr->size)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fsid(xdr, bitmap, &fattr->fsid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fileid(xdr, bitmap, &fattr->fileid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fs_locations(xdr, bitmap, container_of(fattr,\n\t\t\t\t\t\tstruct nfs4_fs_locations,\n\t\t\t\t\t\tfattr))) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_mode(xdr, bitmap, &fattr->mode)) != 0)\n\t\tgoto xdr_error;\n\tfattr->mode |= fmode;\n\tif ((status = decode_attr_nlink(xdr, bitmap, &fattr->nlink)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_owner(xdr, bitmap, server->nfs_client, &fattr->uid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_group(xdr, bitmap, server->nfs_client, &fattr->gid)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_rdev(xdr, bitmap, &fattr->rdev)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_space_used(xdr, bitmap, &fattr->du.nfs3.used)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_access(xdr, bitmap, &fattr->atime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_metadata(xdr, bitmap, &fattr->ctime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_time_modify(xdr, bitmap, &fattr->mtime)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_mounted_on_fileid(xdr, bitmap, &fileid)) != 0)\n\t\tgoto xdr_error;\n\tif (fattr->fileid == 0 && fileid != 0)\n\t\tfattr->fileid = fileid;\n\tif ((status = verify_attr_len(xdr, savep, attrlen)) == 0)\n\t\tfattr->valid = NFS_ATTR_FATTR | NFS_ATTR_FATTR_V3 | NFS_ATTR_FATTR_V4;\nxdr_error:\n\tdprintk(\"%s: xdr returned %d\\n\", __func__, -status);\n\treturn status;\n}\n",
        "output": "0",
        "index": 23019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool vfs_init_custom(connection_struct *conn, const char *vfs_object)\n{\n\tchar *module_path = NULL;\n\tchar *module_name = NULL;\n\tchar *module_param = NULL, *p;\n\tvfs_handle_struct *handle;\n\tconst struct vfs_init_function_entry *entry;\n\n\tif (!conn||!vfs_object||!vfs_object[0]) {\n\t\tDEBUG(0, (\"vfs_init_custom() called with NULL pointer or \"\n\t\t\t  \"empty vfs_object!\\n\"));\n\t\treturn False;\n\t}\n\n\tif(!backends) {\n\t\tstatic_init_vfs;\n\t}\n\n\tDEBUG(3, (\"Initialising custom vfs hooks from [%s]\\n\", vfs_object));\n\n\tmodule_path = smb_xstrdup(vfs_object);\n\n\tp = strchr_m(module_path, ':');\n\n\tif (p) {\n\t\t*p = 0;\n\t\tmodule_param = p+1;\n\t\ttrim_char(module_param, ' ', ' ');\n\t}\n\n\ttrim_char(module_path, ' ', ' ');\n\n\tmodule_name = smb_xstrdup(module_path);\n\n\tif ((module_name[0] == '/') &&\n\t    (strcmp(module_path, DEFAULT_VFS_MODULE_NAME) != 0)) {\n\n\t\t/*\n\t\t * Extract the module name from the path. Just use the base\n\t\t * name of the last path component.\n\t\t */\n\n\t\tSAFE_FREE(module_name);\n\t\tmodule_name = smb_xstrdup(strrchr_m(module_path, '/')+1);\n\n\t\tp = strchr_m(module_name, '.');\n\n\t\tif (p != NULL) {\n\t\t\t*p = '\\0';\n\t\t}\n\t}\n\n\t/* First, try to load the module with the new module system */\n\tentry = vfs_find_backend_entry(module_name);\n\tif (!entry) {\n\t\tNTSTATUS status;\n\n\t\tDEBUG(5, (\"vfs module [%s] not loaded - trying to load...\\n\",\n\t\t\t  vfs_object));\n\n\t\tstatus = smb_load_module(\"vfs\", module_path);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\tDEBUG(0, (\"error probing vfs module '%s': %s\\n\",\n\t\t\t\t  module_path, nt_errstr(status)));\n\t\t\tgoto fail;\n\t\t}\n\n\t\tentry = vfs_find_backend_entry(module_name);\n\t\tif (!entry) {\n\t\t\tDEBUG(0,(\"Can't find a vfs module [%s]\\n\",vfs_object));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tDEBUGADD(5,(\"Successfully loaded vfs module [%s] with the new modules system\\n\", vfs_object));\n\n\thandle = talloc_zero(conn, vfs_handle_struct);\n\tif (!handle) {\n\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\tgoto fail;\n\t}\n\thandle->conn = conn;\n\thandle->fns = entry->fns;\n\tif (module_param) {\n\t\thandle->param = talloc_strdup(conn, module_param);\n\t}\n\tDLIST_ADD(conn->vfs_handles, handle);\n\n\tSAFE_FREE(module_path);\n\tSAFE_FREE(module_name);\n\treturn True;\n\n fail:\n\tSAFE_FREE(module_path);\n\tSAFE_FREE(module_name);\n\treturn False;\n}\n",
        "output": "0",
        "index": 2666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern \"C\" int EffectRelease(effect_handle_t handle){\n    ALOGV(\"\\n\\tEffectRelease start %p\", handle);\n EffectContext * pContext = (EffectContext *)handle;\n\n    ALOGV(\"\\tEffectRelease start handle: %p, context %p\", handle, pContext->pBundledContext);\n if (pContext == NULL){\n        ALOGV(\"\\tLVM_ERROR : EffectRelease called with NULL pointer\");\n return -EINVAL;\n }\n\n SessionContext *pSessionContext = &GlobalSessionMemory[pContext->pBundledContext->SessionNo];\n\n if(pContext->EffectType == LVM_BASS_BOOST) {\n        ALOGV(\"\\tEffectRelease LVM_BASS_BOOST Clearing global intstantiated flag\");\n        pSessionContext->bBassInstantiated = LVM_FALSE;\n if(pContext->pBundledContext->SamplesToExitCountBb > 0){\n            pContext->pBundledContext->NumberEffectsEnabled--;\n }\n        pContext->pBundledContext->SamplesToExitCountBb = 0;\n } else if(pContext->EffectType == LVM_VIRTUALIZER) {\n        ALOGV(\"\\tEffectRelease LVM_VIRTUALIZER Clearing global intstantiated flag\");\n        pSessionContext->bVirtualizerInstantiated = LVM_FALSE;\n if(pContext->pBundledContext->SamplesToExitCountVirt > 0){\n            pContext->pBundledContext->NumberEffectsEnabled--;\n }\n        pContext->pBundledContext->SamplesToExitCountVirt = 0;\n } else if(pContext->EffectType == LVM_EQUALIZER) {\n        ALOGV(\"\\tEffectRelease LVM_EQUALIZER Clearing global intstantiated flag\");\n        pSessionContext->bEqualizerInstantiated =LVM_FALSE;\n if(pContext->pBundledContext->SamplesToExitCountEq > 0){\n            pContext->pBundledContext->NumberEffectsEnabled--;\n }\n        pContext->pBundledContext->SamplesToExitCountEq = 0;\n } else if(pContext->EffectType == LVM_VOLUME) {\n        ALOGV(\"\\tEffectRelease LVM_VOLUME Clearing global intstantiated flag\");\n        pSessionContext->bVolumeInstantiated = LVM_FALSE;\n if (pContext->pBundledContext->bVolumeEnabled == LVM_TRUE){\n            pContext->pBundledContext->NumberEffectsEnabled--;\n }\n } else {\n        ALOGV(\"\\tLVM_ERROR : EffectRelease : Unsupported effect\\n\\n\\n\\n\\n\\n\\n\");\n }\n\n Effect_setEnabled(pContext, LVM_FALSE);\n\n if ((pSessionContext->bBassInstantiated == LVM_FALSE) &&\n (pSessionContext->bVolumeInstantiated == LVM_FALSE) &&\n (pSessionContext->bEqualizerInstantiated ==LVM_FALSE) &&\n (pSessionContext->bVirtualizerInstantiated==LVM_FALSE))\n {\n #ifdef LVM_PCM\n if (pContext->pBundledContext->PcmInPtr != NULL) {\n            fclose(pContext->pBundledContext->PcmInPtr);\n            pContext->pBundledContext->PcmInPtr = NULL;\n }\n if (pContext->pBundledContext->PcmOutPtr != NULL) {\n            fclose(pContext->pBundledContext->PcmOutPtr);\n            pContext->pBundledContext->PcmOutPtr = NULL;\n }\n #endif\n\n\n for(int i=0; i<LVM_MAX_SESSIONS; i++){\n if(SessionIndex[i] == pContext->pBundledContext->SessionId){\n SessionIndex[i] = LVM_UNUSED_SESSION;\n                ALOGV(\"\\tEffectRelease: Clearing SessionIndex SessionNo %d for SessionId %d\\n\",\n                        i, pContext->pBundledContext->SessionId);\n break;\n }\n }\n\n        ALOGV(\"\\tEffectRelease: All effects are no longer instantiated\\n\");\n        pSessionContext->bBundledEffectsEnabled = LVM_FALSE;\n        pSessionContext->pBundledContext = LVM_NULL;\n        ALOGV(\"\\tEffectRelease: Freeing LVM Bundle memory\\n\");\n LvmEffect_free(pContext);\n        ALOGV(\"\\tEffectRelease: Deleting LVM Bundle context %p\\n\", pContext->pBundledContext);\n if (pContext->pBundledContext->workBuffer != NULL) {\n            free(pContext->pBundledContext->workBuffer);\n }\n delete pContext->pBundledContext;\n        pContext->pBundledContext = LVM_NULL;\n }\n delete pContext;\n\n    ALOGV(\"\\tEffectRelease end\\n\");\n return 0;\n\n} /* end EffectRelease */\n",
        "output": "0",
        "index": 170557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long flags;\n\tint cpu = get_cpu();\n\n\t__sched_fork(clone_flags, p);\n\t/*\n\t * We mark the process as running here. This guarantees that\n\t * nobody will actually run it, and a signal or other external\n\t * event cannot wake it up and insert it on the runqueue either.\n\t */\n\tp->state = TASK_RUNNING;\n\n\t/*\n\t * Make sure we do not leak PI boosting priority to the child.\n\t */\n\tp->prio = current->normal_prio;\n\n\t/*\n\t * Revert to default priority/policy on fork if requested.\n\t */\n\tif (unlikely(p->sched_reset_on_fork)) {\n\t\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\t\tp->policy = SCHED_NORMAL;\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\t\t\tp->rt_priority = 0;\n\t\t} else if (PRIO_TO_NICE(p->static_prio) < 0)\n\t\t\tp->static_prio = NICE_TO_PRIO(0);\n\n\t\tp->prio = p->normal_prio = __normal_prio(p);\n\t\tset_load_weight(p);\n\n\t\t/*\n\t\t * We don't need the reset flag anymore after the fork. It has\n\t\t * fulfilled its duty:\n\t\t */\n\t\tp->sched_reset_on_fork = 0;\n\t}\n\n\tif (dl_prio(p->prio)) {\n\t\tput_cpu();\n\t\treturn -EAGAIN;\n\t} else if (rt_prio(p->prio)) {\n\t\tp->sched_class = &rt_sched_class;\n\t} else {\n\t\tp->sched_class = &fair_sched_class;\n\t}\n\n\tif (p->sched_class->task_fork)\n\t\tp->sched_class->task_fork(p);\n\n\t/*\n\t * The child is not yet in the pid-hash so no cgroup attach races,\n\t * and the cgroup is pinned to this child due to cgroup_fork()\n\t * is ran before sched_fork().\n\t *\n\t * Silence PROVE_RCU.\n\t */\n\traw_spin_lock_irqsave(&p->pi_lock, flags);\n\tset_task_cpu(p, cpu);\n\traw_spin_unlock_irqrestore(&p->pi_lock, flags);\n\n#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)\n\tif (likely(sched_info_on()))\n\t\tmemset(&p->sched_info, 0, sizeof(p->sched_info));\n#endif\n#if defined(CONFIG_SMP)\n\tp->on_cpu = 0;\n#endif\n\tinit_task_preempt_count(p);\n#ifdef CONFIG_SMP\n\tplist_node_init(&p->pushable_tasks, MAX_PRIO);\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n#endif\n\n\tput_cpu();\n\treturn 0;\n}\n",
        "output": "0",
        "index": 58199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_config_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\t__le16 mode;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tif ((data->wbuffer = kzalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->maxwritelen = 2048;\n\tdata->on_close = proc_config_on_close;\n\n\treadConfigRid(ai, 1);\n\n\tmode = ai->config.opmode & MODE_CFG_MASK;\n\ti = sprintf( data->rbuffer,\n\t\t     \"Mode: %s\\n\"\n\t\t     \"Radio: %s\\n\"\n\t\t     \"NodeName: %-16s\\n\"\n\t\t     \"PowerMode: %s\\n\"\n\t\t     \"DataRates: %d %d %d %d %d %d %d %d\\n\"\n\t\t     \"Channel: %d\\n\"\n\t\t     \"XmitPower: %d\\n\",\n\t\t     mode == MODE_STA_IBSS ? \"adhoc\" :\n\t\t     mode == MODE_STA_ESS ? get_rmode(ai->config.rmode):\n\t\t     mode == MODE_AP ? \"AP\" :\n\t\t     mode == MODE_AP_RPTR ? \"AP RPTR\" : \"Error\",\n\t\t     test_bit(FLAG_RADIO_OFF, &ai->flags) ? \"off\" : \"on\",\n\t\t     ai->config.nodeName,\n\t\t     ai->config.powerSaveMode == POWERSAVE_CAM ? \"CAM\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSP ? \"PSP\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSPCAM ? \"PSPCAM\" :\n\t\t     \"Error\",\n\t\t     (int)ai->config.rates[0],\n\t\t     (int)ai->config.rates[1],\n\t\t     (int)ai->config.rates[2],\n\t\t     (int)ai->config.rates[3],\n\t\t     (int)ai->config.rates[4],\n\t\t     (int)ai->config.rates[5],\n\t\t     (int)ai->config.rates[6],\n\t\t     (int)ai->config.rates[7],\n\t\t     le16_to_cpu(ai->config.channelSet),\n\t\t     le16_to_cpu(ai->config.txPower)\n\t\t);\n\tsprintf( data->rbuffer + i,\n\t\t \"LongRetryLimit: %d\\n\"\n\t\t \"ShortRetryLimit: %d\\n\"\n\t\t \"RTSThreshold: %d\\n\"\n\t\t \"TXMSDULifetime: %d\\n\"\n\t\t \"RXMSDULifetime: %d\\n\"\n\t\t \"TXDiversity: %s\\n\"\n\t\t \"RXDiversity: %s\\n\"\n\t\t \"FragThreshold: %d\\n\"\n\t\t \"WEP: %s\\n\"\n\t\t \"Modulation: %s\\n\"\n\t\t \"Preamble: %s\\n\",\n\t\t le16_to_cpu(ai->config.longRetryLimit),\n\t\t le16_to_cpu(ai->config.shortRetryLimit),\n\t\t le16_to_cpu(ai->config.rtsThres),\n\t\t le16_to_cpu(ai->config.txLifetime),\n\t\t le16_to_cpu(ai->config.rxLifetime),\n\t\t ai->config.txDiversity == 1 ? \"left\" :\n\t\t ai->config.txDiversity == 2 ? \"right\" : \"both\",\n\t\t ai->config.rxDiversity == 1 ? \"left\" :\n\t\t ai->config.rxDiversity == 2 ? \"right\" : \"both\",\n\t\t le16_to_cpu(ai->config.fragThresh),\n\t\t ai->config.authType == AUTH_ENCRYPT ? \"encrypt\" :\n\t\t ai->config.authType == AUTH_SHAREDKEY ? \"shared\" : \"open\",\n\t\t ai->config.modulation == MOD_DEFAULT ? \"default\" :\n\t\t ai->config.modulation == MOD_CCK ? \"cck\" :\n\t\t ai->config.modulation == MOD_MOK ? \"mok\" : \"error\",\n\t\t ai->config.preamble == PREAMBLE_AUTO ? \"auto\" :\n\t\t ai->config.preamble == PREAMBLE_LONG ? \"long\" :\n\t\t ai->config.preamble == PREAMBLE_SHORT ? \"short\" : \"error\"\n\t\t);\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n",
        "output": "0",
        "index": 24057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __sk_mem_schedule(struct sock *sk, int size, int kind)\n{\n\tstruct proto *prot = sk->sk_prot;\n\tint amt = sk_mem_pages(size);\n\tlong allocated;\n\n\tsk->sk_forward_alloc += amt * SK_MEM_QUANTUM;\n\n\tallocated = sk_memory_allocated_add(sk, amt);\n\n\tif (mem_cgroup_sockets_enabled && sk->sk_memcg &&\n\t    !mem_cgroup_charge_skmem(sk->sk_memcg, amt))\n\t\tgoto suppress_allocation;\n\n\t/* Under limit. */\n\tif (allocated <= sk_prot_mem_limits(sk, 0)) {\n\t\tsk_leave_memory_pressure(sk);\n\t\treturn 1;\n\t}\n\n\t/* Under pressure. */\n\tif (allocated > sk_prot_mem_limits(sk, 1))\n\t\tsk_enter_memory_pressure(sk);\n\n\t/* Over hard limit. */\n\tif (allocated > sk_prot_mem_limits(sk, 2))\n\t\tgoto suppress_allocation;\n\n\t/* guarantee minimum buffer size under pressure */\n\tif (kind == SK_MEM_RECV) {\n\t\tif (atomic_read(&sk->sk_rmem_alloc) < prot->sysctl_rmem[0])\n\t\t\treturn 1;\n\n\t} else { /* SK_MEM_SEND */\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tif (sk->sk_wmem_queued < prot->sysctl_wmem[0])\n\t\t\t\treturn 1;\n\t\t} else if (atomic_read(&sk->sk_wmem_alloc) <\n\t\t\t   prot->sysctl_wmem[0])\n\t\t\t\treturn 1;\n\t}\n\n\tif (sk_has_memory_pressure(sk)) {\n\t\tint alloc;\n\n\t\tif (!sk_under_memory_pressure(sk))\n\t\t\treturn 1;\n\t\talloc = sk_sockets_allocated_read_positive(sk);\n\t\tif (sk_prot_mem_limits(sk, 2) > alloc *\n\t\t    sk_mem_pages(sk->sk_wmem_queued +\n\t\t\t\t atomic_read(&sk->sk_rmem_alloc) +\n\t\t\t\t sk->sk_forward_alloc))\n\t\t\treturn 1;\n\t}\n\nsuppress_allocation:\n\n\tif (kind == SK_MEM_SEND && sk->sk_type == SOCK_STREAM) {\n\t\tsk_stream_moderate_sndbuf(sk);\n\n\t\t/* Fail only if socket is _under_ its sndbuf.\n\t\t * In this case we cannot block, so that we have to fail.\n\t\t */\n\t\tif (sk->sk_wmem_queued + size >= sk->sk_sndbuf)\n\t\t\treturn 1;\n\t}\n\n\ttrace_sock_exceed_buf_limit(sk, prot, allocated);\n\n\t/* Alas. Undo changes. */\n\tsk->sk_forward_alloc -= amt * SK_MEM_QUANTUM;\n\n\tsk_memory_allocated_sub(sk, amt);\n\n\tif (mem_cgroup_sockets_enabled && sk->sk_memcg)\n\t\tmem_cgroup_uncharge_skmem(sk->sk_memcg, amt);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 47856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\n{\n    BIGNUM *kinv = NULL;\n    BIGNUM *m, *blind, *blindm, *tmp;\n    BN_CTX *ctx = NULL;\n    int reason = ERR_R_BN_LIB;\n    DSA_SIG *ret = NULL;\n    int rv = 0;\n\n    if (dsa->p == NULL || dsa->q == NULL || dsa->g == NULL) {\n        reason = DSA_R_MISSING_PARAMETERS;\n        goto err;\n    }\n\n    ret = DSA_SIG_new();\n    if (ret == NULL)\n        goto err;\n    ret->r = BN_new();\n    ret->s = BN_new();\n    if (ret->r == NULL || ret->s == NULL)\n        goto err;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    m = BN_CTX_get(ctx);\n    blind = BN_CTX_get(ctx);\n    blindm = BN_CTX_get(ctx);\n    tmp = BN_CTX_get(ctx);\n    if (tmp == NULL)\n        goto err;\n\n redo:\n    if (!dsa_sign_setup(dsa, ctx, &kinv, &ret->r, dgst, dlen))\n        goto err;\n\n    if (dlen > BN_num_bytes(dsa->q))\n        /*\n         * if the digest length is greater than the size of q use the\n         * BN_num_bits(dsa->q) leftmost bits of the digest, see fips 186-3,\n         * 4.2\n         */\n        dlen = BN_num_bytes(dsa->q);\n    if (BN_bin2bn(dgst, dlen, m) == NULL)\n        goto err;\n\n    /*\n     * The normal signature calculation is:\n     *\n     *   s := k^-1 * (m + r * priv_key) mod q\n     *\n     * We will blind this to protect against side channel attacks\n     *\n     *   s := blind^-1 * k^-1 * (blind * m + blind * r * priv_key) mod q\n     */\n\n    /* Generate a blinding value */\n    do {\n        if (!BN_rand(blind, BN_num_bits(dsa->q) - 1, BN_RAND_TOP_ANY,\n                     BN_RAND_BOTTOM_ANY))\n            goto err;\n    } while (BN_is_zero(blind));\n    BN_set_flags(blind, BN_FLG_CONSTTIME);\n    BN_set_flags(blindm, BN_FLG_CONSTTIME);\n    BN_set_flags(tmp, BN_FLG_CONSTTIME);\n\n    /* tmp := blind * priv_key * r mod q */\n    if (!BN_mod_mul(tmp, blind, dsa->priv_key, dsa->q, ctx))\n        goto err;\n    if (!BN_mod_mul(tmp, tmp, ret->r, dsa->q, ctx))\n        goto err;\n\n    /* blindm := blind * m mod q */\n    if (!BN_mod_mul(blindm, blind, m, dsa->q, ctx))\n        goto err;\n\n    /* s : = (blind * priv_key * r) + (blind * m) mod q */\n    if (!BN_mod_add_quick(ret->s, tmp, blindm, dsa->q))\n        goto err;\n\n    /* s := s * k^-1 mod q */\n    if (!BN_mod_mul(ret->s, ret->s, kinv, dsa->q, ctx))\n        goto err;\n\n    /* s:= s * blind^-1 mod q */\n    if (BN_mod_inverse(blind, blind, dsa->q, ctx) == NULL)\n        goto err;\n    if (!BN_mod_mul(ret->s, ret->s, blind, dsa->q, ctx))\n        goto err;\n\n    /*\n     * Redo if r or s is zero as required by FIPS 186-3: this is very\n     * unlikely.\n     */\n    if (BN_is_zero(ret->r) || BN_is_zero(ret->s))\n        goto redo;\n\n    rv = 1;\n\n err:\n    if (rv == 0) {\n        DSAerr(DSA_F_DSA_DO_SIGN, reason);\n        DSA_SIG_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_free(ctx);\n    BN_clear_free(kinv);\n    return ret;\n}\n",
        "output": "0",
        "index": 15390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __show_regs(struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tchar buf[64];\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprint_symbol(\"PC is at %s\\n\", instruction_pointer(regs));\n\tprint_symbol(\"LR is at %s\\n\", regs->ARM_lr);\n\tprintk(\"pc : [<%08lx>]    lr : [<%08lx>]    psr: %08lx\\n\"\n\t       \"sp : %08lx  ip : %08lx  fp : %08lx\\n\",\n\t\tregs->ARM_pc, regs->ARM_lr, regs->ARM_cpsr,\n\t\tregs->ARM_sp, regs->ARM_ip, regs->ARM_fp);\n\tprintk(\"r10: %08lx  r9 : %08lx  r8 : %08lx\\n\",\n\t\tregs->ARM_r10, regs->ARM_r9,\n\t\tregs->ARM_r8);\n\tprintk(\"r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\\n\",\n\t\tregs->ARM_r7, regs->ARM_r6,\n\t\tregs->ARM_r5, regs->ARM_r4);\n\tprintk(\"r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\\n\",\n\t\tregs->ARM_r3, regs->ARM_r2,\n\t\tregs->ARM_r1, regs->ARM_r0);\n\n\tflags = regs->ARM_cpsr;\n\tbuf[0] = flags & PSR_N_BIT ? 'N' : 'n';\n\tbuf[1] = flags & PSR_Z_BIT ? 'Z' : 'z';\n\tbuf[2] = flags & PSR_C_BIT ? 'C' : 'c';\n\tbuf[3] = flags & PSR_V_BIT ? 'V' : 'v';\n\tbuf[4] = '\\0';\n\n\tprintk(\"Flags: %s  IRQs o%s  FIQs o%s  Mode %s  ISA %s  Segment %s\\n\",\n\t\tbuf, interrupts_enabled(regs) ? \"n\" : \"ff\",\n\t\tfast_interrupts_enabled(regs) ? \"n\" : \"ff\",\n\t\tprocessor_modes[processor_mode(regs)],\n\t\tisa_modes[isa_mode(regs)],\n\t\tget_fs() == get_ds() ? \"kernel\" : \"user\");\n#ifdef CONFIG_CPU_CP15\n\t{\n\t\tunsigned int ctrl;\n\n\t\tbuf[0] = '\\0';\n#ifdef CONFIG_CPU_CP15_MMU\n\t\t{\n\t\t\tunsigned int transbase, dac;\n\t\t\tasm(\"mrc p15, 0, %0, c2, c0\\n\\t\"\n\t\t\t    \"mrc p15, 0, %1, c3, c0\\n\"\n\t\t\t    : \"=r\" (transbase), \"=r\" (dac));\n\t\t\tsnprintf(buf, sizeof(buf), \"  Table: %08x  DAC: %08x\",\n\t\t\t  \ttransbase, dac);\n\t\t}\n#endif\n\t\tasm(\"mrc p15, 0, %0, c1, c0\\n\" : \"=r\" (ctrl));\n\n\t\tprintk(\"Control: %08x%s\\n\", ctrl, buf);\n\t}\n#endif\n}\n",
        "output": "0",
        "index": 58324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t     struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tunsigned int copied, rlen;\n\tstruct sk_buff *skb, *cskb;\n\tint err = 0;\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\n\t    skb_queue_empty(&sk->sk_receive_queue)) {\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tpr_err(\"Recv datagram failed state %d %d %d\",\n\t\t       sk->sk_state, err, sock_error(sk));\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\trlen = skb->len;\t\t/* real length of skb */\n\tcopied = min_t(unsigned int, rlen, len);\n\n\tcskb = skb;\n\tif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -EFAULT;\n\t}\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\n\t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\n\t\tstruct sockaddr_nfc_llcp *sockaddr =\n\t\t\t(struct sockaddr_nfc_llcp *) msg->msg_name;\n\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\n\n\t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);\n\n\t\tmemset(sockaddr, 0, sizeof(*sockaddr));\n\t\tsockaddr->sa_family = AF_NFC;\n\t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\n\t\tsockaddr->dsap = ui_cb->dsap;\n\t\tsockaddr->ssap = ui_cb->ssap;\n\t}\n\n\t/* Mark read part of skb as used */\n\tif (!(flags & MSG_PEEK)) {\n\n\t\t/* SOCK_STREAM: re-queue skb if it contains unreceived data */\n\t\tif (sk->sk_type == SOCK_STREAM ||\n\t\t    sk->sk_type == SOCK_DGRAM ||\n\t\t    sk->sk_type == SOCK_RAW) {\n\t\t\tskb_pull(skb, copied);\n\t\t\tif (skb->len) {\n\t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* XXX Queue backlogged skbs */\n\ndone:\n\t/* SOCK_SEQPACKET: return real length if MSG_TRUNC is set */\n\tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\n\t\tcopied = rlen;\n\n\treturn copied;\n}\n",
        "output": "1",
        "index": 179681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGLRenderingContextBase::ValidateTexFuncData(\n    const char* function_name,\n    TexImageDimension tex_dimension,\n    GLint level,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLenum format,\n    GLenum type,\n    DOMArrayBufferView* pixels,\n    NullDisposition disposition,\n    GLuint src_offset) {\n  if (!pixels) {\n    DCHECK_NE(disposition, kNullNotReachable);\n    if (disposition == kNullAllowed)\n      return true;\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no pixels\");\n    return false;\n  }\n\n  if (!ValidateSettableTexFormat(function_name, format))\n    return false;\n\n  switch (type) {\n    case GL_BYTE:\n      if (pixels->GetType() != DOMArrayBufferView::kTypeInt8) {\n        SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                          \"type BYTE but ArrayBufferView not Int8Array\");\n        return false;\n      }\n      break;\n    case GL_UNSIGNED_BYTE:\n      if (pixels->GetType() != DOMArrayBufferView::kTypeUint8) {\n        SynthesizeGLError(\n            GL_INVALID_OPERATION, function_name,\n            \"type UNSIGNED_BYTE but ArrayBufferView not Uint8Array\");\n        return false;\n      }\n      break;\n    case GL_SHORT:\n      if (pixels->GetType() != DOMArrayBufferView::kTypeInt16) {\n        SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                          \"type SHORT but ArrayBufferView not Int16Array\");\n        return false;\n      }\n      break;\n    case GL_UNSIGNED_SHORT:\n    case GL_UNSIGNED_SHORT_5_6_5:\n    case GL_UNSIGNED_SHORT_4_4_4_4:\n    case GL_UNSIGNED_SHORT_5_5_5_1:\n      if (pixels->GetType() != DOMArrayBufferView::kTypeUint16) {\n        SynthesizeGLError(\n            GL_INVALID_OPERATION, function_name,\n            \"type UNSIGNED_SHORT but ArrayBufferView not Uint16Array\");\n        return false;\n      }\n      break;\n    case GL_INT:\n      if (pixels->GetType() != DOMArrayBufferView::kTypeInt32) {\n        SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                          \"type INT but ArrayBufferView not Int32Array\");\n        return false;\n      }\n      break;\n    case GL_UNSIGNED_INT:\n    case GL_UNSIGNED_INT_2_10_10_10_REV:\n    case GL_UNSIGNED_INT_10F_11F_11F_REV:\n    case GL_UNSIGNED_INT_5_9_9_9_REV:\n    case GL_UNSIGNED_INT_24_8:\n      if (pixels->GetType() != DOMArrayBufferView::kTypeUint32) {\n        SynthesizeGLError(\n            GL_INVALID_OPERATION, function_name,\n            \"type UNSIGNED_INT but ArrayBufferView not Uint32Array\");\n        return false;\n      }\n      break;\n    case GL_FLOAT:  // OES_texture_float\n      if (pixels->GetType() != DOMArrayBufferView::kTypeFloat32) {\n        SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                          \"type FLOAT but ArrayBufferView not Float32Array\");\n        return false;\n      }\n      break;\n    case GL_HALF_FLOAT:\n    case GL_HALF_FLOAT_OES:  // OES_texture_half_float\n      if (pixels->GetType() != DOMArrayBufferView::kTypeUint16) {\n        SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                          \"type HALF_FLOAT_OES but ArrayBufferView is not NULL \"\n                          \"and not Uint16Array\");\n        return false;\n      }\n      break;\n    case GL_FLOAT_32_UNSIGNED_INT_24_8_REV:\n      SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                        \"type FLOAT_32_UNSIGNED_INT_24_8_REV but \"\n                        \"ArrayBufferView is not NULL\");\n      return false;\n    default:\n      NOTREACHED();\n  }\n\n  unsigned total_bytes_required, skip_bytes;\n  GLenum error = WebGLImageConversion::ComputeImageSizeInBytes(\n      format, type, width, height, depth,\n      GetUnpackPixelStoreParams(tex_dimension), &total_bytes_required, nullptr,\n      &skip_bytes);\n  if (error != GL_NO_ERROR) {\n    SynthesizeGLError(error, function_name, \"invalid texture dimensions\");\n    return false;\n  }\n  CheckedNumeric<uint32_t> total = src_offset;\n  total *= pixels->TypeSize();\n  total += total_bytes_required;\n  total += skip_bytes;\n  if (!total.IsValid() || pixels->byteLength() < total.ValueOrDie()) {\n    SynthesizeGLError(GL_INVALID_OPERATION, function_name,\n                      \"ArrayBufferView not big enough for request\");\n    return false;\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 159324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void UiSceneCreator::CreateWebVrTimeoutScreen() {\n  auto scaler = base::MakeUnique<ScaledDepthAdjuster>(kSpinnerDistance);\n\n  auto timeout_message =\n      Create<Rect>(kWebVrTimeoutMessage, kPhaseOverlayForeground);\n  timeout_message->SetVisible(false);\n  timeout_message->set_bounds_contain_children(true);\n  timeout_message->set_corner_radius(kTimeoutMessageCornerRadiusDMM);\n  timeout_message->SetTransitionedProperties({OPACITY, TRANSFORM});\n  timeout_message->set_padding(kTimeoutMessageHorizontalPaddingDMM,\n                               kTimeoutMessageVerticalPaddingDMM);\n  timeout_message->AddBinding(\n      VR_BIND_FUNC(bool, Model, model_, web_vr_timeout_state == kWebVrTimedOut,\n                   Rect, timeout_message.get(), SetVisible));\n  timeout_message->SetColor(model_->color_scheme().timeout_message_background);\n\n  auto timeout_layout = Create<LinearLayout>(kWebVrTimeoutMessageLayout,\n                                             kPhaseNone, LinearLayout::kRight);\n  timeout_layout->set_hit_testable(false);\n  timeout_layout->set_margin(kTimeoutMessageLayoutGapDMM);\n\n  auto timeout_icon = Create<VectorIcon>(kWebVrTimeoutMessageIcon,\n                                         kPhaseOverlayForeground, 512);\n  timeout_icon->SetIcon(kSadTabIcon);\n  timeout_icon->SetSize(kTimeoutMessageIconWidthDMM,\n                        kTimeoutMessageIconHeightDMM);\n\n  auto timeout_text =\n      Create<Text>(kWebVrTimeoutMessageText, kPhaseOverlayForeground,\n                   kTimeoutMessageTextFontHeightDMM);\n  timeout_text->SetText(\n      l10n_util::GetStringUTF16(IDS_VR_WEB_VR_TIMEOUT_MESSAGE));\n  timeout_text->SetColor(model_->color_scheme().timeout_message_foreground);\n  timeout_text->SetTextAlignment(UiTexture::kTextAlignmentLeft);\n  timeout_text->SetSize(kTimeoutMessageTextWidthDMM,\n                        kTimeoutMessageTextHeightDMM);\n\n  auto button_scaler =\n      base::MakeUnique<ScaledDepthAdjuster>(kTimeoutButtonDepthOffset);\n\n  auto button = Create<DiscButton>(\n      kWebVrTimeoutMessageButton, kPhaseOverlayForeground,\n      base::Bind(&UiBrowserInterface::ExitPresent, base::Unretained(browser_)),\n      vector_icons::kClose16Icon);\n  button->SetVisible(false);\n  button->SetTranslate(0, -kTimeoutMessageTextWidthDMM, 0);\n  button->SetRotate(1, 0, 0, kTimeoutButtonRotationRad);\n  button->SetTransitionedProperties({OPACITY});\n  button->SetSize(kWebVrTimeoutMessageButtonDiameterDMM,\n                  kWebVrTimeoutMessageButtonDiameterDMM);\n  button->AddBinding(VR_BIND_FUNC(bool, Model, model_,\n                                  web_vr_timeout_state == kWebVrTimedOut,\n                                  DiscButton, button.get(), SetVisible));\n  BindButtonColors(model_, button.get(), &ColorScheme::button_colors,\n                   &DiscButton::SetButtonColors);\n\n  auto timeout_button_text =\n      Create<Text>(kWebVrTimeoutMessageButtonText, kPhaseOverlayForeground,\n                   kTimeoutMessageTextFontHeightDMM);\n\n  timeout_button_text->SetText(\n      l10n_util::GetStringUTF16(IDS_VR_WEB_VR_EXIT_BUTTON_LABEL));\n  timeout_button_text->SetColor(model_->color_scheme().spinner_color);\n  timeout_button_text->SetSize(kTimeoutButtonTextWidthDMM,\n                               kTimeoutButtonTextHeightDMM);\n  timeout_button_text->set_y_anchoring(BOTTOM);\n  timeout_button_text->SetTranslate(0, -kTimeoutButtonTextVerticalOffsetDMM, 0);\n\n  button->AddChild(std::move(timeout_button_text));\n  timeout_layout->AddChild(std::move(timeout_icon));\n  timeout_layout->AddChild(std::move(timeout_text));\n  timeout_message->AddChild(std::move(timeout_layout));\n  button_scaler->AddChild(std::move(button));\n  timeout_message->AddChild(std::move(button_scaler));\n  scaler->AddChild(std::move(timeout_message));\n  scene_->AddUiElement(kSplashScreenViewportAwareRoot, std::move(scaler));\n}\n",
        "output": "0",
        "index": 168695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_reclaim_open_state(struct nfs4_state_owner *sp, const struct nfs4_state_recovery_ops *ops)\n{\n\tstruct nfs4_state *state;\n\tstruct nfs4_lock_state *lock;\n\tint status = 0;\n\n\t/* Note: we rely on the sp->so_states list being ordered \n\t * so that we always reclaim open(O_RDWR) and/or open(O_WRITE)\n\t * states first.\n\t * This is needed to ensure that the server won't give us any\n\t * read delegations that we have to return if, say, we are\n\t * recovering after a network partition or a reboot from a\n\t * server that doesn't support a grace period.\n\t */\nrestart:\n\tspin_lock(&sp->so_lock);\n\tlist_for_each_entry(state, &sp->so_states, open_states) {\n\t\tif (!test_and_clear_bit(ops->state_flag_bit, &state->flags))\n\t\t\tcontinue;\n\t\tif (state->state == 0)\n\t\t\tcontinue;\n\t\tatomic_inc(&state->count);\n\t\tspin_unlock(&sp->so_lock);\n\t\tstatus = ops->recover_open(sp, state);\n\t\tif (status >= 0) {\n\t\t\tstatus = nfs4_reclaim_locks(state, ops);\n\t\t\tif (status >= 0) {\n\t\t\t\tlist_for_each_entry(lock, &state->lock_states, ls_locks) {\n\t\t\t\t\tif (!(lock->ls_flags & NFS_LOCK_INITIALIZED))\n\t\t\t\t\t\tprintk(\"%s: Lock reclaim failed!\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\t\t\t}\n\t\t\t\tnfs4_put_open_state(state);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tswitch (status) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"%s: unhandled error %d. Zeroing state\\n\",\n\t\t\t\t\t\t__func__, status);\n\t\t\tcase -ENOENT:\n\t\t\tcase -ESTALE:\n\t\t\t\t/*\n\t\t\t\t * Open state on this file cannot be recovered\n\t\t\t\t * All we can do is revert to using the zero stateid.\n\t\t\t\t */\n\t\t\t\tmemset(state->stateid.data, 0,\n\t\t\t\t\tsizeof(state->stateid.data));\n\t\t\t\t/* Mark the file as being 'closed' */\n\t\t\t\tstate->state = 0;\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_RECLAIM_BAD:\n\t\t\tcase -NFS4ERR_RECLAIM_CONFLICT:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_client, state);\n\t\t\t\tbreak;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tcase -NFS4ERR_NO_GRACE:\n\t\t\t\tnfs4_state_mark_reclaim_nograce(sp->so_client, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tnfs4_put_open_state(state);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&sp->so_lock);\n\treturn 0;\nout_err:\n\tnfs4_put_open_state(state);\n\treturn status;\n}\n",
        "output": "0",
        "index": 22951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\t/*\n\t * Copies from kernel address space cannot fail (NFSD is a big user).\n\t */\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t/* Pagecache index for current page */\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n \n \t\tcond_resched();\n \n \t\tif (unlikely(copied == 0)) {\n \t\t\t/*\n \t\t\t * If we were unable to copy any data at all, we must\n\t\t\t * fall back to a single segment length write.\n\t\t\t *\n\t\t\t * If we didn't fallback here, we could livelock\n\t\t\t * because not all segments in the iov can be copied at\n\t\t\t * once without a pagefault.\n\t\t\t */\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n \t\t\t\t\t\tiov_iter_single_seg_count(i));\n \t\t\tgoto again;\n \t\t}\n\t\tiov_iter_advance(i, copied);\n \t\tpos += copied;\n \t\twritten += copied;\n \n\t\tbalance_dirty_pages_ratelimited(mapping);\n\n\t} while (iov_iter_count(i));\n\n\treturn written ? written : status;\n}\n",
        "output": "1",
        "index": 180790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  if ((MagickSizeType) compact_size > GetBlobSize(image))\n    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n    }\n\n  memset(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n        if (ret == Z_STREAM_END)\n          break;\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n    {\n      p=pixels;\n      while (count > 0)\n      {\n        length=image->columns;\n        while (--length)\n        {\n          if (packet_size == 2)\n            {\n              p[2]+=p[0]+((p[1]+p[3]) >> 8);\n              p[3]+=p[1];\n            }\n          /*\n          else if (packet_size == 4)\n             {\n               TODO: Figure out what to do there.\n             }\n          */\n          else\n            *(p+1)+=*p;\n          p+=packet_size;\n        }\n        p+=packet_size;\n        count-=row_size;\n      }\n    }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}\n",
        "output": "0",
        "index": 91371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void adjustOpenFilesLimit(void) {\n    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;\n    struct rlimit limit;\n\n    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {\n        serverLog(LL_WARNING,\"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.\",\n            strerror(errno));\n        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;\n    } else {\n        rlim_t oldlimit = limit.rlim_cur;\n\n        /* Set the max number of files if the current limit is not enough\n         * for our needs. */\n        if (oldlimit < maxfiles) {\n            rlim_t bestlimit;\n            int setrlimit_error = 0;\n\n            /* Try to set the file limit to match 'maxfiles' or at least\n             * to the higher value supported less than maxfiles. */\n            bestlimit = maxfiles;\n            while(bestlimit > oldlimit) {\n                rlim_t decr_step = 16;\n\n                limit.rlim_cur = bestlimit;\n                limit.rlim_max = bestlimit;\n                if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;\n                setrlimit_error = errno;\n\n                /* We failed to set file limit to 'bestlimit'. Try with a\n                 * smaller limit decrementing by a few FDs per iteration. */\n                if (bestlimit < decr_step) break;\n                bestlimit -= decr_step;\n            }\n\n            /* Assume that the limit we get initially is still valid if\n             * our last try was even lower. */\n            if (bestlimit < oldlimit) bestlimit = oldlimit;\n\n            if (bestlimit < maxfiles) {\n                int old_maxclients = server.maxclients;\n                server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;\n                if (server.maxclients < 1) {\n                    serverLog(LL_WARNING,\"Your current 'ulimit -n' \"\n                        \"of %llu is not enough for the server to start. \"\n                        \"Please increase your open file limit to at least \"\n                        \"%llu. Exiting.\",\n                        (unsigned long long) oldlimit,\n                        (unsigned long long) maxfiles);\n                    exit(1);\n                }\n                serverLog(LL_WARNING,\"You requested maxclients of %d \"\n                    \"requiring at least %llu max file descriptors.\",\n                    old_maxclients,\n                    (unsigned long long) maxfiles);\n                serverLog(LL_WARNING,\"Server can't set maximum open files \"\n                    \"to %llu because of OS error: %s.\",\n                    (unsigned long long) maxfiles, strerror(setrlimit_error));\n                serverLog(LL_WARNING,\"Current maximum open files is %llu. \"\n                    \"maxclients has been reduced to %d to compensate for \"\n                    \"low ulimit. \"\n                    \"If you need higher maxclients increase 'ulimit -n'.\",\n                    (unsigned long long) bestlimit, server.maxclients);\n            } else {\n                serverLog(LL_NOTICE,\"Increased maximum number of open files \"\n                    \"to %llu (it was originally set to %llu).\",\n                    (unsigned long long) maxfiles,\n                    (unsigned long long) oldlimit);\n            }\n        }\n    }\n}\n",
        "output": "0",
        "index": 69995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dtls1_buffer_message(SSL *s, int is_ccs)\n{\n    pitem *item;\n    hm_fragment *frag;\n    unsigned char seq64be[8];\n\n    /*\n     * this function is called immediately after a message has been\n     * serialized\n     */\n    OPENSSL_assert(s->init_off == 0);\n\n    frag = dtls1_hm_fragment_new(s->init_num, 0);\n    if (frag == NULL)\n        return 0;\n\n    memcpy(frag->fragment, s->init_buf->data, s->init_num);\n\n    if (is_ccs) {\n        /* For DTLS1_BAD_VER the header length is non-standard */\n        OPENSSL_assert(s->d1->w_msg_hdr.msg_len +\n                       ((s->version ==\n                         DTLS1_BAD_VER) ? 3 : DTLS1_CCS_HEADER_LENGTH)\n                       == (unsigned int)s->init_num);\n    } else {\n        OPENSSL_assert(s->d1->w_msg_hdr.msg_len +\n                       DTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num);\n    }\n\n    frag->msg_header.msg_len = s->d1->w_msg_hdr.msg_len;\n    frag->msg_header.seq = s->d1->w_msg_hdr.seq;\n    frag->msg_header.type = s->d1->w_msg_hdr.type;\n    frag->msg_header.frag_off = 0;\n    frag->msg_header.frag_len = s->d1->w_msg_hdr.msg_len;\n    frag->msg_header.is_ccs = is_ccs;\n\n    /* save current state */\n    frag->msg_header.saved_retransmit_state.enc_write_ctx = s->enc_write_ctx;\n    frag->msg_header.saved_retransmit_state.write_hash = s->write_hash;\n    frag->msg_header.saved_retransmit_state.compress = s->compress;\n    frag->msg_header.saved_retransmit_state.session = s->session;\n    frag->msg_header.saved_retransmit_state.epoch =\n        DTLS_RECORD_LAYER_get_w_epoch(&s->rlayer);\n\n    memset(seq64be, 0, sizeof(seq64be));\n    seq64be[6] =\n        (unsigned\n         char)(dtls1_get_queue_priority(frag->msg_header.seq,\n                                        frag->msg_header.is_ccs) >> 8);\n    seq64be[7] =\n        (unsigned\n         char)(dtls1_get_queue_priority(frag->msg_header.seq,\n                                        frag->msg_header.is_ccs));\n\n    item = pitem_new(seq64be, frag);\n    if (item == NULL) {\n        dtls1_hm_fragment_free(frag);\n        return 0;\n    }\n\n    pqueue_insert(s->d1->sent_messages, item);\n    return 1;\n}\n",
        "output": "0",
        "index": 9364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ctrl_fill_info(const struct genl_family *family, u32 portid, u32 seq,\n\t\t\t  u32 flags, struct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id) ||\n\t    nla_put_u32(skb, CTRL_ATTR_VERSION, family->version) ||\n\t    nla_put_u32(skb, CTRL_ATTR_HDRSIZE, family->hdrsize) ||\n\t    nla_put_u32(skb, CTRL_ATTR_MAXATTR, family->maxattr))\n\t\tgoto nla_put_failure;\n\n\tif (family->n_ops) {\n\t\tstruct nlattr *nla_ops;\n\t\tint i;\n\n\t\tnla_ops = nla_nest_start(skb, CTRL_ATTR_OPS);\n\t\tif (nla_ops == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_ops; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_ops *ops = &family->ops[i];\n\t\t\tu32 op_flags = ops->flags;\n\n\t\t\tif (ops->dumpit)\n\t\t\t\top_flags |= GENL_CMD_CAP_DUMP;\n\t\t\tif (ops->doit)\n\t\t\t\top_flags |= GENL_CMD_CAP_DO;\n\t\t\tif (ops->policy)\n\t\t\t\top_flags |= GENL_CMD_CAP_HASPOL;\n\n\t\t\tnest = nla_nest_start(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_OP_ID, ops->cmd) ||\n\t\t\t    nla_put_u32(skb, CTRL_ATTR_OP_FLAGS, op_flags))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\n\t\tnla_nest_end(skb, nla_ops);\n\t}\n\n\tif (family->n_mcgrps) {\n\t\tstruct nlattr *nla_grps;\n\t\tint i;\n\n\t\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\t\tif (nla_grps == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < family->n_mcgrps; i++) {\n\t\t\tstruct nlattr *nest;\n\t\t\tconst struct genl_multicast_group *grp;\n\n\t\t\tgrp = &family->mcgrps[i];\n\n\t\t\tnest = nla_nest_start(skb, i + 1);\n\t\t\tif (nest == NULL)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID,\n\t\t\t\t\tfamily->mcgrp_offset + i) ||\n\t\t\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t\t\t   grp->name))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(skb, nest);\n\t\t}\n\t\tnla_nest_end(skb, nla_grps);\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n",
        "output": "0",
        "index": 88032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_METHOD(Phar, setStub)\n{\n\tzval *zstub;\n\tchar *stub, *error;\n\tint stub_len;\n\tlong len = -1;\n\tphp_stream *stream;\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\"Cannot change stub, phar is read-only\");\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_data) {\n\t\tif (phar_obj->arc.archive->is_tar) {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"A Phar stub cannot be set in a plain tar archive\");\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"A Phar stub cannot be set in a plain zip archive\");\n\t\t}\n\t\treturn;\n\t}\n\n\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &zstub, &len) == SUCCESS) {\n\t\tif ((php_stream_from_zval_no_verify(stream, &zstub)) != NULL) {\n\t\t\tif (len > 0) {\n\t\t\t\tlen = -len;\n\t\t\t} else {\n\t\t\t\tlen = -1;\n\t\t\t}\n\t\t\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tphar_flush(phar_obj->arc.archive, (char *) &zstub, len, 0, &error TSRMLS_CC);\n\t\t\tif (error) {\n\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\t\tefree(error);\n\t\t\t}\n\t\t\tRETURN_TRUE;\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,\n\t\t\t\t\"Cannot change stub, unable to read from input stream\");\n\t\t}\n\t} else if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &stub, &stub_len) == SUCCESS) {\n\t\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);\n\t\t\treturn;\n\t\t}\n\t\tphar_flush(phar_obj->arc.archive, stub, stub_len, 0, &error TSRMLS_CC);\n\n\t\tif (error) {\n\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);\n\t\t\tefree(error);\n\t\t}\n\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n",
        "output": "0",
        "index": 4383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool V4L2JpegEncodeAccelerator::EncodedInstanceDmaBuf::SetInputBufferFormat(\n    gfx::Size coded_size,\n    const VideoFrameLayout& input_layout) {\n  DCHECK(parent_->encoder_task_runner_->BelongsToCurrentThread());\n  DCHECK(!input_streamon_);\n  DCHECK(input_job_queue_.empty());\n\n  constexpr uint32_t input_pix_fmt_candidates[] = {V4L2_PIX_FMT_NV12M,\n                                                   V4L2_PIX_FMT_NV12};\n\n  struct v4l2_format format;\n  input_buffer_pixelformat_ = 0;\n  for (const auto input_pix_fmt : input_pix_fmt_candidates) {\n    DCHECK_EQ(V4L2Device::V4L2PixFmtToVideoPixelFormat(input_pix_fmt),\n              PIXEL_FORMAT_NV12);\n    memset(&format, 0, sizeof(format));\n    format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n    format.fmt.pix_mp.num_planes = kMaxNV12Plane;\n    format.fmt.pix_mp.pixelformat = input_pix_fmt;\n    format.fmt.pix_mp.field = V4L2_FIELD_ANY;\n    format.fmt.pix_mp.width = coded_size.width();\n    format.fmt.pix_mp.height = coded_size.height();\n\n    auto num_planes = input_layout.num_planes();\n    for (size_t i = 0; i < num_planes; i++) {\n      format.fmt.pix_mp.plane_fmt[i].sizeimage = input_layout.planes()[i].size;\n      format.fmt.pix_mp.plane_fmt[i].bytesperline =\n          input_layout.planes()[i].stride;\n    }\n\n    if (device_->Ioctl(VIDIOC_S_FMT, &format) == 0 &&\n        format.fmt.pix_mp.pixelformat == input_pix_fmt) {\n      device_input_layout_ = V4L2Device::V4L2FormatToVideoFrameLayout(format);\n\n      input_buffer_pixelformat_ = format.fmt.pix_mp.pixelformat;\n      input_buffer_num_planes_ = format.fmt.pix_mp.num_planes;\n      input_buffer_height_ = format.fmt.pix_mp.height;\n      break;\n    }\n  }\n\n  if (input_buffer_pixelformat_ == 0) {\n    VLOGF(1) << \"Neither NV12 nor NV12M is supported.\";\n    return false;\n  }\n\n  if (format.fmt.pix_mp.width != static_cast<uint32_t>(coded_size.width()) ||\n      format.fmt.pix_mp.height != static_cast<uint32_t>(coded_size.height())) {\n    VLOGF(1) << \"Width \" << coded_size.width() << \"->\"\n             << format.fmt.pix_mp.width << \",Height \" << coded_size.height()\n             << \"->\" << format.fmt.pix_mp.height;\n    return false;\n  }\n  return true;\n}\n",
        "output": "0",
        "index": 148743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::BeginNavigationInternal(\n    std::unique_ptr<blink::WebNavigationInfo> info) {\n  std::unique_ptr<DocumentState> document_state_owned = BuildDocumentState();\n  DocumentState* document_state = document_state_owned.get();\n  if (!frame_->CreatePlaceholderDocumentLoader(\n          *info, std::move(document_state_owned))) {\n    return;\n  }\n\n  browser_side_navigation_pending_ = true;\n  browser_side_navigation_pending_url_ = info->url_request.Url();\n\n  blink::WebURLRequest& request = info->url_request;\n\n  WebDocument frame_document = frame_->GetDocument();\n  if (info->frame_type == network::mojom::RequestContextFrameType::kTopLevel)\n    request.SetSiteForCookies(request.Url());\n  else\n    request.SetSiteForCookies(frame_document.SiteForCookies());\n\n  ui::PageTransition transition_type = GetTransitionType(\n      ui::PAGE_TRANSITION_LINK,\n      info->frame_load_type == WebFrameLoadType::kReplaceCurrentItem,\n      IsMainFrame(), info->navigation_type);\n  if (info->is_client_redirect) {\n    transition_type = ui::PageTransitionFromInt(\n        transition_type | ui::PAGE_TRANSITION_CLIENT_REDIRECT);\n  }\n\n  WillSendRequestInternal(\n      request,\n      frame_->Parent() ? ResourceType::kSubFrame : ResourceType::kMainFrame,\n      document_state, transition_type);\n\n  if (!info->url_request.GetExtraData())\n    info->url_request.SetExtraData(std::make_unique<RequestExtraData>());\n\n  DCHECK_EQ(network::mojom::FetchRequestMode::kNavigate,\n            info->url_request.GetFetchRequestMode());\n  DCHECK_EQ(network::mojom::FetchCredentialsMode::kInclude,\n            info->url_request.GetFetchCredentialsMode());\n  DCHECK_EQ(network::mojom::FetchRedirectMode::kManual,\n            info->url_request.GetFetchRedirectMode());\n  DCHECK(frame_->Parent() ||\n         info->frame_type ==\n             network::mojom::RequestContextFrameType::kTopLevel);\n  DCHECK(!frame_->Parent() ||\n         info->frame_type == network::mojom::RequestContextFrameType::kNested);\n\n  bool is_form_submission =\n      info->navigation_type == blink::kWebNavigationTypeFormSubmitted ||\n      info->navigation_type == blink::kWebNavigationTypeFormResubmitted;\n\n  GURL searchable_form_url;\n  std::string searchable_form_encoding;\n  if (!info->form.IsNull()) {\n    WebSearchableFormData web_searchable_form_data(info->form);\n    searchable_form_url = web_searchable_form_data.Url();\n    searchable_form_encoding = web_searchable_form_data.Encoding().Utf8();\n  }\n\n  GURL client_side_redirect_url;\n  if (info->is_client_redirect)\n    client_side_redirect_url = frame_->GetDocument().Url();\n\n  blink::mojom::BlobURLTokenPtr blob_url_token(\n      CloneBlobURLToken(info->blob_url_token.get()));\n\n  int load_flags = info->url_request.GetLoadFlagsForWebUrlRequest();\n  std::unique_ptr<base::DictionaryValue> initiator =\n      GetDevToolsInitiator(info->devtools_initiator_info);\n  mojom::BeginNavigationParamsPtr begin_navigation_params =\n      mojom::BeginNavigationParams::New(\n          GetWebURLRequestHeadersAsString(info->url_request), load_flags,\n          info->url_request.GetSkipServiceWorker(),\n          GetRequestContextTypeForWebURLRequest(info->url_request),\n          GetMixedContentContextTypeForWebURLRequest(info->url_request),\n          is_form_submission, searchable_form_url, searchable_form_encoding,\n          client_side_redirect_url,\n          initiator ? base::make_optional<base::Value>(std::move(*initiator))\n                    : base::nullopt);\n\n  mojom::NavigationClientAssociatedPtrInfo navigation_client_info;\n  if (IsPerNavigationMojoInterfaceEnabled()) {\n    BindNavigationClient(mojo::MakeRequest(&navigation_client_info));\n    navigation_client_impl_->MarkWasInitiatedInThisFrame();\n  }\n\n  blink::mojom::NavigationInitiatorPtr initiator_ptr(\n      blink::mojom::NavigationInitiatorPtrInfo(\n          std::move(info->navigation_initiator_handle), 0));\n\n  bool current_frame_has_download_sandbox_flag =\n      !frame_->IsAllowedToDownloadWithoutUserActivation();\n  bool has_download_sandbox_flag =\n      info->initiator_frame_has_download_sandbox_flag ||\n      current_frame_has_download_sandbox_flag;\n  bool from_ad = info->initiator_frame_is_ad || frame_->IsAdSubframe();\n\n  GetFrameHost()->BeginNavigation(\n      MakeCommonNavigationParams(frame_->GetSecurityOrigin(), std::move(info),\n                                 load_flags, has_download_sandbox_flag,\n                                 from_ad),\n      std::move(begin_navigation_params), std::move(blob_url_token),\n      std::move(navigation_client_info), std::move(initiator_ptr));\n}\n",
        "output": "0",
        "index": 152192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int FAST_FUNC start_bunzip(bunzip_data **bdp, int in_fd,\n\t\tconst void *inbuf, int len)\n{\n\tbunzip_data *bd;\n\tunsigned i;\n\tenum {\n\t\tBZh0 = ('B' << 24) + ('Z' << 16) + ('h' << 8) + '0',\n\t\th0 = ('h' << 8) + '0',\n\t};\n\n\t/* Figure out how much data to allocate */\n\ti = sizeof(bunzip_data);\n\tif (in_fd != -1) i += IOBUF_SIZE;\n\n\t/* Allocate bunzip_data.  Most fields initialize to zero. */\n\tbd = *bdp = xzalloc(i);\n\n\t/* Setup input buffer */\n\tbd->in_fd = in_fd;\n\tif (-1 == in_fd) {\n\t\t/* in this case, bd->inbuf is read-only */\n\t\tbd->inbuf = (void*)inbuf; /* cast away const-ness */\n\t} else {\n\t\tbd->inbuf = (uint8_t*)(bd + 1);\n\t\tmemcpy(bd->inbuf, inbuf, len);\n\t}\n\tbd->inbufCount = len;\n\n\t/* Init the CRC32 table (big endian) */\n\tcrc32_filltable(bd->crc32Table, 1);\n\n\t/* Setup for I/O error handling via longjmp */\n\ti = setjmp(bd->jmpbuf);\n\tif (i) return i;\n\n\t/* Ensure that file starts with \"BZh['1'-'9'].\" */\n\t/* Update: now caller verifies 1st two bytes, makes .gz/.bz2\n\t * integration easier */\n\t/* was: */\n\t/* i = get_bits(bd, 32); */\n\t/* if ((unsigned)(i - BZh0 - 1) >= 9) return RETVAL_NOT_BZIP_DATA; */\n\ti = get_bits(bd, 16);\n\tif ((unsigned)(i - h0 - 1) >= 9) return RETVAL_NOT_BZIP_DATA;\n\n\t/* Fourth byte (ascii '1'-'9') indicates block size in units of 100k of\n\t   uncompressed data.  Allocate intermediate buffer for block. */\n\t/* bd->dbufSize = 100000 * (i - BZh0); */\n\tbd->dbufSize = 100000 * (i - h0);\n\n\t/* Cannot use xmalloc - may leak bd in NOFORK case! */\n\tbd->dbuf = malloc_or_warn(bd->dbufSize * sizeof(bd->dbuf[0]));\n\tif (!bd->dbuf) {\n\t\tfree(bd);\n\t\txfunc_die();\n\t}\n\treturn RETVAL_OK;\n}\n",
        "output": "0",
        "index": 1788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "figure_mime( httpd_conn* hc )\n    {\n    char* prev_dot;\n    char* dot;\n    char* ext;\n    int me_indexes[100], n_me_indexes;\n    size_t ext_len, encodings_len;\n    int i, top, bot, mid;\n    int r;\n    char* default_type = \"application/octet-stream\";\n\n    /* Peel off encoding extensions until there aren't any more. */\n    n_me_indexes = 0;\n    hc->type = default_type;\n    for ( prev_dot = &hc->expnfilename[strlen(hc->expnfilename)]; ; prev_dot = dot )\n\t{\n\tfor ( dot = prev_dot - 1; dot >= hc->expnfilename && *dot != '.'; --dot )\n\t    ;\n\tif ( dot < hc->expnfilename )\n\t    {\n\t    /* No dot found.  No more extensions.  */\n\t    goto done;\n\t    }\n\text = dot + 1;\n\text_len = prev_dot - ext;\n\t/* Search the encodings table.  Linear search is fine here, there\n\t** are only a few entries.\n\t*/\n\tfor ( i = 0; i < n_enc_tab; ++i )\n\t    {\n\t    if ( ext_len == enc_tab[i].ext_len && strncasecmp( ext, enc_tab[i].ext, ext_len ) == 0 )\n\t\t{\n\t\tif ( n_me_indexes < sizeof(me_indexes)/sizeof(*me_indexes) )\n\t\t    {\n\t\t    me_indexes[n_me_indexes] = i;\n\t\t    ++n_me_indexes;\n\t\t    }\n\t\tbreak;\n\t\t}\n\t    }\n\t/* Binary search for a matching type extension. */\n\ttop = n_typ_tab - 1;\n\tbot = 0;\n\twhile ( top >= bot )\n\t    {\n\t    mid = ( top + bot ) / 2;\n\t    r = strncasecmp( ext, typ_tab[mid].ext, ext_len );\n\t    if ( r < 0 )\n\t\ttop = mid - 1;\n\t    else if ( r > 0 )\n\t\tbot = mid + 1;\n\t    else\n\t\tif ( ext_len < typ_tab[mid].ext_len )\n\t\t    top = mid - 1;\n\t\telse if ( ext_len > typ_tab[mid].ext_len )\n\t\t    bot = mid + 1;\n\t\telse\n\t\t    {\n\t\t    hc->type = typ_tab[mid].val;\n\t\t    goto done;\n\t\t    }\n\t    }\n\t}\n\n    done:\n\n    /* The last thing we do is actually generate the mime-encoding header. */\n    hc->encodings[0] = '\\0';\n    encodings_len = 0;\n    for ( i = n_me_indexes - 1; i >= 0; --i )\n\t{\n\thttpd_realloc_str(\n\t    &hc->encodings, &hc->maxencodings,\n\t    encodings_len + enc_tab[me_indexes[i]].val_len + 1 );\n\tif ( hc->encodings[0] != '\\0' )\n\t    {\n\t    (void) strcpy( &hc->encodings[encodings_len], \",\" );\n\t    ++encodings_len;\n\t    }\n\t(void) strcpy( &hc->encodings[encodings_len], enc_tab[me_indexes[i]].val );\n\tencodings_len += enc_tab[me_indexes[i]].val_len;\n\t}\n\n    }\n",
        "output": "0",
        "index": 63802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n    cmsMLU* mlu;\n    cmsUInt32Number Count, RecLen, NumOfWchar;\n    cmsUInt32Number SizeOfHeader;\n    cmsUInt32Number  Len, Offset;\n    cmsUInt32Number  i;\n    wchar_t*         Block;\n    cmsUInt32Number  BeginOfThisString, EndOfThisString, LargestPosition;\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &Count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &RecLen)) return NULL;\n\n    if (RecLen != 12) {\n\n        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"multiLocalizedUnicodeType of len != 12 is not supported.\");\n        return NULL;\n    }\n\n    mlu = cmsMLUalloc(self ->ContextID, Count);\n    if (mlu == NULL) return NULL;\n\n    mlu ->UsedEntries = Count;\n\n    SizeOfHeader = 12 * Count + sizeof(_cmsTagBase);\n    LargestPosition = 0;\n\n    for (i=0; i < Count; i++) {\n\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Language)) goto Error;\n        if (!_cmsReadUInt16Number(io, &mlu ->Entries[i].Country))  goto Error;\n\n        if (!_cmsReadUInt32Number(io, &Len)) goto Error;\n        if (!_cmsReadUInt32Number(io, &Offset)) goto Error;\n \n         if (Offset < (SizeOfHeader + 8)) goto Error;\n \n         BeginOfThisString = Offset - SizeOfHeader - 8;\n\n        mlu ->Entries[i].Len = (Len * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n        mlu ->Entries[i].StrW = (BeginOfThisString * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n\n        EndOfThisString = BeginOfThisString + Len;\n        if (EndOfThisString > LargestPosition)\n            LargestPosition = EndOfThisString;\n    }\n\n    SizeOfTag   = (LargestPosition * sizeof(wchar_t)) / sizeof(cmsUInt16Number);\n    if (SizeOfTag == 0)\n    {\n        Block = NULL;\n        NumOfWchar = 0;\n\n    }\n    else\n    {\n        Block = (wchar_t*) _cmsMalloc(self ->ContextID, SizeOfTag);\n        if (Block == NULL) goto Error;\n        NumOfWchar = SizeOfTag / sizeof(wchar_t);\n        if (!_cmsReadWCharArray(io, NumOfWchar, Block)) goto Error;\n    }\n\n    mlu ->MemPool  = Block;\n    mlu ->PoolSize = SizeOfTag;\n    mlu ->PoolUsed = SizeOfTag;\n\n    *nItems = 1;\n    return (void*) mlu;\n\nError:\n    if (mlu) cmsMLUfree(mlu);\n    return NULL;\n}\n",
        "output": "1",
        "index": 181684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void  ahci_port_write(AHCIState *s, int port, int offset, uint32_t val)\n{\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n    DPRINTF(port, \"offset: 0x%x val: 0x%x\\n\", offset, val);\n    switch (offset) {\n        case PORT_LST_ADDR:\n            pr->lst_addr = val;\n            map_page(&s->dev[port].lst,\n                     ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n            s->dev[port].cur_cmd = NULL;\n            break;\n        case PORT_LST_ADDR_HI:\n            pr->lst_addr_hi = val;\n            map_page(&s->dev[port].lst,\n                     ((uint64_t)pr->lst_addr_hi << 32) | pr->lst_addr, 1024);\n            s->dev[port].cur_cmd = NULL;\n            break;\n        case PORT_FIS_ADDR:\n            pr->fis_addr = val;\n            map_page(&s->dev[port].res_fis,\n                     ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n            break;\n        case PORT_FIS_ADDR_HI:\n            pr->fis_addr_hi = val;\n            map_page(&s->dev[port].res_fis,\n                     ((uint64_t)pr->fis_addr_hi << 32) | pr->fis_addr, 256);\n            break;\n        case PORT_IRQ_STAT:\n            pr->irq_stat &= ~val;\n            ahci_check_irq(s);\n            break;\n        case PORT_IRQ_MASK:\n            pr->irq_mask = val & 0xfdc000ff;\n            ahci_check_irq(s);\n            break;\n        case PORT_CMD:\n            pr->cmd = val & ~(PORT_CMD_LIST_ON | PORT_CMD_FIS_ON);\n\n            if (pr->cmd & PORT_CMD_START) {\n                pr->cmd |= PORT_CMD_LIST_ON;\n            }\n\n            if (pr->cmd & PORT_CMD_FIS_RX) {\n                pr->cmd |= PORT_CMD_FIS_ON;\n            }\n\n            /* XXX usually the FIS would be pending on the bus here and\n                   issuing deferred until the OS enables FIS receival.\n                   Instead, we only submit it once - which works in most\n                   cases, but is a hack. */\n            if ((pr->cmd & PORT_CMD_FIS_ON) &&\n                !s->dev[port].init_d2h_sent) {\n                ahci_init_d2h(&s->dev[port]);\n                s->dev[port].init_d2h_sent = true;\n            }\n\n            check_cmd(s, port);\n            break;\n        case PORT_TFDATA:\n            s->dev[port].port.ifs[0].error = (val >> 8) & 0xff;\n            s->dev[port].port.ifs[0].status = val & 0xff;\n            break;\n        case PORT_SIG:\n            pr->sig = val;\n            break;\n        case PORT_SCR_STAT:\n            pr->scr_stat = val;\n            break;\n        case PORT_SCR_CTL:\n            if (((pr->scr_ctl & AHCI_SCR_SCTL_DET) == 1) &&\n                ((val & AHCI_SCR_SCTL_DET) == 0)) {\n                ahci_reset_port(s, port);\n            }\n            pr->scr_ctl = val;\n            break;\n        case PORT_SCR_ERR:\n            pr->scr_err &= ~val;\n            break;\n        case PORT_SCR_ACT:\n            /* RW1 */\n            pr->scr_act |= val;\n            break;\n        case PORT_CMD_ISSUE:\n            pr->cmd_issue |= val;\n            check_cmd(s, port);\n            break;\n        default:\n            break;\n    }\n}\n",
        "output": "0",
        "index": 15773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t copy_page_from_iter_iovec(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tsize_t skip, copy, left, wanted;\n\tconst struct iovec *iov;\n\tchar __user *buf;\n\tvoid *kaddr, *to;\n\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\n\twanted = bytes;\n\tiov = i->iov;\n\tskip = i->iov_offset;\n\tbuf = iov->iov_base + skip;\n\tcopy = min(bytes, iov->iov_len - skip);\n\n\tif (IS_ENABLED(CONFIG_HIGHMEM) && !fault_in_pages_readable(buf, copy)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tto = kaddr + offset;\n\n\t\t/* first chunk, usually the only one */\n\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip += copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\n\t\twhile (unlikely(!left && bytes)) {\n\t\t\tiov++;\n\t\t\tbuf = iov->iov_base;\n\t\t\tcopy = min(bytes, iov->iov_len);\n\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\t\tcopy -= left;\n\t\t\tskip = copy;\n\t\t\tto += copy;\n\t\t\tbytes -= copy;\n\t\t}\n\t\tif (likely(!bytes)) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tgoto done;\n\t\t}\n\t\toffset = to - kaddr;\n\t\tbuf += copy;\n\t\tkunmap_atomic(kaddr);\n\t\tcopy = min(bytes, iov->iov_len - skip);\n\t}\n\t/* Too bad - revert to non-atomic kmap */\n\n\tkaddr = kmap(page);\n\tto = kaddr + offset;\n\tleft = __copy_from_user(to, buf, copy);\n\tcopy -= left;\n\tskip += copy;\n\tto += copy;\n\tbytes -= copy;\n\twhile (unlikely(!left && bytes)) {\n\t\tiov++;\n\t\tbuf = iov->iov_base;\n\t\tcopy = min(bytes, iov->iov_len);\n\t\tleft = __copy_from_user(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip = copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t}\n\tkunmap(page);\n\ndone:\n\tif (skip == iov->iov_len) {\n\t\tiov++;\n\t\tskip = 0;\n\t}\n\ti->count -= wanted - bytes;\n\ti->nr_segs -= iov - i->iov;\n\ti->iov = iov;\n\ti->iov_offset = skip;\n\treturn wanted - bytes;\n}\n",
        "output": "0",
        "index": 68721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  T42_Open_Face( T42_Face  face )\n  {\n    T42_LoaderRec  loader;\n    T42_Parser     parser;\n    T1_Font        type1 = &face->type1;\n    FT_Memory      memory = face->root.memory;\n    FT_Error       error;\n\n    PSAux_Service  psaux  = (PSAux_Service)face->psaux;\n\n\n    t42_loader_init( &loader, face );\n\n    parser = &loader.parser;\n\n     if ( FT_ALLOC( face->ttf_data, 12 ) )\n       goto Exit;\n \n     error = t42_parser_init( parser,\n                              face->root.stream,\n                              memory,\n    if ( error )\n      goto Exit;\n\n    if ( type1->font_type != 42 )\n    {\n      FT_ERROR(( \"T42_Open_Face: cannot handle FontType %d\\n\",\n                 type1->font_type ));\n      error = FT_THROW( Unknown_File_Format );\n      goto Exit;\n    }\n\n    /* now, propagate the charstrings and glyphnames tables */\n    /* to the Type1 data                                    */\n    type1->num_glyphs = loader.num_glyphs;\n\n    if ( !loader.charstrings.init )\n    {\n      FT_ERROR(( \"T42_Open_Face: no charstrings array in face\\n\" ));\n      error = FT_THROW( Invalid_File_Format );\n    }\n\n    loader.charstrings.init  = 0;\n    type1->charstrings_block = loader.charstrings.block;\n    type1->charstrings       = loader.charstrings.elements;\n    type1->charstrings_len   = loader.charstrings.lengths;\n\n    /* we copy the glyph names `block' and `elements' fields; */\n    /* the `lengths' field must be released later             */\n    type1->glyph_names_block    = loader.glyph_names.block;\n    type1->glyph_names          = (FT_String**)loader.glyph_names.elements;\n    loader.glyph_names.block    = 0;\n    loader.glyph_names.elements = 0;\n\n    /* we must now build type1.encoding when we have a custom array */\n    if ( type1->encoding_type == T1_ENCODING_TYPE_ARRAY )\n    {\n      FT_Int    charcode, idx, min_char, max_char;\n      FT_Byte*  glyph_name;\n\n\n      /* OK, we do the following: for each element in the encoding   */\n      /* table, look up the index of the glyph having the same name  */\n      /* as defined in the CharStrings array.                        */\n      /* The index is then stored in type1.encoding.char_index, and  */\n      /* the name in type1.encoding.char_name                        */\n\n      min_char = 0;\n      max_char = 0;\n\n      charcode = 0;\n      for ( ; charcode < loader.encoding_table.max_elems; charcode++ )\n      {\n        FT_Byte*  char_name;\n\n\n        type1->encoding.char_index[charcode] = 0;\n        type1->encoding.char_name [charcode] = (char *)\".notdef\";\n\n        char_name = loader.encoding_table.elements[charcode];\n        if ( char_name )\n          for ( idx = 0; idx < type1->num_glyphs; idx++ )\n          {\n            glyph_name = (FT_Byte*)type1->glyph_names[idx];\n            if ( ft_strcmp( (const char*)char_name,\n                            (const char*)glyph_name ) == 0 )\n            {\n              type1->encoding.char_index[charcode] = (FT_UShort)idx;\n              type1->encoding.char_name [charcode] = (char*)glyph_name;\n\n              /* Change min/max encoded char only if glyph name is */\n              /* not /.notdef                                      */\n              if ( ft_strcmp( (const char*)\".notdef\",\n                              (const char*)glyph_name ) != 0 )\n              {\n                if ( charcode < min_char )\n                  min_char = charcode;\n                if ( charcode >= max_char )\n                  max_char = charcode + 1;\n              }\n              break;\n            }\n          }\n      }\n\n      type1->encoding.code_first = min_char;\n      type1->encoding.code_last  = max_char;\n      type1->encoding.num_chars  = loader.num_chars;\n    }\n\n  Exit:\n    t42_loader_done( &loader );\n    return error;\n  }\n",
        "output": "1",
        "index": 178033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vrend_fb_bind_texture(struct vrend_resource *res,\n                           int idx,\n                           uint32_t level, uint32_t layer)\n{\n   const struct util_format_description *desc = util_format_description(res->base.format);\n   GLenum attachment = GL_COLOR_ATTACHMENT0_EXT + idx;\n\n   if (vrend_format_is_ds(res->base.format)) { {\n         if (util_format_has_stencil(desc)) {\n            if (util_format_has_depth(desc))\n               attachment = GL_DEPTH_STENCIL_ATTACHMENT;\n            else\n               attachment = GL_STENCIL_ATTACHMENT;\n         } else\n            attachment = GL_DEPTH_ATTACHMENT;\n      }\n   }\n\n   switch (res->target) {\n   case GL_TEXTURE_1D_ARRAY:\n   case GL_TEXTURE_2D_ARRAY:\n   case GL_TEXTURE_2D_MULTISAMPLE_ARRAY:\n   case GL_TEXTURE_CUBE_MAP_ARRAY:\n      if (layer == 0xffffffff)\n         glFramebufferTexture(GL_FRAMEBUFFER_EXT, attachment,\n                              res->id, level);\n      else\n         glFramebufferTextureLayer(GL_FRAMEBUFFER_EXT, attachment,\n                                   res->id, level, layer);\n      break;\n   case GL_TEXTURE_3D:\n      if (layer == 0xffffffff)\n         glFramebufferTexture(GL_FRAMEBUFFER_EXT, attachment,\n                              res->id, level);\n      else\n         glFramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                   res->target, res->id, level, layer);\n      break;\n   case GL_TEXTURE_CUBE_MAP:\n      if (layer == 0xffffffff)\n         glFramebufferTexture(GL_FRAMEBUFFER_EXT, attachment,\n                              res->id, level);\n      else\n         glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                   GL_TEXTURE_CUBE_MAP_POSITIVE_X + layer, res->id, level);\n      break;\n   case GL_TEXTURE_1D:\n      glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                res->target, res->id, level);\n      break;\n   case GL_TEXTURE_2D:\n   default:\n      glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment,\n                                res->target, res->id, level);\n      break;\n   }\n\n   if (attachment == GL_DEPTH_ATTACHMENT) {\n      switch (res->target) {\n      case GL_TEXTURE_1D:\n         glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT,\n                                   GL_TEXTURE_1D, 0, 0);\n         break;\n      case GL_TEXTURE_2D:\n      default:\n         glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_STENCIL_ATTACHMENT,\n                                   GL_TEXTURE_2D, 0, 0);\n         break;\n      }\n   }\n}\n",
        "output": "0",
        "index": 8859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jsR_setproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Value *value = stackidx(J, -1);\n\tjs_Property *ref;\n\tint k;\n\tint own;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tdouble rawlen = jsV_tonumber(J, value);\n\t\t\tint newlen = jsV_numbertointeger(rawlen);\n\t\t\tif (newlen != rawlen)\n\t\t\t\tjs_rangeerror(J, \"array length\");\n\t\t\tjsV_resizearray(J, obj, newlen);\n\t\t\treturn;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (k >= obj->u.a.length)\n\t\t\t\tobj->u.a.length = k + 1;\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\"))\n\t\t\tgoto readonly;\n\t\tif (js_isarrayindex(J, name, &k))\n\t\t\tif (js_runeat(J, obj->u.s.string, k))\n\t\t\t\tgoto readonly;\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) goto readonly;\n\t\tif (!strcmp(name, \"global\")) goto readonly;\n\t\tif (!strcmp(name, \"ignoreCase\")) goto readonly;\n\t\tif (!strcmp(name, \"multiline\")) goto readonly;\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tobj->u.r.last = jsV_tointeger(J, value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.put && obj->u.user.put(J, obj->u.user.data, name))\n\t\t\treturn;\n\t}\n\n\t/* First try to find a setter in prototype chain */\n\tref = jsV_getpropertyx(J, obj, name, &own);\n\tif (ref && ref->setter) {\n\t\tjs_pushobject(J, ref->setter);\n\t\tjs_pushobject(J, obj);\n\t\tjs_pushvalue(J, *value);\n\t\tjs_call(J, 1);\n\t\tjs_pop(J, 1);\n\t\treturn;\n\t}\n\n\t/* Property not found on this object, so create one */\n\tif (!ref || !own)\n\t\tref = jsV_setproperty(J, obj, name);\n\n\tif (ref) {\n\t\tif (!(ref->atts & JS_READONLY))\n\t\t\tref->value = *value;\n\t\telse\n\t\t\tgoto readonly;\n\t}\n\n\treturn;\n\nreadonly:\n\tif (J->strict)\n\t\tjs_typeerror(J, \"'%s' is read-only\", name);\n}\n",
        "output": "0",
        "index": 13412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_net_device_realize(DeviceState *dev, Error **errp)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n    VirtIONet *n = VIRTIO_NET(dev);\n    NetClientState *nc;\n    int i;\n\n    virtio_init(vdev, \"virtio-net\", VIRTIO_ID_NET, n->config_size);\n\n    n->max_queues = MAX(n->nic_conf.queues, 1);\n    n->vqs = g_malloc0(sizeof(VirtIONetQueue) * n->max_queues);\n    n->vqs[0].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);\n    n->curr_queues = 1;\n    n->vqs[0].n = n;\n    n->tx_timeout = n->net_conf.txtimer;\n\n    if (n->net_conf.tx && strcmp(n->net_conf.tx, \"timer\")\n                       && strcmp(n->net_conf.tx, \"bh\")) {\n        error_report(\"virtio-net: \"\n                     \"Unknown option tx=%s, valid options: \\\"timer\\\" \\\"bh\\\"\",\n                     n->net_conf.tx);\n        error_report(\"Defaulting to \\\"bh\\\"\");\n    }\n\n    if (n->net_conf.tx && !strcmp(n->net_conf.tx, \"timer\")) {\n        n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n                                           virtio_net_handle_tx_timer);\n        n->vqs[0].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, virtio_net_tx_timer,\n                                               &n->vqs[0]);\n    } else {\n        n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n                                           virtio_net_handle_tx_bh);\n        n->vqs[0].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[0]);\n    }\n    n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);\n    qemu_macaddr_default_if_unset(&n->nic_conf.macaddr);\n    memcpy(&n->mac[0], &n->nic_conf.macaddr, sizeof(n->mac));\n    n->status = VIRTIO_NET_S_LINK_UP;\n\n    if (n->netclient_type) {\n        /*\n         * Happen when virtio_net_set_netclient_name has been called.\n         */\n        n->nic = qemu_new_nic(&net_virtio_info, &n->nic_conf,\n                              n->netclient_type, n->netclient_name, n);\n    } else {\n        n->nic = qemu_new_nic(&net_virtio_info, &n->nic_conf,\n                              object_get_typename(OBJECT(dev)), dev->id, n);\n    }\n\n    peer_test_vnet_hdr(n);\n    if (peer_has_vnet_hdr(n)) {\n        for (i = 0; i < n->max_queues; i++) {\n            qemu_using_vnet_hdr(qemu_get_subqueue(n->nic, i)->peer, true);\n        }\n        n->host_hdr_len = sizeof(struct virtio_net_hdr);\n    } else {\n        n->host_hdr_len = 0;\n    }\n\n    qemu_format_nic_info_str(qemu_get_queue(n->nic), n->nic_conf.macaddr.a);\n\n    n->vqs[0].tx_waiting = 0;\n    n->tx_burst = n->net_conf.txburst;\n    virtio_net_set_mrg_rx_bufs(n, 0);\n    n->promisc = 1; /* for compatibility */\n\n    n->mac_table.macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    n->vlans = g_malloc0(MAX_VLAN >> 3);\n\n    nc = qemu_get_queue(n->nic);\n    nc->rxfilter_notify_enabled = 1;\n\n    n->qdev = dev;\n    register_savevm(dev, \"virtio-net\", -1, VIRTIO_NET_VM_VERSION,\n                    virtio_net_save, virtio_net_load, n);\n\n    add_boot_device_path(n->nic_conf.bootindex, dev, \"/ethernet-phy@0\");\n}\n",
        "output": "0",
        "index": 15828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool Type_MPE_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsUInt32Number i, BaseOffset, DirectoryPos, CurrentPos;\n    int inputChan, outputChan;\n    cmsUInt32Number ElemCount;\n    cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL, Before;\n    cmsStageSignature ElementSig;\n    cmsPipeline* Lut = (cmsPipeline*) Ptr;\n    cmsStage* Elem = Lut ->Elements;\n    cmsTagTypeHandler* TypeHandler;\n    _cmsTagTypePluginChunkType* MPETypePluginChunk  = ( _cmsTagTypePluginChunkType*) _cmsContextGetClientChunk(self->ContextID, MPEPlugin);\n\n    BaseOffset = io ->Tell(io) - sizeof(_cmsTagBase);\n\n    inputChan  = cmsPipelineInputChannels(Lut);\n    outputChan = cmsPipelineOutputChannels(Lut);\n    ElemCount  = cmsPipelineStageCount(Lut);\n\n    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementOffsets == NULL) goto Error;\n\n    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));\n    if (ElementSizes == NULL) goto Error;\n\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) inputChan)) goto Error;\n    if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) outputChan)) goto Error;\n    if (!_cmsWriteUInt32Number(io, (cmsUInt16Number) ElemCount)) goto Error;\n\n    DirectoryPos = io ->Tell(io);\n\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // Offset\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;  // size\n    }\n\n    for (i=0; i < ElemCount; i++) {\n\n        ElementOffsets[i] = io ->Tell(io) - BaseOffset;\n\n        ElementSig = Elem ->Type;\n\n        TypeHandler = GetHandler((cmsTagTypeSignature) ElementSig, MPETypePluginChunk->TagTypes, SupportedMPEtypes);\n        if (TypeHandler == NULL)  {\n\n                char String[5];\n\n                _cmsTagSignature2String(String, (cmsTagSignature) ElementSig);\n\n                 cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"Found unknown MPE type '%s'\", String);\n                 goto Error;\n        }\n\n        if (!_cmsWriteUInt32Number(io, ElementSig)) goto Error;\n        if (!_cmsWriteUInt32Number(io, 0)) goto Error;\n        Before = io ->Tell(io);\n        if (!TypeHandler ->WritePtr(self, io, Elem, 1)) goto Error;\n        if (!_cmsWriteAlignment(io)) goto Error;\n\n        ElementSizes[i] = io ->Tell(io) - Before;\n\n        Elem = Elem ->Next;\n    }\n\n    CurrentPos = io ->Tell(io);\n\n    if (!io ->Seek(io, DirectoryPos)) goto Error;\n\n    for (i=0; i < ElemCount; i++) {\n        if (!_cmsWriteUInt32Number(io, ElementOffsets[i])) goto Error;\n        if (!_cmsWriteUInt32Number(io, ElementSizes[i])) goto Error;\n    }\n\n    if (!io ->Seek(io, CurrentPos)) goto Error;\n\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return TRUE;\n\nError:\n    if (ElementOffsets != NULL) _cmsFree(self ->ContextID, ElementOffsets);\n    if (ElementSizes != NULL) _cmsFree(self ->ContextID, ElementSizes);\n    return FALSE;\n\n    cmsUNUSED_PARAMETER(nItems);\n}\n",
        "output": "0",
        "index": 71017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *merge_dir_config(apr_pool_t *p, void *basev, void *overridesv)\n{\n    ap_lua_dir_cfg *a, *base, *overrides;\n\n    a         = (ap_lua_dir_cfg *)apr_pcalloc(p, sizeof(ap_lua_dir_cfg));\n    base      = (ap_lua_dir_cfg*)basev;\n    overrides = (ap_lua_dir_cfg*)overridesv;\n\n    a->pool = overrides->pool;\n    a->dir = apr_pstrdup(p, overrides->dir);\n\n    a->vm_scope = (overrides->vm_scope == AP_LUA_SCOPE_UNSET) ? base->vm_scope: overrides->vm_scope;\n    a->inherit = (overrides->inherit == AP_LUA_INHERIT_UNSET) ? base->inherit : overrides->inherit;\n    a->codecache = (overrides->codecache == AP_LUA_CACHE_UNSET) ? base->codecache : overrides->codecache;\n    \n    a->vm_min = (overrides->vm_min == 0) ? base->vm_min : overrides->vm_min;\n    a->vm_max = (overrides->vm_max == 0) ? base->vm_max : overrides->vm_max;\n\n    if (a->inherit == AP_LUA_INHERIT_UNSET || a->inherit == AP_LUA_INHERIT_PARENT_FIRST) { \n        a->package_paths = apr_array_append(p, base->package_paths, overrides->package_paths);\n        a->package_cpaths = apr_array_append(p, base->package_cpaths, overrides->package_cpaths);\n        a->mapped_handlers = apr_array_append(p, base->mapped_handlers, overrides->mapped_handlers);\n        a->mapped_filters = apr_array_append(p, base->mapped_filters, overrides->mapped_filters);\n        a->hooks = apr_hash_merge(p, overrides->hooks, base->hooks, overlay_hook_specs, NULL);\n    }\n    else if (a->inherit == AP_LUA_INHERIT_PARENT_LAST) { \n        a->package_paths = apr_array_append(p, overrides->package_paths, base->package_paths);\n        a->package_cpaths = apr_array_append(p, overrides->package_cpaths, base->package_cpaths);\n        a->mapped_handlers = apr_array_append(p, overrides->mapped_handlers, base->mapped_handlers);\n        a->mapped_filters = apr_array_append(p, overrides->mapped_filters, base->mapped_filters);\n        a->hooks = apr_hash_merge(p, base->hooks, overrides->hooks, overlay_hook_specs, NULL);\n    }\n    else { \n        a->package_paths = overrides->package_paths;\n        a->package_cpaths = overrides->package_cpaths;\n        a->mapped_handlers= overrides->mapped_handlers;\n        a->mapped_filters= overrides->mapped_filters;\n        a->hooks= overrides->hooks;\n    }\n\n    return a;\n}\n",
        "output": "0",
        "index": 35714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLES2DecoderImpl::GLES2DecoderImpl(ContextGroup* group)\n    : GLES2Decoder(),\n      group_(group),\n      logger_(&debug_marker_manager_),\n      state_(group_->feature_info(), this, &logger_),\n      unpack_flip_y_(false),\n      unpack_premultiply_alpha_(false),\n      unpack_unpremultiply_alpha_(false),\n      attrib_0_buffer_id_(0),\n      attrib_0_buffer_matches_value_(true),\n      attrib_0_size_(0),\n      fixed_attrib_buffer_id_(0),\n      fixed_attrib_buffer_size_(0),\n      offscreen_target_color_format_(0),\n      offscreen_target_depth_format_(0),\n      offscreen_target_stencil_format_(0),\n      offscreen_target_samples_(0),\n      offscreen_target_buffer_preserved_(true),\n      offscreen_saved_color_format_(0),\n      back_buffer_color_format_(0),\n      back_buffer_has_depth_(false),\n      back_buffer_has_stencil_(false),\n      surfaceless_(false),\n      backbuffer_needs_clear_bits_(0),\n      current_decoder_error_(error::kNoError),\n      use_shader_translator_(true),\n      validators_(group_->feature_info()->validators()),\n      feature_info_(group_->feature_info()),\n      frame_number_(0),\n      has_robustness_extension_(false),\n      reset_status_(GL_NO_ERROR),\n      reset_by_robustness_extension_(false),\n      supports_post_sub_buffer_(false),\n      force_webgl_glsl_validation_(false),\n      derivatives_explicitly_enabled_(false),\n      frag_depth_explicitly_enabled_(false),\n      draw_buffers_explicitly_enabled_(false),\n      shader_texture_lod_explicitly_enabled_(false),\n      compile_shader_always_succeeds_(false),\n      lose_context_when_out_of_memory_(false),\n      service_logging_(base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableGPUServiceLoggingGPU)),\n      viewport_max_width_(0),\n      viewport_max_height_(0),\n      texture_state_(group_->feature_info()\n                         ->workarounds()\n                         .texsubimage2d_faster_than_teximage2d),\n      cb_command_trace_category_(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(\n          TRACE_DISABLED_BY_DEFAULT(\"cb_command\"))),\n      gpu_decoder_category_(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(\n          TRACE_DISABLED_BY_DEFAULT(\"gpu_decoder\"))),\n      gpu_trace_level_(2),\n      gpu_trace_commands_(false),\n      gpu_debug_commands_(false),\n      validation_texture_(0),\n      validation_fbo_multisample_(0),\n      validation_fbo_(0) {\n  DCHECK(group);\n\n  attrib_0_value_.v[0] = 0.0f;\n  attrib_0_value_.v[1] = 0.0f;\n  attrib_0_value_.v[2] = 0.0f;\n  attrib_0_value_.v[3] = 1.0f;\n\n  if (gfx::GetGLImplementation() == gfx::kGLImplementationMockGL ||\n      base::CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDisableGLSLTranslator)) {\n    use_shader_translator_ = false;\n  }\n}\n",
        "output": "0",
        "index": 140767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi)\n{\n /* Reuse the standard stuff as appropriate. */\n   standard_info_part1(&dp->this, pp, pi);\n\n\n    /* If requested strip 16 to 8 bits - this is handled automagically below\n     * because the output bit depth is read from the library.  Note that there\n     * are interactions with sBIT but, internally, libpng makes sbit at most\n    * PNG_MAX_GAMMA_8 when doing the following.\n     */\n    if (dp->scale16)\n #     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED\n         png_set_scale_16(pp);\n#     else\n /* The following works both in 1.5.4 and earlier versions: */\n#        ifdef PNG_READ_16_TO_8_SUPPORTED\n            png_set_strip_16(pp);\n#        else\n            png_error(pp, \"scale16 (16 to 8 bit conversion) not supported\");\n#        endif\n#     endif\n\n if (dp->expand16)\n#     ifdef PNG_READ_EXPAND_16_SUPPORTED\n         png_set_expand_16(pp);\n#     else\n         png_error(pp, \"expand16 (8 to 16 bit conversion) not supported\");\n#     endif\n\n if (dp->do_background >= ALPHA_MODE_OFFSET)\n {\n#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED\n {\n /* This tests the alpha mode handling, if supported. */\n int mode = dp->do_background - ALPHA_MODE_OFFSET;\n\n /* The gamma value is the output gamma, and is in the standard,\n\n           * non-inverted, represenation.  It provides a default for the PNG file\n           * gamma, but since the file has a gAMA chunk this does not matter.\n           */\n         PNG_CONST double sg = dp->screen_gamma;\n #        ifndef PNG_FLOATING_POINT_SUPPORTED\n            PNG_CONST png_fixed_point g = fix(sg);\n #        endif\n \n #        ifdef PNG_FLOATING_POINT_SUPPORTED\n            png_set_alpha_mode(pp, mode, sg);\n#        else\n            png_set_alpha_mode_fixed(pp, mode, g);\n#        endif\n\n /* However, for the standard Porter-Duff algorithm the output defaults\n          * to be linear, so if the test requires non-linear output it must be\n          * corrected here.\n          */\n if (mode == PNG_ALPHA_STANDARD && sg != 1)\n {\n#           ifdef PNG_FLOATING_POINT_SUPPORTED\n               png_set_gamma(pp, sg, dp->file_gamma);\n#           else\n               png_fixed_point f = fix(dp->file_gamma);\n               png_set_gamma_fixed(pp, g, f);\n#           endif\n }\n }\n#     else\n         png_error(pp, \"alpha mode handling not supported\");\n#     endif\n }\n\n else\n {\n /* Set up gamma processing. */\n#     ifdef PNG_FLOATING_POINT_SUPPORTED\n         png_set_gamma(pp, dp->screen_gamma, dp->file_gamma);\n#     else\n {\n         png_fixed_point s = fix(dp->screen_gamma);\n         png_fixed_point f = fix(dp->file_gamma);\n         png_set_gamma_fixed(pp, s, f);\n }\n#     endif\n\n if (dp->do_background)\n {\n\n #     ifdef PNG_READ_BACKGROUND_SUPPORTED\n          /* NOTE: this assumes the caller provided the correct background gamma!\n           */\n         PNG_CONST double bg = dp->background_gamma;\n #        ifndef PNG_FLOATING_POINT_SUPPORTED\n            PNG_CONST png_fixed_point g = fix(bg);\n #        endif\n \n #        ifdef PNG_FLOATING_POINT_SUPPORTED\n            png_set_background(pp, &dp->background_color, dp->do_background,\n 0/*need_expand*/, bg);\n#        else\n            png_set_background_fixed(pp, &dp->background_color,\n               dp->do_background, 0/*need_expand*/, g);\n#        endif\n#     else\n         png_error(pp, \"png_set_background not supported\");\n#     endif\n }\n }\n\n {\n int i = dp->this.use_update_info;\n /* Always do one call, even if use_update_info is 0. */\n do\n         png_read_update_info(pp, pi);\n while (--i > 0);\n }\n\n /* Now we may get a different cbRow: */\n   standard_info_part2(&dp->this, pp, pi, 1 /*images*/);\n}\n",
        "output": "1",
        "index": 187635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n {\n\tchar buffer[4096];\n    char buffer2[4096];\n     int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n \tint l;\n \n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n \tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n \t\n \tif (SUHOSIN_G(cookie_plainlist)) {\n \t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\n decrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n             memcpy(*where, name, o_name_len);\n             *where += o_name_len;\n             **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n \t}\n \t\n \t\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n \t\n \tvalue_len = php_url_decode(buf2, value_len);\n \t\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n \t*where += l;\n \tefree(d_url);\n skip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n \treturn *where;\n }\n",
        "output": "1",
        "index": 178821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\n\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\n\t/* Extract a tag from the data */\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\t/* It appears to be an EOC. */\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\n\t/* Extract the length */\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t/* Indefinite length */\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}\n",
        "output": "0",
        "index": 55432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sched_domain_debug_one(struct sched_domain *sd, int cpu, int level,\n\t\t\t\t  struct cpumask *groupmask)\n{\n\tstruct sched_group *group = sd->groups;\n\n\tcpumask_clear(groupmask);\n\n\tprintk(KERN_DEBUG \"%*s domain %d: \", level, \"\", level);\n\n\tif (!(sd->flags & SD_LOAD_BALANCE)) {\n\t\tprintk(\"does not load-balance\\n\");\n\t\tif (sd->parent)\n\t\t\tprintk(KERN_ERR \"ERROR: !SD_LOAD_BALANCE domain\"\n\t\t\t\t\t\" has parent\");\n\t\treturn -1;\n\t}\n\n\tprintk(KERN_CONT \"span %*pbl level %s\\n\",\n\t       cpumask_pr_args(sched_domain_span(sd)), sd->name);\n\n\tif (!cpumask_test_cpu(cpu, sched_domain_span(sd))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->span does not contain \"\n\t\t\t\t\"CPU%d\\n\", cpu);\n\t}\n\tif (!cpumask_test_cpu(cpu, sched_group_cpus(group))) {\n\t\tprintk(KERN_ERR \"ERROR: domain->groups does not contain\"\n\t\t\t\t\" CPU%d\\n\", cpu);\n\t}\n\n\tprintk(KERN_DEBUG \"%*s groups:\", level + 1, \"\");\n\tdo {\n\t\tif (!group) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: group is NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!cpumask_weight(sched_group_cpus(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: empty group\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(sd->flags & SD_OVERLAP) &&\n\t\t    cpumask_intersects(groupmask, sched_group_cpus(group))) {\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tprintk(KERN_ERR \"ERROR: repeated CPUs\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpumask_or(groupmask, groupmask, sched_group_cpus(group));\n\n\t\tprintk(KERN_CONT \" %*pbl\",\n\t\t       cpumask_pr_args(sched_group_cpus(group)));\n\t\tif (group->sgc->capacity != SCHED_CAPACITY_SCALE) {\n\t\t\tprintk(KERN_CONT \" (cpu_capacity = %d)\",\n\t\t\t\tgroup->sgc->capacity);\n\t\t}\n\n\t\tgroup = group->next;\n\t} while (group != sd->groups);\n\tprintk(KERN_CONT \"\\n\");\n\n\tif (!cpumask_equal(sched_domain_span(sd), groupmask))\n\t\tprintk(KERN_ERR \"ERROR: groups don't span domain->span\\n\");\n\n\tif (sd->parent &&\n\t    !cpumask_subset(groupmask, sched_domain_span(sd->parent)))\n\t\tprintk(KERN_ERR \"ERROR: parent span is not a superset \"\n\t\t\t\"of domain->span\\n\");\n\treturn 0;\n}\n",
        "output": "0",
        "index": 55599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rfc4106_set_key(struct crypto_aead *parent, const u8 *key,\n\t\t\t\t\t\t   unsigned int key_len)\n{\n\tint ret = 0;\n\tstruct crypto_tfm *tfm = crypto_aead_tfm(parent);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(parent);\n\tstruct crypto_aead *cryptd_child = cryptd_aead_child(ctx->cryptd_tfm);\n\tstruct aesni_rfc4106_gcm_ctx *child_ctx =\n                                 aesni_rfc4106_gcm_ctx_get(cryptd_child);\n\tu8 *new_key_align, *new_key_mem = NULL;\n\n\tif (key_len < 4) {\n\t\tcrypto_tfm_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\t/*Account for 4 byte nonce at the end.*/\n\tkey_len -= 4;\n\tif (key_len != AES_KEYSIZE_128 && key_len != AES_KEYSIZE_192 &&\n\t    key_len != AES_KEYSIZE_256) {\n\t\tcrypto_tfm_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ctx->nonce, key + key_len, sizeof(ctx->nonce));\n\t/*This must be on a 16 byte boundary!*/\n\tif ((unsigned long)(&(ctx->aes_key_expanded.key_enc[0])) % AESNI_ALIGN)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)key % AESNI_ALIGN) {\n\t\t/*key is not aligned: use an auxuliar aligned pointer*/\n\t\tnew_key_mem = kmalloc(key_len+AESNI_ALIGN, GFP_KERNEL);\n\t\tif (!new_key_mem)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_key_align = PTR_ALIGN(new_key_mem, AESNI_ALIGN);\n\t\tmemcpy(new_key_align, key, key_len);\n\t\tkey = new_key_align;\n\t}\n\n\tif (!irq_fpu_usable())\n\t\tret = crypto_aes_expand_key(&(ctx->aes_key_expanded),\n\t\tkey, key_len);\n\telse {\n\t\tkernel_fpu_begin();\n\t\tret = aesni_set_key(&(ctx->aes_key_expanded), key, key_len);\n\t\tkernel_fpu_end();\n\t}\n\t/*This must be on a 16 byte boundary!*/\n\tif ((unsigned long)(&(ctx->hash_subkey[0])) % AESNI_ALIGN) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\tret = rfc4106_set_hash_subkey(ctx->hash_subkey, key, key_len);\n\tmemcpy(child_ctx, ctx, sizeof(*ctx));\nexit:\n\tkfree(new_key_mem);\n\treturn ret;\n}\n",
        "output": "0",
        "index": 43494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType DrawPatternPath(Image *image,\n  const DrawInfo *draw_info,const char *name,Image **pattern,\n  ExceptionInfo *exception)\n{\n  char\n    property[MagickPathExtent];\n\n  const char\n    *geometry,\n    *path,\n    *type;\n\n  DrawInfo\n    *clone_info;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  assert(name != (const char *) NULL);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s\",name);\n  path=GetImageArtifact(image,property);\n  if (path == (const char *) NULL)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-geometry\",name);\n  geometry=GetImageArtifact(image,property);\n  if (geometry == (const char *) NULL)\n    return(MagickFalse);\n  if ((*pattern) != (Image *) NULL)\n    *pattern=DestroyImage(*pattern);\n  image_info=AcquireImageInfo();\n  image_info->size=AcquireString(geometry);\n  *pattern=AcquireImage(image_info,exception);\n  image_info=DestroyImageInfo(image_info);\n  (void) QueryColorCompliance(\"#000000ff\",AllCompliance,\n    &(*pattern)->background_color,exception);\n  (void) SetImageBackgroundColor(*pattern,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"begin pattern-path %s %s\",name,geometry);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill_pattern=NewImageList();\n  clone_info->stroke_pattern=NewImageList();\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s-type\",name);\n  type=GetImageArtifact(image,property);\n  if (type != (const char *) NULL)\n    clone_info->gradient.type=(GradientType) ParseCommandOption(\n      MagickGradientOptions,MagickFalse,type);\n  (void) CloneString(&clone_info->primitive,path);\n  status=RenderMVGContent(*pattern,clone_info,0,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end pattern-path\");\n  return(status);\n}\n",
        "output": "0",
        "index": 87273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int amd_gpio_set_debounce(struct gpio_chip *gc, unsigned offset,\n\t\tunsigned debounce)\n{\n\tu32 time;\n\tu32 pin_reg;\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\n\tif (debounce) {\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t/*\n\t\tDebounce\tDebounce\tTimer\tMax\n\t\tTmrLarge\tTmrOutUnit\tUnit\tDebounce\n\t\t\t\t\t\t\tTime\n\t\t0\t0\t61 usec (2 RtcClk)\t976 usec\n\t\t0\t1\t244 usec (8 RtcClk)\t3.9 msec\n\t\t1\t0\t15.6 msec (512 RtcClk)\t250 msec\n\t\t1\t1\t62.5 msec (2048 RtcClk)\t1 sec\n\t\t*/\n\n\t\tif (debounce < 61) {\n\t\t\tpin_reg |= 1;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 976) {\n\t\t\ttime = debounce / 61;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 3900) {\n\t\t\ttime = debounce / 244;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 250000) {\n\t\t\ttime = debounce / 15600;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 1000000) {\n\t\t\ttime = debounce / 62500;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else {\n\t\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t}\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 86168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    struct net_device *dev)\n{\n\tstruct net_bridge *br = netdev_priv(dev);\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct nlattr *nest, *nest2;\n\tint i, err = 0;\n\tint idx = 0, s_idx = cb->args[1];\n\n\tif (br->multicast_disabled)\n\t\treturn 0;\n\n\tmdb = rcu_dereference(br->mdb);\n\tif (!mdb)\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < mdb->max; i++) {\n\t\tstruct net_bridge_mdb_entry *mp;\n\t\tstruct net_bridge_port_group *p, **pp;\n\t\tstruct net_bridge_port *port;\n\n\t\thlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\n\t\t\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\t\t\tif (nest2 == NULL) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (pp = &mp->ports;\n\t\t\t     (p = rcu_dereference(*pp)) != NULL;\n\t\t\t      pp = &p->next) {\n \t\t\t\tport = p->port;\n \t\t\t\tif (port) {\n \t\t\t\t\tstruct br_mdb_entry e;\n \t\t\t\t\te.ifindex = port->dev->ifindex;\n \t\t\t\t\te.state = p->state;\n \t\t\t\t\tif (p->addr.proto == htons(ETH_P_IP))\n\t\t\t\t\t\te.addr.u.ip4 = p->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t\tif (p->addr.proto == htons(ETH_P_IPV6))\n\t\t\t\t\t\te.addr.u.ip6 = p->addr.u.ip6;\n#endif\n\t\t\t\t\te.addr.proto = p->addr.proto;\n\t\t\t\t\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {\n\t\t\t\t\t\tnla_nest_cancel(skb, nest2);\n\t\t\t\t\t\terr = -EMSGSIZE;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnla_nest_end(skb, nest2);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\nout:\n\tcb->args[1] = idx;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n",
        "output": "1",
        "index": 179225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cac_get_properties(sc_card_t *card, cac_properties_t *prop)\n{\n\tu8 *rbuf = NULL;\n\tsize_t rbuflen = 0, len;\n\tu8 *val, *val_end, tag;\n\tsize_t i = 0;\n\tint r;\n\tprop->num_objects = 0;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = cac_apdu_io(card, CAC_INS_GET_PROPERTIES, 0x01, 0x00, NULL, 0,\n\t\t&rbuf, &rbuflen);\n\tif (r < 0)\n\t\treturn r;\n\n\tval = rbuf;\n\tval_end = val + rbuflen;\n\tfor (; val < val_end; val += len) {\n\t\t/* get the tag and the length */\n\t\tif (sc_simpletlv_read_tag(&val, val_end - val, &tag, &len) != SC_SUCCESS)\n\t\t\tbreak;\n\n\t\tswitch (tag) {\n\t\tcase CAC_TAG_APPLET_INFORMATION:\n\t\t\tif (len != 5) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Applet Information: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Applet Information: Family: 0x%0x\", val[0]);\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"     Applet Version: 0x%02x 0x%02x 0x%02x 0x%02x\",\n\t\t\t    val[1], val[2], val[3], val[4]);\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_NUMBER_OF_OBJECTS:\n\t\t\tif (len != 1) {\n\t\t\t\tsc_log(card->ctx, \"TAG: Num objects: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: Num objects = %hhd\", *val);\n\t\t\t/* make sure we do not overrun buffer */\n\t\t\tprop->num_objects = MIN(val[0], CAC_MAX_OBJECTS);\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_TV_BUFFER:\n\t\t\tif (len != 17) {\n\t\t\t\tsc_log(card->ctx, \"TAG: TV Object: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: TV Object nr. %\"SC_FORMAT_LEN_SIZE_T\"u\", i);\n\t\t\tif (i >= CAC_MAX_OBJECTS) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\n\t\t\tif (cac_parse_properties_object(card, tag, val, len,\n\t\t\t    &prop->objects[i]) == SC_SUCCESS)\n\t\t\t\ti++;\n\t\t\tbreak;\n\n\t\tcase CAC_TAG_PKI_OBJECT:\n\t\t\tif (len != 17) {\n\t\t\t\tsc_log(card->ctx, \"TAG: PKI Object: \"\n\t\t\t\t    \"Invalid length %\"SC_FORMAT_LEN_SIZE_T\"u\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t    \"TAG: PKI Object nr. %\"SC_FORMAT_LEN_SIZE_T\"u\", i);\n\t\t\tif (i >= CAC_MAX_OBJECTS) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\n\t\t\tif (cac_parse_properties_object(card, tag, val, len,\n\t\t\t    &prop->objects[i]) == SC_SUCCESS)\n\t\t\t\ti++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* ignore tags we don't understand */\n\t\t\tsc_log(card->ctx, \"TAG: Unknown (0x%02x), len=%\"\n\t\t\t    SC_FORMAT_LEN_SIZE_T\"u\", tag, len);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(rbuf);\n\t/* sanity */\n\tif (i != prop->num_objects)\n\t\tsc_log(card->ctx, \"The announced number of objects (%u) \"\n\t\t    \"did not match reality (%\"SC_FORMAT_LEN_SIZE_T\"u)\",\n\t\t    prop->num_objects, i);\n\tprop->num_objects = i;\n\n\treturn SC_SUCCESS;\n}\n",
        "output": "0",
        "index": 78238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DownloadInterruptReason ResourceDispatcherHostImpl::BeginDownload(\n    scoped_ptr<net::URLRequest> request,\n    const Referrer& referrer,\n    bool is_content_initiated,\n    ResourceContext* context,\n    int child_id,\n    int render_view_route_id,\n    int render_frame_route_id,\n    bool prefer_cache,\n    bool do_not_prompt_for_login,\n    scoped_ptr<DownloadSaveInfo> save_info,\n    uint32_t download_id,\n    const DownloadStartedCallback& started_callback) {\n  if (is_shutdown_)\n    return CallbackAndReturn(started_callback,\n                             DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN);\n\n  const GURL& url = request->original_url();\n\n  char url_buf[128];\n  base::strlcpy(url_buf, url.spec().c_str(), arraysize(url_buf));\n  base::debug::Alias(url_buf);\n  CHECK(ContainsKey(active_resource_contexts_, context));\n\n  SetReferrerForRequest(request.get(), referrer);\n\n  int extra_load_flags = net::LOAD_NORMAL;\n  if (prefer_cache) {\n    if (request->get_upload() != NULL)\n      extra_load_flags |= net::LOAD_ONLY_FROM_CACHE;\n    else\n      extra_load_flags |= net::LOAD_PREFERRING_CACHE;\n  } else {\n    extra_load_flags |= net::LOAD_DISABLE_CACHE;\n  }\n  request->SetLoadFlags(request->load_flags() | extra_load_flags);\n\n  request->set_first_party_url_policy(\n      net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);\n\n  if (!ChildProcessSecurityPolicyImpl::GetInstance()->\n          CanRequestURL(child_id, url)) {\n    VLOG(1) << \"Denied unauthorized download request for \"\n            << url.possibly_invalid_spec();\n    return CallbackAndReturn(started_callback,\n                             DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST);\n  }\n\n  request_id_--;\n\n  const net::URLRequestContext* request_context = context->GetRequestContext();\n  if (!request_context->job_factory()->IsHandledURL(url)) {\n    VLOG(1) << \"Download request for unsupported protocol: \"\n            << url.possibly_invalid_spec();\n    return CallbackAndReturn(started_callback,\n                             DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST);\n  }\n\n  ResourceRequestInfoImpl* extra_info =\n      CreateRequestInfo(child_id, render_view_route_id,\n                        render_frame_route_id, true, context);\n  extra_info->set_do_not_prompt_for_login(do_not_prompt_for_login);\n  extra_info->AssociateWithRequest(request.get());  // Request takes ownership.\n\n  if (request->url().SchemeIs(url::kBlobScheme)) {\n    ChromeBlobStorageContext* blob_context =\n        GetChromeBlobStorageContextForResourceContext(context);\n    storage::BlobProtocolHandler::SetRequestedBlobDataHandle(\n        request.get(),\n        blob_context->context()->GetBlobDataFromPublicURL(request->url()));\n  }\n\n  scoped_ptr<ResourceHandler> handler(CreateResourceHandlerForDownload(\n      request.get(), is_content_initiated, true, download_id,\n      std::move(save_info), started_callback));\n\n  BeginRequestInternal(std::move(request), std::move(handler));\n\n  return DOWNLOAD_INTERRUPT_REASON_NONE;\n}\n",
        "output": "0",
        "index": 145474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GDataFileSystem::GetResolvedFileByPath(\n    const FilePath& file_path,\n    const GetFileCallback& get_file_callback,\n    const GetDownloadDataCallback& get_download_data_callback,\n    GDataFileError error,\n    const GDataEntryProto* entry_proto) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n\n  if (entry_proto && !entry_proto->has_file_specific_info())\n    error = GDATA_FILE_ERROR_NOT_FOUND;\n\n  if (error != GDATA_FILE_OK) {\n    if (!get_file_callback.is_null()) {\n      MessageLoop::current()->PostTask(\n          FROM_HERE,\n          base::Bind(get_file_callback,\n                     GDATA_FILE_ERROR_NOT_FOUND,\n                     FilePath(),\n                     std::string(),\n                     REGULAR_FILE));\n    }\n    return;\n  }\n\n  if (entry_proto->file_specific_info().is_hosted_document()) {\n    GDataFileError* error =\n        new GDataFileError(GDATA_FILE_OK);\n    FilePath* temp_file_path = new FilePath;\n    std::string* mime_type = new std::string;\n    GDataFileType* file_type = new GDataFileType(REGULAR_FILE);\n    util::PostBlockingPoolSequencedTaskAndReply(\n        FROM_HERE,\n        blocking_task_runner_,\n        base::Bind(&CreateDocumentJsonFileOnBlockingPool,\n                   cache_->GetCacheDirectoryPath(\n                       GDataCache::CACHE_TYPE_TMP_DOCUMENTS),\n                   GURL(entry_proto->file_specific_info().alternate_url()),\n                   entry_proto->resource_id(),\n                   error,\n                   temp_file_path,\n                   mime_type,\n                   file_type),\n        base::Bind(&RunGetFileCallbackHelper,\n                   get_file_callback,\n                   base::Owned(error),\n                   base::Owned(temp_file_path),\n                   base::Owned(mime_type),\n                   base::Owned(file_type)));\n    return;\n  }\n\n  FilePath local_tmp_path = cache_->GetCacheFilePath(\n      entry_proto->resource_id(),\n      entry_proto->file_specific_info().file_md5(),\n      GDataCache::CACHE_TYPE_TMP,\n      GDataCache::CACHED_FILE_FROM_SERVER);\n  cache_->GetFileOnUIThread(\n      entry_proto->resource_id(),\n      entry_proto->file_specific_info().file_md5(),\n      base::Bind(\n          &GDataFileSystem::OnGetFileFromCache,\n          ui_weak_ptr_,\n          GetFileFromCacheParams(\n              file_path,\n              local_tmp_path,\n              GURL(entry_proto->content_url()),\n              entry_proto->resource_id(),\n              entry_proto->file_specific_info().file_md5(),\n              entry_proto->file_specific_info().content_mime_type(),\n              get_file_callback,\n              get_download_data_callback)));\n}\n",
        "output": "0",
        "index": 125377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sctp_process_asconf_ack(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *asconf_ack)\n{\n\tstruct sctp_chunk\t*asconf = asoc->addip_last_asconf;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tint\tlength = 0;\n\tint\tasconf_len = asconf->skb->len;\n\tint\tall_param_pass = 0;\n\tint\tno_err = 1;\n\tint\tretval = 0;\n\t__be16\terr_code = SCTP_ERROR_NO_ERROR;\n\n\t/* Skip the chunkhdr and addiphdr from the last asconf sent and store\n\t * a pointer to address parameter.\n\t */\n\tlength = sizeof(sctp_addip_chunk_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tasconf_len -= length;\n\n\t/* Skip the address parameter in the last asconf sent and store a\n\t * pointer to the first asconf parameter.\n\t */\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tasconf_len -= length;\n\n\t/* ADDIP 4.1\n\t * A8) If there is no response(s) to specific TLV parameter(s), and no\n\t * failures are indicated, then all request(s) are considered\n\t * successful.\n\t */\n\tif (asconf_ack->skb->len == sizeof(sctp_addiphdr_t))\n\t\tall_param_pass = 1;\n\n\t/* Process the TLVs contained in the last sent ASCONF chunk. */\n\twhile (asconf_len > 0) {\n\t\tif (all_param_pass)\n\t\t\terr_code = SCTP_ERROR_NO_ERROR;\n\t\telse {\n\t\t\terr_code = sctp_get_asconf_response(asconf_ack,\n\t\t\t\t\t\t\t    asconf_param,\n\t\t\t\t\t\t\t    no_err);\n\t\t\tif (no_err && (SCTP_ERROR_NO_ERROR != err_code))\n\t\t\t\tno_err = 0;\n\t\t}\n\n\t\tswitch (err_code) {\n\t\tcase SCTP_ERROR_NO_ERROR:\n\t\t\tsctp_asconf_param_success(asoc, asconf_param);\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_RSRC_LOW:\n\t\t\tretval = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_UNKNOWN_PARAM:\n\t\t\t/* Disable sending this type of asconf parameter in\n\t\t\t * future.\n\t\t\t */\n\t\t\tasoc->peer.addip_disabled_mask |=\n\t\t\t\tasconf_param->param_hdr.type;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_REQ_REFUSED:\n\t\tcase SCTP_ERROR_DEL_LAST_IP:\n\t\tcase SCTP_ERROR_DEL_SRC_IP:\n\t\tdefault:\n\t\t\t break;\n\t\t}\n\n\t\t/* Skip the processed asconf parameter and move to the next\n\t\t * one.\n\t\t */\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tasconf_len -= length;\n\t}\n\n\tif (no_err && asoc->src_out_of_asoc_ok) {\n\t\tasoc->src_out_of_asoc_ok = 0;\n\t\tsctp_transport_immediate_rtx(asoc->peer.primary_path);\n\t}\n\n\t/* Free the cached last sent asconf chunk. */\n\tlist_del_init(&asconf->transmitted_list);\n\tsctp_chunk_free(asconf);\n\tasoc->addip_last_asconf = NULL;\n\n\treturn retval;\n}\n",
        "output": "0",
        "index": 35883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "drive_ata_smart_refresh_data_completed_cb (DBusGMethodInvocation *context,\n                                           Device *device,\n                                           gboolean job_was_cancelled,\n                                           int status,\n                                           const char *stderr,\n                                           const char *stdout,\n                                           gpointer user_data)\n{\n  gint rc;\n  SkDisk *d;\n  gchar *blob;\n  gsize blob_size;\n  time_t time_collected;\n  SkSmartOverall overall;\n\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) start\", device->priv->native_path);\n\n  d = NULL;\n  blob = NULL;\n\n  if (job_was_cancelled || stdout == NULL)\n    {\n      if (job_was_cancelled)\n        {\n          if (context != NULL)\n            throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          if (context != NULL)\n            throw_error (context,\n                         ERROR_FAILED,\n                         \"Error retrieving ATA SMART data: no output\",\n                         WEXITSTATUS (status),\n                         stderr);\n        }\n      goto out;\n    }\n\n  rc = WEXITSTATUS (status);\n\n  if (rc != 0)\n    {\n      if (rc == 2)\n        {\n          if (context != NULL)\n            {\n              throw_error (context, ERROR_ATA_SMART_WOULD_WAKEUP, \"Error retrieving ATA SMART data: %s\", stderr);\n            }\n        }\n      else\n        {\n          if (context != NULL)\n            {\n              throw_error (context,\n                           ERROR_FAILED,\n                           \"Error retrieving ATA SMART data: helper failed with exit code %d: %s\",\n                           rc,\n                           stderr);\n            }\n        }\n      goto out;\n    }\n\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) decode blob\", device->priv->native_path);\n  blob = (gchar *) g_base64_decode (stdout, &blob_size);\n\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) set blob\", device->priv->native_path);\n  if (blob == NULL)\n    {\n      if (context != NULL)\n        {\n          throw_error (context, ERROR_FAILED, \"Error decoding ATA SMART data: invalid base64 format: %s\", stdout);\n        }\n      else\n        {\n          g_warning (\"Error decoding ATA SMART data: invalid base64 format: %s\", stdout);\n        }\n      goto out;\n    }\n\n  if (sk_disk_open (NULL, &d) != 0)\n    {\n      if (context != NULL)\n        {\n          throw_error (context, ERROR_FAILED, \"unable to open a SkDisk\");\n        }\n      goto out;\n    }\n\n  if (sk_disk_set_blob (d, blob, blob_size) != 0)\n    {\n      if (context != NULL)\n        {\n          throw_error (context, ERROR_FAILED, \"error parsing blob: %s\", strerror (errno));\n        }\n      goto out;\n    }\n\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) time collected\", device->priv->native_path);\n  time_collected = time (NULL);\n  device_set_drive_ata_smart_time_collected (device, time_collected);\n\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) overall smart status\", device->priv->native_path);\n  if (sk_disk_smart_get_overall (d, &overall) != 0)\n    overall = -1;\n  device_set_drive_ata_smart_status (device, overall);\n  device_set_drive_ata_smart_blob_steal (device, blob, blob_size);\n  blob = NULL;\n\n  /* emit change event since we've updated the smart data */\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) drain pending changes\", device->priv->native_path);\n  drain_pending_changes (device, FALSE);\n\n  if (context != NULL)\n    dbus_g_method_return (context);\n\n out:\n  g_free (blob);\n  if (d != NULL)\n    sk_disk_free (d);\n  PROFILE (\"drive_ata_smart_refresh_data_completed_cb(device=%s) end\", device->priv->native_path);\n}\n",
        "output": "0",
        "index": 11684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vrend_decode_create_rasterizer(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_rasterizer_state *rs_state;\n   uint32_t tmp;\n\n   if (length != VIRGL_OBJ_RS_SIZE)\n      return EINVAL;\n\n   rs_state = CALLOC_STRUCT(pipe_rasterizer_state);\n   if (!rs_state)\n      return ENOMEM;\n\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_RS_S0);\n#define ebit(name, bit) rs_state->name = (tmp >> bit) & 0x1\n#define emask(name, bit, mask) rs_state->name = (tmp >> bit) & mask\n\n   ebit(flatshade, 0);\n   ebit(depth_clip, 1);\n   ebit(clip_halfz, 2);\n   ebit(rasterizer_discard, 3);\n   ebit(flatshade_first, 4);\n   ebit(light_twoside, 5);\n   ebit(sprite_coord_mode, 6);\n   ebit(point_quad_rasterization, 7);\n   emask(cull_face, 8, 0x3);\n   emask(fill_front, 10, 0x3);\n   emask(fill_back, 12, 0x3);\n   ebit(scissor, 14);\n   ebit(front_ccw, 15);\n   ebit(clamp_vertex_color, 16);\n   ebit(clamp_fragment_color, 17);\n   ebit(offset_line, 18);\n   ebit(offset_point, 19);\n   ebit(offset_tri, 20);\n   ebit(poly_smooth, 21);\n   ebit(poly_stipple_enable, 22);\n   ebit(point_smooth, 23);\n   ebit(point_size_per_vertex, 24);\n   ebit(multisample, 25);\n   ebit(line_smooth, 26);\n   ebit(line_stipple_enable, 27);\n   ebit(line_last_pixel, 28);\n   ebit(half_pixel_center, 29);\n   ebit(bottom_edge_rule, 30);\n   rs_state->point_size = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_POINT_SIZE));\n   rs_state->sprite_coord_enable = get_buf_entry(ctx, VIRGL_OBJ_RS_SPRITE_COORD_ENABLE);\n   tmp = get_buf_entry(ctx, VIRGL_OBJ_RS_S3);\n   emask(line_stipple_pattern, 0, 0xffff);\n   emask(line_stipple_factor, 16, 0xff);\n   emask(clip_plane_enable, 24, 0xff);\n\n   rs_state->line_width = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_LINE_WIDTH));\n   rs_state->offset_units = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_UNITS));\n   rs_state->offset_scale = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_SCALE));\n   rs_state->offset_clamp = uif(get_buf_entry(ctx, VIRGL_OBJ_RS_OFFSET_CLAMP));\n\n   tmp = vrend_renderer_object_insert(ctx->grctx, rs_state, sizeof(struct pipe_rasterizer_state), handle,\n                                      VIRGL_OBJECT_RASTERIZER);\n   if (tmp == 0) {\n      FREE(rs_state);\n      return ENOMEM;\n   }\n   return 0;\n}\n",
        "output": "0",
        "index": 9097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FFmpegVideoDecodeEngine::DecodeFrame(scoped_refptr<Buffer> buffer) {\n  scoped_refptr<VideoFrame> video_frame;\n\n  AVPacket packet;\n  av_init_packet(&packet);\n  packet.data = const_cast<uint8*>(buffer->GetData());\n  packet.size = buffer->GetDataSize();\n\n  PipelineStatistics statistics;\n  statistics.video_bytes_decoded = buffer->GetDataSize();\n\n  codec_context_->reordered_opaque = buffer->GetTimestamp().InMicroseconds();\n\n  av_frame_->reordered_opaque = codec_context_->reordered_opaque;\n\n  int frame_decoded = 0;\n  int result = avcodec_decode_video2(codec_context_,\n                                     av_frame_.get(),\n                                     &frame_decoded,\n                                     &packet);\n\n  if (result < 0) {\n    LOG(ERROR) << \"Error decoding a video frame with timestamp: \"\n               << buffer->GetTimestamp().InMicroseconds() << \" us, duration: \"\n               << buffer->GetDuration().InMicroseconds() << \" us, packet size: \"\n               << buffer->GetDataSize() << \" bytes\";\n    event_handler_->OnError();\n    return;\n  }\n\n  if (frame_decoded == 0) {\n    if (buffer->IsEndOfStream()) {  // We had started flushing.\n      event_handler_->ConsumeVideoFrame(video_frame, statistics);\n      output_eos_reached_ = true;\n    } else {\n      ReadInput();\n    }\n    return;\n  }\n\n  if (!av_frame_->data[VideoFrame::kYPlane] ||\n      !av_frame_->data[VideoFrame::kUPlane] ||\n      !av_frame_->data[VideoFrame::kVPlane]) {\n    event_handler_->OnError();\n    return;\n  }\n\n  DCHECK_LE(av_frame_->repeat_pict, 2);  // Sanity check.\n  AVRational doubled_time_base;\n  doubled_time_base.num = frame_rate_denominator_;\n  doubled_time_base.den = frame_rate_numerator_ * 2;\n\n  base::TimeDelta timestamp =\n      base::TimeDelta::FromMicroseconds(av_frame_->reordered_opaque);\n  base::TimeDelta duration =\n      ConvertFromTimeBase(doubled_time_base, 2 + av_frame_->repeat_pict);\n\n  DCHECK(frame_queue_available_.size());\n  video_frame = frame_queue_available_.front();\n  frame_queue_available_.pop_front();\n\n  size_t height = codec_context_->height;\n  CopyPlane(VideoFrame::kYPlane, video_frame.get(), av_frame_.get(), height);\n  CopyPlane(VideoFrame::kUPlane, video_frame.get(), av_frame_.get(), height);\n  CopyPlane(VideoFrame::kVPlane, video_frame.get(), av_frame_.get(), height);\n\n  video_frame->SetTimestamp(timestamp);\n  video_frame->SetDuration(duration);\n\n  pending_output_buffers_--;\n  event_handler_->ConsumeVideoFrame(video_frame, statistics);\n}\n",
        "output": "0",
        "index": 103231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int UnpackWPG2Raster(Image *image,int bpp)\n{\n  int XorMe = 0;\n\n  int\n    RunCount;\n\n  size_t\n    x,\n    y;\n\n  ssize_t\n    i,\n    ldblk;\n\n  unsigned int\n    SampleSize=1;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    SampleBuffer[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  x=0;\n  y=0;\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));\n  if(BImgBuff==NULL)\n    return(-2);\n\n  while( y< image->rows)\n    {\n      bbuf=ReadBlobByte(image);\n\n      switch(bbuf)\n        {\n        case 0x7D:\n          SampleSize=ReadBlobByte(image);  /* DSZ */\n          if(SampleSize>8)\n            return(-2);\n          if(SampleSize<1)\n            return(-2);\n          break;\n        case 0x7E:\n          (void) FormatLocaleFile(stderr,\n            \"\\nUnsupported WPG token XOR, please report!\");\n          XorMe=!XorMe;\n          break;\n        case 0x7F:\n          RunCount=ReadBlobByte(image);   /* BLK */\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0);\n            }\n          break;\n        case 0xFD:\n          RunCount=ReadBlobByte(image);   /* EXT */\n          for(i=0; i<= RunCount;i++)\n            for(bbuf=0; bbuf < SampleSize; bbuf++)\n              InsertByte6(SampleBuffer[bbuf]);\n          break;\n        case 0xFE:\n          RunCount=ReadBlobByte(image);  /* RST */\n          if(x!=0)\n            {\n              (void) FormatLocaleFile(stderr,\n                \"\\nUnsupported WPG2 unaligned token RST x=%.20g, please report!\\n\"\n                ,(double) x);\n              return(-3);\n            }\n          {\n            /* duplicate the previous row RunCount x */\n            for(i=0;i<=RunCount;i++)\n              {\n                InsertRow(BImgBuff,(ssize_t) (image->rows >= y ? y : image->rows-1),\n                          image,bpp);\n                y++;\n              }\n          }\n          break;\n        case 0xFF:\n          RunCount=ReadBlobByte(image);   /* WHT */\n          for (i=0; i < SampleSize*(RunCount+1); i++)\n          {\n            InsertByte6(0xFF);\n          }\n          break;\n        default:\n          RunCount=bbuf & 0x7F;\n\n          if(bbuf & 0x80)     /* REP */\n            {\n              for(i=0; i < SampleSize; i++)\n                SampleBuffer[i]=ReadBlobByte(image);\n              for(i=0;i<=RunCount;i++)\n                for(bbuf=0;bbuf<SampleSize;bbuf++)\n                  InsertByte6(SampleBuffer[bbuf]);\n            }\n          else {      /* NRP */\n            for(i=0; i< SampleSize*(RunCount+1);i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte6(bbuf);\n              }\n          }\n        }\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(0);\n}\n",
        "output": "0",
        "index": 71853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gx_parse_output_format(gs_parsed_file_name_t *pfn, const char **pfmt)\n{\n    bool have_format = false, field;\n    int width[2], int_width = sizeof(int) * 3, w = 0;\n    uint i;\n\n    /* Scan the file name for a format string, and validate it if present. */\n    width[0] = width[1] = 0;\n    for (i = 0; i < pfn->len; ++i)\n        if (pfn->fname[i] == '%') {\n            if (i + 1 < pfn->len && pfn->fname[i + 1] == '%') {\n                i++;\n                continue;\n            }\n            if (have_format)\t/* more than one % */\n                return_error(gs_error_undefinedfilename);\n            have_format = true;\n            field = -1; /* -1..3 for the 5 components of \"%[flags][width][.precision][l]type\" */\n            for (;;)\n                if (++i == pfn->len)\n                    return_error(gs_error_undefinedfilename);\n                else {\n                    switch (field) {\n                        case -1: /* flags */\n                            if (strchr(\" #+-\", pfn->fname[i]))\n                                continue;\n                            else\n                                field++;\n                            /* falls through */\n                        default: /* width (field = 0) and precision (field = 1) */\n                            if (strchr(\"0123456789\", pfn->fname[i])) {\n                                width[field] = width[field] * 10 + pfn->fname[i] - '0';\n                                continue;\n                            } else if (0 == field && '.' == pfn->fname[i]) {\n                                field++;\n                                continue;\n                            } else\n                                field = 2;\n                            /* falls through */\n                        case 2: /* \"long\" indicator */\n                            field++;\n                            if ('l' == pfn->fname[i]) {\n                                int_width = sizeof(long) * 3;\n                                continue;\n                            }\n                            /* falls through */\n                        case 3: /* type */\n                            if (strchr(\"diuoxX\", pfn->fname[i])) {\n                                *pfmt = &pfn->fname[i];\n                                break;\n                            } else\n                                return_error(gs_error_undefinedfilename);\n                    }\n                    break;\n                }\n        }\n    if (have_format) {\n        /* Calculate a conservative maximum width. */\n        w = max(width[0], width[1]);\n        w = max(w, int_width) + 5;\n    }\n    return w;\n}\n",
        "output": "0",
        "index": 2826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static StringInfo *ParseImageResourceBlocks(Image *image,\n  const unsigned char *blocks,size_t length,\n  MagickBooleanType *has_merged_image,ExceptionInfo *exception)\n{\n  const unsigned char\n    *p;\n\n  ssize_t\n    offset;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    name_length;\n\n  unsigned int\n    count;\n\n  unsigned short\n    id,\n    short_sans;\n\n  if (length < 16)\n    return((StringInfo *) NULL);\n  profile=BlobToStringInfo((const unsigned char *) NULL,length);\n  SetStringInfoDatum(profile,blocks);\n  SetStringInfoName(profile,\"8bim\");\n  for (p=blocks; (p >= blocks) && (p < (blocks+length-7)); )\n  {\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushCharPixel(p,&name_length);\n    if ((name_length % 2) == 0)\n      name_length++;\n    p+=name_length;\n    if (p > (blocks+length-4))\n      break;\n    p=PushLongPixel(MSBEndian,p,&count);\n    offset=(ssize_t) count;\n    if (((p+offset) < blocks) || ((p+offset) > (blocks+length)))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        char\n          value[MagickPathExtent];\n\n        unsigned short\n          resolution;\n\n        /*\n          Resolution info.\n        */\n        if (offset < 16)\n          break;\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.x=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n          image->resolution.x);\n        (void) SetImageProperty(image,\"tiff:XResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&resolution);\n        image->resolution.y=(double) resolution;\n        (void) FormatLocaleString(value,MagickPathExtent,\"%g\",\n          image->resolution.y);\n        (void) SetImageProperty(image,\"tiff:YResolution\",value,exception);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        p=PushShortPixel(MSBEndian,p,&short_sans);\n        image->units=PixelsPerInchResolution;\n        break;\n      }\n      case 0x0421:\n      {\n        if ((offset > 4) && (*(p+4) == 0))\n          *has_merged_image=MagickFalse;\n        p+=offset;\n        break;\n      }\n      default:\n      {\n        p+=offset;\n        break;\n      }\n    }\n    if ((offset & 0x01) != 0)\n      p++;\n  }\n  return(profile);\n}\n",
        "output": "0",
        "index": 91365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_mmap_event(struct perf_mmap_event *mmap_event)\n{\n\tstruct vm_area_struct *vma = mmap_event->vma;\n\tstruct file *file = vma->vm_file;\n\tint maj = 0, min = 0;\n\tu64 ino = 0, gen = 0;\n\tu32 prot = 0, flags = 0;\n\tunsigned int size;\n\tchar tmp[16];\n\tchar *buf = NULL;\n\tchar *name;\n\n\tif (vma->vm_flags & VM_READ)\n\t\tprot |= PROT_READ;\n\tif (vma->vm_flags & VM_WRITE)\n\t\tprot |= PROT_WRITE;\n\tif (vma->vm_flags & VM_EXEC)\n\t\tprot |= PROT_EXEC;\n\n\tif (vma->vm_flags & VM_MAYSHARE)\n\t\tflags = MAP_SHARED;\n\telse\n\t\tflags = MAP_PRIVATE;\n\n\tif (vma->vm_flags & VM_DENYWRITE)\n\t\tflags |= MAP_DENYWRITE;\n\tif (vma->vm_flags & VM_MAYEXEC)\n\t\tflags |= MAP_EXECUTABLE;\n\tif (vma->vm_flags & VM_LOCKED)\n\t\tflags |= MAP_LOCKED;\n\tif (vma->vm_flags & VM_HUGETLB)\n\t\tflags |= MAP_HUGETLB;\n\n\tif (file) {\n\t\tstruct inode *inode;\n\t\tdev_t dev;\n\n\t\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tname = \"//enomem\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\t/*\n\t\t * d_path() works from the end of the rb backwards, so we\n\t\t * need to add enough zero bytes after the string to handle\n\t\t * the 64bit alignment we do later.\n\t\t */\n\t\tname = file_path(file, buf, PATH_MAX - sizeof(u64));\n\t\tif (IS_ERR(name)) {\n\t\t\tname = \"//toolong\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\tinode = file_inode(vma->vm_file);\n\t\tdev = inode->i_sb->s_dev;\n\t\tino = inode->i_ino;\n\t\tgen = inode->i_generation;\n\t\tmaj = MAJOR(dev);\n\t\tmin = MINOR(dev);\n\n\t\tgoto got_name;\n\t} else {\n\t\tif (vma->vm_ops && vma->vm_ops->name) {\n\t\t\tname = (char *) vma->vm_ops->name(vma);\n\t\t\tif (name)\n\t\t\t\tgoto cpy_name;\n\t\t}\n\n\t\tname = (char *)arch_vma_name(vma);\n\t\tif (name)\n\t\t\tgoto cpy_name;\n\n\t\tif (vma->vm_start <= vma->vm_mm->start_brk &&\n\t\t\t\tvma->vm_end >= vma->vm_mm->brk) {\n\t\t\tname = \"[heap]\";\n\t\t\tgoto cpy_name;\n\t\t}\n\t\tif (vma->vm_start <= vma->vm_mm->start_stack &&\n\t\t\t\tvma->vm_end >= vma->vm_mm->start_stack) {\n\t\t\tname = \"[stack]\";\n\t\t\tgoto cpy_name;\n\t\t}\n\n\t\tname = \"//anon\";\n\t\tgoto cpy_name;\n\t}\n\ncpy_name:\n\tstrlcpy(tmp, name, sizeof(tmp));\n\tname = tmp;\ngot_name:\n\t/*\n\t * Since our buffer works in 8 byte units we need to align our string\n\t * size to a multiple of 8. However, we must guarantee the tail end is\n\t * zero'd out to avoid leaking random bits to userspace.\n\t */\n\tsize = strlen(name)+1;\n\twhile (!IS_ALIGNED(size, sizeof(u64)))\n\t\tname[size++] = '\\0';\n\n\tmmap_event->file_name = name;\n\tmmap_event->file_size = size;\n\tmmap_event->maj = maj;\n\tmmap_event->min = min;\n\tmmap_event->ino = ino;\n\tmmap_event->ino_generation = gen;\n\tmmap_event->prot = prot;\n\tmmap_event->flags = flags;\n\n\tif (!(vma->vm_flags & VM_EXEC))\n\t\tmmap_event->event_id.header.misc |= PERF_RECORD_MISC_MMAP_DATA;\n\n\tmmap_event->event_id.header.size = sizeof(mmap_event->event_id) + size;\n\n\tperf_iterate_sb(perf_event_mmap_output,\n\t\t       mmap_event,\n\t\t       NULL);\n\n\tkfree(buf);\n}\n",
        "output": "0",
        "index": 85223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n#ifdef SAVE_ON_FLASH\n  jsiConsolePrint(\"Trace unimplemented in this version.\\n\");\n#else\n  int i;\n  for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n\n  if (!var) {\n    jsiConsolePrint(\"undefined\");\n    return;\n  }\n\n  jsvTraceLockInfo(var);\n\n  int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var);\n  if (lowestLevel < level) {\n    jsiConsolePrint(\"...\\n\");\n    return;\n  }\n\n  if (jsvIsName(var)) jsiConsolePrint(\"Name \");\n\n  char endBracket = ' ';\n  if (jsvIsObject(var)) { jsiConsolePrint(\"Object { \"); endBracket = '}'; }\n  else if (jsvIsArray(var)) { jsiConsolePrintf(\"Array(%d) [ \", var->varData.integer); endBracket = ']'; }\n  else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(\"NativeFunction 0x%x (%d) { \", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; }\n  else if (jsvIsFunction(var)) {\n    jsiConsolePrint(\"Function { \");\n    if (jsvIsFunctionReturn(var)) jsiConsolePrint(\"return \");\n    endBracket = '}';\n  } else if (jsvIsPin(var)) jsiConsolePrintf(\"Pin %d\", jsvGetInteger(var));\n  else if (jsvIsInt(var)) jsiConsolePrintf(\"Integer %d\", jsvGetInteger(var));\n  else if (jsvIsBoolean(var)) jsiConsolePrintf(\"Bool %s\", jsvGetBool(var)?\"true\":\"false\");\n   else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)); // way to get nice name\n   else if (jsvIsString(var)) {\n     size_t blocks = 1;\n     if (jsvGetLastChild(var)) {\n      JsVar *v = jsvLock(jsvGetLastChild(var));\n      blocks += jsvCountJsVarsUsed(v);\n      jsvUnLock(v);\n    }\n    if (jsvIsFlatString(var)) {\n      blocks += jsvGetFlatStringBlocks(var);\n    }\n    jsiConsolePrintf(\"%sString [%d blocks] %q\", jsvIsFlatString(var)?\"Flat\":(jsvIsNativeString(var)?\"Native\":\"\"), blocks, var);\n  } else {\n    jsiConsolePrintf(\"Unknown %d\", var->flags & (JsVarFlags)~(JSV_LOCK_MASK));\n  }\n\n  if (jsvIsNameInt(var)) {\n    jsiConsolePrintf(\"= int %d\\n\", (int)jsvGetFirstChildSigned(var));\n    return;\n  } else if (jsvIsNameIntBool(var)) {\n    jsiConsolePrintf(\"= bool %s\\n\", jsvGetFirstChild(var)?\"true\":\"false\");\n    return;\n  }\n\n  if (jsvHasSingleChild(var)) {\n    JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0;\n    _jsvTrace(child, indent+2, baseVar, level+1);\n    jsvUnLock(child);\n  } else if (jsvHasChildren(var)) {\n    JsvIterator it;\n    jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS);\n    bool first = true;\n    while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) {\n      if (first) jsiConsolePrintf(\"\\n\");\n      first = false;\n      JsVar *child = jsvIteratorGetKey(&it);\n      _jsvTrace(child, indent+2, baseVar, level+1);\n      jsvUnLock(child);\n      jsiConsolePrintf(\"\\n\");\n      jsvIteratorNext(&it);\n    }\n    jsvIteratorFree(&it);\n    if (!first)\n      for (i=0;i<indent;i++) jsiConsolePrint(\" \");\n  }\n  jsiConsolePrintf(\"%c\", endBracket);\n#endif\n}\n",
        "output": "1",
        "index": 182389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n \tgfp_t gfp_mask;\n \tlong timeo;\n \tint err;\n \n \tgfp_mask = sk->sk_allocation;\n \tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n \t\t\tskb = alloc_skb(header_len, gfp_mask);\n \t\t\tif (skb) {\n\t\t\t\tint npages;\n \t\t\t\tint i;\n \n \t\t\t\t/* No pages, we're done... */\n \t\t\t\tif (!data_len)\n \t\t\t\t\tbreak;\n \n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n \t\t\t\tskb->truesize += data_len;\n \t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n \t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\t\tgoto failure;\n\t\t\t\t\t}\n\n\t\t\t\t\t__skb_fill_page_desc(skb, i,\n\t\t\t\t\t\t\tpage, 0,\n\t\t\t\t\t\t\t(data_len >= PAGE_SIZE ?\n\t\t\t\t\t\t\t PAGE_SIZE :\n\t\t\t\t\t\t\t data_len));\n\t\t\t\t\tdata_len -= PAGE_SIZE;\n\t\t\t\t}\n\n\t\t\t\t/* Full success... */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto failure;\n\t\t}\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto failure;\n\t\tif (signal_pending(current))\n\t\t\tgoto interrupted;\n\t\ttimeo = sock_wait_for_wmem(sk, timeo);\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\treturn skb;\n\ninterrupted:\n\terr = sock_intr_errno(timeo);\nfailure:\n\t*errcode = err;\n\treturn NULL;\n}\n",
        "output": "1",
        "index": 178774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nvmet_fc_rcv_fcp_req(struct nvmet_fc_target_port *target_port,\n\t\t\tstruct nvmefc_tgt_fcp_req *fcpreq,\n\t\t\tvoid *cmdiubuf, u32 cmdiubuf_len)\n{\n\tstruct nvmet_fc_tgtport *tgtport = targetport_to_tgtport(target_port);\n\tstruct nvme_fc_cmd_iu *cmdiu = cmdiubuf;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tstruct nvmet_fc_fcp_iod *fod;\n\tstruct nvmet_fc_defer_fcp_req *deferfcp;\n\tunsigned long flags;\n\n\t/* validate iu, so the connection id can be used to find the queue */\n\tif ((cmdiubuf_len != sizeof(*cmdiu)) ||\n\t\t\t(cmdiu->scsi_id != NVME_CMD_SCSI_ID) ||\n\t\t\t(cmdiu->fc_id != NVME_CMD_FC_ID) ||\n\t\t\t(be16_to_cpu(cmdiu->iu_len) != (sizeof(*cmdiu)/4)))\n\t\treturn -EIO;\n\n\tqueue = nvmet_fc_find_target_queue(tgtport,\n\t\t\t\tbe64_to_cpu(cmdiu->connection_id));\n\tif (!queue)\n\t\treturn -ENOTCONN;\n\n\t/*\n\t * note: reference taken by find_target_queue\n\t * After successful fod allocation, the fod will inherit the\n\t * ownership of that reference and will remove the reference\n\t * when the fod is freed.\n\t */\n\n\tspin_lock_irqsave(&queue->qlock, flags);\n\n\tfod = nvmet_fc_alloc_fcp_iod(queue);\n\tif (fod) {\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\n\t\tfcpreq->nvmet_fc_private = fod;\n\t\tfod->fcpreq = fcpreq;\n\n\t\tmemcpy(&fod->cmdiubuf, cmdiubuf, cmdiubuf_len);\n\n\t\tnvmet_fc_queue_fcp_req(tgtport, queue, fcpreq);\n\n\t\treturn 0;\n\t}\n\n\tif (!tgtport->ops->defer_rcv) {\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\t\t/* release the queue lookup reference */\n\t\tnvmet_fc_tgt_q_put(queue);\n\t\treturn -ENOENT;\n\t}\n\n\tdeferfcp = list_first_entry_or_null(&queue->avail_defer_list,\n\t\t\tstruct nvmet_fc_defer_fcp_req, req_list);\n\tif (deferfcp) {\n\t\t/* Just re-use one that was previously allocated */\n\t\tlist_del(&deferfcp->req_list);\n\t} else {\n\t\tspin_unlock_irqrestore(&queue->qlock, flags);\n\n\t\t/* Now we need to dynamically allocate one */\n\t\tdeferfcp = kmalloc(sizeof(*deferfcp), GFP_KERNEL);\n\t\tif (!deferfcp) {\n\t\t\t/* release the queue lookup reference */\n\t\t\tnvmet_fc_tgt_q_put(queue);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tspin_lock_irqsave(&queue->qlock, flags);\n\t}\n\n\t/* For now, use rspaddr / rsplen to save payload information */\n\tfcpreq->rspaddr = cmdiubuf;\n\tfcpreq->rsplen  = cmdiubuf_len;\n\tdeferfcp->fcp_req = fcpreq;\n\n\t/* defer processing till a fod becomes available */\n\tlist_add_tail(&deferfcp->req_list, &queue->pending_cmd_list);\n\n\t/* NOTE: the queue lookup reference is still valid */\n\n\tspin_unlock_irqrestore(&queue->qlock, flags);\n\n\treturn -EOVERFLOW;\n}\n",
        "output": "0",
        "index": 93629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_inode_ag_walk(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args,\n\tint\t\t\ttag,\n\tint\t\t\titer_flags)\n{\n\tuint32_t\t\tfirst_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tdone;\n\tint\t\t\tnr_found;\n\nrestart:\n\tdone = 0;\n\tskipped = 0;\n\tfirst_index = 0;\n\tnr_found = 0;\n\tdo {\n\t\tstruct xfs_inode *batch[XFS_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\trcu_read_lock();\n\n\t\tif (tag == -1)\n\t\t\tnr_found = radix_tree_gang_lookup(&pag->pag_ici_root,\n\t\t\t\t\t(void **)batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH);\n\t\telse\n\t\t\tnr_found = radix_tree_gang_lookup_tag(\n\t\t\t\t\t&pag->pag_ici_root,\n\t\t\t\t\t(void **) batch, first_index,\n\t\t\t\t\tXFS_LOOKUP_BATCH, tag);\n\n\t\tif (!nr_found) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Grab the inodes before we drop the lock. if we found\n\t\t * nothing, nr == 0 and the loop will be skipped.\n\t\t */\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_inode *ip = batch[i];\n\n\t\t\tif (done || xfs_inode_ag_walk_grab(ip, iter_flags))\n\t\t\t\tbatch[i] = NULL;\n\n\t\t\t/*\n\t\t\t * Update the index for the next lookup. Catch\n\t\t\t * overflows into the next AG range which can occur if\n\t\t\t * we have inodes in the last block of the AG and we\n\t\t\t * are currently pointing to the last inode.\n\t\t\t *\n\t\t\t * Because we may see inodes that are from the wrong AG\n\t\t\t * due to RCU freeing and reallocation, only update the\n\t\t\t * index if it lies in this AG. It was a race that lead\n\t\t\t * us to see this inode, so another lookup from the\n\t\t\t * same index will not find it again.\n\t\t\t */\n\t\t\tif (XFS_INO_TO_AGNO(mp, ip->i_ino) != pag->pag_agno)\n\t\t\t\tcontinue;\n\t\t\tfirst_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);\n\t\t\tif (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino))\n\t\t\t\tdone = 1;\n\t\t}\n\n\t\t/* unlock now we've grabbed the inodes. */\n\t\trcu_read_unlock();\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tif (!batch[i])\n\t\t\t\tcontinue;\n\t\t\tif ((iter_flags & XFS_AGITER_INEW_WAIT) &&\n\t\t\t    xfs_iflags_test(batch[i], XFS_INEW))\n\t\t\t\txfs_inew_wait(batch[i]);\n\t\t\terror = execute(batch[i], flags, args);\n\t\t\tIRELE(batch[i]);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (error == -EFSCORRUPTED)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\n\t} while (nr_found && !done);\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\treturn last_error;\n}\n",
        "output": "0",
        "index": 79957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __dev_queue_xmit(struct sk_buff *skb, void *accel_priv)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct netdev_queue *txq;\n\tstruct Qdisc *q;\n\tint rc = -ENOMEM;\n\n\tskb_reset_mac_header(skb);\n\n\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_SCHED_TSTAMP))\n\t\t__skb_tstamp_tx(skb, NULL, skb->sk, SCM_TSTAMP_SCHED);\n\n\t/* Disable soft irqs for various locks below. Also\n\t * stops preemption for RCU.\n\t */\n\trcu_read_lock_bh();\n\n\tskb_update_prio(skb);\n\n\tqdisc_pkt_len_init(skb);\n#ifdef CONFIG_NET_CLS_ACT\n\tskb->tc_at_ingress = 0;\n# ifdef CONFIG_NET_EGRESS\n\tif (static_key_false(&egress_needed)) {\n\t\tskb = sch_handle_egress(skb, &rc, dev);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t}\n# endif\n#endif\n\t/* If device/qdisc don't need skb->dst, release it right now while\n\t * its hot in this cpu cache.\n\t */\n\tif (dev->priv_flags & IFF_XMIT_DST_RELEASE)\n\t\tskb_dst_drop(skb);\n\telse\n\t\tskb_dst_force(skb);\n\n\ttxq = netdev_pick_tx(dev, skb, accel_priv);\n\tq = rcu_dereference_bh(txq->qdisc);\n\n\ttrace_net_dev_queue(skb);\n\tif (q->enqueue) {\n\t\trc = __dev_xmit_skb(skb, q, dev, txq);\n\t\tgoto out;\n\t}\n\n\t/* The device has no queue. Common case for software devices:\n\t * loopback, all the sorts of tunnels...\n\n\t * Really, it is unlikely that netif_tx_lock protection is necessary\n\t * here.  (f.e. loopback and IP tunnels are clean ignoring statistics\n\t * counters.)\n\t * However, it is possible, that they rely on protection\n\t * made by us here.\n\n\t * Check this and shot the lock. It is not prone from deadlocks.\n\t *Either shot noqueue qdisc, it is even simpler 8)\n\t */\n\tif (dev->flags & IFF_UP) {\n\t\tint cpu = smp_processor_id(); /* ok because BHs are off */\n\n\t\tif (txq->xmit_lock_owner != cpu) {\n\t\t\tif (unlikely(__this_cpu_read(xmit_recursion) >\n\t\t\t\t     XMIT_RECURSION_LIMIT))\n\t\t\t\tgoto recursion_alert;\n\n\t\t\tskb = validate_xmit_skb(skb, dev);\n\t\t\tif (!skb)\n\t\t\t\tgoto out;\n\n\t\t\tHARD_TX_LOCK(dev, txq, cpu);\n\n\t\t\tif (!netif_xmit_stopped(txq)) {\n\t\t\t\t__this_cpu_inc(xmit_recursion);\n\t\t\t\tskb = dev_hard_start_xmit(skb, dev, txq, &rc);\n\t\t\t\t__this_cpu_dec(xmit_recursion);\n\t\t\t\tif (dev_xmit_complete(rc)) {\n\t\t\t\t\tHARD_TX_UNLOCK(dev, txq);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tHARD_TX_UNLOCK(dev, txq);\n\t\t\tnet_crit_ratelimited(\"Virtual device %s asks to queue packet!\\n\",\n\t\t\t\t\t     dev->name);\n\t\t} else {\n\t\t\t/* Recursion is detected! It is possible,\n\t\t\t * unfortunately\n\t\t\t */\nrecursion_alert:\n\t\t\tnet_crit_ratelimited(\"Dead loop on virtual device %s, fix it urgently!\\n\",\n\t\t\t\t\t     dev->name);\n\t\t}\n\t}\n\n\trc = -ENETDOWN;\n\trcu_read_unlock_bh();\n\n\tatomic_long_inc(&dev->tx_dropped);\n\tkfree_skb_list(skb);\n\treturn rc;\nout:\n\trcu_read_unlock_bh();\n\treturn rc;\n}\n",
        "output": "0",
        "index": 93345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void capa_response(int flags)\n{\n    const char *sasllist; /* the list of SASL mechanisms */\n    int mechcount;\n    int need_space = 0;\n    int i;\n\n    int lminus = config_getswitch(IMAPOPT_LITERALMINUS);\n\n    for (i = 0; base_capabilities[i].str; i++) {\n        const char *capa = base_capabilities[i].str;\n        /* Filter capabilities if requested */\n        if (capa_is_disabled(capa))\n            continue;\n        /* Don't show \"MAILBOX-REFERRALS\" if disabled by config */\n        if (config_getswitch(IMAPOPT_PROXYD_DISABLE_MAILBOX_REFERRALS) &&\n            !strcmp(capa, \"MAILBOX-REFERRALS\"))\n            continue;\n        /* Don't show if they're not shown at this level of login */\n        if (!(base_capabilities[i].mask & flags))\n            continue;\n        /* cheap and nasty version of LITERAL- support - just say so */\n        if (lminus && !strcmp(capa, \"LITERAL+\"))\n            capa = \"LITERAL-\";\n        /* print the capability */\n        if (need_space) prot_putc(' ', imapd_out);\n        else need_space = 1;\n        prot_printf(imapd_out, \"%s\", base_capabilities[i].str);\n    }\n\n    if (config_mupdate_server) {\n        prot_printf(imapd_out, \" MUPDATE=mupdate://%s/\", config_mupdate_server);\n    }\n\n    if (apns_enabled) {\n        prot_printf(imapd_out, \" XAPPLEPUSHSERVICE\");\n    }\n\n    if (tls_enabled() && !imapd_starttls_done && !imapd_authstate) {\n        prot_printf(imapd_out, \" STARTTLS\");\n    }\n    if (imapd_tls_required || imapd_authstate ||\n        (!imapd_starttls_done && (extprops_ssf < 2) &&\n         !config_getswitch(IMAPOPT_ALLOWPLAINTEXT))) {\n        prot_printf(imapd_out, \" LOGINDISABLED\");\n    }\n\n    /* add the SASL mechs */\n    if (!imapd_tls_required && (!imapd_authstate || saslprops.ssf) &&\n        sasl_listmech(imapd_saslconn, NULL,\n                      \"AUTH=\", \" AUTH=\",\n                      !imapd_authstate ? \" SASL-IR\" : \"\", &sasllist,\n                      NULL, &mechcount) == SASL_OK && mechcount > 0) {\n        prot_printf(imapd_out, \" %s\", sasllist);\n    } else {\n        /* else don't show anything */\n    }\n\n    if (!(flags & CAPA_POSTAUTH)) return;\n\n    if (config_getswitch(IMAPOPT_CONVERSATIONS))\n        prot_printf(imapd_out, \" XCONVERSATIONS\");\n\n#ifdef HAVE_ZLIB\n    if (!imapd_compress_done && !imapd_tls_comp) {\n        prot_printf(imapd_out, \" COMPRESS=DEFLATE\");\n    }\n#endif // HAVE_ZLIB\n\n    for (i = 0 ; i < QUOTA_NUMRESOURCES ; i++)\n        prot_printf(imapd_out, \" X-QUOTA=%s\", quota_names[i]);\n\n    if (idle_enabled()) {\n        prot_printf(imapd_out, \" IDLE\");\n    }\n}\n",
        "output": "0",
        "index": 95126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned char * php_pgsql_unescape_bytea(unsigned char *strtext, size_t *retbuflen)\n{\n\tsize_t     buflen;\n\tunsigned char *buffer,\n\t\t\t   *sp,\n\t\t\t   *bp;\n\tunsigned int state = 0;\n\n\tif (strtext == NULL)\n\t\treturn NULL;\n\tbuflen = strlen(strtext);\t/* will shrink, also we discover if\n\t\t\t\t\t\t\t\t * strtext */\n\tbuffer = (unsigned char *) emalloc(buflen);\t/* isn't NULL terminated */\n\tfor (bp = buffer, sp = strtext; *sp != '\\0'; bp++, sp++)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tif (*sp == '\\\\')\n\t\t\t\t\tstate = 1;\n\t\t\t\t*bp = *sp;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (*sp == '\\'')\t/* state=5 */\n\t\t\t\t{\t\t\t\t/* replace \\' with 39 */\n\t\t\t\t\tbp--;\n\t\t\t\t\t*bp = '\\'';\n\t\t\t\t\tbuflen--;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse if (*sp == '\\\\')\t/* state=6 */\n\t\t\t\t{\t\t\t\t/* replace \\\\ with 92 */\n\t\t\t\t\tbp--;\n\t\t\t\t\t*bp = '\\\\';\n\t\t\t\t\tbuflen--;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isdigit(*sp))\n\t\t\t\t\t\tstate = 2;\n\t\t\t\t\telse\n\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t*bp = *sp;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (isdigit(*sp))\n\t\t\t\t\tstate = 3;\n\t\t\t\telse\n\t\t\t\t\tstate = 0;\n\t\t\t\t*bp = *sp;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (isdigit(*sp))\t\t/* state=4 */\n\t\t\t\t{\n\t\t\t\t\tunsigned char *start, *end, buf[4]; /* 000 + '\\0' */\n\t\t\t\t\t\n\t\t\t\t\tbp -= 3;\n\t\t\t\t\tmemcpy(buf, sp-2, 3);\n\t\t\t\t\tbuf[3] = '\\0';\n\t\t\t\t\tstart = buf;\n\t\t\t\t\t*bp = (unsigned char)strtoul(start, (char **)&end, 8);\n\t\t\t\t\tbuflen -= 3;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t*bp = *sp;\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tbuffer = erealloc(buffer, buflen+1);\n\tbuffer[buflen] = '\\0';\n\n\t*retbuflen = buflen;\n\treturn buffer;\n}\n",
        "output": "0",
        "index": 15245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\n \t/* Limit the size of the queue to prevent DOS attacks */\n \tif (pqueue_size(queue->q) >= 100)\n \t\treturn 0;\n \trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n \titem = pitem_new(priority, rdata);\n \tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\t\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\t\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\n\titem->data = rdata;\n\n#ifndef OPENSSL_NO_SCTP\n\t/* Store bio_dgram_sctp_rcvinfo struct */\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n \tif (!ssl3_setup_buffers(s))\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \n \t/* insert should not fail, since duplicates are dropped */\n \tif (pqueue_insert(queue->q, item) == NULL)\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \n \treturn(1);\n\t}\n",
        "output": "1",
        "index": 179917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType QuantizeImage(const QuantizeInfo *quantize_info,\n  Image *image)\n{\n  CubeInfo\n    *cube_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    depth,\n    maximum_colors;\n\n  assert(quantize_info != (const QuantizeInfo *) NULL);\n  assert(quantize_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  maximum_colors=quantize_info->number_colors;\n  if (maximum_colors == 0)\n    maximum_colors=MaxColormapSize;\n  if (maximum_colors > MaxColormapSize)\n    maximum_colors=MaxColormapSize;\n  if (image->matte == MagickFalse)\n    {\n      if (SetImageGray(image,&image->exception) != MagickFalse)\n        (void) SetGrayscaleImage(image);\n    }\n  if ((image->storage_class == PseudoClass) &&\n      (image->colors <= maximum_colors))\n    {\n      if ((quantize_info->colorspace != UndefinedColorspace) &&\n          (quantize_info->colorspace != CMYKColorspace))\n        (void) TransformImageColorspace(image,quantize_info->colorspace);\n      return(MagickTrue);\n    }\n  depth=quantize_info->tree_depth;\n  if (depth == 0)\n    {\n      size_t\n        colors;\n\n      /*\n        Depth of color tree is: Log4(colormap size)+2.\n      */\n      colors=maximum_colors;\n      for (depth=1; colors != 0; depth++)\n        colors>>=2;\n      if ((quantize_info->dither != MagickFalse) && (depth > 2))\n        depth--;\n      if ((image->matte != MagickFalse) && (depth > 5))\n        depth--;\n      if (SetImageGray(image,&image->exception) != MagickFalse)\n        depth=MaxTreeDepth;\n    }\n  /*\n    Initialize color cube.\n  */\n  cube_info=GetCubeInfo(quantize_info,depth,maximum_colors);\n  if (cube_info == (CubeInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=ClassifyImageColors(cube_info,image,&image->exception);\n  if (status != MagickFalse)\n    {\n      /*\n        Reduce the number of colors in the image if it contains more than the\n        maximum, otherwise we can disable dithering to improve the performance.\n      */\n      if (cube_info->colors > cube_info->maximum_colors)\n        ReduceImageColors(image,cube_info);\n      else\n        cube_info->quantize_info->dither_method=NoDitherMethod;\n      status=AssignImageColors(image,cube_info);\n    }\n  DestroyCubeInfo(cube_info);\n  return(status);\n}\n",
        "output": "0",
        "index": 62722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SkBlendMode PropertyTreeManager::SynthesizeCcEffectsForClipsIfNeeded(\n    const ClipPaintPropertyNode* target_clip,\n    SkBlendMode delegated_blend,\n    bool effect_is_newly_built) {\n  if (delegated_blend != SkBlendMode::kSrcOver) {\n    while (IsCurrentCcEffectSynthetic())\n      CloseCcEffect();\n\n    GetEffectTree().Node(current_effect_id_)->has_render_surface = true;\n  } else {\n    const auto& lca = LowestCommonAncestor(*current_clip_, *target_clip);\n    while (current_clip_ != &lca) {\n      DCHECK(IsCurrentCcEffectSynthetic());\n      const auto* pre_exit_clip = current_clip_;\n      CloseCcEffect();\n      if (IsNodeOnAncestorChain(lca, *pre_exit_clip, *current_clip_))\n        break;\n    }\n\n    if (!effect_is_newly_built && !IsCurrentCcEffectSynthetic() &&\n        current_effect_->Opacity() != 1.f)\n      GetEffectTree().Node(current_effect_id_)->has_render_surface = true;\n  }\n\n  DCHECK(current_clip_->IsAncestorOf(*target_clip));\n\n  Vector<const ClipPaintPropertyNode*> pending_clips;\n  for (; target_clip != current_clip_; target_clip = target_clip->Parent()) {\n    DCHECK(target_clip);\n    bool should_synthesize =\n        target_clip->ClipRect().IsRounded() || target_clip->ClipPath();\n    if (should_synthesize)\n      pending_clips.push_back(target_clip);\n  }\n\n  for (size_t i = pending_clips.size(); i--;) {\n    const ClipPaintPropertyNode* next_clip = pending_clips[i];\n\n    cc::EffectNode& mask_isolation = *GetEffectTree().Node(\n        GetEffectTree().Insert(cc::EffectNode(), current_effect_id_));\n    mask_isolation.clip_id = EnsureCompositorClipNode(next_clip);\n    mask_isolation.has_render_surface = true;\n    DCHECK(delegated_blend != SkBlendMode::kDstIn);\n    mask_isolation.blend_mode = delegated_blend;\n    delegated_blend = SkBlendMode::kSrcOver;\n\n    effect_stack_.emplace_back(\n        EffectStackEntry{current_effect_id_, current_effect_type_,\n                         current_effect_, current_clip_});\n    current_effect_id_ = mask_isolation.id;\n    current_effect_type_ = CcEffectType::kSynthesizedClip;\n    current_clip_ = next_clip;\n  }\n\n  return delegated_blend;\n}\n",
        "output": "0",
        "index": 136482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sys_debug_setcontext(struct ucontext __user *ctx,\n\t\t\t int ndbg, struct sig_dbg_op __user *dbg,\n\t\t\t int r6, int r7, int r8,\n\t\t\t struct pt_regs *regs)\n{\n\tstruct sig_dbg_op op;\n\tint i;\n\tunsigned char tmp;\n\tunsigned long new_msr = regs->msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tunsigned long new_dbcr0 = current->thread.debug.dbcr0;\n#endif\n\n\tfor (i=0; i<ndbg; i++) {\n\t\tif (copy_from_user(&op, dbg + i, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tswitch (op.dbg_type) {\n\t\tcase SIG_DBG_SINGLE_STEPPING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tif (op.dbg_value) {\n\t\t\t\tnew_msr |= MSR_DE;\n\t\t\t\tnew_dbcr0 |= (DBCR0_IDM | DBCR0_IC);\n\t\t\t} else {\n\t\t\t\tnew_dbcr0 &= ~DBCR0_IC;\n\t\t\t\tif (!DBCR_ACTIVE_EVENTS(new_dbcr0,\n\t\t\t\t\t\tcurrent->thread.debug.dbcr1)) {\n\t\t\t\t\tnew_msr &= ~MSR_DE;\n\t\t\t\t\tnew_dbcr0 &= ~DBCR0_IDM;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_SE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_SE;\n#endif\n\t\t\tbreak;\n\t\tcase SIG_DBG_BRANCH_TRACING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\treturn -EINVAL;\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_BE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_BE;\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* We wait until here to actually install the values in the\n\t   registers so if we fail in the above loop, it will not\n\t   affect the contents of these registers.  After this point,\n\t   failure is a problem, anyway, and it's very unlikely unless\n\t   the user is really doing something wrong. */\n\tregs->msr = new_msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tcurrent->thread.debug.dbcr0 = new_dbcr0;\n#endif\n\n\tif (!access_ok(VERIFY_READ, ctx, sizeof(*ctx))\n\t    || __get_user(tmp, (u8 __user *) ctx)\n\t    || __get_user(tmp, (u8 __user *) (ctx + 1) - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(ctx, regs, 1)) {\n\t\tif (show_unhandled_signals)\n\t\t\tprintk_ratelimited(KERN_INFO \"%s[%d]: bad frame in \"\n\t\t\t\t\t   \"sys_debug_setcontext: %p nip %08lx \"\n\t\t\t\t\t   \"lr %08lx\\n\",\n\t\t\t\t\t   current->comm, current->pid,\n\t\t\t\t\t   ctx, regs->nip, regs->link);\n\n\t\tforce_sig(SIGSEGV, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n\trestore_altstack(&ctx->uc_stack);\n\n\tset_thread_flag(TIF_RESTOREALL);\n out:\n\treturn 0;\n}\n",
        "output": "0",
        "index": 56486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setcieaspace(i_ctx_t * i_ctx_p, ref *r, int *stage, int *cont, int CIESubst)\n{\n    int code = 0;\n    ref CIEDict, *nocie;\n    ulong dictkey;\n    gs_md5_state_t md5;\n    byte key[16];\n\n    if (i_ctx_p->language_level < 2)\n        return_error(gs_error_undefined);\n\n    code = dict_find_string(systemdict, \"NOCIE\", &nocie);\n    if (code > 0) {\n        if (!r_has_type(nocie, t_boolean))\n            return_error(gs_error_typecheck);\n        if (nocie->value.boolval)\n            return setgrayspace(i_ctx_p, r, stage, cont, 1);\n    }\n\n    *cont = 0;\n    code = array_get(imemory, r, 1, &CIEDict);\n    if (code < 0)\n        return code;\n    if ((*stage) > 0) {\n        gs_client_color cc;\n\n        cc.pattern = 0x00;\n        cc.paint.values[0] = 0;\n        code = gs_setcolor(igs, &cc);\n        *stage = 0;\n        return code;\n    }\n    gs_md5_init(&md5);\n    /* If the hash (dictkey) is 0, we don't check for an existing\n     * ICC profile dor this space. So if we get an error hashing\n     * the space, we construct a new profile.\n     */\n    dictkey = 0;\n    if (hashcieaspace(i_ctx_p, r, &md5)) {\n        /* Ideally we would use the whole md5 hash, but the ICC code only\n         * expects a long. I'm 'slightly' concerned about collisions here\n         * but I think its unlikely really. If it ever becomes a problem\n         * we could add the hash bytes up, or modify the ICC cache to store\n         * the full 16 byte hashs.\n         */\n        gs_md5_finish(&md5, key);\n        dictkey = *(ulong *)&key[sizeof(key) - sizeof(ulong)];\n    } else {\n        gs_md5_finish(&md5, key);\n    }\n    code = cieaspace(i_ctx_p, &CIEDict, dictkey);\n    (*stage)++;\n    *cont = 1;\n    return code;\n}\n",
        "output": "0",
        "index": 3136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_load_fit_image(struct spl_load_info *info, ulong sector,\n\t\t\t      void *fit, ulong base_offset, int node,\n\t\t\t      struct spl_image_info *image_info)\n{\n\tint offset;\n\tsize_t length;\n\tint len;\n\tulong size;\n\tulong load_addr, load_ptr;\n\tvoid *src;\n\tulong overhead;\n\tint nr_sectors;\n\tint align_len = ARCH_DMA_MINALIGN - 1;\n\tuint8_t image_comp = -1, type = -1;\n\tconst void *data;\n\tbool external_data = false;\n\n\tif (IS_ENABLED(CONFIG_SPL_FPGA_SUPPORT) ||\n\t    (IS_ENABLED(CONFIG_SPL_OS_BOOT) && IS_ENABLED(CONFIG_SPL_GZIP))) {\n\t\tif (fit_image_get_type(fit, node, &type))\n\t\t\tputs(\"Cannot get image type.\\n\");\n\t\telse\n \t\t\tdebug(\"%s \", genimg_get_type_name(type));\n \t}\n \n\tif (IS_ENABLED(CONFIG_SPL_OS_BOOT) && IS_ENABLED(CONFIG_SPL_GZIP)) {\n\t\tif (fit_image_get_comp(fit, node, &image_comp))\n\t\t\tputs(\"Cannot get image compression format.\\n\");\n\t\telse\n\t\t\tdebug(\"%s \", genimg_get_comp_name(image_comp));\n \t}\n \n \tif (fit_image_get_load(fit, node, &load_addr))\n\t\tload_addr = image_info->load_addr;\n\n\tif (!fit_image_get_data_position(fit, node, &offset)) {\n\t\texternal_data = true;\n\t} else if (!fit_image_get_data_offset(fit, node, &offset)) {\n\t\toffset += base_offset;\n\t\texternal_data = true;\n\t}\n\n\tif (external_data) {\n\t\t/* External data */\n\t\tif (fit_image_get_data_size(fit, node, &len))\n\t\t\treturn -ENOENT;\n\n\t\tload_ptr = (load_addr + align_len) & ~align_len;\n\t\tlength = len;\n\n\t\toverhead = get_aligned_image_overhead(info, offset);\n\t\tnr_sectors = get_aligned_image_size(info, length, offset);\n\n\t\tif (info->read(info,\n\t\t\t       sector + get_aligned_image_offset(info, offset),\n\t\t\t       nr_sectors, (void *)load_ptr) != nr_sectors)\n\t\t\treturn -EIO;\n\n\t\tdebug(\"External data: dst=%lx, offset=%x, size=%lx\\n\",\n\t\t      load_ptr, offset, (unsigned long)length);\n\t\tsrc = (void *)load_ptr + overhead;\n\t} else {\n\t\t/* Embedded data */\n\t\tif (fit_image_get_data(fit, node, &data, &length)) {\n\t\t\tputs(\"Cannot get image data/size\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tdebug(\"Embedded data: dst=%lx, size=%lx\\n\", load_addr,\n\t\t      (unsigned long)length);\n\t\tsrc = (void *)data;\n\t}\n\n#ifdef CONFIG_SPL_FIT_SIGNATURE\n\tprintf(\"## Checking hash(es) for Image %s ... \",\n\t       fit_get_name(fit, node, NULL));\n\tif (!fit_image_verify_with_data(fit, node,\n\t\t\t\t\t src, length))\n\t\treturn -EPERM;\n\tputs(\"OK\\n\");\n#endif\n\n#ifdef CONFIG_SPL_FIT_IMAGE_POST_PROCESS\n\tboard_fit_image_post_process(&src, &length);\n#endif\n\n\tif (IS_ENABLED(CONFIG_SPL_GZIP) && image_comp == IH_COMP_GZIP) {\n\t\tsize = length;\n\t\tif (gunzip((void *)load_addr, CONFIG_SYS_BOOTM_LEN,\n\t\t\t   src, &size)) {\n\t\t\tputs(\"Uncompressing error\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tlength = size;\n\t} else {\n\t\tmemcpy((void *)load_addr, src, length);\n\t}\n\n\tif (image_info) {\n\t\timage_info->load_addr = load_addr;\n\t\timage_info->size = length;\n\t\timage_info->entry_point = fdt_getprop_u32(fit, node, \"entry\");\n\t}\n\n\treturn 0;\n}\n",
        "output": "1",
        "index": 182812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeContentBrowserClient::RenderProcessWillLaunch(\n    content::RenderProcessHost* host,\n    service_manager::mojom::ServiceRequest* service_request) {\n  int id = host->GetID();\n  Profile* profile = Profile::FromBrowserContext(host->GetBrowserContext());\n  host->AddFilter(new ChromeRenderMessageFilter(id, profile));\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  host->AddFilter(new cast::CastTransportHostFilter(profile));\n#endif\n#if BUILDFLAG(ENABLE_PRINTING)\n  host->AddFilter(new printing::PrintingMessageFilter(id, profile));\n#endif\n  host->AddFilter(new prerender::PrerenderMessageFilter(id, profile));\n  host->AddFilter(new TtsMessageFilter(host->GetBrowserContext()));\n  WebRtcLoggingHandlerHost* webrtc_logging_handler_host =\n      new WebRtcLoggingHandlerHost(id, profile,\n                                   g_browser_process->webrtc_log_uploader());\n  host->AddFilter(webrtc_logging_handler_host);\n  host->SetUserData(\n      WebRtcLoggingHandlerHost::kWebRtcLoggingHandlerHostKey,\n      std::make_unique<base::UserDataAdapter<WebRtcLoggingHandlerHost>>(\n          webrtc_logging_handler_host));\n\n  AudioDebugRecordingsHandler* audio_debug_recordings_handler =\n      new AudioDebugRecordingsHandler(profile);\n  host->SetUserData(\n      AudioDebugRecordingsHandler::kAudioDebugRecordingsHandlerKey,\n      std::make_unique<base::UserDataAdapter<AudioDebugRecordingsHandler>>(\n          audio_debug_recordings_handler));\n\n#if BUILDFLAG(ENABLE_NACL)\n  host->AddFilter(new nacl::NaClHostMessageFilter(id, profile->IsOffTheRecord(),\n                                                  profile->GetPath()));\n#endif\n\n#if defined(OS_ANDROID)\n  host->AddFilter(\n      new cdm::CdmMessageFilterAndroid(!profile->IsOffTheRecord(), false));\n\n  host->SetUserData(\n      CrashMemoryMetricsCollector::kCrashMemoryMetricsCollectorKey,\n      std::make_unique<CrashMemoryMetricsCollector>(host));\n#endif\n\n  Profile* original_profile = profile->GetOriginalProfile();\n  RendererUpdaterFactory::GetForProfile(original_profile)\n      ->InitializeRenderer(host);\n\n  for (size_t i = 0; i < extra_parts_.size(); ++i)\n    extra_parts_[i]->RenderProcessWillLaunch(host);\n\n  service_manager::mojom::ServicePtr service;\n  *service_request = mojo::MakeRequest(&service);\n  service_manager::mojom::PIDReceiverPtr pid_receiver;\n  service_manager::Identity renderer_identity = host->GetChildIdentity();\n  ChromeService::GetInstance()->connector()->RegisterServiceInstance(\n      service_manager::Identity(chrome::mojom::kRendererServiceName,\n                                renderer_identity.instance_group(),\n                                renderer_identity.instance_id(),\n                                base::Token::CreateRandom()),\n      std::move(service), mojo::MakeRequest(&pid_receiver));\n}\n",
        "output": "0",
        "index": 166519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static HB_Error  Load_ChainPosRule( HB_ChainPosRule*  cpr,\n\t\t\t\t    HB_Stream          stream )\n{\n  HB_Error  error;\n\n  HB_UShort             n, count;\n  HB_UShort*            b;\n  HB_UShort*            i;\n  HB_UShort*            l;\n\n  HB_PosLookupRecord*  plr;\n\n\n  if ( ACCESS_Frame( 2L ) )\n    return error;\n\n  cpr->BacktrackGlyphCount = GET_UShort();\n\n  FORGET_Frame();\n\n  cpr->Backtrack = NULL;\n\n  count = cpr->BacktrackGlyphCount;\n\n  if ( ALLOC_ARRAY( cpr->Backtrack, count, HB_UShort ) )\n    return error;\n\n  b = cpr->Backtrack;\n\n  if ( ACCESS_Frame( count * 2L ) )\n    goto Fail4;\n\n  for ( n = 0; n < count; n++ )\n    b[n] = GET_UShort();\n\n  FORGET_Frame();\n\n  if ( ACCESS_Frame( 2L ) )\n    goto Fail4;\n\n  cpr->InputGlyphCount = GET_UShort();\n\n  FORGET_Frame();\n\n  cpr->Input = NULL;\n\n  count = cpr->InputGlyphCount - 1;  /* only InputGlyphCount - 1 elements */\n\n  if ( ALLOC_ARRAY( cpr->Input, count, HB_UShort ) )\n    goto Fail4;\n\n  i = cpr->Input;\n\n  if ( ACCESS_Frame( count * 2L ) )\n    goto Fail3;\n\n  for ( n = 0; n < count; n++ )\n    i[n] = GET_UShort();\n\n  FORGET_Frame();\n\n  if ( ACCESS_Frame( 2L ) )\n    goto Fail3;\n\n  cpr->LookaheadGlyphCount = GET_UShort();\n\n  FORGET_Frame();\n\n  cpr->Lookahead = NULL;\n\n  count = cpr->LookaheadGlyphCount;\n\n  if ( ALLOC_ARRAY( cpr->Lookahead, count, HB_UShort ) )\n    goto Fail3;\n\n  l = cpr->Lookahead;\n\n  if ( ACCESS_Frame( count * 2L ) )\n    goto Fail2;\n\n  for ( n = 0; n < count; n++ )\n    l[n] = GET_UShort();\n\n  FORGET_Frame();\n\n  if ( ACCESS_Frame( 2L ) )\n    goto Fail2;\n\n  cpr->PosCount = GET_UShort();\n\n  FORGET_Frame();\n\n  cpr->PosLookupRecord = NULL;\n\n  count = cpr->PosCount;\n\n  if ( ALLOC_ARRAY( cpr->PosLookupRecord, count, HB_PosLookupRecord ) )\n    goto Fail2;\n\n  plr = cpr->PosLookupRecord;\n\n  if ( ACCESS_Frame( count * 4L ) )\n    goto Fail1;\n\n  for ( n = 0; n < count; n++ )\n  {\n    plr[n].SequenceIndex   = GET_UShort();\n    plr[n].LookupListIndex = GET_UShort();\n  }\n\n  FORGET_Frame();\n\n  return HB_Err_Ok;\n\nFail1:\n  FREE( plr );\n\nFail2:\n  FREE( l );\n\nFail3:\n  FREE( i );\n\nFail4:\n  FREE( b );\n  return error;\n}\n",
        "output": "0",
        "index": 13574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sk_buff **inet_gro_receive(struct sk_buff **head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst struct net_protocol *ops;\n\tstruct sk_buff **pp = NULL;\n\tstruct sk_buff *p;\n\tconst struct iphdr *iph;\n\tunsigned int hlen;\n\tunsigned int off;\n\tunsigned int id;\n\tint flush = 1;\n\tint proto;\n\n\toff = skb_gro_offset(skb);\n\thlen = off + sizeof(*iph);\n\tiph = skb_gro_header_fast(skb, off);\n\tif (skb_gro_header_hard(skb, hlen)) {\n\t\tiph = skb_gro_header_slow(skb, hlen, off);\n\t\tif (unlikely(!iph))\n\t\t\tgoto out;\n\t}\n\n\tproto = iph->protocol & (MAX_INET_PROTOS - 1);\n\n\trcu_read_lock();\n\tops = rcu_dereference(inet_protos[proto]);\n\tif (!ops || !ops->gro_receive)\n\t\tgoto out_unlock;\n\n\tif (*(u8 *)iph != 0x45)\n\t\tgoto out_unlock;\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto out_unlock;\n\n\tid = ntohl(*(__be32 *)&iph->id);\n\tflush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id ^ IP_DF));\n\tid >>= 16;\n\n\tfor (p = *head; p; p = p->next) {\n\t\tstruct iphdr *iph2;\n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tiph2 = ip_hdr(p);\n\n\t\tif ((iph->protocol ^ iph2->protocol) |\n\t\t    (iph->tos ^ iph2->tos) |\n\t\t    ((__force u32)iph->saddr ^ (__force u32)iph2->saddr) |\n\t\t    ((__force u32)iph->daddr ^ (__force u32)iph2->daddr)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* All fields must match except length and checksum. */\n\t\tNAPI_GRO_CB(p)->flush |=\n\t\t\t(iph->ttl ^ iph2->ttl) |\n\t\t\t((u16)(ntohs(iph2->id) + NAPI_GRO_CB(p)->count) ^ id);\n\n\t\tNAPI_GRO_CB(p)->flush |= flush;\n\t}\n\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\tskb_gro_pull(skb, sizeof(*iph));\n\tskb_set_transport_header(skb, skb_gro_offset(skb));\n\n\tpp = ops->gro_receive(head, skb);\n\nout_unlock:\n\trcu_read_unlock();\n\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\n\treturn pp;\n}\n",
        "output": "0",
        "index": 18785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vips_foreign_load_class_init( VipsForeignLoadClass *class )\n{\n\tGObjectClass *gobject_class = G_OBJECT_CLASS( class );\n\tVipsObjectClass *object_class = (VipsObjectClass *) class;\n\tVipsOperationClass *operation_class = (VipsOperationClass *) class;\n\n\tgobject_class->dispose = vips_foreign_load_dispose;\n\tgobject_class->set_property = vips_object_set_property;\n\tgobject_class->get_property = vips_object_get_property;\n\n\tobject_class->build = vips_foreign_load_build;\n\tobject_class->summary_class = vips_foreign_load_summary_class;\n\tobject_class->new_from_string = vips_foreign_load_new_from_string;\n\tobject_class->nickname = \"fileload\";\n\tobject_class->description = _( \"file loaders\" );\n\n\toperation_class->get_flags = vips_foreign_load_operation_get_flags;\n\n\tVIPS_ARG_IMAGE( class, \"out\", 2, \n\t\t_( \"Output\" ), \n\t\t_( \"Output image\" ),\n\t\tVIPS_ARGUMENT_REQUIRED_OUTPUT, \n\t\tG_STRUCT_OFFSET( VipsForeignLoad, out ) );\n\n\tVIPS_ARG_FLAGS( class, \"flags\", 6, \n\t\t_( \"Flags\" ), \n\t\t_( \"Flags for this file\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_OUTPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoad, flags ),\n\t\tVIPS_TYPE_FOREIGN_FLAGS, VIPS_FOREIGN_NONE ); \n\n\tVIPS_ARG_BOOL( class, \"memory\", 7, \n\t\t_( \"Memory\" ), \n\t\t_( \"Force open via memory\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoad, memory ),\n\t\tFALSE );\n\n\tVIPS_ARG_ENUM( class, \"access\", 8, \n\t\t_( \"Access\" ), \n\t\t_( \"Required access pattern for this file\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoad, access ),\n\t\tVIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM ); \n\n\tVIPS_ARG_BOOL( class, \"sequential\", 10, \n\t\t_( \"Sequential\" ), \n\t\t_( \"Sequential read only\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,\n\t\tG_STRUCT_OFFSET( VipsForeignLoad, sequential ),\n\t\tFALSE );\n\n\tVIPS_ARG_BOOL( class, \"fail\", 11, \n\t\t_( \"Fail\" ), \n\t\t_( \"Fail on first error\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT,\n\t\tG_STRUCT_OFFSET( VipsForeignLoad, fail ),\n\t\tFALSE );\n\n\tVIPS_ARG_BOOL( class, \"disc\", 12, \n\t\t_( \"Disc\" ), \n\t\t_( \"Open to disc\" ),\n\t\tVIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,\n\t\tG_STRUCT_OFFSET( VipsForeignLoad, disc ),\n\t\tTRUE );\n\n}\n",
        "output": "0",
        "index": 83901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int make_msg_set(struct ImapData *idata, struct Buffer *buf, int flag,\n                        bool changed, bool invert, int *pos)\n{\n  int count = 0;             /* number of messages in message set */\n  unsigned int setstart = 0; /* start of current message range */\n  int n;\n  bool started = false;\n  struct Header **hdrs = idata->ctx->hdrs;\n\n  for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)\n  {\n    bool match = false; /* whether current message matches flag condition */\n    /* don't include pending expunged messages */\n    if (hdrs[n]->active)\n    {\n      switch (flag)\n      {\n        case MUTT_DELETED:\n          if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)\n            match = invert ^ hdrs[n]->deleted;\n          break;\n        case MUTT_FLAG:\n          if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)\n            match = invert ^ hdrs[n]->flagged;\n          break;\n        case MUTT_OLD:\n          if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)\n            match = invert ^ hdrs[n]->old;\n          break;\n        case MUTT_READ:\n          if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)\n            match = invert ^ hdrs[n]->read;\n          break;\n        case MUTT_REPLIED:\n          if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)\n            match = invert ^ hdrs[n]->replied;\n          break;\n        case MUTT_TAG:\n          if (hdrs[n]->tagged)\n            match = true;\n          break;\n        case MUTT_TRASH:\n          if (hdrs[n]->deleted && !hdrs[n]->purge)\n            match = true;\n          break;\n      }\n    }\n\n    if (match && (!changed || hdrs[n]->changed))\n    {\n      count++;\n      if (setstart == 0)\n      {\n        setstart = HEADER_DATA(hdrs[n])->uid;\n        if (!started)\n        {\n          mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);\n          started = true;\n        }\n        else\n          mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);\n      }\n      /* tie up if the last message also matches */\n      else if (n == idata->ctx->msgcount - 1)\n        mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);\n    }\n    /* End current set if message doesn't match or we've reached the end\n     * of the mailbox via inactive messages following the last match. */\n    else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))\n    {\n      if (HEADER_DATA(hdrs[n - 1])->uid > setstart)\n        mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);\n      setstart = 0;\n    }\n  }\n\n  *pos = n;\n\n  return count;\n}\n",
        "output": "0",
        "index": 79612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mac80211_hwsim_tx(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_control *control,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct mac80211_hwsim_data *data = hw->priv;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tbool ack;\n\tu32 _portid;\n\n\tif (WARN_ON(skb->len < 10)) {\n\t\t/* Should not happen; just a sanity check for addr1 use */\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (!data->use_chanctx) {\n\t\tchannel = data->channel;\n\t} else if (txi->hw_queue == 4) {\n\t\tchannel = data->tmp_chan;\n\t} else {\n\t\tchanctx_conf = rcu_dereference(txi->control.vif->chanctx_conf);\n\t\tif (chanctx_conf)\n\t\t\tchannel = chanctx_conf->def.chan;\n\t\telse\n\t\t\tchannel = NULL;\n\t}\n\n\tif (WARN(!channel, \"TX w/o channel - queue = %d\\n\", txi->hw_queue)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (data->idle && !data->tmp_chan) {\n\t\twiphy_dbg(hw->wiphy, \"Trying to TX when idle - reject\\n\");\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tif (txi->control.vif)\n\t\thwsim_check_magic(txi->control.vif);\n\tif (control->sta)\n\t\thwsim_check_sta_magic(control->sta);\n\n\tif (ieee80211_hw_check(hw, SUPPORTS_RC_TABLE))\n\t\tieee80211_get_tx_rates(txi->control.vif, control->sta, skb,\n\t\t\t\t       txi->control.rates,\n\t\t\t\t       ARRAY_SIZE(txi->control.rates));\n\n\tif (skb->len >= 24 + 8 &&\n\t    ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t/* fake header transmission time */\n\t\tstruct ieee80211_mgmt *mgmt;\n\t\tstruct ieee80211_rate *txrate;\n\t\tu64 ts;\n\n\t\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\t\ttxrate = ieee80211_get_tx_rate(hw, txi);\n\t\tts = mac80211_hwsim_get_tsf_raw();\n\t\tmgmt->u.probe_resp.timestamp =\n\t\t\tcpu_to_le64(ts + data->tsf_offset +\n\t\t\t\t    24 * 8 * 10 / txrate->bitrate);\n\t}\n\n\tmac80211_hwsim_monitor_rx(hw, skb, channel);\n\n\t/* wmediumd mode check */\n\t_portid = READ_ONCE(data->wmediumd);\n\n\tif (_portid)\n\t\treturn mac80211_hwsim_tx_frame_nl(hw, skb, _portid);\n\n\t/* NO wmediumd detected, perfect medium simulation */\n\tdata->tx_pkts++;\n\tdata->tx_bytes += skb->len;\n\tack = mac80211_hwsim_tx_frame_no_nl(hw, skb, channel);\n\n\tif (ack && skb->len >= 16)\n\t\tmac80211_hwsim_monitor_ack(channel, hdr->addr2);\n\n\tieee80211_tx_info_clear_status(txi);\n\n\t/* frame was transmitted at most favorable rate at first attempt */\n\ttxi->control.rates[0].count = 1;\n\ttxi->control.rates[1].idx = -1;\n\n\tif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) && ack)\n\t\ttxi->flags |= IEEE80211_TX_STAT_ACK;\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n",
        "output": "0",
        "index": 83867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gre_print_1(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tu_int len = length;\n\tuint16_t flags, prot;\n\n\t/* 16 bits ND_TCHECKed in gre_print() */\n\tflags = EXTRACT_16BITS(bp);\n\tlen -= 2;\n\tbp += 2;\n\n\tif (ndo->ndo_vflag)\n            ND_PRINT((ndo, \", Flags [%s]\",\n                   bittok2str(gre_flag_values,\"none\",flags)));\n\n\tND_TCHECK2(*bp, 2);\n\tif (len < 2)\n\t\tgoto trunc;\n\tprot = EXTRACT_16BITS(bp);\n\tlen -= 2;\n\tbp += 2;\n\n\n\tif (flags & GRE_KP) {\n\t\tuint32_t k;\n\n\t\tND_TCHECK2(*bp, 4);\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tk = EXTRACT_32BITS(bp);\n\t\tND_PRINT((ndo, \", call %d\", k & 0xffff));\n\t\tlen -= 4;\n\t\tbp += 4;\n\t}\n\n\tif (flags & GRE_SP) {\n\t\tND_TCHECK2(*bp, 4);\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \", seq %u\", EXTRACT_32BITS(bp)));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t}\n\n\tif (flags & GRE_AP) {\n\t\tND_TCHECK2(*bp, 4);\n\t\tif (len < 4)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \", ack %u\", EXTRACT_32BITS(bp)));\n\t\tbp += 4;\n\t\tlen -= 4;\n\t}\n\n\tif ((flags & GRE_SP) == 0)\n\t\tND_PRINT((ndo, \", no-payload\"));\n\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \", proto %s (0x%04x)\",\n                   tok2str(ethertype_values,\"unknown\",prot),\n                   prot));\n\n        ND_PRINT((ndo, \", length %u\",length));\n\n        if ((flags & GRE_SP) == 0)\n            return;\n\n        if (ndo->ndo_vflag < 1)\n            ND_PRINT((ndo, \": \")); /* put in a colon as protocol demarc */\n        else\n            ND_PRINT((ndo, \"\\n\\t\")); /* if verbose go multiline */\n\n\tswitch (prot) {\n\tcase ETHERTYPE_PPP:\n\t\tppp_print(ndo, bp, len);\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"gre-proto-0x%x\", prot));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "output": "0",
        "index": 62573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_trans(netdissect_options *ndo,\n            const u_char *words, const u_char *data1, const u_char *buf, const u_char *maxbuf)\n{\n    u_int bcc;\n    const char *f1, *f2, *f3, *f4;\n    const u_char *data, *param;\n    const u_char *w = words + 1;\n    int datalen, paramlen;\n\n    if (request) {\n\tND_TCHECK2(w[12 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 9 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 10 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 11 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 12 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nMaxParmCnt=[d] \\nMaxDataCnt=[d]\\nMaxSCnt=[d] \\nTransFlags=[w] \\nRes1=[w] \\nRes2=[w] \\nRes3=[w]\\nParamCnt=[d] \\nParamOff=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nSUCnt=[d]\\n\";\n\tf2 = \"|Name=[S]\\n\";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    } else {\n\tND_TCHECK2(w[7 * 2], 2);\n\tparamlen = EXTRACT_LE_16BITS(w + 3 * 2);\n\tparam = buf + EXTRACT_LE_16BITS(w + 4 * 2);\n\tdatalen = EXTRACT_LE_16BITS(w + 6 * 2);\n\tdata = buf + EXTRACT_LE_16BITS(w + 7 * 2);\n\tf1 = \"TotParamCnt=[d] \\nTotDataCnt=[d] \\nRes1=[d]\\nParamCnt=[d] \\nParamOff=[d] \\nRes2=[d] \\nDataCnt=[d] \\nDataOff=[d] \\nRes3=[d]\\nLsetup=[d]\\n\";\n\tf2 = \"|Unknown \";\n\tf3 = \"|Param \";\n\tf4 = \"|Data \";\n    }\n\n    smb_fdata(ndo, words + 1, f1, min(words + 1 + 2 * words[0], maxbuf),\n        unicodestr);\n\n    ND_TCHECK2(*data1, 2);\n    bcc = EXTRACT_LE_16BITS(data1);\n     ND_PRINT((ndo, \"smb_bcc=%u\\n\", bcc));\n     if (bcc > 0) {\n \tsmb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);\n\tif (strcmp((const char *)(data1 + 2), \"\\\\MAILSLOT\\\\BROWSE\") == 0) {\n \t    print_browse(ndo, param, paramlen, data, datalen);\n \t    return;\n \t}\n \n\tif (strcmp((const char *)(data1 + 2), \"\\\\PIPE\\\\LANMAN\") == 0) {\n \t    print_ipc(ndo, param, paramlen, data, datalen);\n \t    return;\n \t}\n \n \tif (paramlen)\n \t    smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr);\n\tif (datalen)\n\t    smb_fdata(ndo, data, f4, min(data + datalen, maxbuf), unicodestr);\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "output": "1",
        "index": 182987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickPrivate void SetPixelCacheMethods(Cache cache,CacheMethods *cache_methods)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  GetOneAuthenticPixelFromHandler\n    get_one_authentic_pixel_from_handler;\n\n  GetOneVirtualPixelFromHandler\n    get_one_virtual_pixel_from_handler;\n\n  /*\n    Set cache pixel methods.\n  */\n  assert(cache != (Cache) NULL);\n  assert(cache_methods != (CacheMethods *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  if (cache_methods->get_virtual_pixel_handler != (GetVirtualPixelHandler) NULL)\n    cache_info->methods.get_virtual_pixel_handler=\n      cache_methods->get_virtual_pixel_handler;\n  if (cache_methods->destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    cache_info->methods.destroy_pixel_handler=\n      cache_methods->destroy_pixel_handler;\n  if (cache_methods->get_virtual_metacontent_from_handler !=\n      (GetVirtualMetacontentFromHandler) NULL)\n    cache_info->methods.get_virtual_metacontent_from_handler=\n      cache_methods->get_virtual_metacontent_from_handler;\n  if (cache_methods->get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    cache_info->methods.get_authentic_pixels_handler=\n      cache_methods->get_authentic_pixels_handler;\n  if (cache_methods->queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    cache_info->methods.queue_authentic_pixels_handler=\n      cache_methods->queue_authentic_pixels_handler;\n  if (cache_methods->sync_authentic_pixels_handler !=\n      (SyncAuthenticPixelsHandler) NULL)\n    cache_info->methods.sync_authentic_pixels_handler=\n      cache_methods->sync_authentic_pixels_handler;\n  if (cache_methods->get_authentic_pixels_from_handler !=\n      (GetAuthenticPixelsFromHandler) NULL)\n    cache_info->methods.get_authentic_pixels_from_handler=\n      cache_methods->get_authentic_pixels_from_handler;\n  if (cache_methods->get_authentic_metacontent_from_handler !=\n      (GetAuthenticMetacontentFromHandler) NULL)\n    cache_info->methods.get_authentic_metacontent_from_handler=\n      cache_methods->get_authentic_metacontent_from_handler;\n  get_one_virtual_pixel_from_handler=\n    cache_info->methods.get_one_virtual_pixel_from_handler;\n  if (get_one_virtual_pixel_from_handler !=\n      (GetOneVirtualPixelFromHandler) NULL)\n    cache_info->methods.get_one_virtual_pixel_from_handler=\n      cache_methods->get_one_virtual_pixel_from_handler;\n  get_one_authentic_pixel_from_handler=\n    cache_methods->get_one_authentic_pixel_from_handler;\n  if (get_one_authentic_pixel_from_handler !=\n      (GetOneAuthenticPixelFromHandler) NULL)\n    cache_info->methods.get_one_authentic_pixel_from_handler=\n      cache_methods->get_one_authentic_pixel_from_handler;\n}\n",
        "output": "0",
        "index": 94814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usb_disable_device(struct usb_device *dev, int skip_ep0)\n{\n\tint i;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\t/* getting rid of interfaces will disconnect\n\t * any drivers bound to them (a key side effect)\n\t */\n\tif (dev->actconfig) {\n\t\t/*\n\t\t * FIXME: In order to avoid self-deadlock involving the\n\t\t * bandwidth_mutex, we have to mark all the interfaces\n\t\t * before unregistering any of them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\n\t\t\tdev->actconfig->interface[i]->unregistering = 1;\n\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tstruct usb_interface\t*interface;\n\n\t\t\t/* remove this interface if it has been registered */\n\t\t\tinterface = dev->actconfig->interface[i];\n\t\t\tif (!device_is_registered(&interface->dev))\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->dev, \"unregistering interface %s\\n\",\n\t\t\t\tdev_name(&interface->dev));\n\t\t\tremove_intf_ep_devs(interface);\n\t\t\tdevice_del(&interface->dev);\n\t\t}\n\n\t\t/* Now that the interfaces are unbound, nobody should\n\t\t * try to access them.\n\t\t */\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tput_device(&dev->actconfig->interface[i]->dev);\n\t\t\tdev->actconfig->interface[i] = NULL;\n\t\t}\n\n\t\tif (dev->usb2_hw_lpm_enabled == 1)\n\t\t\tusb_set_usb2_hardware_lpm(dev, 0);\n\t\tusb_unlocked_disable_lpm(dev);\n\t\tusb_disable_ltm(dev);\n\n\t\tdev->actconfig = NULL;\n\t\tif (dev->state == USB_STATE_CONFIGURED)\n\t\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t}\n\n\tdev_dbg(&dev->dev, \"%s nuking %s URBs\\n\", __func__,\n\t\tskip_ep0 ? \"non-ep0\" : \"all\");\n\tif (hcd->driver->check_bandwidth) {\n\t\t/* First pass: Cancel URBs, leave endpoint pointers intact. */\n\t\tfor (i = skip_ep0; i < 16; ++i) {\n\t\t\tusb_disable_endpoint(dev, i, false);\n\t\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, false);\n\t\t}\n\t\t/* Remove endpoints from the host controller internal state */\n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\t/* Second pass: remove endpoint pointers */\n\t}\n\tfor (i = skip_ep0; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n}\n",
        "output": "0",
        "index": 59769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline int __linearize(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t       struct segmented_address addr,\n\t\t\t\t       unsigned *max_size, unsigned size,\n\t\t\t\t       bool write, bool fetch,\n\t\t\t\t       enum x86emul_mode mode, ulong *linear)\n{\n\tstruct desc_struct desc;\n\tbool usable;\n\tulong la;\n\tu32 lim;\n\tu16 sel;\n\n\tla = seg_base(ctxt, addr.seg) + addr.ea;\n\t*max_size = 0;\n\tswitch (mode) {\n\tcase X86EMUL_MODE_PROT64:\n\t\t*linear = la;\n\t\tif (is_noncanonical_address(la))\n\t\t\tgoto bad;\n\n\t\t*max_size = min_t(u64, ~0u, (1ull << 48) - la);\n\t\tif (size > *max_size)\n\t\t\tgoto bad;\n\t\tbreak;\n\tdefault:\n\t\t*linear = la = (u32)la;\n\t\tusable = ctxt->ops->get_segment(ctxt, &sel, &desc, NULL,\n\t\t\t\t\t\taddr.seg);\n\t\tif (!usable)\n\t\t\tgoto bad;\n\t\t/* code segment in protected mode or read-only data segment */\n\t\tif ((((ctxt->mode != X86EMUL_MODE_REAL) && (desc.type & 8))\n\t\t\t\t\t|| !(desc.type & 2)) && write)\n\t\t\tgoto bad;\n\t\t/* unreadable code segment */\n\t\tif (!fetch && (desc.type & 8) && !(desc.type & 2))\n\t\t\tgoto bad;\n\t\tlim = desc_limit_scaled(&desc);\n\t\tif (!(desc.type & 8) && (desc.type & 4)) {\n\t\t\t/* expand-down segment */\n\t\t\tif (addr.ea <= lim)\n\t\t\t\tgoto bad;\n\t\t\tlim = desc.d ? 0xffffffff : 0xffff;\n\t\t}\n\t\tif (addr.ea > lim)\n\t\t\tgoto bad;\n\t\tif (lim == 0xffffffff)\n\t\t\t*max_size = ~0u;\n\t\telse {\n\t\t\t*max_size = (u64)lim + 1 - addr.ea;\n\t\t\tif (size > *max_size)\n\t\t\t\tgoto bad;\n\t\t}\n\t\tbreak;\n\t}\n\tif (insn_aligned(ctxt, size) && ((la & (size - 1)) != 0))\n\t\treturn emulate_gp(ctxt, 0);\n\treturn X86EMUL_CONTINUE;\nbad:\n\tif (addr.seg == VCPU_SREG_SS)\n\t\treturn emulate_ss(ctxt, 0);\n\telse\n\t\treturn emulate_gp(ctxt, 0);\n}\n",
        "output": "0",
        "index": 47938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool OmniboxViewViews::HandleKeyEvent(views::Textfield* textfield,\n                                      const ui::KeyEvent& event) {\n  if (event.type() == ui::ET_KEY_RELEASED) {\n    if (event.key_code() == ui::VKEY_CONTROL)\n      model()->OnControlKeyChanged(false);\n\n    return false;\n  }\n\n  delete_at_end_pressed_ = false;\n\n  if (event.IsUnicodeKeyCode())\n    return false;\n\n  const bool shift = event.IsShiftDown();\n  const bool control = event.IsControlDown();\n  const bool alt = event.IsAltDown() || event.IsAltGrDown();\n  switch (event.key_code()) {\n    case ui::VKEY_RETURN:\n      model()->AcceptInput(alt ? WindowOpenDisposition::NEW_FOREGROUND_TAB\n                               : WindowOpenDisposition::CURRENT_TAB,\n                           false);\n      return true;\n    case ui::VKEY_ESCAPE:\n      return model()->OnEscapeKeyPressed();\n    case ui::VKEY_CONTROL:\n      model()->OnControlKeyChanged(true);\n      break;\n    case ui::VKEY_DELETE:\n      if (shift && model()->popup_model()->IsOpen())\n        model()->popup_model()->TryDeletingCurrentItem();\n\n      delete_at_end_pressed_ = (!event.IsAltDown() && !HasSelection() &&\n                                GetCursorPosition() == text().length());\n      break;\n    case ui::VKEY_UP:\n      if (IsTextEditCommandEnabled(ui::TextEditCommand::MOVE_UP)) {\n        ExecuteTextEditCommand(ui::TextEditCommand::MOVE_UP);\n        return true;\n      }\n      break;\n    case ui::VKEY_DOWN:\n      if (IsTextEditCommandEnabled(ui::TextEditCommand::MOVE_DOWN)) {\n        ExecuteTextEditCommand(ui::TextEditCommand::MOVE_DOWN);\n        return true;\n      }\n      break;\n    case ui::VKEY_PRIOR:\n      if (control || alt || shift)\n        return false;\n      model()->OnUpOrDownKeyPressed(-1 * model()->result().size());\n      return true;\n    case ui::VKEY_NEXT:\n      if (control || alt || shift)\n        return false;\n      model()->OnUpOrDownKeyPressed(model()->result().size());\n      return true;\n    case ui::VKEY_V:\n      if (control && !alt &&\n          IsTextEditCommandEnabled(ui::TextEditCommand::PASTE)) {\n        ExecuteTextEditCommand(ui::TextEditCommand::PASTE);\n        return true;\n      }\n      break;\n    case ui::VKEY_INSERT:\n      if (shift && !control &&\n          IsTextEditCommandEnabled(ui::TextEditCommand::PASTE)) {\n        ExecuteTextEditCommand(ui::TextEditCommand::PASTE);\n        return true;\n      }\n      break;\n    case ui::VKEY_BACK:\n      if (model()->is_keyword_hint() || model()->keyword().empty() ||\n          HasSelection() || GetCursorPosition() != 0)\n        return false;\n      model()->ClearKeyword();\n      return true;\n\n    default:\n      break;\n  }\n\n  return HandleEarlyTabActions(event);\n}\n",
        "output": "0",
        "index": 163437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "selCreateFromSArray(SARRAY  *sa,\n                    l_int32  first,\n                    l_int32  last)\n{\nchar     ch;\nchar    *name, *line;\nl_int32  n, len, i, w, h, y, x;\nSEL     *sel;\n\n    PROCNAME(\"selCreateFromSArray\");\n\n    if (!sa)\n        return (SEL *)ERROR_PTR(\"sa not defined\", procName, NULL);\n    n = sarrayGetCount(sa);\n    if (first < 0 || first >= n || last <= first || last >= n)\n        return (SEL *)ERROR_PTR(\"invalid range\", procName, NULL);\n\n    name = sarrayGetString(sa, first, L_NOCOPY);\n    h = last - first;\n    line = sarrayGetString(sa, first + 1, L_NOCOPY);\n    len = strlen(line);\n    if (line[0] != '\"' || line[len - 1] != '\"')\n        return (SEL *)ERROR_PTR(\"invalid format\", procName, NULL);\n    w = len - 2;\n    if ((sel = selCreate(h, w, name)) == NULL)\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    for (i = first + 1; i <= last; i++) {\n        line = sarrayGetString(sa, i, L_NOCOPY);\n        y = i - first - 1;\n        for (x = 0; x < w; ++x) {\n            ch = line[x + 1];  /* skip the leading double-quote */\n            switch (ch)\n            {\n                case 'X':\n                    selSetOrigin(sel, y, x);  /* set origin and hit */\n                case 'x':\n                    selSetElement(sel, y, x, SEL_HIT);\n                    break;\n\n                case 'O':\n                    selSetOrigin(sel, y, x);  /* set origin and miss */\n                case 'o':\n                    selSetElement(sel, y, x, SEL_MISS);\n                    break;\n\n                case 'C':\n                    selSetOrigin(sel, y, x);  /* set origin and don't-care */\n                case ' ':\n                    selSetElement(sel, y, x, SEL_DONT_CARE);\n                    break;\n\n                default:\n                    selDestroy(&sel);\n                    return (SEL *)ERROR_PTR(\"unknown char\", procName, NULL);\n            }\n        }\n    }\n\n    return sel;\n}\n",
        "output": "0",
        "index": 84211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aiff_read_basc_chunk (SF_PRIVATE * psf, int datasize)\n{\tconst char * type_str ;\n\tbasc_CHUNK bc ;\n\tint count ;\n\n\tcount = psf_binheader_readf (psf, \"E442\", &bc.version, &bc.numBeats, &bc.rootNote) ;\n\tcount += psf_binheader_readf (psf, \"E222\", &bc.scaleType, &bc.sigNumerator, &bc.sigDenominator) ;\n\tcount += psf_binheader_readf (psf, \"E2j\", &bc.loopType, datasize - sizeof (bc)) ;\n\n\tpsf_log_printf (psf, \"  Version ? : %u\\n  Num Beats : %u\\n  Root Note : 0x%x\\n\",\n\t\t\t\t\t\tbc.version, bc.numBeats, bc.rootNote) ;\n\n\tswitch (bc.scaleType)\n\t{\tcase basc_SCALE_MINOR :\n\t\t\t\ttype_str = \"MINOR\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_MAJOR :\n\t\t\t\ttype_str = \"MAJOR\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_NEITHER :\n\t\t\t\ttype_str = \"NEITHER\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_SCALE_BOTH :\n\t\t\t\ttype_str = \"BOTH\" ;\n\t\t\t\tbreak ;\n\t\tdefault :\n\t\t\t\ttype_str = \"!!WRONG!!\" ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  ScaleType : 0x%x (%s)\\n\", bc.scaleType, type_str) ;\n\tpsf_log_printf (psf, \"  Time Sig  : %d/%d\\n\", bc.sigNumerator, bc.sigDenominator) ;\n\n\tswitch (bc.loopType)\n\t{\tcase basc_TYPE_ONE_SHOT :\n\t\t\t\ttype_str = \"One Shot\" ;\n\t\t\t\tbreak ;\n\t\tcase basc_TYPE_LOOP :\n\t\t\t\ttype_str = \"Loop\" ;\n\t\t\t\tbreak ;\n\t\tdefault:\n\t\t\t\ttype_str = \"!!WRONG!!\" ;\n\t\t\t\tbreak ;\n\t\t} ;\n\n\tpsf_log_printf (psf, \"  Loop Type : 0x%x (%s)\\n\", bc.loopType, type_str) ;\n\n\tif ((psf->loop_info = calloc (1, sizeof (SF_LOOP_INFO))) == NULL)\n\t\treturn SFE_MALLOC_FAILED ;\n\n\tpsf->loop_info->time_sig_num\t= bc.sigNumerator ;\n\tpsf->loop_info->time_sig_den\t= bc.sigDenominator ;\n\tpsf->loop_info->loop_mode\t\t= (bc.loopType == basc_TYPE_ONE_SHOT) ? SF_LOOP_NONE : SF_LOOP_FORWARD ;\n\tpsf->loop_info->num_beats\t\t= bc.numBeats ;\n\n\t/* Can always be recalculated from other known fields. */\n\tpsf->loop_info->bpm = (1.0 / psf->sf.frames) * psf->sf.samplerate\n\t\t\t\t\t\t\t* ((bc.numBeats * 4.0) / bc.sigDenominator) * 60.0 ;\n\tpsf->loop_info->root_key = bc.rootNote ;\n\n\tif (count < datasize)\n\t\tpsf_binheader_readf (psf, \"j\", datasize - count) ;\n\n\treturn 0 ;\n} /* aiff_read_basc_chunk */\n",
        "output": "0",
        "index": 67870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->ldr_bits = 8;\n\t/* flat mode is default */\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All APICs have to be configured in the same mode by an OS.\n\t\t * We take advatage of this while building logical id loockup\n\t\t * table. After reset APICs are in xapic/flat mode, so if we\n\t\t * find apic with different setting we assume this is the mode\n\t\t * OS wants all apics to be in; build lookup table accordingly.\n\t\t */\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask /* flat mode */ &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}\n",
        "output": "0",
        "index": 28800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType WriteOTBImage(const ImageInfo *image_info,Image *image)\n{\n#define SetBit(a,i,set) \\\n  a=(unsigned char) ((set) ? (a) | (1L << (i)) : (a) & ~(1L << (i)))\n\n  MagickBooleanType\n    status;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    bit,\n    byte,\n    info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert image to a bi-level image.\n  */\n  (void) SetImageType(image,BilevelType);\n  info=0;\n  if ((image->columns >= 256) || (image->rows >= 256))\n    SetBit(info,4,1);\n  (void) WriteBlobByte(image,info);\n  if ((image->columns >= 256) || (image->rows >= 256))\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n    }\n  else\n    {\n      (void) WriteBlobByte(image,(unsigned char) image->columns);\n      (void) WriteBlobByte(image,(unsigned char) image->rows);\n    }\n  (void) WriteBlobByte(image,1);  /* depth */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x1 << (7-bit);\n      bit++;\n      if (bit == 8)\n        {\n          (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
        "output": "0",
        "index": 71621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Segment::ParseNext(\n    const Cluster* pCurr,\n    const Cluster*& pResult,\n    long long& pos,\n    long& len)\n{\n    assert(pCurr);\n    assert(!pCurr->EOS());\n    assert(m_clusters);\n \n    pResult = 0;\n \n    if (pCurr->m_index >= 0)  //loaded (not merely preloaded)\n    {\n        assert(m_clusters[pCurr->m_index] == pCurr);\n \n        const long next_idx = pCurr->m_index + 1;\n \n        if (next_idx < m_clusterCount)\n        {\n            pResult = m_clusters[next_idx];\n            return 0;  //success\n        }\n \n \n        const long result = LoadCluster(pos, len);\n \n        if (result < 0)  //error or underflow\n            return result;\n \n        if (result > 0)  //no more clusters\n        {\n            return 1;\n        }\n \n        pResult = GetLast();\n        return 0;  //success\n     }\n \n    assert(m_pos > 0);\n \n    long long total, avail;\n \n    long status = m_pReader->Length(&total, &avail);\n \n    if (status < 0)  //error\n        return status;\n \n    assert((total < 0) || (avail <= total));\n \n    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;\n \n \n    pos = pCurr->m_element_start;\n \n    if (pCurr->m_element_size >= 0)\n        pos += pCurr->m_element_size;\n     else\n    {\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n \n        long long result = GetUIntLength(m_pReader, pos, len);\n \n        if (result < 0)  //error\n            return static_cast<long>(result);\n \n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n \n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n \n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long id = ReadUInt(m_pReader, pos, len);\n        if (id != 0x0F43B675)  //weird: not Cluster ID\n            return -1;\n        pos += len;  //consume ID\n        if ((pos + 1) > avail)\n        {\n            len = 1;\n            return E_BUFFER_NOT_FULL;\n        }\n        result = GetUIntLength(m_pReader, pos, len);\n        if (result < 0)  //error\n            return static_cast<long>(result);\n        if (result > 0)  //weird\n            return E_BUFFER_NOT_FULL;\n        if ((segment_stop >= 0) && ((pos + len) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        if ((pos + len) > avail)\n            return E_BUFFER_NOT_FULL;\n        const long long size = ReadUInt(m_pReader, pos, len);\n        if (size < 0) //error\n            return static_cast<long>(size);\n        pos += len;  //consume size field\n        const long long unknown_size = (1LL << (7 * len)) - 1;\n        if (size == unknown_size)          //TODO: should never happen\n            return E_FILE_FORMAT_INVALID;  //TODO: resolve this\n        if ((segment_stop >= 0) && ((pos + size) > segment_stop))\n            return E_FILE_FORMAT_INVALID;\n        pos += size;  //consume payload (that is, the current cluster)\n        assert((segment_stop < 0) || (pos <= segment_stop));\n    }\n    for (;;)\n    {\n        const long status = DoParseNext(pResult, pos, len);\n        if (status <= 1)\n            return status;\n    }\n }\n",
        "output": "1",
        "index": 188450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SMB2_ioctl_init(struct cifs_tcon *tcon, struct smb_rqst *rqst,\n\t\tu64 persistent_fid, u64 volatile_fid, u32 opcode,\n\t\tbool is_fsctl, char *in_data, u32 indatalen,\n\t\t__u32 max_response_size)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct kvec *iov = rqst->rq_iov;\n\tunsigned int total_len;\n\tint rc;\n\n\trc = smb2_plain_req_init(SMB2_IOCTL, tcon, (void **) &req, &total_len);\n\tif (rc)\n\t\treturn rc;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]).\n\t */\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer));\n\t\trqst->rq_nvec = 2;\n\t\tiov[0].iov_len = total_len - 1;\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t} else {\n\t\trqst->rq_nvec = 1;\n\t\tiov[0].iov_len = total_len;\n\t}\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * In most cases max_response_size is set to 16K (CIFSMaxBufSize)\n\t * We Could increase default MaxOutputResponse, but that could require\n\t * more credits. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t * We can not handle more than CIFS_MAX_BUF_SIZE yet but may want\n\t * to increase this limit up in the future.\n\t * Note that for snapshot queries that servers like Azure expect that\n\t * the first query be minimal size (and just used to get the number/size\n\t * of previous versions) so response size must be specified as EXACTLY\n\t * sizeof(struct snapshot_array) which is 16 when rounded up to multiple\n\t * of eight bytes.  Currently that is the only case where we set max\n\t * response size smaller.\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(max_response_size);\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\t/* validate negotiate request must be signed - see MS-SMB2 3.2.5.5 */\n\tif (opcode == FSCTL_VALIDATE_NEGOTIATE_INFO)\n\t\treq->sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 88076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char* get_sigcode(int signo, int code) {\n switch (signo) {\n case SIGILL:\n switch (code) {\n case ILL_ILLOPC: return \"ILL_ILLOPC\";\n case ILL_ILLOPN: return \"ILL_ILLOPN\";\n case ILL_ILLADR: return \"ILL_ILLADR\";\n case ILL_ILLTRP: return \"ILL_ILLTRP\";\n case ILL_PRVOPC: return \"ILL_PRVOPC\";\n case ILL_PRVREG: return \"ILL_PRVREG\";\n case ILL_COPROC: return \"ILL_COPROC\";\n case ILL_BADSTK: return \"ILL_BADSTK\";\n }\n static_assert(NSIGILL == ILL_BADSTK, \"missing ILL_* si_code\");\n break;\n case SIGBUS:\n switch (code) {\n case BUS_ADRALN: return \"BUS_ADRALN\";\n case BUS_ADRERR: return \"BUS_ADRERR\";\n case BUS_OBJERR: return \"BUS_OBJERR\";\n case BUS_MCEERR_AR: return \"BUS_MCEERR_AR\";\n case BUS_MCEERR_AO: return \"BUS_MCEERR_AO\";\n }\n static_assert(NSIGBUS == BUS_MCEERR_AO, \"missing BUS_* si_code\");\n break;\n case SIGFPE:\n switch (code) {\n case FPE_INTDIV: return \"FPE_INTDIV\";\n case FPE_INTOVF: return \"FPE_INTOVF\";\n case FPE_FLTDIV: return \"FPE_FLTDIV\";\n case FPE_FLTOVF: return \"FPE_FLTOVF\";\n case FPE_FLTUND: return \"FPE_FLTUND\";\n case FPE_FLTRES: return \"FPE_FLTRES\";\n case FPE_FLTINV: return \"FPE_FLTINV\";\n case FPE_FLTSUB: return \"FPE_FLTSUB\";\n }\n static_assert(NSIGFPE == FPE_FLTSUB, \"missing FPE_* si_code\");\n break;\n case SIGSEGV:\n switch (code) {\n case SEGV_MAPERR: return \"SEGV_MAPERR\";\n case SEGV_ACCERR: return \"SEGV_ACCERR\";\n }\n static_assert(NSIGSEGV == SEGV_ACCERR, \"missing SEGV_* si_code\");\n break;\n case SIGTRAP:\n switch (code) {\n case TRAP_BRKPT: return \"TRAP_BRKPT\";\n case TRAP_TRACE: return \"TRAP_TRACE\";\n case TRAP_BRANCH: return \"TRAP_BRANCH\";\n case TRAP_HWBKPT: return \"TRAP_HWBKPT\";\n }\n static_assert(NSIGTRAP == TRAP_HWBKPT, \"missing TRAP_* si_code\");\n break;\n }\n switch (code) {\n case SI_USER: return \"SI_USER\";\n case SI_KERNEL: return \"SI_KERNEL\";\n case SI_QUEUE: return \"SI_QUEUE\";\n case SI_TIMER: return \"SI_TIMER\";\n case SI_MESGQ: return \"SI_MESGQ\";\n case SI_ASYNCIO: return \"SI_ASYNCIO\";\n case SI_SIGIO: return \"SI_SIGIO\";\n case SI_TKILL: return \"SI_TKILL\";\n case SI_DETHREAD: return \"SI_DETHREAD\";\n }\n return \"?\";\n}\n",
        "output": "0",
        "index": 174448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mode_in(struct cpio *cpio)\n{\n\tstruct archive *a;\n\tstruct archive_entry *entry;\n\tstruct archive *ext;\n\tconst char *destpath;\n\tint r;\n\n\text = archive_write_disk_new();\n\tif (ext == NULL)\n\t\tlafe_errc(1, 0, \"Couldn't allocate restore object\");\n\tr = archive_write_disk_set_options(ext, cpio->extract_flags);\n\tif (r != ARCHIVE_OK)\n\t\tlafe_errc(1, 0, \"%s\", archive_error_string(ext));\n\ta = archive_read_new();\n\tif (a == NULL)\n\t\tlafe_errc(1, 0, \"Couldn't allocate archive object\");\n\tarchive_read_support_filter_all(a);\n\tarchive_read_support_format_all(a);\n\tif (cpio->passphrase != NULL)\n\t\tr = archive_read_add_passphrase(a, cpio->passphrase);\n\telse\n\t\tr = archive_read_set_passphrase_callback(a, cpio,\n\t\t\t&passphrase_callback);\n\tif (r != ARCHIVE_OK)\n\t\tlafe_errc(1, 0, \"%s\", archive_error_string(a));\n\n\tif (archive_read_open_filename(a, cpio->filename,\n\t\t\t\t\tcpio->bytes_per_block))\n\t\tlafe_errc(1, archive_errno(a),\n\t\t    \"%s\", archive_error_string(a));\n\tfor (;;) {\n\t\tr = archive_read_next_header(a, &entry);\n\t\tif (r == ARCHIVE_EOF)\n\t\t\tbreak;\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tlafe_errc(1, archive_errno(a),\n\t\t\t    \"%s\", archive_error_string(a));\n\t\t}\n\t\tif (archive_match_path_excluded(cpio->matching, entry))\n\t\t\tcontinue;\n\t\tif (cpio->option_rename) {\n\t\t\tdestpath = cpio_rename(archive_entry_pathname(entry));\n\t\t\tarchive_entry_set_pathname(entry, destpath);\n\t\t} else\n\t\t\tdestpath = archive_entry_pathname(entry);\n\t\tif (destpath == NULL)\n\t\t\tcontinue;\n\t\tif (cpio->verbose)\n\t\t\tfprintf(stderr, \"%s\\n\", destpath);\n\t\tif (cpio->dot)\n\t\t\tfprintf(stderr, \".\");\n\t\tif (cpio->uid_override >= 0)\n\t\t\tarchive_entry_set_uid(entry, cpio->uid_override);\n\t\tif (cpio->gid_override >= 0)\n\t\t\tarchive_entry_set_gid(entry, cpio->gid_override);\n\t\tr = archive_write_header(ext, entry);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tfprintf(stderr, \"%s: %s\\n\",\n\t\t\t    archive_entry_pathname(entry),\n\t\t\t    archive_error_string(ext));\n\t\t} else if (!archive_entry_size_is_set(entry)\n\t\t    || archive_entry_size(entry) > 0) {\n\t\t\tr = extract_data(a, ext);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\tcpio->return_value = 1;\n\t\t}\n\t}\n\tr = archive_read_close(a);\n\tif (cpio->dot)\n\t\tfprintf(stderr, \"\\n\");\n\tif (r != ARCHIVE_OK)\n\t\tlafe_errc(1, 0, \"%s\", archive_error_string(a));\n\tr = archive_write_close(ext);\n\tif (r != ARCHIVE_OK)\n\t\tlafe_errc(1, 0, \"%s\", archive_error_string(ext));\n\tif (!cpio->quiet) {\n\t\tint64_t blocks = (archive_filter_bytes(a, 0) + 511)\n\t\t\t      / 512;\n\t\tfprintf(stderr, \"%lu %s\\n\", (unsigned long)blocks,\n\t\t    blocks == 1 ? \"block\" : \"blocks\");\n\t}\n\tarchive_read_free(a);\n\tarchive_write_free(ext);\n\texit(cpio->return_value);\n}\n",
        "output": "0",
        "index": 43877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n \tchar *rundir;\n \n \t/* lockfile will be:\n\t * \"/run\" + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n \t * or\n\t * $XDG_RUNTIME_DIR + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n \t */\n \n\t/* length of \"/lock/lxc/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n \t\treturn NULL;\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n\t\t/* fall back to \"/tmp/\" + $(id -u) + \"/lxc\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0'\n\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n\t\t * * lxcpath always starts with '/'\n\t\t */\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n \n \tfree(rundir);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;\n\t}\n\treturn dest;\n}\n",
        "output": "1",
        "index": 179897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pmcraid_register_interrupt_handler(struct pmcraid_instance *pinstance)\n{\n\tint rc;\n\tstruct pci_dev *pdev = pinstance->pdev;\n\n\tif ((pmcraid_enable_msix) &&\n\t\t(pci_find_capability(pdev, PCI_CAP_ID_MSIX))) {\n\t\tint num_hrrq = PMCRAID_NUM_MSIX_VECTORS;\n\t\tstruct msix_entry entries[PMCRAID_NUM_MSIX_VECTORS];\n\t\tint i;\n\t\tfor (i = 0; i < PMCRAID_NUM_MSIX_VECTORS; i++)\n\t\t\tentries[i].entry = i;\n\n\t\trc = pci_enable_msix(pdev, entries, num_hrrq);\n\t\tif (rc < 0)\n\t\t\tgoto pmcraid_isr_legacy;\n\n\t\t/* Check how many MSIX vectors are allocated and register\n\t\t * msi-x handlers for each of them giving appropriate buffer\n\t\t */\n\t\tif (rc > 0) {\n\t\t\tnum_hrrq = rc;\n\t\t\tif (pci_enable_msix(pdev, entries, num_hrrq))\n\t\t\t\tgoto pmcraid_isr_legacy;\n\t\t}\n\n\t\tfor (i = 0; i < num_hrrq; i++) {\n\t\t\tpinstance->hrrq_vector[i].hrrq_id = i;\n\t\t\tpinstance->hrrq_vector[i].drv_inst = pinstance;\n\t\t\tpinstance->hrrq_vector[i].vector = entries[i].vector;\n\t\t\trc = request_irq(pinstance->hrrq_vector[i].vector,\n\t\t\t\t\tpmcraid_isr_msix, 0,\n\t\t\t\t\tPMCRAID_DRIVER_NAME,\n\t\t\t\t\t&(pinstance->hrrq_vector[i]));\n\n\t\t\tif (rc) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\tfree_irq(entries[j].vector,\n\t\t\t\t\t\t &(pinstance->hrrq_vector[j]));\n\t\t\t\tpci_disable_msix(pdev);\n\t\t\t\tgoto pmcraid_isr_legacy;\n\t\t\t}\n\t\t}\n\n\t\tpinstance->num_hrrq = num_hrrq;\n\t\tpinstance->interrupt_mode = 1;\n\t\tiowrite32(DOORBELL_INTR_MODE_MSIX,\n\t\t\t  pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tioread32(pinstance->int_regs.host_ioa_interrupt_reg);\n\t\tgoto pmcraid_isr_out;\n\t}\n\npmcraid_isr_legacy:\n\t/* If MSI-X registration failed fallback to legacy mode, where\n\t * only one hrrq entry will be used\n\t */\n\tpinstance->hrrq_vector[0].hrrq_id = 0;\n\tpinstance->hrrq_vector[0].drv_inst = pinstance;\n\tpinstance->hrrq_vector[0].vector = pdev->irq;\n\tpinstance->num_hrrq = 1;\n\trc = 0;\n\n\trc = request_irq(pdev->irq, pmcraid_isr, IRQF_SHARED,\n\t\t\t PMCRAID_DRIVER_NAME, &pinstance->hrrq_vector[0]);\npmcraid_isr_out:\n\treturn rc;\n}\n",
        "output": "0",
        "index": 26487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int AppLayerProtoDetectTest02(void)\n{\n    AppLayerProtoDetectUnittestCtxBackup();\n    AppLayerProtoDetectSetup();\n\n    int r = 0;\n\n    const char *buf = \"HTTP\";\n    AppLayerProtoDetectPMRegisterPatternCS(IPPROTO_TCP, ALPROTO_HTTP, buf, 4, 0, STREAM_TOCLIENT);\n    buf = \"ftp\";\n    AppLayerProtoDetectPMRegisterPatternCS(IPPROTO_TCP, ALPROTO_FTP, buf, 4, 0, STREAM_TOCLIENT);\n\n    AppLayerProtoDetectPrepareState();\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].max_pat_id != 0) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].max_pat_id != 0\\n\");\n        goto end;\n    }\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].max_pat_id != 2) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].max_pat_id != 2\\n\");\n        goto end;\n    }\n\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].map != NULL) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[0].map != NULL\\n\");\n        goto end;\n    }\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map == NULL) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map != NULL\\n\");\n        goto end;\n    }\n\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map[0]->alproto != ALPROTO_FTP) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map[0].alproto != ALPROTO_FTP\\n\");\n        goto end;\n    }\n    if (alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map[1]->alproto != ALPROTO_HTTP) {\n        printf(\"alpd_ctx.ctx_ipp[FLOW_PROTO_TCP].ctx_pm[1].map[1].alproto != ALPROTO_HTTP\\n\");\n        goto end;\n    }\n\n    r = 1;\n\n end:\n    AppLayerProtoDetectDeSetup();\n    AppLayerProtoDetectUnittestCtxRestore();\n    return r;\n}\n",
        "output": "0",
        "index": 96513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ip_tunnel * ipgre_tunnel_lookup(struct net_device *dev,\n\t\t\t\t\t      __be32 remote, __be32 local,\n\t\t\t\t\t      __be32 key, __be16 gre_proto)\n{\n\tstruct net *net = dev_net(dev);\n\tint link = dev->ifindex;\n\tunsigned h0 = HASH(remote);\n\tunsigned h1 = HASH(key);\n\tstruct ip_tunnel *t, *cand = NULL;\n\tstruct ipgre_net *ign = net_generic(net, ipgre_net_id);\n\tint dev_type = (gre_proto == htons(ETH_P_TEB)) ?\n\t\t       ARPHRD_ETHER : ARPHRD_IPGRE;\n\tint score, cand_score = 4;\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local != t->parms.iph.saddr ||\n\t\t    remote != t->parms.iph.daddr ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_r[h0 ^ h1]) {\n\t\tif (remote != t->parms.iph.daddr ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_l[h1]) {\n\t\tif ((local != t->parms.iph.saddr &&\n\t\t     (local != t->parms.iph.daddr ||\n\t\t      !ipv4_is_multicast(local))) ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(ign->tunnels_wc[h1]) {\n\t\tif (t->parms.i_key != key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IPGRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tif (cand != NULL)\n\t\treturn cand;\n\n\tdev = ign->fb_tunnel_dev;\n\tif (dev->flags & IFF_UP)\n\t\treturn netdev_priv(dev);\n\n\treturn NULL;\n}\n",
        "output": "0",
        "index": 27505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MPEG4Extractor::parseSegmentIndex(off64_t offset, size_t size) {\n  ALOGV(\"MPEG4Extractor::parseSegmentIndex\");\n\n if (size < 12) {\n return -EINVAL;\n }\n\n uint32_t flags;\n if (!mDataSource->getUInt32(offset, &flags)) {\n return ERROR_MALFORMED;\n }\n\n uint32_t version = flags >> 24;\n    flags &= 0xffffff;\n\n    ALOGV(\"sidx version %d\", version);\n\n uint32_t referenceId;\n if (!mDataSource->getUInt32(offset + 4, &referenceId)) {\n return ERROR_MALFORMED;\n }\n\n uint32_t timeScale;\n if (!mDataSource->getUInt32(offset + 8, &timeScale)) {\n return ERROR_MALFORMED;\n }\n    ALOGV(\"sidx refid/timescale: %d/%d\", referenceId, timeScale);\n\n uint64_t earliestPresentationTime;\n uint64_t firstOffset;\n\n    offset += 12;\n    size -= 12;\n\n if (version == 0) {\n if (size < 8) {\n return -EINVAL;\n }\n uint32_t tmp;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        earliestPresentationTime = tmp;\n if (!mDataSource->getUInt32(offset + 4, &tmp)) {\n return ERROR_MALFORMED;\n }\n        firstOffset = tmp;\n        offset += 8;\n        size -= 8;\n } else {\n if (size < 16) {\n return -EINVAL;\n }\n if (!mDataSource->getUInt64(offset, &earliestPresentationTime)) {\n return ERROR_MALFORMED;\n }\n if (!mDataSource->getUInt64(offset + 8, &firstOffset)) {\n return ERROR_MALFORMED;\n }\n        offset += 16;\n        size -= 16;\n }\n    ALOGV(\"sidx pres/off: %Ld/%Ld\", earliestPresentationTime, firstOffset);\n\n if (size < 4) {\n return -EINVAL;\n }\n\n uint16_t referenceCount;\n if (!mDataSource->getUInt16(offset + 2, &referenceCount)) {\n return ERROR_MALFORMED;\n }\n    offset += 4;\n    size -= 4;\n    ALOGV(\"refcount: %d\", referenceCount);\n\n if (size < referenceCount * 12) {\n return -EINVAL;\n }\n\n uint64_t total_duration = 0;\n for (unsigned int i = 0; i < referenceCount; i++) {\n uint32_t d1, d2, d3;\n\n if (!mDataSource->getUInt32(offset, &d1) || // size\n !mDataSource->getUInt32(offset + 4, &d2) || // duration\n !mDataSource->getUInt32(offset + 8, &d3)) { // flags\n return ERROR_MALFORMED;\n }\n\n if (d1 & 0x80000000) {\n            ALOGW(\"sub-sidx boxes not supported yet\");\n }\n bool sap = d3 & 0x80000000;\n bool saptype = d3 >> 28;\n if (!sap || saptype > 2) {\n            ALOGW(\"not a stream access point, or unsupported type\");\n }\n        total_duration += d2;\n        offset += 12;\n        ALOGV(\" item %d, %08x %08x %08x\", i, d1, d2, d3);\n SidxEntry se;\n        se.mSize = d1 & 0x7fffffff;\n        se.mDurationUs = 1000000LL * d2 / timeScale;\n        mSidxEntries.add(se);\n }\n\n    mSidxDuration = total_duration * 1000000 / timeScale;\n    ALOGV(\"duration: %lld\", mSidxDuration);\n\n int64_t metaDuration;\n if (!mLastTrack->meta->findInt64(kKeyDuration, &metaDuration) || metaDuration == 0) {\n        mLastTrack->meta->setInt64(kKeyDuration, mSidxDuration);\n }\n return OK;\n}\n",
        "output": "0",
        "index": 175040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t ZSTD_CCtx_setParameter(ZSTD_CCtx* cctx, ZSTD_cParameter param, unsigned value)\n{\n    DEBUGLOG(4, \"ZSTD_CCtx_setParameter (%u, %u)\", (U32)param, value);\n    if (cctx->streamStage != zcss_init) {\n        if (ZSTD_isUpdateAuthorized(param)) {\n            cctx->cParamsChanged = 1;\n        } else {\n            return ERROR(stage_wrong);\n    }   }\n\n    switch(param)\n    {\n    case ZSTD_p_format :\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_compressionLevel:\n        if (cctx->cdict) return ERROR(stage_wrong);\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_windowLog:\n    case ZSTD_p_hashLog:\n    case ZSTD_p_chainLog:\n    case ZSTD_p_searchLog:\n    case ZSTD_p_minMatch:\n    case ZSTD_p_targetLength:\n    case ZSTD_p_compressionStrategy:\n        if (cctx->cdict) return ERROR(stage_wrong);\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_contentSizeFlag:\n    case ZSTD_p_checksumFlag:\n    case ZSTD_p_dictIDFlag:\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_forceMaxWindow :  /* Force back-references to remain < windowSize,\n                                   * even when referencing into Dictionary content.\n                                   * default : 0 when using a CDict, 1 when using a Prefix */\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_forceAttachDict:\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_nbWorkers:\n        if ((value>0) && cctx->staticSize) {\n            return ERROR(parameter_unsupported);  /* MT not compatible with static alloc */\n        }\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_jobSize:\n    case ZSTD_p_overlapSizeLog:\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    case ZSTD_p_enableLongDistanceMatching:\n    case ZSTD_p_ldmHashLog:\n    case ZSTD_p_ldmMinMatch:\n    case ZSTD_p_ldmBucketSizeLog:\n    case ZSTD_p_ldmHashEveryLog:\n        if (cctx->cdict) return ERROR(stage_wrong);\n        return ZSTD_CCtxParam_setParameter(&cctx->requestedParams, param, value);\n\n    default: return ERROR(parameter_unsupported);\n    }\n}\n",
        "output": "0",
        "index": 89994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "auth_update_component(struct sc_card *card, struct auth_update_component_info *args)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[SC_MAX_APDU_BUFFER_SIZE + 0x10];\n\tunsigned char ins, p1, p2;\n\tint rv, len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (args->len > sizeof(sbuf) || args->len > 0x100)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\tsc_log(card->ctx, \"nn %i; len %i\", args->component, args->len);\n\tins = 0xD8;\n\tp1 = args->component;\n\tp2 = 0x04;\n\tlen = 0;\n\n\tsbuf[len++] = args->type;\n\tsbuf[len++] = args->len;\n\tmemcpy(sbuf + len, args->data, args->len);\n\tlen += args->len;\n\n\tif (args->type == SC_CARDCTL_OBERTHUR_KEY_DES)   {\n\t\tint outl;\n\t\tconst unsigned char in[8] = {0,0,0,0,0,0,0,0};\n\t\tunsigned char out[8];\n\t\tEVP_CIPHER_CTX  * ctx = NULL;\n\n\t\tif (args->len!=8 && args->len!=24)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t\tctx = EVP_CIPHER_CTX_new();\n\t\tif (ctx == NULL) \n\t\t    SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL,SC_ERROR_OUT_OF_MEMORY);\n\n\t\tp2 = 0;\n\t\tif (args->len == 24)\n\t\t\tEVP_EncryptInit_ex(ctx, EVP_des_ede(), NULL, args->data, NULL);\n\t\telse\n\t\t\tEVP_EncryptInit_ex(ctx, EVP_des_ecb(), NULL, args->data, NULL);\n\t\trv = EVP_EncryptUpdate(ctx, out, &outl, in, 8);\n\t\tEVP_CIPHER_CTX_free(ctx);\n\t\tif (rv == 0) {\n\t\t\tsc_log(card->ctx, \"OpenSSL encryption error.\");\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t\t}\n\n\t\tsbuf[len++] = 0x03;\n\t\tmemcpy(sbuf + len, out, 3);\n\t\tlen += 3;\n\t}\n\telse   {\n\t\tsbuf[len++] = 0;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, ins,\tp1, p2);\n\tapdu.cla |= 0x80;\n\tapdu.data = sbuf;\n\tapdu.datalen = len;\n\tapdu.lc = len;\n\tif (args->len == 0x100)   {\n\t\tsbuf[0] = args->type;\n\t\tsbuf[1] = 0x20;\n\t\tmemcpy(sbuf + 2, args->data, 0x20);\n\t\tsbuf[0x22] = 0;\n\t\tapdu.cla |= 0x10;\n\t\tapdu.data = sbuf;\n\t\tapdu.datalen = 0x23;\n\t\tapdu.lc = 0x23;\n\t\trv = sc_transmit_apdu(card, &apdu);\n\t\tapdu.cla &= ~0x10;\n\t\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\n\t\tsbuf[0] = args->type;\n\t\tsbuf[1] = 0xE0;\n\t\tmemcpy(sbuf + 2, args->data + 0x20, 0xE0);\n\t\tsbuf[0xE2] = 0;\n\t\tapdu.data = sbuf;\n\t\tapdu.datalen = 0xE3;\n\t\tapdu.lc = 0xE3;\n\t}\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tsc_mem_clear(sbuf, sizeof(sbuf));\n\tLOG_TEST_RET(card->ctx, rv, \"APDU transmit failed\");\n\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(card->ctx, rv);\n}\n",
        "output": "0",
        "index": 78564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_seek_data(\n\tstruct file\t\t*file,\n\tloff_t\t\t\tstart)\n{\n\tstruct inode\t\t*inode = file->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tloff_t\t\t\tuninitialized_var(offset);\n\txfs_fsize_t\t\tisize;\n\txfs_fileoff_t\t\tfsbno;\n\txfs_filblks_t\t\tend;\n\tuint\t\t\tlock;\n\tint\t\t\terror;\n\n\tlock = xfs_ilock_data_map_shared(ip);\n\n\tisize = i_size_read(inode);\n\tif (start >= isize) {\n\t\terror = ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Try to read extents from the first block indicated\n\t * by fsbno to the end block of the file.\n\t */\n\tfsbno = XFS_B_TO_FSBT(mp, start);\n\tend = XFS_B_TO_FSB(mp, isize);\n\tfor (;;) {\n\t\tstruct xfs_bmbt_irec\tmap[2];\n\t\tint\t\t\tnmap = 2;\n\t\tunsigned int\t\ti;\n\n\t\terror = xfs_bmapi_read(ip, fsbno, end - fsbno, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\t/* No extents at given offset, must be beyond EOF */\n\t\tif (nmap == 0) {\n\t\t\terror = ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < nmap; i++) {\n\t\t\toffset = max_t(loff_t, start,\n\t\t\t\t       XFS_FSB_TO_B(mp, map[i].br_startoff));\n\n\t\t\t/* Landed in a data extent */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK ||\n\t\t\t    (map[i].br_state == XFS_EXT_NORM &&\n\t\t\t     !isnullstartblock(map[i].br_startblock)))\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Landed in an unwritten extent, try to search data\n\t\t\t * from page cache.\n\t\t\t */\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\tif (xfs_find_get_desired_pgoff(inode, &map[i],\n\t\t\t\t\t\t\tDATA_OFF, &offset))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * map[0] is hole or its an unwritten extent but\n\t\t * without data in page cache.  Probably means that\n\t\t * we are reading after EOF if nothing in map[1].\n\t\t */\n\t\tif (nmap == 1) {\n\t\t\terror = ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tASSERT(i > 1);\n\n\t\t/*\n\t\t * Nothing was found, proceed to the next round of search\n\t\t * if reading offset not beyond or hit EOF.\n\t\t */\n\t\tfsbno = map[i - 1].br_startoff + map[i - 1].br_blockcount;\n\t\tstart = XFS_FSB_TO_B(mp, fsbno);\n\t\tif (start >= isize) {\n\t\t\terror = ENXIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout:\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout_unlock:\n\txfs_iunlock(ip, lock);\n\n\tif (error)\n\t\treturn -error;\n\treturn offset;\n}\n",
        "output": "0",
        "index": 46451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Image *decompress_block(Image *orig, unsigned int *Size, ImageInfo *clone_info, ExceptionInfo *exception)\n{\n\nImage *image2;\nvoid *cache_block, *decompress_block;\nz_stream zip_info;\nFILE *mat_file;\nsize_t magick_size;\nsize_t extent;\nint file;\n\nint status;\nint zip_status;\nssize_t TotalSize = 0;\n\n  if(clone_info==NULL) return NULL;\n  if(clone_info->file)    /* Close file opened from previous transaction. */\n  {\n    fclose(clone_info->file);\n    clone_info->file = NULL;\n    (void) remove_utf8(clone_info->filename);\n  }\n\n  cache_block = AcquireQuantumMemory((size_t)(*Size< 16384) ? *Size: 16384,sizeof(unsigned char *));\n  if(cache_block==NULL) return NULL;\n  decompress_block = AcquireQuantumMemory((size_t)(4096),sizeof(unsigned char *));\n  if(decompress_block==NULL)\n  {\n    RelinquishMagickMemory(cache_block);\n    return NULL;\n  }\n\n  mat_file=0;\n  file = AcquireUniqueFileResource(clone_info->filename);\n  if (file != -1)\n    mat_file = fdopen(file,\"w\");\n  if(!mat_file)\n  {\n    RelinquishMagickMemory(cache_block);\n    RelinquishMagickMemory(decompress_block);\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Cannot create file stream for decompressed image\");\n    return NULL;\n  }\n\n  zip_info.zalloc=AcquireZIPMemory;\n  zip_info.zfree=RelinquishZIPMemory;\n  zip_info.opaque = (voidpf) NULL;\n  zip_status = inflateInit(&zip_info);\n  if (zip_status != Z_OK)\n    {\n      RelinquishMagickMemory(cache_block);\n      RelinquishMagickMemory(decompress_block);\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"UnableToUncompressImage\",\"`%s'\",clone_info->filename);\n      (void) fclose(mat_file);\n      RelinquishUniqueFileResource(clone_info->filename);\n      return NULL;\n    }\n  /* zip_info.next_out = 8*4;*/\n\n  zip_info.avail_in = 0;\n  zip_info.total_out = 0;\n  while(*Size>0 && !EOFBlob(orig))\n  {\n    magick_size = ReadBlob(orig, (*Size < 16384) ? *Size : 16384, (unsigned char *) cache_block);\n    zip_info.next_in = (Bytef *) cache_block;\n    zip_info.avail_in = (uInt) magick_size;\n\n    while(zip_info.avail_in>0)\n    {\n      zip_info.avail_out = 4096;\n      zip_info.next_out = (Bytef *) decompress_block;\n      zip_status = inflate(&zip_info,Z_NO_FLUSH);\n\t\t\tif ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n        break;\n      extent=fwrite(decompress_block, 4096-zip_info.avail_out, 1, mat_file);\n      (void) extent;\n      TotalSize += 4096-zip_info.avail_out;\n\n      if(zip_status == Z_STREAM_END) goto DblBreak;\n    }\n \t  if ((zip_status != Z_OK) && (zip_status != Z_STREAM_END))\n      break;\n\n    *Size -= magick_size;\n  }\nDblBreak:\n\n  inflateEnd(&zip_info);\n  (void)fclose(mat_file);\n  RelinquishMagickMemory(cache_block);\n  RelinquishMagickMemory(decompress_block);\n  *Size = TotalSize;\n\n  if((clone_info->file=fopen(clone_info->filename,\"rb\"))==NULL) goto UnlinkFile;\n  if( (image2 = AcquireImage(clone_info))==NULL ) goto EraseFile;\n  status = OpenBlob(clone_info,image2,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n  {\n    DeleteImageFromList(&image2);\nEraseFile:\n    fclose(clone_info->file);\n    clone_info->file = NULL;\nUnlinkFile:\n    RelinquishUniqueFileResource(clone_info->filename);\n    return NULL;\n  }\n\n  return image2;\n}\n",
        "output": "0",
        "index": 62097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int replace_map_fd_with_map_ptr(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tint insn_cnt = env->prog->len;\n\tint i, j, err;\n\n\terr = bpf_prog_calc_tag(env->prog);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) == BPF_LDX &&\n\t\t    (BPF_MODE(insn->code) != BPF_MEM || insn->imm != 0)) {\n\t\t\tverbose(env, \"BPF_LDX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (BPF_CLASS(insn->code) == BPF_STX &&\n\t\t    ((BPF_MODE(insn->code) != BPF_MEM &&\n\t\t      BPF_MODE(insn->code) != BPF_XADD) || insn->imm != 0)) {\n\t\t\tverbose(env, \"BPF_STX uses reserved fields\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (insn[0].code == (BPF_LD | BPF_IMM | BPF_DW)) {\n\t\t\tstruct bpf_map *map;\n\t\t\tstruct fd f;\n\n\t\t\tif (i == insn_cnt - 1 || insn[1].code != 0 ||\n\t\t\t    insn[1].dst_reg != 0 || insn[1].src_reg != 0 ||\n\t\t\t    insn[1].off != 0) {\n\t\t\t\tverbose(env, \"invalid bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (insn->src_reg == 0)\n\t\t\t\t/* valid generic load 64-bit imm */\n\t\t\t\tgoto next_insn;\n\n\t\t\tif (insn->src_reg != BPF_PSEUDO_MAP_FD) {\n\t\t\t\tverbose(env,\n\t\t\t\t\t\"unrecognized bpf_ld_imm64 insn\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tf = fdget(insn->imm);\n\t\t\tmap = __bpf_map_get(f);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tverbose(env, \"fd %d is not pointing to valid bpf_map\\n\",\n\t\t\t\t\tinsn->imm);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\n\t\t\terr = check_map_prog_compatibility(env, map, env->prog);\n\t\t\tif (err) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\t/* store map pointer inside BPF_LD_IMM64 instruction */\n\t\t\tinsn[0].imm = (u32) (unsigned long) map;\n\t\t\tinsn[1].imm = ((u64) (unsigned long) map) >> 32;\n\n\t\t\t/* check whether we recorded this map already */\n\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_used_maps()\n\t\t\t */\n\t\t\tmap = bpf_map_inc(map, false);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tif (bpf_map_is_cgroup_storage(map) &&\n\t\t\t    bpf_cgroup_storage_assign(env->prog, map)) {\n\t\t\t\tverbose(env, \"only one cgroup storage of each type is allowed\\n\");\n\t\t\t\tfdput(f);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Basic sanity check before we invest more work here. */\n\t\tif (!bpf_opcode_in_insntable(insn->code)) {\n\t\t\tverbose(env, \"unknown opcode %02x\\n\", insn->code);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.\n\t */\n\treturn 0;\n}\n",
        "output": "0",
        "index": 91477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_for_audio_disc(struct cdrom_device_info *cdi,\n\t\t\t\tconst struct cdrom_device_ops *cdo)\n{\n        int ret;\n\ttracktype tracks;\n\tcd_dbg(CD_OPEN, \"entering check_for_audio_disc\\n\");\n\tif (!(cdi->options & CDO_CHECK_TYPE))\n\t\treturn 0;\n\tif (cdo->drive_status != NULL) {\n\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\tcd_dbg(CD_OPEN, \"drive_status=%d\\n\", ret);\n\t\tif (ret == CDS_TRAY_OPEN) {\n\t\t\tcd_dbg(CD_OPEN, \"the tray is open...\\n\");\n\t\t\t/* can/may i close it? */\n\t\t\tif (CDROM_CAN(CDC_CLOSE_TRAY) &&\n\t\t\t    cdi->options & CDO_AUTO_CLOSE) {\n\t\t\t\tcd_dbg(CD_OPEN, \"trying to close the tray\\n\");\n\t\t\t\tret=cdo->tray_move(cdi,0);\n\t\t\t\tif (ret) {\n\t\t\t\t\tcd_dbg(CD_OPEN, \"bummer. tried to close tray but failed.\\n\");\n\t\t\t\t\t/* Ignore the error from the low\n\t\t\t\t\tlevel driver.  We don't care why it\n\t\t\t\t\tcouldn't close the tray.  We only care \n\t\t\t\t\tthat there is no disc in the drive, \n\t\t\t\t\tsince that is the _REAL_ problem here.*/\n\t\t\t\t\treturn -ENOMEDIUM;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. this driver can't close the tray.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\n\t\t\t/* Ok, the door should be closed now.. Check again */\n\t\t\tret = cdo->drive_status(cdi, CDSL_CURRENT);\n\t\t\tif ((ret == CDS_NO_DISC) || (ret==CDS_TRAY_OPEN)) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. the tray is still not closed.\\n\");\n\t\t\t\treturn -ENOMEDIUM;\n\t\t\t}\t\n\t\t\tif (ret!=CDS_DISC_OK) {\n\t\t\t\tcd_dbg(CD_OPEN, \"bummer. disc isn't ready.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\t\n\t\t\tcd_dbg(CD_OPEN, \"the tray is now closed\\n\");\n\t\t}\t\n\t}\n\tcdrom_count_tracks(cdi, &tracks);\n\tif (tracks.error) \n\t\treturn(tracks.error);\n\n\tif (tracks.audio==0)\n\t\treturn -EMEDIUMTYPE;\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 76284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(pg_send_query_params)\n{\n\tzval *pgsql_link, *pv_param_arr, **tmp;\n\tint num_params = 0;\n\tchar **params = NULL;\n\tchar *query;\n\tint query_len, id = -1;\n\tPGconn *pgsql;\n\tPGresult *res;\n\tint leftover = 0;\n\tint ret;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsa/\", &pgsql_link, &query, &query_len, &pv_param_arr) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, &pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\n\tif (PQ_SETNONBLOCKING(pgsql, 1)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Cannot set connection to nonblocking mode\");\n\t\tRETURN_FALSE;\n\t}\n\twhile ((res = PQgetResult(pgsql))) {\n\t\tPQclear(res);\n\t\tleftover = 1;\n\t}\n\tif (leftover) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"There are results on this connection. Call pg_get_result() until it returns FALSE\");\n\t}\n\n\tzend_hash_internal_pointer_reset(Z_ARRVAL_P(pv_param_arr));\n\tnum_params = zend_hash_num_elements(Z_ARRVAL_P(pv_param_arr));\n\tif (num_params > 0) {\n\t\tint i = 0;\n\t\tparams = (char **)safe_emalloc(sizeof(char *), num_params, 0);\n\t\t\n\t\tfor(i = 0; i < num_params; i++) {\n\t\t\tif (zend_hash_get_current_data(Z_ARRVAL_P(pv_param_arr), (void **) &tmp) == FAILURE) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Error getting parameter\");\n\t\t\t\t_php_pgsql_free_params(params, num_params);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_PP(tmp) == IS_NULL) {\n\t\t\t\tparams[i] = NULL;\n\t\t\t} else {\n\t\t\t\tzval tmp_val = **tmp;\n\t\t\t\tzval_copy_ctor(&tmp_val);\n\t\t\t\tconvert_to_string(&tmp_val);\n\t\t\t\tif (Z_TYPE(tmp_val) != IS_STRING) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Error converting parameter\");\n\t\t\t\t\tzval_dtor(&tmp_val);\n\t\t\t\t\t_php_pgsql_free_params(params, num_params);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tparams[i] = estrndup(Z_STRVAL(tmp_val), Z_STRLEN(tmp_val));\n\t\t\t\tzval_dtor(&tmp_val);\n\t\t\t}\n\n\t\t\tzend_hash_move_forward(Z_ARRVAL_P(pv_param_arr));\n\t\t}\n\t}\n\n\tif (!PQsendQueryParams(pgsql, query, num_params, NULL, (const char * const *)params, NULL, NULL, 0)) {\n\t\tif ((PGG(auto_reset_persistent) & 2) && PQstatus(pgsql) != CONNECTION_OK) {\n\t\t\tPQreset(pgsql);\n\t\t}\n\t\tif (!PQsendQueryParams(pgsql, query, num_params, NULL, (const char * const *)params, NULL, NULL, 0)) {\n\t\t\t_php_pgsql_free_params(params, num_params);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\t_php_pgsql_free_params(params, num_params);\n\t/* Wait to finish sending buffer */\n\twhile ((ret = PQflush(pgsql))) {\n\t\tif (ret == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Could not empty PostgreSQL send buffer\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10000);\n\t}\n\tif (PQ_SETNONBLOCKING(pgsql, 0)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Cannot set connection to blocking mode\");\n\t}\n\tRETURN_TRUE;\n}\n",
        "output": "0",
        "index": 14759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,\n\t\t\tconst struct utee_attribute *usr_params,\n\t\t\tunsigned long param_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tsize_t byte_size;\n\tTEE_Attribute *params = NULL;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/* Must be a transient object */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Must not be initialized already */\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\t/* Find description of object */\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\t/* Check that maxKeySize follows restrictions */\n\tif (key_size % type_props->quanta != 0)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size < type_props->min_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\tif (key_size > type_props->max_size)\n\t\treturn TEE_ERROR_NOT_SUPPORTED;\n\n\tparams = malloc(sizeof(TEE_Attribute) * param_count);\n\tif (!params)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,\n\t\t\t    params);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,\n\t\t\t\t      params, param_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tswitch (o->info.objectType) {\n\tcase TEE_TYPE_AES:\n\tcase TEE_TYPE_DES:\n\tcase TEE_TYPE_DES3:\n\tcase TEE_TYPE_HMAC_MD5:\n\tcase TEE_TYPE_HMAC_SHA1:\n\tcase TEE_TYPE_HMAC_SHA224:\n\tcase TEE_TYPE_HMAC_SHA256:\n\tcase TEE_TYPE_HMAC_SHA384:\n\tcase TEE_TYPE_HMAC_SHA512:\n\tcase TEE_TYPE_GENERIC_SECRET:\n\t\tbyte_size = key_size / 8;\n\n\t\t/*\n\t\t * We have to do it like this because the parity bits aren't\n\t\t * counted when telling the size of the key in bits.\n\t\t */\n\t\tif (o->info.objectType == TEE_TYPE_DES ||\n\t\t    o->info.objectType == TEE_TYPE_DES3) {\n\t\t\tbyte_size = (key_size + key_size / 7) / 8;\n\t\t}\n\n\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\tif (byte_size > key->alloc_size) {\n\t\t\tres = TEE_ERROR_EXCESS_DATA;\n\t\t\tgoto out;\n\t\t}\n\n\t\tres = crypto_rng_read((void *)(key + 1), byte_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\n\t\tkey->key_size = byte_size;\n\n\t\t/* Set bits for all known attributes for this object type */\n\t\to->have_attrs = (1 << type_props->num_type_attrs) - 1;\n\n\t\tbreak;\n\n\tcase TEE_TYPE_RSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_rsa(o, type_props, key_size,\n\t\t\t\t\t\t   params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DSA_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dsa(o, type_props, key_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_DH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_dh(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase TEE_TYPE_ECDSA_KEYPAIR:\n\tcase TEE_TYPE_ECDH_KEYPAIR:\n\t\tres = tee_svc_obj_generate_key_ecc(o, type_props, key_size,\n\t\t\t\t\t\t  params, param_count);\n\t\tif (res != TEE_SUCCESS)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\tres = TEE_ERROR_BAD_FORMAT;\n\t}\n\nout:\n\tfree(params);\n\tif (res == TEE_SUCCESS) {\n\t\to->info.keySize = key_size;\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\n\t}\n\treturn res;\n}\n",
        "output": "0",
        "index": 86902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Render_Gray_Glyph( RAS_ARG )\n  {\n    Long      pixel_width;\n    FT_Error  error;\n\n\n    Set_High_Precision( RAS_VARS ras.outline.flags &\n                                 FT_OUTLINE_HIGH_PRECISION );\n    ras.scale_shift = ras.precision_shift + 1;\n\n    if ( ras.outline.flags & FT_OUTLINE_IGNORE_DROPOUTS )\n      ras.dropOutControl = 2;\n    else\n    {\n      if ( ras.outline.flags & FT_OUTLINE_SMART_DROPOUTS )\n        ras.dropOutControl = 4;\n      else\n        ras.dropOutControl = 0;\n\n      if ( !( ras.outline.flags & FT_OUTLINE_INCLUDE_STUBS ) )\n        ras.dropOutControl += 1;\n    }\n\n    ras.second_pass = !( ras.outline.flags & FT_OUTLINE_SINGLE_PASS );\n\n    /* Vertical Sweep */\n\n    ras.band_top            = 0;\n    ras.band_stack[0].y_min = 0;\n    ras.band_stack[0].y_max = 2 * ras.target.rows - 1;\n\n    ras.bWidth  = ras.gray_width;\n    pixel_width = 2 * ( ( ras.target.width + 3 ) >> 2 );\n\n    if ( ras.bWidth > pixel_width )\n      ras.bWidth = pixel_width;\n\n    ras.bWidth  = ras.bWidth * 8;\n    ras.bTarget = (Byte*)ras.gray_lines;\n    ras.gTarget = (Byte*)ras.target.buffer;\n\n    ras.Proc_Sweep_Init = Vertical_Gray_Sweep_Init;\n    ras.Proc_Sweep_Span = Vertical_Sweep_Span;\n    ras.Proc_Sweep_Drop = Vertical_Sweep_Drop;\n    ras.Proc_Sweep_Step = Vertical_Gray_Sweep_Step;\n\n    error = Render_Single_Pass( RAS_VARS 0 );\n    if ( error )\n      return error;\n\n    /* Horizontal Sweep */\n    if ( ras.second_pass && ras.dropOutControl != 2 )\n    {\n      ras.Proc_Sweep_Init = Horizontal_Sweep_Init;\n      ras.Proc_Sweep_Span = Horizontal_Gray_Sweep_Span;\n      ras.Proc_Sweep_Drop = Horizontal_Gray_Sweep_Drop;\n      ras.Proc_Sweep_Step = Horizontal_Sweep_Step;\n\n      ras.band_top            = 0;\n      ras.band_stack[0].y_min = 0;\n      ras.band_stack[0].y_max = ras.target.width * 2 - 1;\n\n      error = Render_Single_Pass( RAS_VARS 1 );\n      if ( error )\n        return error;\n    }\n\n    return Raster_Err_None;\n  }\n",
        "output": "0",
        "index": 7037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LocalFrame::CanNavigate(const Frame& target_frame,\n                             const KURL& destination_url) {\n  String error_reason;\n  const bool is_allowed_navigation =\n      CanNavigateWithoutFramebusting(target_frame, error_reason);\n  const bool sandboxed =\n      GetSecurityContext()->GetSandboxFlags() != kSandboxNone;\n  const bool has_user_gesture = HasBeenActivated();\n\n  if (target_frame != this && sandboxed && target_frame == Tree().Top()) {\n    UseCounter::Count(this, WebFeature::kTopNavInSandbox);\n    if (!has_user_gesture) {\n      UseCounter::Count(this, WebFeature::kTopNavInSandboxWithoutGesture);\n    }\n  }\n\n  if (target_frame != this &&\n      !GetSecurityContext()->IsSandboxed(kSandboxTopNavigation) &&\n      target_frame == Tree().Top()) {\n    DEFINE_STATIC_LOCAL(EnumerationHistogram, framebust_histogram,\n                        (\"WebCore.Framebust\", 4));\n    const unsigned kUserGestureBit = 0x1;\n    const unsigned kAllowedBit = 0x2;\n    unsigned framebust_params = 0;\n\n    if (has_user_gesture)\n      framebust_params |= kUserGestureBit;\n\n    UseCounter::Count(this, WebFeature::kTopNavigationFromSubFrame);\n    if (sandboxed) {  // Sandboxed with 'allow-top-navigation'.\n      UseCounter::Count(this, WebFeature::kTopNavInSandboxWithPerm);\n      if (!has_user_gesture) {\n        UseCounter::Count(this,\n                          WebFeature::kTopNavInSandboxWithPermButNoGesture);\n      }\n    }\n\n    if (is_allowed_navigation)\n      framebust_params |= kAllowedBit;\n    framebust_histogram.Count(framebust_params);\n    if (has_user_gesture || is_allowed_navigation ||\n        target_frame.GetSecurityContext()->GetSecurityOrigin()->CanAccess(\n            SecurityOrigin::Create(destination_url).get())) {\n      return true;\n    }\n    if (!RuntimeEnabledFeatures::\n            FramebustingNeedsSameOriginOrUserGestureEnabled() ||\n        Client()->GetContentSettingsClient().AllowPopupsAndRedirects(\n            false /* default_value */)) {\n      String target_frame_description =\n          target_frame.IsLocalFrame() ? \"with URL '\" +\n                                            ToLocalFrame(target_frame)\n                                                .GetDocument()\n                                                ->Url()\n                                                .GetString() +\n                                            \"'\"\n                                      : \"with origin '\" +\n                                            target_frame.GetSecurityContext()\n                                                ->GetSecurityOrigin()\n                                                ->ToString() +\n                                            \"'\";\n      String message = \"Frame with URL '\" + GetDocument()->Url().GetString() +\n                       \"' attempted to navigate its top-level window \" +\n                       target_frame_description +\n                       \". Navigating the top-level window from a cross-origin \"\n                       \"iframe will soon require that the iframe has received \"\n                       \"a user gesture. See \"\n                       \"https://www.chromestatus.com/features/\"\n                       \"5851021045661696.\";\n      PrintNavigationWarning(message);\n      return true;\n    }\n    error_reason =\n        \"The frame attempting navigation is targeting its top-level window, \"\n        \"but is neither same-origin with its target nor has it received a \"\n        \"user gesture. See \"\n        \"https://www.chromestatus.com/features/5851021045661696.\";\n    PrintNavigationErrorMessage(target_frame, error_reason.Latin1().data());\n    Client()->DidBlockFramebust(destination_url);\n    return false;\n  }\n\n  if (Client()->Opener() == target_frame &&\n      !HasTransientUserActivation(this, false /* checkIfMainThread */) &&\n      !target_frame.GetSecurityContext()->GetSecurityOrigin()->CanAccess(\n          SecurityOrigin::Create(destination_url).get())) {\n    UseCounter::Count(this, WebFeature::kOpenerNavigationWithoutGesture);\n  }\n\n  if (!is_allowed_navigation && !error_reason.IsNull())\n    PrintNavigationErrorMessage(target_frame, error_reason.Latin1().data());\n  return is_allowed_navigation;\n}\n",
        "output": "0",
        "index": 167907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n                          const unsigned char *in, size_t len)\n{\n    EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,ctx);\n    CCM128_CONTEXT *ccm = &cctx->ccm;\n    /* If not set up, return error */\n    if (!cctx->key_set)\n        return -1;\n\n    if (cctx->tls_aad_len >= 0)\n        return aes_ccm_tls_cipher(ctx, out, in, len);\n\n    if (!cctx->iv_set)\n        return -1;\n\n    if (!EVP_CIPHER_CTX_encrypting(ctx) && !cctx->tag_set)\n        return -1;\n    if (!out) {\n        if (!in) {\n            if (CRYPTO_ccm128_setiv(ccm, EVP_CIPHER_CTX_iv_noconst(ctx),\n                                    15 - cctx->L, len))\n                return -1;\n            cctx->len_set = 1;\n            return len;\n        }\n        /* If have AAD need message length */\n        if (!cctx->len_set && len)\n            return -1;\n        CRYPTO_ccm128_aad(ccm, in, len);\n        return len;\n    }\n    /* EVP_*Final() doesn't return any data */\n    if (!in)\n        return 0;\n    /* If not set length yet do it */\n    if (!cctx->len_set) {\n        if (CRYPTO_ccm128_setiv(ccm, EVP_CIPHER_CTX_iv_noconst(ctx),\n                                15 - cctx->L, len))\n            return -1;\n        cctx->len_set = 1;\n    }\n    if (EVP_CIPHER_CTX_encrypting(ctx)) {\n        if (cctx->str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,\n                                                    cctx->str) :\n            CRYPTO_ccm128_encrypt(ccm, in, out, len))\n            return -1;\n        cctx->tag_set = 1;\n        return len;\n    } else {\n        int rv = -1;\n        if (cctx->str ? !CRYPTO_ccm128_decrypt_ccm64(ccm, in, out, len,\n                                                     cctx->str) :\n            !CRYPTO_ccm128_decrypt(ccm, in, out, len)) {\n            unsigned char tag[16];\n            if (CRYPTO_ccm128_tag(ccm, tag, cctx->M)) {\n                if (!CRYPTO_memcmp(tag, EVP_CIPHER_CTX_buf_noconst(ctx),\n                                   cctx->M))\n                    rv = len;\n            }\n        }\n        if (rv == -1)\n            OPENSSL_cleanse(out, len);\n        cctx->iv_set = 0;\n        cctx->tag_set = 0;\n        cctx->len_set = 0;\n        return rv;\n    }\n}\n",
        "output": "0",
        "index": 69316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParseStartTag(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    const xmlChar *attname;\n    xmlChar *attvalue;\n    const xmlChar **atts = ctxt->atts;\n    int nbatts = 0;\n    int maxatts = ctxt->maxatts;\n    int i;\n\n    if (RAW != '<') return(NULL);\n    NEXT1;\n\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t     \"xmlParseStartTag: invalid element name\\n\");\n        return(NULL);\n    }\n\n    /*\n     * Now parse the attributes, it ends up with the ending\n     *\n     * (S Attribute)* S?\n     */\n    SKIP_BLANKS;\n    GROW;\n\n    while (((RAW != '>') &&\n\t   ((RAW != '/') || (NXT(1) != '>')) &&\n\t   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n\tconst xmlChar *q = CUR_PTR;\n\tunsigned int cons = ctxt->input->consumed;\n\n\tattname = xmlParseAttribute(ctxt, &attvalue);\n        if ((attname != NULL) && (attvalue != NULL)) {\n\t    /*\n\t     * [ WFC: Unique Att Spec ]\n\t     * No attribute name may appear more than once in the same\n\t     * start-tag or empty-element tag.\n\t     */\n\t    for (i = 0; i < nbatts;i += 2) {\n\t        if (xmlStrEqual(atts[i], attname)) {\n\t\t    xmlErrAttributeDup(ctxt, NULL, attname);\n\t\t    xmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t    }\n\t    /*\n\t     * Add the pair to atts\n\t     */\n\t    if (atts == NULL) {\n\t        maxatts = 22; /* allow for 10 attrs by default */\n\t        atts = (const xmlChar **)\n\t\t       xmlMalloc(maxatts * sizeof(xmlChar *));\n\t\tif (atts == NULL) {\n\t\t    xmlErrMemory(ctxt, NULL);\n\t\t    if (attvalue != NULL)\n\t\t\txmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t\tctxt->atts = atts;\n\t\tctxt->maxatts = maxatts;\n\t    } else if (nbatts + 4 > maxatts) {\n\t        const xmlChar **n;\n\n\t        maxatts *= 2;\n\t        n = (const xmlChar **) xmlRealloc((void *) atts,\n\t\t\t\t\t     maxatts * sizeof(const xmlChar *));\n\t\tif (n == NULL) {\n\t\t    xmlErrMemory(ctxt, NULL);\n\t\t    if (attvalue != NULL)\n\t\t\txmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t\tatts = n;\n\t\tctxt->atts = atts;\n\t\tctxt->maxatts = maxatts;\n\t    }\n\t    atts[nbatts++] = attname;\n\t    atts[nbatts++] = attvalue;\n\t    atts[nbatts] = NULL;\n\t    atts[nbatts + 1] = NULL;\n\t} else {\n\t    if (attvalue != NULL)\n\t\txmlFree(attvalue);\n\t}\n\nfailed:\n\n\tGROW\n\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t    break;\n\tif (SKIP_BLANKS == 0) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t   \"attributes construct error\\n\");\n\t}\n        if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&\n            (attname == NULL) && (attvalue == NULL)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t   \"xmlParseStartTag: problem parsing attributes\\n\");\n\t    break;\n\t}\n\tSHRINK;\n        GROW;\n    }\n\n    /*\n     * SAX: Start of Element !\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&\n\t(!ctxt->disableSAX)) {\n\tif (nbatts > 0)\n\t    ctxt->sax->startElement(ctxt->userData, name, atts);\n\telse\n\t    ctxt->sax->startElement(ctxt->userData, name, NULL);\n    }\n\n    if (atts != NULL) {\n        /* Free only the content strings */\n        for (i = 1;i < nbatts;i+=2)\n\t    if (atts[i] != NULL)\n\t       xmlFree((xmlChar *) atts[i]);\n    }\n    return(name);\n}\n",
        "output": "0",
        "index": 59516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int create_pin_file(const sc_path_t *inpath, int chv, const char *key_id)\n{\n\tchar prompt[40], *pin, *puk;\n\tchar buf[30], *p = buf;\n\tsc_path_t file_id, path;\n\tsc_file_t *file;\n\tsize_t len;\n\tint r;\n\n\tfile_id = *inpath;\n\tif (file_id.len < 2)\n\t\treturn -1;\n\tif (chv == 1)\n\t\tsc_format_path(\"I0000\", &file_id);\n\telse if (chv == 2)\n\t\tsc_format_path(\"I0100\", &file_id);\n\telse\n\t\treturn -1;\n\tr = sc_select_file(card, inpath, NULL);\n\tif (r)\n\t\treturn -1;\n\tr = sc_select_file(card, &file_id, NULL);\n\tif (r == 0)\n\t\treturn 0;\n\n\tsprintf(prompt, \"Please enter CHV%d%s: \", chv, key_id);\n\tpin = getpin(prompt);\n\tif (pin == NULL)\n\t\treturn -1;\n\n\tsprintf(prompt, \"Please enter PUK for CHV%d%s: \", chv, key_id);\n\tpuk = getpin(prompt);\n\tif (puk == NULL) {\n\t\tfree(pin);\n\t\treturn -1;\n\t}\n\n\tmemset(p, 0xFF, 3);\n\tp += 3;\n\tmemcpy(p, pin, 8);\n\tp += 8;\n\t*p++ = opt_pin_attempts;\n\t*p++ = opt_pin_attempts;\n\tmemcpy(p, puk, 8);\n\tp += 8;\n\t*p++ = opt_puk_attempts;\n\t*p++ = opt_puk_attempts;\n\tlen = p - buf;\n\n\tfree(pin);\n\tfree(puk);\n\n\tfile = sc_file_new();\n\tfile->type = SC_FILE_TYPE_WORKING_EF;\n\tfile->ef_structure = SC_FILE_EF_TRANSPARENT;\n\tsc_file_add_acl_entry(file, SC_AC_OP_READ, SC_AC_NEVER, SC_AC_KEY_REF_NONE);\n\tif (inpath->len == 2 && inpath->value[0] == 0x3F &&\n\t    inpath->value[1] == 0x00)\n\t\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_AUT, 1);\n\telse\n\t\tsc_file_add_acl_entry(file, SC_AC_OP_UPDATE, SC_AC_CHV, 2);\n\n\tsc_file_add_acl_entry(file, SC_AC_OP_INVALIDATE, SC_AC_AUT, 1);\n\tsc_file_add_acl_entry(file, SC_AC_OP_REHABILITATE, SC_AC_AUT, 1);\n\tfile->size = len;\n\tfile->id = (file_id.value[0] << 8) | file_id.value[1];\n\tr = sc_create_file(card, file);\n\tsc_file_free(file);\n\tif (r) {\n\t\tfprintf(stderr, \"PIN file creation failed: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tpath = *inpath;\n\tsc_append_path(&path, &file_id);\n\tr = sc_select_file(card, &path, NULL);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select created PIN file: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\tr = sc_update_binary(card, 0, (const u8 *) buf, len, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to update created PIN file: %s\\n\", sc_strerror(r));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 78869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret;\n\tunsigned long __user *datap = (unsigned long __user *)data;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long tmp;\n\n\t\tret = -EIO;\n\t\tif ((addr & (sizeof(data) - 1)) || addr >= sizeof(struct user))\n\t\t\tbreak;\n\n\t\ttmp = 0;  /* Default return condition */\n\t\tif (addr < sizeof(struct user_regs_struct))\n\t\t\ttmp = getreg(child, addr);\n\t\telse if (addr >= offsetof(struct user, u_debugreg[0]) &&\n\t\t\t addr <= offsetof(struct user, u_debugreg[7])) {\n\t\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\t\ttmp = ptrace_get_debugreg(child, addr / sizeof(data));\n\t\t}\n\t\tret = put_user(tmp, datap);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_POKEUSR: /* write the word at location addr in the USER area */\n\t\tret = -EIO;\n\t\tif ((addr & (sizeof(data) - 1)) || addr >= sizeof(struct user))\n\t\t\tbreak;\n\n\t\tif (addr < sizeof(struct user_regs_struct))\n\t\t\tret = putreg(child, addr, data);\n\t\telse if (addr >= offsetof(struct user, u_debugreg[0]) &&\n\t\t\t addr <= offsetof(struct user, u_debugreg[7])) {\n\t\t\taddr -= offsetof(struct user, u_debugreg[0]);\n\t\t\tret = ptrace_set_debugreg(child,\n\t\t\t\t\t\t  addr / sizeof(data), data);\n\t\t}\n\t\tbreak;\n\n\tcase PTRACE_GETREGS:\t/* Get all gp regs from the child. */\n\t\treturn copy_regset_to_user(child,\n\t\t\t\t\t   task_user_regset_view(current),\n\t\t\t\t\t   REGSET_GENERAL,\n\t\t\t\t\t   0, sizeof(struct user_regs_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child,\n\t\t\t\t\t     task_user_regset_view(current),\n\t\t\t\t\t     REGSET_GENERAL,\n\t\t\t\t\t     0, sizeof(struct user_regs_struct),\n\t\t\t\t\t     datap);\n\n\tcase PTRACE_GETFPREGS:\t/* Get the child FPU state. */\n\t\treturn copy_regset_to_user(child,\n\t\t\t\t\t   task_user_regset_view(current),\n\t\t\t\t\t   REGSET_FP,\n\t\t\t\t\t   0, sizeof(struct user_i387_struct),\n\t\t\t\t\t   datap);\n\n\tcase PTRACE_SETFPREGS:\t/* Set the child FPU state. */\n\t\treturn copy_regset_from_user(child,\n\t\t\t\t\t     task_user_regset_view(current),\n\t\t\t\t\t     REGSET_FP,\n\t\t\t\t\t     0, sizeof(struct user_i387_struct),\n\t\t\t\t\t     datap);\n\n#ifdef CONFIG_X86_32\n\tcase PTRACE_GETFPXREGS:\t/* Get the child extended FPU state. */\n\t\treturn copy_regset_to_user(child, &user_x86_32_view,\n\t\t\t\t\t   REGSET_XFP,\n\t\t\t\t\t   0, sizeof(struct user_fxsr_struct),\n\t\t\t\t\t   datap) ? -EIO : 0;\n\n\tcase PTRACE_SETFPXREGS:\t/* Set the child extended FPU state. */\n\t\treturn copy_regset_from_user(child, &user_x86_32_view,\n\t\t\t\t\t     REGSET_XFP,\n\t\t\t\t\t     0, sizeof(struct user_fxsr_struct),\n\t\t\t\t\t     datap) ? -EIO : 0;\n#endif\n\n#if defined CONFIG_X86_32 || defined CONFIG_IA32_EMULATION\n\tcase PTRACE_GET_THREAD_AREA:\n\t\tif ((int) addr < 0)\n\t\t\treturn -EIO;\n\t\tret = do_get_thread_area(child, addr,\n\t\t\t\t\t(struct user_desc __user *)data);\n\t\tbreak;\n\n\tcase PTRACE_SET_THREAD_AREA:\n\t\tif ((int) addr < 0)\n\t\t\treturn -EIO;\n\t\tret = do_set_thread_area(child, addr,\n\t\t\t\t\t(struct user_desc __user *)data, 0);\n\t\tbreak;\n#endif\n\n#ifdef CONFIG_X86_64\n\t\t/* normal 64bit interface to access TLS data.\n\t\t   Works just like arch_prctl, except that the arguments\n\t\t   are reversed. */\n\tcase PTRACE_ARCH_PRCTL:\n\t\tret = do_arch_prctl(child, data, addr);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 25887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UWORD8 ih264d_is_end_of_pic(UWORD16 u2_frame_num,\n                            UWORD8 u1_nal_ref_idc,\n pocstruct_t *ps_cur_poc,\n pocstruct_t *ps_prev_poc,\n dec_slice_params_t * ps_prev_slice, /*!< Previous slice parameters*/\n                            UWORD8 u1_pic_order_cnt_type,\n                            UWORD8 u1_nal_unit_type,\n                            UWORD32 u4_idr_pic_id,\n                            UWORD8 u1_field_pic_flag,\n                            UWORD8 u1_bottom_field_flag)\n{\n    WORD8 i1_is_end_of_pic;\n    WORD8 a, b, c, d, e, f, g, h;\n\n    a = b = c = d = e = f = g = h = 0;\n    a = (ps_prev_slice->u2_frame_num != u2_frame_num);\n    b = (ps_prev_slice->u1_field_pic_flag != u1_field_pic_flag);\n if(u1_field_pic_flag && ps_prev_slice->u1_field_pic_flag)\n        c = (u1_bottom_field_flag != ps_prev_slice->u1_bottom_field_flag);\n    d =\n (u1_nal_ref_idc == 0 && ps_prev_slice->u1_nal_ref_idc != 0)\n || (u1_nal_ref_idc != 0\n && ps_prev_slice->u1_nal_ref_idc\n == 0);\n if(!a)\n {\n if((u1_pic_order_cnt_type == 0)\n && (ps_prev_slice->u1_pic_order_cnt_type == 0))\n {\n            e =\n ((ps_cur_poc->i4_pic_order_cnt_lsb\n != ps_prev_poc->i4_pic_order_cnt_lsb)\n || (ps_cur_poc->i4_delta_pic_order_cnt_bottom\n != ps_prev_poc->i4_delta_pic_order_cnt_bottom));\n }\n\n if((u1_pic_order_cnt_type == 1)\n && (ps_prev_slice->u1_pic_order_cnt_type == 1))\n {\n            f =\n ((ps_cur_poc->i4_delta_pic_order_cnt[0]\n != ps_prev_poc->i4_delta_pic_order_cnt[0])\n || (ps_cur_poc->i4_delta_pic_order_cnt[1]\n != ps_prev_poc->i4_delta_pic_order_cnt[1]));\n }\n }\n\n if((u1_nal_unit_type == IDR_SLICE_NAL)\n && (ps_prev_slice->u1_nal_unit_type == IDR_SLICE_NAL))\n {\n        g = (u4_idr_pic_id != ps_prev_slice->u4_idr_pic_id);\n }\n\n if((u1_nal_unit_type == IDR_SLICE_NAL)\n && (ps_prev_slice->u1_nal_unit_type != IDR_SLICE_NAL))\n {\n        h = 1;\n }\n    i1_is_end_of_pic = a + b + c + d + e + f + g + h;\n return (i1_is_end_of_pic);\n}\n",
        "output": "0",
        "index": 175724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t\t    struct pipe_inode_info *pipe, size_t len,\n\t\t\t    unsigned int flags)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tstruct partial_page partial_def[PIPE_DEF_BUFFERS];\n\tstruct page *pages_def[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages_max\t= PIPE_DEF_BUFFERS,\n\t\t.ops\t\t= &buffer_pipe_buf_ops,\n\t\t.spd_release\t= buffer_spd_release,\n\t};\n\tstruct buffer_ref *ref;\n\tint entries, i;\n\tssize_t ret = 0;\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -EBUSY;\n#endif\n\n\tif (*ppos & (PAGE_SIZE - 1))\n\t\treturn -EINVAL;\n\n\tif (len & (PAGE_SIZE - 1)) {\n\t\tif (len < PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tlen &= PAGE_MASK;\n\t}\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tentries = ring_buffer_entries_cpu(iter->trace_buffer->buffer, iter->cpu_file);\n\n\tfor (i = 0; i < spd.nr_pages_max && len && entries; i++, len -= PAGE_SIZE) {\n\t\tstruct page *page;\n\t\tint r;\n\n\t\tref = kzalloc(sizeof(*ref), GFP_KERNEL);\n\t\tif (!ref) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tref->ref = 1;\n\t\tref->buffer = iter->trace_buffer->buffer;\n\t\tref->page = ring_buffer_alloc_read_page(ref->buffer, iter->cpu_file);\n\t\tif (IS_ERR(ref->page)) {\n\t\t\tret = PTR_ERR(ref->page);\n\t\t\tref->page = NULL;\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\t\tref->cpu = iter->cpu_file;\n\n\t\tr = ring_buffer_read_page(ref->buffer, &ref->page,\n\t\t\t\t\t  len, iter->cpu_file, 1);\n\t\tif (r < 0) {\n\t\t\tring_buffer_free_read_page(ref->buffer, ref->cpu,\n\t\t\t\t\t\t   ref->page);\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\n\t\tpage = virt_to_page(ref->page);\n\n\t\tspd.pages[i] = page;\n\t\tspd.partial[i].len = PAGE_SIZE;\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].private = (unsigned long)ref;\n\t\tspd.nr_pages++;\n\t\t*ppos += PAGE_SIZE;\n\n\t\tentries = ring_buffer_entries_cpu(iter->trace_buffer->buffer, iter->cpu_file);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\tspd.nr_pages = i;\n\n\t/* did we read anything? */\n\tif (!spd.nr_pages) {\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = -EAGAIN;\n\t\tif ((file->f_flags & O_NONBLOCK) || (flags & SPLICE_F_NONBLOCK))\n\t\t\tgoto out;\n\n\t\tret = wait_on_pipe(iter, iter->tr->buffer_percent);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tgoto again;\n\t}\n\n\tret = splice_to_pipe(pipe, &spd);\nout:\n\tsplice_shrink_spd(&spd);\n\n\treturn ret;\n}\n",
        "output": "0",
        "index": 96914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "processXmlDecl(XML_Parser parser, int isGeneralTextEntity,\n               const char *s, const char *next)\n{\n  const char *encodingName = NULL;\n  const XML_Char *storedEncName = NULL;\n  const ENCODING *newEncoding = NULL;\n  const char *version = NULL;\n  const char *versionend;\n  const XML_Char *storedversion = NULL;\n  int standalone = -1;\n  if (!(parser->m_ns\n        ? XmlParseXmlDeclNS\n        : XmlParseXmlDecl)(isGeneralTextEntity,\n                           parser->m_encoding,\n                           s,\n                           next,\n                           &parser->m_eventPtr,\n                           &version,\n                           &versionend,\n                           &encodingName,\n                           &newEncoding,\n                           &standalone)) {\n    if (isGeneralTextEntity)\n      return XML_ERROR_TEXT_DECL;\n    else\n      return XML_ERROR_XML_DECL;\n  }\n  if (!isGeneralTextEntity && standalone == 1) {\n    parser->m_dtd->standalone = XML_TRUE;\n#ifdef XML_DTD\n    if (parser->m_paramEntityParsing == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)\n      parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif /* XML_DTD */\n  }\n  if (parser->m_xmlDeclHandler) {\n    if (encodingName != NULL) {\n      storedEncName = poolStoreString(&parser->m_temp2Pool,\n                                      parser->m_encoding,\n                                      encodingName,\n                                      encodingName\n                                      + XmlNameLength(parser->m_encoding, encodingName));\n      if (!storedEncName)\n              return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_temp2Pool);\n    }\n    if (version) {\n      storedversion = poolStoreString(&parser->m_temp2Pool,\n                                      parser->m_encoding,\n                                      version,\n                                      versionend - parser->m_encoding->minBytesPerChar);\n      if (!storedversion)\n        return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_xmlDeclHandler(parser->m_handlerArg, storedversion, storedEncName, standalone);\n  }\n  else if (parser->m_defaultHandler)\n    reportDefault(parser, parser->m_encoding, s, next);\n  if (parser->m_protocolEncodingName == NULL) {\n    if (newEncoding) {\n      /* Check that the specified encoding does not conflict with what\n       * the parser has already deduced.  Do we have the same number\n       * of bytes in the smallest representation of a character?  If\n       * this is UTF-16, is it the same endianness?\n       */\n      if (newEncoding->minBytesPerChar != parser->m_encoding->minBytesPerChar\n          || (newEncoding->minBytesPerChar == 2 &&\n              newEncoding != parser->m_encoding)) {\n        parser->m_eventPtr = encodingName;\n        return XML_ERROR_INCORRECT_ENCODING;\n      }\n      parser->m_encoding = newEncoding;\n    }\n    else if (encodingName) {\n      enum XML_Error result;\n      if (!storedEncName) {\n        storedEncName = poolStoreString(\n          &parser->m_temp2Pool, parser->m_encoding, encodingName,\n          encodingName + XmlNameLength(parser->m_encoding, encodingName));\n        if (!storedEncName)\n          return XML_ERROR_NO_MEMORY;\n      }\n      result = handleUnknownEncoding(parser, storedEncName);\n      poolClear(&parser->m_temp2Pool);\n      if (result == XML_ERROR_UNKNOWN_ENCODING)\n        parser->m_eventPtr = encodingName;\n      return result;\n    }\n  }\n\n  if (storedEncName || storedversion)\n    poolClear(&parser->m_temp2Pool);\n\n  return XML_ERROR_NONE;\n}\n",
        "output": "0",
        "index": 92363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t\t\t     sizeof(sctp_initack_chunk_t)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n",
        "output": "0",
        "index": 31562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltReverseCompMatch(xsltParserContextPtr ctxt, xsltCompMatchPtr comp) {\n    int i = 0;\n    int j = comp->nbStep - 1;\n\n    while (j > i) {\n\tregister xmlChar *tmp;\n\tregister xsltOp op;\n\tregister xmlXPathCompExprPtr expr;\n\tregister int t;\n\n\ttmp = comp->steps[i].value;\n\tcomp->steps[i].value = comp->steps[j].value;\n\tcomp->steps[j].value = tmp;\n\ttmp = comp->steps[i].value2;\n\tcomp->steps[i].value2 = comp->steps[j].value2;\n\tcomp->steps[j].value2 = tmp;\n\ttmp = comp->steps[i].value3;\n\tcomp->steps[i].value3 = comp->steps[j].value3;\n\tcomp->steps[j].value3 = tmp;\n\top = comp->steps[i].op;\n\tcomp->steps[i].op = comp->steps[j].op;\n\tcomp->steps[j].op = op;\n\texpr = comp->steps[i].comp;\n\tcomp->steps[i].comp = comp->steps[j].comp;\n\tcomp->steps[j].comp = expr;\n\tt = comp->steps[i].previousExtra;\n\tcomp->steps[i].previousExtra = comp->steps[j].previousExtra;\n\tcomp->steps[j].previousExtra = t;\n\tt = comp->steps[i].indexExtra;\n\tcomp->steps[i].indexExtra = comp->steps[j].indexExtra;\n\tcomp->steps[j].indexExtra = t;\n\tt = comp->steps[i].lenExtra;\n\tcomp->steps[i].lenExtra = comp->steps[j].lenExtra;\n\tcomp->steps[j].lenExtra = t;\n\tj--;\n\ti++;\n    }\n     xsltCompMatchAdd(ctxt, comp, XSLT_OP_END, NULL, NULL, 0);\n \n     /*\n     * detect consecutive XSLT_OP_PREDICATE indicating a direct\n     * matching should be done.\n      */\n     for (i = 0;i < comp->nbStep - 1;i++) {\n        if ((comp->steps[i].op == XSLT_OP_PREDICATE) &&\n \t    (comp->steps[i + 1].op == XSLT_OP_PREDICATE)) {\n \n \t    comp->direct = 1;\n\t    if (comp->pattern[0] != '/') {\n\t\txmlChar *query;\n\n\t\tquery = xmlStrdup((const xmlChar *)\"//\");\n\t\tquery = xmlStrcat(query, comp->pattern);\n\n\t\txmlFree((xmlChar *) comp->pattern);\n\t\tcomp->pattern = query;\n\t    }\n\t    break;\n\t}\n    }\n}\n",
        "output": "1",
        "index": 187335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void btif_hl_close_socket( fd_set *p_org_set){\n    BTIF_TRACE_DEBUG(\"entering %s\",__FUNCTION__);\n for (const list_node_t *node = list_begin(soc_queue);\n            node != list_end(soc_queue); node = list_next(node)) {\n btif_hl_soc_cb_t *p_scb = list_node(node);\n if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_REL) {\n            BTIF_TRACE_DEBUG(\"app_idx=%d mcl_id=%d, mdl_idx=%d\",\n                    p_scb->app_idx, p_scb->mcl_idx, p_scb->mdl_idx);\n            btif_hl_set_socket_state(p_scb, BTIF_HL_SOC_STATE_IDLE);\n if (p_scb->socket_id[1] != -1) {\n                FD_CLR(p_scb->socket_id[1] , p_org_set);\n                shutdown(p_scb->socket_id[1], SHUT_RDWR);\n                close(p_scb->socket_id[1]);\n\n btif_hl_evt_cb_t evt_param;\n                evt_param.chan_cb.app_id = (int) btif_hl_get_app_id(p_scb->channel_id);\n                memcpy(evt_param.chan_cb.bd_addr, p_scb->bd_addr, sizeof(BD_ADDR));\n                evt_param.chan_cb.channel_id = p_scb->channel_id;\n                evt_param.chan_cb.fd = p_scb->socket_id[0];\n                evt_param.chan_cb.mdep_cfg_index = (int ) p_scb->mdep_cfg_idx;\n                evt_param.chan_cb.cb_state = BTIF_HL_CHAN_CB_STATE_DISCONNECTED_PENDING;\n int len = sizeof(btif_hl_send_chan_state_cb_t);\n bt_status_t status = btif_transfer_context (btif_hl_proc_cb_evt,\n                        BTIF_HL_SEND_DISCONNECTED_CB,\n (char*) &evt_param, len, NULL);\n                ASSERTC(status == BT_STATUS_SUCCESS, \"context transfer failed\", status);\n }\n }\n }\n\n for (const list_node_t *node = list_begin(soc_queue);\n        node != list_end(soc_queue); ) {\n btif_hl_soc_cb_t *p_scb = list_node(node);\n        node = list_next(node);\n if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_IDLE) {\n btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx,\n                    p_scb->mcl_idx, p_scb->mdl_idx);\n            BTIF_TRACE_DEBUG(\"idle socket app_idx=%d mcl_id=%d, mdl_idx=%d p_dcb->in_use=%d\",\n                    p_scb->app_idx, p_scb->mcl_idx, p_scb->mdl_idx, p_dcb->in_use);\n            list_remove(soc_queue, p_scb);\n            btif_hl_free_buf((void **)&p_scb);\n            p_dcb->p_scb = NULL;\n }\n        BTIF_TRACE_DEBUG(\"p_scb=0x%x\", p_scb);\n }\n    BTIF_TRACE_DEBUG(\"leaving %s\",__FUNCTION__);\n}\n",
        "output": "0",
        "index": 171840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_rsc_op(xmlNode * rsc_op)\n{\n    int rc = -1;\n    int status = -1;\n    int action = -1;\n    int interval = 0;\n    int target_rc = -1;\n    int transition_num = -1;\n    gboolean notify = TRUE;\n\n    char *rsc = NULL;\n    char *task = NULL;\n    const char *desc = NULL;\n    const char *node = NULL;\n    const char *magic = NULL;\n    const char *id = crm_element_value(rsc_op, XML_LRM_ATTR_TASK_KEY);\n    char *update_te_uuid = NULL;\n\n    xmlNode *n = rsc_op;\n\n    if (id == NULL) {\n        /* Compatability with <= 1.1.5 */\n        id = ID(rsc_op);\n    }\n\n    magic = crm_element_value(rsc_op, XML_ATTR_TRANSITION_MAGIC);\n    if (magic == NULL) {\n        /* non-change */\n        return;\n    }\n\n    if (FALSE == decode_transition_magic(magic, &update_te_uuid, &transition_num, &action,\n                                         &status, &rc, &target_rc)) {\n        crm_err(\"Invalid event %s detected for %s\", magic, id);\n        return;\n    }\n\n    if (parse_op_key(id, &rsc, &task, &interval) == FALSE) {\n        crm_err(\"Invalid event detected for %s\", id);\n        goto bail;\n    }\n\n    while (n != NULL && safe_str_neq(XML_CIB_TAG_STATE, TYPE(n))) {\n        n = n->parent;\n    }\n\n    node = crm_element_value(n, XML_ATTR_UNAME);\n    if (node == NULL) {\n        node = ID(n);\n    }\n    if (node == NULL) {\n        crm_err(\"No node detected for event %s (%s)\", magic, id);\n        goto bail;\n    }\n\n    /* look up where we expected it to be? */\n    desc = pcmk_strerror(pcmk_ok);\n    if (status == PCMK_LRM_OP_DONE && target_rc == rc) {\n        crm_notice(\"%s of %s on %s completed: %s\", task, rsc, node, desc);\n        if (rc == PCMK_EXECRA_NOT_RUNNING) {\n            notify = FALSE;\n        }\n\n    } else if (status == PCMK_LRM_OP_DONE) {\n        desc = lrmd_event_rc2str(rc);\n        crm_warn(\"%s of %s on %s failed: %s\", task, rsc, node, desc);\n\n    } else {\n        desc = services_lrm_status_str(status);\n        crm_warn(\"%s of %s on %s failed: %s\", task, rsc, node, desc);\n    }\n\n    if (notify && snmp_target) {\n        send_snmp_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n    if (notify && crm_mail_to) {\n        send_smtp_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n    if (notify && external_agent) {\n        send_custom_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n  bail:\n    free(update_te_uuid);\n    free(rsc);\n    free(task);\n}\n",
        "output": "0",
        "index": 33938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don't know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\"sg_build_indirect: buff_size=%d, blk_size=%d\\n\",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n \t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n \t\t\tscatter_elem_sz_prev : rem_sz;\n \n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n \t\tif (!schp->pages[k])\n \t\t\tgoto out;\n \n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t \"sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n\",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t \"sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n\",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}\n",
        "output": "1",
        "index": 182114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParseStartTag(xmlParserCtxtPtr ctxt) {\n    const xmlChar *name;\n    const xmlChar *attname;\n    xmlChar *attvalue;\n    const xmlChar **atts = ctxt->atts;\n    int nbatts = 0;\n    int maxatts = ctxt->maxatts;\n    int i;\n\n    if (RAW != '<') return(NULL);\n    NEXT1;\n\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n\t     \"xmlParseStartTag: invalid element name\\n\");\n        return(NULL);\n    }\n\n    /*\n     * Now parse the attributes, it ends up with the ending\n     *\n     * (S Attribute)* S?\n     */\n    SKIP_BLANKS;\n    GROW;\n\n    while ((RAW != '>') && \n\t   ((RAW != '/') || (NXT(1) != '>')) &&\n\t   (IS_BYTE_CHAR(RAW))) {\n\tconst xmlChar *q = CUR_PTR;\n\tunsigned int cons = ctxt->input->consumed;\n\n\tattname = xmlParseAttribute(ctxt, &attvalue);\n        if ((attname != NULL) && (attvalue != NULL)) {\n\t    /*\n\t     * [ WFC: Unique Att Spec ]\n\t     * No attribute name may appear more than once in the same\n\t     * start-tag or empty-element tag. \n\t     */\n\t    for (i = 0; i < nbatts;i += 2) {\n\t        if (xmlStrEqual(atts[i], attname)) {\n\t\t    xmlErrAttributeDup(ctxt, NULL, attname);\n\t\t    xmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t    }\n\t    /*\n\t     * Add the pair to atts\n\t     */\n\t    if (atts == NULL) {\n\t        maxatts = 22; /* allow for 10 attrs by default */\n\t        atts = (const xmlChar **)\n\t\t       xmlMalloc(maxatts * sizeof(xmlChar *));\n\t\tif (atts == NULL) {\n\t\t    xmlErrMemory(ctxt, NULL);\n\t\t    if (attvalue != NULL)\n\t\t\txmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t\tctxt->atts = atts;\n\t\tctxt->maxatts = maxatts;\n\t    } else if (nbatts + 4 > maxatts) {\n\t        const xmlChar **n;\n\n\t        maxatts *= 2;\n\t        n = (const xmlChar **) xmlRealloc((void *) atts,\n\t\t\t\t\t     maxatts * sizeof(const xmlChar *));\n\t\tif (n == NULL) {\n\t\t    xmlErrMemory(ctxt, NULL);\n\t\t    if (attvalue != NULL)\n\t\t\txmlFree(attvalue);\n\t\t    goto failed;\n\t\t}\n\t\tatts = n;\n\t\tctxt->atts = atts;\n\t\tctxt->maxatts = maxatts;\n\t    }\n\t    atts[nbatts++] = attname;\n\t    atts[nbatts++] = attvalue;\n\t    atts[nbatts] = NULL;\n\t    atts[nbatts + 1] = NULL;\n\t} else {\n\t    if (attvalue != NULL)\n\t\txmlFree(attvalue);\n\t}\n\nfailed:     \n\n\tGROW\n\tif ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))\n\t    break;\n\tif (!IS_BLANK_CH(RAW)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n\t\t\t   \"attributes construct error\\n\");\n\t}\n\tSKIP_BLANKS;\n        if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&\n            (attname == NULL) && (attvalue == NULL)) {\n\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t   \"xmlParseStartTag: problem parsing attributes\\n\");\n\t    break;\n\t}\n\tSHRINK;\n        GROW;\n    }\n\n    /*\n     * SAX: Start of Element !\n     */\n    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&\n\t(!ctxt->disableSAX)) {\n\tif (nbatts > 0)\n\t    ctxt->sax->startElement(ctxt->userData, name, atts);\n\telse\n\t    ctxt->sax->startElement(ctxt->userData, name, NULL);\n    }\n\n    if (atts != NULL) {\n        /* Free only the content strings */\n        for (i = 1;i < nbatts;i+=2)\n\t    if (atts[i] != NULL)\n\t       xmlFree((xmlChar *) atts[i]);\n    }\n    return(name);\n}\n",
        "output": "0",
        "index": 100750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n #ifdef CONFIG_TCP_MD5SIG\n \tstruct tcp_md5sig_key *key;\n #endif\n \n \tif (sk_acceptq_is_full(sk))\n \t\tgoto exit_overflow;\n\n\tif (!dst && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto exit_nonewsk;\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV4;\n\tsk_setup_caps(newsk, dst);\n\n\tnewtp\t\t      = tcp_sk(newsk);\n\tnewinet\t\t      = inet_sk(newsk);\n\tireq\t\t      = inet_rsk(req);\n \tnewinet->inet_daddr   = ireq->rmt_addr;\n \tnewinet->inet_rcv_saddr = ireq->loc_addr;\n \tnewinet->inet_saddr\t      = ireq->loc_addr;\n\tnewinet->opt\t      = ireq->opt;\n \tireq->opt\t      = NULL;\n \tnewinet->mc_index     = inet_iif(skb);\n \tnewinet->mc_ttl\t      = ip_hdr(skb)->ttl;\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (newinet->opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;\n \tnewinet->inet_id = newtp->write_seq ^ jiffies;\n \n \ttcp_mtup_init(newsk);\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = dst_metric_advmss(dst);\n\tif (tcp_sk(sk)->rx_opt.user_mss &&\n\t    tcp_sk(sk)->rx_opt.user_mss < newtp->advmss)\n\t\tnewtp->advmss = tcp_sk(sk)->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(newsk);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v4_md5_do_lookup(sk, newinet->inet_daddr);\n\tif (key != NULL) {\n\t\t/*\n\t\t * We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\tchar *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC);\n\t\tif (newkey != NULL)\n\t\t\ttcp_v4_md5_do_add(newsk, newinet->inet_daddr,\n\t\t\t\t\t  newkey, key->keylen);\n\t\tsk_nocaps_add(newsk, NETIF_F_GSO_MASK);\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\n\treturn newsk;\n\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n",
        "output": "1",
        "index": 178744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FoFiType1C::readPrivateDict(int offset, int length,\n\t\t\t\t Type1CPrivateDict *pDict) {\n  int pos;\n\n  pDict->hasFontMatrix = gFalse;\n  pDict->nBlueValues = 0;\n  pDict->nOtherBlues = 0;\n  pDict->nFamilyBlues = 0;\n  pDict->nFamilyOtherBlues = 0;\n  pDict->blueScale = 0.039625;\n  pDict->blueShift = 7;\n  pDict->blueFuzz = 1;\n  pDict->hasStdHW = gFalse;\n  pDict->hasStdVW = gFalse;\n  pDict->nStemSnapH = 0;\n  pDict->nStemSnapV = 0;\n  pDict->hasForceBold = gFalse;\n  pDict->forceBoldThreshold = 0;\n  pDict->languageGroup = 0;\n  pDict->expansionFactor = 0.06;\n  pDict->initialRandomSeed = 0;\n  pDict->subrsOffset = 0;\n  pDict->defaultWidthX = 0;\n  pDict->defaultWidthXFP = gFalse;\n  pDict->nominalWidthX = 0;\n  pDict->nominalWidthXFP = gFalse;\n\n  if (offset == 0 || length == 0) {\n    return;\n  }\n\n  pos = offset;\n  nOps = 0;\n  while (pos < offset + length) {\n    pos = getOp(pos, gFalse, &parsedOk);\n    if (!parsedOk) {\n      break;\n    }\n    if (!ops[nOps - 1].isNum) {\n      --nOps; // drop the operator\n      switch (ops[nOps].op) {\n      case 0x0006:\n\tpDict->nBlueValues = getDeltaIntArray(pDict->blueValues,\n\t\t\t\t\t      type1CMaxBlueValues);\n\tbreak;\n      case 0x0007:\n\tpDict->nOtherBlues = getDeltaIntArray(pDict->otherBlues,\n\t\t\t\t\t      type1CMaxOtherBlues);\n\tbreak;\n      case 0x0008:\n\tpDict->nFamilyBlues = getDeltaIntArray(pDict->familyBlues,\n\t\t\t\t\t       type1CMaxBlueValues);\n\tbreak;\n      case 0x0009:\n\tpDict->nFamilyOtherBlues = getDeltaIntArray(pDict->familyOtherBlues,\n\t\t\t\t\t\t    type1CMaxOtherBlues);\n\tbreak;\n      case 0x0c09:\n\tpDict->blueScale = ops[0].num;\n\tbreak;\n      case 0x0c0a:\n\tpDict->blueShift = (int)ops[0].num;\n\tbreak;\n      case 0x0c0b:\n\tpDict->blueFuzz = (int)ops[0].num;\n\tbreak;\n      case 0x000a:\n\tpDict->stdHW = ops[0].num;\n\tpDict->hasStdHW = gTrue;\n\tbreak;\n      case 0x000b:\n\tpDict->stdVW = ops[0].num;\n\tpDict->hasStdVW = gTrue;\n\tbreak;\n      case 0x0c0c:\n\tpDict->nStemSnapH = getDeltaFPArray(pDict->stemSnapH,\n\t\t\t\t\t    type1CMaxStemSnap);\n\tbreak;\n      case 0x0c0d:\n\tpDict->nStemSnapV = getDeltaFPArray(pDict->stemSnapV,\n\t\t\t\t\t    type1CMaxStemSnap);\n\tbreak;\n      case 0x0c0e:\n\tpDict->forceBold = ops[0].num != 0;\n\tpDict->hasForceBold = gTrue;\n\tbreak;\n      case 0x0c0f:\n\tpDict->forceBoldThreshold = ops[0].num;\n\tbreak;\n      case 0x0c11:\n\tpDict->languageGroup = (int)ops[0].num;\n\tbreak;\n      case 0x0c12:\n\tpDict->expansionFactor = ops[0].num;\n\tbreak;\n      case 0x0c13:\n\tpDict->initialRandomSeed = (int)ops[0].num;\n\tbreak;\n      case 0x0013:\n\tpDict->subrsOffset = offset + (int)ops[0].num;\n\tbreak;\n      case 0x0014:\n\tpDict->defaultWidthX = ops[0].num;\n\tpDict->defaultWidthXFP = ops[0].isFP;\n\tbreak;\n      case 0x0015:\n\tpDict->nominalWidthX = ops[0].num;\n\tpDict->nominalWidthXFP = ops[0].isFP;\n\tbreak;\n      }\n      nOps = 0;\n    }\n  }\n}\n",
        "output": "0",
        "index": 2227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,\n\tunsigned char *ToLinear8)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n    register unsigned char  t0, t1, t2, t3;\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    op[0] = 0;\n\t    t1 = ToLinear8[cb = (wp[2] & mask)];\n\t    t2 = ToLinear8[cg = (wp[1] & mask)];\n\t    t3 = ToLinear8[cr = (wp[0] & mask)];\n\t    op[1] = t1;\n\t    op[2] = t2;\n\t    op[3] = t3;\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\top += 4;\n\t\top[0] = 0;\n\t\tt1 = ToLinear8[(cb += wp[2]) & mask];\n\t\tt2 = ToLinear8[(cg += wp[1]) & mask];\n\t\tt3 = ToLinear8[(cr += wp[0]) & mask];\n\t\top[1] = t1;\n\t\top[2] = t2;\n\t\top[3] = t3;\n\t    }\n\t} else if (stride == 4) {\n\t    t0 = ToLinear8[ca = (wp[3] & mask)];\n\t    t1 = ToLinear8[cb = (wp[2] & mask)];\n\t    t2 = ToLinear8[cg = (wp[1] & mask)];\n\t    t3 = ToLinear8[cr = (wp[0] & mask)];\n\t    op[0] = t0;\n\t    op[1] = t1;\n\t    op[2] = t2;\n\t    op[3] = t3;\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\top += 4;\n\t\tt0 = ToLinear8[(ca += wp[3]) & mask];\n\t\tt1 = ToLinear8[(cb += wp[2]) & mask];\n\t\tt2 = ToLinear8[(cg += wp[1]) & mask];\n\t\tt3 = ToLinear8[(cr += wp[0]) & mask];\n\t\top[0] = t0;\n\t\top[1] = t1;\n\t\top[2] = t2;\n\t\top[3] = t3;\n\t    }\n\t} else {\n\t    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}\n",
        "output": "0",
        "index": 48317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebMediaPlayerImpl::DoLoad(LoadType load_type,\n                                const blink::WebURL& url,\n                                CORSMode cors_mode) {\n  TRACE_EVENT1(\"media\", \"WebMediaPlayerImpl::DoLoad\", \"id\", media_log_->id());\n  DVLOG(1) << __func__;\n  DCHECK(main_task_runner_->BelongsToCurrentThread());\n\n  GURL gurl(url);\n  ReportMetrics(load_type, gurl, frame_->GetSecurityOrigin(), media_log_.get());\n\n  if (load_type == kLoadTypeURL) {\n    if (preload_ == MultibufferDataSource::METADATA) {\n      UMA_HISTOGRAM_BOOLEAN(\"Media.SRC.PreloadMetaDataHasPoster\", has_poster_);\n    } else if (preload_ == MultibufferDataSource::AUTO) {\n      UMA_HISTOGRAM_BOOLEAN(\"Media.SRC.PreloadAutoHasPoster\", has_poster_);\n    }\n  }\n\n  static base::debug::CrashKeyString* subresource_url =\n      base::debug::AllocateCrashKeyString(\"subresource_url\",\n                                          base::debug::CrashKeySize::Size256);\n  base::debug::SetCrashKeyString(subresource_url, gurl.spec());\n\n  loaded_url_ = gurl;\n\n  load_type_ = load_type;\n\n  SetNetworkState(WebMediaPlayer::kNetworkStateLoading);\n  SetReadyState(WebMediaPlayer::kReadyStateHaveNothing);\n  media_log_->AddEvent(media_log_->CreateLoadEvent(url.GetString().Utf8()));\n  load_start_time_ = base::TimeTicks::Now();\n\n  media_metrics_provider_->Initialize(load_type == kLoadTypeMediaSource,\n                                      frame_ == frame_->Top(),\n                                      frame_->Top()->GetSecurityOrigin());\n\n  if (load_type == kLoadTypeMediaSource) {\n    StartPipeline();\n  } else {\n    data_source_.reset(new MultibufferDataSource(\n        main_task_runner_,\n        url_index_->GetByUrl(url, static_cast<UrlData::CORSMode>(cors_mode)),\n        media_log_.get(), &buffered_data_source_host_,\n        base::Bind(&WebMediaPlayerImpl::NotifyDownloading, AsWeakPtr())));\n    data_source_->SetPreload(preload_);\n    data_source_->SetIsClientAudioElement(client_->IsAudioElement());\n    data_source_->Initialize(\n        base::Bind(&WebMediaPlayerImpl::DataSourceInitialized, AsWeakPtr()));\n  }\n\n#if defined(OS_ANDROID)  // WMPI_CAST\n  cast_impl_.Initialize(url, frame_, delegate_id_);\n#endif\n}\n",
        "output": "0",
        "index": 167516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uiserver_encrypt (void *engine, gpgme_key_t recp[], gpgme_encrypt_flags_t flags,\n\t\t  gpgme_data_t plain, gpgme_data_t ciph, int use_armor)\n{\n  engine_uiserver_t uiserver = engine;\n  gpgme_error_t err;\n  const char *protocol;\n  char *cmd;\n\n  if (!uiserver)\n    return gpg_error (GPG_ERR_INV_VALUE);\n  if (uiserver->protocol == GPGME_PROTOCOL_DEFAULT)\n    protocol = \"\";\n  else if (uiserver->protocol == GPGME_PROTOCOL_OpenPGP)\n    protocol = \" --protocol=OpenPGP\";\n  else if (uiserver->protocol == GPGME_PROTOCOL_CMS)\n    protocol = \" --protocol=CMS\";\n  else\n    return gpgme_error (GPG_ERR_UNSUPPORTED_PROTOCOL);\n\n  if (flags & GPGME_ENCRYPT_PREPARE)\n    {\n      if (!recp || plain || ciph)\n\treturn gpg_error (GPG_ERR_INV_VALUE);\n\n      if (asprintf (&cmd, \"PREP_ENCRYPT%s%s\", protocol,\n\t\t    (flags & GPGME_ENCRYPT_EXPECT_SIGN)\n\t\t    ? \" --expect-sign\" : \"\") < 0)\n\treturn gpg_error_from_syserror ();\n    }\n  else\n    {\n      if (!plain || !ciph)\n\treturn gpg_error (GPG_ERR_INV_VALUE);\n\n      if (asprintf (&cmd, \"ENCRYPT%s\", protocol) < 0)\n\treturn gpg_error_from_syserror ();\n    }\n\n  if (plain)\n    {\n      uiserver->input_cb.data = plain;\n      err = uiserver_set_fd (uiserver, INPUT_FD,\n\t\t\t     map_data_enc (uiserver->input_cb.data));\n      if (err)\n\t{\n\t  free (cmd);\n\t  return err;\n\t}\n    }\n\n  if (ciph)\n    {\n      uiserver->output_cb.data = ciph;\n      err = uiserver_set_fd (uiserver, OUTPUT_FD, use_armor ? \"--armor\"\n\t\t\t     : map_data_enc (uiserver->output_cb.data));\n      if (err)\n\t{\n\t  free (cmd);\n\t  return err;\n\t}\n    }\n\n  uiserver->inline_data = NULL;\n\n  if (recp)\n    {\n      err = set_recipients (uiserver, recp);\n      if (err)\n\t{\n\t  free (cmd);\n\t  return err;\n\t}\n    }\n\n  err = start (uiserver, cmd);\n  free (cmd);\n  return err;\n}\n",
        "output": "0",
        "index": 12300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qcow2_write_compressed(BlockDriverState *bs, int64_t sector_num,\n                                  const uint8_t *buf, int nb_sectors)\n{\n    BDRVQcowState *s = bs->opaque;\n    z_stream strm;\n    int ret, out_len;\n    uint8_t *out_buf;\n    uint64_t cluster_offset;\n\n    if (nb_sectors == 0) {\n        /* align end of file to a sector boundary to ease reading with\n           sector based I/Os */\n        cluster_offset = bdrv_getlength(bs->file);\n        cluster_offset = (cluster_offset + 511) & ~511;\n        bdrv_truncate(bs->file, cluster_offset);\n        return 0;\n    }\n\n    if (nb_sectors != s->cluster_sectors) {\n        ret = -EINVAL;\n\n        /* Zero-pad last write if image size is not cluster aligned */\n        if (sector_num + nb_sectors == bs->total_sectors &&\n            nb_sectors < s->cluster_sectors) {\n            uint8_t *pad_buf = qemu_blockalign(bs, s->cluster_size);\n            memset(pad_buf, 0, s->cluster_size);\n            memcpy(pad_buf, buf, nb_sectors * BDRV_SECTOR_SIZE);\n            ret = qcow2_write_compressed(bs, sector_num,\n                                         pad_buf, s->cluster_sectors);\n            qemu_vfree(pad_buf);\n        }\n        return ret;\n    }\n\n    out_buf = g_malloc(s->cluster_size + (s->cluster_size / 1000) + 128);\n\n    /* best compression, small window, no zlib header */\n    memset(&strm, 0, sizeof(strm));\n    ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                       Z_DEFLATED, -12,\n                       9, Z_DEFAULT_STRATEGY);\n    if (ret != 0) {\n        ret = -EINVAL;\n        goto fail;\n    }\n\n    strm.avail_in = s->cluster_size;\n    strm.next_in = (uint8_t *)buf;\n    strm.avail_out = s->cluster_size;\n    strm.next_out = out_buf;\n\n    ret = deflate(&strm, Z_FINISH);\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n        deflateEnd(&strm);\n        ret = -EINVAL;\n        goto fail;\n    }\n    out_len = strm.next_out - out_buf;\n\n    deflateEnd(&strm);\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n        /* could not compress: write normal cluster */\n        ret = bdrv_write(bs, sector_num, buf, s->cluster_sectors);\n        if (ret < 0) {\n            goto fail;\n        }\n    } else {\n        cluster_offset = qcow2_alloc_compressed_cluster_offset(bs,\n            sector_num << 9, out_len);\n        if (!cluster_offset) {\n            ret = -EIO;\n            goto fail;\n        }\n        cluster_offset &= s->cluster_offset_mask;\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n        if (ret < 0) {\n            goto fail;\n        }\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n        ret = bdrv_pwrite(bs->file, cluster_offset, out_buf, out_len);\n        if (ret < 0) {\n            goto fail;\n        }\n    }\n\n    ret = 0;\nfail:\n    g_free(out_buf);\n    return ret;\n}\n",
        "output": "0",
        "index": 16831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void onMessages(const std::list<omx_message> &messages) {\n if (messages.empty()) {\n return;\n }\n\n        sp<AMessage> notify = mNotify->dup();\n bool first = true;\n        sp<MessageList> msgList = new MessageList();\n for (std::list<omx_message>::const_iterator it = messages.cbegin();\n              it != messages.cend(); ++it) {\n const omx_message &omx_msg = *it;\n if (first) {\n                notify->setInt32(\"node\", omx_msg.node);\n                first = false;\n }\n\n            sp<AMessage> msg = new AMessage;\n            msg->setInt32(\"type\", omx_msg.type);\n switch (omx_msg.type) {\n case omx_message::EVENT:\n {\n                    msg->setInt32(\"event\", omx_msg.u.event_data.event);\n                    msg->setInt32(\"data1\", omx_msg.u.event_data.data1);\n                    msg->setInt32(\"data2\", omx_msg.u.event_data.data2);\n break;\n }\n\n case omx_message::EMPTY_BUFFER_DONE:\n {\n                    msg->setInt32(\"buffer\", omx_msg.u.buffer_data.buffer);\n                    msg->setInt32(\"fence_fd\", omx_msg.fenceFd);\n break;\n }\n\n case omx_message::FILL_BUFFER_DONE:\n {\n                    msg->setInt32(\n \"buffer\", omx_msg.u.extended_buffer_data.buffer);\n                    msg->setInt32(\n \"range_offset\",\n                            omx_msg.u.extended_buffer_data.range_offset);\n                    msg->setInt32(\n \"range_length\",\n                            omx_msg.u.extended_buffer_data.range_length);\n                    msg->setInt32(\n \"flags\",\n                            omx_msg.u.extended_buffer_data.flags);\n                    msg->setInt64(\n \"timestamp\",\n                            omx_msg.u.extended_buffer_data.timestamp);\n                    msg->setInt32(\n \"fence_fd\", omx_msg.fenceFd);\n break;\n }\n\n case omx_message::FRAME_RENDERED:\n {\n                    msg->setInt64(\n \"media_time_us\", omx_msg.u.render_data.timestamp);\n                    msg->setInt64(\n \"system_nano\", omx_msg.u.render_data.nanoTime);\n break;\n }\n\n default:\n                    ALOGE(\"Unrecognized message type: %d\", omx_msg.type);\n break;\n }\n            msgList->getList().push_back(msg);\n }\n        notify->setObject(\"messages\", msgList);\n        notify->post();\n }\n",
        "output": "0",
        "index": 177266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_image_t *ras_decode(jas_stream_t *in, char *optstr)\n{\n\tras_hdr_t hdr;\n\tras_cmap_t cmap;\n\tjas_image_t *image;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tint clrspc;\n\tint numcmpts;\n\tint i;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring RAS decoder options\\n\");\n\t}\n\n\t/* Read the header. */\n\tif (ras_gethdr(in, &hdr)) {\n\t\treturn 0;\n\t}\n\n\t/* Does the header information look reasonably sane? */\n\tif (hdr.magic != RAS_MAGIC || hdr.width <= 0 || hdr.height <= 0 ||\n\t  hdr.depth <= 0 || hdr.depth > 32) {\n\t\treturn 0;\n\t}\n\n\t/* In the case of the old format, do not rely on the length field\n\tbeing properly specified.  Calculate the quantity from scratch. */\n\tif (hdr.type == RAS_TYPE_OLD) {\n\t\thdr.length = RAS_ROWSIZE(&hdr) * hdr.height;\n\t}\n\n\t/* Calculate some quantities needed for creation of the image\n\tobject. */\n\tif (RAS_ISRGB(&hdr)) {\n\t\tclrspc = JAS_CLRSPC_SRGB;\n\t\tnumcmpts = 3;\n\t} else {\n\t\tclrspc = JAS_CLRSPC_SGRAY;\n\t\tnumcmpts = 1;\n\t}\n\tfor (i = 0, cmptparm = cmptparms; i < numcmpts; ++i, ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->hstep = 1;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = hdr.width;\n\t\tcmptparm->height = hdr.height;\n\t\tcmptparm->prec = RAS_ISRGB(&hdr) ? 8 : hdr.depth;\n\t\tcmptparm->sgnd = false;\n\t}\n\t/* Create the image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms, JAS_CLRSPC_UNKNOWN))) {\n\t\treturn 0;\n\t}\n\n\t/* Read the color map (if there is one). */\n\tif (ras_getcmap(in, &hdr, &cmap)) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\t/* Read the pixel data. */\n\tif (ras_getdata(in, &hdr, &cmap, image)) {\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tjas_image_setclrspc(image, clrspc);\n\tif (clrspc == JAS_CLRSPC_SRGB) {\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\treturn image;\n}\n",
        "output": "0",
        "index": 73012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ReadOnlyOriginView(const base::string16& page_title,\n                     const GURL& origin,\n                     gfx::ImageSkia icon_image_skia,\n                     SkColor background_color,\n                     views::ButtonListener* site_settings_listener) {\n    std::unique_ptr<views::View> title_origin_container =\n        std::make_unique<views::View>();\n    SkColor foreground = color_utils::GetColorWithMaxContrast(background_color);\n    views::GridLayout* title_origin_layout =\n        title_origin_container->SetLayoutManager(\n            std::make_unique<views::GridLayout>(title_origin_container.get()));\n\n    views::ColumnSet* columns = title_origin_layout->AddColumnSet(0);\n    columns->AddColumn(views::GridLayout::LEADING, views::GridLayout::FILL, 1.0,\n                       views::GridLayout::USE_PREF, 0, 0);\n\n    bool title_is_valid = !page_title.empty();\n    if (title_is_valid) {\n      title_origin_layout->StartRow(views::GridLayout::kFixedSize, 0);\n      std::unique_ptr<views::Label> title_label =\n          std::make_unique<views::Label>(page_title,\n                                         views::style::CONTEXT_DIALOG_TITLE);\n      title_label->set_id(static_cast<int>(DialogViewID::SHEET_TITLE));\n      title_label->SetFocusBehavior(\n          views::View::FocusBehavior::ACCESSIBLE_ONLY);\n      title_label->SetAutoColorReadabilityEnabled(false);\n      title_label->SetEnabledColor(foreground);\n      title_origin_layout->AddView(title_label.release());\n    }\n\n    title_origin_layout->StartRow(views::GridLayout::kFixedSize, 0);\n    views::Label* origin_label =\n        new views::Label(base::UTF8ToUTF16(origin.host()));\n    origin_label->SetElideBehavior(gfx::ELIDE_HEAD);\n    if (!title_is_valid) {\n      origin_label->set_id(static_cast<int>(DialogViewID::SHEET_TITLE));\n\n      constexpr int kVerticalPadding = 10;\n      origin_label->SetBorder(\n          views::CreateEmptyBorder(kVerticalPadding, 0, kVerticalPadding, 0));\n    }\n    origin_label->SetAutoColorReadabilityEnabled(false);\n    origin_label->SetEnabledColor(foreground);\n\n    origin_label->SetBackgroundColor(background_color);\n    title_origin_layout->AddView(origin_label);\n\n    views::GridLayout* top_level_layout =\n        SetLayoutManager(std::make_unique<views::GridLayout>(this));\n    views::ColumnSet* top_level_columns = top_level_layout->AddColumnSet(0);\n    top_level_columns->AddColumn(views::GridLayout::LEADING,\n                                 views::GridLayout::CENTER, 1.0,\n                                 views::GridLayout::USE_PREF, 0, 0);\n    const bool has_icon = icon_image_skia.width() && icon_image_skia.height();\n    float adjusted_width = base::checked_cast<float>(icon_image_skia.width());\n    if (has_icon) {\n      adjusted_width =\n          adjusted_width *\n          IconSizeCalculator::kPaymentAppDeviceIndependentIdealIconHeight /\n          icon_image_skia.height();\n      top_level_columns->AddColumn(\n          views::GridLayout::LEADING, views::GridLayout::FILL,\n          views::GridLayout::kFixedSize, views::GridLayout::FIXED,\n          adjusted_width,\n          IconSizeCalculator::kPaymentAppDeviceIndependentIdealIconHeight);\n      top_level_columns->AddPaddingColumn(views::GridLayout::kFixedSize, 8);\n    }\n\n    top_level_layout->StartRow(views::GridLayout::kFixedSize, 0);\n    top_level_layout->AddView(title_origin_container.release());\n    if (has_icon) {\n      std::unique_ptr<views::ImageView> instrument_icon_view =\n          CreateInstrumentIconView(/*icon_id=*/0, icon_image_skia,\n                                   /*label=*/page_title);\n      instrument_icon_view->SetImageSize(gfx::Size(\n          adjusted_width,\n          IconSizeCalculator::kPaymentAppDeviceIndependentIdealIconHeight));\n      top_level_layout->AddView(instrument_icon_view.release());\n    }\n  }\n",
        "output": "0",
        "index": 163950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__init static int tracer_alloc_buffers(void)\n{\n\tint ring_buf_size;\n\tint ret = -ENOMEM;\n\n\t/*\n\t * Make sure we don't accidently add more trace options\n\t * than we have bits for.\n\t */\n\tBUILD_BUG_ON(TRACE_ITER_LAST_BIT > TRACE_FLAGS_MAX_SIZE);\n\n\tif (!alloc_cpumask_var(&tracing_buffer_mask, GFP_KERNEL))\n\t\tgoto out;\n\n\tif (!alloc_cpumask_var(&global_trace.tracing_cpumask, GFP_KERNEL))\n\t\tgoto out_free_buffer_mask;\n\n\t/* Only allocate trace_printk buffers if a trace_printk exists */\n\tif (__stop___trace_bprintk_fmt != __start___trace_bprintk_fmt)\n\t\t/* Must be called before global_trace.buffer is allocated */\n\t\ttrace_printk_init_buffers();\n\n\t/* To save memory, keep the ring buffer size to its minimum */\n\tif (ring_buffer_expanded)\n\t\tring_buf_size = trace_buf_size;\n\telse\n\t\tring_buf_size = 1;\n\n\tcpumask_copy(tracing_buffer_mask, cpu_possible_mask);\n\tcpumask_copy(global_trace.tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&global_trace.start_lock);\n\n\t/*\n\t * The prepare callbacks allocates some memory for the ring buffer. We\n\t * don't free the buffer if the if the CPU goes down. If we were to free\n\t * the buffer, then the user would lose any trace that was in the\n\t * buffer. The memory will be removed once the \"instance\" is removed.\n\t */\n\tret = cpuhp_setup_state_multi(CPUHP_TRACE_RB_PREPARE,\n\t\t\t\t      \"trace/RB:preapre\", trace_rb_cpu_prepare,\n\t\t\t\t      NULL);\n\tif (ret < 0)\n\t\tgoto out_free_cpumask;\n\t/* Used for event triggers */\n\tret = -ENOMEM;\n\ttemp_buffer = ring_buffer_alloc(PAGE_SIZE, RB_FL_OVERWRITE);\n\tif (!temp_buffer)\n\t\tgoto out_rm_hp_state;\n\n\tif (trace_create_savedcmd() < 0)\n\t\tgoto out_free_temp_buffer;\n\n\t/* TODO: make the number of buffers hot pluggable with CPUS */\n\tif (allocate_trace_buffers(&global_trace, ring_buf_size) < 0) {\n\t\tprintk(KERN_ERR \"tracer: failed to allocate ring buffer!\\n\");\n\t\tWARN_ON(1);\n\t\tgoto out_free_savedcmd;\n\t}\n\n\tif (global_trace.buffer_disabled)\n\t\ttracing_off();\n\n\tif (trace_boot_clock) {\n\t\tret = tracing_set_clock(&global_trace, trace_boot_clock);\n\t\tif (ret < 0)\n\t\t\tpr_warn(\"Trace clock %s not defined, going back to default\\n\",\n\t\t\t\ttrace_boot_clock);\n\t}\n\n\t/*\n\t * register_tracer() might reference current_trace, so it\n\t * needs to be set before we register anything. This is\n\t * just a bootstrap of current_trace anyway.\n\t */\n\tglobal_trace.current_trace = &nop_trace;\n\n\tglobal_trace.max_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\n\tftrace_init_global_array_ops(&global_trace);\n\n\tinit_trace_flags_index(&global_trace);\n\n\tregister_tracer(&nop_trace);\n\n\t/* Function tracing may start here (via kernel command line) */\n\tinit_function_trace();\n\n\t/* All seems OK, enable tracing */\n\ttracing_disabled = 0;\n\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &trace_panic_notifier);\n\n\tregister_die_notifier(&trace_die_notifier);\n\n\tglobal_trace.flags = TRACE_ARRAY_FL_GLOBAL;\n\n\tINIT_LIST_HEAD(&global_trace.systems);\n\tINIT_LIST_HEAD(&global_trace.events);\n\tINIT_LIST_HEAD(&global_trace.hist_vars);\n\tlist_add(&global_trace.list, &ftrace_trace_arrays);\n\n\tapply_trace_boot_options();\n\n\tregister_snapshot_cmd();\n\n\treturn 0;\n\nout_free_savedcmd:\n\tfree_saved_cmdlines_buffer(savedcmd);\nout_free_temp_buffer:\n\tring_buffer_free(temp_buffer);\nout_rm_hp_state:\n\tcpuhp_remove_multi_state(CPUHP_TRACE_RB_PREPARE);\nout_free_cpumask:\n\tfree_cpumask_var(global_trace.tracing_cpumask);\nout_free_buffer_mask:\n\tfree_cpumask_var(tracing_buffer_mask);\nout:\n\treturn ret;\n}\n",
        "output": "0",
        "index": 81445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bt_status_t destroy_channel(int channel_id){\n    UINT8 app_idx, mcl_idx, mdl_cfg_idx, mdep_cfg_idx = 0;\n bt_status_t status = BT_STATUS_SUCCESS;\n btif_hl_mdl_cfg_t *p_mdl;\n btif_hl_mcl_cb_t *p_mcb;\n btif_hl_app_cb_t *p_acb;\n\n    CHECK_BTHL_INIT();\n    BTIF_TRACE_EVENT(\"%s channel_id=0x%08x\", __FUNCTION__, channel_id);\n    btif_hl_display_calling_process_name();\n\n\n if (btif_hl_if_channel_setup_pending(channel_id, &app_idx, &mcl_idx))\n {\n        btif_hl_dch_abort(app_idx, mcl_idx);\n }\n else\n {\n if (btif_hl_find_mdl_cfg_idx_using_channel_id(channel_id, &app_idx, &mdl_cfg_idx))\n {\n            p_acb = BTIF_HL_GET_APP_CB_PTR(app_idx);\n if (!p_acb->delete_mdl.active)\n {\n                p_mdl =BTIF_HL_GET_MDL_CFG_PTR(app_idx, mdl_cfg_idx);\n                p_acb->delete_mdl.active = TRUE;\n                p_acb->delete_mdl.mdl_id = p_mdl->base.mdl_id;\n                p_acb->delete_mdl.channel_id = channel_id;\n                p_acb->delete_mdl.mdep_cfg_idx = p_mdl->extra.mdep_cfg_idx;\n                memcpy(p_acb->delete_mdl.bd_addr, p_mdl->base.peer_bd_addr,sizeof(BD_ADDR));\n\n if (btif_hl_find_mcl_idx(app_idx, p_mdl->base.peer_bd_addr, &mcl_idx))\n {\n                    p_mcb = BTIF_HL_GET_MCL_CB_PTR(app_idx, mcl_idx);\n if (p_mcb->is_connected)\n {\n                        BTIF_TRACE_DEBUG(\"calling BTA_HlDeleteMdl mdl_id=%d\",p_acb->delete_mdl.mdl_id );\n                        BTA_HlDeleteMdl(p_mcb->mcl_handle, p_acb->delete_mdl.mdl_id);\n }\n else\n {\n                        status = BT_STATUS_FAIL;\n }\n }\n else\n {\n                    BTIF_TRACE_DEBUG(\"btif_hl_delete_mdl calling btif_hl_cch_open\" );\n                    mdep_cfg_idx = p_mdl->extra.mdep_cfg_idx;\n                    p_acb->filter.num_elems =1;\n                    p_acb->filter.elem[0].data_type = p_acb->sup_feature.mdep[mdep_cfg_idx].mdep_cfg.data_cfg[mdep_cfg_idx].data_type;\n if (p_acb->sup_feature.mdep[mdep_cfg_idx].mdep_cfg.mdep_role == BTA_HL_MDEP_ROLE_SINK)\n                        p_acb->filter.elem[0].peer_mdep_role = BTA_HL_MDEP_ROLE_SOURCE;\n else\n                        p_acb->filter.elem[0].peer_mdep_role = BTA_HL_MDEP_ROLE_SINK;\n if (btif_hl_cch_open(p_acb->app_id, p_acb->delete_mdl.bd_addr, 0,\n                                         mdep_cfg_idx,\n                                         BTIF_HL_PEND_DCH_OP_DELETE_MDL, NULL))\n {\n                        status = BT_STATUS_FAIL;\n }\n }\n\n if (  status == BT_STATUS_FAIL)\n {\n /* fail for now  */\n                    btif_hl_clean_delete_mdl(&p_acb->delete_mdl);\n }\n }\n else\n {\n                status = BT_STATUS_BUSY;\n }\n }\n else\n {\n            status = BT_STATUS_FAIL;\n }\n\n }\n return status;\n}\n",
        "output": "0",
        "index": 171938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf14_cmap_gray_direct(frac gray, gx_device_color * pdc, const gs_gstate * pgs,\n                 gx_device * dev, gs_color_select_t select)\n{\n    int i,ncomps;\n    frac cm_comps[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    gx_color_value cv[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    gx_color_index color;\n    gx_device *trans_device;\n\n    /* If trans device is set, we need to use its procs. */\n    if (pgs->trans_device != NULL) {\n        trans_device = pgs->trans_device;\n    } else {\n        trans_device = dev;\n    }\n    ncomps = trans_device->color_info.num_components;\n    /* map to the color model */\n    dev_proc(trans_device, get_color_mapping_procs)(trans_device)->map_gray(trans_device, gray, cm_comps);\n\n    /* If we are in a Gray blending color space and have spots then we have\n     * possibly an issue here with the transfer function */\n    if (pgs->trans_device != NULL) {\n        cv[0] = frac2cv(gx_map_color_frac(pgs, cm_comps[0], effective_transfer[0]));\n        for (i = 1; i < ncomps; i++)\n            cv[i] = gx_color_value_from_byte(cm_comps[i]);\n    } else {\n        /* Not a transparency device.  Just use the transfer functions directly */\n        for (i = 0; i < ncomps; i++)\n            cv[i] = frac2cv(gx_map_color_frac(pgs, cm_comps[i], effective_transfer[i]));\n    }\n\n    /* if output device supports devn, we need to make sure we send it the\n    proper color type.  We now support Gray + spots as devn colors */\n    if (dev_proc(trans_device, dev_spec_op)(trans_device, gxdso_supports_devn, NULL, 0)) {\n        for (i = 0; i < ncomps; i++)\n            pdc->colors.devn.values[i] = cv[i];\n        pdc->type = gx_dc_type_devn;\n    } else {\n        /* encode as a color index */\n        color = dev_proc(trans_device, encode_color)(trans_device, cv);\n        /* check if the encoding was successful; we presume failure is rare */\n        if (color != gx_no_color_index)\n            color_set_pure(pdc, color);\n    }\n}\n",
        "output": "0",
        "index": 13292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PasswordAutofillManager::OnShowPasswordSuggestions(\n    int key,\n    base::i18n::TextDirection text_direction,\n    const base::string16& typed_username,\n    int options,\n    const gfx::RectF& bounds) {\n  std::vector<autofill::Suggestion> suggestions;\n  LoginToPasswordInfoMap::const_iterator fill_data_it =\n      login_to_password_info_.find(key);\n  if (fill_data_it == login_to_password_info_.end()) {\n    NOTREACHED();\n    return;\n  }\n  GetSuggestions(fill_data_it->second, typed_username, &suggestions,\n                 (options & autofill::SHOW_ALL) != 0,\n                 (options & autofill::IS_PASSWORD_FIELD) != 0);\n\n  form_data_key_ = key;\n\n  if (suggestions.empty()) {\n    autofill_client_->HideAutofillPopup();\n    return;\n  }\n\n  if (options & autofill::IS_PASSWORD_FIELD) {\n    autofill::Suggestion password_field_suggestions(l10n_util::GetStringUTF16(\n        IDS_AUTOFILL_PASSWORD_FIELD_SUGGESTIONS_TITLE));\n    password_field_suggestions.frontend_id = autofill::POPUP_ITEM_ID_TITLE;\n    suggestions.insert(suggestions.begin(), password_field_suggestions);\n  }\n\n  GURL origin = (fill_data_it->second).origin;\n  bool is_context_secure = autofill_client_->IsContextSecure() &&\n                           (!origin.is_valid() || !origin.SchemeIs(\"http\"));\n  if (!is_context_secure && security_state::IsHttpWarningInFormEnabled()) {\n    std::string icon_str;\n\n    if (origin.is_valid() && origin.SchemeIs(\"http\")) {\n      icon_str = \"httpWarning\";\n    } else {\n      icon_str = \"httpsInvalid\";\n    }\n\n    autofill::Suggestion http_warning_suggestion(\n        l10n_util::GetStringUTF8(IDS_AUTOFILL_LOGIN_HTTP_WARNING_MESSAGE),\n        l10n_util::GetStringUTF8(IDS_AUTOFILL_HTTP_WARNING_LEARN_MORE),\n        icon_str, autofill::POPUP_ITEM_ID_HTTP_NOT_SECURE_WARNING_MESSAGE);\n#if !defined(OS_ANDROID)\n      suggestions.insert(suggestions.begin(), autofill::Suggestion());\n      suggestions.front().frontend_id = autofill::POPUP_ITEM_ID_SEPARATOR;\n#endif\n      suggestions.insert(suggestions.begin(), http_warning_suggestion);\n\n      if (!did_show_form_not_secure_warning_) {\n        did_show_form_not_secure_warning_ = true;\n        metrics_util::LogShowedFormNotSecureWarningOnCurrentNavigation();\n      }\n  }\n\n   if (ShouldShowManualFallbackForPreLollipop(\n           autofill_client_->GetSyncService())) {\n     if (base::FeatureList::IsEnabled(\n            password_manager::features::kEnableManualFallbacksFilling) &&\n         (options & autofill::IS_PASSWORD_FIELD) && password_client_ &&\n         password_client_->IsFillingFallbackEnabledForCurrentPage()) {\n       AddSimpleSuggestionWithSeparatorOnTop(\n          IDS_AUTOFILL_SHOW_ALL_SAVED_FALLBACK,\n          autofill::POPUP_ITEM_ID_ALL_SAVED_PASSWORDS_ENTRY, &suggestions);\n\n      show_all_saved_passwords_shown_context_ =\n          metrics_util::SHOW_ALL_SAVED_PASSWORDS_CONTEXT_PASSWORD;\n      metrics_util::LogContextOfShowAllSavedPasswordsShown(\n          show_all_saved_passwords_shown_context_);\n    }\n    if (base::FeatureList::IsEnabled(\n            password_manager::features::kEnableManualFallbacksGeneration) &&\n        password_manager_util::GetPasswordSyncState(\n            autofill_client_->GetSyncService()) == SYNCING_NORMAL_ENCRYPTION) {\n      AddSimpleSuggestionWithSeparatorOnTop(\n          IDS_AUTOFILL_GENERATE_PASSWORD_FALLBACK,\n          autofill::POPUP_ITEM_ID_GENERATE_PASSWORD_ENTRY, &suggestions);\n    }\n  }\n\n  autofill_client_->ShowAutofillPopup(bounds,\n                                      text_direction,\n                                      suggestions,\n                                      weak_ptr_factory_.GetWeakPtr());\n}\n",
        "output": "1",
        "index": 185624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "content::PreviewsState ChromeContentBrowserClient::DetermineAllowedPreviews(\n    content::PreviewsState initial_state,\n    content::NavigationHandle* navigation_handle,\n    const GURL& current_navigation_url) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (!navigation_handle->IsInMainFrame() ||\n      navigation_handle->IsSameDocument()) {\n    return initial_state;\n  }\n\n  if (!current_navigation_url.SchemeIsHTTPOrHTTPS()) {\n    return content::PREVIEWS_OFF;\n  }\n\n  content::WebContents* web_contents = navigation_handle->GetWebContents();\n  content::WebContentsDelegate* delegate = web_contents->GetDelegate();\n\n  auto* browser_context = web_contents->GetBrowserContext();\n\n  PreviewsService* previews_service = PreviewsServiceFactory::GetForProfile(\n      Profile::FromBrowserContext(browser_context));\n  auto* data_reduction_proxy_settings =\n      DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n          browser_context);\n  if (!previews_service || !previews_service->previews_ui_service() ||\n      !data_reduction_proxy_settings) {\n    return content::PREVIEWS_OFF;\n  }\n\n  PreviewsUITabHelper* ui_tab_helper =\n      PreviewsUITabHelper::FromWebContents(web_contents);\n  if (!ui_tab_helper)\n    return content::PREVIEWS_OFF;\n\n  DCHECK(!browser_context->IsOffTheRecord());\n\n  previews::PreviewsDeciderImpl* previews_decider_impl =\n      previews_service->previews_ui_service()->previews_decider_impl();\n  DCHECK(previews_decider_impl);\n\n  content::PreviewsState previews_state = content::PREVIEWS_UNSPECIFIED;\n\n  previews::PreviewsUserData* previews_data =\n      ui_tab_helper->GetPreviewsUserData(navigation_handle);\n\n  bool is_redirect = false;\n  if (previews_data) {\n    is_redirect = !previews_data->server_lite_page_info();\n  } else {\n    previews_data = ui_tab_helper->CreatePreviewsUserDataForNavigationHandle(\n        navigation_handle, previews_decider_impl->GeneratePageId());\n  }\n\n  DCHECK(previews_data);\n\n  bool is_reload =\n      navigation_handle->GetReloadType() != content::ReloadType::NONE;\n\n  content::PreviewsState server_previews_enabled_state =\n      content::SERVER_LOFI_ON | content::SERVER_LITE_PAGE_ON;\n\n  if (is_redirect) {\n    previews_state |= (previews_data->allowed_previews_state() &\n                       server_previews_enabled_state);\n  } else {\n    if (previews_decider_impl->ShouldAllowPreviewAtNavigationStart(\n            previews_data, current_navigation_url, is_reload,\n            previews::PreviewsType::LITE_PAGE)) {\n      previews_state |= server_previews_enabled_state;\n    }\n  }\n\n  previews_state |= previews::DetermineAllowedClientPreviewsState(\n      previews_data, current_navigation_url, is_reload, is_redirect,\n      data_reduction_proxy_settings->IsDataReductionProxyEnabled(),\n      previews_decider_impl);\n\n  if (previews_state & content::PREVIEWS_OFF) {\n    previews_data->set_allowed_previews_state(content::PREVIEWS_OFF);\n    return content::PREVIEWS_OFF;\n  }\n\n  if (previews_state & content::PREVIEWS_NO_TRANSFORM) {\n    previews_data->set_allowed_previews_state(content::PREVIEWS_NO_TRANSFORM);\n    return content::PREVIEWS_NO_TRANSFORM;\n  }\n\n  if (previews_state == content::PREVIEWS_UNSPECIFIED) {\n    previews_data->set_allowed_previews_state(content::PREVIEWS_OFF);\n    return content::PREVIEWS_OFF;\n  }\n\n  content::PreviewsState embedder_state = content::PREVIEWS_UNSPECIFIED;\n  if (delegate) {\n    delegate->AdjustPreviewsStateForNavigation(web_contents, &embedder_state);\n  }\n\n  if (embedder_state != content::PREVIEWS_UNSPECIFIED) {\n    previews_state = previews_state & embedder_state;\n    if (previews_state == content::PREVIEWS_UNSPECIFIED)\n      previews_state = content::PREVIEWS_OFF;\n  }\n  previews_data->set_allowed_previews_state(previews_state);\n  return previews_state;\n}\n",
        "output": "0",
        "index": 165291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderFrameImpl::RenderFrameImpl(CreateParams params)\n    : frame_(nullptr),\n      is_main_frame_(true),\n      unique_name_frame_adapter_(this),\n      unique_name_helper_(&unique_name_frame_adapter_),\n      in_frame_tree_(false),\n      render_view_(params.render_view),\n      routing_id_(params.routing_id),\n      proxy_routing_id_(MSG_ROUTING_NONE),\n#if BUILDFLAG(ENABLE_PLUGINS)\n      plugin_power_saver_helper_(nullptr),\n#endif\n      cookie_jar_(this),\n      selection_text_offset_(0),\n      selection_range_(gfx::Range::InvalidRange()),\n      handling_select_range_(false),\n      web_user_media_client_(nullptr),\n      push_messaging_client_(nullptr),\n      render_accessibility_(nullptr),\n      previews_state_(PREVIEWS_UNSPECIFIED),\n      effective_connection_type_(\n          blink::WebEffectiveConnectionType::kTypeUnknown),\n      is_pasting_(false),\n      suppress_further_dialogs_(false),\n      blame_context_(nullptr),\n#if BUILDFLAG(ENABLE_PLUGINS)\n      focused_pepper_plugin_(nullptr),\n      pepper_last_mouse_event_target_(nullptr),\n#endif\n      autoplay_configuration_binding_(this),\n      frame_binding_(this),\n      host_zoom_binding_(this),\n      frame_bindings_control_binding_(this),\n      frame_navigation_control_binding_(this),\n      fullscreen_binding_(this),\n      navigation_client_impl_(nullptr),\n      has_accessed_initial_document_(false),\n      media_factory_(this,\n                     base::Bind(&RenderFrameImpl::RequestOverlayRoutingToken,\n                                base::Unretained(this))),\n      input_target_client_impl_(this),\n      devtools_frame_token_(params.devtools_frame_token),\n      weak_factory_(this) {\n  CHECK(params.interface_provider.is_bound());\n  remote_interfaces_.Bind(std::move(params.interface_provider));\n  blink_interface_registry_.reset(new BlinkInterfaceRegistryImpl(\n      registry_.GetWeakPtr(), associated_interfaces_.GetWeakPtr()));\n\n  media_factory_.SetupMojo();\n\n  std::pair<RoutingIDFrameMap::iterator, bool> result =\n      g_routing_id_frame_map.Get().insert(std::make_pair(routing_id_, this));\n  CHECK(result.second) << \"Inserting a duplicate item.\";\n\n#if defined(OS_ANDROID)\n  new GinJavaBridgeDispatcher(this);\n#endif\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  plugin_power_saver_helper_ = new PluginPowerSaverHelper(this);\n#endif\n\n  manifest_manager_ = std::make_unique<ManifestManager>(this);\n  if (IsMainFrame()) {\n    new ManifestChangeNotifier(this);\n  }\n}\n",
        "output": "0",
        "index": 165930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void http_change_connection_header(struct http_txn *txn, struct http_msg *msg, int wanted)\n{\n\tstruct hdr_ctx ctx;\n\tconst char *hdr_val = \"Connection\";\n\tint hdr_len = 10;\n\n\tctx.idx = 0;\n\n\n\tif (unlikely(txn->flags & TX_USE_PX_CONN)) {\n\t\thdr_val = \"Proxy-Connection\";\n\t\thdr_len = 16;\n\t}\n\n\ttxn->flags &= ~(TX_CON_CLO_SET | TX_CON_KAL_SET);\n\twhile (http_find_header2(hdr_val, hdr_len, msg->chn->buf->p, &txn->hdr_idx, &ctx)) {\n\t\tif (ctx.vlen >= 10 && word_match(ctx.line + ctx.val, ctx.vlen, \"keep-alive\", 10)) {\n\t\t\tif (wanted & TX_CON_KAL_SET)\n\t\t\t\ttxn->flags |= TX_CON_KAL_SET;\n\t\t\telse\n\t\t\t\thttp_remove_header2(msg, &txn->hdr_idx, &ctx);\n\t\t}\n\t\telse if (ctx.vlen >= 5 && word_match(ctx.line + ctx.val, ctx.vlen, \"close\", 5)) {\n\t\t\tif (wanted & TX_CON_CLO_SET)\n\t\t\t\ttxn->flags |= TX_CON_CLO_SET;\n\t\t\telse\n\t\t\t\thttp_remove_header2(msg, &txn->hdr_idx, &ctx);\n\t\t}\n\t}\n\n\tif (wanted == (txn->flags & (TX_CON_CLO_SET|TX_CON_KAL_SET)))\n\t\treturn;\n\n\tif ((wanted & TX_CON_CLO_SET) && !(txn->flags & TX_CON_CLO_SET)) {\n\t\ttxn->flags |= TX_CON_CLO_SET;\n\t\thdr_val = \"Connection: close\";\n\t\thdr_len  = 17;\n\t\tif (unlikely(txn->flags & TX_USE_PX_CONN)) {\n\t\t\thdr_val = \"Proxy-Connection: close\";\n\t\t\thdr_len = 23;\n\t\t}\n\t\thttp_header_add_tail2(msg, &txn->hdr_idx, hdr_val, hdr_len);\n\t}\n\n\tif ((wanted & TX_CON_KAL_SET) && !(txn->flags & TX_CON_KAL_SET)) {\n\t\ttxn->flags |= TX_CON_KAL_SET;\n\t\thdr_val = \"Connection: keep-alive\";\n\t\thdr_len = 22;\n\t\tif (unlikely(txn->flags & TX_USE_PX_CONN)) {\n\t\t\thdr_val = \"Proxy-Connection: keep-alive\";\n\t\t\thdr_len = 28;\n\t\t}\n\t\thttp_header_add_tail2(msg, &txn->hdr_idx, hdr_val, hdr_len);\n\t}\n\treturn;\n}\n",
        "output": "0",
        "index": 6817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {\n    union {\n        protocol_binary_request_no_extras request;\n        protocol_binary_response_no_extras response;\n        char bytes[1024];\n    } send, receive;\n\n    size_t len = storage_command(send.bytes, sizeof(send.bytes),\n                                 PROTOCOL_BINARY_CMD_ADD,\n                                 key, strlen(key), NULL, 0, 0, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);\n    safe_send(send.bytes, len, false);\n    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, cmd,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n    }\n\n    len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_GET,\n                      key, strlen(key), NULL, 0);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                             PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n    sleep(2);\n    safe_send(send.bytes, len, false);\n    safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n\n    int ii;\n    for (ii = 0; ii < 2; ++ii) {\n        len = storage_command(send.bytes, sizeof(send.bytes),\n                              PROTOCOL_BINARY_CMD_ADD,\n                              key, strlen(key), NULL, 0, 0, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,\n                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);\n\n        len = flush_command(send.bytes, sizeof(send.bytes), cmd, 0, ii == 0);\n        safe_send(send.bytes, len, false);\n        if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {\n            safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n            validate_response_header(&receive.response, cmd,\n                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);\n        }\n\n        len = raw_command(send.bytes, sizeof(send.bytes),\n                          PROTOCOL_BINARY_CMD_GET,\n                          key, strlen(key), NULL, 0);\n        safe_send(send.bytes, len, false);\n        safe_recv_packet(receive.bytes, sizeof(receive.bytes));\n        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_GET,\n                                 PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);\n    }\n\n    return TEST_PASS;\n}\n",
        "output": "0",
        "index": 94254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::commitProvisionalLoad(PassRefPtr<CachedPage> prpCachedPage)\n{\n    RefPtr<CachedPage> cachedPage = prpCachedPage;\n    RefPtr<DocumentLoader> pdl = m_provisionalDocumentLoader;\n\n    LOG(PageCache, \"WebCoreLoading %s: About to commit provisional load from previous URL '%s' to new URL '%s'\", m_frame->tree()->name().string().utf8().data(), m_URL.string().utf8().data(), \n        pdl ? pdl->url().string().utf8().data() : \"<no provisional DocumentLoader>\");\n\n    cachePageForHistoryItem(history()->currentItem());\n    \n    if (m_loadType != FrameLoadTypeReplace)\n        closeOldDataSources();\n    \n    if (!cachedPage && !m_creatingInitialEmptyDocument)\n        m_client->makeRepresentation(pdl.get());\n    \n    transitionToCommitted(cachedPage);\n    \n    if (m_sentRedirectNotification)\n        clientRedirectCancelledOrFinished(false);\n    \n    if (cachedPage && cachedPage->document())\n        open(*cachedPage);\n    else {        \n        KURL url = pdl->substituteData().responseURL();\n        if (url.isEmpty())\n            url = pdl->url();\n        if (url.isEmpty())\n            url = pdl->responseURL();\n        if (url.isEmpty())\n            url = blankURL();\n\n        didOpenURL(url);\n    }\n\n    LOG(Loading, \"WebCoreLoading %s: Finished committing provisional load to URL %s\", m_frame->tree()->name().string().utf8().data(), m_URL.string().utf8().data());\n\n    if (m_loadType == FrameLoadTypeStandard && m_documentLoader->isClientRedirect())\n        history()->updateForClientRedirect();\n\n    if (m_loadingFromCachedPage) {\n        m_frame->document()->documentDidBecomeActive();\n        \n        m_frame->view()->forceLayout();\n\n        const ResponseVector& responses = m_documentLoader->responses();\n        size_t count = responses.size();\n        for (size_t i = 0; i < count; i++) {\n            const ResourceResponse& response = responses[i];\n            ResourceError error;\n            unsigned long identifier;\n            ResourceRequest request(response.url());\n            requestFromDelegate(request, identifier, error);\n            notifier()->sendRemainingDelegateMessages(m_documentLoader.get(), identifier, response, static_cast<int>(response.expectedContentLength()), error);\n        }\n        \n        pageCache()->remove(history()->currentItem());\n\n        m_documentLoader->setPrimaryLoadComplete(true);\n\n        checkLoadCompleteForThisFrame();\n    }\n}\n",
        "output": "0",
        "index": 97376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ar6000_ap_mode_profile_commit(struct ar6_softc *ar)\n{\n    WMI_CONNECT_CMD p;\n    unsigned long  flags;\n\n    /* No change in AP's profile configuration */\n    if(ar->ap_profile_flag==0) {\n        A_PRINTF(\"COMMIT: No change in profile!!!\\n\");\n        return -ENODATA;\n    }\n\n    if(!ar->arSsidLen) {\n        A_PRINTF(\"SSID not set!!!\\n\");\n        return -ECHRNG;\n    }\n\n    switch(ar->arAuthMode) {\n    case NONE_AUTH:\n        if((ar->arPairwiseCrypto != NONE_CRYPT) &&\n#ifdef WAPI_ENABLE\n           (ar->arPairwiseCrypto != WAPI_CRYPT) &&\n#endif\n           (ar->arPairwiseCrypto != WEP_CRYPT)) {\n            A_PRINTF(\"Cipher not supported in AP mode Open auth\\n\");\n            return -EOPNOTSUPP;\n        }\n        break;\n    case WPA_PSK_AUTH:\n    case WPA2_PSK_AUTH:\n    case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n        break;\n    default:\n        A_PRINTF(\"This key mgmt type not supported in AP mode\\n\");\n        return -EOPNOTSUPP;\n    }\n\n    /* Update the arNetworkType */\n    ar->arNetworkType = ar->arNextMode;\n\n    A_MEMZERO(&p,sizeof(p));\n    p.ssidLength = ar->arSsidLen;\n    memcpy(p.ssid,ar->arSsid,p.ssidLength);\n    p.channel = ar->arChannelHint;\n    p.networkType = ar->arNetworkType;\n\n    p.dot11AuthMode = ar->arDot11AuthMode;\n    p.authMode = ar->arAuthMode;\n    p.pairwiseCryptoType = ar->arPairwiseCrypto;\n    p.pairwiseCryptoLen = ar->arPairwiseCryptoLen;\n    p.groupCryptoType = ar->arGroupCrypto;\n    p.groupCryptoLen = ar->arGroupCryptoLen;\n    p.ctrl_flags = ar->arConnectCtrlFlags;\n\n    wmi_ap_profile_commit(ar->arWmi, &p);\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    ar->ap_profile_flag = 0;\n    return 0;\n}\n",
        "output": "0",
        "index": 24151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int whiteheat_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\t/*\n\t * When the module is reloaded the firmware is still there and\n\t * the endpoints are still in the usb core unchanged. This is the\n\t * unlinking bug in disguise. Same for the call below.\n\t */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\t/* See the comment on the usb_clear_halt() above */\n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\n\treturn 0;\n\nno_firmware:\n\t/* Firmware likely not running */\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\n\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\n",
        "output": "0",
        "index": 38095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int compat_mc_getsockopt(struct sock *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen,\n\tint (*getsockopt)(struct sock *, int, int, char __user *, int __user *))\n{\n\tstruct compat_group_filter __user *gf32 = (void *)optval;\n\tstruct group_filter __user *kgf;\n\tint __user\t*koptlen;\n\tu32 interface, fmode, numsrc;\n\tint klen, ulen, err;\n\n\tif (optname != MCAST_MSFILTER)\n\t\treturn getsockopt(sock, level, optname, optval, optlen);\n\n\tkoptlen = compat_alloc_user_space(sizeof(*koptlen));\n\tif (!access_ok(VERIFY_READ, optlen, sizeof(*optlen)) ||\n\t    __get_user(ulen, optlen))\n\t\treturn -EFAULT;\n\n\t/* adjust len for pad */\n\tklen = ulen + sizeof(*kgf) - sizeof(*gf32);\n\n\tif (klen < GROUP_FILTER_SIZE(0))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, koptlen, sizeof(*koptlen)) ||\n\t    __put_user(klen, koptlen))\n\t\treturn -EFAULT;\n\n\t/* have to allow space for previous compat_alloc_user_space, too */\n\tkgf = compat_alloc_user_space(klen+sizeof(*optlen));\n\n\tif (!access_ok(VERIFY_READ, gf32, __COMPAT_GF0_SIZE) ||\n\t    __get_user(interface, &gf32->gf_interface) ||\n\t    __get_user(fmode, &gf32->gf_fmode) ||\n\t    __get_user(numsrc, &gf32->gf_numsrc) ||\n\t    __put_user(interface, &kgf->gf_interface) ||\n\t    __put_user(fmode, &kgf->gf_fmode) ||\n\t    __put_user(numsrc, &kgf->gf_numsrc) ||\n\t    copy_in_user(&kgf->gf_group, &gf32->gf_group, sizeof(kgf->gf_group)))\n\t\treturn -EFAULT;\n\n\terr = getsockopt(sock, level, optname, (char __user *)kgf, koptlen);\n\tif (err)\n\t\treturn err;\n\n\tif (!access_ok(VERIFY_READ, koptlen, sizeof(*koptlen)) ||\n\t    __get_user(klen, koptlen))\n\t\treturn -EFAULT;\n\n\tulen = klen - (sizeof(*kgf)-sizeof(*gf32));\n\n\tif (!access_ok(VERIFY_WRITE, optlen, sizeof(*optlen)) ||\n\t    __put_user(ulen, optlen))\n\t\treturn -EFAULT;\n\n\tif (!access_ok(VERIFY_READ, kgf, klen) ||\n\t    !access_ok(VERIFY_WRITE, gf32, ulen) ||\n\t    __get_user(interface, &kgf->gf_interface) ||\n\t    __get_user(fmode, &kgf->gf_fmode) ||\n\t    __get_user(numsrc, &kgf->gf_numsrc) ||\n\t    __put_user(interface, &gf32->gf_interface) ||\n\t    __put_user(fmode, &gf32->gf_fmode) ||\n\t    __put_user(numsrc, &gf32->gf_numsrc))\n\t\treturn -EFAULT;\n\tif (numsrc) {\n\t\tint copylen;\n\n\t\tklen -= GROUP_FILTER_SIZE(0);\n\t\tcopylen = numsrc * sizeof(gf32->gf_slist[0]);\n\t\tif (copylen > klen)\n\t\t\tcopylen = klen;\n\t\tif (copy_in_user(gf32->gf_slist, kgf->gf_slist, copylen))\n\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}\n",
        "output": "0",
        "index": 40065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean webkit_web_view_forward_context_menu_event(WebKitWebView* webView, const PlatformMouseEvent& event)\n{\n    Page* page = core(webView);\n    page->contextMenuController()->clearContextMenu();\n    Frame* focusedFrame;\n    Frame* mainFrame = page->mainFrame();\n    gboolean mousePressEventResult = FALSE;\n\n    if (!mainFrame->view())\n        return FALSE;\n\n    mainFrame->view()->setCursor(pointerCursor());\n    if (page->frameCount()) {\n        HitTestRequest request(HitTestRequest::Active);\n        IntPoint point = mainFrame->view()->windowToContents(event.pos());\n        MouseEventWithHitTestResults mev = mainFrame->document()->prepareMouseEvent(request, point, event);\n\n        Frame* targetFrame = EventHandler::subframeForHitTestResult(mev);\n        if (!targetFrame)\n            targetFrame = mainFrame;\n\n        focusedFrame = page->focusController()->focusedOrMainFrame();\n        if (targetFrame != focusedFrame) {\n            page->focusController()->setFocusedFrame(targetFrame);\n            focusedFrame = targetFrame;\n        }\n    } else\n        focusedFrame = mainFrame;\n\n    if (focusedFrame->view() && focusedFrame->eventHandler()->handleMousePressEvent(event))\n        mousePressEventResult = TRUE;\n\n\n    bool handledEvent = focusedFrame->eventHandler()->sendContextMenuEvent(event);\n    if (!handledEvent)\n        return FALSE;\n\n    ContextMenuController* controller = page->contextMenuController();\n    ContextMenu* coreMenu = controller->contextMenu();\n    if (!coreMenu)\n        return mousePressEventResult;\n\n    WebKitWebSettings* settings = webkit_web_view_get_settings(webView);\n    gboolean enableDefaultContextMenu;\n    g_object_get(settings, \"enable-default-context-menu\", &enableDefaultContextMenu, NULL);\n\n    if (!enableDefaultContextMenu)\n        return FALSE;\n\n    GtkMenu* menu = GTK_MENU(coreMenu->platformDescription());\n    if (!menu)\n        return FALSE;\n\n    gtk_container_foreach(GTK_CONTAINER(menu), (GtkCallback)contextMenuConnectActivate, controller);\n\n    g_signal_emit(webView, webkit_web_view_signals[POPULATE_POPUP], 0, menu);\n\n    GOwnPtr<GList> items(gtk_container_get_children(GTK_CONTAINER(menu)));\n    if (!items)\n        return FALSE;\n\n    WebKitWebViewPrivate* priv = webView->priv;\n    priv->currentMenu = menu;\n    priv->lastPopupXPosition = event.globalX();\n    priv->lastPopupYPosition = event.globalY();\n\n    gtk_menu_popup(menu, 0, 0, &PopupMenuPositionFunc, webView, event.button() + 1, gtk_get_current_event_time());\n    return TRUE;\n}\n",
        "output": "0",
        "index": 105424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void imapd_reset(void)\n{\n    int i;\n    int bytes_in = 0;\n    int bytes_out = 0;\n\n    proc_cleanup();\n\n    /* close backend connections */\n    i = 0;\n    while (backend_cached && backend_cached[i]) {\n        proxy_downserver(backend_cached[i]);\n        if (backend_cached[i]->last_result.s) {\n            free(backend_cached[i]->last_result.s);\n        }\n        free(backend_cached[i]);\n        i++;\n    }\n    if (backend_cached) free(backend_cached);\n    backend_cached = NULL;\n    backend_inbox = backend_current = NULL;\n    if (mupdate_h) mupdate_disconnect(&mupdate_h);\n    mupdate_h = NULL;\n    proxy_cmdcnt = 0;\n    disable_referrals = 0;\n    supports_referrals = 0;\n\n    if (imapd_index) index_close(&imapd_index);\n\n    if (imapd_in) {\n        /* Flush the incoming buffer */\n        prot_NONBLOCK(imapd_in);\n        prot_fill(imapd_in);\n        bytes_in = prot_bytes_in(imapd_in);\n        prot_free(imapd_in);\n    }\n\n    if (imapd_out) {\n        /* Flush the outgoing buffer */\n        prot_flush(imapd_out);\n        bytes_out = prot_bytes_out(imapd_out);\n        prot_free(imapd_out);\n    }\n\n    if (config_auditlog)\n        syslog(LOG_NOTICE, \"auditlog: traffic sessionid=<%s> bytes_in=<%d> bytes_out=<%d>\",\n                           session_id(), bytes_in, bytes_out);\n\n    imapd_in = imapd_out = NULL;\n\n    if (protin) protgroup_reset(protin);\n\n#ifdef HAVE_SSL\n    if (tls_conn) {\n        if (tls_reset_servertls(&tls_conn) == -1) {\n            fatal(\"tls_reset() failed\", EC_TEMPFAIL);\n        }\n        tls_conn = NULL;\n    }\n#endif\n\n    cyrus_reset_stdio();\n\n    imapd_clienthost = \"[local]\";\n    if (imapd_logfd != -1) {\n        close(imapd_logfd);\n        imapd_logfd = -1;\n    }\n    if (imapd_userid != NULL) {\n        free(imapd_userid);\n        imapd_userid = NULL;\n    }\n    if (proxy_userid != NULL) {\n        free(proxy_userid);\n        proxy_userid = NULL;\n    }\n    if (imapd_magicplus != NULL) {\n        free(imapd_magicplus);\n        imapd_magicplus = NULL;\n    }\n    if (imapd_authstate) {\n        auth_freestate(imapd_authstate);\n        imapd_authstate = NULL;\n    }\n    imapd_userisadmin = 0;\n    imapd_userisproxyadmin = 0;\n    client_capa = 0;\n    if (imapd_saslconn) {\n        sasl_dispose(&imapd_saslconn);\n        free(imapd_saslconn);\n        imapd_saslconn = NULL;\n    }\n    imapd_compress_done = 0;\n    imapd_tls_comp = NULL;\n    imapd_starttls_done = 0;\n    plaintextloginalert = NULL;\n\n    if(saslprops.iplocalport) {\n        free(saslprops.iplocalport);\n        saslprops.iplocalport = NULL;\n    }\n    if(saslprops.ipremoteport) {\n        free(saslprops.ipremoteport);\n        saslprops.ipremoteport = NULL;\n    }\n    if(saslprops.authid) {\n        free(saslprops.authid);\n        saslprops.authid = NULL;\n    }\n    saslprops.ssf = 0;\n\n    clear_id();\n}\n",
        "output": "0",
        "index": 95221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_peer_node(\n\tint\t\thmode,\n\taddress_node *\taddr,\n\tattr_val_fifo *\toptions\n\t)\n{\n\tpeer_node *my_node;\n\tattr_val *option;\n\tint freenode;\n\tint errflag = 0;\n\n\tmy_node = emalloc_zero(sizeof(*my_node));\n\n\t/* Initialize node values to default */\n\tmy_node->peerversion = NTP_VERSION;\n\n\t/* Now set the node to the read values */\n\tmy_node->host_mode = hmode;\n\tmy_node->addr = addr;\n\n\t/*\n\t * the options FIFO mixes items that will be saved in the\n\t * peer_node as explicit members, such as minpoll, and\n\t * those that are moved intact to the peer_node's peerflags\n\t * FIFO.  The options FIFO is consumed and reclaimed here.\n\t */\n\n\twhile (options != NULL) {\n\t\tUNLINK_FIFO(option, *options, link);\n\t\tif (NULL == option) {\n\t\t\tfree(options);\n\t\t\tbreak;\n\t\t}\n\n\t\tfreenode = 1;\n\t\t/* Check the kind of option being set */\n\t\tswitch (option->attr) {\n\n\t\tcase T_Flag:\n\t\t\tAPPEND_G_FIFO(my_node->peerflags, option);\n\t\t\tfreenode = 0;\n\t\t\tbreak;\n\n\t\tcase T_Minpoll:\n\t\t\tif (option->value.i < NTP_MINPOLL ||\n\t\t\t    option->value.i > UCHAR_MAX) {\n\t\t\t\tmsyslog(LOG_INFO,\n\t\t\t\t\t\"minpoll: provided value (%d) is out of range [%d-%d])\",\n\t\t\t\t\toption->value.i, NTP_MINPOLL,\n\t\t\t\t\tUCHAR_MAX);\n\t\t\t\tmy_node->minpoll = NTP_MINPOLL;\n\t\t\t} else {\n\t\t\t\tmy_node->minpoll = \n\t\t\t\t\t(u_char)option->value.u;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase T_Maxpoll:\n\t\t\tif (option->value.i < 0 ||\n\t\t\t    option->value.i > NTP_MAXPOLL) {\n\t\t\t\tmsyslog(LOG_INFO,\n\t\t\t\t\t\"maxpoll: provided value (%d) is out of range [0-%d])\",\n\t\t\t\t\toption->value.i, NTP_MAXPOLL);\n\t\t\t\tmy_node->maxpoll = NTP_MAXPOLL;\n\t\t\t} else {\n\t\t\t\tmy_node->maxpoll = \n\t\t\t\t\t(u_char)option->value.u;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase T_Ttl:\n\t\t\tif (option->value.u >= MAX_TTL) {\n\t\t\t\tmsyslog(LOG_ERR, \"ttl: invalid argument\");\n\t\t\t\terrflag = 1;\n\t\t\t} else {\n\t\t\t\tmy_node->ttl = (u_char)option->value.u;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase T_Mode:\n\t\t\tif (option->value.u >= UCHAR_MAX) {\n\t\t\t\tmsyslog(LOG_ERR, \"mode: invalid argument\");\n\t\t\t\terrflag = 1;\n\t\t\t} else {\n\t\t\t\tmy_node->ttl = (u_char)option->value.u;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase T_Key:\n\t\t\tif (option->value.u >= KEYID_T_MAX) {\n\t\t\t\tmsyslog(LOG_ERR, \"key: invalid argument\");\n\t\t\t\terrflag = 1;\n\t\t\t} else {\n\t\t\t\tmy_node->peerkey = \n\t\t\t\t\t(keyid_t)option->value.u;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase T_Version:\n\t\t\tif (option->value.u >= UCHAR_MAX) {\n\t\t\t\tmsyslog(LOG_ERR, \"version: invalid argument\");\n\t\t\t\terrflag = 1;\n\t\t\t} else {\n\t\t\t\tmy_node->peerversion = \n\t\t\t\t\t(u_char)option->value.u;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase T_Ident:\n\t\t\tmy_node->group = option->value.s;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmsyslog(LOG_ERR, \n\t\t\t\t\"Unknown peer/server option token %s\",\n\t\t\t\ttoken_name(option->attr));\n\t\t\terrflag = 1;\n\t\t}\n\t\tif (freenode)\n\t\t\tfree(option);\n\t}\n\n\t/* Check if errors were reported. If yes, ignore the node */\n\tif (errflag) {\n\t\tfree(my_node);\n\t\tmy_node = NULL;\n\t}\n\n\treturn my_node;\n}\n",
        "output": "0",
        "index": 74159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n{\n    unsigned char *seq;\n    EVP_MD_CTX *hash;\n    size_t md_size;\n    int i;\n    EVP_MD_CTX *hmac = NULL, *mac_ctx;\n    unsigned char header[13];\n    int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)\n                      : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));\n    int t;\n\n    if (send) {\n        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);\n        hash = ssl->write_hash;\n    } else {\n        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);\n        hash = ssl->read_hash;\n    }\n\n    t = EVP_MD_CTX_size(hash);\n    OPENSSL_assert(t >= 0);\n    md_size = t;\n\n    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */\n    if (stream_mac) {\n        mac_ctx = hash;\n    } else {\n        hmac = EVP_MD_CTX_new();\n        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))\n            return -1;\n        mac_ctx = hmac;\n    }\n\n    if (SSL_IS_DTLS(ssl)) {\n        unsigned char dtlsseq[8], *p = dtlsseq;\n\n        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :\n            DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p);\n        memcpy(p, &seq[2], 6);\n\n        memcpy(header, dtlsseq, 8);\n    } else\n        memcpy(header, seq, 8);\n\n    header[8] = rec->type;\n    header[9] = (unsigned char)(ssl->version >> 8);\n    header[10] = (unsigned char)(ssl->version);\n     header[11] = (rec->length) >> 8;\n     header[12] = (rec->length) & 0xff;\n \n    if (!send && !SSL_USE_ETM(ssl) &&\n         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n         ssl3_cbc_record_digest_supported(mac_ctx)) {\n         /*\n         * This is a CBC-encrypted record. We must avoid leaking any\n         * timing-side channel information about how many blocks of data we\n         * are hashing because that gives an attacker a timing-oracle.\n         */\n        /* Final param == not SSLv3 */\n        if (ssl3_cbc_digest_record(mac_ctx,\n                                   md, &md_size,\n                                   header, rec->input,\n                                   rec->length + md_size, rec->orig_len,\n                                   ssl->s3->read_mac_secret,\n                                   ssl->s3->read_mac_secret_size, 0) <= 0) {\n            EVP_MD_CTX_free(hmac);\n            return -1;\n        }\n    } else {\n        if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0\n            || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0\n            || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) {\n             EVP_MD_CTX_free(hmac);\n             return -1;\n         }\n        if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())\n             if (!tls_fips_digest_extra(ssl->enc_read_ctx,\n                                        mac_ctx, rec->input,\n                                        rec->length, rec->orig_len)) {\n                EVP_MD_CTX_free(hmac);\n                return -1;\n            }\n    }\n\n    EVP_MD_CTX_free(hmac);\n\n#ifdef SSL_DEBUG\n    fprintf(stderr, \"seq=\");\n    {\n        int z;\n        for (z = 0; z < 8; z++)\n            fprintf(stderr, \"%02X \", seq[z]);\n        fprintf(stderr, \"\\n\");\n    }\n    fprintf(stderr, \"rec=\");\n    {\n        unsigned int z;\n        for (z = 0; z < rec->length; z++)\n            fprintf(stderr, \"%02X \", rec->data[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n\n    if (!SSL_IS_DTLS(ssl)) {\n        for (i = 7; i >= 0; i--) {\n            ++seq[i];\n            if (seq[i] != 0)\n                break;\n        }\n    }\n#ifdef SSL_DEBUG\n    {\n        unsigned int z;\n        for (z = 0; z < md_size; z++)\n            fprintf(stderr, \"%02X \", md[z]);\n        fprintf(stderr, \"\\n\");\n    }\n#endif\n    return (md_size);\n}\n",
        "output": "1",
        "index": 181596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static opj_pi_iterator_t * opj_pi_create(const opj_image_t *image,\n        const opj_cp_t *cp,\n        OPJ_UINT32 tileno)\n{\n    /* loop*/\n    OPJ_UINT32 pino, compno;\n    /* number of poc in the p_pi*/\n    OPJ_UINT32 l_poc_bound;\n\n    /* pointers to tile coding parameters and components.*/\n    opj_pi_iterator_t *l_pi = 00;\n    opj_tcp_t *tcp = 00;\n    const opj_tccp_t *tccp = 00;\n\n    /* current packet iterator being allocated*/\n    opj_pi_iterator_t *l_current_pi = 00;\n\n    /* preconditions in debug*/\n    assert(cp != 00);\n    assert(image != 00);\n    assert(tileno < cp->tw * cp->th);\n\n    /* initializations*/\n    tcp = &cp->tcps[tileno];\n    l_poc_bound = tcp->numpocs + 1;\n\n    /* memory allocations*/\n    l_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound),\n                                           sizeof(opj_pi_iterator_t));\n    if (!l_pi) {\n        return NULL;\n    }\n\n    l_current_pi = l_pi;\n    for (pino = 0; pino < l_poc_bound ; ++pino) {\n\n        l_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps,\n                              sizeof(opj_pi_comp_t));\n        if (! l_current_pi->comps) {\n            opj_pi_destroy(l_pi, l_poc_bound);\n            return NULL;\n        }\n\n        l_current_pi->numcomps = image->numcomps;\n\n        for (compno = 0; compno < image->numcomps; ++compno) {\n            opj_pi_comp_t *comp = &l_current_pi->comps[compno];\n\n            tccp = &tcp->tccps[compno];\n\n            comp->resolutions = (opj_pi_resolution_t*) opj_calloc(tccp->numresolutions,\n                                sizeof(opj_pi_resolution_t));\n            if (!comp->resolutions) {\n                opj_pi_destroy(l_pi, l_poc_bound);\n                return 00;\n            }\n\n            comp->numresolutions = tccp->numresolutions;\n        }\n        ++l_current_pi;\n    }\n    return l_pi;\n}\n",
        "output": "0",
        "index": 70096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM))\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.pending = events->exception.injected;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\n\tvcpu->arch.interrupt.pending = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tkvm_x86_ops->set_interrupt_shadow(vcpu,\n\t\t\t\t\t\t  events->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tkvm_x86_ops->set_nmi_mask(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    kvm_vcpu_has_lapic(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (events->smi.smm)\n\t\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_MASK;\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\t\tif (events->smi.smm_inside_nmi)\n\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\telse\n\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\tif (kvm_vcpu_has_lapic(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n",
        "output": "0",
        "index": 57772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t BnCrypto::onTransact(\n uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {\n switch (code) {\n case INIT_CHECK:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(initCheck());\n\n return OK;\n }\n\n case IS_CRYPTO_SUPPORTED:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n            reply->writeInt32(isCryptoSchemeSupported(uuid));\n\n return OK;\n }\n\n case CREATE_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n uint8_t uuid[16];\n            data.read(uuid, sizeof(uuid));\n\n size_t opaqueSize = data.readInt32();\n void *opaqueData = NULL;\n\n if (opaqueSize > 0) {\n                opaqueData = malloc(opaqueSize);\n                data.read(opaqueData, opaqueSize);\n }\n\n            reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize));\n\n if (opaqueData != NULL) {\n                free(opaqueData);\n                opaqueData = NULL;\n }\n\n return OK;\n }\n\n case DESTROY_PLUGIN:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n            reply->writeInt32(destroyPlugin());\n\n return OK;\n }\n\n case REQUIRES_SECURE_COMPONENT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n const char *mime = data.readCString();\n            reply->writeInt32(requiresSecureDecoderComponent(mime));\n\n return OK;\n }\n\n case DECRYPT:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n bool secure = data.readInt32() != 0;\n CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32();\n\n uint8_t key[16];\n            data.read(key, sizeof(key));\n\n uint8_t iv[16];\n            data.read(iv, sizeof(iv));\n\n size_t totalSize = data.readInt32();\n            sp<IMemory> sharedBuffer =\n                interface_cast<IMemory>(data.readStrongBinder());\n int32_t offset = data.readInt32();\n\n int32_t numSubSamples = data.readInt32();\n\n CryptoPlugin::SubSample *subSamples =\n new CryptoPlugin::SubSample[numSubSamples];\n\n            data.read(\n                    subSamples,\n sizeof(CryptoPlugin::SubSample) * numSubSamples);\n\n void *secureBufferId, *dstPtr;\n if (secure) {\n                secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));\n } else {\n                dstPtr = calloc(1, totalSize);\n }\n\n AString errorDetailMsg;\n ssize_t result;\n\n size_t sumSubsampleSizes = 0;\n bool overflow = false;\n for (int32_t i = 0; i < numSubSamples; ++i) {\n CryptoPlugin::SubSample &ss = subSamples[i];\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {\n                    sumSubsampleSizes += ss.mNumBytesOfEncryptedData;\n } else {\n                    overflow = true;\n }\n if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {\n                    sumSubsampleSizes += ss.mNumBytesOfClearData;\n } else {\n                    overflow = true;\n }\n }\n\n \n             if (overflow || sumSubsampleSizes != totalSize) {\n                 result = -EINVAL;\n            } else if (offset + totalSize > sharedBuffer->size()) {\n                 result = -EINVAL;\n             } else {\n                 result = decrypt(\n                    secure,\n                    key,\n                    iv,\n                    mode,\n                    sharedBuffer, offset,\n                    subSamples, numSubSamples,\n                    secure ? secureBufferId : dstPtr,\n &errorDetailMsg);\n }\n\n            reply->writeInt32(result);\n\n if (isCryptoError(result)) {\n                reply->writeCString(errorDetailMsg.c_str());\n }\n\n if (!secure) {\n if (result >= 0) {\n                    CHECK_LE(result, static_cast<ssize_t>(totalSize));\n                    reply->write(dstPtr, result);\n }\n                free(dstPtr);\n                dstPtr = NULL;\n }\n\n delete[] subSamples;\n            subSamples = NULL;\n\n return OK;\n }\n\n case NOTIFY_RESOLUTION:\n {\n            CHECK_INTERFACE(ICrypto, data, reply);\n\n int32_t width = data.readInt32();\n int32_t height = data.readInt32();\n            notifyResolution(width, height);\n\n return OK;\n }\n\n case SET_MEDIADRM_SESSION:\n {\n            CHECK_INTERFACE(IDrm, data, reply);\n Vector<uint8_t> sessionId;\n            readVector(data, sessionId);\n            reply->writeInt32(setMediaDrmSession(sessionId));\n return OK;\n }\n\n default:\n return BBinder::onTransact(code, data, reply, flags);\n }\n}\n",
        "output": "1",
        "index": 187981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dgram_sendmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t size)\n{\n\tstruct net_device *dev;\n\tunsigned int mtu;\n\tstruct sk_buff *skb;\n\tstruct dgram_sock *ro = dgram_sk(sk);\n\tint hlen, tlen;\n\tint err;\n\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tpr_debug(\"msg->msg_flags = 0x%x\\n\", msg->msg_flags);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ro->bound)\n\t\tdev = dev_getfirstbyhwtype(sock_net(sk), ARPHRD_IEEE802154);\n\telse\n\t\tdev = ieee802154_get_dev(sock_net(sk), &ro->src_addr);\n\n\tif (!dev) {\n\t\tpr_debug(\"no dev\\n\");\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\tmtu = dev->mtu;\n\tpr_debug(\"name = %s, mtu = %u\\n\", dev->name, mtu);\n\n\tif (size > mtu) {\n\t\tpr_debug(\"size = %Zu, mtu = %u\\n\", size, mtu);\n\t\terr = -EINVAL;\n\t\tgoto out_dev;\n\t}\n\n\thlen = LL_RESERVED_SPACE(dev);\n\ttlen = dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk, hlen + tlen + size,\n\t\t\tmsg->msg_flags & MSG_DONTWAIT,\n\t\t\t&err);\n\tif (!skb)\n\t\tgoto out_dev;\n\n\tskb_reserve(skb, hlen);\n\n\tskb_reset_network_header(skb);\n\n\tmac_cb(skb)->flags = IEEE802154_FC_TYPE_DATA;\n\tif (ro->want_ack)\n\t\tmac_cb(skb)->flags |= MAC_CB_FLAG_ACKREQ;\n\n\tmac_cb(skb)->seq = ieee802154_mlme_ops(dev)->get_dsn(dev);\n\terr = dev_hard_header(skb, dev, ETH_P_IEEE802154, &ro->dst_addr,\n\t\t\tro->bound ? &ro->src_addr : NULL, size);\n\tif (err < 0)\n\t\tgoto out_skb;\n\n\tskb_reset_mac_header(skb);\n\n\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\tif (err < 0)\n\t\tgoto out_skb;\n\n\tskb->dev = dev;\n\tskb->sk  = sk;\n\tskb->protocol = htons(ETH_P_IEEE802154);\n\n\tdev_put(dev);\n\n\terr = dev_queue_xmit(skb);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\n\treturn err ?: size;\n\nout_skb:\n\tkfree_skb(skb);\nout_dev:\n\tdev_put(dev);\nout:\n\treturn err;\n}\n",
        "output": "0",
        "index": 40144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "scoped_refptr<EntryImpl> BackendImpl::CreateEntryImpl(const std::string& key) {\n  if (disabled_ || key.empty())\n    return NULL;\n\n  TimeTicks start = TimeTicks::Now();\n  uint32_t hash = base::Hash(key);\n  Trace(\"Create hash 0x%x\", hash);\n\n  scoped_refptr<EntryImpl> parent;\n  Addr entry_address(data_->table[hash & mask_]);\n  if (entry_address.is_initialized()) {\n    bool error;\n    scoped_refptr<EntryImpl> old_entry =\n        MatchEntry(key, hash, false, Addr(), &error);\n    if (old_entry)\n      return ResurrectEntry(std::move(old_entry));\n\n    parent = MatchEntry(key, hash, true, Addr(), &error);\n    DCHECK(!error);\n    if (!parent && data_->table[hash & mask_]) {\n      NOTREACHED();\n      return NULL;\n    }\n  }\n\n\n  int num_blocks = EntryImpl::NumBlocksForEntry(key.size());\n  if (!block_files_.CreateBlock(BLOCK_256, num_blocks, &entry_address)) {\n    LOG(ERROR) << \"Create entry failed \" << key.c_str();\n    stats_.OnEvent(Stats::CREATE_ERROR);\n    return NULL;\n  }\n\n  Addr node_address(0);\n  if (!block_files_.CreateBlock(RANKINGS, 1, &node_address)) {\n    block_files_.DeleteBlock(entry_address, false);\n    LOG(ERROR) << \"Create entry failed \" << key.c_str();\n    stats_.OnEvent(Stats::CREATE_ERROR);\n    return NULL;\n  }\n\n  scoped_refptr<EntryImpl> cache_entry(\n      new EntryImpl(this, entry_address, false));\n  IncreaseNumRefs();\n\n  if (!cache_entry->CreateEntry(node_address, key, hash)) {\n    block_files_.DeleteBlock(entry_address, false);\n    block_files_.DeleteBlock(node_address, false);\n    LOG(ERROR) << \"Create entry failed \" << key.c_str();\n    stats_.OnEvent(Stats::CREATE_ERROR);\n    return NULL;\n  }\n\n  cache_entry->BeginLogging(net_log_, true);\n\n  open_entries_[entry_address.value()] = cache_entry.get();\n\n  cache_entry->entry()->Store();\n  cache_entry->rankings()->Store();\n  IncreaseNumEntries();\n  entry_count_++;\n\n  if (parent.get()) {\n    parent->SetNextAddress(entry_address);\n  } else {\n    data_->table[hash & mask_] = entry_address.value();\n  }\n\n  eviction_.OnCreateEntry(cache_entry.get());\n\n  CACHE_UMA(AGE_MS, \"CreateTime\", 0, start);\n  stats_.OnEvent(Stats::CREATE_HIT);\n  Trace(\"create entry hit \");\n  FlushIndex();\n  return cache_entry;\n}\n",
        "output": "0",
        "index": 160015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_tags_recursive(const u8 * buf0, const u8 * buf,\n\t\t\t\t size_t buflen, size_t depth)\n{\n\tint r;\n\tsize_t i;\n\tsize_t bytesleft = buflen;\n\tconst char *classes[4] = {\n\t\t\"Universal\",\n\t\t\"Application\",\n\t\t\"Context\",\n\t\t\"Private\"\n\t};\n\tconst u8 *p = buf;\n\n\twhile (bytesleft >= 2) {\n\t\tunsigned int cla = 0, tag = 0, hlen;\n\t\tconst u8 *tagp = p;\n\t\tsize_t len;\n\n\t\tr = sc_asn1_read_tag(&tagp, bytesleft, &cla, &tag, &len);\n\t\tif (r != SC_SUCCESS || tagp == NULL) {\n\t\t\tprintf(\"Error in decoding.\\n\");\n\t\t\treturn;\n\t\t}\n\t\thlen = tagp - p;\n\t\tif (cla == 0 && tag == 0) {\n\t\t\tprintf(\"Zero tag, finishing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tprint_indent(depth);\n\t\t/* let i be the length of the tag in bytes */\n\t\tfor (i = 1; i < sizeof tag - 1; i++) {\n\t\t\tif (!(tag >> 8*i))\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%02X\", cla<<(i-1)*8 | tag);\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_UNIVERSAL) {\n\t\t\tprintf(\" %s\", tag2str(tag));\n\t\t} else {\n\t\t\tprintf(\" %s %-2u\",\n\t\t\t\t\tclasses[cla >> 6],\n\t\t\t\t\ti == 1 ? tag & SC_ASN1_TAG_PRIMITIVE : tag & (((unsigned int) ~0) >> (i + 1) * 8));\n\t\t}\n\t\tif (!((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_UNIVERSAL\n\t\t\t\t\t&& tag == SC_ASN1_TAG_NULL && len == 0)) {\n\t\t\tprintf(\" (%\"SC_FORMAT_LEN_SIZE_T\"u byte%s)\",\n\t\t\t\t\tlen,\n\t\t\t\t\tlen != 1 ? \"s\" : \"\");\n\t\t}\n\n\t\tif (len + hlen > bytesleft) {\n\t\t\tprintf(\" Illegal length!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tp += hlen + len;\n\t\tbytesleft -= hlen + len;\n\n\t\tif (cla & SC_ASN1_TAG_CONSTRUCTED) {\n\t\t\tputchar('\\n');\n\t\t\tprint_tags_recursive(buf0, tagp, len, depth + 2*i + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag) {\n\t\t\tcase SC_ASN1_TAG_BIT_STRING:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_bit_string(tagp, len, depth + 2*i + 1);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_OCTET_STRING:\n\t\t\t\tsc_asn1_print_octet_string(tagp, len, depth + 2*i + 1);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_OBJECT:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_object_id(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_INTEGER:\n\t\t\tcase SC_ASN1_TAG_ENUMERATED:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_integer(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_IA5STRING:\n\t\t\tcase SC_ASN1_TAG_PRINTABLESTRING:\n\t\t\tcase SC_ASN1_TAG_T61STRING:\n\t\t\tcase SC_ASN1_TAG_UTF8STRING:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_utf8string(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_TAG_BOOLEAN:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_boolean(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_GENERALIZEDTIME:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_generalizedtime(tagp, len);\n\t\t\t\tbreak;\n\t\t\tcase SC_ASN1_UTCTIME:\n\t\t\t\tprintf(\": \");\n\t\t\t\tsc_asn1_print_utctime(tagp, len);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_APPLICATION) {\n\t\t\tprint_hex(tagp, len, depth + 2*i + 1);\n\t\t}\n\n\t\tif ((cla & SC_ASN1_TAG_CLASS) == SC_ASN1_TAG_CONTEXT) {\n\t\t\tprint_hex(tagp, len, depth + 2*i + 1);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n}\n",
        "output": "0",
        "index": 78120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GPMF_ERR GPMF_Validate(GPMF_stream *ms, GPMF_LEVELS recurse)\n{\n\tif (ms)\n\t{\n\t\tuint32_t currpos = ms->pos;\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\t\t\n\t\twhile (ms->pos+1 < ms->buffer_size_longs && nestsize > 0)\n\t\t{\n\t\t\tuint32_t key = ms->buffer[ms->pos];\n\n\t\t\tif (ms->nest_level == 0 && key != GPMF_KEY_DEVICE && ms->device_count == 0 && ms->pos == 0)\n\t\t\t{\n\t\t\t\tDBG_MSG(\"ERROR: uninitized -- GPMF_ERROR_BAD_STRUCTURE\\n\");\n\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t}\n\n\t\t\tif (GPMF_VALID_FOURCC(key))\n\t\t\t{\n\t\t\t\tuint32_t type_size_repeat = ms->buffer[ms->pos + 1];\n\t\t\t\tint32_t size = GPMF_DATA_SIZE(type_size_repeat) >> 2;\n\t\t\t\tuint8_t type = GPMF_SAMPLE_TYPE(type_size_repeat);\n\t\t\t\tif (size + 2 > nestsize)\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: nest size too small within %c%c%c%c-- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\tif (!GPMF_VALID_FOURCC(key))\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: invalid 4CC -- GPMF_ERROR_BAD_STRUCTURE\\n\");\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\tif (type == GPMF_TYPE_NEST && recurse == GPMF_RECURSE_LEVELS)\n\t\t\t\t{\n\t\t\t\t\tuint32_t validnest;\n\t\t\t\t\tms->pos += 2;\n\t\t\t\t\tms->nest_level++;\n\t\t\t\t\tif (ms->nest_level > GPMF_NEST_LIMIT)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_MSG(\"ERROR: nest level within %c%c%c%c too deep -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t\t}\n\t\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\t\tvalidnest = GPMF_Validate(ms, recurse);\n\t\t\t\t\tms->nest_level--;\n\t\t\t\t\tif (GPMF_OK != validnest)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_MSG(\"ERROR: invalid nest within %c%c%c%c -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ms->nest_level == 0)\n\t\t\t\t\t\t\tms->device_count++;\n\t\t\t\t\t}\n\n\t\t\t\t\tms->pos += size;\n\t\t\t\t\tnestsize -= 2 + size;\n\n\t\t\t\t\twhile (ms->pos < ms->buffer_size_longs && nestsize > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos++;\n\t\t\t\t\t\tnestsize--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tms->pos += 2 + size;\n\t\t\t\t\tnestsize -= 2 + size;\n\t\t\t\t}\n\n\t\t\t\tif (ms->pos == ms->buffer_size_longs)\n\t\t\t\t{\n\t\t\t\t\tms->pos = currpos;\n\t\t\t\t\treturn GPMF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (key == GPMF_KEY_END)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos++;\n\t\t\t\t\t\tnestsize--;\n\t\t\t\t\t} while (ms->pos < ms->buffer_size_longs && nestsize > 0 && ms->buffer[ms->pos] == 0);\n\t\t\t\t}\n\t\t\t\telse if (ms->nest_level == 0 && ms->device_count > 0)\n\t\t\t\t{\n\t\t\t\t\tms->pos = currpos;\n\t\t\t\t\treturn GPMF_OK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: bad struct within %c%c%c%c -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tms->pos = currpos;\n\t\treturn GPMF_OK;\n\t}\n\telse\n\t{\n\t\tDBG_MSG(\"ERROR: Invalid handle -- GPMF_ERROR_MEMORY\\n\");\n\t\treturn GPMF_ERROR_MEMORY;\n\t}\n}\n",
        "output": "0",
        "index": 88454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "poppler_page_get_link_mapping (PopplerPage *page)\n{\n  GList *map_list = NULL;\n  gint i;\n  Links *links;\n  Object obj;\n  double width, height;\n  \n  g_return_val_if_fail (POPPLER_IS_PAGE (page), NULL);\n  \n  links = new Links (page->page->getAnnots (&obj),\n\t\t     page->document->doc->getCatalog ()->getBaseURI ());\n  obj.free ();\n  \n  if (links == NULL)\n    return NULL;\n  \n  poppler_page_get_size (page, &width, &height);\n  \n  for (i = 0; i < links->getNumLinks (); i++)\n    {\n      PopplerLinkMapping *mapping;\n      PopplerRectangle rect;\n      LinkAction *link_action;\n      Link *link;\n      \n      link = links->getLink (i);\n      link_action = link->getAction ();\n      \n      /* Create the mapping */\n      mapping = g_new (PopplerLinkMapping, 1);\n      mapping->action = _poppler_action_new (page->document, link_action, NULL);\n      \n      link->getRect (&rect.x1, &rect.y1, &rect.x2, &rect.y2);\n      \n      switch (page->page->getRotate ())\n        {\n        case 90:\n\t  mapping->area.x1 = rect.y1;\n\t  mapping->area.y1 = height - rect.x2;\n\t  mapping->area.x2 = mapping->area.x1 + (rect.y2 - rect.y1);\n\t  mapping->area.y2 = mapping->area.y1 + (rect.x2 - rect.x1);\n\t  \n\t  break;\n\tcase 180:\n\t  mapping->area.x1 = width - rect.x2;\n\t  mapping->area.y1 = height - rect.y2;\n\t  mapping->area.x2 = mapping->area.x1 + (rect.x2 - rect.x1);\n\t  mapping->area.y2 = mapping->area.y1 + (rect.y2 - rect.y1);\n\t  \n\t  break;\n\tcase 270:\n\t  mapping->area.x1 = width - rect.y2;\n\t  mapping->area.y1 = rect.x1;\n\t  mapping->area.x2 = mapping->area.x1 + (rect.y2 - rect.y1);\n\t  mapping->area.y2 = mapping->area.y1 + (rect.x2 - rect.x1);\n\t  \n\t  break;\n\tdefault:\n\t  mapping->area.x1 = rect.x1;\n\t  mapping->area.y1 = rect.y1;\n\t  mapping->area.x2 = rect.x2;\n\t  mapping->area.y2 = rect.y2;\n\t}\n\t\t\t\n      mapping->area.x1 -= page->page->getCropBox()->x1;\n      mapping->area.x2 -= page->page->getCropBox()->x1;\n      mapping->area.y1 -= page->page->getCropBox()->y1;\n      mapping->area.y2 -= page->page->getCropBox()->y1;\n      \n      map_list = g_list_prepend (map_list, mapping);\n    }\n  \n  delete links;\n  \n  return map_list;\n}\n",
        "output": "0",
        "index": 785
    }
]